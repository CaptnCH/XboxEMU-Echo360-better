#include "C:\Users\xdfah\Downloads\recompiler\Echo-360\Echo-360 0.0.1\../../dev/src/xenon_launcher/xenonCPU.h"

//////////////////////////////////////////////////////
// Block at 82060000h
// Function '?XMMatrixInverse@@YA?AU_XMMATRIX@@PAU__vector4@@U1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82060000( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82060000) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82060000);
		  /* 82060000h */ case    0:  		/* std R5, <#[R1 + 32]> */
		/* 82060000h case    0:*/		cpu::mem::store64( regs, regs.R5, (uint32)(regs.R1 + 0x00000020) );
		/* 82060000h case    0:*/		return 0x82060004;
		  /* 82060004h */ case    1:  		/* addi R11, R1, 32 */
		/* 82060004h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x20);
		/* 82060004h case    1:*/		return 0x82060008;
		  /* 82060008h */ case    2:  		/* std R7, <#[R1 + 48]> */
		/* 82060008h case    2:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R1 + 0x00000030) );
		/* 82060008h case    2:*/		return 0x8206000C;
		  /* 8206000Ch */ case    3:  		/* vspltisw VR63, 31 */
		/* 8206000Ch case    3:*/		cpu::op::vspltisw<0,31>(regs,&regs.VR63);
		/* 8206000Ch case    3:*/		return 0x82060010;
		  /* 82060010h */ case    4:  		/* std R8, <#[R1 + 56]> */
		/* 82060010h case    4:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R1 + 0x00000038) );
		/* 82060010h case    4:*/		return 0x82060014;
		  /* 82060014h */ case    5:  		/* addi R8, R1, 80 */
		/* 82060014h case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x50);
		/* 82060014h case    5:*/		return 0x82060018;
		  /* 82060018h */ case    6:  		/* std R9, <#[R1 + 64]> */
		/* 82060018h case    6:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000040) );
		/* 82060018h case    6:*/		return 0x8206001C;
		  /* 8206001Ch */ case    7:  		/* addi R9, R1, 48 */
		/* 8206001Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x30);
		/* 8206001Ch case    7:*/		return 0x82060020;
		  /* 82060020h */ case    8:  		/* std R10, <#[R1 + 72]> */
		/* 82060020h case    8:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000048) );
		/* 82060020h case    8:*/		return 0x82060024;
		  /* 82060024h */ case    9:  		/* addi R10, R1, 64 */
		/* 82060024h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x40);
		/* 82060024h case    9:*/		return 0x82060028;
		  /* 82060028h */ case   10:  		/* std R6, <#[R1 + 40]> */
		/* 82060028h case   10:*/		cpu::mem::store64( regs, regs.R6, (uint32)(regs.R1 + 0x00000028) );
		/* 82060028h case   10:*/		return 0x8206002C;
		  /* 8206002Ch */ case   11:  		/* vslw VR58, VR63, VR63 */
		/* 8206002Ch case   11:*/		cpu::op::vslw<0>(regs,&regs.VR58,regs.VR63,regs.VR63);
		/* 8206002Ch case   11:*/		return 0x82060030;
		  /* 82060030h */ case   12:  		/* lvx VR63, <#[R11]> */
		/* 82060030h case   12:*/		cpu::mem::lvx( regs, &regs.VR63, (uint32)(regs.R11 + 0x00000000) );
		/* 82060030h case   12:*/		return 0x82060034;
		  /* 82060034h */ case   13:  		/* vspltisw VR59, 0 */
		/* 82060034h case   13:*/		cpu::op::vspltisw<0,0>(regs,&regs.VR59);
		/* 82060034h case   13:*/		return 0x82060038;
		  /* 82060038h */ case   14:  		/* lvx VR60, <#[R8]> */
		/* 82060038h case   14:*/		cpu::mem::lvx( regs, &regs.VR60, (uint32)(regs.R8 + 0x00000000) );
		/* 82060038h case   14:*/		return 0x8206003C;
		  /* 8206003Ch */ case   15:  		/* lvx VR61, <#[R9]> */
		/* 8206003Ch case   15:*/		cpu::mem::lvx( regs, &regs.VR61, (uint32)(regs.R9 + 0x00000000) );
		/* 8206003Ch case   15:*/		return 0x82060040;
		  /* 82060040h */ case   16:  		/* lvx VR62, <#[R10]> */
		/* 82060040h case   16:*/		cpu::mem::lvx( regs, &regs.VR62, (uint32)(regs.R10 + 0x00000000) );
		/* 82060040h case   16:*/		return 0x82060044;
		  /* 82060044h */ case   17:  		/* vmrghw VR56, VR63, VR62 */
		/* 82060044h case   17:*/		cpu::op::vmrghw<0>(regs,&regs.VR56,regs.VR63,regs.VR62);
		/* 82060044h case   17:*/		return 0x82060048;
		  /* 82060048h */ case   18:  		/* vmrglw VR63, VR63, VR62 */
		/* 82060048h case   18:*/		cpu::op::vmrglw<0>(regs,&regs.VR63,regs.VR63,regs.VR62);
		/* 82060048h case   18:*/		return 0x8206004C;
		  /* 8206004Ch */ case   19:  		/* mr VR13, VR56 */
		/* 8206004Ch case   19:*/		regs.VR13 = regs.VR56;
		/* 8206004Ch case   19:*/		return 0x82060050;
		  /* 82060050h */ case   20:  		/* vmrghw VR62, VR61, VR60 */
		/* 82060050h case   20:*/		cpu::op::vmrghw<0>(regs,&regs.VR62,regs.VR61,regs.VR60);
		/* 82060050h case   20:*/		return 0x82060054;
		  /* 82060054h */ case   21:  		/* vmrglw VR61, VR61, VR60 */
		/* 82060054h case   21:*/		cpu::op::vmrglw<0>(regs,&regs.VR61,regs.VR61,regs.VR60);
		/* 82060054h case   21:*/		return 0x82060058;
		  /* 82060058h */ case   22:  		/* vmrghw VR60, VR59, VR58 */
		/* 82060058h case   22:*/		cpu::op::vmrghw<0>(regs,&regs.VR60,regs.VR59,regs.VR58);
		/* 82060058h case   22:*/		return 0x8206005C;
		  /* 8206005Ch */ case   23:  		/* vupkd3d128 VR57, VR59, 1 */
		/* 8206005Ch case   23:*/		cpu::op::vupkd3d128<0,1>(regs,&regs.VR57,regs.VR59);
		/* 8206005Ch case   23:*/		return 0x82060060;
		  /* 82060060h */ case   24:  		/* mr VR55, VR63 */
		/* 82060060h case   24:*/		regs.VR55 = regs.VR63;
		/* 82060060h case   24:*/		return 0x82060064;
		  /* 82060064h */ case   25:  		/* mr VR54, VR62 */
		/* 82060064h case   25:*/		regs.VR54 = regs.VR62;
		/* 82060064h case   25:*/		return 0x82060068;
		  /* 82060068h */ case   26:  		/* vmrghw VR59, VR58, VR59 */
		/* 82060068h case   26:*/		cpu::op::vmrghw<0>(regs,&regs.VR59,regs.VR58,regs.VR59);
		/* 82060068h case   26:*/		return 0x8206006C;
		  /* 8206006Ch */ case   27:  		/* vmrglw VR58, VR56, VR62 */
		/* 8206006Ch case   27:*/		cpu::op::vmrglw<0>(regs,&regs.VR58,regs.VR56,regs.VR62);
		/* 8206006Ch case   27:*/		return 0x82060070;
		  /* 82060070h */ case   28:  		/* vrlimi128 VR13, VR63, 12, 2 */
		/* 82060070h case   28:*/		cpu::op::vrlimi128<0,12,2>(regs,&regs.VR13,regs.VR63);
		/* 82060070h case   28:*/		return 0x82060074;
		  /* 82060074h */ case   29:  		/* vmrghw VR53, VR56, VR62 */
		/* 82060074h case   29:*/		cpu::op::vmrghw<0>(regs,&regs.VR53,regs.VR56,regs.VR62);
		/* 82060074h case   29:*/		return 0x82060078;
		  /* 82060078h */ case   30:  		/* mr VR0, VR61 */
		/* 82060078h case   30:*/		regs.VR0 = regs.VR61;
		/* 82060078h case   30:*/		return 0x8206007C;
		  /* 8206007Ch */ case   31:  		/* vmrghw VR52, VR63, VR61 */
		/* 8206007Ch case   31:*/		cpu::op::vmrghw<0>(regs,&regs.VR52,regs.VR63,regs.VR61);
		/* 8206007Ch case   31:*/		return 0x82060080;
		  /* 82060080h */ case   32:  		/* vrlimi128 VR55, VR56, 3, 2 */
		/* 82060080h case   32:*/		cpu::op::vrlimi128<0,3,2>(regs,&regs.VR55,regs.VR56);
		/* 82060080h case   32:*/		return 0x82060084;
		  /* 82060084h */ case   33:  		/* vmrglw VR63, VR63, VR61 */
		/* 82060084h case   33:*/		cpu::op::vmrglw<0>(regs,&regs.VR63,regs.VR63,regs.VR61);
		/* 82060084h case   33:*/		return 0x82060088;
		  /* 82060088h */ case   34:  		/* vrlimi128 VR54, VR61, 12, 2 */
		/* 82060088h case   34:*/		cpu::op::vrlimi128<0,12,2>(regs,&regs.VR54,regs.VR61);
		/* 82060088h case   34:*/		return 0x8206008C;
		  /* 8206008Ch */ case   35:  		/* vpermwi128 VR56, VR58, 187 */
		/* 8206008Ch case   35:*/		cpu::op::vpermwi128<0,187>(regs,&regs.VR56,regs.VR58);
		/* 8206008Ch case   35:*/		return 0x82060090;
		  /* 82060090h */ case   36:  		/* vpermwi128 VR61, VR53, 5 */
		/* 82060090h case   36:*/		cpu::op::vpermwi128<0,5>(regs,&regs.VR61,regs.VR53);
		/* 82060090h case   36:*/		return 0x82060094;
		  /* 82060094h */ case   37:  		/* vrlimi128 VR0, VR62, 3, 2 */
		/* 82060094h case   37:*/		cpu::op::vrlimi128<0,3,2>(regs,&regs.VR0,regs.VR62);
		/* 82060094h case   37:*/		return 0x82060098;
		  /* 82060098h */ case   38:  		/* vpermwi128 VR62, VR52, 5 */
		/* 82060098h case   38:*/		cpu::op::vpermwi128<0,5>(regs,&regs.VR62,regs.VR52);
		/* 82060098h case   38:*/		return 0x8206009C;
		  /* 8206009Ch */ case   39:  		/* vpermwi128 VR51, VR63, 187 */
		/* 8206009Ch case   39:*/		cpu::op::vpermwi128<0,187>(regs,&regs.VR51,regs.VR63);
		/* 8206009Ch case   39:*/		return 0x820600A0;
		  /* 820600A0h */ case   40:  		/* vmulfp128 VR4, VR55, VR54 */
		/* 820600A0h case   40:*/		cpu::op::vmulfp128<0>(regs,&regs.VR4,regs.VR55,regs.VR54);
		/* 820600A0h case   40:*/		return 0x820600A4;
		  /* 820600A4h */ case   41:  		/* vpermwi128 VR11, VR58, 5 */
		/* 820600A4h case   41:*/		cpu::op::vpermwi128<0,5>(regs,&regs.VR11,regs.VR58);
		/* 820600A4h case   41:*/		return 0x820600A8;
		  /* 820600A8h */ case   42:  		/* vmulfp128 VR5, VR61, VR56 */
		/* 820600A8h case   42:*/		cpu::op::vmulfp128<0>(regs,&regs.VR5,regs.VR61,regs.VR56);
		/* 820600A8h case   42:*/		return 0x820600AC;
		  /* 820600ACh */ case   43:  		/* vpermwi128 VR12, VR53, 187 */
		/* 820600ACh case   43:*/		cpu::op::vpermwi128<0,187>(regs,&regs.VR12,regs.VR53);
		/* 820600ACh case   43:*/		return 0x820600B0;
		  /* 820600B0h */ case   44:  		/* vpermwi128 VR10, VR52, 187 */
		/* 820600B0h case   44:*/		cpu::op::vpermwi128<0,187>(regs,&regs.VR10,regs.VR52);
		/* 820600B0h case   44:*/		return 0x820600B4;
		  /* 820600B4h */ case   45:  		/* vmulfp128 VR3, VR62, VR51 */
		/* 820600B4h case   45:*/		cpu::op::vmulfp128<0>(regs,&regs.VR3,regs.VR62,regs.VR51);
		/* 820600B4h case   45:*/		return 0x820600B8;
		  /* 820600B8h */ case   46:  		/* vpermwi128 VR9, VR63, 5 */
		/* 820600B8h case   46:*/		cpu::op::vpermwi128<0,5>(regs,&regs.VR9,regs.VR63);
		/* 820600B8h case   46:*/		return 0x820600BC;
		  /* 820600BCh */ case   47:  		/* vpermwi128 VR55, VR58, 97 */
		/* 820600BCh case   47:*/		cpu::op::vpermwi128<0,97>(regs,&regs.VR55,regs.VR58);
		/* 820600BCh case   47:*/		return 0x820600C0;
		  /* 820600C0h */ case   48:  		/* vpermwi128 VR8, VR58, 182 */
		/* 820600C0h case   48:*/		cpu::op::vpermwi128<0,182>(regs,&regs.VR8,regs.VR58);
		/* 820600C0h case   48:*/		return 0x820600C4;
		  /* 820600C4h */ case   49:  		/* vpermwi128 VR62, VR63, 97 */
		/* 820600C4h case   49:*/		cpu::op::vpermwi128<0,97>(regs,&regs.VR62,regs.VR63);
		/* 820600C4h case   49:*/		return 0x820600C8;
		  /* 820600C8h */ case   50:  		/* vpermwi128 VR61, VR52, 132 */
		/* 820600C8h case   50:*/		cpu::op::vpermwi128<0,132>(regs,&regs.VR61,regs.VR52);
		/* 820600C8h case   50:*/		return 0x820600CC;
		  /* 820600CCh */ case   51:  		/* vpermwi128 VR56, VR53, 132 */
		/* 820600CCh case   51:*/		cpu::op::vpermwi128<0,132>(regs,&regs.VR56,regs.VR53);
		/* 820600CCh case   51:*/		return 0x820600D0;
		  /* 820600D0h */ case   52:  		/* vpermwi128 VR7, VR53, 237 */
		/* 820600D0h case   52:*/		cpu::op::vpermwi128<0,237>(regs,&regs.VR7,regs.VR53);
		/* 820600D0h case   52:*/		return 0x820600D4;
		  /* 820600D4h */ case   53:  		/* vpermwi128 VR6, VR63, 182 */
		/* 820600D4h case   53:*/		cpu::op::vpermwi128<0,182>(regs,&regs.VR6,regs.VR63);
		/* 820600D4h case   53:*/		return 0x820600D8;
		  /* 820600D8h */ case   54:  		/* vpermwi128 VR58, VR58, 204 */
		/* 820600D8h case   54:*/		cpu::op::vpermwi128<0,204>(regs,&regs.VR58,regs.VR58);
		/* 820600D8h case   54:*/		return 0x820600DC;
		  /* 820600DCh */ case   55:  		/* vnmsubfp VR2, VR12, VR11, VR5 */
		/* 820600DCh case   55:*/		cpu::op::vnmsubfp<0>(regs,&regs.VR2,regs.VR12,regs.VR11,regs.VR5);
		/* 820600DCh case   55:*/		return 0x820600E0;
		  /* 820600E0h */ case   56:  		/* vpermwi128 VR5, VR52, 237 */
		/* 820600E0h case   56:*/		cpu::op::vpermwi128<0,237>(regs,&regs.VR5,regs.VR52);
		/* 820600E0h case   56:*/		return 0x820600E4;
		  /* 820600E4h */ case   57:  		/* vnmsubfp VR12, VR0, VR13, VR4 */
		/* 820600E4h case   57:*/		cpu::op::vnmsubfp<0>(regs,&regs.VR12,regs.VR0,regs.VR13,regs.VR4);
		/* 820600E4h case   57:*/		return 0x820600E8;
		  /* 820600E8h */ case   58:  		/* vnmsubfp VR0, VR10, VR9, VR3 */
		/* 820600E8h case   58:*/		cpu::op::vnmsubfp<0>(regs,&regs.VR0,regs.VR10,regs.VR9,regs.VR3);
		/* 820600E8h case   58:*/		return 0x820600EC;
		  /* 820600ECh */ case   59:  		/* mr VR54, VR2 */
		/* 820600ECh case   59:*/		regs.VR54 = regs.VR2;
		/* 820600ECh case   59:*/		return 0x820600F0;
		  /* 820600F0h */ case   60:  		/* mr VR51, VR12 */
		/* 820600F0h case   60:*/		regs.VR51 = regs.VR12;
		/* 820600F0h case   60:*/		return 0x820600F4;
		  /* 820600F4h */ case   61:  		/* mr VR50, VR0 */
		/* 820600F4h case   61:*/		regs.VR50 = regs.VR0;
		/* 820600F4h case   61:*/		return 0x820600F8;
		  /* 820600F8h */ case   62:  		/* vpermwi128 VR12, VR54, 198 */
		/* 820600F8h case   62:*/		cpu::op::vpermwi128<0,198>(regs,&regs.VR12,regs.VR54);
		/* 820600F8h case   62:*/		return 0x820600FC;
		  /* 820600FCh */ case   63:  		/* vpermwi128 VR11, VR54, 156 */
		/* 820600FCh case   63:*/		cpu::op::vpermwi128<0,156>(regs,&regs.VR11,regs.VR54);
		/* 820600FCh case   63:*/		return 0x82060100;
		  /* 82060100h */ case   64:  		/* vpermwi128 VR13, VR50, 156 */
		/* 82060100h case   64:*/		cpu::op::vpermwi128<0,156>(regs,&regs.VR13,regs.VR50);
		/* 82060100h case   64:*/		return 0x82060104;
		  /* 82060104h */ case   65:  		/* vpermwi128 VR0, VR50, 198 */
		/* 82060104h case   65:*/		cpu::op::vpermwi128<0,198>(regs,&regs.VR0,regs.VR50);
		/* 82060104h case   65:*/		return 0x82060108;
		  /* 82060108h */ case   66:  		/* mr VR49, VR12 */
		/* 82060108h case   66:*/		regs.VR49 = regs.VR12;
		/* 82060108h case   66:*/		return 0x8206010C;
		  /* 8206010Ch */ case   67:  		/* mr VR48, VR11 */
		/* 8206010Ch case   67:*/		regs.VR48 = regs.VR11;
		/* 8206010Ch case   67:*/		return 0x82060110;
		  /* 82060110h */ case   68:  		/* mr VR47, VR13 */
		/* 82060110h case   68:*/		regs.VR47 = regs.VR13;
		/* 82060110h case   68:*/		return 0x82060114;
		  /* 82060114h */ case   69:  		/* mr VR46, VR0 */
		/* 82060114h case   69:*/		regs.VR46 = regs.VR0;
		/* 82060114h case   69:*/		return 0x82060118;
		  /* 82060118h */ case   70:  		/* vrlimi128 VR49, VR51, 4, 2 */
		/* 82060118h case   70:*/		cpu::op::vrlimi128<0,4,2>(regs,&regs.VR49,regs.VR51);
		/* 82060118h case   70:*/		return 0x8206011C;
		  /* 8206011Ch */ case   71:  		/* vrlimi128 VR48, VR51, 8, 3 */
		/* 8206011Ch case   71:*/		cpu::op::vrlimi128<0,8,3>(regs,&regs.VR48,regs.VR51);
		/* 8206011Ch case   71:*/		return 0x82060120;
		  /* 82060120h */ case   72:  		/* vrlimi128 VR47, VR51, 8, 1 */
		/* 82060120h case   72:*/		cpu::op::vrlimi128<0,8,1>(regs,&regs.VR47,regs.VR51);
		/* 82060120h case   72:*/		return 0x82060124;
		  /* 82060124h */ case   73:  		/* vrlimi128 VR46, VR51, 4, 0 */
		/* 82060124h case   73:*/		cpu::op::vrlimi128<0,4,0>(regs,&regs.VR46,regs.VR51);
		/* 82060124h case   73:*/		return 0x82060128;
		  /* 82060128h */ case   74:  		/* vrlimi128 VR0, VR51, 1, 1 */
		/* 82060128h case   74:*/		cpu::op::vrlimi128<0,1,1>(regs,&regs.VR0,regs.VR51);
		/* 82060128h case   74:*/		return 0x8206012C;
		  /* 8206012Ch */ case   75:  		/* vmulfp128 VR3, VR61, VR49 */
		/* 8206012Ch case   75:*/		cpu::op::vmulfp128<0>(regs,&regs.VR3,regs.VR61,regs.VR49);
		/* 8206012Ch case   75:*/		return 0x82060130;
		  /* 82060130h */ case   76:  		/* vmulfp128 VR4, VR62, VR48 */
		/* 82060130h case   76:*/		cpu::op::vmulfp128<0>(regs,&regs.VR4,regs.VR62,regs.VR48);
		/* 82060130h case   76:*/		return 0x82060134;
		  /* 82060134h */ case   77:  		/* vrlimi128 VR13, VR51, 2, 2 */
		/* 82060134h case   77:*/		cpu::op::vrlimi128<0,2,2>(regs,&regs.VR13,regs.VR51);
		/* 82060134h case   77:*/		return 0x82060138;
		  /* 82060138h */ case   78:  		/* vmulfp128 VR2, VR55, VR47 */
		/* 82060138h case   78:*/		cpu::op::vmulfp128<0>(regs,&regs.VR2,regs.VR55,regs.VR47);
		/* 82060138h case   78:*/		return 0x8206013C;
		  /* 8206013Ch */ case   79:  		/* vmulfp128 VR1, VR56, VR46 */
		/* 8206013Ch case   79:*/		cpu::op::vmulfp128<0>(regs,&regs.VR1,regs.VR56,regs.VR46);
		/* 8206013Ch case   79:*/		return 0x82060140;
		  /* 82060140h */ case   80:  		/* vnmsubfp VR31, VR8, VR0, VR2 */
		/* 82060140h case   80:*/		cpu::op::vnmsubfp<0>(regs,&regs.VR31,regs.VR8,regs.VR0,regs.VR2);
		/* 82060140h case   80:*/		return 0x82060144;
		  /* 82060144h */ case   81:  		/* vsldoi VR62, VR50, VR51, 8 */
		/* 82060144h case   81:*/		cpu::op::vsldoi<0,8>(regs,&regs.VR62,regs.VR50,regs.VR51);
		/* 82060144h case   81:*/		return 0x82060148;
		  /* 82060148h */ case   82:  		/* vxor VR2, VR58, VR60 */
		/* 82060148h case   82:*/		cpu::op::vxor<0>(regs,&regs.VR2,regs.VR58,regs.VR60);
		/* 82060148h case   82:*/		return 0x8206014C;
		  /* 8206014Ch */ case   83:  		/* vrlimi128 VR12, VR51, 1, 3 */
		/* 8206014Ch case   83:*/		cpu::op::vrlimi128<0,1,3>(regs,&regs.VR12,regs.VR51);
		/* 8206014Ch case   83:*/		return 0x82060150;
		  /* 82060150h */ case   84:  		/* vpermwi128 VR63, VR63, 204 */
		/* 82060150h case   84:*/		cpu::op::vpermwi128<0,204>(regs,&regs.VR63,regs.VR63);
		/* 82060150h case   84:*/		return 0x82060154;
		  /* 82060154h */ case   85:  		/* vrlimi128 VR11, VR51, 2, 0 */
		/* 82060154h case   85:*/		cpu::op::vrlimi128<0,2,0>(regs,&regs.VR11,regs.VR51);
		/* 82060154h case   85:*/		return 0x82060158;
		  /* 82060158h */ case   86:  		/* vpermwi128 VR61, VR52, 114 */
		/* 82060158h case   86:*/		cpu::op::vpermwi128<0,114>(regs,&regs.VR61,regs.VR52);
		/* 82060158h case   86:*/		return 0x8206015C;
		  /* 8206015Ch */ case   87:  		/* vpermwi128 VR0, VR54, 78 */
		/* 8206015Ch case   87:*/		cpu::op::vpermwi128<0,78>(regs,&regs.VR0,regs.VR54);
		/* 8206015Ch case   87:*/		return 0x82060160;
		  /* 82060160h */ case   88:  		/* vnmsubfp VR1, VR7, VR13, VR1 */
		/* 82060160h case   88:*/		cpu::op::vnmsubfp<0>(regs,&regs.VR1,regs.VR7,regs.VR13,regs.VR1);
		/* 82060160h case   88:*/		return 0x82060164;
		  /* 82060164h */ case   89:  		/* vpermwi128 VR8, VR62, 56 */
		/* 82060164h case   89:*/		cpu::op::vpermwi128<0,56>(regs,&regs.VR8,regs.VR62);
		/* 82060164h case   89:*/		return 0x82060168;
		  /* 82060168h */ case   90:  		/* li R11, 16 */
		/* 82060168h case   90:*/		cpu::op::li<0>(regs,&regs.R11,0x10);
		/* 82060168h case   90:*/		return 0x8206016C;
		  /* 8206016Ch */ case   91:  		/* vnmsubfp VR4, VR6, VR12, VR4 */
		/* 8206016Ch case   91:*/		cpu::op::vnmsubfp<0>(regs,&regs.VR4,regs.VR6,regs.VR12,regs.VR4);
		/* 8206016Ch case   91:*/		return 0x82060170;
		  /* 82060170h */ case   92:  		/* vxor VR12, VR63, VR60 */
		/* 82060170h case   92:*/		cpu::op::vxor<0>(regs,&regs.VR12,regs.VR63,regs.VR60);
		/* 82060170h case   92:*/		return 0x82060174;
		  /* 82060174h */ case   93:  		/* vnmsubfp VR6, VR5, VR11, VR3 */
		/* 82060174h case   93:*/		cpu::op::vnmsubfp<0>(regs,&regs.VR6,regs.VR5,regs.VR11,regs.VR3);
		/* 82060174h case   93:*/		return 0x82060178;
		  /* 82060178h */ case   94:  		/* vxor VR11, VR61, VR59 */
		/* 82060178h case   94:*/		cpu::op::vxor<0>(regs,&regs.VR11,regs.VR61,regs.VR59);
		/* 82060178h case   94:*/		return 0x8206017C;
		  /* 8206017Ch */ case   95:  		/* vrlimi128 VR0, VR51, 9, 3 */
		/* 8206017Ch case   95:*/		cpu::op::vrlimi128<0,9,3>(regs,&regs.VR0,regs.VR51);
		/* 8206017Ch case   95:*/		return 0x82060180;
		  /* 82060180h */ case   96:  		/* vspltw VR9, VR57, 3 */
		/* 82060180h case   96:*/		cpu::op::vspltw<0,3>(regs,&regs.VR9,regs.VR57);
		/* 82060180h case   96:*/		return 0x82060184;
		  /* 82060184h */ case   97:  		/* vmaddfp VR8, VR2, VR8, VR31 */
		/* 82060184h case   97:*/		cpu::op::vmaddfp<0>(regs,&regs.VR8,regs.VR2,regs.VR8,regs.VR31);
		/* 82060184h case   97:*/		return 0x82060188;
		  /* 82060188h */ case   98:  		/* vpermwi128 VR62, VR53, 114 */
		/* 82060188h case   98:*/		cpu::op::vpermwi128<0,114>(regs,&regs.VR62,regs.VR53);
		/* 82060188h case   98:*/		return 0x8206018C;
		  /* 8206018Ch */ case   99:  		/* vpermwi128 VR10, VR50, 78 */
		/* 8206018Ch case   99:*/		cpu::op::vpermwi128<0,78>(regs,&regs.VR10,regs.VR50);
		/* 8206018Ch case   99:*/		return 0x82060190;
		  /* 82060190h */ case  100:  		/* li R10, 32 */
		/* 82060190h case  100:*/		cpu::op::li<0>(regs,&regs.R10,0x20);
		/* 82060190h case  100:*/		return 0x82060194;
		  /* 82060194h */ case  101:  		/* vmrglw VR58, VR54, VR51 */
		/* 82060194h case  101:*/		cpu::op::vmrglw<0>(regs,&regs.VR58,regs.VR54,regs.VR51);
		/* 82060194h case  101:*/		return 0x82060198;
		  /* 82060198h */ case  102:  		/* li R9, 48 */
		/* 82060198h case  102:*/		cpu::op::li<0>(regs,&regs.R9,0x30);
		/* 82060198h case  102:*/		return 0x8206019C;
		  /* 8206019Ch */ case  103:  		/* vxor VR13, VR62, VR59 */
		/* 8206019Ch case  103:*/		cpu::op::vxor<0>(regs,&regs.VR13,regs.VR62,regs.VR59);
		/* 8206019Ch case  103:*/		return 0x820601A0;
		  /* 820601A0h */ case  104:  		/* vrlimi128 VR10, VR51, 9, 1 */
		/* 820601A0h case  104:*/		cpu::op::vrlimi128<0,9,1>(regs,&regs.VR10,regs.VR51);
		/* 820601A0h case  104:*/		return 0x820601A4;
		  /* 820601A4h */ case  105:  		/* vpermwi128 VR7, VR58, 52 */
		/* 820601A4h case  105:*/		cpu::op::vpermwi128<0,52>(regs,&regs.VR7,regs.VR58);
		/* 820601A4h case  105:*/		return 0x820601A8;
		  /* 820601A8h */ case  106:  		/* vmaddfp VR5, VR13, VR10, VR1 */
		/* 820601A8h case  106:*/		cpu::op::vmaddfp<0>(regs,&regs.VR5,regs.VR13,regs.VR10,regs.VR1);
		/* 820601A8h case  106:*/		return 0x820601AC;
		  /* 820601ACh */ case  107:  		/* vmaddfp VR6, VR11, VR0, VR6 */
		/* 820601ACh case  107:*/		cpu::op::vmaddfp<0>(regs,&regs.VR6,regs.VR11,regs.VR0,regs.VR6);
		/* 820601ACh case  107:*/		return 0x820601B0;
		  /* 820601B0h */ case  108:  		/* vmaddfp VR7, VR12, VR7, VR4 */
		/* 820601B0h case  108:*/		cpu::op::vmaddfp<0>(regs,&regs.VR7,regs.VR12,regs.VR7,regs.VR4);
		/* 820601B0h case  108:*/		return 0x820601B4;
		  /* 820601B4h */ case  109:  		/* mr VR63, VR8 */
		/* 820601B4h case  109:*/		regs.VR63 = regs.VR8;
		/* 820601B4h case  109:*/		return 0x820601B8;
		  /* 820601B8h */ case  110:  		/* vdot4fp VR11, VR63, VR53 */
		/* 820601B8h case  110:*/		cpu::op::vdot4fp<0>(regs,&regs.VR11,regs.VR63,regs.VR53);
		/* 820601B8h case  110:*/		return 0x820601BC;
		  /* 820601BCh */ case  111:  		/* stvx VR11, <#[R4]> */
		/* 820601BCh case  111:*/		cpu::mem::stvx( regs, regs.VR11, (uint32)(regs.R4 + 0x00000000) );
		/* 820601BCh case  111:*/		return 0x820601C0;
		  /* 820601C0h */ case  112:  		/* vrefp VR0, VR11 */
		/* 820601C0h case  112:*/		cpu::op::vrefp<0>(regs,&regs.VR0,regs.VR11);
		/* 820601C0h case  112:*/		return 0x820601C4;
		  /* 820601C4h */ case  113:  		/* vnmsubfp VR8, VR11, VR0, VR9 */
		/* 820601C4h case  113:*/		cpu::op::vnmsubfp<0>(regs,&regs.VR8,regs.VR11,regs.VR0,regs.VR9);
		/* 820601C4h case  113:*/		return 0x820601C8;
		  /* 820601C8h */ case  114:  		/* mr VR10, VR0 */
		/* 820601C8h case  114:*/		regs.VR10 = regs.VR0;
		/* 820601C8h case  114:*/		return 0x820601CC;
		  /* 820601CCh */ case  115:  		/* vmaddfp VR0, VR0, VR8, VR0 */
		/* 820601CCh case  115:*/		cpu::op::vmaddfp<0>(regs,&regs.VR0,regs.VR0,regs.VR8,regs.VR0);
		/* 820601CCh case  115:*/		return 0x820601D0;
		  /* 820601D0h */ case  116:  		/* vnmsubfp VR12, VR11, VR0, VR9 */
		/* 820601D0h case  116:*/		cpu::op::vnmsubfp<0>(regs,&regs.VR12,regs.VR11,regs.VR0,regs.VR9);
		/* 820601D0h case  116:*/		return 0x820601D4;
		  /* 820601D4h */ case  117:  		/* vcmpeqfp VR8, VR0, VR0 */
		/* 820601D4h case  117:*/		cpu::op::vcmpeqfp<0>(regs,&regs.VR8,regs.VR0,regs.VR0);
		/* 820601D4h case  117:*/		return 0x820601D8;
		  /* 820601D8h */ case  118:  		/* vmaddfp VR0, VR0, VR12, VR0 */
		/* 820601D8h case  118:*/		cpu::op::vmaddfp<0>(regs,&regs.VR0,regs.VR0,regs.VR12,regs.VR0);
		/* 820601D8h case  118:*/		return 0x820601DC;
		  /* 820601DCh */ case  119:  		/* vsel VR13, VR10, VR0, VR8 */
		/* 820601DCh case  119:*/		cpu::op::vsel<0>(regs,&regs.VR13,regs.VR10,regs.VR0,regs.VR8);
		/* 820601DCh case  119:*/		return 0x820601E0;
		  /* 820601E0h */ case  120:  		/* vmulfp128 VR63, VR63, VR13 */
		/* 820601E0h case  120:*/		cpu::op::vmulfp128<0>(regs,&regs.VR63,regs.VR63,regs.VR13);
		/* 820601E0h case  120:*/		return 0x820601E4;
		  /* 820601E4h */ case  121:  		/* vmulfp128 VR62, VR5, VR13 */
		/* 820601E4h case  121:*/		cpu::op::vmulfp128<0>(regs,&regs.VR62,regs.VR5,regs.VR13);
		/* 820601E4h case  121:*/		return 0x820601E8;
		  /* 820601E8h */ case  122:  		/* vmulfp128 VR61, VR7, VR13 */
		/* 820601E8h case  122:*/		cpu::op::vmulfp128<0>(regs,&regs.VR61,regs.VR7,regs.VR13);
		/* 820601E8h case  122:*/		return 0x820601EC;
		  /* 820601ECh */ case  123:  		/* vmulfp128 VR60, VR6, VR13 */
		/* 820601ECh case  123:*/		cpu::op::vmulfp128<0>(regs,&regs.VR60,regs.VR6,regs.VR13);
		/* 820601ECh case  123:*/		return 0x820601F0;
		  /* 820601F0h */ case  124:  		/* stvx VR63, <#[R3]> */
		/* 820601F0h case  124:*/		cpu::mem::stvx( regs, regs.VR63, (uint32)(regs.R3 + 0x00000000) );
		/* 820601F0h case  124:*/		return 0x820601F4;
		  /* 820601F4h */ case  125:  		/* stvx VR62, <#[R3 + R11]> */
		/* 820601F4h case  125:*/		cpu::mem::stvx( regs, regs.VR62, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 820601F4h case  125:*/		return 0x820601F8;
		  /* 820601F8h */ case  126:  		/* stvx VR61, <#[R3 + R10]> */
		/* 820601F8h case  126:*/		cpu::mem::stvx( regs, regs.VR61, (uint32)(regs.R3 + regs.R10 + 0x00000000) );
		/* 820601F8h case  126:*/		return 0x820601FC;
		  /* 820601FCh */ case  127:  		/* stvx VR60, <#[R3 + R9]> */
		/* 820601FCh case  127:*/		cpu::mem::stvx( regs, regs.VR60, (uint32)(regs.R3 + regs.R9 + 0x00000000) );
		/* 820601FCh case  127:*/		return 0x82060200;
		  /* 82060200h */ case  128:  		/* bclr 20, CR0_LT */
		/* 82060200h case  128:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82060200h case  128:*/		return 0x82060204;
	}
	return 0x82060204;
} // Block from 82060000h-82060204h (129 instructions)

//////////////////////////////////////////////////////
// Block at 82060204h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82060204( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82060204) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82060204);
		  /* 82060204h */ case    0:  		/* nop */
		/* 82060204h case    0:*/		cpu::op::nop();
		/* 82060204h case    0:*/		return 0x82060208;
	}
	return 0x82060208;
} // Block from 82060204h-82060208h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82060208h
// Function '?XMScalarSinCos@@YAXPAM0M@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82060208( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82060208) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82060208);
		  /* 82060208h */ case    0:  		/* vdot3fp VR63, VR2, VR2 */
		/* 82060208h case    0:*/		cpu::op::vdot3fp<0>(regs,&regs.VR63,regs.VR2,regs.VR2);
		/* 82060208h case    0:*/		return 0x8206020C;
		  /* 8206020Ch */ case    1:  		/* vspltisw VR62, 1 */
		/* 8206020Ch case    1:*/		cpu::op::vspltisw<0,1>(regs,&regs.VR62);
		/* 8206020Ch case    1:*/		return 0x82060210;
		  /* 82060210h */ case    2:  		/* vspltisw VR60, 31 */
		/* 82060210h case    2:*/		cpu::op::vspltisw<0,31>(regs,&regs.VR60);
		/* 82060210h case    2:*/		return 0x82060214;
		  /* 82060214h */ case    3:  		/* li R11, 16 */
		/* 82060214h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x10);
		/* 82060214h case    3:*/		return 0x82060218;
		  /* 82060218h */ case    4:  		/* vpermwi128 VR61, VR3, 99 */
		/* 82060218h case    4:*/		cpu::op::vpermwi128<0,99>(regs,&regs.VR61,regs.VR3);
		/* 82060218h case    4:*/		return 0x8206021C;
		  /* 8206021Ch */ case    5:  		/* li R10, 32 */
		/* 8206021Ch case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x20);
		/* 8206021Ch case    5:*/		return 0x82060220;
		  /* 82060220h */ case    6:  		/* vpermwi128 VR10, VR3, 135 */
		/* 82060220h case    6:*/		cpu::op::vpermwi128<0,135>(regs,&regs.VR10,regs.VR3);
		/* 82060220h case    6:*/		return 0x82060224;
		  /* 82060224h */ case    7:  		/* li R9, 48 */
		/* 82060224h case    7:*/		cpu::op::li<0>(regs,&regs.R9,0x30);
		/* 82060224h case    7:*/		return 0x82060228;
		  /* 82060228h */ case    8:  		/* vcsxwfp VR0, VR62, 1 */
		/* 82060228h case    8:*/		cpu::op::vcsxwfp<0,1>(regs,&regs.VR0,regs.VR62);
		/* 82060228h case    8:*/		return 0x8206022C;
		  /* 8206022Ch */ case    9:  		/* vspltisw VR62, 0 */
		/* 8206022Ch case    9:*/		cpu::op::vspltisw<0,0>(regs,&regs.VR62);
		/* 8206022Ch case    9:*/		return 0x82060230;
		  /* 82060230h */ case   10:  		/* vslw VR60, VR60, VR60 */
		/* 82060230h case   10:*/		cpu::op::vslw<0>(regs,&regs.VR60,regs.VR60,regs.VR60);
		/* 82060230h case   10:*/		return 0x82060234;
		  /* 82060234h */ case   11:  		/* vupkd3d128 VR62, VR62, 1 */
		/* 82060234h case   11:*/		cpu::op::vupkd3d128<0,1>(regs,&regs.VR62,regs.VR62);
		/* 82060234h case   11:*/		return 0x82060238;
		  /* 82060238h */ case   12:  		/* vxor VR60, VR1, VR60 */
		/* 82060238h case   12:*/		cpu::op::vxor<0>(regs,&regs.VR60,regs.VR1,regs.VR60);
		/* 82060238h case   12:*/		return 0x8206023C;
		  /* 8206023Ch */ case   13:  		/* vpermwi128 VR62, VR62, 171 */
		/* 8206023Ch case   13:*/		cpu::op::vpermwi128<0,171>(regs,&regs.VR62,regs.VR62);
		/* 8206023Ch case   13:*/		return 0x82060240;
		  /* 82060240h */ case   14:  		/* vrsqrtefp VR13, VR63 */
		/* 82060240h case   14:*/		cpu::op::vrsqrtefp<0>(regs,&regs.VR13,regs.VR63);
		/* 82060240h case   14:*/		return 0x82060244;
		  /* 82060244h */ case   15:  		/* vmulfp128 VR12, VR63, VR0 */
		/* 82060244h case   15:*/		cpu::op::vmulfp128<0>(regs,&regs.VR12,regs.VR63,regs.VR0);
		/* 82060244h case   15:*/		return 0x82060248;
		  /* 82060248h */ case   16:  		/* vmulfp128 VR11, VR13, VR13 */
		/* 82060248h case   16:*/		cpu::op::vmulfp128<0>(regs,&regs.VR11,regs.VR13,regs.VR13);
		/* 82060248h case   16:*/		return 0x8206024C;
		  /* 8206024Ch */ case   17:  		/* vnmsubfp VR9, VR12, VR11, VR0 */
		/* 8206024Ch case   17:*/		cpu::op::vnmsubfp<0>(regs,&regs.VR9,regs.VR12,regs.VR11,regs.VR0);
		/* 8206024Ch case   17:*/		return 0x82060250;
		  /* 82060250h */ case   18:  		/* vmaddfp VR13, VR13, VR9, VR13 */
		/* 82060250h case   18:*/		cpu::op::vmaddfp<0>(regs,&regs.VR13,regs.VR13,regs.VR9,regs.VR13);
		/* 82060250h case   18:*/		return 0x82060254;
		  /* 82060254h */ case   19:  		/* vmulfp128 VR63, VR2, VR13 */
		/* 82060254h case   19:*/		cpu::op::vmulfp128<0>(regs,&regs.VR63,regs.VR2,regs.VR13);
		/* 82060254h case   19:*/		return 0x82060258;
		  /* 82060258h */ case   20:  		/* vpermwi128 VR9, VR63, 135 */
		/* 82060258h case   20:*/		cpu::op::vpermwi128<0,135>(regs,&regs.VR9,regs.VR63);
		/* 82060258h case   20:*/		return 0x8206025C;
		  /* 8206025Ch */ case   21:  		/* vdot3fp VR59, VR63, VR60 */
		/* 8206025Ch case   21:*/		cpu::op::vdot3fp<0>(regs,&regs.VR59,regs.VR63,regs.VR60);
		/* 8206025Ch case   21:*/		return 0x82060260;
		  /* 82060260h */ case   22:  		/* vpermwi128 VR58, VR63, 99 */
		/* 82060260h case   22:*/		cpu::op::vpermwi128<0,99>(regs,&regs.VR58,regs.VR63);
		/* 82060260h case   22:*/		return 0x82060264;
		  /* 82060264h */ case   23:  		/* vmulfp128 VR12, VR61, VR9 */
		/* 82060264h case   23:*/		cpu::op::vmulfp128<0>(regs,&regs.VR12,regs.VR61,regs.VR9);
		/* 82060264h case   23:*/		return 0x82060268;
		  /* 82060268h */ case   24:  		/* mr VR13, VR58 */
		/* 82060268h case   24:*/		regs.VR13 = regs.VR58;
		/* 82060268h case   24:*/		return 0x8206026C;
		  /* 8206026Ch */ case   25:  		/* vnmsubfp VR12, VR10, VR13, VR12 */
		/* 8206026Ch case   25:*/		cpu::op::vnmsubfp<0>(regs,&regs.VR12,regs.VR10,regs.VR13,regs.VR12);
		/* 8206026Ch case   25:*/		return 0x82060270;
		  /* 82060270h */ case   26:  		/* vrlimi128 VR59, VR63, 14, 0 */
		/* 82060270h case   26:*/		cpu::op::vrlimi128<0,14,0>(regs,&regs.VR59,regs.VR63);
		/* 82060270h case   26:*/		return 0x82060274;
		  /* 82060274h */ case   27:  		/* mr VR63, VR12 */
		/* 82060274h case   27:*/		regs.VR63 = regs.VR12;
		/* 82060274h case   27:*/		return 0x82060278;
		  /* 82060278h */ case   28:  		/* vdot3fp VR61, VR63, VR63 */
		/* 82060278h case   28:*/		cpu::op::vdot3fp<0>(regs,&regs.VR61,regs.VR63,regs.VR63);
		/* 82060278h case   28:*/		return 0x8206027C;
		  /* 8206027Ch */ case   29:  		/* vrsqrtefp VR13, VR61 */
		/* 8206027Ch case   29:*/		cpu::op::vrsqrtefp<0>(regs,&regs.VR13,regs.VR61);
		/* 8206027Ch case   29:*/		return 0x82060280;
		  /* 82060280h */ case   30:  		/* vmulfp128 VR12, VR61, VR0 */
		/* 82060280h case   30:*/		cpu::op::vmulfp128<0>(regs,&regs.VR12,regs.VR61,regs.VR0);
		/* 82060280h case   30:*/		return 0x82060284;
		  /* 82060284h */ case   31:  		/* vmulfp128 VR11, VR13, VR13 */
		/* 82060284h case   31:*/		cpu::op::vmulfp128<0>(regs,&regs.VR11,regs.VR13,regs.VR13);
		/* 82060284h case   31:*/		return 0x82060288;
		  /* 82060288h */ case   32:  		/* vnmsubfp VR0, VR12, VR11, VR0 */
		/* 82060288h case   32:*/		cpu::op::vnmsubfp<0>(regs,&regs.VR0,regs.VR12,regs.VR11,regs.VR0);
		/* 82060288h case   32:*/		return 0x8206028C;
		  /* 8206028Ch */ case   33:  		/* vmaddfp VR0, VR13, VR0, VR13 */
		/* 8206028Ch case   33:*/		cpu::op::vmaddfp<0>(regs,&regs.VR0,regs.VR13,regs.VR0,regs.VR13);
		/* 8206028Ch case   33:*/		return 0x82060290;
		  /* 82060290h */ case   34:  		/* vmulfp128 VR63, VR63, VR0 */
		/* 82060290h case   34:*/		cpu::op::vmulfp128<0>(regs,&regs.VR63,regs.VR63,regs.VR0);
		/* 82060290h case   34:*/		return 0x82060294;
		  /* 82060294h */ case   35:  		/* vpermwi128 VR61, VR63, 135 */
		/* 82060294h case   35:*/		cpu::op::vpermwi128<0,135>(regs,&regs.VR61,regs.VR63);
		/* 82060294h case   35:*/		return 0x82060298;
		  /* 82060298h */ case   36:  		/* vdot3fp VR57, VR63, VR60 */
		/* 82060298h case   36:*/		cpu::op::vdot3fp<0>(regs,&regs.VR57,regs.VR63,regs.VR60);
		/* 82060298h case   36:*/		return 0x8206029C;
		  /* 8206029Ch */ case   37:  		/* vpermwi128 VR0, VR63, 99 */
		/* 8206029Ch case   37:*/		cpu::op::vpermwi128<0,99>(regs,&regs.VR0,regs.VR63);
		/* 8206029Ch case   37:*/		return 0x820602A0;
		  /* 820602A0h */ case   38:  		/* vmulfp128 VR13, VR58, VR61 */
		/* 820602A0h case   38:*/		cpu::op::vmulfp128<0>(regs,&regs.VR13,regs.VR58,regs.VR61);
		/* 820602A0h case   38:*/		return 0x820602A4;
		  /* 820602A4h */ case   39:  		/* vnmsubfp VR13, VR9, VR0, VR13 */
		/* 820602A4h case   39:*/		cpu::op::vnmsubfp<0>(regs,&regs.VR13,regs.VR9,regs.VR0,regs.VR13);
		/* 820602A4h case   39:*/		return 0x820602A8;
		  /* 820602A8h */ case   40:  		/* vrlimi128 VR57, VR63, 14, 0 */
		/* 820602A8h case   40:*/		cpu::op::vrlimi128<0,14,0>(regs,&regs.VR57,regs.VR63);
		/* 820602A8h case   40:*/		return 0x820602AC;
		  /* 820602ACh */ case   41:  		/* vmrghw VR63, VR57, VR59 */
		/* 820602ACh case   41:*/		cpu::op::vmrghw<0>(regs,&regs.VR63,regs.VR57,regs.VR59);
		/* 820602ACh case   41:*/		return 0x820602B0;
		  /* 820602B0h */ case   42:  		/* vmrglw VR61, VR57, VR59 */
		/* 820602B0h case   42:*/		cpu::op::vmrglw<0>(regs,&regs.VR61,regs.VR57,regs.VR59);
		/* 820602B0h case   42:*/		return 0x820602B4;
		  /* 820602B4h */ case   43:  		/* vdot3fp VR60, VR13, VR60 */
		/* 820602B4h case   43:*/		cpu::op::vdot3fp<0>(regs,&regs.VR60,regs.VR13,regs.VR60);
		/* 820602B4h case   43:*/		return 0x820602B8;
		  /* 820602B8h */ case   44:  		/* vrlimi128 VR60, VR13, 14, 0 */
		/* 820602B8h case   44:*/		cpu::op::vrlimi128<0,14,0>(regs,&regs.VR60,regs.VR13);
		/* 820602B8h case   44:*/		return 0x820602BC;
		  /* 820602BCh */ case   45:  		/* vmrghw VR59, VR60, VR62 */
		/* 820602BCh case   45:*/		cpu::op::vmrghw<0>(regs,&regs.VR59,regs.VR60,regs.VR62);
		/* 820602BCh case   45:*/		return 0x820602C0;
		  /* 820602C0h */ case   46:  		/* vmrglw VR62, VR60, VR62 */
		/* 820602C0h case   46:*/		cpu::op::vmrglw<0>(regs,&regs.VR62,regs.VR60,regs.VR62);
		/* 820602C0h case   46:*/		return 0x820602C4;
		  /* 820602C4h */ case   47:  		/* vmrghw VR60, VR63, VR59 */
		/* 820602C4h case   47:*/		cpu::op::vmrghw<0>(regs,&regs.VR60,regs.VR63,regs.VR59);
		/* 820602C4h case   47:*/		return 0x820602C8;
		  /* 820602C8h */ case   48:  		/* vmrglw VR63, VR63, VR59 */
		/* 820602C8h case   48:*/		cpu::op::vmrglw<0>(regs,&regs.VR63,regs.VR63,regs.VR59);
		/* 820602C8h case   48:*/		return 0x820602CC;
		  /* 820602CCh */ case   49:  		/* vmrghw VR59, VR61, VR62 */
		/* 820602CCh case   49:*/		cpu::op::vmrghw<0>(regs,&regs.VR59,regs.VR61,regs.VR62);
		/* 820602CCh case   49:*/		return 0x820602D0;
		  /* 820602D0h */ case   50:  		/* vmrglw VR62, VR61, VR62 */
		/* 820602D0h case   50:*/		cpu::op::vmrglw<0>(regs,&regs.VR62,regs.VR61,regs.VR62);
		/* 820602D0h case   50:*/		return 0x820602D4;
		  /* 820602D4h */ case   51:  		/* stvx VR60, <#[R3]> */
		/* 820602D4h case   51:*/		cpu::mem::stvx( regs, regs.VR60, (uint32)(regs.R3 + 0x00000000) );
		/* 820602D4h case   51:*/		return 0x820602D8;
		  /* 820602D8h */ case   52:  		/* stvx VR63, <#[R3 + R11]> */
		/* 820602D8h case   52:*/		cpu::mem::stvx( regs, regs.VR63, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 820602D8h case   52:*/		return 0x820602DC;
		  /* 820602DCh */ case   53:  		/* stvx VR59, <#[R3 + R10]> */
		/* 820602DCh case   53:*/		cpu::mem::stvx( regs, regs.VR59, (uint32)(regs.R3 + regs.R10 + 0x00000000) );
		/* 820602DCh case   53:*/		return 0x820602E0;
		  /* 820602E0h */ case   54:  		/* stvx VR62, <#[R3 + R9]> */
		/* 820602E0h case   54:*/		cpu::mem::stvx( regs, regs.VR62, (uint32)(regs.R3 + regs.R9 + 0x00000000) );
		/* 820602E0h case   54:*/		return 0x820602E4;
		  /* 820602E4h */ case   55:  		/* bclr 20, CR0_LT */
		/* 820602E4h case   55:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820602E4h case   55:*/		return 0x820602E8;
	}
	return 0x820602E8;
} // Block from 82060208h-820602E8h (56 instructions)

//////////////////////////////////////////////////////
// Block at 820602E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820602E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820602E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820602E8);
		  /* 820602E8h */ case    0:  		/* lis R11, -32256 */
		/* 820602E8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820602E8h case    0:*/		return 0x820602EC;
		  /* 820602ECh */ case    1:  		/* lis R10, -32256 */
		/* 820602ECh case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 820602ECh case    1:*/		return 0x820602F0;
		  /* 820602F0h */ case    2:  		/* lis R8, -32256 */
		/* 820602F0h case    2:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8200);
		/* 820602F0h case    2:*/		return 0x820602F4;
		  /* 820602F4h */ case    3:  		/* addi R7, R1, -16 */
		/* 820602F4h case    3:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0xFFFFFFF0);
		/* 820602F4h case    3:*/		return 0x820602F8;
		  /* 820602F8h */ case    4:  		/* lis R9, -32256 */
		/* 820602F8h case    4:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 820602F8h case    4:*/		return 0x820602FC;
		  /* 820602FCh */ case    5:  		/* lfs FR0, <#[R11 + 1804]> */
		/* 820602FCh case    5:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x0000070C) );
		/* 820602FCh case    5:*/		return 0x82060300;
		  /* 82060300h */ case    6:  		/* lis R11, -32256 */
		/* 82060300h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82060300h case    6:*/		return 0x82060304;
		  /* 82060304h */ case    7:  		/* fadds FR10, FR1, FR0 */
		/* 82060304h case    7:*/		cpu::op::fadds<0>(regs,&regs.FR10,regs.FR1,regs.FR0);
		/* 82060304h case    7:*/		return 0x82060308;
		  /* 82060308h */ case    8:  		/* lfs FR12, <#[R10 + 1800]> */
		/* 82060308h case    8:*/		cpu::mem::load32f( regs, &regs.FR12, (uint32)(regs.R10 + 0x00000708) );
		/* 82060308h case    8:*/		return 0x8206030C;
		  /* 8206030Ch */ case    9:  		/* addi R10, R1, -16 */
		/* 8206030Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xFFFFFFF0);
		/* 8206030Ch case    9:*/		return 0x82060310;
		  /* 82060310h */ case   10:  		/* lfs FR13, <#[R8 + 1792]> */
		/* 82060310h case   10:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R8 + 0x00000700) );
		/* 82060310h case   10:*/		return 0x82060314;
		  /* 82060314h */ case   11:  		/* stfs FR13, <#[R1 - 16]> */
		/* 82060314h case   11:*/		cpu::mem::store32f( regs, regs.FR13, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82060314h case   11:*/		return 0x82060318;
		  /* 82060318h */ case   12:  		/* addi R11, R11, 1728 */
		/* 82060318h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6C0);
		/* 82060318h case   12:*/		return 0x8206031C;
		  /* 8206031Ch */ case   13:  		/* lfs FR11, <#[R9 + 1796]> */
		/* 8206031Ch case   13:*/		cpu::mem::load32f( regs, &regs.FR11, (uint32)(regs.R9 + 0x00000704) );
		/* 8206031Ch case   13:*/		return 0x82060320;
		  /* 82060320h */ case   14:  		/* lis R8, -32256 */
		/* 82060320h case   14:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8200);
		/* 82060320h case   14:*/		return 0x82060324;
		  /* 82060324h */ case   15:  		/* lis R9, -32256 */
		/* 82060324h case   15:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 82060324h case   15:*/		return 0x82060328;
		  /* 82060328h */ case   16:  		/* lis R6, -32256 */
		/* 82060328h case   16:*/		cpu::op::lis<0>(regs,&regs.R6,0xFFFF8200);
		/* 82060328h case   16:*/		return 0x8206032C;
		  /* 8206032Ch */ case   17:  		/* addi R9, R9, 1744 */
		/* 8206032Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x6D0);
		/* 8206032Ch case   17:*/		return 0x82060330;
		  /* 82060330h */ case   18:  		/* lvx VR62, <#[R11]> */
		/* 82060330h case   18:*/		cpu::mem::lvx( regs, &regs.VR62, (uint32)(regs.R11 + 0x00000000) );
		/* 82060330h case   18:*/		return 0x82060334;
		  /* 82060334h */ case   19:  		/* addi R11, R8, 1760 */
		/* 82060334h case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R8,0x6E0);
		/* 82060334h case   19:*/		return 0x82060338;
		  /* 82060338h */ case   20:  		/* lis R8, -32256 */
		/* 82060338h case   20:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8200);
		/* 82060338h case   20:*/		return 0x8206033C;
		  /* 8206033Ch */ case   21:  		/* lis R5, -32256 */
		/* 8206033Ch case   21:*/		cpu::op::lis<0>(regs,&regs.R5,0xFFFF8200);
		/* 8206033Ch case   21:*/		return 0x82060340;
		  /* 82060340h */ case   22:  		/* fabs FR13, FR10 */
		/* 82060340h case   22:*/		cpu::op::fabs<0>(regs,&regs.FR13,regs.FR10);
		/* 82060340h case   22:*/		return 0x82060344;
		  /* 82060344h */ case   23:  		/* lvx VR60, <#[R9]> */
		/* 82060344h case   23:*/		cpu::mem::lvx( regs, &regs.VR60, (uint32)(regs.R9 + 0x00000000) );
		/* 82060344h case   23:*/		return 0x82060348;
		  /* 82060348h */ case   24:  		/* addi R9, R6, 1712 */
		/* 82060348h case   24:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R6,0x6B0);
		/* 82060348h case   24:*/		return 0x8206034C;
		  /* 8206034Ch */ case   25:  		/* lvx VR58, <#[R11]> */
		/* 8206034Ch case   25:*/		cpu::mem::lvx( regs, &regs.VR58, (uint32)(regs.R11 + 0x00000000) );
		/* 8206034Ch case   25:*/		return 0x82060350;
		  /* 82060350h */ case   26:  		/* addi R11, R8, 1696 */
		/* 82060350h case   26:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R8,0x6A0);
		/* 82060350h case   26:*/		return 0x82060354;
		  /* 82060354h */ case   27:  		/* addi R8, R5, 1680 */
		/* 82060354h case   27:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R5,0x690);
		/* 82060354h case   27:*/		return 0x82060358;
		  /* 82060358h */ case   28:  		/* addi R6, R1, -16 */
		/* 82060358h case   28:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0xFFFFFFF0);
		/* 82060358h case   28:*/		return 0x8206035C;
		  /* 8206035Ch */ case   29:  		/* addi R5, R1, -16 */
		/* 8206035Ch case   29:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0xFFFFFFF0);
		/* 8206035Ch case   29:*/		return 0x82060360;
		  /* 82060360h */ case   30:  		/* lvx VR57, <#[R9]> */
		/* 82060360h case   30:*/		cpu::mem::lvx( regs, &regs.VR57, (uint32)(regs.R9 + 0x00000000) );
		/* 82060360h case   30:*/		return 0x82060364;
		  /* 82060364h */ case   31:  		/* addi R9, R1, -16 */
		/* 82060364h case   31:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0xFFFFFFF0);
		/* 82060364h case   31:*/		return 0x82060368;
	}
	return 0x82060368;
} // Block from 820602E8h-82060368h (32 instructions)

//////////////////////////////////////////////////////
// Block at 82060368h
// Function '?GetAppTime@Timer@ATG@@QAANXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82060368( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82060368) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82060368);
		  /* 82060368h */ case    0:  		/* lvx VR59, <#[R11]> */
		/* 82060368h case    0:*/		cpu::mem::lvx( regs, &regs.VR59, (uint32)(regs.R11 + 0x00000000) );
		/* 82060368h case    0:*/		return 0x8206036C;
		  /* 8206036Ch */ case    1:  		/* addi R11, R1, -16 */
		/* 8206036Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xFFFFFFF0);
		/* 8206036Ch case    1:*/		return 0x82060370;
		  /* 82060370h */ case    2:  		/* lvx VR61, <#[R8]> */
		/* 82060370h case    2:*/		cpu::mem::lvx( regs, &regs.VR61, (uint32)(regs.R8 + 0x00000000) );
		/* 82060370h case    2:*/		return 0x82060374;
		  /* 82060374h */ case    3:  		/* addi R8, R1, -16 */
		/* 82060374h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xFFFFFFF0);
		/* 82060374h case    3:*/		return 0x82060378;
		  /* 82060378h */ case    4:  		/* fmuls FR12, FR13, FR12 */
		/* 82060378h case    4:*/		cpu::op::fmuls<0>(regs,&regs.FR12,regs.FR13,regs.FR12);
		/* 82060378h case    4:*/		return 0x8206037C;
		  /* 8206037Ch */ case    5:  		/* fctidz FR12, FR12 */
		/* 8206037Ch case    5:*/		cpu::op::fctidz<0>(regs,&regs.FR12,regs.FR12);
		/* 8206037Ch case    5:*/		return 0x82060380;
		  /* 82060380h */ case    6:  		/* fcfid FR12, FR12 */
		/* 82060380h case    6:*/		cpu::op::fcfid<0>(regs,&regs.FR12,regs.FR12);
		/* 82060380h case    6:*/		return 0x82060384;
		  /* 82060384h */ case    7:  		/* frsp FR12, FR12 */
		/* 82060384h case    7:*/		cpu::op::frsp<0>(regs,&regs.FR12,regs.FR12);
		/* 82060384h case    7:*/		return 0x82060388;
		  /* 82060388h */ case    8:  		/* fnmsubs FR13, FR12, FR11, FR13 */
		/* 82060388h case    8:*/		cpu::op::fnmsubs<0>(regs,&regs.FR13,regs.FR12,regs.FR11,regs.FR13);
		/* 82060388h case    8:*/		return 0x8206038C;
		  /* 8206038Ch */ case    9:  		/* fsubs FR0, FR13, FR0 */
		/* 8206038Ch case    9:*/		cpu::op::fsubs<0>(regs,&regs.FR0,regs.FR13,regs.FR0);
		/* 8206038Ch case    9:*/		return 0x82060390;
		  /* 82060390h */ case   10:  		/* fneg FR13, FR0 */
		/* 82060390h case   10:*/		cpu::op::fneg<0>(regs,&regs.FR13,regs.FR0);
		/* 82060390h case   10:*/		return 0x82060394;
		  /* 82060394h */ case   11:  		/* fsel FR0, FR10, FR0, FR13 */
		/* 82060394h case   11:*/		cpu::op::fsel<0>(regs,&regs.FR0,regs.FR10,regs.FR0,regs.FR13);
		/* 82060394h case   11:*/		return 0x82060398;
		  /* 82060398h */ case   12:  		/* stfs FR0, <#[R1 - 12]> */
		/* 82060398h case   12:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF4) );
		/* 82060398h case   12:*/		return 0x8206039C;
		  /* 8206039Ch */ case   13:  		/* fmuls FR13, FR0, FR0 */
		/* 8206039Ch case   13:*/		cpu::op::fmuls<0>(regs,&regs.FR13,regs.FR0,regs.FR0);
		/* 8206039Ch case   13:*/		return 0x820603A0;
		  /* 820603A0h */ case   14:  		/* stfs FR13, <#[R1 - 8]> */
		/* 820603A0h case   14:*/		cpu::mem::store32f( regs, regs.FR13, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820603A0h case   14:*/		return 0x820603A4;
		  /* 820603A4h */ case   15:  		/* fmuls FR0, FR13, FR0 */
		/* 820603A4h case   15:*/		cpu::op::fmuls<0>(regs,&regs.FR0,regs.FR13,regs.FR0);
		/* 820603A4h case   15:*/		return 0x820603A8;
		  /* 820603A8h */ case   16:  		/* stfs FR0, <#[R1 - 4]> */
		/* 820603A8h case   16:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0xFFFFFFFC) );
		/* 820603A8h case   16:*/		return 0x820603AC;
		  /* 820603ACh */ case   17:  		/* lvx VR63, <#[R7]> */
		/* 820603ACh case   17:*/		cpu::mem::lvx( regs, &regs.VR63, (uint32)(regs.R7 + 0x00000000) );
		/* 820603ACh case   17:*/		return 0x820603B0;
		  /* 820603B0h */ case   18:  		/* vmulfp128 VR56, VR63, VR63 */
		/* 820603B0h case   18:*/		cpu::op::vmulfp128<0>(regs,&regs.VR56,regs.VR63,regs.VR63);
		/* 820603B0h case   18:*/		return 0x820603B4;
		  /* 820603B4h */ case   19:  		/* vspltw VR55, VR63, 2 */
		/* 820603B4h case   19:*/		cpu::op::vspltw<0,2>(regs,&regs.VR55,regs.VR63);
		/* 820603B4h case   19:*/		return 0x820603B8;
		  /* 820603B8h */ case   20:  		/* vdot4fp VR62, VR56, VR62 */
		/* 820603B8h case   20:*/		cpu::op::vdot4fp<0>(regs,&regs.VR62,regs.VR56,regs.VR62);
		/* 820603B8h case   20:*/		return 0x820603BC;
		  /* 820603BCh */ case   21:  		/* vspltw VR54, VR56, 3 */
		/* 820603BCh case   21:*/		cpu::op::vspltw<0,3>(regs,&regs.VR54,regs.VR56);
		/* 820603BCh case   21:*/		return 0x820603C0;
		  /* 820603C0h */ case   22:  		/* vspltw VR63, VR63, 1 */
		/* 820603C0h case   22:*/		cpu::op::vspltw<0,1>(regs,&regs.VR63,regs.VR63);
		/* 820603C0h case   22:*/		return 0x820603C4;
		  /* 820603C4h */ case   23:  		/* vmulfp128 VR55, VR54, VR55 */
		/* 820603C4h case   23:*/		cpu::op::vmulfp128<0>(regs,&regs.VR55,regs.VR54,regs.VR55);
		/* 820603C4h case   23:*/		return 0x820603C8;
		  /* 820603C8h */ case   24:  		/* vmulfp128 VR63, VR56, VR63 */
		/* 820603C8h case   24:*/		cpu::op::vmulfp128<0>(regs,&regs.VR63,regs.VR56,regs.VR63);
		/* 820603C8h case   24:*/		return 0x820603CC;
		  /* 820603CCh */ case   25:  		/* stvx VR62, <#[R10]> */
		/* 820603CCh case   25:*/		cpu::mem::stvx( regs, regs.VR62, (uint32)(regs.R10 + 0x00000000) );
		/* 820603CCh case   25:*/		return 0x820603D0;
	}
	return 0x820603D0;
} // Block from 82060368h-820603D0h (26 instructions)

//////////////////////////////////////////////////////
// Block at 820603D0h
// Function '?GetFrameRate@Timer@ATG@@QAAPA_WXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820603D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820603D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820603D0);
		  /* 820603D0h */ case    0:  		/* lfs FR0, <#[R1 - 16]> */
		/* 820603D0h case    0:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820603D0h case    0:*/		return 0x820603D4;
		  /* 820603D4h */ case    1:  		/* vmulfp128 VR62, VR56, VR55 */
		/* 820603D4h case    1:*/		cpu::op::vmulfp128<0>(regs,&regs.VR62,regs.VR56,regs.VR55);
		/* 820603D4h case    1:*/		return 0x820603D8;
		  /* 820603D8h */ case    2:  		/* vmulfp128 VR56, VR63, VR55 */
		/* 820603D8h case    2:*/		cpu::op::vmulfp128<0>(regs,&regs.VR56,regs.VR63,regs.VR55);
		/* 820603D8h case    2:*/		return 0x820603DC;
		  /* 820603DCh */ case    3:  		/* vdot4fp VR63, VR63, VR61 */
		/* 820603DCh case    3:*/		cpu::op::vdot4fp<0>(regs,&regs.VR63,regs.VR63,regs.VR61);
		/* 820603DCh case    3:*/		return 0x820603E0;
		  /* 820603E0h */ case    4:  		/* stvx VR63, <#[R8]> */
		/* 820603E0h case    4:*/		cpu::mem::stvx( regs, regs.VR63, (uint32)(regs.R8 + 0x00000000) );
		/* 820603E0h case    4:*/		return 0x820603E4;
		  /* 820603E4h */ case    5:  		/* vmulfp128 VR61, VR62, VR55 */
		/* 820603E4h case    5:*/		cpu::op::vmulfp128<0>(regs,&regs.VR61,regs.VR62,regs.VR55);
		/* 820603E4h case    5:*/		return 0x820603E8;
		  /* 820603E8h */ case    6:  		/* lfs FR13, <#[R1 - 16]> */
		/* 820603E8h case    6:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820603E8h case    6:*/		return 0x820603EC;
		  /* 820603ECh */ case    7:  		/* vdot4fp VR62, VR62, VR60 */
		/* 820603ECh case    7:*/		cpu::op::vdot4fp<0>(regs,&regs.VR62,regs.VR62,regs.VR60);
		/* 820603ECh case    7:*/		return 0x820603F0;
		  /* 820603F0h */ case    8:  		/* stvx VR62, <#[R6]> */
		/* 820603F0h case    8:*/		cpu::mem::stvx( regs, regs.VR62, (uint32)(regs.R6 + 0x00000000) );
		/* 820603F0h case    8:*/		return 0x820603F4;
		  /* 820603F4h */ case    9:  		/* lfs FR12, <#[R1 - 16]> */
		/* 820603F4h case    9:*/		cpu::mem::load32f( regs, &regs.FR12, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820603F4h case    9:*/		return 0x820603F8;
		  /* 820603F8h */ case   10:  		/* vdot4fp VR59, VR56, VR59 */
		/* 820603F8h case   10:*/		cpu::op::vdot4fp<0>(regs,&regs.VR59,regs.VR56,regs.VR59);
		/* 820603F8h case   10:*/		return 0x820603FC;
		  /* 820603FCh */ case   11:  		/* stvx VR59, <#[R11]> */
		/* 820603FCh case   11:*/		cpu::mem::stvx( regs, regs.VR59, (uint32)(regs.R11 + 0x00000000) );
		/* 820603FCh case   11:*/		return 0x82060400;
		  /* 82060400h */ case   12:  		/* vdot4fp VR63, VR61, VR58 */
		/* 82060400h case   12:*/		cpu::op::vdot4fp<0>(regs,&regs.VR63,regs.VR61,regs.VR58);
		/* 82060400h case   12:*/		return 0x82060404;
		  /* 82060404h */ case   13:  		/* lfs FR11, <#[R1 - 16]> */
		/* 82060404h case   13:*/		cpu::mem::load32f( regs, &regs.FR11, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82060404h case   13:*/		return 0x82060408;
		  /* 82060408h */ case   14:  		/* vmulfp128 VR60, VR56, VR55 */
		/* 82060408h case   14:*/		cpu::op::vmulfp128<0>(regs,&regs.VR60,regs.VR56,regs.VR55);
		/* 82060408h case   14:*/		return 0x8206040C;
		  /* 8206040Ch */ case   15:  		/* stvx VR63, <#[R5]> */
		/* 8206040Ch case   15:*/		cpu::mem::stvx( regs, regs.VR63, (uint32)(regs.R5 + 0x00000000) );
		/* 8206040Ch case   15:*/		return 0x82060410;
		  /* 82060410h */ case   16:  		/* lfs FR10, <#[R1 - 16]> */
		/* 82060410h case   16:*/		cpu::mem::load32f( regs, &regs.FR10, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82060410h case   16:*/		return 0x82060414;
		  /* 82060414h */ case   17:  		/* vdot4fp VR61, VR60, VR57 */
		/* 82060414h case   17:*/		cpu::op::vdot4fp<0>(regs,&regs.VR61,regs.VR60,regs.VR57);
		/* 82060414h case   17:*/		return 0x82060418;
		  /* 82060418h */ case   18:  		/* stvx VR61, <#[R9]> */
		/* 82060418h case   18:*/		cpu::mem::stvx( regs, regs.VR61, (uint32)(regs.R9 + 0x00000000) );
		/* 82060418h case   18:*/		return 0x8206041C;
		  /* 8206041Ch */ case   19:  		/* fadds FR12, FR10, FR12 */
		/* 8206041Ch case   19:*/		cpu::op::fadds<0>(regs,&regs.FR12,regs.FR10,regs.FR12);
		/* 8206041Ch case   19:*/		return 0x82060420;
		  /* 82060420h */ case   20:  		/* fadds FR0, FR12, FR0 */
		/* 82060420h case   20:*/		cpu::op::fadds<0>(regs,&regs.FR0,regs.FR12,regs.FR0);
		/* 82060420h case   20:*/		return 0x82060424;
		  /* 82060424h */ case   21:  		/* lfs FR12, <#[R1 - 16]> */
		/* 82060424h case   21:*/		cpu::mem::load32f( regs, &regs.FR12, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82060424h case   21:*/		return 0x82060428;
		  /* 82060428h */ case   22:  		/* stfs FR0, <#[R4]> */
		/* 82060428h case   22:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R4 + 0x00000000) );
		/* 82060428h case   22:*/		return 0x8206042C;
		  /* 8206042Ch */ case   23:  		/* fadds FR0, FR12, FR11 */
		/* 8206042Ch case   23:*/		cpu::op::fadds<0>(regs,&regs.FR0,regs.FR12,regs.FR11);
		/* 8206042Ch case   23:*/		return 0x82060430;
		  /* 82060430h */ case   24:  		/* fadds FR0, FR0, FR13 */
		/* 82060430h case   24:*/		cpu::op::fadds<0>(regs,&regs.FR0,regs.FR0,regs.FR13);
		/* 82060430h case   24:*/		return 0x82060434;
		  /* 82060434h */ case   25:  		/* stfs FR0, <#[R3]> */
		/* 82060434h case   25:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R3 + 0x00000000) );
		/* 82060434h case   25:*/		return 0x82060438;
		  /* 82060438h */ case   26:  		/* bclr 20, CR0_LT */
		/* 82060438h case   26:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82060438h case   26:*/		return 0x8206043C;
	}
	return 0x8206043C;
} // Block from 820603D0h-8206043Ch (27 instructions)

//////////////////////////////////////////////////////
// Block at 8206043Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206043C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206043C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206043C);
		  /* 8206043Ch */ case    0:  		/* nop */
		/* 8206043Ch case    0:*/		cpu::op::nop();
		/* 8206043Ch case    0:*/		return 0x82060440;
	}
	return 0x82060440;
} // Block from 8206043Ch-82060440h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82060440h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82060440( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82060440) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82060440);
		  /* 82060440h */ case    0:  		/* mfspr R12, LR */
		/* 82060440h case    0:*/		regs.R12 = regs.LR;
		/* 82060440h case    0:*/		return 0x82060444;
		  /* 82060444h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82060444h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82060444h case    1:*/		return 0x82060448;
		  /* 82060448h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82060448h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82060448h case    2:*/		return 0x8206044C;
		  /* 8206044Ch */ case    3:  		/* stwu R1, <#[R1 - 112]> */
		/* 8206044Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8206044Ch case    3:*/		return 0x82060450;
		  /* 82060450h */ case    4:  		/* lis R11, -32256 */
		/* 82060450h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82060450h case    4:*/		return 0x82060454;
		  /* 82060454h */ case    5:  		/* lfd FR0, <#[R3 + 32]> */
		/* 82060454h case    5:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R3 + 0x00000020) );
		/* 82060454h case    5:*/		return 0x82060458;
		  /* 82060458h */ case    6:  		/* mr R31, R3 */
		/* 82060458h case    6:*/		regs.R31 = regs.R3;
		/* 82060458h case    6:*/		return 0x8206045C;
		  /* 8206045Ch */ case    7:  		/* lfd FR13, <#[R11 + 1808]> */
		/* 8206045Ch case    7:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000710) );
		/* 8206045Ch case    7:*/		return 0x82060460;
		  /* 82060460h */ case    8:  		/* fcmpu CR6, FR0, FR13 */
		/* 82060460h case    8:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82060460h case    8:*/		return 0x82060464;
		  /* 82060464h */ case    9:  		/* bc 4, CR6_EQ, 32 */
		/* 82060464h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82060484;  }
		/* 82060464h case    9:*/		return 0x82060468;
		  /* 82060468h */ case   10:  		/* addi R3, R1, 80 */
		/* 82060468h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82060468h case   10:*/		return 0x8206046C;
		  /* 8206046Ch */ case   11:  		/* bl 161092 */
		/* 8206046Ch case   11:*/		regs.LR = 0x82060470; return 0x820879B0;
		/* 8206046Ch case   11:*/		return 0x82060470;
	}
	return 0x82060470;
} // Block from 82060440h-82060470h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82060470h
// Function 'main'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82060470( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82060470) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82060470);
		  /* 82060470h */ case    0:  		/* lfd FR0, <#[R31 + 88]> */
		/* 82060470h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R31 + 0x00000058) );
		/* 82060470h case    0:*/		return 0x82060474;
		  /* 82060474h */ case    1:  		/* lfd FR13, <#[R1 + 80]> */
		/* 82060474h case    1:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000050) );
		/* 82060474h case    1:*/		return 0x82060478;
		  /* 82060478h */ case    2:  		/* fcfid FR0, FR0 */
		/* 82060478h case    2:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 82060478h case    2:*/		return 0x8206047C;
		  /* 8206047Ch */ case    3:  		/* fcfid FR13, FR13 */
		/* 8206047Ch case    3:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 8206047Ch case    3:*/		return 0x82060480;
		  /* 82060480h */ case    4:  		/* fdiv FR0, FR13, FR0 */
		/* 82060480h case    4:*/		cpu::op::fdiv<0>(regs,&regs.FR0,regs.FR13,regs.FR0);
		/* 82060480h case    4:*/		return 0x82060484;
	}
	return 0x82060484;
} // Block from 82060470h-82060484h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82060484h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82060484( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82060484) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82060484);
		  /* 82060484h */ case    0:  		/* fmr FR1, FR0 */
		/* 82060484h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR0);
		/* 82060484h case    0:*/		return 0x82060488;
		  /* 82060488h */ case    1:  		/* addi R1, R1, 112 */
		/* 82060488h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82060488h case    1:*/		return 0x8206048C;
		  /* 8206048Ch */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 8206048Ch case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206048Ch case    2:*/		return 0x82060490;
		  /* 82060490h */ case    3:  		/* mtspr LR, R12 */
		/* 82060490h case    3:*/		regs.LR = regs.R12;
		/* 82060490h case    3:*/		return 0x82060494;
		  /* 82060494h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 82060494h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82060494h case    4:*/		return 0x82060498;
		  /* 82060498h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82060498h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82060498h case    5:*/		return 0x8206049C;
	}
	return 0x8206049C;
} // Block from 82060484h-8206049Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8206049Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206049C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206049C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206049C);
		  /* 8206049Ch */ case    0:  		/* nop */
		/* 8206049Ch case    0:*/		cpu::op::nop();
		/* 8206049Ch case    0:*/		return 0x820604A0;
	}
	return 0x820604A0;
} // Block from 8206049Ch-820604A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820604A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820604A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820604A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820604A0);
		  /* 820604A0h */ case    0:  		/* mfspr R12, LR */
		/* 820604A0h case    0:*/		regs.R12 = regs.LR;
		/* 820604A0h case    0:*/		return 0x820604A4;
		  /* 820604A4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820604A4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820604A4h case    1:*/		return 0x820604A8;
		  /* 820604A8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820604A8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820604A8h case    2:*/		return 0x820604AC;
		  /* 820604ACh */ case    3:  		/* stwu R1, <#[R1 - 112]> */
		/* 820604ACh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820604ACh case    3:*/		return 0x820604B0;
		  /* 820604B0h */ case    4:  		/* mr R31, R3 */
		/* 820604B0h case    4:*/		regs.R31 = regs.R3;
		/* 820604B0h case    4:*/		return 0x820604B4;
		  /* 820604B4h */ case    5:  		/* addi R3, R1, 80 */
		/* 820604B4h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 820604B4h case    5:*/		return 0x820604B8;
		  /* 820604B8h */ case    6:  		/* bl 161016 */
		/* 820604B8h case    6:*/		regs.LR = 0x820604BC; return 0x820879B0;
		/* 820604B8h case    6:*/		return 0x820604BC;
		  /* 820604BCh */ case    7:  		/* lfd FR0, <#[R31 + 88]> */
		/* 820604BCh case    7:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R31 + 0x00000058) );
		/* 820604BCh case    7:*/		return 0x820604C0;
		  /* 820604C0h */ case    8:  		/* lfd FR13, <#[R1 + 80]> */
		/* 820604C0h case    8:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000050) );
		/* 820604C0h case    8:*/		return 0x820604C4;
		  /* 820604C4h */ case    9:  		/* fcfid FR0, FR0 */
		/* 820604C4h case    9:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 820604C4h case    9:*/		return 0x820604C8;
		  /* 820604C8h */ case   10:  		/* fcfid FR13, FR13 */
		/* 820604C8h case   10:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 820604C8h case   10:*/		return 0x820604CC;
		  /* 820604CCh */ case   11:  		/* lwz R11, <#[R31 + 40]> */
		/* 820604CCh case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 820604CCh case   11:*/		return 0x820604D0;
		  /* 820604D0h */ case   12:  		/* cmpwi CR6, R11, 0 */
		/* 820604D0h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 820604D0h case   12:*/		return 0x820604D4;
		  /* 820604D4h */ case   13:  		/* fdiv FR0, FR13, FR0 */
		/* 820604D4h case   13:*/		cpu::op::fdiv<0>(regs,&regs.FR0,regs.FR13,regs.FR0);
		/* 820604D4h case   13:*/		return 0x820604D8;
		  /* 820604D8h */ case   14:  		/* bc 12, CR6_EQ, 24 */
		/* 820604D8h case   14:*/		if ( regs.CR[6].eq ) { return 0x820604F0;  }
		/* 820604D8h case   14:*/		return 0x820604DC;
		  /* 820604DCh */ case   15:  		/* lfd FR13, <#[R31 + 32]> */
		/* 820604DCh case   15:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R31 + 0x00000020) );
		/* 820604DCh case   15:*/		return 0x820604E0;
		  /* 820604E0h */ case   16:  		/* fsub FR13, FR0, FR13 */
		/* 820604E0h case   16:*/		cpu::op::fsub<0>(regs,&regs.FR13,regs.FR0,regs.FR13);
		/* 820604E0h case   16:*/		return 0x820604E4;
		  /* 820604E4h */ case   17:  		/* lfd FR12, <#[R31 + 24]> */
		/* 820604E4h case   17:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R31 + 0x00000018) );
		/* 820604E4h case   17:*/		return 0x820604E8;
		  /* 820604E8h */ case   18:  		/* fadd FR13, FR13, FR12 */
		/* 820604E8h case   18:*/		cpu::op::fadd<0>(regs,&regs.FR13,regs.FR13,regs.FR12);
		/* 820604E8h case   18:*/		return 0x820604EC;
		  /* 820604ECh */ case   19:  		/* stfd FR13, <#[R31 + 24]> */
		/* 820604ECh case   19:*/		cpu::mem::store64f( regs, regs.FR13, (uint32)(regs.R31 + 0x00000018) );
		/* 820604ECh case   19:*/		return 0x820604F0;
	}
	return 0x820604F0;
} // Block from 820604A0h-820604F0h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820604F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820604F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820604F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820604F0);
		  /* 820604F0h */ case    0:  		/* lis R11, -32256 */
		/* 820604F0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820604F0h case    0:*/		return 0x820604F4;
		  /* 820604F4h */ case    1:  		/* stfd FR0, <#[R31 + 16]> */
		/* 820604F4h case    1:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R31 + 0x00000010) );
		/* 820604F4h case    1:*/		return 0x820604F8;
		  /* 820604F8h */ case    2:  		/* li R10, 0 */
		/* 820604F8h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820604F8h case    2:*/		return 0x820604FC;
		  /* 820604FCh */ case    3:  		/* stw R10, <#[R31 + 40]> */
		/* 820604FCh case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000028) );
		/* 820604FCh case    3:*/		return 0x82060500;
		  /* 82060500h */ case    4:  		/* lfd FR0, <#[R11 + 1808]> */
		/* 82060500h case    4:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000710) );
		/* 82060500h case    4:*/		return 0x82060504;
		  /* 82060504h */ case    5:  		/* stfd FR0, <#[R31 + 32]> */
		/* 82060504h case    5:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R31 + 0x00000020) );
		/* 82060504h case    5:*/		return 0x82060508;
		  /* 82060508h */ case    6:  		/* addi R1, R1, 112 */
		/* 82060508h case    6:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82060508h case    6:*/		return 0x8206050C;
		  /* 8206050Ch */ case    7:  		/* lwz R12, <#[R1 - 8]> */
		/* 8206050Ch case    7:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206050Ch case    7:*/		return 0x82060510;
		  /* 82060510h */ case    8:  		/* mtspr LR, R12 */
		/* 82060510h case    8:*/		regs.LR = regs.R12;
		/* 82060510h case    8:*/		return 0x82060514;
		  /* 82060514h */ case    9:  		/* ld R31, <#[R1 - 16]> */
		/* 82060514h case    9:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82060514h case    9:*/		return 0x82060518;
		  /* 82060518h */ case   10:  		/* bclr 20, CR0_LT */
		/* 82060518h case   10:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82060518h case   10:*/		return 0x8206051C;
	}
	return 0x8206051C;
} // Block from 820604F0h-8206051Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8206051Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206051C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206051C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206051C);
		  /* 8206051Ch */ case    0:  		/* nop */
		/* 8206051Ch case    0:*/		cpu::op::nop();
		/* 8206051Ch case    0:*/		return 0x82060520;
	}
	return 0x82060520;
} // Block from 8206051Ch-82060520h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82060520h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82060520( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82060520) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82060520);
		  /* 82060520h */ case    0:  		/* mfspr R12, LR */
		/* 82060520h case    0:*/		regs.R12 = regs.LR;
		/* 82060520h case    0:*/		return 0x82060524;
		  /* 82060524h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82060524h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82060524h case    1:*/		return 0x82060528;
		  /* 82060528h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82060528h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82060528h case    2:*/		return 0x8206052C;
		  /* 8206052Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8206052Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8206052Ch case    3:*/		return 0x82060530;
		  /* 82060530h */ case    4:  		/* mr R31, R3 */
		/* 82060530h case    4:*/		regs.R31 = regs.R3;
		/* 82060530h case    4:*/		return 0x82060534;
		  /* 82060534h */ case    5:  		/* addi R3, R3, 620 */
		/* 82060534h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x26C);
		/* 82060534h case    5:*/		return 0x82060538;
		  /* 82060538h */ case    6:  		/* bl 191848 */
		/* 82060538h case    6:*/		regs.LR = 0x8206053C; return 0x8208F2A0;
		/* 82060538h case    6:*/		return 0x8206053C;
		  /* 8206053Ch */ case    7:  		/* addi R3, R31, 560 */
		/* 8206053Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x230);
		/* 8206053Ch case    7:*/		return 0x82060540;
		  /* 82060540h */ case    8:  		/* bl 191840 */
		/* 82060540h case    8:*/		regs.LR = 0x82060544; return 0x8208F2A0;
		/* 82060540h case    8:*/		return 0x82060544;
		  /* 82060544h */ case    9:  		/* addi R3, R31, 544 */
		/* 82060544h case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x220);
		/* 82060544h case    9:*/		return 0x82060548;
		  /* 82060548h */ case   10:  		/* bl 191832 */
		/* 82060548h case   10:*/		regs.LR = 0x8206054C; return 0x8208F2A0;
		/* 82060548h case   10:*/		return 0x8206054C;
		  /* 8206054Ch */ case   11:  		/* addi R3, R31, 528 */
		/* 8206054Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x210);
		/* 8206054Ch case   11:*/		return 0x82060550;
		  /* 82060550h */ case   12:  		/* bl 191824 */
		/* 82060550h case   12:*/		regs.LR = 0x82060554; return 0x8208F2A0;
		/* 82060550h case   12:*/		return 0x82060554;
		  /* 82060554h */ case   13:  		/* addi R3, R31, 296 */
		/* 82060554h case   13:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x128);
		/* 82060554h case   13:*/		return 0x82060558;
		  /* 82060558h */ case   14:  		/* bl 186656 */
		/* 82060558h case   14:*/		regs.LR = 0x8206055C; return 0x8208DE78;
		/* 82060558h case   14:*/		return 0x8206055C;
		  /* 8206055Ch */ case   15:  		/* addi R3, R31, 104 */
		/* 8206055Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x68);
		/* 8206055Ch case   15:*/		return 0x82060560;
		  /* 82060560h */ case   16:  		/* bl 189880 */
		/* 82060560h case   16:*/		regs.LR = 0x82060564; return 0x8208EB18;
		/* 82060560h case   16:*/		return 0x82060564;
		  /* 82060564h */ case   17:  		/* addi R1, R1, 96 */
		/* 82060564h case   17:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82060564h case   17:*/		return 0x82060568;
		  /* 82060568h */ case   18:  		/* lwz R12, <#[R1 - 8]> */
		/* 82060568h case   18:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82060568h case   18:*/		return 0x8206056C;
		  /* 8206056Ch */ case   19:  		/* mtspr LR, R12 */
		/* 8206056Ch case   19:*/		regs.LR = regs.R12;
		/* 8206056Ch case   19:*/		return 0x82060570;
		  /* 82060570h */ case   20:  		/* ld R31, <#[R1 - 16]> */
		/* 82060570h case   20:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82060570h case   20:*/		return 0x82060574;
		  /* 82060574h */ case   21:  		/* bclr 20, CR0_LT */
		/* 82060574h case   21:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82060574h case   21:*/		return 0x82060578;
	}
	return 0x82060578;
} // Block from 82060520h-82060578h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82060578h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82060578( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82060578) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82060578);
		  /* 82060578h */ case    0:  		/* mfspr R12, LR */
		/* 82060578h case    0:*/		regs.R12 = regs.LR;
		/* 82060578h case    0:*/		return 0x8206057C;
		  /* 8206057Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8206057Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206057Ch case    1:*/		return 0x82060580;
	}
	return 0x82060580;
} // Block from 82060578h-82060580h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82060580h
// Function '??0Sample@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82060580( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82060580) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82060580);
		  /* 82060580h */ case    0:  		/* std R5, <#[R1 + 32]> */
		/* 82060580h case    0:*/		cpu::mem::store64( regs, regs.R5, (uint32)(regs.R1 + 0x00000020) );
		/* 82060580h case    0:*/		return 0x82060584;
		  /* 82060584h */ case    1:  		/* std R6, <#[R1 + 40]> */
		/* 82060584h case    1:*/		cpu::mem::store64( regs, regs.R6, (uint32)(regs.R1 + 0x00000028) );
		/* 82060584h case    1:*/		return 0x82060588;
		  /* 82060588h */ case    2:  		/* std R7, <#[R1 + 48]> */
		/* 82060588h case    2:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R1 + 0x00000030) );
		/* 82060588h case    2:*/		return 0x8206058C;
		  /* 8206058Ch */ case    3:  		/* std R8, <#[R1 + 56]> */
		/* 8206058Ch case    3:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R1 + 0x00000038) );
		/* 8206058Ch case    3:*/		return 0x82060590;
		  /* 82060590h */ case    4:  		/* std R9, <#[R1 + 64]> */
		/* 82060590h case    4:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000040) );
		/* 82060590h case    4:*/		return 0x82060594;
		  /* 82060594h */ case    5:  		/* std R10, <#[R1 + 72]> */
		/* 82060594h case    5:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000048) );
		/* 82060594h case    5:*/		return 0x82060598;
		  /* 82060598h */ case    6:  		/* stwu R1, <#[R1 - 96]> */
		/* 82060598h case    6:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82060598h case    6:*/		return 0x8206059C;
		  /* 8206059Ch */ case    7:  		/* stw R4, <#[R1 + 124]> */
		/* 8206059Ch case    7:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000007C) );
		/* 8206059Ch case    7:*/		return 0x820605A0;
		  /* 820605A0h */ case    8:  		/* addi R11, R1, 80 */
		/* 820605A0h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820605A0h case    8:*/		return 0x820605A4;
		  /* 820605A4h */ case    9:  		/* addi R10, R1, 128 */
		/* 820605A4h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x80);
		/* 820605A4h case    9:*/		return 0x820605A8;
		  /* 820605A8h */ case   10:  		/* mr R5, R4 */
		/* 820605A8h case   10:*/		regs.R5 = regs.R4;
		/* 820605A8h case   10:*/		return 0x820605AC;
		  /* 820605ACh */ case   11:  		/* li R4, 16 */
		/* 820605ACh case   11:*/		cpu::op::li<0>(regs,&regs.R4,0x10);
		/* 820605ACh case   11:*/		return 0x820605B0;
		  /* 820605B0h */ case   12:  		/* stw R10, <#[R11]> */
		/* 820605B0h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820605B0h case   12:*/		return 0x820605B4;
		  /* 820605B4h */ case   13:  		/* lwz R6, <#[R1 + 80]> */
		/* 820605B4h case   13:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 820605B4h case   13:*/		return 0x820605B8;
		  /* 820605B8h */ case   14:  		/* bl 198952 */
		/* 820605B8h case   14:*/		regs.LR = 0x820605BC; return 0x82090EE0;
		/* 820605B8h case   14:*/		return 0x820605BC;
		  /* 820605BCh */ case   15:  		/* addi R1, R1, 96 */
		/* 820605BCh case   15:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 820605BCh case   15:*/		return 0x820605C0;
		  /* 820605C0h */ case   16:  		/* lwz R12, <#[R1 - 8]> */
		/* 820605C0h case   16:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820605C0h case   16:*/		return 0x820605C4;
		  /* 820605C4h */ case   17:  		/* mtspr LR, R12 */
		/* 820605C4h case   17:*/		regs.LR = regs.R12;
		/* 820605C4h case   17:*/		return 0x820605C8;
		  /* 820605C8h */ case   18:  		/* bclr 20, CR0_LT */
		/* 820605C8h case   18:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820605C8h case   18:*/		return 0x820605CC;
	}
	return 0x820605CC;
} // Block from 82060580h-820605CCh (19 instructions)

//////////////////////////////////////////////////////
// Block at 820605CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820605CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820605CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820605CC);
		  /* 820605CCh */ case    0:  		/* nop */
		/* 820605CCh case    0:*/		cpu::op::nop();
		/* 820605CCh case    0:*/		return 0x820605D0;
	}
	return 0x820605D0;
} // Block from 820605CCh-820605D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820605D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820605D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820605D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820605D0);
		  /* 820605D0h */ case    0:  		/* mfspr R12, LR */
		/* 820605D0h case    0:*/		regs.R12 = regs.LR;
		/* 820605D0h case    0:*/		return 0x820605D4;
		  /* 820605D4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820605D4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820605D4h case    1:*/		return 0x820605D8;
		  /* 820605D8h */ case    2:  		/* std R5, <#[R1 + 32]> */
		/* 820605D8h case    2:*/		cpu::mem::store64( regs, regs.R5, (uint32)(regs.R1 + 0x00000020) );
		/* 820605D8h case    2:*/		return 0x820605DC;
		  /* 820605DCh */ case    3:  		/* std R6, <#[R1 + 40]> */
		/* 820605DCh case    3:*/		cpu::mem::store64( regs, regs.R6, (uint32)(regs.R1 + 0x00000028) );
		/* 820605DCh case    3:*/		return 0x820605E0;
		  /* 820605E0h */ case    4:  		/* std R7, <#[R1 + 48]> */
		/* 820605E0h case    4:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R1 + 0x00000030) );
		/* 820605E0h case    4:*/		return 0x820605E4;
		  /* 820605E4h */ case    5:  		/* std R8, <#[R1 + 56]> */
		/* 820605E4h case    5:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R1 + 0x00000038) );
		/* 820605E4h case    5:*/		return 0x820605E8;
		  /* 820605E8h */ case    6:  		/* std R9, <#[R1 + 64]> */
		/* 820605E8h case    6:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000040) );
		/* 820605E8h case    6:*/		return 0x820605EC;
		  /* 820605ECh */ case    7:  		/* std R10, <#[R1 + 72]> */
		/* 820605ECh case    7:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000048) );
		/* 820605ECh case    7:*/		return 0x820605F0;
		  /* 820605F0h */ case    8:  		/* stwu R1, <#[R1 - 96]> */
		/* 820605F0h case    8:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820605F0h case    8:*/		return 0x820605F4;
		  /* 820605F4h */ case    9:  		/* stw R4, <#[R1 + 124]> */
		/* 820605F4h case    9:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000007C) );
		/* 820605F4h case    9:*/		return 0x820605F8;
		  /* 820605F8h */ case   10:  		/* addi R11, R1, 80 */
		/* 820605F8h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820605F8h case   10:*/		return 0x820605FC;
		  /* 820605FCh */ case   11:  		/* addi R10, R1, 128 */
		/* 820605FCh case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x80);
		/* 820605FCh case   11:*/		return 0x82060600;
		  /* 82060600h */ case   12:  		/* mr R5, R4 */
		/* 82060600h case   12:*/		regs.R5 = regs.R4;
		/* 82060600h case   12:*/		return 0x82060604;
		  /* 82060604h */ case   13:  		/* li R4, 80 */
		/* 82060604h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x50);
		/* 82060604h case   13:*/		return 0x82060608;
		  /* 82060608h */ case   14:  		/* stw R10, <#[R11]> */
		/* 82060608h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82060608h case   14:*/		return 0x8206060C;
		  /* 8206060Ch */ case   15:  		/* lwz R6, <#[R1 + 80]> */
		/* 8206060Ch case   15:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 8206060Ch case   15:*/		return 0x82060610;
		  /* 82060610h */ case   16:  		/* bl 199320 */
		/* 82060610h case   16:*/		regs.LR = 0x82060614; return 0x820910A8;
		/* 82060610h case   16:*/		return 0x82060614;
		  /* 82060614h */ case   17:  		/* addi R1, R1, 96 */
		/* 82060614h case   17:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82060614h case   17:*/		return 0x82060618;
		  /* 82060618h */ case   18:  		/* lwz R12, <#[R1 - 8]> */
		/* 82060618h case   18:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82060618h case   18:*/		return 0x8206061C;
		  /* 8206061Ch */ case   19:  		/* mtspr LR, R12 */
		/* 8206061Ch case   19:*/		regs.LR = regs.R12;
		/* 8206061Ch case   19:*/		return 0x82060620;
		  /* 82060620h */ case   20:  		/* bclr 20, CR0_LT */
		/* 82060620h case   20:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82060620h case   20:*/		return 0x82060624;
	}
	return 0x82060624;
} // Block from 820605D0h-82060624h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82060624h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82060624( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82060624) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82060624);
		  /* 82060624h */ case    0:  		/* nop */
		/* 82060624h case    0:*/		cpu::op::nop();
		/* 82060624h case    0:*/		return 0x82060628;
	}
	return 0x82060628;
} // Block from 82060624h-82060628h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82060628h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82060628( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82060628) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82060628);
		  /* 82060628h */ case    0:  		/* mfspr R12, LR */
		/* 82060628h case    0:*/		regs.R12 = regs.LR;
		/* 82060628h case    0:*/		return 0x8206062C;
		  /* 8206062Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8206062Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206062Ch case    1:*/		return 0x82060630;
		  /* 82060630h */ case    2:  		/* std R5, <#[R1 + 32]> */
		/* 82060630h case    2:*/		cpu::mem::store64( regs, regs.R5, (uint32)(regs.R1 + 0x00000020) );
		/* 82060630h case    2:*/		return 0x82060634;
		  /* 82060634h */ case    3:  		/* std R6, <#[R1 + 40]> */
		/* 82060634h case    3:*/		cpu::mem::store64( regs, regs.R6, (uint32)(regs.R1 + 0x00000028) );
		/* 82060634h case    3:*/		return 0x82060638;
		  /* 82060638h */ case    4:  		/* std R7, <#[R1 + 48]> */
		/* 82060638h case    4:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R1 + 0x00000030) );
		/* 82060638h case    4:*/		return 0x8206063C;
		  /* 8206063Ch */ case    5:  		/* std R8, <#[R1 + 56]> */
		/* 8206063Ch case    5:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R1 + 0x00000038) );
		/* 8206063Ch case    5:*/		return 0x82060640;
		  /* 82060640h */ case    6:  		/* std R9, <#[R1 + 64]> */
		/* 82060640h case    6:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000040) );
		/* 82060640h case    6:*/		return 0x82060644;
		  /* 82060644h */ case    7:  		/* std R10, <#[R1 + 72]> */
		/* 82060644h case    7:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000048) );
		/* 82060644h case    7:*/		return 0x82060648;
		  /* 82060648h */ case    8:  		/* stwu R1, <#[R1 - 96]> */
		/* 82060648h case    8:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82060648h case    8:*/		return 0x8206064C;
		  /* 8206064Ch */ case    9:  		/* stw R4, <#[R1 + 124]> */
		/* 8206064Ch case    9:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000007C) );
		/* 8206064Ch case    9:*/		return 0x82060650;
		  /* 82060650h */ case   10:  		/* addi R11, R1, 80 */
		/* 82060650h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 82060650h case   10:*/		return 0x82060654;
		  /* 82060654h */ case   11:  		/* addi R10, R1, 128 */
		/* 82060654h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x80);
		/* 82060654h case   11:*/		return 0x82060658;
		  /* 82060658h */ case   12:  		/* mr R5, R4 */
		/* 82060658h case   12:*/		regs.R5 = regs.R4;
		/* 82060658h case   12:*/		return 0x8206065C;
		  /* 8206065Ch */ case   13:  		/* li R4, 80 */
		/* 8206065Ch case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x50);
		/* 8206065Ch case   13:*/		return 0x82060660;
		  /* 82060660h */ case   14:  		/* stw R10, <#[R11]> */
		/* 82060660h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82060660h case   14:*/		return 0x82060664;
		  /* 82060664h */ case   15:  		/* lwz R6, <#[R1 + 80]> */
		/* 82060664h case   15:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 82060664h case   15:*/		return 0x82060668;
		  /* 82060668h */ case   16:  		/* bl 198776 */
		/* 82060668h case   16:*/		regs.LR = 0x8206066C; return 0x82090EE0;
		/* 82060668h case   16:*/		return 0x8206066C;
		  /* 8206066Ch */ case   17:  		/* addi R1, R1, 96 */
		/* 8206066Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8206066Ch case   17:*/		return 0x82060670;
		  /* 82060670h */ case   18:  		/* lwz R12, <#[R1 - 8]> */
		/* 82060670h case   18:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82060670h case   18:*/		return 0x82060674;
		  /* 82060674h */ case   19:  		/* mtspr LR, R12 */
		/* 82060674h case   19:*/		regs.LR = regs.R12;
		/* 82060674h case   19:*/		return 0x82060678;
		  /* 82060678h */ case   20:  		/* bclr 20, CR0_LT */
		/* 82060678h case   20:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82060678h case   20:*/		return 0x8206067C;
	}
	return 0x8206067C;
} // Block from 82060628h-8206067Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 8206067Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206067C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206067C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206067C);
		  /* 8206067Ch */ case    0:  		/* nop */
		/* 8206067Ch case    0:*/		cpu::op::nop();
		/* 8206067Ch case    0:*/		return 0x82060680;
	}
	return 0x82060680;
} // Block from 8206067Ch-82060680h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82060680h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82060680( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82060680) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82060680);
		  /* 82060680h */ case    0:  		/* mfspr R12, LR */
		/* 82060680h case    0:*/		regs.R12 = regs.LR;
		/* 82060680h case    0:*/		return 0x82060684;
		  /* 82060684h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82060684h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82060684h case    1:*/		return 0x82060688;
		  /* 82060688h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82060688h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82060688h case    2:*/		return 0x8206068C;
		  /* 8206068Ch */ case    3:  		/* stwu R1, <#[R1 - 128]> */
		/* 8206068Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8206068Ch case    3:*/		return 0x82060690;
		  /* 82060690h */ case    4:  		/* mr R31, R3 */
		/* 82060690h case    4:*/		regs.R31 = regs.R3;
		/* 82060690h case    4:*/		return 0x82060694;
		  /* 82060694h */ case    5:  		/* addi R4, R1, 84 */
		/* 82060694h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x54);
		/* 82060694h case    5:*/		return 0x82060698;
		  /* 82060698h */ case    6:  		/* addi R3, R1, 80 */
		/* 82060698h case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82060698h case    6:*/		return 0x8206069C;
		  /* 8206069Ch */ case    7:  		/* bl -948 */
		/* 8206069Ch case    7:*/		regs.LR = 0x820606A0; return 0x820602E8;
		/* 8206069Ch case    7:*/		return 0x820606A0;
		  /* 820606A0h */ case    8:  		/* vspltisw VR63, 0 */
		/* 820606A0h case    8:*/		cpu::op::vspltisw<0,0>(regs,&regs.VR63);
		/* 820606A0h case    8:*/		return 0x820606A4;
		  /* 820606A4h */ case    9:  		/* lis R11, -32256 */
		/* 820606A4h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820606A4h case    9:*/		return 0x820606A8;
		  /* 820606A8h */ case   10:  		/* lfs FR13, <#[R1 + 84]> */
		/* 820606A8h case   10:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000054) );
		/* 820606A8h case   10:*/		return 0x820606AC;
		  /* 820606ACh */ case   11:  		/* li R8, 48 */
		/* 820606ACh case   11:*/		cpu::op::li<0>(regs,&regs.R8,0x30);
		/* 820606ACh case   11:*/		return 0x820606B0;
		  /* 820606B0h */ case   12:  		/* addi R10, R1, 96 */
		/* 820606B0h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x60);
		/* 820606B0h case   12:*/		return 0x820606B4;
		  /* 820606B4h */ case   13:  		/* stfs FR13, <#[R1 + 104]> */
		/* 820606B4h case   13:*/		cpu::mem::store32f( regs, regs.FR13, (uint32)(regs.R1 + 0x00000068) );
		/* 820606B4h case   13:*/		return 0x820606B8;
		  /* 820606B8h */ case   14:  		/* vupkd3d128 VR63, VR63, 1 */
		/* 820606B8h case   14:*/		cpu::op::vupkd3d128<0,1>(regs,&regs.VR63,regs.VR63);
		/* 820606B8h case   14:*/		return 0x820606BC;
		  /* 820606BCh */ case   15:  		/* li R9, 16 */
		/* 820606BCh case   15:*/		cpu::op::li<0>(regs,&regs.R9,0x10);
		/* 820606BCh case   15:*/		return 0x820606C0;
		  /* 820606C0h */ case   16:  		/* li R7, 32 */
		/* 820606C0h case   16:*/		cpu::op::li<0>(regs,&regs.R7,0x20);
		/* 820606C0h case   16:*/		return 0x820606C4;
		  /* 820606C4h */ case   17:  		/* lfs FR0, <#[R11 + 1816]> */
		/* 820606C4h case   17:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000718) );
		/* 820606C4h case   17:*/		return 0x820606C8;
		  /* 820606C8h */ case   18:  		/* mr R3, R31 */
		/* 820606C8h case   18:*/		regs.R3 = regs.R31;
		/* 820606C8h case   18:*/		return 0x820606CC;
		  /* 820606CCh */ case   19:  		/* stfs FR0, <#[R1 + 108]> */
		/* 820606CCh case   19:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0x0000006C) );
		/* 820606CCh case   19:*/		return 0x820606D0;
		  /* 820606D0h */ case   20:  		/* vpermwi128 VR62, VR63, 186 */
		/* 820606D0h case   20:*/		cpu::op::vpermwi128<0,186>(regs,&regs.VR62,regs.VR63);
		/* 820606D0h case   20:*/		return 0x820606D4;
		  /* 820606D4h */ case   21:  		/* vpermwi128 VR63, VR63, 171 */
		/* 820606D4h case   21:*/		cpu::op::vpermwi128<0,171>(regs,&regs.VR63,regs.VR63);
		/* 820606D4h case   21:*/		return 0x820606D8;
		  /* 820606D8h */ case   22:  		/* stvx VR62, <#[R31 + R9]> */
		/* 820606D8h case   22:*/		cpu::mem::stvx( regs, regs.VR62, (uint32)(regs.R31 + regs.R9 + 0x00000000) );
		/* 820606D8h case   22:*/		return 0x820606DC;
		  /* 820606DCh */ case   23:  		/* stvx VR63, <#[R31 + R8]> */
		/* 820606DCh case   23:*/		cpu::mem::stvx( regs, regs.VR63, (uint32)(regs.R31 + regs.R8 + 0x00000000) );
		/* 820606DCh case   23:*/		return 0x820606E0;
		  /* 820606E0h */ case   24:  		/* lfs FR0, <#[R1 + 80]> */
		/* 820606E0h case   24:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 820606E0h case   24:*/		return 0x820606E4;
		  /* 820606E4h */ case   25:  		/* fneg FR12, FR0 */
		/* 820606E4h case   25:*/		cpu::op::fneg<0>(regs,&regs.FR12,regs.FR0);
		/* 820606E4h case   25:*/		return 0x820606E8;
		  /* 820606E8h */ case   26:  		/* stfs FR0, <#[R1 + 96]> */
		/* 820606E8h case   26:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000060) );
		/* 820606E8h case   26:*/		return 0x820606EC;
		  /* 820606ECh */ case   27:  		/* stfs FR12, <#[R1 + 100]> */
		/* 820606ECh case   27:*/		cpu::mem::store32f( regs, regs.FR12, (uint32)(regs.R1 + 0x00000064) );
		/* 820606ECh case   27:*/		return 0x820606F0;
		  /* 820606F0h */ case   28:  		/* lvx VR63, <#[R10]> */
		/* 820606F0h case   28:*/		cpu::mem::lvx( regs, &regs.VR63, (uint32)(regs.R10 + 0x00000000) );
		/* 820606F0h case   28:*/		return 0x820606F4;
		  /* 820606F4h */ case   29:  		/* vpermwi128 VR62, VR63, 183 */
		/* 820606F4h case   29:*/		cpu::op::vpermwi128<0,183>(regs,&regs.VR62,regs.VR63);
		/* 820606F4h case   29:*/		return 0x820606F8;
	}
	return 0x820606F8;
} // Block from 82060680h-820606F8h (30 instructions)

//////////////////////////////////////////////////////
// Block at 820606F8h
// Function '?Initialize@Sample@@UAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820606F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820606F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820606F8);
		  /* 820606F8h */ case    0:  		/* vpermwi128 VR63, VR63, 59 */
		/* 820606F8h case    0:*/		cpu::op::vpermwi128<0,59>(regs,&regs.VR63,regs.VR63);
		/* 820606F8h case    0:*/		return 0x820606FC;
		  /* 820606FCh */ case    1:  		/* stvx VR62, <#[R31]> */
		/* 820606FCh case    1:*/		cpu::mem::stvx( regs, regs.VR62, (uint32)(regs.R31 + 0x00000000) );
		/* 820606FCh case    1:*/		return 0x82060700;
		  /* 82060700h */ case    2:  		/* stvx VR63, <#[R31 + R7]> */
		/* 82060700h case    2:*/		cpu::mem::stvx( regs, regs.VR63, (uint32)(regs.R31 + regs.R7 + 0x00000000) );
		/* 82060700h case    2:*/		return 0x82060704;
		  /* 82060704h */ case    3:  		/* addi R1, R1, 128 */
		/* 82060704h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82060704h case    3:*/		return 0x82060708;
		  /* 82060708h */ case    4:  		/* lwz R12, <#[R1 - 8]> */
		/* 82060708h case    4:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82060708h case    4:*/		return 0x8206070C;
		  /* 8206070Ch */ case    5:  		/* mtspr LR, R12 */
		/* 8206070Ch case    5:*/		regs.LR = regs.R12;
		/* 8206070Ch case    5:*/		return 0x82060710;
		  /* 82060710h */ case    6:  		/* ld R31, <#[R1 - 16]> */
		/* 82060710h case    6:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82060710h case    6:*/		return 0x82060714;
		  /* 82060714h */ case    7:  		/* bclr 20, CR0_LT */
		/* 82060714h case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82060714h case    7:*/		return 0x82060718;
	}
	return 0x82060718;
} // Block from 820606F8h-82060718h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82060718h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82060718( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82060718) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82060718);
		  /* 82060718h */ case    0:  		/* mfspr R12, LR */
		/* 82060718h case    0:*/		regs.R12 = regs.LR;
		/* 82060718h case    0:*/		return 0x8206071C;
		  /* 8206071Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8206071Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206071Ch case    1:*/		return 0x82060720;
		  /* 82060720h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82060720h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82060720h case    2:*/		return 0x82060724;
		  /* 82060724h */ case    3:  		/* stwu R1, <#[R1 - 128]> */
		/* 82060724h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82060724h case    3:*/		return 0x82060728;
		  /* 82060728h */ case    4:  		/* mr R31, R3 */
		/* 82060728h case    4:*/		regs.R31 = regs.R3;
		/* 82060728h case    4:*/		return 0x8206072C;
		  /* 8206072Ch */ case    5:  		/* addi R4, R1, 84 */
		/* 8206072Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x54);
		/* 8206072Ch case    5:*/		return 0x82060730;
		  /* 82060730h */ case    6:  		/* addi R3, R1, 80 */
		/* 82060730h case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82060730h case    6:*/		return 0x82060734;
		  /* 82060734h */ case    7:  		/* bl -1100 */
		/* 82060734h case    7:*/		regs.LR = 0x82060738; return 0x820602E8;
		/* 82060734h case    7:*/		return 0x82060738;
		  /* 82060738h */ case    8:  		/* vspltisw VR63, 0 */
		/* 82060738h case    8:*/		cpu::op::vspltisw<0,0>(regs,&regs.VR63);
		/* 82060738h case    8:*/		return 0x8206073C;
		  /* 8206073Ch */ case    9:  		/* lis R11, -32256 */
		/* 8206073Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8206073Ch case    9:*/		return 0x82060740;
		  /* 82060740h */ case   10:  		/* lfs FR13, <#[R1 + 84]> */
		/* 82060740h case   10:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000054) );
		/* 82060740h case   10:*/		return 0x82060744;
		  /* 82060744h */ case   11:  		/* li R8, 48 */
		/* 82060744h case   11:*/		cpu::op::li<0>(regs,&regs.R8,0x30);
		/* 82060744h case   11:*/		return 0x82060748;
		  /* 82060748h */ case   12:  		/* addi R10, R1, 96 */
		/* 82060748h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x60);
		/* 82060748h case   12:*/		return 0x8206074C;
		  /* 8206074Ch */ case   13:  		/* stfs FR13, <#[R1 + 104]> */
		/* 8206074Ch case   13:*/		cpu::mem::store32f( regs, regs.FR13, (uint32)(regs.R1 + 0x00000068) );
		/* 8206074Ch case   13:*/		return 0x82060750;
		  /* 82060750h */ case   14:  		/* vupkd3d128 VR63, VR63, 1 */
		/* 82060750h case   14:*/		cpu::op::vupkd3d128<0,1>(regs,&regs.VR63,regs.VR63);
		/* 82060750h case   14:*/		return 0x82060754;
		  /* 82060754h */ case   15:  		/* li R9, 32 */
		/* 82060754h case   15:*/		cpu::op::li<0>(regs,&regs.R9,0x20);
		/* 82060754h case   15:*/		return 0x82060758;
		  /* 82060758h */ case   16:  		/* li R7, 16 */
		/* 82060758h case   16:*/		cpu::op::li<0>(regs,&regs.R7,0x10);
		/* 82060758h case   16:*/		return 0x8206075C;
		  /* 8206075Ch */ case   17:  		/* lfs FR0, <#[R11 + 1816]> */
		/* 8206075Ch case   17:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000718) );
		/* 8206075Ch case   17:*/		return 0x82060760;
		  /* 82060760h */ case   18:  		/* mr R3, R31 */
		/* 82060760h case   18:*/		regs.R3 = regs.R31;
		/* 82060760h case   18:*/		return 0x82060764;
		  /* 82060764h */ case   19:  		/* stfs FR0, <#[R1 + 108]> */
		/* 82060764h case   19:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0x0000006C) );
		/* 82060764h case   19:*/		return 0x82060768;
		  /* 82060768h */ case   20:  		/* vpermwi128 VR62, VR63, 174 */
		/* 82060768h case   20:*/		cpu::op::vpermwi128<0,174>(regs,&regs.VR62,regs.VR63);
		/* 82060768h case   20:*/		return 0x8206076C;
		  /* 8206076Ch */ case   21:  		/* vpermwi128 VR63, VR63, 171 */
		/* 8206076Ch case   21:*/		cpu::op::vpermwi128<0,171>(regs,&regs.VR63,regs.VR63);
		/* 8206076Ch case   21:*/		return 0x82060770;
		  /* 82060770h */ case   22:  		/* stvx VR62, <#[R31 + R9]> */
		/* 82060770h case   22:*/		cpu::mem::stvx( regs, regs.VR62, (uint32)(regs.R31 + regs.R9 + 0x00000000) );
		/* 82060770h case   22:*/		return 0x82060774;
		  /* 82060774h */ case   23:  		/* stvx VR63, <#[R31 + R8]> */
		/* 82060774h case   23:*/		cpu::mem::stvx( regs, regs.VR63, (uint32)(regs.R31 + regs.R8 + 0x00000000) );
		/* 82060774h case   23:*/		return 0x82060778;
		  /* 82060778h */ case   24:  		/* lfs FR0, <#[R1 + 80]> */
		/* 82060778h case   24:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 82060778h case   24:*/		return 0x8206077C;
		  /* 8206077Ch */ case   25:  		/* fneg FR12, FR0 */
		/* 8206077Ch case   25:*/		cpu::op::fneg<0>(regs,&regs.FR12,regs.FR0);
		/* 8206077Ch case   25:*/		return 0x82060780;
		  /* 82060780h */ case   26:  		/* stfs FR0, <#[R1 + 96]> */
		/* 82060780h case   26:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000060) );
		/* 82060780h case   26:*/		return 0x82060784;
		  /* 82060784h */ case   27:  		/* stfs FR12, <#[R1 + 100]> */
		/* 82060784h case   27:*/		cpu::mem::store32f( regs, regs.FR12, (uint32)(regs.R1 + 0x00000064) );
		/* 82060784h case   27:*/		return 0x82060788;
		  /* 82060788h */ case   28:  		/* lvx VR63, <#[R10]> */
		/* 82060788h case   28:*/		cpu::mem::lvx( regs, &regs.VR63, (uint32)(regs.R10 + 0x00000000) );
		/* 82060788h case   28:*/		return 0x8206078C;
		  /* 8206078Ch */ case   29:  		/* vpermwi128 VR62, VR63, 143 */
		/* 8206078Ch case   29:*/		cpu::op::vpermwi128<0,143>(regs,&regs.VR62,regs.VR63);
		/* 8206078Ch case   29:*/		return 0x82060790;
		  /* 82060790h */ case   30:  		/* vpermwi128 VR63, VR63, 111 */
		/* 82060790h case   30:*/		cpu::op::vpermwi128<0,111>(regs,&regs.VR63,regs.VR63);
		/* 82060790h case   30:*/		return 0x82060794;
		  /* 82060794h */ case   31:  		/* stvx VR62, <#[R31]> */
		/* 82060794h case   31:*/		cpu::mem::stvx( regs, regs.VR62, (uint32)(regs.R31 + 0x00000000) );
		/* 82060794h case   31:*/		return 0x82060798;
		  /* 82060798h */ case   32:  		/* stvx VR63, <#[R31 + R7]> */
		/* 82060798h case   32:*/		cpu::mem::stvx( regs, regs.VR63, (uint32)(regs.R31 + regs.R7 + 0x00000000) );
		/* 82060798h case   32:*/		return 0x8206079C;
		  /* 8206079Ch */ case   33:  		/* addi R1, R1, 128 */
		/* 8206079Ch case   33:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8206079Ch case   33:*/		return 0x820607A0;
		  /* 820607A0h */ case   34:  		/* lwz R12, <#[R1 - 8]> */
		/* 820607A0h case   34:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820607A0h case   34:*/		return 0x820607A4;
		  /* 820607A4h */ case   35:  		/* mtspr LR, R12 */
		/* 820607A4h case   35:*/		regs.LR = regs.R12;
		/* 820607A4h case   35:*/		return 0x820607A8;
		  /* 820607A8h */ case   36:  		/* ld R31, <#[R1 - 16]> */
		/* 820607A8h case   36:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820607A8h case   36:*/		return 0x820607AC;
		  /* 820607ACh */ case   37:  		/* bclr 20, CR0_LT */
		/* 820607ACh case   37:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820607ACh case   37:*/		return 0x820607B0;
	}
	return 0x820607B0;
} // Block from 82060718h-820607B0h (38 instructions)

//////////////////////////////////////////////////////
// Block at 820607B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820607B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820607B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820607B0);
		  /* 820607B0h */ case    0:  		/* mfspr R12, LR */
		/* 820607B0h case    0:*/		regs.R12 = regs.LR;
		/* 820607B0h case    0:*/		return 0x820607B4;
		  /* 820607B4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820607B4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820607B4h case    1:*/		return 0x820607B8;
		  /* 820607B8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820607B8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820607B8h case    2:*/		return 0x820607BC;
		  /* 820607BCh */ case    3:  		/* stwu R1, <#[R1 - 112]> */
		/* 820607BCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820607BCh case    3:*/		return 0x820607C0;
		  /* 820607C0h */ case    4:  		/* mr R31, R3 */
		/* 820607C0h case    4:*/		regs.R31 = regs.R3;
		/* 820607C0h case    4:*/		return 0x820607C4;
		  /* 820607C4h */ case    5:  		/* addi R3, R3, 88 */
		/* 820607C4h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x58);
		/* 820607C4h case    5:*/		return 0x820607C8;
		  /* 820607C8h */ case    6:  		/* bl 160264 */
		/* 820607C8h case    6:*/		regs.LR = 0x820607CC; return 0x820879D0;
		/* 820607C8h case    6:*/		return 0x820607CC;
		  /* 820607CCh */ case    7:  		/* addi R3, R1, 80 */
		/* 820607CCh case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 820607CCh case    7:*/		return 0x820607D0;
		  /* 820607D0h */ case    8:  		/* bl 160224 */
		/* 820607D0h case    8:*/		regs.LR = 0x820607D4; return 0x820879B0;
		/* 820607D0h case    8:*/		return 0x820607D4;
		  /* 820607D4h */ case    9:  		/* lis R10, -32256 */
		/* 820607D4h case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 820607D4h case    9:*/		return 0x820607D8;
		  /* 820607D8h */ case   10:  		/* lfd FR13, <#[R1 + 80]> */
		/* 820607D8h case   10:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000050) );
		/* 820607D8h case   10:*/		return 0x820607DC;
		  /* 820607DCh */ case   11:  		/* li R11, 0 */
		/* 820607DCh case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820607DCh case   11:*/		return 0x820607E0;
		  /* 820607E0h */ case   12:  		/* fcfid FR13, FR13 */
		/* 820607E0h case   12:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 820607E0h case   12:*/		return 0x820607E4;
		  /* 820607E4h */ case   13:  		/* mr R3, R31 */
		/* 820607E4h case   13:*/		regs.R3 = regs.R31;
		/* 820607E4h case   13:*/		return 0x820607E8;
		  /* 820607E8h */ case   14:  		/* stw R11, <#[R31 + 40]> */
		/* 820607E8h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 820607E8h case   14:*/		return 0x820607EC;
		  /* 820607ECh */ case   15:  		/* sth R11, <#[R31 + 44]> */
		/* 820607ECh case   15:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 820607ECh case   15:*/		return 0x820607F0;
		  /* 820607F0h */ case   16:  		/* lfd FR0, <#[R10 + 1808]> */
		/* 820607F0h case   16:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000710) );
		/* 820607F0h case   16:*/		return 0x820607F4;
		  /* 820607F4h */ case   17:  		/* stw R11, <#[R31 + 76]> */
		/* 820607F4h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000004C) );
		/* 820607F4h case   17:*/		return 0x820607F8;
		  /* 820607F8h */ case   18:  		/* stfd FR0, <#[R31 + 32]> */
		/* 820607F8h case   18:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R31 + 0x00000020) );
		/* 820607F8h case   18:*/		return 0x820607FC;
		  /* 820607FCh */ case   19:  		/* lfd FR0, <#[R31 + 88]> */
		/* 820607FCh case   19:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R31 + 0x00000058) );
		/* 820607FCh case   19:*/		return 0x82060800;
		  /* 82060800h */ case   20:  		/* fcfid FR0, FR0 */
		/* 82060800h case   20:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 82060800h case   20:*/		return 0x82060804;
		  /* 82060804h */ case   21:  		/* fdiv FR0, FR13, FR0 */
		/* 82060804h case   21:*/		cpu::op::fdiv<0>(regs,&regs.FR0,regs.FR13,regs.FR0);
		/* 82060804h case   21:*/		return 0x82060808;
		  /* 82060808h */ case   22:  		/* stfd FR0, <#[R31 + 8]> */
		/* 82060808h case   22:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R31 + 0x00000008) );
		/* 82060808h case   22:*/		return 0x8206080C;
		  /* 8206080Ch */ case   23:  		/* stfd FR0, <#[R31]> */
		/* 8206080Ch case   23:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R31 + 0x00000000) );
		/* 8206080Ch case   23:*/		return 0x82060810;
		  /* 82060810h */ case   24:  		/* stfd FR0, <#[R31 + 24]> */
		/* 82060810h case   24:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R31 + 0x00000018) );
		/* 82060810h case   24:*/		return 0x82060814;
		  /* 82060814h */ case   25:  		/* stfd FR0, <#[R31 + 16]> */
		/* 82060814h case   25:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R31 + 0x00000010) );
		/* 82060814h case   25:*/		return 0x82060818;
		  /* 82060818h */ case   26:  		/* stfd FR0, <#[R31 + 80]> */
		/* 82060818h case   26:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R31 + 0x00000050) );
		/* 82060818h case   26:*/		return 0x8206081C;
		  /* 8206081Ch */ case   27:  		/* addi R1, R1, 112 */
		/* 8206081Ch case   27:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8206081Ch case   27:*/		return 0x82060820;
		  /* 82060820h */ case   28:  		/* lwz R12, <#[R1 - 8]> */
		/* 82060820h case   28:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82060820h case   28:*/		return 0x82060824;
		  /* 82060824h */ case   29:  		/* mtspr LR, R12 */
		/* 82060824h case   29:*/		regs.LR = regs.R12;
		/* 82060824h case   29:*/		return 0x82060828;
		  /* 82060828h */ case   30:  		/* ld R31, <#[R1 - 16]> */
		/* 82060828h case   30:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82060828h case   30:*/		return 0x8206082C;
		  /* 8206082Ch */ case   31:  		/* bclr 20, CR0_LT */
		/* 8206082Ch case   31:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206082Ch case   31:*/		return 0x82060830;
	}
	return 0x82060830;
} // Block from 820607B0h-82060830h (32 instructions)

//////////////////////////////////////////////////////
// Block at 82060830h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82060830( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82060830) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82060830);
		  /* 82060830h */ case    0:  		/* mfspr R12, LR */
		/* 82060830h case    0:*/		regs.R12 = regs.LR;
		/* 82060830h case    0:*/		return 0x82060834;
		  /* 82060834h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82060834h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82060834h case    1:*/		return 0x82060838;
		  /* 82060838h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82060838h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82060838h case    2:*/		return 0x8206083C;
		  /* 8206083Ch */ case    3:  		/* stwu R1, <#[R1 - 112]> */
		/* 8206083Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8206083Ch case    3:*/		return 0x82060840;
		  /* 82060840h */ case    4:  		/* mr R31, R3 */
		/* 82060840h case    4:*/		regs.R31 = regs.R3;
		/* 82060840h case    4:*/		return 0x82060844;
		  /* 82060844h */ case    5:  		/* addi R3, R1, 80 */
		/* 82060844h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82060844h case    5:*/		return 0x82060848;
		  /* 82060848h */ case    6:  		/* bl 160104 */
		/* 82060848h case    6:*/		regs.LR = 0x8206084C; return 0x820879B0;
		/* 82060848h case    6:*/		return 0x8206084C;
		  /* 8206084Ch */ case    7:  		/* lfd FR0, <#[R31 + 88]> */
		/* 8206084Ch case    7:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R31 + 0x00000058) );
		/* 8206084Ch case    7:*/		return 0x82060850;
		  /* 82060850h */ case    8:  		/* lfd FR13, <#[R1 + 80]> */
		/* 82060850h case    8:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000050) );
		/* 82060850h case    8:*/		return 0x82060854;
		  /* 82060854h */ case    9:  		/* fcfid FR0, FR0 */
		/* 82060854h case    9:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 82060854h case    9:*/		return 0x82060858;
		  /* 82060858h */ case   10:  		/* fcfid FR13, FR13 */
		/* 82060858h case   10:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 82060858h case   10:*/		return 0x8206085C;
		  /* 8206085Ch */ case   11:  		/* lfd FR11, <#[R31 + 80]> */
		/* 8206085Ch case   11:*/		cpu::mem::load64f( regs, &regs.FR11, (uint32)(regs.R31 + 0x00000050) );
		/* 8206085Ch case   11:*/		return 0x82060860;
		  /* 82060860h */ case   12:  		/* lis R11, -32256 */
		/* 82060860h case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82060860h case   12:*/		return 0x82060864;
		  /* 82060864h */ case   13:  		/* lfd FR12, <#[R11 + 1848]> */
		/* 82060864h case   13:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R11 + 0x00000738) );
		/* 82060864h case   13:*/		return 0x82060868;
		  /* 82060868h */ case   14:  		/* fdiv FR0, FR13, FR0 */
		/* 82060868h case   14:*/		cpu::op::fdiv<0>(regs,&regs.FR0,regs.FR13,regs.FR0);
		/* 82060868h case   14:*/		return 0x8206086C;
		  /* 8206086Ch */ case   15:  		/* fsub FR13, FR0, FR11 */
		/* 8206086Ch case   15:*/		cpu::op::fsub<0>(regs,&regs.FR13,regs.FR0,regs.FR11);
		/* 8206086Ch case   15:*/		return 0x82060870;
		  /* 82060870h */ case   16:  		/* fcmpu CR6, FR13, FR12 */
		/* 82060870h case   16:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR12);
		/* 82060870h case   16:*/		return 0x82060874;
		  /* 82060874h */ case   17:  		/* bc 4, CR6_GT, 64 */
		/* 82060874h case   17:*/		if ( !regs.CR[6].gt ) { return 0x820608B4;  }
		/* 82060874h case   17:*/		return 0x82060878;
		  /* 82060878h */ case   18:  		/* lwz R11, <#[R31 + 76]> */
		/* 82060878h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000004C) );
		/* 82060878h case   18:*/		return 0x8206087C;
		  /* 8206087Ch */ case   19:  		/* stfd FR0, <#[R31 + 80]> */
		/* 8206087Ch case   19:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R31 + 0x00000050) );
		/* 8206087Ch case   19:*/		return 0x82060880;
		  /* 82060880h */ case   20:  		/* lis R10, -32256 */
		/* 82060880h case   20:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82060880h case   20:*/		return 0x82060884;
		  /* 82060884h */ case   21:  		/* li R9, 0 */
		/* 82060884h case   21:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82060884h case   21:*/		return 0x82060888;
		  /* 82060888h */ case   22:  		/* addi R4, R10, 1824 */
		/* 82060888h case   22:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0x720);
		/* 82060888h case   22:*/		return 0x8206088C;
		  /* 8206088Ch */ case   23:  		/* addi R3, R31, 44 */
		/* 8206088Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x2C);
		/* 8206088Ch case   23:*/		return 0x82060890;
		  /* 82060890h */ case   24:  		/* stw R9, <#[R31 + 76]> */
		/* 82060890h case   24:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x0000004C) );
		/* 82060890h case   24:*/		return 0x82060894;
		  /* 82060894h */ case   25:  		/* std R11, <#[R1 + 80]> */
		/* 82060894h case   25:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82060894h case   25:*/		return 0x82060898;
		  /* 82060898h */ case   26:  		/* lfd FR0, <#[R1 + 80]> */
		/* 82060898h case   26:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 82060898h case   26:*/		return 0x8206089C;
		  /* 8206089Ch */ case   27:  		/* fcfid FR0, FR0 */
		/* 8206089Ch case   27:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 8206089Ch case   27:*/		return 0x820608A0;
		  /* 820608A0h */ case   28:  		/* fdiv FR0, FR0, FR13 */
		/* 820608A0h case   28:*/		cpu::op::fdiv<0>(regs,&regs.FR0,regs.FR0,regs.FR13);
		/* 820608A0h case   28:*/		return 0x820608A4;
		  /* 820608A4h */ case   29:  		/* frsp FR1, FR0 */
		/* 820608A4h case   29:*/		cpu::op::frsp<0>(regs,&regs.FR1,regs.FR0);
		/* 820608A4h case   29:*/		return 0x820608A8;
		  /* 820608A8h */ case   30:  		/* stfd FR1, <#[R1 + 32]> */
		/* 820608A8h case   30:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000020) );
		/* 820608A8h case   30:*/		return 0x820608AC;
		  /* 820608ACh */ case   31:  		/* ld R5, <#[R1 + 32]> */
		/* 820608ACh case   31:*/		cpu::mem::load64( regs, &regs.R5, (uint32)(regs.R1 + 0x00000020) );
		/* 820608ACh case   31:*/		return 0x820608B0;
		  /* 820608B0h */ case   32:  		/* bl -824 */
		/* 820608B0h case   32:*/		regs.LR = 0x820608B4; return 0x82060578;
		/* 820608B0h case   32:*/		return 0x820608B4;
	}
	return 0x820608B4;
} // Block from 82060830h-820608B4h (33 instructions)

//////////////////////////////////////////////////////
// Block at 820608B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820608B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820608B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820608B4);
		  /* 820608B4h */ case    0:  		/* addi R3, R31, 44 */
		/* 820608B4h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x2C);
		/* 820608B4h case    0:*/		return 0x820608B8;
		  /* 820608B8h */ case    1:  		/* addi R1, R1, 112 */
		/* 820608B8h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820608B8h case    1:*/		return 0x820608BC;
		  /* 820608BCh */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 820608BCh case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820608BCh case    2:*/		return 0x820608C0;
		  /* 820608C0h */ case    3:  		/* mtspr LR, R12 */
		/* 820608C0h case    3:*/		regs.LR = regs.R12;
		/* 820608C0h case    3:*/		return 0x820608C4;
		  /* 820608C4h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 820608C4h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820608C4h case    4:*/		return 0x820608C8;
		  /* 820608C8h */ case    5:  		/* bclr 20, CR0_LT */
		/* 820608C8h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820608C8h case    5:*/		return 0x820608CC;
	}
	return 0x820608CC;
} // Block from 820608B4h-820608CCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820608CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820608CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820608CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820608CC);
		  /* 820608CCh */ case    0:  		/* nop */
		/* 820608CCh case    0:*/		cpu::op::nop();
		/* 820608CCh case    0:*/		return 0x820608D0;
	}
	return 0x820608D0;
} // Block from 820608CCh-820608D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820608D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820608D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820608D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820608D0);
		  /* 820608D0h */ case    0:  		/* mfspr R12, LR */
		/* 820608D0h case    0:*/		regs.R12 = regs.LR;
		/* 820608D0h case    0:*/		return 0x820608D4;
		  /* 820608D4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820608D4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820608D4h case    1:*/		return 0x820608D8;
		  /* 820608D8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820608D8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820608D8h case    2:*/		return 0x820608DC;
		  /* 820608DCh */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820608DCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820608DCh case    3:*/		return 0x820608E0;
		  /* 820608E0h */ case    4:  		/* mr R31, R3 */
		/* 820608E0h case    4:*/		regs.R31 = regs.R3;
		/* 820608E0h case    4:*/		return 0x820608E4;
		  /* 820608E4h */ case    5:  		/* lis R11, -32256 */
		/* 820608E4h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820608E4h case    5:*/		return 0x820608E8;
		  /* 820608E8h */ case    6:  		/* addi R3, R3, 8 */
		/* 820608E8h case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x8);
		/* 820608E8h case    6:*/		return 0x820608EC;
		  /* 820608ECh */ case    7:  		/* addi R11, R11, 1856 */
		/* 820608ECh case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x740);
		/* 820608ECh case    7:*/		return 0x820608F0;
		  /* 820608F0h */ case    8:  		/* stw R11, <#[R31]> */
		/* 820608F0h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820608F0h case    8:*/		return 0x820608F4;
		  /* 820608F4h */ case    9:  		/* bl -324 */
		/* 820608F4h case    9:*/		regs.LR = 0x820608F8; return 0x820607B0;
		/* 820608F4h case    9:*/		return 0x820608F8;
		  /* 820608F8h */ case   10:  		/* addi R3, R31, 104 */
		/* 820608F8h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x68);
		/* 820608F8h case   10:*/		return 0x820608FC;
		  /* 820608FCh */ case   11:  		/* bl 186436 */
		/* 820608FCh case   11:*/		regs.LR = 0x82060900; return 0x8208E140;
		/* 820608FCh case   11:*/		return 0x82060900;
		  /* 82060900h */ case   12:  		/* addi R3, R31, 296 */
		/* 82060900h case   12:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x128);
		/* 82060900h case   12:*/		return 0x82060904;
		  /* 82060904h */ case   13:  		/* bl 185404 */
		/* 82060904h case   13:*/		regs.LR = 0x82060908; return 0x8208DD40;
		/* 82060904h case   13:*/		return 0x82060908;
		  /* 82060908h */ case   14:  		/* addi R3, R31, 528 */
		/* 82060908h case   14:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x210);
		/* 82060908h case   14:*/		return 0x8206090C;
		  /* 8206090Ch */ case   15:  		/* bl 190836 */
		/* 8206090Ch case   15:*/		regs.LR = 0x82060910; return 0x8208F280;
		/* 8206090Ch case   15:*/		return 0x82060910;
		  /* 82060910h */ case   16:  		/* addi R3, R31, 544 */
		/* 82060910h case   16:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x220);
		/* 82060910h case   16:*/		return 0x82060914;
		  /* 82060914h */ case   17:  		/* bl 190828 */
		/* 82060914h case   17:*/		regs.LR = 0x82060918; return 0x8208F280;
		/* 82060914h case   17:*/		return 0x82060918;
		  /* 82060918h */ case   18:  		/* addi R3, R31, 560 */
		/* 82060918h case   18:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x230);
		/* 82060918h case   18:*/		return 0x8206091C;
		  /* 8206091Ch */ case   19:  		/* bl 190820 */
		/* 8206091Ch case   19:*/		regs.LR = 0x82060920; return 0x8208F280;
		/* 8206091Ch case   19:*/		return 0x82060920;
		  /* 82060920h */ case   20:  		/* addi R3, R31, 620 */
		/* 82060920h case   20:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x26C);
		/* 82060920h case   20:*/		return 0x82060924;
		  /* 82060924h */ case   21:  		/* bl 190812 */
		/* 82060924h case   21:*/		regs.LR = 0x82060928; return 0x8208F280;
		/* 82060924h case   21:*/		return 0x82060928;
		  /* 82060928h */ case   22:  		/* mr R3, R31 */
		/* 82060928h case   22:*/		regs.R3 = regs.R31;
		/* 82060928h case   22:*/		return 0x8206092C;
		  /* 8206092Ch */ case   23:  		/* addi R1, R1, 96 */
		/* 8206092Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8206092Ch case   23:*/		return 0x82060930;
		  /* 82060930h */ case   24:  		/* lwz R12, <#[R1 - 8]> */
		/* 82060930h case   24:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82060930h case   24:*/		return 0x82060934;
		  /* 82060934h */ case   25:  		/* mtspr LR, R12 */
		/* 82060934h case   25:*/		regs.LR = regs.R12;
		/* 82060934h case   25:*/		return 0x82060938;
		  /* 82060938h */ case   26:  		/* ld R31, <#[R1 - 16]> */
		/* 82060938h case   26:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82060938h case   26:*/		return 0x8206093C;
		  /* 8206093Ch */ case   27:  		/* bclr 20, CR0_LT */
		/* 8206093Ch case   27:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206093Ch case   27:*/		return 0x82060940;
	}
	return 0x82060940;
} // Block from 820608D0h-82060940h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82060940h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82060940( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82060940) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82060940);
		  /* 82060940h */ case    0:  		/* mfspr R12, LR */
		/* 82060940h case    0:*/		regs.R12 = regs.LR;
		/* 82060940h case    0:*/		return 0x82060944;
		  /* 82060944h */ case    1:  		/* bl 198928 */
		/* 82060944h case    1:*/		regs.LR = 0x82060948; return 0x82091254;
		/* 82060944h case    1:*/		return 0x82060948;
		  /* 82060948h */ case    2:  		/* stfd FR31, <#[R1 - 56]> */
		/* 82060948h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFC8) );
		/* 82060948h case    2:*/		return 0x8206094C;
		  /* 8206094Ch */ case    3:  		/* li R12, -96 */
		/* 8206094Ch case    3:*/		cpu::op::li<0>(regs,&regs.R12,0xFFFFFFA0);
		/* 8206094Ch case    3:*/		return 0x82060950;
		  /* 82060950h */ case    4:  		/* stvx VR126, <#[R1 + R12]> */
		/* 82060950h case    4:*/		cpu::mem::stvx( regs, regs.VR126, (uint32)(regs.R1 + regs.R12 + 0x00000000) );
		/* 82060950h case    4:*/		return 0x82060954;
		  /* 82060954h */ case    5:  		/* li R12, -80 */
		/* 82060954h case    5:*/		cpu::op::li<0>(regs,&regs.R12,0xFFFFFFB0);
		/* 82060954h case    5:*/		return 0x82060958;
		  /* 82060958h */ case    6:  		/* stvx VR127, <#[R1 + R12]> */
		/* 82060958h case    6:*/		cpu::mem::stvx( regs, regs.VR127, (uint32)(regs.R1 + regs.R12 + 0x00000000) );
		/* 82060958h case    6:*/		return 0x8206095C;
		  /* 8206095Ch */ case    7:  		/* stwu R1, <#[R1 - 1136]> */
		/* 8206095Ch case    7:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFB90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFB90);
		/* 8206095Ch case    7:*/		return 0x82060960;
		  /* 82060960h */ case    8:  		/* addi R30, R3, 104 */
		/* 82060960h case    8:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R3,0x68);
		/* 82060960h case    8:*/		return 0x82060964;
		  /* 82060964h */ case    9:  		/* lis R11, -32256 */
		/* 82060964h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82060964h case    9:*/		return 0x82060968;
		  /* 82060968h */ case   10:  		/* mr R31, R3 */
		/* 82060968h case   10:*/		regs.R31 = regs.R3;
		/* 82060968h case   10:*/		return 0x8206096C;
		  /* 8206096Ch */ case   11:  		/* mr R3, R30 */
		/* 8206096Ch case   11:*/		regs.R3 = regs.R30;
		/* 8206096Ch case   11:*/		return 0x82060970;
		  /* 82060970h */ case   12:  		/* addi R4, R11, 2628 */
		/* 82060970h case   12:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xA44);
		/* 82060970h case   12:*/		return 0x82060974;
		  /* 82060974h */ case   13:  		/* bl 188892 */
		/* 82060974h case   13:*/		regs.LR = 0x82060978; return 0x8208EB50;
		/* 82060974h case   13:*/		return 0x82060978;
		  /* 82060978h */ case   14:  		/* or. R29, R3, R3 */
		/* 82060978h case   14:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 82060978h case   14:*/		return 0x8206097C;
		  /* 8206097Ch */ case   15:  		/* bc 4, CR0_LT, 48 */
		/* 8206097Ch case   15:*/		if ( !regs.CR[0].lt ) { return 0x820609AC;  }
		/* 8206097Ch case   15:*/		return 0x82060980;
		  /* 82060980h */ case   16:  		/* lis R11, -32256 */
		/* 82060980h case   16:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82060980h case   16:*/		return 0x82060984;
		  /* 82060984h */ case   17:  		/* lis R10, -32256 */
		/* 82060984h case   17:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82060984h case   17:*/		return 0x82060988;
		  /* 82060988h */ case   18:  		/* addi R4, R11, 2612 */
		/* 82060988h case   18:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xA34);
		/* 82060988h case   18:*/		return 0x8206098C;
		  /* 8206098Ch */ case   19:  		/* addi R3, R10, 2596 */
		/* 8206098Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R10,0xA24);
		/* 8206098Ch case   19:*/		return 0x82060990;
		  /* 82060990h */ case   20:  		/* li R5, 111 */
		/* 82060990h case   20:*/		cpu::op::li<0>(regs,&regs.R5,0x6F);
		/* 82060990h case   20:*/		return 0x82060994;
		  /* 82060994h */ case   21:  		/* bl 192420 */
		/* 82060994h case   21:*/		regs.LR = 0x82060998; return 0x8208F938;
		/* 82060994h case   21:*/		return 0x82060998;
		  /* 82060998h */ case   22:  		/* lis R11, -32256 */
		/* 82060998h case   22:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82060998h case   22:*/		return 0x8206099C;
		  /* 8206099Ch */ case   23:  		/* addi R3, R11, 2572 */
		/* 8206099Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xA0C);
		/* 8206099Ch case   23:*/		return 0x820609A0;
		  /* 820609A0h */ case   24:  		/* bl 192408 */
		/* 820609A0h case   24:*/		regs.LR = 0x820609A4; return 0x8208F938;
		/* 820609A0h case   24:*/		return 0x820609A4;
		  /* 820609A4h */ case   25:  		/* mr R3, R29 */
		/* 820609A4h case   25:*/		regs.R3 = regs.R29;
		/* 820609A4h case   25:*/		return 0x820609A8;
		  /* 820609A8h */ case   26:  		/* b 1500 */
		/* 820609A8h case   26:*/		return 0x82060F84;
		/* 820609A8h case   26:*/		return 0x820609AC;
	}
	return 0x820609AC;
} // Block from 82060940h-820609ACh (27 instructions)

//////////////////////////////////////////////////////
// Block at 820609ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820609AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820609AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820609AC);
		  /* 820609ACh */ case    0:  		/* addi R3, R1, 112 */
		/* 820609ACh case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x70);
		/* 820609ACh case    0:*/		return 0x820609B0;
		  /* 820609B0h */ case    1:  		/* bl 192600 */
		/* 820609B0h case    1:*/		regs.LR = 0x820609B4; return 0x8208FA08;
		/* 820609B0h case    1:*/		return 0x820609B4;
		  /* 820609B4h */ case    2:  		/* mr R11, R3 */
		/* 820609B4h case    2:*/		regs.R11 = regs.R3;
		/* 820609B4h case    2:*/		return 0x820609B8;
		  /* 820609B8h */ case    3:  		/* addi R10, R1, 80 */
		/* 820609B8h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 820609B8h case    3:*/		return 0x820609BC;
		  /* 820609BCh */ case    4:  		/* addi R4, R1, 80 */
		/* 820609BCh case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 820609BCh case    4:*/		return 0x820609C0;
		  /* 820609C0h */ case    5:  		/* mr R3, R30 */
		/* 820609C0h case    5:*/		regs.R3 = regs.R30;
		/* 820609C0h case    5:*/		return 0x820609C4;
		  /* 820609C4h */ case    6:  		/* lwz R9, <#[R11]> */
		/* 820609C4h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820609C4h case    6:*/		return 0x820609C8;
		  /* 820609C8h */ case    7:  		/* stw R9, <#[R10]> */
		/* 820609C8h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 820609C8h case    7:*/		return 0x820609CC;
		  /* 820609CCh */ case    8:  		/* lwz R9, <#[R11 + 4]> */
		/* 820609CCh case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 820609CCh case    8:*/		return 0x820609D0;
		  /* 820609D0h */ case    9:  		/* stw R9, <#[R10 + 4]> */
		/* 820609D0h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 820609D0h case    9:*/		return 0x820609D4;
		  /* 820609D4h */ case   10:  		/* lwz R9, <#[R11 + 8]> */
		/* 820609D4h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 820609D4h case   10:*/		return 0x820609D8;
		  /* 820609D8h */ case   11:  		/* stw R9, <#[R10 + 8]> */
		/* 820609D8h case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 820609D8h case   11:*/		return 0x820609DC;
		  /* 820609DCh */ case   12:  		/* lwz R11, <#[R11 + 12]> */
		/* 820609DCh case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 820609DCh case   12:*/		return 0x820609E0;
		  /* 820609E0h */ case   13:  		/* stw R11, <#[R10 + 12]> */
		/* 820609E0h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		/* 820609E0h case   13:*/		return 0x820609E4;
		  /* 820609E4h */ case   14:  		/* bl 186372 */
		/* 820609E4h case   14:*/		regs.LR = 0x820609E8; return 0x8208E1E8;
		/* 820609E4h case   14:*/		return 0x820609E8;
		  /* 820609E8h */ case   15:  		/* lis R11, -32256 */
		/* 820609E8h case   15:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820609E8h case   15:*/		return 0x820609EC;
		  /* 820609ECh */ case   16:  		/* addi R30, R31, 296 */
		/* 820609ECh case   16:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x128);
		/* 820609ECh case   16:*/		return 0x820609F0;
		  /* 820609F0h */ case   17:  		/* addi R4, R11, 2544 */
		/* 820609F0h case   17:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x9F0);
		/* 820609F0h case   17:*/		return 0x820609F4;
		  /* 820609F4h */ case   18:  		/* mr R3, R30 */
		/* 820609F4h case   18:*/		regs.R3 = regs.R30;
		/* 820609F4h case   18:*/		return 0x820609F8;
		  /* 820609F8h */ case   19:  		/* bl 185480 */
		/* 820609F8h case   19:*/		regs.LR = 0x820609FC; return 0x8208DE80;
		/* 820609F8h case   19:*/		return 0x820609FC;
		  /* 820609FCh */ case   20:  		/* or. R29, R3, R3 */
		/* 820609FCh case   20:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 820609FCh case   20:*/		return 0x82060A00;
		  /* 82060A00h */ case   21:  		/* bc 4, CR0_LT, 40 */
		/* 82060A00h case   21:*/		if ( !regs.CR[0].lt ) { return 0x82060A28;  }
		/* 82060A00h case   21:*/		return 0x82060A04;
		  /* 82060A04h */ case   22:  		/* lis R11, -32256 */
		/* 82060A04h case   22:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82060A04h case   22:*/		return 0x82060A08;
		  /* 82060A08h */ case   23:  		/* lis R10, -32256 */
		/* 82060A08h case   23:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82060A08h case   23:*/		return 0x82060A0C;
		  /* 82060A0Ch */ case   24:  		/* addi R4, R11, 2612 */
		/* 82060A0Ch case   24:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xA34);
		/* 82060A0Ch case   24:*/		return 0x82060A10;
		  /* 82060A10h */ case   25:  		/* addi R3, R10, 2596 */
		/* 82060A10h case   25:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R10,0xA24);
		/* 82060A10h case   25:*/		return 0x82060A14;
		  /* 82060A14h */ case   26:  		/* li R5, 121 */
		/* 82060A14h case   26:*/		cpu::op::li<0>(regs,&regs.R5,0x79);
		/* 82060A14h case   26:*/		return 0x82060A18;
		  /* 82060A18h */ case   27:  		/* bl 192288 */
		/* 82060A18h case   27:*/		regs.LR = 0x82060A1C; return 0x8208F938;
		/* 82060A18h case   27:*/		return 0x82060A1C;
		  /* 82060A1Ch */ case   28:  		/* lis R11, -32256 */
		/* 82060A1Ch case   28:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82060A1Ch case   28:*/		return 0x82060A20;
		  /* 82060A20h */ case   29:  		/* addi R3, R11, 2512 */
		/* 82060A20h case   29:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x9D0);
		/* 82060A20h case   29:*/		return 0x82060A24;
		  /* 82060A24h */ case   30:  		/* b -132 */
		/* 82060A24h case   30:*/		return 0x820609A0;
		/* 82060A24h case   30:*/		return 0x82060A28;
	}
	return 0x82060A28;
} // Block from 820609ACh-82060A28h (31 instructions)

//////////////////////////////////////////////////////
// Block at 82060A28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82060A28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82060A28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82060A28);
		  /* 82060A28h */ case    0:  		/* lis R11, -32256 */
		/* 82060A28h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82060A28h case    0:*/		return 0x82060A2C;
		  /* 82060A2Ch */ case    1:  		/* mr R3, R30 */
		/* 82060A2Ch case    1:*/		regs.R3 = regs.R30;
		/* 82060A2Ch case    1:*/		return 0x82060A30;
		  /* 82060A30h */ case    2:  		/* addi R4, R11, 2496 */
		/* 82060A30h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x9C0);
		/* 82060A30h case    2:*/		return 0x82060A34;
		  /* 82060A34h */ case    3:  		/* bl 185140 */
		/* 82060A34h case    3:*/		regs.LR = 0x82060A38; return 0x8208DD68;
		/* 82060A34h case    3:*/		return 0x82060A38;
		  /* 82060A38h */ case    4:  		/* stw R3, <#[R31 + 576]> */
		/* 82060A38h case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000240) );
		/* 82060A38h case    4:*/		return 0x82060A3C;
		  /* 82060A3Ch */ case    5:  		/* lis R11, -32256 */
		/* 82060A3Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82060A3Ch case    5:*/		return 0x82060A40;
		  /* 82060A40h */ case    6:  		/* mr R3, R30 */
		/* 82060A40h case    6:*/		regs.R3 = regs.R30;
		/* 82060A40h case    6:*/		return 0x82060A44;
		  /* 82060A44h */ case    7:  		/* addi R4, R11, 2480 */
		/* 82060A44h case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x9B0);
		/* 82060A44h case    7:*/		return 0x82060A48;
		  /* 82060A48h */ case    8:  		/* bl 185120 */
		/* 82060A48h case    8:*/		regs.LR = 0x82060A4C; return 0x8208DD68;
		/* 82060A48h case    8:*/		return 0x82060A4C;
		  /* 82060A4Ch */ case    9:  		/* lis R11, -32256 */
		/* 82060A4Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82060A4Ch case    9:*/		return 0x82060A50;
		  /* 82060A50h */ case   10:  		/* stw R3, <#[R31 + 636]> */
		/* 82060A50h case   10:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000027C) );
		/* 82060A50h case   10:*/		return 0x82060A54;
		  /* 82060A54h */ case   11:  		/* li R29, 0 */
		/* 82060A54h case   11:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82060A54h case   11:*/		return 0x82060A58;
		  /* 82060A58h */ case   12:  		/* addi R28, R31, 668 */
		/* 82060A58h case   12:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R31,0x29C);
		/* 82060A58h case   12:*/		return 0x82060A5C;
		  /* 82060A5Ch */ case   13:  		/* addi R27, R11, 2460 */
		/* 82060A5Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R11,0x99C);
		/* 82060A5Ch case   13:*/		return 0x82060A60;
		  /* 82060A60h */ case   14:  		/* mr R4, R27 */
		/* 82060A60h case   14:*/		regs.R4 = regs.R27;
		/* 82060A60h case   14:*/		return 0x82060A64;
		  /* 82060A64h */ case   15:  		/* mr R5, R29 */
		/* 82060A64h case   15:*/		regs.R5 = regs.R29;
		/* 82060A64h case   15:*/		return 0x82060A68;
		  /* 82060A68h */ case   16:  		/* addi R3, R1, 128 */
		/* 82060A68h case   16:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x80);
		/* 82060A68h case   16:*/		return 0x82060A6C;
		  /* 82060A6Ch */ case   17:  		/* bl -1180 */
		/* 82060A6Ch case   17:*/		regs.LR = 0x82060A70; return 0x820605D0;
		/* 82060A6Ch case   17:*/		return 0x82060A70;
		  /* 82060A70h */ case   18:  		/* addi R4, R1, 128 */
		/* 82060A70h case   18:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x80);
		/* 82060A70h case   18:*/		return 0x82060A74;
		  /* 82060A74h */ case   19:  		/* mr R3, R30 */
		/* 82060A74h case   19:*/		regs.R3 = regs.R30;
		/* 82060A74h case   19:*/		return 0x82060A78;
		  /* 82060A78h */ case   20:  		/* bl 185072 */
		/* 82060A78h case   20:*/		regs.LR = 0x82060A7C; return 0x8208DD68;
		/* 82060A78h case   20:*/		return 0x82060A7C;
		  /* 82060A7Ch */ case   21:  		/* addi R29, R29, 1 */
		/* 82060A7Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82060A7Ch case   21:*/		return 0x82060A80;
		  /* 82060A80h */ case   22:  		/* stwu R3, <#[R28 + 4]> */
		/* 82060A80h case   22:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + 0x00000004) );
		regs.R28 = (uint32)(regs.R28 + 0x00000004);
		/* 82060A80h case   22:*/		return 0x82060A84;
		  /* 82060A84h */ case   23:  		/* cmplwi CR6, R29, 32 */
		/* 82060A84h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000020);
		/* 82060A84h case   23:*/		return 0x82060A88;
		  /* 82060A88h */ case   24:  		/* bc 12, CR6_LT, -40 */
		/* 82060A88h case   24:*/		if ( regs.CR[6].lt ) { return 0x82060A60;  }
		/* 82060A88h case   24:*/		return 0x82060A8C;
		  /* 82060A8Ch */ case   25:  		/* lis R11, -32256 */
		/* 82060A8Ch case   25:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82060A8Ch case   25:*/		return 0x82060A90;
		  /* 82060A90h */ case   26:  		/* li R5, 0 */
		/* 82060A90h case   26:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82060A90h case   26:*/		return 0x82060A94;
		  /* 82060A94h */ case   27:  		/* addi R4, R11, 2428 */
		/* 82060A94h case   27:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x97C);
		/* 82060A94h case   27:*/		return 0x82060A98;
		  /* 82060A98h */ case   28:  		/* addi R3, R31, 528 */
		/* 82060A98h case   28:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x210);
		/* 82060A98h case   28:*/		return 0x82060A9C;
		  /* 82060A9Ch */ case   29:  		/* bl 190548 */
		/* 82060A9Ch case   29:*/		regs.LR = 0x82060AA0; return 0x8208F2F0;
		/* 82060A9Ch case   29:*/		return 0x82060AA0;
		  /* 82060AA0h */ case   30:  		/* or. R30, R3, R3 */
		/* 82060AA0h case   30:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 82060AA0h case   30:*/		return 0x82060AA4;
		  /* 82060AA4h */ case   31:  		/* bc 4, CR0_LT, 48 */
		/* 82060AA4h case   31:*/		if ( !regs.CR[0].lt ) { return 0x82060AD4;  }
		/* 82060AA4h case   31:*/		return 0x82060AA8;
		  /* 82060AA8h */ case   32:  		/* lis R11, -32256 */
		/* 82060AA8h case   32:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82060AA8h case   32:*/		return 0x82060AAC;
		  /* 82060AACh */ case   33:  		/* lis R10, -32256 */
		/* 82060AACh case   33:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82060AACh case   33:*/		return 0x82060AB0;
		  /* 82060AB0h */ case   34:  		/* addi R4, R11, 2612 */
		/* 82060AB0h case   34:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xA34);
		/* 82060AB0h case   34:*/		return 0x82060AB4;
		  /* 82060AB4h */ case   35:  		/* addi R3, R10, 2596 */
		/* 82060AB4h case   35:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R10,0xA24);
		/* 82060AB4h case   35:*/		return 0x82060AB8;
		  /* 82060AB8h */ case   36:  		/* li R5, 137 */
		/* 82060AB8h case   36:*/		cpu::op::li<0>(regs,&regs.R5,0x89);
		/* 82060AB8h case   36:*/		return 0x82060ABC;
		  /* 82060ABCh */ case   37:  		/* bl 192124 */
		/* 82060ABCh case   37:*/		regs.LR = 0x82060AC0; return 0x8208F938;
		/* 82060ABCh case   37:*/		return 0x82060AC0;
		  /* 82060AC0h */ case   38:  		/* lis R11, -32256 */
		/* 82060AC0h case   38:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82060AC0h case   38:*/		return 0x82060AC4;
		  /* 82060AC4h */ case   39:  		/* addi R3, R11, 2396 */
		/* 82060AC4h case   39:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x95C);
		/* 82060AC4h case   39:*/		return 0x82060AC8;
		  /* 82060AC8h */ case   40:  		/* bl 192112 */
		/* 82060AC8h case   40:*/		regs.LR = 0x82060ACC; return 0x8208F938;
		/* 82060AC8h case   40:*/		return 0x82060ACC;
		  /* 82060ACCh */ case   41:  		/* mr R3, R30 */
		/* 82060ACCh case   41:*/		regs.R3 = regs.R30;
		/* 82060ACCh case   41:*/		return 0x82060AD0;
		  /* 82060AD0h */ case   42:  		/* b 1204 */
		/* 82060AD0h case   42:*/		return 0x82060F84;
		/* 82060AD0h case   42:*/		return 0x82060AD4;
	}
	return 0x82060AD4;
} // Block from 82060A28h-82060AD4h (43 instructions)

//////////////////////////////////////////////////////
// Block at 82060AD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82060AD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82060AD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82060AD4);
		  /* 82060AD4h */ case    0:  		/* lis R11, -32256 */
		/* 82060AD4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82060AD4h case    0:*/		return 0x82060AD8;
		  /* 82060AD8h */ case    1:  		/* li R5, 0 */
		/* 82060AD8h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82060AD8h case    1:*/		return 0x82060ADC;
		  /* 82060ADCh */ case    2:  		/* addi R4, R11, 2364 */
		/* 82060ADCh case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x93C);
		/* 82060ADCh case    2:*/		return 0x82060AE0;
		  /* 82060AE0h */ case    3:  		/* addi R3, R31, 544 */
		/* 82060AE0h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x220);
		/* 82060AE0h case    3:*/		return 0x82060AE4;
		  /* 82060AE4h */ case    4:  		/* bl 190476 */
		/* 82060AE4h case    4:*/		regs.LR = 0x82060AE8; return 0x8208F2F0;
		/* 82060AE4h case    4:*/		return 0x82060AE8;
		  /* 82060AE8h */ case    5:  		/* or. R30, R3, R3 */
		/* 82060AE8h case    5:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 82060AE8h case    5:*/		return 0x82060AEC;
		  /* 82060AECh */ case    6:  		/* bc 4, CR0_LT, 40 */
		/* 82060AECh case    6:*/		if ( !regs.CR[0].lt ) { return 0x82060B14;  }
		/* 82060AECh case    6:*/		return 0x82060AF0;
		  /* 82060AF0h */ case    7:  		/* lis R11, -32256 */
		/* 82060AF0h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82060AF0h case    7:*/		return 0x82060AF4;
		  /* 82060AF4h */ case    8:  		/* lis R10, -32256 */
		/* 82060AF4h case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82060AF4h case    8:*/		return 0x82060AF8;
		  /* 82060AF8h */ case    9:  		/* addi R4, R11, 2612 */
		/* 82060AF8h case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xA34);
		/* 82060AF8h case    9:*/		return 0x82060AFC;
		  /* 82060AFCh */ case   10:  		/* addi R3, R10, 2596 */
		/* 82060AFCh case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R10,0xA24);
		/* 82060AFCh case   10:*/		return 0x82060B00;
		  /* 82060B00h */ case   11:  		/* li R5, 142 */
		/* 82060B00h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x8E);
		/* 82060B00h case   11:*/		return 0x82060B04;
		  /* 82060B04h */ case   12:  		/* bl 192052 */
		/* 82060B04h case   12:*/		regs.LR = 0x82060B08; return 0x8208F938;
		/* 82060B04h case   12:*/		return 0x82060B08;
		  /* 82060B08h */ case   13:  		/* lis R11, -32256 */
		/* 82060B08h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82060B08h case   13:*/		return 0x82060B0C;
		  /* 82060B0Ch */ case   14:  		/* addi R3, R11, 2332 */
		/* 82060B0Ch case   14:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x91C);
		/* 82060B0Ch case   14:*/		return 0x82060B10;
		  /* 82060B10h */ case   15:  		/* b -72 */
		/* 82060B10h case   15:*/		return 0x82060AC8;
		/* 82060B10h case   15:*/		return 0x82060B14;
	}
	return 0x82060B14;
} // Block from 82060AD4h-82060B14h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82060B14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82060B14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82060B14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82060B14);
		  /* 82060B14h */ case    0:  		/* lis R11, -32256 */
		/* 82060B14h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82060B14h case    0:*/		return 0x82060B18;
		  /* 82060B18h */ case    1:  		/* li R5, 0 */
		/* 82060B18h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82060B18h case    1:*/		return 0x82060B1C;
		  /* 82060B1Ch */ case    2:  		/* addi R4, R11, 2300 */
		/* 82060B1Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x8FC);
		/* 82060B1Ch case    2:*/		return 0x82060B20;
		  /* 82060B20h */ case    3:  		/* addi R3, R31, 560 */
		/* 82060B20h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x230);
		/* 82060B20h case    3:*/		return 0x82060B24;
		  /* 82060B24h */ case    4:  		/* bl 190412 */
		/* 82060B24h case    4:*/		regs.LR = 0x82060B28; return 0x8208F2F0;
		/* 82060B24h case    4:*/		return 0x82060B28;
		  /* 82060B28h */ case    5:  		/* or. R30, R3, R3 */
		/* 82060B28h case    5:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 82060B28h case    5:*/		return 0x82060B2C;
		  /* 82060B2Ch */ case    6:  		/* bc 4, CR0_LT, 40 */
		/* 82060B2Ch case    6:*/		if ( !regs.CR[0].lt ) { return 0x82060B54;  }
		/* 82060B2Ch case    6:*/		return 0x82060B30;
		  /* 82060B30h */ case    7:  		/* lis R11, -32256 */
		/* 82060B30h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82060B30h case    7:*/		return 0x82060B34;
		  /* 82060B34h */ case    8:  		/* lis R10, -32256 */
		/* 82060B34h case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82060B34h case    8:*/		return 0x82060B38;
		  /* 82060B38h */ case    9:  		/* addi R4, R11, 2612 */
		/* 82060B38h case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xA34);
		/* 82060B38h case    9:*/		return 0x82060B3C;
		  /* 82060B3Ch */ case   10:  		/* addi R3, R10, 2596 */
		/* 82060B3Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R10,0xA24);
		/* 82060B3Ch case   10:*/		return 0x82060B40;
		  /* 82060B40h */ case   11:  		/* li R5, 147 */
		/* 82060B40h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x93);
		/* 82060B40h case   11:*/		return 0x82060B44;
		  /* 82060B44h */ case   12:  		/* bl 191988 */
		/* 82060B44h case   12:*/		regs.LR = 0x82060B48; return 0x8208F938;
		/* 82060B44h case   12:*/		return 0x82060B48;
		  /* 82060B48h */ case   13:  		/* lis R11, -32256 */
		/* 82060B48h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82060B48h case   13:*/		return 0x82060B4C;
		  /* 82060B4Ch */ case   14:  		/* addi R3, R11, 2268 */
		/* 82060B4Ch case   14:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x8DC);
		/* 82060B4Ch case   14:*/		return 0x82060B50;
		  /* 82060B50h */ case   15:  		/* b -136 */
		/* 82060B50h case   15:*/		return 0x82060AC8;
		/* 82060B50h case   15:*/		return 0x82060B54;
	}
	return 0x82060B54;
} // Block from 82060B14h-82060B54h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82060B54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82060B54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82060B54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82060B54);
		  /* 82060B54h */ case    0:  		/* lis R11, -32256 */
		/* 82060B54h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82060B54h case    0:*/		return 0x82060B58;
		  /* 82060B58h */ case    1:  		/* li R5, 0 */
		/* 82060B58h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82060B58h case    1:*/		return 0x82060B5C;
		  /* 82060B5Ch */ case    2:  		/* addi R4, R11, 2236 */
		/* 82060B5Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x8BC);
		/* 82060B5Ch case    2:*/		return 0x82060B60;
		  /* 82060B60h */ case    3:  		/* addi R3, R31, 620 */
		/* 82060B60h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x26C);
		/* 82060B60h case    3:*/		return 0x82060B64;
		  /* 82060B64h */ case    4:  		/* bl 190348 */
		/* 82060B64h case    4:*/		regs.LR = 0x82060B68; return 0x8208F2F0;
		/* 82060B64h case    4:*/		return 0x82060B68;
		  /* 82060B68h */ case    5:  		/* or. R30, R3, R3 */
		/* 82060B68h case    5:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 82060B68h case    5:*/		return 0x82060B6C;
		  /* 82060B6Ch */ case    6:  		/* bc 4, CR0_LT, 40 */
		/* 82060B6Ch case    6:*/		if ( !regs.CR[0].lt ) { return 0x82060B94;  }
		/* 82060B6Ch case    6:*/		return 0x82060B70;
		  /* 82060B70h */ case    7:  		/* lis R11, -32256 */
		/* 82060B70h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82060B70h case    7:*/		return 0x82060B74;
		  /* 82060B74h */ case    8:  		/* lis R10, -32256 */
		/* 82060B74h case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82060B74h case    8:*/		return 0x82060B78;
		  /* 82060B78h */ case    9:  		/* addi R4, R11, 2612 */
		/* 82060B78h case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xA34);
		/* 82060B78h case    9:*/		return 0x82060B7C;
		  /* 82060B7Ch */ case   10:  		/* addi R3, R10, 2596 */
		/* 82060B7Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R10,0xA24);
		/* 82060B7Ch case   10:*/		return 0x82060B80;
		  /* 82060B80h */ case   11:  		/* li R5, 152 */
		/* 82060B80h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x98);
		/* 82060B80h case   11:*/		return 0x82060B84;
		  /* 82060B84h */ case   12:  		/* bl 191924 */
		/* 82060B84h case   12:*/		regs.LR = 0x82060B88; return 0x8208F938;
		/* 82060B84h case   12:*/		return 0x82060B88;
		  /* 82060B88h */ case   13:  		/* lis R11, -32256 */
		/* 82060B88h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82060B88h case   13:*/		return 0x82060B8C;
		  /* 82060B8Ch */ case   14:  		/* addi R3, R11, 2204 */
		/* 82060B8Ch case   14:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x89C);
		/* 82060B8Ch case   14:*/		return 0x82060B90;
		  /* 82060B90h */ case   15:  		/* b -200 */
		/* 82060B90h case   15:*/		return 0x82060AC8;
		/* 82060B90h case   15:*/		return 0x82060B94;
	}
	return 0x82060B94;
} // Block from 82060B54h-82060B94h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82060B94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82060B94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82060B94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82060B94);
		  /* 82060B94h */ case    0:  		/* lwz R11, <#[R31 + 632]> */
		/* 82060B94h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000278) );
		/* 82060B94h case    0:*/		return 0x82060B98;
		  /* 82060B98h */ case    1:  		/* li R3, 5 */
		/* 82060B98h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x5);
		/* 82060B98h case    1:*/		return 0x82060B9C;
		  /* 82060B9Ch */ case    2:  		/* lwz R9, <#[R31 + 556]> */
		/* 82060B9Ch case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000022C) );
		/* 82060B9Ch case    2:*/		return 0x82060BA0;
		  /* 82060BA0h */ case    3:  		/* lwz R8, <#[R31 + 572]> */
		/* 82060BA0h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x0000023C) );
		/* 82060BA0h case    3:*/		return 0x82060BA4;
		  /* 82060BA4h */ case    4:  		/* lwz R10, <#[R31 + 540]> */
		/* 82060BA4h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000021C) );
		/* 82060BA4h case    4:*/		return 0x82060BA8;
		  /* 82060BA8h */ case    5:  		/* stw R11, <#[R31 + 640]> */
		/* 82060BA8h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000280) );
		/* 82060BA8h case    5:*/		return 0x82060BAC;
		  /* 82060BACh */ case    6:  		/* addi R7, R10, 36 */
		/* 82060BACh case    6:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0x24);
		/* 82060BACh case    6:*/		return 0x82060BB0;
		  /* 82060BB0h */ case    7:  		/* stw R9, <#[R31 + 584]> */
		/* 82060BB0h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000248) );
		/* 82060BB0h case    7:*/		return 0x82060BB4;
		  /* 82060BB4h */ case    8:  		/* stw R8, <#[R31 + 588]> */
		/* 82060BB4h case    8:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x0000024C) );
		/* 82060BB4h case    8:*/		return 0x82060BB8;
		  /* 82060BB8h */ case    9:  		/* stw R7, <#[R31 + 592]> */
		/* 82060BB8h case    9:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R31 + 0x00000250) );
		/* 82060BB8h case    9:*/		return 0x82060BBC;
		  /* 82060BBCh */ case   10:  		/* addi R7, R11, 36 */
		/* 82060BBCh case   10:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0x24);
		/* 82060BBCh case   10:*/		return 0x82060BC0;
		  /* 82060BC0h */ case   11:  		/* stw R10, <#[R31 + 580]> */
		/* 82060BC0h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000244) );
		/* 82060BC0h case   11:*/		return 0x82060BC4;
		  /* 82060BC4h */ case   12:  		/* stw R7, <#[R31 + 644]> */
		/* 82060BC4h case   12:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R31 + 0x00000284) );
		/* 82060BC4h case   12:*/		return 0x82060BC8;
		  /* 82060BC8h */ case   13:  		/* lwz R9, <#[R10 + 272]> */
		/* 82060BC8h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000110) );
		/* 82060BC8h case   13:*/		return 0x82060BCC;
		  /* 82060BCCh */ case   14:  		/* stw R9, <#[R31 + 596]> */
		/* 82060BCCh case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000254) );
		/* 82060BCCh case   14:*/		return 0x82060BD0;
		  /* 82060BD0h */ case   15:  		/* lwz R9, <#[R10 + 420]> */
		/* 82060BD0h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x000001A4) );
		/* 82060BD0h case   15:*/		return 0x82060BD4;
		  /* 82060BD4h */ case   16:  		/* stw R9, <#[R31 + 604]> */
		/* 82060BD4h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x0000025C) );
		/* 82060BD4h case   16:*/		return 0x82060BD8;
		  /* 82060BD8h */ case   17:  		/* lwz R9, <#[R10 + 432]> */
		/* 82060BD8h case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x000001B0) );
		/* 82060BD8h case   17:*/		return 0x82060BDC;
		  /* 82060BDCh */ case   18:  		/* stw R9, <#[R31 + 608]> */
		/* 82060BDCh case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000260) );
		/* 82060BDCh case   18:*/		return 0x82060BE0;
		  /* 82060BE0h */ case   19:  		/* lwz R10, <#[R10 + 268]> */
		/* 82060BE0h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000010C) );
		/* 82060BE0h case   19:*/		return 0x82060BE4;
		  /* 82060BE4h */ case   20:  		/* stw R10, <#[R31 + 600]> */
		/* 82060BE4h case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000258) );
		/* 82060BE4h case   20:*/		return 0x82060BE8;
		  /* 82060BE8h */ case   21:  		/* lwz R10, <#[R11 + 272]> */
		/* 82060BE8h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000110) );
		/* 82060BE8h case   21:*/		return 0x82060BEC;
		  /* 82060BECh */ case   22:  		/* stw R10, <#[R31 + 648]> */
		/* 82060BECh case   22:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000288) );
		/* 82060BECh case   22:*/		return 0x82060BF0;
		  /* 82060BF0h */ case   23:  		/* lwz R10, <#[R11 + 420]> */
		/* 82060BF0h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x000001A4) );
		/* 82060BF0h case   23:*/		return 0x82060BF4;
		  /* 82060BF4h */ case   24:  		/* stw R10, <#[R31 + 656]> */
		/* 82060BF4h case   24:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000290) );
		/* 82060BF4h case   24:*/		return 0x82060BF8;
		  /* 82060BF8h */ case   25:  		/* lwz R10, <#[R11 + 432]> */
		/* 82060BF8h case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x000001B0) );
		/* 82060BF8h case   25:*/		return 0x82060BFC;
		  /* 82060BFCh */ case   26:  		/* stw R10, <#[R31 + 660]> */
		/* 82060BFCh case   26:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000294) );
		/* 82060BFCh case   26:*/		return 0x82060C00;
		  /* 82060C00h */ case   27:  		/* lwz R10, <#[R11 + 264]> */
		/* 82060C00h case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000108) );
		/* 82060C00h case   27:*/		return 0x82060C04;
		  /* 82060C04h */ case   28:  		/* stw R10, <#[R31 + 664]> */
		/* 82060C04h case   28:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000298) );
		/* 82060C04h case   28:*/		return 0x82060C08;
		  /* 82060C08h */ case   29:  		/* lwz R11, <#[R11 + 268]> */
		/* 82060C08h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000010C) );
		/* 82060C08h case   29:*/		return 0x82060C0C;
		  /* 82060C0Ch */ case   30:  		/* stw R11, <#[R31 + 652]> */
		/* 82060C0Ch case   30:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000028C) );
		/* 82060C0Ch case   30:*/		return 0x82060C10;
		  /* 82060C10h */ case   31:  		/* bl 198336 */
		/* 82060C10h case   31:*/		regs.LR = 0x82060C14; return 0x820912D0;
		/* 82060C10h case   31:*/		return 0x82060C14;
		  /* 82060C14h */ case   32:  		/* li R6, 0 */
		/* 82060C14h case   32:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82060C14h case   32:*/		return 0x82060C18;
		  /* 82060C18h */ case   33:  		/* li R5, 0 */
		/* 82060C18h case   33:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82060C18h case   33:*/		return 0x82060C1C;
		  /* 82060C1Ch */ case   34:  		/* lwz R3, <#[R31 + 640]> */
		/* 82060C1Ch case   34:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000280) );
		/* 82060C1Ch case   34:*/		return 0x82060C20;
		  /* 82060C20h */ case   35:  		/* li R4, 0 */
		/* 82060C20h case   35:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82060C20h case   35:*/		return 0x82060C24;
		  /* 82060C24h */ case   36:  		/* bl 72324 */
		/* 82060C24h case   36:*/		regs.LR = 0x82060C28; return 0x820726A8;
		/* 82060C24h case   36:*/		return 0x82060C28;
		  /* 82060C28h */ case   37:  		/* lwz R11, <#[R31 + 656]> */
		/* 82060C28h case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000290) );
		/* 82060C28h case   37:*/		return 0x82060C2C;
		  /* 82060C2Ch */ case   38:  		/* mr R30, R3 */
		/* 82060C2Ch case   38:*/		regs.R30 = regs.R3;
		/* 82060C2Ch case   38:*/		return 0x82060C30;
		  /* 82060C30h */ case   39:  		/* li R29, 0 */
		/* 82060C30h case   39:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82060C30h case   39:*/		return 0x82060C34;
		  /* 82060C34h */ case   40:  		/* cmplwi CR6, R11, 0 */
		/* 82060C34h case   40:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82060C34h case   40:*/		return 0x82060C38;
		  /* 82060C38h */ case   41:  		/* bc 4, CR6_GT, 144 */
		/* 82060C38h case   41:*/		if ( !regs.CR[6].gt ) { return 0x82060CC8;  }
		/* 82060C38h case   41:*/		return 0x82060C3C;
		  /* 82060C3Ch */ case   42:  		/* lis R11, -32256 */
		/* 82060C3Ch case   42:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82060C3Ch case   42:*/		return 0x82060C40;
		  /* 82060C40h */ case   43:  		/* lfs FR31, <#[R11 + 2200]> */
		/* 82060C40h case   43:*/		cpu::mem::load32f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000898) );
		/* 82060C40h case   43:*/		return 0x82060C44;
		  /* 82060C44h */ case   44:  		/* bl 198332 */
		/* 82060C44h case   44:*/		regs.LR = 0x82060C48; return 0x82091300;
		/* 82060C44h case   44:*/		return 0x82060C48;
		  /* 82060C48h */ case   45:  		/* extsw R11, R3 */
		/* 82060C48h case   45:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R3);
		/* 82060C48h case   45:*/		return 0x82060C4C;
		  /* 82060C4Ch */ case   46:  		/* lfs FR0, <#[R30 + 4]> */
		/* 82060C4Ch case   46:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R30 + 0x00000004) );
		/* 82060C4Ch case   46:*/		return 0x82060C50;
		  /* 82060C50h */ case   47:  		/* std R11, <#[R1 + 112]> */
		/* 82060C50h case   47:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 82060C50h case   47:*/		return 0x82060C54;
		  /* 82060C54h */ case   48:  		/* lfd FR13, <#[R1 + 112]> */
		/* 82060C54h case   48:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000070) );
		/* 82060C54h case   48:*/		return 0x82060C58;
		  /* 82060C58h */ case   49:  		/* fcfid FR13, FR13 */
		/* 82060C58h case   49:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 82060C58h case   49:*/		return 0x82060C5C;
		  /* 82060C5Ch */ case   50:  		/* frsp FR13, FR13 */
		/* 82060C5Ch case   50:*/		cpu::op::frsp<0>(regs,&regs.FR13,regs.FR13);
		/* 82060C5Ch case   50:*/		return 0x82060C60;
		  /* 82060C60h */ case   51:  		/* fmadds FR0, FR13, FR31, FR0 */
		/* 82060C60h case   51:*/		cpu::op::fmadds<0>(regs,&regs.FR0,regs.FR13,regs.FR31,regs.FR0);
		/* 82060C60h case   51:*/		return 0x82060C64;
		  /* 82060C64h */ case   52:  		/* stfs FR0, <#[R30 + 4]> */
		/* 82060C64h case   52:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R30 + 0x00000004) );
		/* 82060C64h case   52:*/		return 0x82060C68;
		  /* 82060C68h */ case   53:  		/* bl 198296 */
		/* 82060C68h case   53:*/		regs.LR = 0x82060C6C; return 0x82091300;
		/* 82060C68h case   53:*/		return 0x82060C6C;
		  /* 82060C6Ch */ case   54:  		/* extsw R11, R3 */
		/* 82060C6Ch case   54:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R3);
		/* 82060C6Ch case   54:*/		return 0x82060C70;
		  /* 82060C70h */ case   55:  		/* lfs FR0, <#[R30 + 4]> */
		/* 82060C70h case   55:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R30 + 0x00000004) );
		/* 82060C70h case   55:*/		return 0x82060C74;
		  /* 82060C74h */ case   56:  		/* std R11, <#[R1 + 96]> */
		/* 82060C74h case   56:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82060C74h case   56:*/		return 0x82060C78;
		  /* 82060C78h */ case   57:  		/* lfd FR13, <#[R1 + 96]> */
		/* 82060C78h case   57:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000060) );
		/* 82060C78h case   57:*/		return 0x82060C7C;
		  /* 82060C7Ch */ case   58:  		/* fcfid FR13, FR13 */
		/* 82060C7Ch case   58:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 82060C7Ch case   58:*/		return 0x82060C80;
		  /* 82060C80h */ case   59:  		/* frsp FR13, FR13 */
		/* 82060C80h case   59:*/		cpu::op::frsp<0>(regs,&regs.FR13,regs.FR13);
		/* 82060C80h case   59:*/		return 0x82060C84;
		  /* 82060C84h */ case   60:  		/* fmadds FR0, FR13, FR31, FR0 */
		/* 82060C84h case   60:*/		cpu::op::fmadds<0>(regs,&regs.FR0,regs.FR13,regs.FR31,regs.FR0);
		/* 82060C84h case   60:*/		return 0x82060C88;
		  /* 82060C88h */ case   61:  		/* stfs FR0, <#[R30 + 4]> */
		/* 82060C88h case   61:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R30 + 0x00000004) );
		/* 82060C88h case   61:*/		return 0x82060C8C;
		  /* 82060C8Ch */ case   62:  		/* bl 198260 */
		/* 82060C8Ch case   62:*/		regs.LR = 0x82060C90; return 0x82091300;
		/* 82060C8Ch case   62:*/		return 0x82060C90;
		  /* 82060C90h */ case   63:  		/* extsw R11, R3 */
		/* 82060C90h case   63:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R3);
		/* 82060C90h case   63:*/		return 0x82060C94;
		  /* 82060C94h */ case   64:  		/* lfs FR0, <#[R30 + 4]> */
		/* 82060C94h case   64:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R30 + 0x00000004) );
		/* 82060C94h case   64:*/		return 0x82060C98;
		  /* 82060C98h */ case   65:  		/* addi R29, R29, 1 */
		/* 82060C98h case   65:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82060C98h case   65:*/		return 0x82060C9C;
		  /* 82060C9Ch */ case   66:  		/* std R11, <#[R1 + 80]> */
		/* 82060C9Ch case   66:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82060C9Ch case   66:*/		return 0x82060CA0;
		  /* 82060CA0h */ case   67:  		/* lfd FR13, <#[R1 + 80]> */
		/* 82060CA0h case   67:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000050) );
		/* 82060CA0h case   67:*/		return 0x82060CA4;
		  /* 82060CA4h */ case   68:  		/* fcfid FR13, FR13 */
		/* 82060CA4h case   68:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 82060CA4h case   68:*/		return 0x82060CA8;
		  /* 82060CA8h */ case   69:  		/* frsp FR13, FR13 */
		/* 82060CA8h case   69:*/		cpu::op::frsp<0>(regs,&regs.FR13,regs.FR13);
		/* 82060CA8h case   69:*/		return 0x82060CAC;
		  /* 82060CACh */ case   70:  		/* fmadds FR0, FR13, FR31, FR0 */
		/* 82060CACh case   70:*/		cpu::op::fmadds<0>(regs,&regs.FR0,regs.FR13,regs.FR31,regs.FR0);
		/* 82060CACh case   70:*/		return 0x82060CB0;
		  /* 82060CB0h */ case   71:  		/* stfs FR0, <#[R30 + 4]> */
		/* 82060CB0h case   71:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R30 + 0x00000004) );
		/* 82060CB0h case   71:*/		return 0x82060CB4;
		  /* 82060CB4h */ case   72:  		/* lwz R10, <#[R31 + 656]> */
		/* 82060CB4h case   72:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000290) );
		/* 82060CB4h case   72:*/		return 0x82060CB8;
		  /* 82060CB8h */ case   73:  		/* lwz R11, <#[R31 + 652]> */
		/* 82060CB8h case   73:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000028C) );
		/* 82060CB8h case   73:*/		return 0x82060CBC;
		  /* 82060CBCh */ case   74:  		/* cmplw CR6, R29, R10 */
		/* 82060CBCh case   74:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R10);
		/* 82060CBCh case   74:*/		return 0x82060CC0;
		  /* 82060CC0h */ case   75:  		/* add R30, R30, R11 */
		/* 82060CC0h case   75:*/		cpu::op::add<0>(regs,&regs.R30,regs.R30,regs.R11);
		/* 82060CC0h case   75:*/		return 0x82060CC4;
		  /* 82060CC4h */ case   76:  		/* bc 12, CR6_LT, -128 */
		/* 82060CC4h case   76:*/		if ( regs.CR[6].lt ) { return 0x82060C44;  }
		/* 82060CC4h case   76:*/		return 0x82060CC8;
	}
	return 0x82060CC8;
} // Block from 82060B94h-82060CC8h (77 instructions)

//////////////////////////////////////////////////////
// Block at 82060CC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82060CC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82060CC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82060CC8);
		  /* 82060CC8h */ case    0:  		/* lwz R3, <#[R31 + 640]> */
		/* 82060CC8h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000280) );
		/* 82060CC8h case    0:*/		return 0x82060CCC;
		  /* 82060CCCh */ case    1:  		/* bl 67972 */
		/* 82060CCCh case    1:*/		regs.LR = 0x82060CD0; return 0x82071650;
		/* 82060CCCh case    1:*/		return 0x82060CD0;
		  /* 82060CD0h */ case    2:  		/* li R11, 0 */
		/* 82060CD0h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82060CD0h case    2:*/		return 0x82060CD4;
		  /* 82060CD4h */ case    3:  		/* li R5, 766 */
		/* 82060CD4h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x2FE);
		/* 82060CD4h case    3:*/		return 0x82060CD8;
		  /* 82060CD8h */ case    4:  		/* li R4, 0 */
		/* 82060CD8h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82060CD8h case    4:*/		return 0x82060CDC;
		  /* 82060CDCh */ case    5:  		/* sth R11, <#[R1 + 272]> */
		/* 82060CDCh case    5:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R1 + 0x00000110) );
		/* 82060CDCh case    5:*/		return 0x82060CE0;
		  /* 82060CE0h */ case    6:  		/* addi R3, R1, 274 */
		/* 82060CE0h case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x112);
		/* 82060CE0h case    6:*/		return 0x82060CE4;
		  /* 82060CE4h */ case    7:  		/* bl 198236 */
		/* 82060CE4h case    7:*/		regs.LR = 0x82060CE8; return 0x82091340;
		/* 82060CE4h case    7:*/		return 0x82060CE8;
		  /* 82060CE8h */ case    8:  		/* lwz R11, <#[R31 + 540]> */
		/* 82060CE8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000021C) );
		/* 82060CE8h case    8:*/		return 0x82060CEC;
		  /* 82060CECh */ case    9:  		/* li R7, 0 */
		/* 82060CECh case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82060CECh case    9:*/		return 0x82060CF0;
		  /* 82060CF0h */ case   10:  		/* li R6, 0 */
		/* 82060CF0h case   10:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82060CF0h case   10:*/		return 0x82060CF4;
		  /* 82060CF4h */ case   11:  		/* addi R5, R11, 72 */
		/* 82060CF4h case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x48);
		/* 82060CF4h case   11:*/		return 0x82060CF8;
		  /* 82060CF8h */ case   12:  		/* li R4, 0 */
		/* 82060CF8h case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82060CF8h case   12:*/		return 0x82060CFC;
		  /* 82060CFCh */ case   13:  		/* addi R3, R1, 272 */
		/* 82060CFCh case   13:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x110);
		/* 82060CFCh case   13:*/		return 0x82060D00;
		  /* 82060D00h */ case   14:  		/* bl 191344 */
		/* 82060D00h case   14:*/		regs.LR = 0x82060D04; return 0x8208F870;
		/* 82060D00h case   14:*/		return 0x82060D04;
		  /* 82060D04h */ case   15:  		/* lwz R11, <#[R31 + 556]> */
		/* 82060D04h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000022C) );
		/* 82060D04h case   15:*/		return 0x82060D08;
		  /* 82060D08h */ case   16:  		/* li R7, 0 */
		/* 82060D08h case   16:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82060D08h case   16:*/		return 0x82060D0C;
		  /* 82060D0Ch */ case   17:  		/* li R6, 1 */
		/* 82060D0Ch case   17:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 82060D0Ch case   17:*/		return 0x82060D10;
		  /* 82060D10h */ case   18:  		/* li R4, 1 */
		/* 82060D10h case   18:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82060D10h case   18:*/		return 0x82060D14;
		  /* 82060D14h */ case   19:  		/* addi R3, R1, 272 */
		/* 82060D14h case   19:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x110);
		/* 82060D14h case   19:*/		return 0x82060D18;
		  /* 82060D18h */ case   20:  		/* addi R5, R11, 72 */
		/* 82060D18h case   20:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x48);
		/* 82060D18h case   20:*/		return 0x82060D1C;
		  /* 82060D1Ch */ case   21:  		/* bl 191316 */
		/* 82060D1Ch case   21:*/		regs.LR = 0x82060D20; return 0x8208F870;
		/* 82060D1Ch case   21:*/		return 0x82060D20;
		  /* 82060D20h */ case   22:  		/* lwz R11, <#[R31 + 572]> */
		/* 82060D20h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000023C) );
		/* 82060D20h case   22:*/		return 0x82060D24;
		  /* 82060D24h */ case   23:  		/* li R7, 0 */
		/* 82060D24h case   23:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82060D24h case   23:*/		return 0x82060D28;
		  /* 82060D28h */ case   24:  		/* li R6, 2 */
		/* 82060D28h case   24:*/		cpu::op::li<0>(regs,&regs.R6,0x2);
		/* 82060D28h case   24:*/		return 0x82060D2C;
		  /* 82060D2Ch */ case   25:  		/* li R4, 2 */
		/* 82060D2Ch case   25:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 82060D2Ch case   25:*/		return 0x82060D30;
		  /* 82060D30h */ case   26:  		/* addi R3, R1, 272 */
		/* 82060D30h case   26:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x110);
		/* 82060D30h case   26:*/		return 0x82060D34;
		  /* 82060D34h */ case   27:  		/* addi R5, R11, 72 */
		/* 82060D34h case   27:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x48);
		/* 82060D34h case   27:*/		return 0x82060D38;
		  /* 82060D38h */ case   28:  		/* bl 191288 */
		/* 82060D38h case   28:*/		regs.LR = 0x82060D3C; return 0x8208F870;
		/* 82060D38h case   28:*/		return 0x82060D3C;
		  /* 82060D3Ch */ case   29:  		/* lis R11, -32215 */
		/* 82060D3Ch case   29:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 82060D3Ch case   29:*/		return 0x82060D40;
		  /* 82060D40h */ case   30:  		/* addi R5, R31, 612 */
		/* 82060D40h case   30:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R31,0x264);
		/* 82060D40h case   30:*/		return 0x82060D44;
		  /* 82060D44h */ case   31:  		/* addi R4, R1, 272 */
		/* 82060D44h case   31:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x110);
		/* 82060D44h case   31:*/		return 0x82060D48;
		  /* 82060D48h */ case   32:  		/* lwz R3, <#[R11 - 31240]> */
		/* 82060D48h case   32:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0xFFFF85F8) );
		/* 82060D48h case   32:*/		return 0x82060D4C;
		  /* 82060D4Ch */ case   33:  		/* bl 193780 */
		/* 82060D4Ch case   33:*/		regs.LR = 0x82060D50; return 0x82090240;
		/* 82060D4Ch case   33:*/		return 0x82060D50;
		  /* 82060D50h */ case   34:  		/* or. R30, R3, R3 */
		/* 82060D50h case   34:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 82060D50h case   34:*/		return 0x82060D54;
		  /* 82060D54h */ case   35:  		/* bc 4, CR0_LT, 40 */
		/* 82060D54h case   35:*/		if ( !regs.CR[0].lt ) { return 0x82060D7C;  }
		/* 82060D54h case   35:*/		return 0x82060D58;
		  /* 82060D58h */ case   36:  		/* lis R11, -32256 */
		/* 82060D58h case   36:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82060D58h case   36:*/		return 0x82060D5C;
		  /* 82060D5Ch */ case   37:  		/* lis R10, -32256 */
		/* 82060D5Ch case   37:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82060D5Ch case   37:*/		return 0x82060D60;
		  /* 82060D60h */ case   38:  		/* addi R4, R11, 2612 */
		/* 82060D60h case   38:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xA34);
		/* 82060D60h case   38:*/		return 0x82060D64;
		  /* 82060D64h */ case   39:  		/* addi R3, R10, 2596 */
		/* 82060D64h case   39:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R10,0xA24);
		/* 82060D64h case   39:*/		return 0x82060D68;
		  /* 82060D68h */ case   40:  		/* li R5, 200 */
		/* 82060D68h case   40:*/		cpu::op::li<0>(regs,&regs.R5,0xC8);
		/* 82060D68h case   40:*/		return 0x82060D6C;
		  /* 82060D6Ch */ case   41:  		/* bl 191436 */
		/* 82060D6Ch case   41:*/		regs.LR = 0x82060D70; return 0x8208F938;
		/* 82060D6Ch case   41:*/		return 0x82060D70;
		  /* 82060D70h */ case   42:  		/* lis R11, -32256 */
		/* 82060D70h case   42:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82060D70h case   42:*/		return 0x82060D74;
		  /* 82060D74h */ case   43:  		/* addi R3, R11, 2164 */
		/* 82060D74h case   43:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x874);
		/* 82060D74h case   43:*/		return 0x82060D78;
		  /* 82060D78h */ case   44:  		/* b -688 */
		/* 82060D78h case   44:*/		return 0x82060AC8;
		/* 82060D78h case   44:*/		return 0x82060D7C;
	}
	return 0x82060D7C;
} // Block from 82060CC8h-82060D7Ch (45 instructions)

//////////////////////////////////////////////////////
// Block at 82060D7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82060D7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82060D7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82060D7C);
		  /* 82060D7Ch */ case    0:  		/* lis R11, -32256 */
		/* 82060D7Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82060D7Ch case    0:*/		return 0x82060D80;
		  /* 82060D80h */ case    1:  		/* li R5, 0 */
		/* 82060D80h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82060D80h case    1:*/		return 0x82060D84;
		  /* 82060D84h */ case    2:  		/* addi R3, R11, 2124 */
		/* 82060D84h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x84C);
		/* 82060D84h case    2:*/		return 0x82060D88;
		  /* 82060D88h */ case    3:  		/* addi R4, R31, 616 */
		/* 82060D88h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x268);
		/* 82060D88h case    3:*/		return 0x82060D8C;
		  /* 82060D8Ch */ case    4:  		/* bl 191796 */
		/* 82060D8Ch case    4:*/		regs.LR = 0x82060D90; return 0x8208FAC0;
		/* 82060D8Ch case    4:*/		return 0x82060D90;
		  /* 82060D90h */ case    5:  		/* or. R30, R3, R3 */
		/* 82060D90h case    5:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 82060D90h case    5:*/		return 0x82060D94;
		  /* 82060D94h */ case    6:  		/* bc 4, CR0_LT, 40 */
		/* 82060D94h case    6:*/		if ( !regs.CR[0].lt ) { return 0x82060DBC;  }
		/* 82060D94h case    6:*/		return 0x82060D98;
		  /* 82060D98h */ case    7:  		/* lis R11, -32256 */
		/* 82060D98h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82060D98h case    7:*/		return 0x82060D9C;
		  /* 82060D9Ch */ case    8:  		/* lis R10, -32256 */
		/* 82060D9Ch case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82060D9Ch case    8:*/		return 0x82060DA0;
		  /* 82060DA0h */ case    9:  		/* addi R4, R11, 2612 */
		/* 82060DA0h case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xA34);
		/* 82060DA0h case    9:*/		return 0x82060DA4;
		  /* 82060DA4h */ case   10:  		/* addi R3, R10, 2596 */
		/* 82060DA4h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R10,0xA24);
		/* 82060DA4h case   10:*/		return 0x82060DA8;
		  /* 82060DA8h */ case   11:  		/* li R5, 205 */
		/* 82060DA8h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0xCD);
		/* 82060DA8h case   11:*/		return 0x82060DAC;
		  /* 82060DACh */ case   12:  		/* bl 191372 */
		/* 82060DACh case   12:*/		regs.LR = 0x82060DB0; return 0x8208F938;
		/* 82060DACh case   12:*/		return 0x82060DB0;
		  /* 82060DB0h */ case   13:  		/* lis R11, -32256 */
		/* 82060DB0h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82060DB0h case   13:*/		return 0x82060DB4;
		  /* 82060DB4h */ case   14:  		/* addi R3, R11, 2088 */
		/* 82060DB4h case   14:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x828);
		/* 82060DB4h case   14:*/		return 0x82060DB8;
		  /* 82060DB8h */ case   15:  		/* b -752 */
		/* 82060DB8h case   15:*/		return 0x82060AC8;
		/* 82060DB8h case   15:*/		return 0x82060DBC;
	}
	return 0x82060DBC;
} // Block from 82060D7Ch-82060DBCh (16 instructions)

//////////////////////////////////////////////////////
// Block at 82060DBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82060DBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82060DBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82060DBC);
		  /* 82060DBCh */ case    0:  		/* lis R11, -32256 */
		/* 82060DBCh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82060DBCh case    0:*/		return 0x82060DC0;
		  /* 82060DC0h */ case    1:  		/* li R5, 0 */
		/* 82060DC0h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82060DC0h case    1:*/		return 0x82060DC4;
		  /* 82060DC4h */ case    2:  		/* addi R3, R11, 2052 */
		/* 82060DC4h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x804);
		/* 82060DC4h case    2:*/		return 0x82060DC8;
		  /* 82060DC8h */ case    3:  		/* addi R4, R31, 668 */
		/* 82060DC8h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x29C);
		/* 82060DC8h case    3:*/		return 0x82060DCC;
		  /* 82060DCCh */ case    4:  		/* bl 191732 */
		/* 82060DCCh case    4:*/		regs.LR = 0x82060DD0; return 0x8208FAC0;
		/* 82060DCCh case    4:*/		return 0x82060DD0;
		  /* 82060DD0h */ case    5:  		/* or. R30, R3, R3 */
		/* 82060DD0h case    5:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 82060DD0h case    5:*/		return 0x82060DD4;
		  /* 82060DD4h */ case    6:  		/* bc 4, CR0_LT, 40 */
		/* 82060DD4h case    6:*/		if ( !regs.CR[0].lt ) { return 0x82060DFC;  }
		/* 82060DD4h case    6:*/		return 0x82060DD8;
		  /* 82060DD8h */ case    7:  		/* lis R11, -32256 */
		/* 82060DD8h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82060DD8h case    7:*/		return 0x82060DDC;
		  /* 82060DDCh */ case    8:  		/* lis R10, -32256 */
		/* 82060DDCh case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82060DDCh case    8:*/		return 0x82060DE0;
		  /* 82060DE0h */ case    9:  		/* addi R4, R11, 2612 */
		/* 82060DE0h case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xA34);
		/* 82060DE0h case    9:*/		return 0x82060DE4;
		  /* 82060DE4h */ case   10:  		/* addi R3, R10, 2596 */
		/* 82060DE4h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R10,0xA24);
		/* 82060DE4h case   10:*/		return 0x82060DE8;
		  /* 82060DE8h */ case   11:  		/* li R5, 211 */
		/* 82060DE8h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0xD3);
		/* 82060DE8h case   11:*/		return 0x82060DEC;
		  /* 82060DECh */ case   12:  		/* bl 191308 */
		/* 82060DECh case   12:*/		regs.LR = 0x82060DF0; return 0x8208F938;
		/* 82060DECh case   12:*/		return 0x82060DF0;
		  /* 82060DF0h */ case   13:  		/* lis R11, -32256 */
		/* 82060DF0h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82060DF0h case   13:*/		return 0x82060DF4;
		  /* 82060DF4h */ case   14:  		/* addi R3, R11, 2020 */
		/* 82060DF4h case   14:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x7E4);
		/* 82060DF4h case   14:*/		return 0x82060DF8;
		  /* 82060DF8h */ case   15:  		/* b -816 */
		/* 82060DF8h case   15:*/		return 0x82060AC8;
		/* 82060DF8h case   15:*/		return 0x82060DFC;
	}
	return 0x82060DFC;
} // Block from 82060DBCh-82060DFCh (16 instructions)

//////////////////////////////////////////////////////
// Block at 82060DFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82060DFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82060DFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82060DFC);
		  /* 82060DFCh */ case    0:  		/* lis R11, -32256 */
		/* 82060DFCh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82060DFCh case    0:*/		return 0x82060E00;
		  /* 82060E00h */ case    1:  		/* li R5, 0 */
		/* 82060E00h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82060E00h case    1:*/		return 0x82060E04;
		  /* 82060E04h */ case    2:  		/* addi R3, R11, 1976 */
		/* 82060E04h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x7B8);
		/* 82060E04h case    2:*/		return 0x82060E08;
		  /* 82060E08h */ case    3:  		/* addi R4, R31, 804 */
		/* 82060E08h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x324);
		/* 82060E08h case    3:*/		return 0x82060E0C;
		  /* 82060E0Ch */ case    4:  		/* bl 191804 */
		/* 82060E0Ch case    4:*/		regs.LR = 0x82060E10; return 0x8208FB48;
		/* 82060E0Ch case    4:*/		return 0x82060E10;
		  /* 82060E10h */ case    5:  		/* or. R30, R3, R3 */
		/* 82060E10h case    5:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 82060E10h case    5:*/		return 0x82060E14;
		  /* 82060E14h */ case    6:  		/* bc 4, CR0_LT, 40 */
		/* 82060E14h case    6:*/		if ( !regs.CR[0].lt ) { return 0x82060E3C;  }
		/* 82060E14h case    6:*/		return 0x82060E18;
		  /* 82060E18h */ case    7:  		/* lis R11, -32256 */
		/* 82060E18h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82060E18h case    7:*/		return 0x82060E1C;
		  /* 82060E1Ch */ case    8:  		/* lis R10, -32256 */
		/* 82060E1Ch case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82060E1Ch case    8:*/		return 0x82060E20;
		  /* 82060E20h */ case    9:  		/* addi R4, R11, 2612 */
		/* 82060E20h case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xA34);
		/* 82060E20h case    9:*/		return 0x82060E24;
		  /* 82060E24h */ case   10:  		/* addi R3, R10, 2596 */
		/* 82060E24h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R10,0xA24);
		/* 82060E24h case   10:*/		return 0x82060E28;
		  /* 82060E28h */ case   11:  		/* li R5, 218 */
		/* 82060E28h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0xDA);
		/* 82060E28h case   11:*/		return 0x82060E2C;
		  /* 82060E2Ch */ case   12:  		/* bl 191244 */
		/* 82060E2Ch case   12:*/		regs.LR = 0x82060E30; return 0x8208F938;
		/* 82060E2Ch case   12:*/		return 0x82060E30;
		  /* 82060E30h */ case   13:  		/* lis R11, -32256 */
		/* 82060E30h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82060E30h case   13:*/		return 0x82060E34;
		  /* 82060E34h */ case   14:  		/* addi R3, R11, 1936 */
		/* 82060E34h case   14:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x790);
		/* 82060E34h case   14:*/		return 0x82060E38;
		  /* 82060E38h */ case   15:  		/* b -880 */
		/* 82060E38h case   15:*/		return 0x82060AC8;
		/* 82060E38h case   15:*/		return 0x82060E3C;
	}
	return 0x82060E3C;
} // Block from 82060DFCh-82060E3Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 82060E3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82060E3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82060E3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82060E3C);
		  /* 82060E3Ch */ case    0:  		/* lis R11, -32217 */
		/* 82060E3Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82060E3Ch case    0:*/		return 0x82060E40;
		  /* 82060E40h */ case    1:  		/* vspltisw VR127, 0 */
		/* 82060E40h case    1:*/		cpu::op::vspltisw<0,0>(regs,&regs.VR127);
		/* 82060E40h case    1:*/		return 0x82060E44;
		  /* 82060E44h */ case    2:  		/* lis R10, -32256 */
		/* 82060E44h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82060E44h case    2:*/		return 0x82060E48;
		  /* 82060E48h */ case    3:  		/* addi R9, R11, 6928 */
		/* 82060E48h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x1B10);
		/* 82060E48h case    3:*/		return 0x82060E4C;
		  /* 82060E4Ch */ case    4:  		/* addi R7, R10, 1920 */
		/* 82060E4Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0x780);
		/* 82060E4Ch case    4:*/		return 0x82060E50;
		  /* 82060E50h */ case    5:  		/* lis R8, -32256 */
		/* 82060E50h case    5:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8200);
		/* 82060E50h case    5:*/		return 0x82060E54;
		  /* 82060E54h */ case    6:  		/* vupkd3d128 VR126, VR127, 1 */
		/* 82060E54h case    6:*/		cpu::op::vupkd3d128<0,1>(regs,&regs.VR126,regs.VR127);
		/* 82060E54h case    6:*/		return 0x82060E58;
		  /* 82060E58h */ case    7:  		/* lwz R11, <#[R11 + 6928]> */
		/* 82060E58h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00001B10) );
		/* 82060E58h case    7:*/		return 0x82060E5C;
		  /* 82060E5Ch */ case    8:  		/* lis R6, -32256 */
		/* 82060E5Ch case    8:*/		cpu::op::lis<0>(regs,&regs.R6,0xFFFF8200);
		/* 82060E5Ch case    8:*/		return 0x82060E60;
	}
	return 0x82060E60;
} // Block from 82060E3Ch-82060E60h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82060E60h
// Function '?Update@Sample@@UAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82060E60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82060E60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82060E60);
		  /* 82060E60h */ case    0:  		/* addi R8, R8, 1904 */
		/* 82060E60h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x770);
		/* 82060E60h case    0:*/		return 0x82060E64;
		  /* 82060E64h */ case    1:  		/* lwz R10, <#[R9 + 4]> */
		/* 82060E64h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000004) );
		/* 82060E64h case    1:*/		return 0x82060E68;
		  /* 82060E68h */ case    2:  		/* mr R9, R11 */
		/* 82060E68h case    2:*/		regs.R9 = regs.R11;
		/* 82060E68h case    2:*/		return 0x82060E6C;
		  /* 82060E6Ch */ case    3:  		/* lvx VR1, <#[R7]> */
		/* 82060E6Ch case    3:*/		cpu::mem::lvx( regs, &regs.VR1, (uint32)(regs.R7 + 0x00000000) );
		/* 82060E6Ch case    3:*/		return 0x82060E70;
		  /* 82060E70h */ case    4:  		/* vpermwi128 VR63, VR126, 234 */
		/* 82060E70h case    4:*/		cpu::op::vpermwi128<0,234>(regs,&regs.VR63,regs.VR126);
		/* 82060E70h case    4:*/		return 0x82060E74;
		  /* 82060E74h */ case    5:  		/* std R9, <#[R1 + 80]> */
		/* 82060E74h case    5:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 82060E74h case    5:*/		return 0x82060E78;
		  /* 82060E78h */ case    6:  		/* vpermwi128 VR62, VR126, 186 */
		/* 82060E78h case    6:*/		cpu::op::vpermwi128<0,186>(regs,&regs.VR62,regs.VR126);
		/* 82060E78h case    6:*/		return 0x82060E7C;
		  /* 82060E7Ch */ case    7:  		/* vpermwi128 VR60, VR126, 174 */
		/* 82060E7Ch case    7:*/		cpu::op::vpermwi128<0,174>(regs,&regs.VR60,regs.VR126);
		/* 82060E7Ch case    7:*/		return 0x82060E80;
		  /* 82060E80h */ case    8:  		/* addi R11, R31, 336 */
		/* 82060E80h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x150);
		/* 82060E80h case    8:*/		return 0x82060E84;
		  /* 82060E84h */ case    9:  		/* lvx VR61, <#[R8]> */
		/* 82060E84h case    9:*/		cpu::mem::lvx( regs, &regs.VR61, (uint32)(regs.R8 + 0x00000000) );
		/* 82060E84h case    9:*/		return 0x82060E88;
		  /* 82060E88h */ case   10:  		/* li R28, 16 */
		/* 82060E88h case   10:*/		cpu::op::li<0>(regs,&regs.R28,0x10);
		/* 82060E88h case   10:*/		return 0x82060E8C;
		  /* 82060E8Ch */ case   11:  		/* std R10, <#[R1 + 112]> */
		/* 82060E8Ch case   11:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000070) );
		/* 82060E8Ch case   11:*/		return 0x82060E90;
		  /* 82060E90h */ case   12:  		/* lfd FR13, <#[R1 + 112]> */
		/* 82060E90h case   12:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000070) );
		/* 82060E90h case   12:*/		return 0x82060E94;
		  /* 82060E94h */ case   13:  		/* fcfid FR13, FR13 */
		/* 82060E94h case   13:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 82060E94h case   13:*/		return 0x82060E98;
		  /* 82060E98h */ case   14:  		/* vsubfp VR2, VR61, VR1 */
		/* 82060E98h case   14:*/		cpu::op::vsubfp<0>(regs,&regs.VR2,regs.VR61,regs.VR1);
		/* 82060E98h case   14:*/		return 0x82060E9C;
		  /* 82060E9Ch */ case   15:  		/* lfd FR0, <#[R1 + 80]> */
		/* 82060E9Ch case   15:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 82060E9Ch case   15:*/		return 0x82060EA0;
		  /* 82060EA0h */ case   16:  		/* frsp FR13, FR13 */
		/* 82060EA0h case   16:*/		cpu::op::frsp<0>(regs,&regs.FR13,regs.FR13);
		/* 82060EA0h case   16:*/		return 0x82060EA4;
		  /* 82060EA4h */ case   17:  		/* fcfid FR0, FR0 */
		/* 82060EA4h case   17:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 82060EA4h case   17:*/		return 0x82060EA8;
		  /* 82060EA8h */ case   18:  		/* vpermwi128 VR61, VR126, 171 */
		/* 82060EA8h case   18:*/		cpu::op::vpermwi128<0,171>(regs,&regs.VR61,regs.VR126);
		/* 82060EA8h case   18:*/		return 0x82060EAC;
		  /* 82060EACh */ case   19:  		/* addi R10, R6, 1888 */
		/* 82060EACh case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R6,0x760);
		/* 82060EACh case   19:*/		return 0x82060EB0;
		  /* 82060EB0h */ case   20:  		/* stvx VR63, <#[R11]> */
		/* 82060EB0h case   20:*/		cpu::mem::stvx( regs, regs.VR63, (uint32)(regs.R11 + 0x00000000) );
		/* 82060EB0h case   20:*/		return 0x82060EB4;
		  /* 82060EB4h */ case   21:  		/* li R29, 32 */
		/* 82060EB4h case   21:*/		cpu::op::li<0>(regs,&regs.R29,0x20);
		/* 82060EB4h case   21:*/		return 0x82060EB8;
		  /* 82060EB8h */ case   22:  		/* stvx VR62, <#[R11 + R28]> */
		/* 82060EB8h case   22:*/		cpu::mem::stvx( regs, regs.VR62, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 82060EB8h case   22:*/		return 0x82060EBC;
		  /* 82060EBCh */ case   23:  		/* li R30, 48 */
		/* 82060EBCh case   23:*/		cpu::op::li<0>(regs,&regs.R30,0x30);
		/* 82060EBCh case   23:*/		return 0x82060EC0;
		  /* 82060EC0h */ case   24:  		/* addi R3, R1, 208 */
		/* 82060EC0h case   24:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xD0);
		/* 82060EC0h case   24:*/		return 0x82060EC4;
		  /* 82060EC4h */ case   25:  		/* lvx VR3, <#[R10]> */
		/* 82060EC4h case   25:*/		cpu::mem::lvx( regs, &regs.VR3, (uint32)(regs.R10 + 0x00000000) );
		/* 82060EC4h case   25:*/		return 0x82060EC8;
		  /* 82060EC8h */ case   26:  		/* stvx VR60, <#[R11 + R29]> */
		/* 82060EC8h case   26:*/		cpu::mem::stvx( regs, regs.VR60, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 82060EC8h case   26:*/		return 0x82060ECC;
		  /* 82060ECCh */ case   27:  		/* stvx VR61, <#[R11 + R30]> */
		/* 82060ECCh case   27:*/		cpu::mem::stvx( regs, regs.VR61, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82060ECCh case   27:*/		return 0x82060ED0;
		  /* 82060ED0h */ case   28:  		/* frsp FR0, FR0 */
		/* 82060ED0h case   28:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 82060ED0h case   28:*/		return 0x82060ED4;
		  /* 82060ED4h */ case   29:  		/* fdivs FR31, FR0, FR13 */
		/* 82060ED4h case   29:*/		cpu::op::fdivs<0>(regs,&regs.FR31,regs.FR0,regs.FR13);
		/* 82060ED4h case   29:*/		return 0x82060ED8;
		  /* 82060ED8h */ case   30:  		/* bl -3280 */
		/* 82060ED8h case   30:*/		regs.LR = 0x82060EDC; return 0x82060208;
		/* 82060ED8h case   30:*/		return 0x82060EDC;
		  /* 82060EDCh */ case   31:  		/* mr R10, R3 */
		/* 82060EDCh case   31:*/		regs.R10 = regs.R3;
		/* 82060EDCh case   31:*/		return 0x82060EE0;
		  /* 82060EE0h */ case   32:  		/* vpermwi128 VR126, VR126, 171 */
		/* 82060EE0h case   32:*/		cpu::op::vpermwi128<0,171>(regs,&regs.VR126,regs.VR126);
		/* 82060EE0h case   32:*/		return 0x82060EE4;
		  /* 82060EE4h */ case   33:  		/* addi R11, R31, 400 */
		/* 82060EE4h case   33:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x190);
		/* 82060EE4h case   33:*/		return 0x82060EE8;
		  /* 82060EE8h */ case   34:  		/* lis R9, -32256 */
		/* 82060EE8h case   34:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 82060EE8h case   34:*/		return 0x82060EEC;
		  /* 82060EECh */ case   35:  		/* addi R4, R1, 96 */
		/* 82060EECh case   35:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 82060EECh case   35:*/		return 0x82060EF0;
		  /* 82060EF0h */ case   36:  		/* addi R3, R1, 112 */
		/* 82060EF0h case   36:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x70);
		/* 82060EF0h case   36:*/		return 0x82060EF4;
		  /* 82060EF4h */ case   37:  		/* lvx VR63, <#[R10]> */
		/* 82060EF4h case   37:*/		cpu::mem::lvx( regs, &regs.VR63, (uint32)(regs.R10 + 0x00000000) );
		/* 82060EF4h case   37:*/		return 0x82060EF8;
		  /* 82060EF8h */ case   38:  		/* lvx VR62, <#[R10 + R28]> */
		/* 82060EF8h case   38:*/		cpu::mem::lvx( regs, &regs.VR62, (uint32)(regs.R10 + regs.R28 + 0x00000000) );
		/* 82060EF8h case   38:*/		return 0x82060EFC;
		  /* 82060EFCh */ case   39:  		/* lvx VR61, <#[R10 + R29]> */
		/* 82060EFCh case   39:*/		cpu::mem::lvx( regs, &regs.VR61, (uint32)(regs.R10 + regs.R29 + 0x00000000) );
		/* 82060EFCh case   39:*/		return 0x82060F00;
		  /* 82060F00h */ case   40:  		/* lvx VR60, <#[R10 + R30]> */
		/* 82060F00h case   40:*/		cpu::mem::lvx( regs, &regs.VR60, (uint32)(regs.R10 + regs.R30 + 0x00000000) );
		/* 82060F00h case   40:*/		return 0x82060F04;
		  /* 82060F04h */ case   41:  		/* stvx VR63, <#[R11]> */
		/* 82060F04h case   41:*/		cpu::mem::stvx( regs, regs.VR63, (uint32)(regs.R11 + 0x00000000) );
		/* 82060F04h case   41:*/		return 0x82060F08;
		  /* 82060F08h */ case   42:  		/* stvx VR62, <#[R11 + R28]> */
		/* 82060F08h case   42:*/		cpu::mem::stvx( regs, regs.VR62, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 82060F08h case   42:*/		return 0x82060F0C;
		  /* 82060F0Ch */ case   43:  		/* stvx VR61, <#[R11 + R29]> */
		/* 82060F0Ch case   43:*/		cpu::mem::stvx( regs, regs.VR61, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 82060F0Ch case   43:*/		return 0x82060F10;
		  /* 82060F10h */ case   44:  		/* stvx VR60, <#[R11 + R30]> */
		/* 82060F10h case   44:*/		cpu::mem::stvx( regs, regs.VR60, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82060F10h case   44:*/		return 0x82060F14;
		  /* 82060F14h */ case   45:  		/* lfs FR1, <#[R9 + 1876]> */
		/* 82060F14h case   45:*/		cpu::mem::load32f( regs, &regs.FR1, (uint32)(regs.R9 + 0x00000754) );
		/* 82060F14h case   45:*/		return 0x82060F18;
		  /* 82060F18h */ case   46:  		/* bl -3120 */
		/* 82060F18h case   46:*/		regs.LR = 0x82060F1C; return 0x820602E8;
		/* 82060F18h case   46:*/		return 0x82060F1C;
		  /* 82060F1Ch */ case   47:  		/* lis R10, -32256 */
		/* 82060F1Ch case   47:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82060F1Ch case   47:*/		return 0x82060F20;
		  /* 82060F20h */ case   48:  		/* lis R9, -32256 */
		/* 82060F20h case   48:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 82060F20h case   48:*/		return 0x82060F24;
		  /* 82060F24h */ case   49:  		/* mr VR62, VR127 */
		/* 82060F24h case   49:*/		regs.VR62 = regs.VR127;
		/* 82060F24h case   49:*/		return 0x82060F28;
		  /* 82060F28h */ case   50:  		/* addi R8, R1, 80 */
		/* 82060F28h case   50:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x50);
		/* 82060F28h case   50:*/		return 0x82060F2C;
		  /* 82060F2Ch */ case   51:  		/* mr VR61, VR127 */
		/* 82060F2Ch case   51:*/		regs.VR61 = regs.VR127;
		/* 82060F2Ch case   51:*/		return 0x82060F30;
		  /* 82060F30h */ case   52:  		/* addi R11, R31, 464 */
		/* 82060F30h case   52:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x1D0);
		/* 82060F30h case   52:*/		return 0x82060F34;
		  /* 82060F34h */ case   53:  		/* li R3, 0 */
		/* 82060F34h case   53:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82060F34h case   53:*/		return 0x82060F38;
		  /* 82060F38h */ case   54:  		/* lfs FR0, <#[R10 + 1872]> */
		/* 82060F38h case   54:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000750) );
		/* 82060F38h case   54:*/		return 0x82060F3C;
		  /* 82060F3Ch */ case   55:  		/* lfs FR13, <#[R9 + 1868]> */
		/* 82060F3Ch case   55:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R9 + 0x0000074C) );
		/* 82060F3Ch case   55:*/		return 0x82060F40;
		  /* 82060F40h */ case   56:  		/* stfs FR0, <#[R1 + 88]> */
		/* 82060F40h case   56:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 82060F40h case   56:*/		return 0x82060F44;
		  /* 82060F44h */ case   57:  		/* stfs FR13, <#[R1 + 92]> */
		/* 82060F44h case   57:*/		cpu::mem::store32f( regs, regs.FR13, (uint32)(regs.R1 + 0x0000005C) );
		/* 82060F44h case   57:*/		return 0x82060F48;
		  /* 82060F48h */ case   58:  		/* lfs FR0, <#[R1 + 96]> */
		/* 82060F48h case   58:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000060) );
		/* 82060F48h case   58:*/		return 0x82060F4C;
		  /* 82060F4Ch */ case   59:  		/* lfs FR13, <#[R1 + 112]> */
		/* 82060F4Ch case   59:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000070) );
		/* 82060F4Ch case   59:*/		return 0x82060F50;
		  /* 82060F50h */ case   60:  		/* fdivs FR0, FR0, FR13 */
		/* 82060F50h case   60:*/		cpu::op::fdivs<0>(regs,&regs.FR0,regs.FR0,regs.FR13);
		/* 82060F50h case   60:*/		return 0x82060F54;
		  /* 82060F54h */ case   61:  		/* stfs FR0, <#[R1 + 84]> */
		/* 82060F54h case   61:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000054) );
		/* 82060F54h case   61:*/		return 0x82060F58;
		  /* 82060F58h */ case   62:  		/* fdivs FR0, FR0, FR31 */
		/* 82060F58h case   62:*/		cpu::op::fdivs<0>(regs,&regs.FR0,regs.FR0,regs.FR31);
		/* 82060F58h case   62:*/		return 0x82060F5C;
		  /* 82060F5Ch */ case   63:  		/* stfs FR0, <#[R1 + 80]> */
		/* 82060F5Ch case   63:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 82060F5Ch case   63:*/		return 0x82060F60;
		  /* 82060F60h */ case   64:  		/* lvx VR63, <#[R8]> */
		/* 82060F60h case   64:*/		cpu::mem::lvx( regs, &regs.VR63, (uint32)(regs.R8 + 0x00000000) );
		/* 82060F60h case   64:*/		return 0x82060F64;
		  /* 82060F64h */ case   65:  		/* vrlimi128 VR62, VR63, 8, 0 */
		/* 82060F64h case   65:*/		cpu::op::vrlimi128<0,8,0>(regs,&regs.VR62,regs.VR63);
		/* 82060F64h case   65:*/		return 0x82060F68;
		  /* 82060F68h */ case   66:  		/* vrlimi128 VR61, VR63, 4, 0 */
		/* 82060F68h case   66:*/		cpu::op::vrlimi128<0,4,0>(regs,&regs.VR61,regs.VR63);
		/* 82060F68h case   66:*/		return 0x82060F6C;
		  /* 82060F6Ch */ case   67:  		/* vrlimi128 VR126, VR63, 2, 0 */
		/* 82060F6Ch case   67:*/		cpu::op::vrlimi128<0,2,0>(regs,&regs.VR126,regs.VR63);
		/* 82060F6Ch case   67:*/		return 0x82060F70;
		  /* 82060F70h */ case   68:  		/* vrlimi128 VR127, VR63, 2, 1 */
		/* 82060F70h case   68:*/		cpu::op::vrlimi128<0,2,1>(regs,&regs.VR127,regs.VR63);
		/* 82060F70h case   68:*/		return 0x82060F74;
		  /* 82060F74h */ case   69:  		/* stvx VR62, <#[R11]> */
		/* 82060F74h case   69:*/		cpu::mem::stvx( regs, regs.VR62, (uint32)(regs.R11 + 0x00000000) );
		/* 82060F74h case   69:*/		return 0x82060F78;
		  /* 82060F78h */ case   70:  		/* stvx VR61, <#[R11 + R28]> */
		/* 82060F78h case   70:*/		cpu::mem::stvx( regs, regs.VR61, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 82060F78h case   70:*/		return 0x82060F7C;
		  /* 82060F7Ch */ case   71:  		/* stvx VR126, <#[R11 + R29]> */
		/* 82060F7Ch case   71:*/		cpu::mem::stvx( regs, regs.VR126, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 82060F7Ch case   71:*/		return 0x82060F80;
		  /* 82060F80h */ case   72:  		/* stvx VR127, <#[R11 + R30]> */
		/* 82060F80h case   72:*/		cpu::mem::stvx( regs, regs.VR127, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82060F80h case   72:*/		return 0x82060F84;
	}
	return 0x82060F84;
} // Block from 82060E60h-82060F84h (73 instructions)

//////////////////////////////////////////////////////
// Block at 82060F84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82060F84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82060F84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82060F84);
		  /* 82060F84h */ case    0:  		/* addi R1, R1, 1136 */
		/* 82060F84h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x470);
		/* 82060F84h case    0:*/		return 0x82060F88;
		  /* 82060F88h */ case    1:  		/* li R0, -96 */
		/* 82060F88h case    1:*/		cpu::op::li<0>(regs,&regs.R0,0xFFFFFFA0);
		/* 82060F88h case    1:*/		return 0x82060F8C;
		  /* 82060F8Ch */ case    2:  		/* lvx VR126, <#[R1 + R0]> */
		/* 82060F8Ch case    2:*/		cpu::mem::lvx( regs, &regs.VR126, (uint32)(regs.R1 + regs.R0 + 0x00000000) );
		/* 82060F8Ch case    2:*/		return 0x82060F90;
		  /* 82060F90h */ case    3:  		/* li R0, -80 */
		/* 82060F90h case    3:*/		cpu::op::li<0>(regs,&regs.R0,0xFFFFFFB0);
		/* 82060F90h case    3:*/		return 0x82060F94;
		  /* 82060F94h */ case    4:  		/* lvx VR127, <#[R1 + R0]> */
		/* 82060F94h case    4:*/		cpu::mem::lvx( regs, &regs.VR127, (uint32)(regs.R1 + regs.R0 + 0x00000000) );
		/* 82060F94h case    4:*/		return 0x82060F98;
		  /* 82060F98h */ case    5:  		/* lfd FR31, <#[R1 - 56]> */
		/* 82060F98h case    5:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFC8) );
		/* 82060F98h case    5:*/		return 0x82060F9C;
		  /* 82060F9Ch */ case    6:  		/* b 197384 */
		/* 82060F9Ch case    6:*/		return 0x820912A4;
		/* 82060F9Ch case    6:*/		return 0x82060FA0;
	}
	return 0x82060FA0;
} // Block from 82060F84h-82060FA0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82060FA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82060FA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82060FA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82060FA0);
		  /* 82060FA0h */ case    0:  		/* mfspr R12, LR */
		/* 82060FA0h case    0:*/		regs.R12 = regs.LR;
		/* 82060FA0h case    0:*/		return 0x82060FA4;
		  /* 82060FA4h */ case    1:  		/* bl 197288 */
		/* 82060FA4h case    1:*/		regs.LR = 0x82060FA8; return 0x8209124C;
		/* 82060FA4h case    1:*/		return 0x82060FA8;
		  /* 82060FA8h */ case    2:  		/* addi R12, R1, -64 */
		/* 82060FA8h case    2:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R1,0xFFFFFFC0);
		/* 82060FA8h case    2:*/		return 0x82060FAC;
		  /* 82060FACh */ case    3:  		/* bl 197736 */
		/* 82060FACh case    3:*/		regs.LR = 0x82060FB0; return 0x82091414;
		/* 82060FACh case    3:*/		return 0x82060FB0;
		  /* 82060FB0h */ case    4:  		/* addi R12, R1, -112 */
		/* 82060FB0h case    4:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R1,0xFFFFFF90);
		/* 82060FB0h case    4:*/		return 0x82060FB4;
		  /* 82060FB4h */ case    5:  		/* bl 198448 */
		/* 82060FB4h case    5:*/		regs.LR = 0x82060FB8; return 0x820916E4;
		/* 82060FB4h case    5:*/		return 0x82060FB8;
		  /* 82060FB8h */ case    6:  		/* stwu R1, <#[R1 - 816]> */
		/* 82060FB8h case    6:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFCD0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFCD0);
		/* 82060FB8h case    6:*/		return 0x82060FBC;
		  /* 82060FBCh */ case    7:  		/* addi R31, R3, 8 */
		/* 82060FBCh case    7:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R3,0x8);
		/* 82060FBCh case    7:*/		return 0x82060FC0;
		  /* 82060FC0h */ case    8:  		/* mr R26, R3 */
		/* 82060FC0h case    8:*/		regs.R26 = regs.R3;
		/* 82060FC0h case    8:*/		return 0x82060FC4;
		  /* 82060FC4h */ case    9:  		/* mr R3, R31 */
		/* 82060FC4h case    9:*/		regs.R3 = regs.R31;
		/* 82060FC4h case    9:*/		return 0x82060FC8;
		  /* 82060FC8h */ case   10:  		/* bl -2952 */
		/* 82060FC8h case   10:*/		regs.LR = 0x82060FCC; return 0x82060440;
		/* 82060FC8h case   10:*/		return 0x82060FCC;
		  /* 82060FCCh */ case   11:  		/* lfd FR0, <#[R26 + 32]> */
		/* 82060FCCh case   11:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R26 + 0x00000020) );
		/* 82060FCCh case   11:*/		return 0x82060FD0;
		  /* 82060FD0h */ case   12:  		/* fsub FR0, FR1, FR0 */
		/* 82060FD0h case   12:*/		cpu::op::fsub<0>(regs,&regs.FR0,regs.FR1,regs.FR0);
		/* 82060FD0h case   12:*/		return 0x82060FD4;
		  /* 82060FD4h */ case   13:  		/* li R4, 0 */
		/* 82060FD4h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82060FD4h case   13:*/		return 0x82060FD8;
		  /* 82060FD8h */ case   14:  		/* li R3, 0 */
		/* 82060FD8h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82060FD8h case   14:*/		return 0x82060FDC;
		  /* 82060FDCh */ case   15:  		/* frsp FR30, FR0 */
		/* 82060FDCh case   15:*/		cpu::op::frsp<0>(regs,&regs.FR30,regs.FR0);
		/* 82060FDCh case   15:*/		return 0x82060FE0;
		  /* 82060FE0h */ case   16:  		/* bl 193816 */
		/* 82060FE0h case   16:*/		regs.LR = 0x82060FE4; return 0x820904F8;
		/* 82060FE0h case   16:*/		return 0x82060FE4;
		  /* 82060FE4h */ case   17:  		/* lhz R11, <#[R3 + 40]> */
		/* 82060FE4h case   17:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000028) );
		/* 82060FE4h case   17:*/		return 0x82060FE8;
		  /* 82060FE8h */ case   18:  		/* rlwinm. R11, R11, 0, 27, 27 */
		/* 82060FE8h case   18:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R11);
		/* 82060FE8h case   18:*/		return 0x82060FEC;
		  /* 82060FECh */ case   19:  		/* bc 12, CR0_EQ, 72 */
		/* 82060FECh case   19:*/		if ( regs.CR[0].eq ) { return 0x82061034;  }
		/* 82060FECh case   19:*/		return 0x82060FF0;
		  /* 82060FF0h */ case   20:  		/* lis R10, -32216 */
		/* 82060FF0h case   20:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8228);
		/* 82060FF0h case   20:*/		return 0x82060FF4;
		  /* 82060FF4h */ case   21:  		/* mr R3, R31 */
		/* 82060FF4h case   21:*/		regs.R3 = regs.R31;
		/* 82060FF4h case   21:*/		return 0x82060FF8;
		  /* 82060FF8h */ case   22:  		/* lwz R11, <#[R10 + 28676]> */
		/* 82060FF8h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00007004) );
		/* 82060FF8h case   22:*/		return 0x82060FFC;
		  /* 82060FFCh */ case   23:  		/* cntlzw R11, R11 */
		/* 82060FFCh case   23:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 82060FFCh case   23:*/		return 0x82061000;
		  /* 82061000h */ case   24:  		/* rlwinm. R11, R11, 27, 31, 31 */
		/* 82061000h case   24:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R11,regs.R11);
		/* 82061000h case   24:*/		return 0x82061004;
		  /* 82061004h */ case   25:  		/* stw R11, <#[R10 + 28676]> */
		/* 82061004h case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00007004) );
		/* 82061004h case   25:*/		return 0x82061008;
		  /* 82061008h */ case   26:  		/* bc 12, CR0_EQ, 40 */
		/* 82061008h case   26:*/		if ( regs.CR[0].eq ) { return 0x82061030;  }
		/* 82061008h case   26:*/		return 0x8206100C;
		  /* 8206100Ch */ case   27:  		/* bl -3020 */
		/* 8206100Ch case   27:*/		regs.LR = 0x82061010; return 0x82060440;
		/* 8206100Ch case   27:*/		return 0x82061010;
		  /* 82061010h */ case   28:  		/* lwz R11, <#[R31 + 40]> */
		/* 82061010h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 82061010h case   28:*/		return 0x82061014;
		  /* 82061014h */ case   29:  		/* cmpwi CR6, R11, 0 */
		/* 82061014h case   29:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82061014h case   29:*/		return 0x82061018;
		  /* 82061018h */ case   30:  		/* bc 4, CR6_EQ, 28 */
		/* 82061018h case   30:*/		if ( !regs.CR[6].eq ) { return 0x82061034;  }
		/* 82061018h case   30:*/		return 0x8206101C;
		  /* 8206101Ch */ case   31:  		/* li R11, 1 */
		/* 8206101Ch case   31:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8206101Ch case   31:*/		return 0x82061020;
		  /* 82061020h */ case   32:  		/* stfd FR1, <#[R31 + 32]> */
		/* 82061020h case   32:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R31 + 0x00000020) );
		/* 82061020h case   32:*/		return 0x82061024;
		  /* 82061024h */ case   33:  		/* stfd FR1, <#[R31 + 16]> */
		/* 82061024h case   33:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R31 + 0x00000010) );
		/* 82061024h case   33:*/		return 0x82061028;
		  /* 82061028h */ case   34:  		/* stw R11, <#[R31 + 40]> */
		/* 82061028h case   34:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 82061028h case   34:*/		return 0x8206102C;
		  /* 8206102Ch */ case   35:  		/* b 8 */
		/* 8206102Ch case   35:*/		return 0x82061034;
		/* 8206102Ch case   35:*/		return 0x82061030;
	}
	return 0x82061030;
} // Block from 82060FA0h-82061030h (36 instructions)

//////////////////////////////////////////////////////
// Block at 82061030h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82061030( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82061030) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82061030);
		  /* 82061030h */ case    0:  		/* bl -2960 */
		/* 82061030h case    0:*/		regs.LR = 0x82061034; return 0x820604A0;
		/* 82061030h case    0:*/		return 0x82061034;
	}
	return 0x82061034;
} // Block from 82061030h-82061034h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82061034h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82061034( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82061034) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82061034);
		  /* 82061034h */ case    0:  		/* lis R11, -32256 */
		/* 82061034h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82061034h case    0:*/		return 0x82061038;
		  /* 82061038h */ case    1:  		/* lis R10, -32256 */
		/* 82061038h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82061038h case    1:*/		return 0x8206103C;
		  /* 8206103Ch */ case    2:  		/* lfs FR0, <#[R11 + 2752]> */
		/* 8206103Ch case    2:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000AC0) );
		/* 8206103Ch case    2:*/		return 0x82061040;
		  /* 82061040h */ case    3:  		/* fmuls FR28, FR30, FR0 */
		/* 82061040h case    3:*/		cpu::op::fmuls<0>(regs,&regs.FR28,regs.FR30,regs.FR0);
		/* 82061040h case    3:*/		return 0x82061044;
		  /* 82061044h */ case    4:  		/* lfs FR13, <#[R10 + 2748]> */
		/* 82061044h case    4:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R10 + 0x00000ABC) );
		/* 82061044h case    4:*/		return 0x82061048;
		  /* 82061048h */ case    5:  		/* fmuls FR31, FR30, FR13 */
		/* 82061048h case    5:*/		cpu::op::fmuls<0>(regs,&regs.FR31,regs.FR30,regs.FR13);
		/* 82061048h case    5:*/		return 0x8206104C;
		  /* 8206104Ch */ case    6:  		/* fmr FR1, FR28 */
		/* 8206104Ch case    6:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR28);
		/* 8206104Ch case    6:*/		return 0x82061050;
		  /* 82061050h */ case    7:  		/* bl 195192 */
		/* 82061050h case    7:*/		regs.LR = 0x82061054; return 0x82090AC8;
		/* 82061050h case    7:*/		return 0x82061054;
		  /* 82061054h */ case    8:  		/* lis R11, -32256 */
		/* 82061054h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82061054h case    8:*/		return 0x82061058;
		  /* 82061058h */ case    9:  		/* vspltisw VR127, 0 */
		/* 82061058h case    9:*/		cpu::op::vspltisw<0,0>(regs,&regs.VR127);
		/* 82061058h case    9:*/		return 0x8206105C;
		  /* 8206105Ch */ case   10:  		/* frsp FR29, FR1 */
		/* 8206105Ch case   10:*/		cpu::op::frsp<0>(regs,&regs.FR29,regs.FR1);
		/* 8206105Ch case   10:*/		return 0x82061060;
		  /* 82061060h */ case   11:  		/* addi R11, R11, 2744 */
		/* 82061060h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xAB8);
		/* 82061060h case   11:*/		return 0x82061064;
		  /* 82061064h */ case   12:  		/* fmr FR1, FR28 */
		/* 82061064h case   12:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR28);
		/* 82061064h case   12:*/		return 0x82061068;
		  /* 82061068h */ case   13:  		/* mr VR63, VR127 */
		/* 82061068h case   13:*/		regs.VR63 = regs.VR127;
		/* 82061068h case   13:*/		return 0x8206106C;
		  /* 8206106Ch */ case   14:  		/* vupkd3d128 VR126, VR127, 1 */
		/* 8206106Ch case   14:*/		cpu::op::vupkd3d128<0,1>(regs,&regs.VR126,regs.VR127);
		/* 8206106Ch case   14:*/		return 0x82061070;
		  /* 82061070h */ case   15:  		/* mr VR62, VR127 */
		/* 82061070h case   15:*/		regs.VR62 = regs.VR127;
		/* 82061070h case   15:*/		return 0x82061074;
		  /* 82061074h */ case   16:  		/* lvlx VR61, <#[R11]> */
		/* 82061074h case   16:*/		cpu::mem::lvlx( regs, &regs.VR61, (uint32)(regs.R11 + 0x00000000) );
		/* 82061074h case   16:*/		return 0x82061078;
		  /* 82061078h */ case   17:  		/* mr VR60, VR61 */
		/* 82061078h case   17:*/		regs.VR60 = regs.VR61;
		/* 82061078h case   17:*/		return 0x8206107C;
		  /* 8206107Ch */ case   18:  		/* vpermwi128 VR125, VR126, 171 */
		/* 8206107Ch case   18:*/		cpu::op::vpermwi128<0,171>(regs,&regs.VR125,regs.VR126);
		/* 8206107Ch case   18:*/		return 0x82061080;
		  /* 82061080h */ case   19:  		/* vrlimi128 VR63, VR61, 4, 3 */
		/* 82061080h case   19:*/		cpu::op::vrlimi128<0,4,3>(regs,&regs.VR63,regs.VR61);
		/* 82061080h case   19:*/		return 0x82061084;
		  /* 82061084h */ case   20:  		/* vrlimi128 VR62, VR61, 2, 2 */
		/* 82061084h case   20:*/		cpu::op::vrlimi128<0,2,2>(regs,&regs.VR62,regs.VR61);
		/* 82061084h case   20:*/		return 0x82061088;
		  /* 82061088h */ case   21:  		/* vrlimi128 VR60, VR127, 7, 0 */
		/* 82061088h case   21:*/		cpu::op::vrlimi128<0,7,0>(regs,&regs.VR60,regs.VR127);
		/* 82061088h case   21:*/		return 0x8206108C;
		  /* 8206108Ch */ case   22:  		/* mr VR124, VR63 */
		/* 8206108Ch case   22:*/		regs.VR124 = regs.VR63;
		/* 8206108Ch case   22:*/		return 0x82061090;
		  /* 82061090h */ case   23:  		/* mr VR123, VR62 */
		/* 82061090h case   23:*/		regs.VR123 = regs.VR62;
		/* 82061090h case   23:*/		return 0x82061094;
		  /* 82061094h */ case   24:  		/* mr VR122, VR60 */
		/* 82061094h case   24:*/		regs.VR122 = regs.VR60;
		/* 82061094h case   24:*/		return 0x82061098;
		  /* 82061098h */ case   25:  		/* bl 195344 */
		/* 82061098h case   25:*/		regs.LR = 0x8206109C; return 0x82090BA8;
		/* 82061098h case   25:*/		return 0x8206109C;
		  /* 8206109Ch */ case   26:  		/* frsp FR13, FR1 */
		/* 8206109Ch case   26:*/		cpu::op::frsp<0>(regs,&regs.FR13,regs.FR1);
		/* 8206109Ch case   26:*/		return 0x820610A0;
		  /* 820610A0h */ case   27:  		/* lis R11, -32256 */
		/* 820610A0h case   27:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820610A0h case   27:*/		return 0x820610A4;
		  /* 820610A4h */ case   28:  		/* addi R3, R1, 288 */
		/* 820610A4h case   28:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x120);
		/* 820610A4h case   28:*/		return 0x820610A8;
		  /* 820610A8h */ case   29:  		/* lfs FR0, <#[R11 + 2740]> */
		/* 820610A8h case   29:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000AB4) );
		/* 820610A8h case   29:*/		return 0x820610AC;
		  /* 820610ACh */ case   30:  		/* fmuls FR1, FR13, FR0 */
		/* 820610ACh case   30:*/		cpu::op::fmuls<0>(regs,&regs.FR1,regs.FR13,regs.FR0);
		/* 820610ACh case   30:*/		return 0x820610B0;
		  /* 820610B0h */ case   31:  		/* bl -2456 */
		/* 820610B0h case   31:*/		regs.LR = 0x820610B4; return 0x82060718;
		/* 820610B0h case   31:*/		return 0x820610B4;
		  /* 820610B4h */ case   32:  		/* mr R11, R3 */
		/* 820610B4h case   32:*/		regs.R11 = regs.R3;
		/* 820610B4h case   32:*/		return 0x820610B8;
		  /* 820610B8h */ case   33:  		/* vspltw VR63, VR122, 0 */
		/* 820610B8h case   33:*/		cpu::op::vspltw<0,0>(regs,&regs.VR63,regs.VR122);
		/* 820610B8h case   33:*/		return 0x820610BC;
		  /* 820610BCh */ case   34:  		/* vspltw VR62, VR124, 0 */
		/* 820610BCh case   34:*/		cpu::op::vspltw<0,0>(regs,&regs.VR62,regs.VR124);
		/* 820610BCh case   34:*/		return 0x820610C0;
		  /* 820610C0h */ case   35:  		/* li R27, 16 */
		/* 820610C0h case   35:*/		cpu::op::li<0>(regs,&regs.R27,0x10);
		/* 820610C0h case   35:*/		return 0x820610C4;
		  /* 820610C4h */ case   36:  		/* vspltw VR61, VR123, 0 */
		/* 820610C4h case   36:*/		cpu::op::vspltw<0,0>(regs,&regs.VR61,regs.VR123);
		/* 820610C4h case   36:*/		return 0x820610C8;
		  /* 820610C8h */ case   37:  		/* li R28, 32 */
		/* 820610C8h case   37:*/		cpu::op::li<0>(regs,&regs.R28,0x20);
		/* 820610C8h case   37:*/		return 0x820610CC;
		  /* 820610CCh */ case   38:  		/* vspltw VR60, VR125, 0 */
		/* 820610CCh case   38:*/		cpu::op::vspltw<0,0>(regs,&regs.VR60,regs.VR125);
		/* 820610CCh case   38:*/		return 0x820610D0;
		  /* 820610D0h */ case   39:  		/* li R29, 48 */
		/* 820610D0h case   39:*/		cpu::op::li<0>(regs,&regs.R29,0x30);
		/* 820610D0h case   39:*/		return 0x820610D4;
		  /* 820610D4h */ case   40:  		/* vspltw VR11, VR122, 1 */
		/* 820610D4h case   40:*/		cpu::op::vspltw<0,1>(regs,&regs.VR11,regs.VR122);
		/* 820610D4h case   40:*/		return 0x820610D8;
		  /* 820610D8h */ case   41:  		/* addi R3, R1, 224 */
		/* 820610D8h case   41:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0xE0);
		/* 820610D8h case   41:*/		return 0x820610DC;
		  /* 820610DCh */ case   42:  		/* lvx VR59, <#[R11]> */
		/* 820610DCh case   42:*/		cpu::mem::lvx( regs, &regs.VR59, (uint32)(regs.R11 + 0x00000000) );
		/* 820610DCh case   42:*/		return 0x820610E0;
		  /* 820610E0h */ case   43:  		/* vspltw VR9, VR124, 1 */
		/* 820610E0h case   43:*/		cpu::op::vspltw<0,1>(regs,&regs.VR9,regs.VR124);
		/* 820610E0h case   43:*/		return 0x820610E4;
		  /* 820610E4h */ case   44:  		/* vmulfp128 VR10, VR63, VR59 */
		/* 820610E4h case   44:*/		cpu::op::vmulfp128<0>(regs,&regs.VR10,regs.VR63,regs.VR59);
		/* 820610E4h case   44:*/		return 0x820610E8;
		  /* 820610E8h */ case   45:  		/* vspltw VR7, VR123, 1 */
		/* 820610E8h case   45:*/		cpu::op::vspltw<0,1>(regs,&regs.VR7,regs.VR123);
		/* 820610E8h case   45:*/		return 0x820610EC;
		  /* 820610ECh */ case   46:  		/* vmulfp128 VR8, VR62, VR59 */
		/* 820610ECh case   46:*/		cpu::op::vmulfp128<0>(regs,&regs.VR8,regs.VR62,regs.VR59);
		/* 820610ECh case   46:*/		return 0x820610F0;
		  /* 820610F0h */ case   47:  		/* lvx VR0, <#[R11 + R27]> */
		/* 820610F0h case   47:*/		cpu::mem::lvx( regs, &regs.VR0, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 820610F0h case   47:*/		return 0x820610F4;
		  /* 820610F4h */ case   48:  		/* vmulfp128 VR6, VR61, VR59 */
		/* 820610F4h case   48:*/		cpu::op::vmulfp128<0>(regs,&regs.VR6,regs.VR61,regs.VR59);
		/* 820610F4h case   48:*/		return 0x820610F8;
		  /* 820610F8h */ case   49:  		/* vspltw VR5, VR125, 1 */
		/* 820610F8h case   49:*/		cpu::op::vspltw<0,1>(regs,&regs.VR5,regs.VR125);
		/* 820610F8h case   49:*/		return 0x820610FC;
		  /* 820610FCh */ case   50:  		/* vmulfp128 VR4, VR60, VR59 */
		/* 820610FCh case   50:*/		cpu::op::vmulfp128<0>(regs,&regs.VR4,regs.VR60,regs.VR59);
		/* 820610FCh case   50:*/		return 0x82061100;
		  /* 82061100h */ case   51:  		/* vspltw VR3, VR122, 2 */
		/* 82061100h case   51:*/		cpu::op::vspltw<0,2>(regs,&regs.VR3,regs.VR122);
		/* 82061100h case   51:*/		return 0x82061104;
		  /* 82061104h */ case   52:  		/* vspltw VR2, VR124, 2 */
		/* 82061104h case   52:*/		cpu::op::vspltw<0,2>(regs,&regs.VR2,regs.VR124);
		/* 82061104h case   52:*/		return 0x82061108;
		  /* 82061108h */ case   53:  		/* lvx VR13, <#[R11 + R28]> */
		/* 82061108h case   53:*/		cpu::mem::lvx( regs, &regs.VR13, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 82061108h case   53:*/		return 0x8206110C;
		  /* 8206110Ch */ case   54:  		/* vspltw VR1, VR123, 2 */
		/* 8206110Ch case   54:*/		cpu::op::vspltw<0,2>(regs,&regs.VR1,regs.VR123);
		/* 8206110Ch case   54:*/		return 0x82061110;
		  /* 82061110h */ case   55:  		/* lvx VR12, <#[R11 + R29]> */
		/* 82061110h case   55:*/		cpu::mem::lvx( regs, &regs.VR12, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 82061110h case   55:*/		return 0x82061114;
		  /* 82061114h */ case   56:  		/* vspltw VR31, VR125, 2 */
		/* 82061114h case   56:*/		cpu::op::vspltw<0,2>(regs,&regs.VR31,regs.VR125);
		/* 82061114h case   56:*/		return 0x82061118;
		  /* 82061118h */ case   57:  		/* fmr FR1, FR31 */
		/* 82061118h case   57:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 82061118h case   57:*/		return 0x8206111C;
		  /* 8206111Ch */ case   58:  		/* vspltw VR30, VR122, 3 */
		/* 8206111Ch case   58:*/		cpu::op::vspltw<0,3>(regs,&regs.VR30,regs.VR122);
		/* 8206111Ch case   58:*/		return 0x82061120;
		  /* 82061120h */ case   59:  		/* vspltw VR29, VR124, 3 */
		/* 82061120h case   59:*/		cpu::op::vspltw<0,3>(regs,&regs.VR29,regs.VR124);
		/* 82061120h case   59:*/		return 0x82061124;
		  /* 82061124h */ case   60:  		/* vspltw VR28, VR123, 3 */
		/* 82061124h case   60:*/		cpu::op::vspltw<0,3>(regs,&regs.VR28,regs.VR123);
		/* 82061124h case   60:*/		return 0x82061128;
		  /* 82061128h */ case   61:  		/* vspltw VR27, VR125, 3 */
		/* 82061128h case   61:*/		cpu::op::vspltw<0,3>(regs,&regs.VR27,regs.VR125);
		/* 82061128h case   61:*/		return 0x8206112C;
		  /* 8206112Ch */ case   62:  		/* vmaddfp VR11, VR11, VR0, VR10 */
		/* 8206112Ch case   62:*/		cpu::op::vmaddfp<0>(regs,&regs.VR11,regs.VR11,regs.VR0,regs.VR10);
		/* 8206112Ch case   62:*/		return 0x82061130;
		  /* 82061130h */ case   63:  		/* vmaddfp VR10, VR9, VR0, VR8 */
		/* 82061130h case   63:*/		cpu::op::vmaddfp<0>(regs,&regs.VR10,regs.VR9,regs.VR0,regs.VR8);
		/* 82061130h case   63:*/		return 0x82061134;
		  /* 82061134h */ case   64:  		/* vmaddfp VR9, VR7, VR0, VR6 */
		/* 82061134h case   64:*/		cpu::op::vmaddfp<0>(regs,&regs.VR9,regs.VR7,regs.VR0,regs.VR6);
		/* 82061134h case   64:*/		return 0x82061138;
		  /* 82061138h */ case   65:  		/* vmaddfp VR0, VR5, VR0, VR4 */
		/* 82061138h case   65:*/		cpu::op::vmaddfp<0>(regs,&regs.VR0,regs.VR5,regs.VR0,regs.VR4);
		/* 82061138h case   65:*/		return 0x8206113C;
		  /* 8206113Ch */ case   66:  		/* vmaddfp VR11, VR3, VR13, VR11 */
		/* 8206113Ch case   66:*/		cpu::op::vmaddfp<0>(regs,&regs.VR11,regs.VR3,regs.VR13,regs.VR11);
		/* 8206113Ch case   66:*/		return 0x82061140;
		  /* 82061140h */ case   67:  		/* vmaddfp VR10, VR2, VR13, VR10 */
		/* 82061140h case   67:*/		cpu::op::vmaddfp<0>(regs,&regs.VR10,regs.VR2,regs.VR13,regs.VR10);
		/* 82061140h case   67:*/		return 0x82061144;
		  /* 82061144h */ case   68:  		/* vmaddfp VR9, VR1, VR13, VR9 */
		/* 82061144h case   68:*/		cpu::op::vmaddfp<0>(regs,&regs.VR9,regs.VR1,regs.VR13,regs.VR9);
		/* 82061144h case   68:*/		return 0x82061148;
		  /* 82061148h */ case   69:  		/* vmaddfp VR0, VR31, VR13, VR0 */
		/* 82061148h case   69:*/		cpu::op::vmaddfp<0>(regs,&regs.VR0,regs.VR31,regs.VR13,regs.VR0);
		/* 82061148h case   69:*/		return 0x8206114C;
		  /* 8206114Ch */ case   70:  		/* vmaddfp VR13, VR30, VR12, VR11 */
		/* 8206114Ch case   70:*/		cpu::op::vmaddfp<0>(regs,&regs.VR13,regs.VR30,regs.VR12,regs.VR11);
		/* 8206114Ch case   70:*/		return 0x82061150;
		  /* 82061150h */ case   71:  		/* vmaddfp VR11, VR29, VR12, VR10 */
		/* 82061150h case   71:*/		cpu::op::vmaddfp<0>(regs,&regs.VR11,regs.VR29,regs.VR12,regs.VR10);
		/* 82061150h case   71:*/		return 0x82061154;
		  /* 82061154h */ case   72:  		/* vmaddfp VR10, VR28, VR12, VR9 */
		/* 82061154h case   72:*/		cpu::op::vmaddfp<0>(regs,&regs.VR10,regs.VR28,regs.VR12,regs.VR9);
		/* 82061154h case   72:*/		return 0x82061158;
		  /* 82061158h */ case   73:  		/* vmaddfp VR0, VR27, VR12, VR0 */
		/* 82061158h case   73:*/		cpu::op::vmaddfp<0>(regs,&regs.VR0,regs.VR27,regs.VR12,regs.VR0);
		/* 82061158h case   73:*/		return 0x8206115C;
		  /* 8206115Ch */ case   74:  		/* mr VR125, VR13 */
		/* 8206115Ch case   74:*/		regs.VR125 = regs.VR13;
		/* 8206115Ch case   74:*/		return 0x82061160;
		  /* 82061160h */ case   75:  		/* mr VR124, VR11 */
		/* 82061160h case   75:*/		regs.VR124 = regs.VR11;
		/* 82061160h case   75:*/		return 0x82061164;
		  /* 82061164h */ case   76:  		/* mr VR123, VR10 */
		/* 82061164h case   76:*/		regs.VR123 = regs.VR10;
		/* 82061164h case   76:*/		return 0x82061168;
		  /* 82061168h */ case   77:  		/* mr VR122, VR0 */
		/* 82061168h case   77:*/		regs.VR122 = regs.VR0;
		/* 82061168h case   77:*/		return 0x8206116C;
		  /* 8206116Ch */ case   78:  		/* bl -2796 */
		/* 8206116Ch case   78:*/		regs.LR = 0x82061170; return 0x82060680;
		/* 8206116Ch case   78:*/		return 0x82061170;
		  /* 82061170h */ case   79:  		/* lvx VR62, <#[R3]> */
		/* 82061170h case   79:*/		cpu::mem::lvx( regs, &regs.VR62, (uint32)(regs.R3 + 0x00000000) );
		/* 82061170h case   79:*/		return 0x82061174;
		  /* 82061174h */ case   80:  		/* vspltw VR63, VR125, 0 */
		/* 82061174h case   80:*/		cpu::op::vspltw<0,0>(regs,&regs.VR63,regs.VR125);
		/* 82061174h case   80:*/		return 0x82061178;
		  /* 82061178h */ case   81:  		/* vspltw VR61, VR124, 0 */
		/* 82061178h case   81:*/		cpu::op::vspltw<0,0>(regs,&regs.VR61,regs.VR124);
		/* 82061178h case   81:*/		return 0x8206117C;
		  /* 8206117Ch */ case   82:  		/* vmulfp128 VR10, VR63, VR62 */
		/* 8206117Ch case   82:*/		cpu::op::vmulfp128<0>(regs,&regs.VR10,regs.VR63,regs.VR62);
		/* 8206117Ch case   82:*/		return 0x82061180;
		  /* 82061180h */ case   83:  		/* vspltw VR60, VR123, 0 */
		/* 82061180h case   83:*/		cpu::op::vspltw<0,0>(regs,&regs.VR60,regs.VR123);
		/* 82061180h case   83:*/		return 0x82061184;
		  /* 82061184h */ case   84:  		/* lvx VR0, <#[R3 + R27]> */
		/* 82061184h case   84:*/		cpu::mem::lvx( regs, &regs.VR0, (uint32)(regs.R3 + regs.R27 + 0x00000000) );
		/* 82061184h case   84:*/		return 0x82061188;
		  /* 82061188h */ case   85:  		/* vspltw VR59, VR122, 0 */
		/* 82061188h case   85:*/		cpu::op::vspltw<0,0>(regs,&regs.VR59,regs.VR122);
		/* 82061188h case   85:*/		return 0x8206118C;
		  /* 8206118Ch */ case   86:  		/* lvx VR13, <#[R3 + R28]> */
		/* 8206118Ch case   86:*/		cpu::mem::lvx( regs, &regs.VR13, (uint32)(regs.R3 + regs.R28 + 0x00000000) );
		/* 8206118Ch case   86:*/		return 0x82061190;
		  /* 82061190h */ case   87:  		/* vspltw VR11, VR125, 1 */
		/* 82061190h case   87:*/		cpu::op::vspltw<0,1>(regs,&regs.VR11,regs.VR125);
		/* 82061190h case   87:*/		return 0x82061194;
		  /* 82061194h */ case   88:  		/* lvx VR12, <#[R3 + R29]> */
		/* 82061194h case   88:*/		cpu::mem::lvx( regs, &regs.VR12, (uint32)(regs.R3 + regs.R29 + 0x00000000) );
		/* 82061194h case   88:*/		return 0x82061198;
		  /* 82061198h */ case   89:  		/* vmulfp128 VR8, VR61, VR62 */
		/* 82061198h case   89:*/		cpu::op::vmulfp128<0>(regs,&regs.VR8,regs.VR61,regs.VR62);
		/* 82061198h case   89:*/		return 0x8206119C;
		  /* 8206119Ch */ case   90:  		/* vspltw VR9, VR124, 1 */
		/* 8206119Ch case   90:*/		cpu::op::vspltw<0,1>(regs,&regs.VR9,regs.VR124);
		/* 8206119Ch case   90:*/		return 0x820611A0;
		  /* 820611A0h */ case   91:  		/* vmulfp128 VR6, VR60, VR62 */
		/* 820611A0h case   91:*/		cpu::op::vmulfp128<0>(regs,&regs.VR6,regs.VR60,regs.VR62);
		/* 820611A0h case   91:*/		return 0x820611A4;
		  /* 820611A4h */ case   92:  		/* vspltw VR7, VR123, 1 */
		/* 820611A4h case   92:*/		cpu::op::vspltw<0,1>(regs,&regs.VR7,regs.VR123);
		/* 820611A4h case   92:*/		return 0x820611A8;
		  /* 820611A8h */ case   93:  		/* vmulfp128 VR4, VR59, VR62 */
		/* 820611A8h case   93:*/		cpu::op::vmulfp128<0>(regs,&regs.VR4,regs.VR59,regs.VR62);
		/* 820611A8h case   93:*/		return 0x820611AC;
		  /* 820611ACh */ case   94:  		/* vspltw VR5, VR122, 1 */
		/* 820611ACh case   94:*/		cpu::op::vspltw<0,1>(regs,&regs.VR5,regs.VR122);
		/* 820611ACh case   94:*/		return 0x820611B0;
		  /* 820611B0h */ case   95:  		/* vspltw VR3, VR125, 2 */
		/* 820611B0h case   95:*/		cpu::op::vspltw<0,2>(regs,&regs.VR3,regs.VR125);
		/* 820611B0h case   95:*/		return 0x820611B4;
		  /* 820611B4h */ case   96:  		/* fmr FR1, FR31 */
		/* 820611B4h case   96:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 820611B4h case   96:*/		return 0x820611B8;
		  /* 820611B8h */ case   97:  		/* vspltw VR2, VR124, 2 */
		/* 820611B8h case   97:*/		cpu::op::vspltw<0,2>(regs,&regs.VR2,regs.VR124);
		/* 820611B8h case   97:*/		return 0x820611BC;
		  /* 820611BCh */ case   98:  		/* vspltw VR1, VR123, 2 */
		/* 820611BCh case   98:*/		cpu::op::vspltw<0,2>(regs,&regs.VR1,regs.VR123);
		/* 820611BCh case   98:*/		return 0x820611C0;
		  /* 820611C0h */ case   99:  		/* vspltw VR31, VR122, 2 */
		/* 820611C0h case   99:*/		cpu::op::vspltw<0,2>(regs,&regs.VR31,regs.VR122);
		/* 820611C0h case   99:*/		return 0x820611C4;
		  /* 820611C4h */ case  100:  		/* vspltw VR30, VR125, 3 */
		/* 820611C4h case  100:*/		cpu::op::vspltw<0,3>(regs,&regs.VR30,regs.VR125);
		/* 820611C4h case  100:*/		return 0x820611C8;
		  /* 820611C8h */ case  101:  		/* vmaddfp VR11, VR11, VR0, VR10 */
		/* 820611C8h case  101:*/		cpu::op::vmaddfp<0>(regs,&regs.VR11,regs.VR11,regs.VR0,regs.VR10);
		/* 820611C8h case  101:*/		return 0x820611CC;
		  /* 820611CCh */ case  102:  		/* vspltw VR29, VR124, 3 */
		/* 820611CCh case  102:*/		cpu::op::vspltw<0,3>(regs,&regs.VR29,regs.VR124);
		/* 820611CCh case  102:*/		return 0x820611D0;
		  /* 820611D0h */ case  103:  		/* vspltw VR28, VR123, 3 */
		/* 820611D0h case  103:*/		cpu::op::vspltw<0,3>(regs,&regs.VR28,regs.VR123);
		/* 820611D0h case  103:*/		return 0x820611D4;
		  /* 820611D4h */ case  104:  		/* vspltw VR27, VR122, 3 */
		/* 820611D4h case  104:*/		cpu::op::vspltw<0,3>(regs,&regs.VR27,regs.VR122);
		/* 820611D4h case  104:*/		return 0x820611D8;
		  /* 820611D8h */ case  105:  		/* vmaddfp VR10, VR9, VR0, VR8 */
		/* 820611D8h case  105:*/		cpu::op::vmaddfp<0>(regs,&regs.VR10,regs.VR9,regs.VR0,regs.VR8);
		/* 820611D8h case  105:*/		return 0x820611DC;
		  /* 820611DCh */ case  106:  		/* vmaddfp VR9, VR7, VR0, VR6 */
		/* 820611DCh case  106:*/		cpu::op::vmaddfp<0>(regs,&regs.VR9,regs.VR7,regs.VR0,regs.VR6);
		/* 820611DCh case  106:*/		return 0x820611E0;
		  /* 820611E0h */ case  107:  		/* vmaddfp VR0, VR5, VR0, VR4 */
		/* 820611E0h case  107:*/		cpu::op::vmaddfp<0>(regs,&regs.VR0,regs.VR5,regs.VR0,regs.VR4);
		/* 820611E0h case  107:*/		return 0x820611E4;
		  /* 820611E4h */ case  108:  		/* vmaddfp VR11, VR3, VR13, VR11 */
		/* 820611E4h case  108:*/		cpu::op::vmaddfp<0>(regs,&regs.VR11,regs.VR3,regs.VR13,regs.VR11);
		/* 820611E4h case  108:*/		return 0x820611E8;
		  /* 820611E8h */ case  109:  		/* vmaddfp VR10, VR2, VR13, VR10 */
		/* 820611E8h case  109:*/		cpu::op::vmaddfp<0>(regs,&regs.VR10,regs.VR2,regs.VR13,regs.VR10);
		/* 820611E8h case  109:*/		return 0x820611EC;
		  /* 820611ECh */ case  110:  		/* vmaddfp VR9, VR1, VR13, VR9 */
		/* 820611ECh case  110:*/		cpu::op::vmaddfp<0>(regs,&regs.VR9,regs.VR1,regs.VR13,regs.VR9);
		/* 820611ECh case  110:*/		return 0x820611F0;
		  /* 820611F0h */ case  111:  		/* vmaddfp VR0, VR31, VR13, VR0 */
		/* 820611F0h case  111:*/		cpu::op::vmaddfp<0>(regs,&regs.VR0,regs.VR31,regs.VR13,regs.VR0);
		/* 820611F0h case  111:*/		return 0x820611F4;
		  /* 820611F4h */ case  112:  		/* vmaddfp VR13, VR30, VR12, VR11 */
		/* 820611F4h case  112:*/		cpu::op::vmaddfp<0>(regs,&regs.VR13,regs.VR30,regs.VR12,regs.VR11);
		/* 820611F4h case  112:*/		return 0x820611F8;
		  /* 820611F8h */ case  113:  		/* vmaddfp VR11, VR29, VR12, VR10 */
		/* 820611F8h case  113:*/		cpu::op::vmaddfp<0>(regs,&regs.VR11,regs.VR29,regs.VR12,regs.VR10);
		/* 820611F8h case  113:*/		return 0x820611FC;
		  /* 820611FCh */ case  114:  		/* vmaddfp VR10, VR28, VR12, VR9 */
		/* 820611FCh case  114:*/		cpu::op::vmaddfp<0>(regs,&regs.VR10,regs.VR28,regs.VR12,regs.VR9);
		/* 820611FCh case  114:*/		return 0x82061200;
		  /* 82061200h */ case  115:  		/* vmaddfp VR0, VR27, VR12, VR0 */
		/* 82061200h case  115:*/		cpu::op::vmaddfp<0>(regs,&regs.VR0,regs.VR27,regs.VR12,regs.VR0);
		/* 82061200h case  115:*/		return 0x82061204;
		  /* 82061204h */ case  116:  		/* mr VR125, VR13 */
		/* 82061204h case  116:*/		regs.VR125 = regs.VR13;
		/* 82061204h case  116:*/		return 0x82061208;
		  /* 82061208h */ case  117:  		/* mr VR124, VR11 */
		/* 82061208h case  117:*/		regs.VR124 = regs.VR11;
		/* 82061208h case  117:*/		return 0x8206120C;
		  /* 8206120Ch */ case  118:  		/* mr VR123, VR10 */
		/* 8206120Ch case  118:*/		regs.VR123 = regs.VR10;
		/* 8206120Ch case  118:*/		return 0x82061210;
		  /* 82061210h */ case  119:  		/* mr VR122, VR0 */
		/* 82061210h case  119:*/		regs.VR122 = regs.VR0;
		/* 82061210h case  119:*/		return 0x82061214;
		  /* 82061214h */ case  120:  		/* bl 194964 */
		/* 82061214h case  120:*/		regs.LR = 0x82061218; return 0x82090BA8;
		/* 82061214h case  120:*/		return 0x82061218;
		  /* 82061218h */ case  121:  		/* frsp FR27, FR1 */
		/* 82061218h case  121:*/		cpu::op::frsp<0>(regs,&regs.FR27,regs.FR1);
		/* 82061218h case  121:*/		return 0x8206121C;
		  /* 8206121Ch */ case  122:  		/* fmr FR1, FR28 */
		/* 8206121Ch case  122:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR28);
		/* 8206121Ch case  122:*/		return 0x82061220;
		  /* 82061220h */ case  123:  		/* bl 194728 */
		/* 82061220h case  123:*/		regs.LR = 0x82061224; return 0x82090AC8;
		/* 82061220h case  123:*/		return 0x82061224;
		  /* 82061224h */ case  124:  		/* frsp FR28, FR1 */
		/* 82061224h case  124:*/		cpu::op::frsp<0>(regs,&regs.FR28,regs.FR1);
		/* 82061224h case  124:*/		return 0x82061228;
		  /* 82061228h */ case  125:  		/* fmr FR1, FR31 */
		/* 82061228h case  125:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 82061228h case  125:*/		return 0x8206122C;
		  /* 8206122Ch */ case  126:  		/* bl 194716 */
		/* 8206122Ch case  126:*/		regs.LR = 0x82061230; return 0x82090AC8;
		/* 8206122Ch case  126:*/		return 0x82061230;
		  /* 82061230h */ case  127:  		/* frsp FR10, FR1 */
		/* 82061230h case  127:*/		cpu::op::frsp<0>(regs,&regs.FR10,regs.FR1);
		/* 82061230h case  127:*/		return 0x82061234;
		  /* 82061234h */ case  128:  		/* lis R11, -32256 */
		/* 82061234h case  128:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82061234h case  128:*/		return 0x82061238;
		  /* 82061238h */ case  129:  		/* lis R10, -32256 */
		/* 82061238h case  129:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82061238h case  129:*/		return 0x8206123C;
		  /* 8206123Ch */ case  130:  		/* vpermwi128 VR63, VR126, 234 */
		/* 8206123Ch case  130:*/		cpu::op::vpermwi128<0,234>(regs,&regs.VR63,regs.VR126);
		/* 8206123Ch case  130:*/		return 0x82061240;
		  /* 82061240h */ case  131:  		/* lis R9, -32256 */
		/* 82061240h case  131:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 82061240h case  131:*/		return 0x82061244;
		  /* 82061244h */ case  132:  		/* vspltw VR62, VR125, 0 */
		/* 82061244h case  132:*/		cpu::op::vspltw<0,0>(regs,&regs.VR62,regs.VR125);
		/* 82061244h case  132:*/		return 0x82061248;
		  /* 82061248h */ case  133:  		/* lis R8, -32256 */
		/* 82061248h case  133:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8200);
		/* 82061248h case  133:*/		return 0x8206124C;
		  /* 8206124Ch */ case  134:  		/* vspltw VR61, VR124, 0 */
		/* 8206124Ch case  134:*/		cpu::op::vspltw<0,0>(regs,&regs.VR61,regs.VR124);
		/* 8206124Ch case  134:*/		return 0x82061250;
		  /* 82061250h */ case  135:  		/* addi R7, R1, 96 */
		/* 82061250h case  135:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 82061250h case  135:*/		return 0x82061254;
		  /* 82061254h */ case  136:  		/* vspltw VR60, VR123, 0 */
		/* 82061254h case  136:*/		cpu::op::vspltw<0,0>(regs,&regs.VR60,regs.VR123);
		/* 82061254h case  136:*/		return 0x82061258;
		  /* 82061258h */ case  137:  		/* vspltw VR59, VR122, 0 */
		/* 82061258h case  137:*/		cpu::op::vspltw<0,0>(regs,&regs.VR59,regs.VR122);
		/* 82061258h case  137:*/		return 0x8206125C;
		  /* 8206125Ch */ case  138:  		/* lfs FR12, <#[R11 + 1820]> */
		/* 8206125Ch case  138:*/		cpu::mem::load32f( regs, &regs.FR12, (uint32)(regs.R11 + 0x0000071C) );
		/* 8206125Ch case  138:*/		return 0x82061260;
		  /* 82061260h */ case  139:  		/* lfs FR0, <#[R10 + 2736]> */
		/* 82061260h case  139:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000AB0) );
		/* 82061260h case  139:*/		return 0x82061264;
		  /* 82061264h */ case  140:  		/* fmuls FR9, FR28, FR12 */
		/* 82061264h case  140:*/		cpu::op::fmuls<0>(regs,&regs.FR9,regs.FR28,regs.FR12);
		/* 82061264h case  140:*/		return 0x82061268;
		  /* 82061268h */ case  141:  		/* lfs FR11, <#[R9 + 2732]> */
		/* 82061268h case  141:*/		cpu::mem::load32f( regs, &regs.FR11, (uint32)(regs.R9 + 0x00000AAC) );
		/* 82061268h case  141:*/		return 0x8206126C;
		  /* 8206126Ch */ case  142:  		/* fnmsubs FR0, FR27, FR0, FR0 */
		/* 8206126Ch case  142:*/		cpu::op::fnmsubs<0>(regs,&regs.FR0,regs.FR27,regs.FR0,regs.FR0);
		/* 8206126Ch case  142:*/		return 0x82061270;
		  /* 82061270h */ case  143:  		/* lfs FR13, <#[R8 + 1792]> */
		/* 82061270h case  143:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R8 + 0x00000700) );
		/* 82061270h case  143:*/		return 0x82061274;
		  /* 82061274h */ case  144:  		/* vpermwi128 VR0, VR126, 186 */
		/* 82061274h case  144:*/		cpu::op::vpermwi128<0,186>(regs,&regs.VR0,regs.VR126);
		/* 82061274h case  144:*/		return 0x82061278;
		  /* 82061278h */ case  145:  		/* stfs FR9, <#[R1 + 100]> */
		/* 82061278h case  145:*/		cpu::mem::store32f( regs, regs.FR9, (uint32)(regs.R1 + 0x00000064) );
		/* 82061278h case  145:*/		return 0x8206127C;
		  /* 8206127Ch */ case  146:  		/* vpermwi128 VR13, VR126, 174 */
		/* 8206127Ch case  146:*/		cpu::op::vpermwi128<0,174>(regs,&regs.VR13,regs.VR126);
		/* 8206127Ch case  146:*/		return 0x82061280;
		  /* 82061280h */ case  147:  		/* fmuls FR11, FR10, FR11 */
		/* 82061280h case  147:*/		cpu::op::fmuls<0>(regs,&regs.FR11,regs.FR10,regs.FR11);
		/* 82061280h case  147:*/		return 0x82061284;
		  /* 82061284h */ case  148:  		/* stfs FR0, <#[R1 + 104]> */
		/* 82061284h case  148:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000068) );
		/* 82061284h case  148:*/		return 0x82061288;
		  /* 82061288h */ case  149:  		/* stfs FR13, <#[R1 + 108]> */
		/* 82061288h case  149:*/		cpu::mem::store32f( regs, regs.FR13, (uint32)(regs.R1 + 0x0000006C) );
		/* 82061288h case  149:*/		return 0x8206128C;
		  /* 8206128Ch */ case  150:  		/* vspltw VR11, VR125, 1 */
		/* 8206128Ch case  150:*/		cpu::op::vspltw<0,1>(regs,&regs.VR11,regs.VR125);
		/* 8206128Ch case  150:*/		return 0x82061290;
		  /* 82061290h */ case  151:  		/* stfs FR11, <#[R1 + 96]> */
		/* 82061290h case  151:*/		cpu::mem::store32f( regs, regs.FR11, (uint32)(regs.R1 + 0x00000060) );
		/* 82061290h case  151:*/		return 0x82061294;
		  /* 82061294h */ case  152:  		/* vspltw VR9, VR124, 1 */
		/* 82061294h case  152:*/		cpu::op::vspltw<0,1>(regs,&regs.VR9,regs.VR124);
		/* 82061294h case  152:*/		return 0x82061298;
		  /* 82061298h */ case  153:  		/* lvx VR12, <#[R7]> */
		/* 82061298h case  153:*/		cpu::mem::lvx( regs, &regs.VR12, (uint32)(regs.R7 + 0x00000000) );
		/* 82061298h case  153:*/		return 0x8206129C;
		  /* 8206129Ch */ case  154:  		/* vspltw VR3, VR125, 2 */
		/* 8206129Ch case  154:*/		cpu::op::vspltw<0,2>(regs,&regs.VR3,regs.VR125);
		/* 8206129Ch case  154:*/		return 0x820612A0;
		  /* 820612A0h */ case  155:  		/* vspltw VR2, VR124, 2 */
		/* 820612A0h case  155:*/		cpu::op::vspltw<0,2>(regs,&regs.VR2,regs.VR124);
		/* 820612A0h case  155:*/		return 0x820612A4;
		  /* 820612A4h */ case  156:  		/* vmulfp128 VR10, VR62, VR63 */
		/* 820612A4h case  156:*/		cpu::op::vmulfp128<0>(regs,&regs.VR10,regs.VR62,regs.VR63);
		/* 820612A4h case  156:*/		return 0x820612A8;
		  /* 820612A8h */ case  157:  		/* vmulfp128 VR8, VR61, VR63 */
		/* 820612A8h case  157:*/		cpu::op::vmulfp128<0>(regs,&regs.VR8,regs.VR61,regs.VR63);
		/* 820612A8h case  157:*/		return 0x820612AC;
		  /* 820612ACh */ case  158:  		/* vspltw VR7, VR123, 1 */
		/* 820612ACh case  158:*/		cpu::op::vspltw<0,1>(regs,&regs.VR7,regs.VR123);
		/* 820612ACh case  158:*/		return 0x820612B0;
		  /* 820612B0h */ case  159:  		/* vmulfp128 VR6, VR60, VR63 */
		/* 820612B0h case  159:*/		cpu::op::vmulfp128<0>(regs,&regs.VR6,regs.VR60,regs.VR63);
		/* 820612B0h case  159:*/		return 0x820612B4;
		  /* 820612B4h */ case  160:  		/* vspltw VR5, VR122, 1 */
		/* 820612B4h case  160:*/		cpu::op::vspltw<0,1>(regs,&regs.VR5,regs.VR122);
		/* 820612B4h case  160:*/		return 0x820612B8;
		  /* 820612B8h */ case  161:  		/* vmulfp128 VR4, VR59, VR63 */
		/* 820612B8h case  161:*/		cpu::op::vmulfp128<0>(regs,&regs.VR4,regs.VR59,regs.VR63);
		/* 820612B8h case  161:*/		return 0x820612BC;
		  /* 820612BCh */ case  162:  		/* lis R11, -32256 */
		/* 820612BCh case  162:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820612BCh case  162:*/		return 0x820612C0;
		  /* 820612C0h */ case  163:  		/* vmaddfp VR11, VR11, VR0, VR10 */
		/* 820612C0h case  163:*/		cpu::op::vmaddfp<0>(regs,&regs.VR11,regs.VR11,regs.VR0,regs.VR10);
		/* 820612C0h case  163:*/		return 0x820612C4;
		  /* 820612C4h */ case  164:  		/* vmaddfp VR10, VR9, VR0, VR8 */
		/* 820612C4h case  164:*/		cpu::op::vmaddfp<0>(regs,&regs.VR10,regs.VR9,regs.VR0,regs.VR8);
		/* 820612C4h case  164:*/		return 0x820612C8;
		  /* 820612C8h */ case  165:  		/* vspltw VR1, VR123, 2 */
		/* 820612C8h case  165:*/		cpu::op::vspltw<0,2>(regs,&regs.VR1,regs.VR123);
		/* 820612C8h case  165:*/		return 0x820612CC;
		  /* 820612CCh */ case  166:  		/* vmaddfp VR9, VR7, VR0, VR6 */
		/* 820612CCh case  166:*/		cpu::op::vmaddfp<0>(regs,&regs.VR9,regs.VR7,regs.VR0,regs.VR6);
		/* 820612CCh case  166:*/		return 0x820612D0;
		  /* 820612D0h */ case  167:  		/* vspltw VR31, VR122, 2 */
		/* 820612D0h case  167:*/		cpu::op::vspltw<0,2>(regs,&regs.VR31,regs.VR122);
		/* 820612D0h case  167:*/		return 0x820612D4;
		  /* 820612D4h */ case  168:  		/* vmaddfp VR0, VR5, VR0, VR4 */
		/* 820612D4h case  168:*/		cpu::op::vmaddfp<0>(regs,&regs.VR0,regs.VR5,regs.VR0,regs.VR4);
		/* 820612D4h case  168:*/		return 0x820612D8;
		  /* 820612D8h */ case  169:  		/* lis R9, -32216 */
		/* 820612D8h case  169:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8228);
		/* 820612D8h case  169:*/		return 0x820612DC;
		  /* 820612DCh */ case  170:  		/* vspltw VR30, VR125, 3 */
		/* 820612DCh case  170:*/		cpu::op::vspltw<0,3>(regs,&regs.VR30,regs.VR125);
		/* 820612DCh case  170:*/		return 0x820612E0;
		  /* 820612E0h */ case  171:  		/* mr VR126, VR12 */
		/* 820612E0h case  171:*/		regs.VR126 = regs.VR12;
		/* 820612E0h case  171:*/		return 0x820612E4;
		  /* 820612E4h */ case  172:  		/* lfs FR0, <#[R11 + 2728]> */
		/* 820612E4h case  172:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000AA8) );
		/* 820612E4h case  172:*/		return 0x820612E8;
		  /* 820612E8h */ case  173:  		/* addi R30, R9, 28660 */
		/* 820612E8h case  173:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R9,0x6FF4);
		/* 820612E8h case  173:*/		return 0x820612EC;
		  /* 820612ECh */ case  174:  		/* fmuls FR0, FR30, FR0 */
		/* 820612ECh case  174:*/		cpu::op::fmuls<0>(regs,&regs.FR0,regs.FR30,regs.FR0);
		/* 820612ECh case  174:*/		return 0x820612F0;
		  /* 820612F0h */ case  175:  		/* vspltw VR29, VR124, 3 */
		/* 820612F0h case  175:*/		cpu::op::vspltw<0,3>(regs,&regs.VR29,regs.VR124);
		/* 820612F0h case  175:*/		return 0x820612F4;
		  /* 820612F4h */ case  176:  		/* vspltw VR28, VR123, 3 */
		/* 820612F4h case  176:*/		cpu::op::vspltw<0,3>(regs,&regs.VR28,regs.VR123);
		/* 820612F4h case  176:*/		return 0x820612F8;
		  /* 820612F8h */ case  177:  		/* mr VR125, VR12 */
		/* 820612F8h case  177:*/		regs.VR125 = regs.VR12;
		/* 820612F8h case  177:*/		return 0x820612FC;
		  /* 820612FCh */ case  178:  		/* vspltw VR27, VR122, 3 */
		/* 820612FCh case  178:*/		cpu::op::vspltw<0,3>(regs,&regs.VR27,regs.VR122);
		/* 820612FCh case  178:*/		return 0x82061300;
		  /* 82061300h */ case  179:  		/* mr VR124, VR12 */
		/* 82061300h case  179:*/		regs.VR124 = regs.VR12;
		/* 82061300h case  179:*/		return 0x82061304;
		  /* 82061304h */ case  180:  		/* mr VR123, VR12 */
		/* 82061304h case  180:*/		regs.VR123 = regs.VR12;
		/* 82061304h case  180:*/		return 0x82061308;
		  /* 82061308h */ case  181:  		/* lis R10, -32216 */
		/* 82061308h case  181:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8228);
		/* 82061308h case  181:*/		return 0x8206130C;
		  /* 8206130Ch */ case  182:  		/* addi R8, R1, 224 */
		/* 8206130Ch case  182:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xE0);
		/* 8206130Ch case  182:*/		return 0x82061310;
		  /* 82061310h */ case  183:  		/* addi R7, R1, 240 */
		/* 82061310h case  183:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0xF0);
		/* 82061310h case  183:*/		return 0x82061314;
		  /* 82061314h */ case  184:  		/* vmaddfp VR11, VR3, VR13, VR11 */
		/* 82061314h case  184:*/		cpu::op::vmaddfp<0>(regs,&regs.VR11,regs.VR3,regs.VR13,regs.VR11);
		/* 82061314h case  184:*/		return 0x82061318;
		  /* 82061318h */ case  185:  		/* addi R6, R1, 256 */
		/* 82061318h case  185:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x100);
		/* 82061318h case  185:*/		return 0x8206131C;
		  /* 8206131Ch */ case  186:  		/* vmaddfp VR10, VR2, VR13, VR10 */
		/* 8206131Ch case  186:*/		cpu::op::vmaddfp<0>(regs,&regs.VR10,regs.VR2,regs.VR13,regs.VR10);
		/* 8206131Ch case  186:*/		return 0x82061320;
		  /* 82061320h */ case  187:  		/* addi R5, R1, 272 */
		/* 82061320h case  187:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x110);
		/* 82061320h case  187:*/		return 0x82061324;
		  /* 82061324h */ case  188:  		/* vmaddfp VR9, VR1, VR13, VR9 */
		/* 82061324h case  188:*/		cpu::op::vmaddfp<0>(regs,&regs.VR9,regs.VR1,regs.VR13,regs.VR9);
		/* 82061324h case  188:*/		return 0x82061328;
		  /* 82061328h */ case  189:  		/* lis R4, -32256 */
		/* 82061328h case  189:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFF8200);
		/* 82061328h case  189:*/		return 0x8206132C;
		  /* 8206132Ch */ case  190:  		/* vmaddfp VR0, VR31, VR13, VR0 */
		/* 8206132Ch case  190:*/		cpu::op::vmaddfp<0>(regs,&regs.VR0,regs.VR31,regs.VR13,regs.VR0);
		/* 8206132Ch case  190:*/		return 0x82061330;
		  /* 82061330h */ case  191:  		/* lwz R11, <#[R10 + 28656]> */
		/* 82061330h case  191:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00006FF0) );
		/* 82061330h case  191:*/		return 0x82061334;
		  /* 82061334h */ case  192:  		/* fctidz FR0, FR0 */
		/* 82061334h case  192:*/		cpu::op::fctidz<0>(regs,&regs.FR0,regs.FR0);
		/* 82061334h case  192:*/		return 0x82061338;
		  /* 82061338h */ case  193:  		/* stfd FR0, <#[R1 + 96]> */
		/* 82061338h case  193:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000060) );
		/* 82061338h case  193:*/		return 0x8206133C;
		  /* 8206133Ch */ case  194:  		/* rlwinm. R3, R11, 0, 31, 31 */
		/* 8206133Ch case  194:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R3,regs.R11);
		/* 8206133Ch case  194:*/		return 0x82061340;
		  /* 82061340h */ case  195:  		/* vmaddfp VR126, VR30, VR126, VR11 */
		/* 82061340h case  195:*/		cpu::op::vmaddfp<0>(regs,&regs.VR126,regs.VR30,regs.VR126,regs.VR11);
		/* 82061340h case  195:*/		return 0x82061344;
		  /* 82061344h */ case  196:  		/* lfs FR0, <#[R4 + 1816]> */
		/* 82061344h case  196:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R4 + 0x00000718) );
		/* 82061344h case  196:*/		return 0x82061348;
		  /* 82061348h */ case  197:  		/* vmaddfp VR125, VR29, VR125, VR10 */
		/* 82061348h case  197:*/		cpu::op::vmaddfp<0>(regs,&regs.VR125,regs.VR29,regs.VR125,regs.VR10);
		/* 82061348h case  197:*/		return 0x8206134C;
		  /* 8206134Ch */ case  198:  		/* vmaddfp VR124, VR28, VR124, VR9 */
		/* 8206134Ch case  198:*/		cpu::op::vmaddfp<0>(regs,&regs.VR124,regs.VR28,regs.VR124,regs.VR9);
		/* 8206134Ch case  198:*/		return 0x82061350;
		  /* 82061350h */ case  199:  		/* lwz R9, <#[R1 + 100]> */
		/* 82061350h case  199:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000064) );
		/* 82061350h case  199:*/		return 0x82061354;
		  /* 82061354h */ case  200:  		/* vmaddfp VR123, VR27, VR123, VR0 */
		/* 82061354h case  200:*/		cpu::op::vmaddfp<0>(regs,&regs.VR123,regs.VR27,regs.VR123,regs.VR0);
		/* 82061354h case  200:*/		return 0x82061358;
		  /* 82061358h */ case  201:  		/* rlwinm R9, R9, 0, 27, 31 */
		/* 82061358h case  201:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R9);
		/* 82061358h case  201:*/		return 0x8206135C;
		  /* 8206135Ch */ case  202:  		/* addi R9, R9, 168 */
		/* 8206135Ch case  202:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xA8);
		/* 8206135Ch case  202:*/		return 0x82061360;
		  /* 82061360h */ case  203:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82061360h case  203:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82061360h case  203:*/		return 0x82061364;
		  /* 82061364h */ case  204:  		/* stvx VR126, <#[R8]> */
		/* 82061364h case  204:*/		cpu::mem::stvx( regs, regs.VR126, (uint32)(regs.R8 + 0x00000000) );
		/* 82061364h case  204:*/		return 0x82061368;
		  /* 82061368h */ case  205:  		/* stvx VR125, <#[R7]> */
		/* 82061368h case  205:*/		cpu::mem::stvx( regs, regs.VR125, (uint32)(regs.R7 + 0x00000000) );
		/* 82061368h case  205:*/		return 0x8206136C;
		  /* 8206136Ch */ case  206:  		/* lwzx R9, <#[R9 + R26]> */
		/* 8206136Ch case  206:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R26 + 0x00000000) );
		/* 8206136Ch case  206:*/		return 0x82061370;
		  /* 82061370h */ case  207:  		/* stvx VR124, <#[R6]> */
		/* 82061370h case  207:*/		cpu::mem::stvx( regs, regs.VR124, (uint32)(regs.R6 + 0x00000000) );
		/* 82061370h case  207:*/		return 0x82061374;
		  /* 82061374h */ case  208:  		/* stvx VR123, <#[R5]> */
		/* 82061374h case  208:*/		cpu::mem::stvx( regs, regs.VR123, (uint32)(regs.R5 + 0x00000000) );
		/* 82061374h case  208:*/		return 0x82061378;
		  /* 82061378h */ case  209:  		/* stw R9, <#[R26 + 800]> */
		/* 82061378h case  209:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R26 + 0x00000320) );
		/* 82061378h case  209:*/		return 0x8206137C;
		  /* 8206137Ch */ case  210:  		/* bc 4, CR0_EQ, 28 */
		/* 8206137Ch case  210:*/		if ( !regs.CR[0].eq ) { return 0x82061398;  }
		/* 8206137Ch case  210:*/		return 0x82061380;
		  /* 82061380h */ case  211:  		/* ori R11, R11, 1 */
		/* 82061380h case  211:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82061380h case  211:*/		return 0x82061384;
		  /* 82061384h */ case  212:  		/* stfs FR0, <#[R30]> */
		/* 82061384h case  212:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R30 + 0x00000000) );
		/* 82061384h case  212:*/		return 0x82061388;
		  /* 82061388h */ case  213:  		/* stfs FR0, <#[R30 + 4]> */
		/* 82061388h case  213:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R30 + 0x00000004) );
		/* 82061388h case  213:*/		return 0x8206138C;
		  /* 8206138Ch */ case  214:  		/* stfs FR0, <#[R30 + 8]> */
		/* 8206138Ch case  214:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R30 + 0x00000008) );
		/* 8206138Ch case  214:*/		return 0x82061390;
		  /* 82061390h */ case  215:  		/* stw R11, <#[R10 + 28656]> */
		/* 82061390h case  215:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00006FF0) );
		/* 82061390h case  215:*/		return 0x82061394;
		  /* 82061394h */ case  216:  		/* stfs FR0, <#[R30 + 12]> */
		/* 82061394h case  216:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R30 + 0x0000000C) );
		/* 82061394h case  216:*/		return 0x82061398;
	}
	return 0x82061398;
} // Block from 82061034h-82061398h (217 instructions)

//////////////////////////////////////////////////////
// Block at 82061398h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82061398( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82061398) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82061398);
		  /* 82061398h */ case    0:  		/* lis R8, -32256 */
		/* 82061398h case    0:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8200);
		/* 82061398h case    0:*/		return 0x8206139C;
		  /* 8206139Ch */ case    1:  		/* lis R9, -32216 */
		/* 8206139Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8228);
		/* 8206139Ch case    1:*/		return 0x820613A0;
		  /* 820613A0h */ case    2:  		/* rlwinm. R7, R11, 0, 30, 30 */
		/* 820613A0h case    2:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R7,regs.R11);
		/* 820613A0h case    2:*/		return 0x820613A4;
		  /* 820613A4h */ case    3:  		/* lfs FR31, <#[R8 + 2724]> */
		/* 820613A4h case    3:*/		cpu::mem::load32f( regs, &regs.FR31, (uint32)(regs.R8 + 0x00000AA4) );
		/* 820613A4h case    3:*/		return 0x820613A8;
		  /* 820613A8h */ case    4:  		/* addi R31, R9, 28640 */
		/* 820613A8h case    4:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R9,0x6FE0);
		/* 820613A8h case    4:*/		return 0x820613AC;
		  /* 820613ACh */ case    5:  		/* bc 4, CR0_EQ, 36 */
		/* 820613ACh case    5:*/		if ( !regs.CR[0].eq ) { return 0x820613D0;  }
		/* 820613ACh case    5:*/		return 0x820613B0;
		  /* 820613B0h */ case    6:  		/* lis R9, -32256 */
		/* 820613B0h case    6:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 820613B0h case    6:*/		return 0x820613B4;
		  /* 820613B4h */ case    7:  		/* stfs FR12, <#[R31 + 4]> */
		/* 820613B4h case    7:*/		cpu::mem::store32f( regs, regs.FR12, (uint32)(regs.R31 + 0x00000004) );
		/* 820613B4h case    7:*/		return 0x820613B8;
		  /* 820613B8h */ case    8:  		/* ori R11, R11, 2 */
		/* 820613B8h case    8:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2);
		/* 820613B8h case    8:*/		return 0x820613BC;
		  /* 820613BCh */ case    9:  		/* stfs FR13, <#[R31]> */
		/* 820613BCh case    9:*/		cpu::mem::store32f( regs, regs.FR13, (uint32)(regs.R31 + 0x00000000) );
		/* 820613BCh case    9:*/		return 0x820613C0;
		  /* 820613C0h */ case   10:  		/* stfs FR31, <#[R31 + 12]> */
		/* 820613C0h case   10:*/		cpu::mem::store32f( regs, regs.FR31, (uint32)(regs.R31 + 0x0000000C) );
		/* 820613C0h case   10:*/		return 0x820613C4;
		  /* 820613C4h */ case   11:  		/* stw R11, <#[R10 + 28656]> */
		/* 820613C4h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00006FF0) );
		/* 820613C4h case   11:*/		return 0x820613C8;
		  /* 820613C8h */ case   12:  		/* lfs FR12, <#[R9 + 2720]> */
		/* 820613C8h case   12:*/		cpu::mem::load32f( regs, &regs.FR12, (uint32)(regs.R9 + 0x00000AA0) );
		/* 820613C8h case   12:*/		return 0x820613CC;
		  /* 820613CCh */ case   13:  		/* stfs FR12, <#[R31 + 8]> */
		/* 820613CCh case   13:*/		cpu::mem::store32f( regs, regs.FR12, (uint32)(regs.R31 + 0x00000008) );
		/* 820613CCh case   13:*/		return 0x820613D0;
	}
	return 0x820613D0;
} // Block from 82061398h-820613D0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820613D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820613D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820613D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820613D0);
		  /* 820613D0h */ case    0:  		/* fabs FR10, FR29 */
		/* 820613D0h case    0:*/		cpu::op::fabs<0>(regs,&regs.FR10,regs.FR29);
		/* 820613D0h case    0:*/		return 0x820613D4;
		  /* 820613D4h */ case    1:  		/* fcmpu CR6, FR29, FR0 */
		/* 820613D4h case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR29,regs.FR0);
		/* 820613D4h case    1:*/		return 0x820613D8;
		  /* 820613D8h */ case    2:  		/* fsubs FR13, FR13, FR10 */
		/* 820613D8h case    2:*/		cpu::op::fsubs<0>(regs,&regs.FR13,regs.FR13,regs.FR10);
		/* 820613D8h case    2:*/		return 0x820613DC;
		  /* 820613DCh */ case    3:  		/* bc 4, CR6_GT, 16 */
		/* 820613DCh case    3:*/		if ( !regs.CR[6].gt ) { return 0x820613EC;  }
		/* 820613DCh case    3:*/		return 0x820613E0;
		  /* 820613E0h */ case    4:  		/* fmr FR11, FR0 */
		/* 820613E0h case    4:*/		cpu::op::fmr<0>(regs,&regs.FR11,regs.FR0);
		/* 820613E0h case    4:*/		return 0x820613E4;
		  /* 820613E4h */ case    5:  		/* fabs FR12, FR29 */
		/* 820613E4h case    5:*/		cpu::op::fabs<0>(regs,&regs.FR12,regs.FR29);
		/* 820613E4h case    5:*/		return 0x820613E8;
		  /* 820613E8h */ case    6:  		/* b 12 */
		/* 820613E8h case    6:*/		return 0x820613F4;
		/* 820613E8h case    6:*/		return 0x820613EC;
	}
	return 0x820613EC;
} // Block from 820613D0h-820613ECh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820613ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820613EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820613EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820613EC);
		  /* 820613ECh */ case    0:  		/* fmr FR12, FR0 */
		/* 820613ECh case    0:*/		cpu::op::fmr<0>(regs,&regs.FR12,regs.FR0);
		/* 820613ECh case    0:*/		return 0x820613F0;
		  /* 820613F0h */ case    1:  		/* fabs FR11, FR29 */
		/* 820613F0h case    1:*/		cpu::op::fabs<0>(regs,&regs.FR11,regs.FR29);
		/* 820613F0h case    1:*/		return 0x820613F4;
	}
	return 0x820613F4;
} // Block from 820613ECh-820613F4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820613F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820613F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820613F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820613F4);
		  /* 820613F4h */ case    0:  		/* lis R11, -32256 */
		/* 820613F4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820613F4h case    0:*/		return 0x820613F8;
		  /* 820613F8h */ case    1:  		/* stfs FR12, <#[R1 + 96]> */
		/* 820613F8h case    1:*/		cpu::mem::store32f( regs, regs.FR12, (uint32)(regs.R1 + 0x00000060) );
		/* 820613F8h case    1:*/		return 0x820613FC;
		  /* 820613FCh */ case    2:  		/* lis R10, -32256 */
		/* 820613FCh case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 820613FCh case    2:*/		return 0x82061400;
		  /* 82061400h */ case    3:  		/* stfs FR13, <#[R1 + 100]> */
		/* 82061400h case    3:*/		cpu::mem::store32f( regs, regs.FR13, (uint32)(regs.R1 + 0x00000064) );
		/* 82061400h case    3:*/		return 0x82061404;
		  /* 82061404h */ case    4:  		/* lis R9, -32256 */
		/* 82061404h case    4:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 82061404h case    4:*/		return 0x82061408;
		  /* 82061408h */ case    5:  		/* stfs FR11, <#[R1 + 104]> */
		/* 82061408h case    5:*/		cpu::mem::store32f( regs, regs.FR11, (uint32)(regs.R1 + 0x00000068) );
		/* 82061408h case    5:*/		return 0x8206140C;
		  /* 8206140Ch */ case    6:  		/* lis R8, -32256 */
		/* 8206140Ch case    6:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8200);
		/* 8206140Ch case    6:*/		return 0x82061410;
		  /* 82061410h */ case    7:  		/* stfs FR0, <#[R1 + 108]> */
		/* 82061410h case    7:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0x0000006C) );
		/* 82061410h case    7:*/		return 0x82061414;
		  /* 82061414h */ case    8:  		/* addi R7, R1, 96 */
		/* 82061414h case    8:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 82061414h case    8:*/		return 0x82061418;
		  /* 82061418h */ case    9:  		/* fmr FR1, FR30 */
		/* 82061418h case    9:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR30);
		/* 82061418h case    9:*/		return 0x8206141C;
		  /* 8206141Ch */ case   10:  		/* addi R11, R11, 1888 */
		/* 8206141Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x760);
		/* 8206141Ch case   10:*/		return 0x82061420;
		  /* 82061420h */ case   11:  		/* addi R10, R10, 2704 */
		/* 82061420h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xA90);
		/* 82061420h case   11:*/		return 0x82061424;
		  /* 82061424h */ case   12:  		/* addi R9, R9, 2688 */
		/* 82061424h case   12:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xA80);
		/* 82061424h case   12:*/		return 0x82061428;
		  /* 82061428h */ case   13:  		/* addi R8, R8, 2672 */
		/* 82061428h case   13:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xA70);
		/* 82061428h case   13:*/		return 0x8206142C;
		  /* 8206142Ch */ case   14:  		/* lvx VR62, <#[R7]> */
		/* 8206142Ch case   14:*/		cpu::mem::lvx( regs, &regs.VR62, (uint32)(regs.R7 + 0x00000000) );
		/* 8206142Ch case   14:*/		return 0x82061430;
		  /* 82061430h */ case   15:  		/* addi R6, R1, 176 */
		/* 82061430h case   15:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0xB0);
		/* 82061430h case   15:*/		return 0x82061434;
		  /* 82061434h */ case   16:  		/* lvx VR122, <#[R11]> */
		/* 82061434h case   16:*/		cpu::mem::lvx( regs, &regs.VR122, (uint32)(regs.R11 + 0x00000000) );
		/* 82061434h case   16:*/		return 0x82061438;
		  /* 82061438h */ case   17:  		/* addi R11, R1, 112 */
		/* 82061438h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 82061438h case   17:*/		return 0x8206143C;
		  /* 8206143Ch */ case   18:  		/* lvx VR61, <#[R10]> */
		/* 8206143Ch case   18:*/		cpu::mem::lvx( regs, &regs.VR61, (uint32)(regs.R10 + 0x00000000) );
		/* 8206143Ch case   18:*/		return 0x82061440;
		  /* 82061440h */ case   19:  		/* addi R7, R1, 192 */
		/* 82061440h case   19:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0xC0);
		/* 82061440h case   19:*/		return 0x82061444;
		  /* 82061444h */ case   20:  		/* lvx VR60, <#[R9]> */
		/* 82061444h case   20:*/		cpu::mem::lvx( regs, &regs.VR60, (uint32)(regs.R9 + 0x00000000) );
		/* 82061444h case   20:*/		return 0x82061448;
		  /* 82061448h */ case   21:  		/* addi R10, R1, 144 */
		/* 82061448h case   21:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x90);
		/* 82061448h case   21:*/		return 0x8206144C;
		  /* 8206144Ch */ case   22:  		/* lvx VR59, <#[R8]> */
		/* 8206144Ch case   22:*/		cpu::mem::lvx( regs, &regs.VR59, (uint32)(regs.R8 + 0x00000000) );
		/* 8206144Ch case   22:*/		return 0x82061450;
		  /* 82061450h */ case   23:  		/* addi R9, R1, 128 */
		/* 82061450h case   23:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x80);
		/* 82061450h case   23:*/		return 0x82061454;
		  /* 82061454h */ case   24:  		/* addi R8, R1, 160 */
		/* 82061454h case   24:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xA0);
		/* 82061454h case   24:*/		return 0x82061458;
		  /* 82061458h */ case   25:  		/* mr VR63, VR122 */
		/* 82061458h case   25:*/		regs.VR63 = regs.VR122;
		/* 82061458h case   25:*/		return 0x8206145C;
		  /* 8206145Ch */ case   26:  		/* stvx VR62, <#[R6]> */
		/* 8206145Ch case   26:*/		cpu::mem::stvx( regs, regs.VR62, (uint32)(regs.R6 + 0x00000000) );
		/* 8206145Ch case   26:*/		return 0x82061460;
		  /* 82061460h */ case   27:  		/* stvx VR63, <#[R11]> */
		/* 82061460h case   27:*/		cpu::mem::stvx( regs, regs.VR63, (uint32)(regs.R11 + 0x00000000) );
		/* 82061460h case   27:*/		return 0x82061464;
		  /* 82061464h */ case   28:  		/* stvx VR122, <#[R8]> */
		/* 82061464h case   28:*/		cpu::mem::stvx( regs, regs.VR122, (uint32)(regs.R8 + 0x00000000) );
		/* 82061464h case   28:*/		return 0x82061468;
		  /* 82061468h */ case   29:  		/* stvx VR61, <#[R7]> */
		/* 82061468h case   29:*/		cpu::mem::stvx( regs, regs.VR61, (uint32)(regs.R7 + 0x00000000) );
		/* 82061468h case   29:*/		return 0x8206146C;
		  /* 8206146Ch */ case   30:  		/* stvx VR60, <#[R10]> */
		/* 8206146Ch case   30:*/		cpu::mem::stvx( regs, regs.VR60, (uint32)(regs.R10 + 0x00000000) );
		/* 8206146Ch case   30:*/		return 0x82061470;
		  /* 82061470h */ case   31:  		/* stvx VR59, <#[R9]> */
		/* 82061470h case   31:*/		cpu::mem::stvx( regs, regs.VR59, (uint32)(regs.R9 + 0x00000000) );
		/* 82061470h case   31:*/		return 0x82061474;
		  /* 82061474h */ case   32:  		/* bl 194356 */
		/* 82061474h case   32:*/		regs.LR = 0x82061478; return 0x82090BA8;
		/* 82061474h case   32:*/		return 0x82061478;
		  /* 82061478h */ case   33:  		/* frsp FR29, FR1 */
		/* 82061478h case   33:*/		cpu::op::frsp<0>(regs,&regs.FR29,regs.FR1);
		/* 82061478h case   33:*/		return 0x8206147C;
		  /* 8206147Ch */ case   34:  		/* stfs FR31, <#[R1 + 96]> */
		/* 8206147Ch case   34:*/		cpu::mem::store32f( regs, regs.FR31, (uint32)(regs.R1 + 0x00000060) );
		/* 8206147Ch case   34:*/		return 0x82061480;
		  /* 82061480h */ case   35:  		/* fmr FR1, FR30 */
		/* 82061480h case   35:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR30);
		/* 82061480h case   35:*/		return 0x82061484;
		  /* 82061484h */ case   36:  		/* stfs FR31, <#[R1 + 100]> */
		/* 82061484h case   36:*/		cpu::mem::store32f( regs, regs.FR31, (uint32)(regs.R1 + 0x00000064) );
		/* 82061484h case   36:*/		return 0x82061488;
		  /* 82061488h */ case   37:  		/* bl 194112 */
		/* 82061488h case   37:*/		regs.LR = 0x8206148C; return 0x82090AC8;
		/* 82061488h case   37:*/		return 0x8206148C;
		  /* 8206148Ch */ case   38:  		/* frsp FR12, FR1 */
		/* 8206148Ch case   38:*/		cpu::op::frsp<0>(regs,&regs.FR12,regs.FR1);
		/* 8206148Ch case   38:*/		return 0x82061490;
		  /* 82061490h */ case   39:  		/* lis R11, -32256 */
		/* 82061490h case   39:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82061490h case   39:*/		return 0x82061494;
		  /* 82061494h */ case   40:  		/* lis R10, -32256 */
		/* 82061494h case   40:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82061494h case   40:*/		return 0x82061498;
		  /* 82061498h */ case   41:  		/* addi R9, R1, 96 */
		/* 82061498h case   41:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x60);
		/* 82061498h case   41:*/		return 0x8206149C;
		  /* 8206149Ch */ case   42:  		/* addi R8, R1, 208 */
		/* 8206149Ch case   42:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0xD0);
		/* 8206149Ch case   42:*/		return 0x820614A0;
		  /* 820614A0h */ case   43:  		/* addi R3, R1, 80 */
		/* 820614A0h case   43:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 820614A0h case   43:*/		return 0x820614A4;
		  /* 820614A4h */ case   44:  		/* lfs FR0, <#[R11 + 2664]> */
		/* 820614A4h case   44:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000A68) );
		/* 820614A4h case   44:*/		return 0x820614A8;
		  /* 820614A8h */ case   45:  		/* addi R4, R1, 272 */
		/* 820614A8h case   45:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x110);
		/* 820614A8h case   45:*/		return 0x820614AC;
		  /* 820614ACh */ case   46:  		/* lfs FR13, <#[R10 + 2660]> */
		/* 820614ACh case   46:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R10 + 0x00000A64) );
		/* 820614ACh case   46:*/		return 0x820614B0;
		  /* 820614B0h */ case   47:  		/* fmuls FR0, FR29, FR0 */
		/* 820614B0h case   47:*/		cpu::op::fmuls<0>(regs,&regs.FR0,regs.FR29,regs.FR0);
		/* 820614B0h case   47:*/		return 0x820614B4;
		  /* 820614B4h */ case   48:  		/* stfs FR0, <#[R1 + 108]> */
		/* 820614B4h case   48:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0x0000006C) );
		/* 820614B4h case   48:*/		return 0x820614B8;
		  /* 820614B8h */ case   49:  		/* li R5, 16 */
		/* 820614B8h case   49:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 820614B8h case   49:*/		return 0x820614BC;
		  /* 820614BCh */ case   50:  		/* fmuls FR0, FR12, FR13 */
		/* 820614BCh case   50:*/		cpu::op::fmuls<0>(regs,&regs.FR0,regs.FR12,regs.FR13);
		/* 820614BCh case   50:*/		return 0x820614C0;
		  /* 820614C0h */ case   51:  		/* stfs FR0, <#[R1 + 104]> */
		/* 820614C0h case   51:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000068) );
		/* 820614C0h case   51:*/		return 0x820614C4;
		  /* 820614C4h */ case   52:  		/* lvx VR63, <#[R9]> */
		/* 820614C4h case   52:*/		cpu::mem::lvx( regs, &regs.VR63, (uint32)(regs.R9 + 0x00000000) );
		/* 820614C4h case   52:*/		return 0x820614C8;
		  /* 820614C8h */ case   53:  		/* stvx VR63, <#[R8]> */
		/* 820614C8h case   53:*/		cpu::mem::stvx( regs, regs.VR63, (uint32)(regs.R8 + 0x00000000) );
		/* 820614C8h case   53:*/		return 0x820614CC;
		  /* 820614CCh */ case   54:  		/* bl 197860 */
		/* 820614CCh case   54:*/		regs.LR = 0x820614D0; return 0x820919B0;
		/* 820614CCh case   54:*/		return 0x820614D0;
		  /* 820614D0h */ case   55:  		/* addi R4, R1, 96 */
		/* 820614D0h case   55:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 820614D0h case   55:*/		return 0x820614D4;
		  /* 820614D4h */ case   56:  		/* ld R5, <#[R1 + 224]> */
		/* 820614D4h case   56:*/		cpu::mem::load64( regs, &regs.R5, (uint32)(regs.R1 + 0x000000E0) );
		/* 820614D4h case   56:*/		return 0x820614D8;
		  /* 820614D8h */ case   57:  		/* addi R3, R1, 288 */
		/* 820614D8h case   57:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x120);
		/* 820614D8h case   57:*/		return 0x820614DC;
		  /* 820614DCh */ case   58:  		/* ld R6, <#[R1 + 232]> */
		/* 820614DCh case   58:*/		cpu::mem::load64( regs, &regs.R6, (uint32)(regs.R1 + 0x000000E8) );
		/* 820614DCh case   58:*/		return 0x820614E0;
		  /* 820614E0h */ case   59:  		/* ld R7, <#[R1 + 240]> */
		/* 820614E0h case   59:*/		cpu::mem::load64( regs, &regs.R7, (uint32)(regs.R1 + 0x000000F0) );
		/* 820614E0h case   59:*/		return 0x820614E4;
		  /* 820614E4h */ case   60:  		/* ld R8, <#[R1 + 248]> */
		/* 820614E4h case   60:*/		cpu::mem::load64( regs, &regs.R8, (uint32)(regs.R1 + 0x000000F8) );
		/* 820614E4h case   60:*/		return 0x820614E8;
		  /* 820614E8h */ case   61:  		/* ld R9, <#[R1 + 256]> */
		/* 820614E8h case   61:*/		cpu::mem::load64( regs, &regs.R9, (uint32)(regs.R1 + 0x00000100) );
		/* 820614E8h case   61:*/		return 0x820614EC;
		  /* 820614ECh */ case   62:  		/* ld R10, <#[R1 + 264]> */
		/* 820614ECh case   62:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R1 + 0x00000108) );
		/* 820614ECh case   62:*/		return 0x820614F0;
		  /* 820614F0h */ case   63:  		/* bl -5360 */
		/* 820614F0h case   63:*/		regs.LR = 0x820614F4; return 0x82060000;
		/* 820614F0h case   63:*/		return 0x820614F4;
		  /* 820614F4h */ case   64:  		/* addi R10, R1, 288 */
		/* 820614F4h case   64:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x120);
		/* 820614F4h case   64:*/		return 0x820614F8;
		  /* 820614F8h */ case   65:  		/* vspltisw VR63, 1 */
		/* 820614F8h case   65:*/		cpu::op::vspltisw<0,1>(regs,&regs.VR63);
		/* 820614F8h case   65:*/		return 0x820614FC;
		  /* 820614FCh */ case   66:  		/* addi R9, R1, 320 */
		/* 820614FCh case   66:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x140);
		/* 820614FCh case   66:*/		return 0x82061500;
		  /* 82061500h */ case   67:  		/* addi R8, R1, 304 */
		/* 82061500h case   67:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x130);
		/* 82061500h case   67:*/		return 0x82061504;
		  /* 82061504h */ case   68:  		/* addi R7, R1, 336 */
		/* 82061504h case   68:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x150);
		/* 82061504h case   68:*/		return 0x82061508;
		  /* 82061508h */ case   69:  		/* vcsxwfp VR7, VR63, 1 */
		/* 82061508h case   69:*/		cpu::op::vcsxwfp<0,1>(regs,&regs.VR7,regs.VR63);
		/* 82061508h case   69:*/		return 0x8206150C;
		  /* 8206150Ch */ case   70:  		/* addi R11, R26, 400 */
		/* 8206150Ch case   70:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x190);
		/* 8206150Ch case   70:*/		return 0x82061510;
		  /* 82061510h */ case   71:  		/* lvx VR62, <#[R9]> */
		/* 82061510h case   71:*/		cpu::mem::lvx( regs, &regs.VR62, (uint32)(regs.R9 + 0x00000000) );
		/* 82061510h case   71:*/		return 0x82061514;
		  /* 82061514h */ case   72:  		/* lvx VR61, <#[R8]> */
		/* 82061514h case   72:*/		cpu::mem::lvx( regs, &regs.VR61, (uint32)(regs.R8 + 0x00000000) );
		/* 82061514h case   72:*/		return 0x82061518;
		  /* 82061518h */ case   73:  		/* lvx VR60, <#[R7]> */
		/* 82061518h case   73:*/		cpu::mem::lvx( regs, &regs.VR60, (uint32)(regs.R7 + 0x00000000) );
		/* 82061518h case   73:*/		return 0x8206151C;
		  /* 8206151Ch */ case   74:  		/* lvx VR58, <#[R11]> */
		/* 8206151Ch case   74:*/		cpu::mem::lvx( regs, &regs.VR58, (uint32)(regs.R11 + 0x00000000) );
		/* 8206151Ch case   74:*/		return 0x82061520;
		  /* 82061520h */ case   75:  		/* lvx VR63, <#[R10]> */
		/* 82061520h case   75:*/		cpu::mem::lvx( regs, &regs.VR63, (uint32)(regs.R10 + 0x00000000) );
		/* 82061520h case   75:*/		return 0x82061524;
		  /* 82061524h */ case   76:  		/* vmrghw VR59, VR63, VR62 */
		/* 82061524h case   76:*/		cpu::op::vmrghw<0>(regs,&regs.VR59,regs.VR63,regs.VR62);
		/* 82061524h case   76:*/		return 0x82061528;
		  /* 82061528h */ case   77:  		/* vmrglw VR63, VR63, VR62 */
		/* 82061528h case   77:*/		cpu::op::vmrglw<0>(regs,&regs.VR63,regs.VR63,regs.VR62);
		/* 82061528h case   77:*/		return 0x8206152C;
		  /* 8206152Ch */ case   78:  		/* vmrghw VR62, VR61, VR60 */
		/* 8206152Ch case   78:*/		cpu::op::vmrghw<0>(regs,&regs.VR62,regs.VR61,regs.VR60);
		/* 8206152Ch case   78:*/		return 0x82061530;
		  /* 82061530h */ case   79:  		/* vmrglw VR61, VR61, VR60 */
		/* 82061530h case   79:*/		cpu::op::vmrglw<0>(regs,&regs.VR61,regs.VR61,regs.VR60);
		/* 82061530h case   79:*/		return 0x82061534;
		  /* 82061534h */ case   80:  		/* vmrghw VR60, VR59, VR62 */
		/* 82061534h case   80:*/		cpu::op::vmrghw<0>(regs,&regs.VR60,regs.VR59,regs.VR62);
		/* 82061534h case   80:*/		return 0x82061538;
		  /* 82061538h */ case   81:  		/* vmrglw VR62, VR59, VR62 */
		/* 82061538h case   81:*/		cpu::op::vmrglw<0>(regs,&regs.VR62,regs.VR59,regs.VR62);
		/* 82061538h case   81:*/		return 0x8206153C;
		  /* 8206153Ch */ case   82:  		/* lvx VR0, <#[R11 + R27]> */
		/* 8206153Ch case   82:*/		cpu::mem::lvx( regs, &regs.VR0, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 8206153Ch case   82:*/		return 0x82061540;
		  /* 82061540h */ case   83:  		/* vmrghw VR59, VR63, VR61 */
		/* 82061540h case   83:*/		cpu::op::vmrghw<0>(regs,&regs.VR59,regs.VR63,regs.VR61);
		/* 82061540h case   83:*/		return 0x82061544;
		  /* 82061544h */ case   84:  		/* lvx VR13, <#[R11 + R28]> */
		/* 82061544h case   84:*/		cpu::mem::lvx( regs, &regs.VR13, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 82061544h case   84:*/		return 0x82061548;
		  /* 82061548h */ case   85:  		/* vmrglw VR63, VR63, VR61 */
		/* 82061548h case   85:*/		cpu::op::vmrglw<0>(regs,&regs.VR63,regs.VR63,regs.VR61);
		/* 82061548h case   85:*/		return 0x8206154C;
		  /* 8206154Ch */ case   86:  		/* vdot4fp VR61, VR122, VR60 */
		/* 8206154Ch case   86:*/		cpu::op::vdot4fp<0>(regs,&regs.VR61,regs.VR122,regs.VR60);
		/* 8206154Ch case   86:*/		return 0x82061550;
		  /* 82061550h */ case   87:  		/* vspltw VR60, VR126, 0 */
		/* 82061550h case   87:*/		cpu::op::vspltw<0,0>(regs,&regs.VR60,regs.VR126);
		/* 82061550h case   87:*/		return 0x82061554;
		  /* 82061554h */ case   88:  		/* lvx VR12, <#[R11 + R29]> */
		/* 82061554h case   88:*/		cpu::mem::lvx( regs, &regs.VR12, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 82061554h case   88:*/		return 0x82061558;
		  /* 82061558h */ case   89:  		/* vdot4fp VR62, VR122, VR62 */
		/* 82061558h case   89:*/		cpu::op::vdot4fp<0>(regs,&regs.VR62,regs.VR122,regs.VR62);
		/* 82061558h case   89:*/		return 0x8206155C;
		  /* 8206155Ch */ case   90:  		/* vspltw VR57, VR125, 0 */
		/* 8206155Ch case   90:*/		cpu::op::vspltw<0,0>(regs,&regs.VR57,regs.VR125);
		/* 8206155Ch case   90:*/		return 0x82061560;
		  /* 82061560h */ case   91:  		/* vdot4fp VR59, VR122, VR59 */
		/* 82061560h case   91:*/		cpu::op::vdot4fp<0>(regs,&regs.VR59,regs.VR122,regs.VR59);
		/* 82061560h case   91:*/		return 0x82061564;
		  /* 82061564h */ case   92:  		/* vspltw VR56, VR124, 0 */
		/* 82061564h case   92:*/		cpu::op::vspltw<0,0>(regs,&regs.VR56,regs.VR124);
		/* 82061564h case   92:*/		return 0x82061568;
		  /* 82061568h */ case   93:  		/* vdot4fp VR63, VR122, VR63 */
		/* 82061568h case   93:*/		cpu::op::vdot4fp<0>(regs,&regs.VR63,regs.VR122,regs.VR63);
		/* 82061568h case   93:*/		return 0x8206156C;
		  /* 8206156Ch */ case   94:  		/* vspltw VR55, VR123, 0 */
		/* 8206156Ch case   94:*/		cpu::op::vspltw<0,0>(regs,&regs.VR55,regs.VR123);
		/* 8206156Ch case   94:*/		return 0x82061570;
		  /* 82061570h */ case   95:  		/* vmulfp128 VR4, VR60, VR58 */
		/* 82061570h case   95:*/		cpu::op::vmulfp128<0>(regs,&regs.VR4,regs.VR60,regs.VR58);
		/* 82061570h case   95:*/		return 0x82061574;
		  /* 82061574h */ case   96:  		/* vspltw VR8, VR126, 1 */
		/* 82061574h case   96:*/		cpu::op::vspltw<0,1>(regs,&regs.VR8,regs.VR126);
		/* 82061574h case   96:*/		return 0x82061578;
		  /* 82061578h */ case   97:  		/* vmulfp128 VR2, VR57, VR58 */
		/* 82061578h case   97:*/		cpu::op::vmulfp128<0>(regs,&regs.VR2,regs.VR57,regs.VR58);
		/* 82061578h case   97:*/		return 0x8206157C;
		  /* 8206157Ch */ case   98:  		/* vspltw VR3, VR125, 1 */
		/* 8206157Ch case   98:*/		cpu::op::vspltw<0,1>(regs,&regs.VR3,regs.VR125);
		/* 8206157Ch case   98:*/		return 0x82061580;
		  /* 82061580h */ case   99:  		/* vmulfp128 VR31, VR56, VR58 */
		/* 82061580h case   99:*/		cpu::op::vmulfp128<0>(regs,&regs.VR31,regs.VR56,regs.VR58);
		/* 82061580h case   99:*/		return 0x82061584;
		  /* 82061584h */ case  100:  		/* vspltw VR1, VR124, 1 */
		/* 82061584h case  100:*/		cpu::op::vspltw<0,1>(regs,&regs.VR1,regs.VR124);
		/* 82061584h case  100:*/		return 0x82061588;
		  /* 82061588h */ case  101:  		/* vmulfp128 VR29, VR55, VR58 */
		/* 82061588h case  101:*/		cpu::op::vmulfp128<0>(regs,&regs.VR29,regs.VR55,regs.VR58);
		/* 82061588h case  101:*/		return 0x8206158C;
		  /* 8206158Ch */ case  102:  		/* vspltw VR30, VR123, 1 */
		/* 8206158Ch case  102:*/		cpu::op::vspltw<0,1>(regs,&regs.VR30,regs.VR123);
		/* 8206158Ch case  102:*/		return 0x82061590;
		  /* 82061590h */ case  103:  		/* vspltw VR28, VR126, 2 */
		/* 82061590h case  103:*/		cpu::op::vspltw<0,2>(regs,&regs.VR28,regs.VR126);
		/* 82061590h case  103:*/		return 0x82061594;
		  /* 82061594h */ case  104:  		/* addi R10, R26, 464 */
		/* 82061594h case  104:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R26,0x1D0);
		/* 82061594h case  104:*/		return 0x82061598;
		  /* 82061598h */ case  105:  		/* vspltw VR27, VR125, 2 */
		/* 82061598h case  105:*/		cpu::op::vspltw<0,2>(regs,&regs.VR27,regs.VR125);
		/* 82061598h case  105:*/		return 0x8206159C;
		  /* 8206159Ch */ case  106:  		/* addi R9, R1, 112 */
		/* 8206159Ch case  106:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x70);
		/* 8206159Ch case  106:*/		return 0x820615A0;
		  /* 820615A0h */ case  107:  		/* vspltw VR26, VR124, 2 */
		/* 820615A0h case  107:*/		cpu::op::vspltw<0,2>(regs,&regs.VR26,regs.VR124);
		/* 820615A0h case  107:*/		return 0x820615A4;
		  /* 820615A4h */ case  108:  		/* li R8, 1 */
		/* 820615A4h case  108:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820615A4h case  108:*/		return 0x820615A8;
		  /* 820615A8h */ case  109:  		/* vspltw VR25, VR123, 2 */
		/* 820615A8h case  109:*/		cpu::op::vspltw<0,2>(regs,&regs.VR25,regs.VR123);
		/* 820615A8h case  109:*/		return 0x820615AC;
		  /* 820615ACh */ case  110:  		/* vspltw VR24, VR126, 3 */
		/* 820615ACh case  110:*/		cpu::op::vspltw<0,3>(regs,&regs.VR24,regs.VR126);
		/* 820615ACh case  110:*/		return 0x820615B0;
		  /* 820615B0h */ case  111:  		/* vspltw VR23, VR125, 3 */
		/* 820615B0h case  111:*/		cpu::op::vspltw<0,3>(regs,&regs.VR23,regs.VR125);
		/* 820615B0h case  111:*/		return 0x820615B4;
		  /* 820615B4h */ case  112:  		/* lvx VR60, <#[R10]> */
		/* 820615B4h case  112:*/		cpu::mem::lvx( regs, &regs.VR60, (uint32)(regs.R10 + 0x00000000) );
		/* 820615B4h case  112:*/		return 0x820615B8;
		  /* 820615B8h */ case  113:  		/* vspltw VR5, VR124, 3 */
		/* 820615B8h case  113:*/		cpu::op::vspltw<0,3>(regs,&regs.VR5,regs.VR124);
		/* 820615B8h case  113:*/		return 0x820615BC;
		  /* 820615BCh */ case  114:  		/* lvx VR11, <#[R10 + R27]> */
		/* 820615BCh case  114:*/		cpu::mem::lvx( regs, &regs.VR11, (uint32)(regs.R10 + regs.R27 + 0x00000000) );
		/* 820615BCh case  114:*/		return 0x820615C0;
		  /* 820615C0h */ case  115:  		/* vspltw VR6, VR123, 3 */
		/* 820615C0h case  115:*/		cpu::op::vspltw<0,3>(regs,&regs.VR6,regs.VR123);
		/* 820615C0h case  115:*/		return 0x820615C4;
		  /* 820615C4h */ case  116:  		/* lvx VR10, <#[R10 + R28]> */
		/* 820615C4h case  116:*/		cpu::mem::lvx( regs, &regs.VR10, (uint32)(regs.R10 + regs.R28 + 0x00000000) );
		/* 820615C4h case  116:*/		return 0x820615C8;
		  /* 820615C8h */ case  117:  		/* vmaddfp VR8, VR8, VR0, VR4 */
		/* 820615C8h case  117:*/		cpu::op::vmaddfp<0>(regs,&regs.VR8,regs.VR8,regs.VR0,regs.VR4);
		/* 820615C8h case  117:*/		return 0x820615CC;
		  /* 820615CCh */ case  118:  		/* lvx VR9, <#[R10 + R29]> */
		/* 820615CCh case  118:*/		cpu::mem::lvx( regs, &regs.VR9, (uint32)(regs.R10 + regs.R29 + 0x00000000) );
		/* 820615CCh case  118:*/		return 0x820615D0;
		  /* 820615D0h */ case  119:  		/* vmaddfp VR4, VR3, VR0, VR2 */
		/* 820615D0h case  119:*/		cpu::op::vmaddfp<0>(regs,&regs.VR4,regs.VR3,regs.VR0,regs.VR2);
		/* 820615D0h case  119:*/		return 0x820615D4;
		  /* 820615D4h */ case  120:  		/* vmrghw VR61, VR61, VR59 */
		/* 820615D4h case  120:*/		cpu::op::vmrghw<0>(regs,&regs.VR61,regs.VR61,regs.VR59);
		/* 820615D4h case  120:*/		return 0x820615D8;
		  /* 820615D8h */ case  121:  		/* vmaddfp VR3, VR1, VR0, VR31 */
		/* 820615D8h case  121:*/		cpu::op::vmaddfp<0>(regs,&regs.VR3,regs.VR1,regs.VR0,regs.VR31);
		/* 820615D8h case  121:*/		return 0x820615DC;
		  /* 820615DCh */ case  122:  		/* vmrghw VR63, VR62, VR63 */
		/* 820615DCh case  122:*/		cpu::op::vmrghw<0>(regs,&regs.VR63,regs.VR62,regs.VR63);
		/* 820615DCh case  122:*/		return 0x820615E0;
		  /* 820615E0h */ case  123:  		/* vmaddfp VR0, VR30, VR0, VR29 */
		/* 820615E0h case  123:*/		cpu::op::vmaddfp<0>(regs,&regs.VR0,regs.VR30,regs.VR0,regs.VR29);
		/* 820615E0h case  123:*/		return 0x820615E4;
		  /* 820615E4h */ case  124:  		/* vmrghw VR63, VR61, VR63 */
		/* 820615E4h case  124:*/		cpu::op::vmrghw<0>(regs,&regs.VR63,regs.VR61,regs.VR63);
		/* 820615E4h case  124:*/		return 0x820615E8;
		  /* 820615E8h */ case  125:  		/* vdot4fp VR62, VR63, VR63 */
		/* 820615E8h case  125:*/		cpu::op::vdot4fp<0>(regs,&regs.VR62,regs.VR63,regs.VR63);
		/* 820615E8h case  125:*/		return 0x820615EC;
		  /* 820615ECh */ case  126:  		/* vmaddfp VR2, VR28, VR13, VR8 */
		/* 820615ECh case  126:*/		cpu::op::vmaddfp<0>(regs,&regs.VR2,regs.VR28,regs.VR13,regs.VR8);
		/* 820615ECh case  126:*/		return 0x820615F0;
		  /* 820615F0h */ case  127:  		/* vmaddfp VR4, VR27, VR13, VR4 */
		/* 820615F0h case  127:*/		cpu::op::vmaddfp<0>(regs,&regs.VR4,regs.VR27,regs.VR13,regs.VR4);
		/* 820615F0h case  127:*/		return 0x820615F4;
		  /* 820615F4h */ case  128:  		/* vmaddfp VR1, VR26, VR13, VR3 */
		/* 820615F4h case  128:*/		cpu::op::vmaddfp<0>(regs,&regs.VR1,regs.VR26,regs.VR13,regs.VR3);
		/* 820615F4h case  128:*/		return 0x820615F8;
		  /* 820615F8h */ case  129:  		/* vmaddfp VR31, VR25, VR13, VR0 */
		/* 820615F8h case  129:*/		cpu::op::vmaddfp<0>(regs,&regs.VR31,regs.VR25,regs.VR13,regs.VR0);
		/* 820615F8h case  129:*/		return 0x820615FC;
		  /* 820615FCh */ case  130:  		/* vmaddfp VR2, VR24, VR12, VR2 */
		/* 820615FCh case  130:*/		cpu::op::vmaddfp<0>(regs,&regs.VR2,regs.VR24,regs.VR12,regs.VR2);
		/* 820615FCh case  130:*/		return 0x82061600;
		  /* 82061600h */ case  131:  		/* vmaddfp VR4, VR23, VR12, VR4 */
		/* 82061600h case  131:*/		cpu::op::vmaddfp<0>(regs,&regs.VR4,regs.VR23,regs.VR12,regs.VR4);
		/* 82061600h case  131:*/		return 0x82061604;
		  /* 82061604h */ case  132:  		/* vmaddfp VR5, VR5, VR12, VR1 */
		/* 82061604h case  132:*/		cpu::op::vmaddfp<0>(regs,&regs.VR5,regs.VR5,regs.VR12,regs.VR1);
		/* 82061604h case  132:*/		return 0x82061608;
		  /* 82061608h */ case  133:  		/* vrsqrtefp VR0, VR62 */
		/* 82061608h case  133:*/		cpu::op::vrsqrtefp<0>(regs,&regs.VR0,regs.VR62);
		/* 82061608h case  133:*/		return 0x8206160C;
		  /* 8206160Ch */ case  134:  		/* mr VR13, VR62 */
		/* 8206160Ch case  134:*/		regs.VR13 = regs.VR62;
		/* 8206160Ch case  134:*/		return 0x82061610;
		  /* 82061610h */ case  135:  		/* vmaddfp VR6, VR6, VR12, VR31 */
		/* 82061610h case  135:*/		cpu::op::vmaddfp<0>(regs,&regs.VR6,regs.VR6,regs.VR12,regs.VR31);
		/* 82061610h case  135:*/		return 0x82061614;
		  /* 82061614h */ case  136:  		/* vmulfp128 VR8, VR62, VR7 */
		/* 82061614h case  136:*/		cpu::op::vmulfp128<0>(regs,&regs.VR8,regs.VR62,regs.VR7);
		/* 82061614h case  136:*/		return 0x82061618;
		  /* 82061618h */ case  137:  		/* vcmpeqfp VR3, VR62, VR127 */
		/* 82061618h case  137:*/		cpu::op::vcmpeqfp<0>(regs,&regs.VR3,regs.VR62,regs.VR127);
		/* 82061618h case  137:*/		return 0x8206161C;
		  /* 8206161Ch */ case  138:  		/* mr VR62, VR2 */
		/* 8206161Ch case  138:*/		regs.VR62 = regs.VR2;
		/* 8206161Ch case  138:*/		return 0x82061620;
		  /* 82061620h */ case  139:  		/* mr VR61, VR4 */
		/* 82061620h case  139:*/		regs.VR61 = regs.VR4;
		/* 82061620h case  139:*/		return 0x82061624;
		  /* 82061624h */ case  140:  		/* mr VR59, VR5 */
		/* 82061624h case  140:*/		regs.VR59 = regs.VR5;
		/* 82061624h case  140:*/		return 0x82061628;
		  /* 82061628h */ case  141:  		/* vmulfp128 VR12, VR0, VR0 */
		/* 82061628h case  141:*/		cpu::op::vmulfp128<0>(regs,&regs.VR12,regs.VR0,regs.VR0);
		/* 82061628h case  141:*/		return 0x8206162C;
		  /* 8206162Ch */ case  142:  		/* vspltw VR58, VR62, 0 */
		/* 8206162Ch case  142:*/		cpu::op::vspltw<0,0>(regs,&regs.VR58,regs.VR62);
		/* 8206162Ch case  142:*/		return 0x82061630;
		  /* 82061630h */ case  143:  		/* mr VR57, VR6 */
		/* 82061630h case  143:*/		regs.VR57 = regs.VR6;
		/* 82061630h case  143:*/		return 0x82061634;
		  /* 82061634h */ case  144:  		/* vspltw VR56, VR61, 0 */
		/* 82061634h case  144:*/		cpu::op::vspltw<0,0>(regs,&regs.VR56,regs.VR61);
		/* 82061634h case  144:*/		return 0x82061638;
		  /* 82061638h */ case  145:  		/* vspltw VR4, VR62, 1 */
		/* 82061638h case  145:*/		cpu::op::vspltw<0,1>(regs,&regs.VR4,regs.VR62);
		/* 82061638h case  145:*/		return 0x8206163C;
		  /* 8206163Ch */ case  146:  		/* vspltw VR55, VR59, 0 */
		/* 8206163Ch case  146:*/		cpu::op::vspltw<0,0>(regs,&regs.VR55,regs.VR59);
		/* 8206163Ch case  146:*/		return 0x82061640;
		  /* 82061640h */ case  147:  		/* vmulfp128 VR5, VR58, VR60 */
		/* 82061640h case  147:*/		cpu::op::vmulfp128<0>(regs,&regs.VR5,regs.VR58,regs.VR60);
		/* 82061640h case  147:*/		return 0x82061644;
		  /* 82061644h */ case  148:  		/* vspltw VR6, VR61, 1 */
		/* 82061644h case  148:*/		cpu::op::vspltw<0,1>(regs,&regs.VR6,regs.VR61);
		/* 82061644h case  148:*/		return 0x82061648;
		  /* 82061648h */ case  149:  		/* vspltw VR2, VR62, 2 */
		/* 82061648h case  149:*/		cpu::op::vspltw<0,2>(regs,&regs.VR2,regs.VR62);
		/* 82061648h case  149:*/		return 0x8206164C;
		  /* 8206164Ch */ case  150:  		/* vspltw VR58, VR57, 0 */
		/* 8206164Ch case  150:*/		cpu::op::vspltw<0,0>(regs,&regs.VR58,regs.VR57);
		/* 8206164Ch case  150:*/		return 0x82061650;
		  /* 82061650h */ case  151:  		/* vnmsubfp VR1, VR8, VR12, VR7 */
		/* 82061650h case  151:*/		cpu::op::vnmsubfp<0>(regs,&regs.VR1,regs.VR8,regs.VR12,regs.VR7);
		/* 82061650h case  151:*/		return 0x82061654;
		  /* 82061654h */ case  152:  		/* vspltw VR8, VR59, 1 */
		/* 82061654h case  152:*/		cpu::op::vspltw<0,1>(regs,&regs.VR8,regs.VR59);
		/* 82061654h case  152:*/		return 0x82061658;
		  /* 82061658h */ case  153:  		/* vmulfp128 VR7, VR56, VR60 */
		/* 82061658h case  153:*/		cpu::op::vmulfp128<0>(regs,&regs.VR7,regs.VR56,regs.VR60);
		/* 82061658h case  153:*/		return 0x8206165C;
		  /* 8206165Ch */ case  154:  		/* vmulfp128 VR12, VR55, VR60 */
		/* 8206165Ch case  154:*/		cpu::op::vmulfp128<0>(regs,&regs.VR12,regs.VR55,regs.VR60);
		/* 8206165Ch case  154:*/		return 0x82061660;
		  /* 82061660h */ case  155:  		/* vmaddfp VR30, VR4, VR11, VR5 */
		/* 82061660h case  155:*/		cpu::op::vmaddfp<0>(regs,&regs.VR30,regs.VR4,regs.VR11,regs.VR5);
		/* 82061660h case  155:*/		return 0x82061664;
		  /* 82061664h */ case  156:  		/* vspltw VR5, VR57, 1 */
		/* 82061664h case  156:*/		cpu::op::vspltw<0,1>(regs,&regs.VR5,regs.VR57);
		/* 82061664h case  156:*/		return 0x82061668;
		  /* 82061668h */ case  157:  		/* vmaddfp VR0, VR0, VR1, VR0 */
		/* 82061668h case  157:*/		cpu::op::vmaddfp<0>(regs,&regs.VR0,regs.VR0,regs.VR1,regs.VR0);
		/* 82061668h case  157:*/		return 0x8206166C;
		  /* 8206166Ch */ case  158:  		/* vmaddfp VR31, VR6, VR11, VR7 */
		/* 8206166Ch case  158:*/		cpu::op::vmaddfp<0>(regs,&regs.VR31,regs.VR6,regs.VR11,regs.VR7);
		/* 8206166Ch case  158:*/		return 0x82061670;
		  /* 82061670h */ case  159:  		/* vmulfp128 VR0, VR63, VR0 */
		/* 82061670h case  159:*/		cpu::op::vmulfp128<0>(regs,&regs.VR0,regs.VR63,regs.VR0);
		/* 82061670h case  159:*/		return 0x82061674;
		  /* 82061674h */ case  160:  		/* vsel VR3, VR0, VR13, VR3 */
		/* 82061674h case  160:*/		cpu::op::vsel<0>(regs,&regs.VR3,regs.VR0,regs.VR13,regs.VR3);
		/* 82061674h case  160:*/		return 0x82061678;
		  /* 82061678h */ case  161:  		/* stvx VR3, <#[R9]> */
		/* 82061678h case  161:*/		cpu::mem::stvx( regs, regs.VR3, (uint32)(regs.R9 + 0x00000000) );
		/* 82061678h case  161:*/		return 0x8206167C;
		  /* 8206167Ch */ case  162:  		/* vmulfp128 VR6, VR58, VR60 */
		/* 8206167Ch case  162:*/		cpu::op::vmulfp128<0>(regs,&regs.VR6,regs.VR58,regs.VR60);
		/* 8206167Ch case  162:*/		return 0x82061680;
		  /* 82061680h */ case  163:  		/* vspltw VR3, VR61, 2 */
		/* 82061680h case  163:*/		cpu::op::vspltw<0,2>(regs,&regs.VR3,regs.VR61);
		/* 82061680h case  163:*/		return 0x82061684;
		  /* 82061684h */ case  164:  		/* vmaddfp VR1, VR8, VR11, VR12 */
		/* 82061684h case  164:*/		cpu::op::vmaddfp<0>(regs,&regs.VR1,regs.VR8,regs.VR11,regs.VR12);
		/* 82061684h case  164:*/		return 0x82061688;
		  /* 82061688h */ case  165:  		/* vspltw VR4, VR59, 2 */
		/* 82061688h case  165:*/		cpu::op::vspltw<0,2>(regs,&regs.VR4,regs.VR59);
		/* 82061688h case  165:*/		return 0x8206168C;
		  /* 8206168Ch */ case  166:  		/* vspltw VR13, VR57, 2 */
		/* 8206168Ch case  166:*/		cpu::op::vspltw<0,2>(regs,&regs.VR13,regs.VR57);
		/* 8206168Ch case  166:*/		return 0x82061690;
		  /* 82061690h */ case  167:  		/* vmaddfp VR2, VR2, VR10, VR30 */
		/* 82061690h case  167:*/		cpu::op::vmaddfp<0>(regs,&regs.VR2,regs.VR2,regs.VR10,regs.VR30);
		/* 82061690h case  167:*/		return 0x82061694;
		  /* 82061694h */ case  168:  		/* vmrghw VR55, VR62, VR59 */
		/* 82061694h case  168:*/		cpu::op::vmrghw<0>(regs,&regs.VR55,regs.VR62,regs.VR59);
		/* 82061694h case  168:*/		return 0x82061698;
		  /* 82061698h */ case  169:  		/* lvx VR60, <#[R11 + R28]> */
		/* 82061698h case  169:*/		cpu::mem::lvx( regs, &regs.VR60, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 82061698h case  169:*/		return 0x8206169C;
		  /* 8206169Ch */ case  170:  		/* vmaddfp VR3, VR3, VR10, VR31 */
		/* 8206169Ch case  170:*/		cpu::op::vmaddfp<0>(regs,&regs.VR3,regs.VR3,regs.VR10,regs.VR31);
		/* 8206169Ch case  170:*/		return 0x820616A0;
		  /* 820616A0h */ case  171:  		/* vmrghw VR53, VR61, VR57 */
		/* 820616A0h case  171:*/		cpu::op::vmrghw<0>(regs,&regs.VR53,regs.VR61,regs.VR57);
		/* 820616A0h case  171:*/		return 0x820616A4;
		  /* 820616A4h */ case  172:  		/* vspltw VR7, VR62, 3 */
		/* 820616A4h case  172:*/		cpu::op::vspltw<0,3>(regs,&regs.VR7,regs.VR62);
		/* 820616A4h case  172:*/		return 0x820616A8;
		  /* 820616A8h */ case  173:  		/* lvx VR58, <#[R11 + R29]> */
		/* 820616A8h case  173:*/		cpu::mem::lvx( regs, &regs.VR58, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 820616A8h case  173:*/		return 0x820616AC;
		  /* 820616ACh */ case  174:  		/* vspltw VR8, VR61, 3 */
		/* 820616ACh case  174:*/		cpu::op::vspltw<0,3>(regs,&regs.VR8,regs.VR61);
		/* 820616ACh case  174:*/		return 0x820616B0;
		  /* 820616B0h */ case  175:  		/* lvx VR56, <#[R11 + R27]> */
		/* 820616B0h case  175:*/		cpu::mem::lvx( regs, &regs.VR56, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 820616B0h case  175:*/		return 0x820616B4;
		  /* 820616B4h */ case  176:  		/* vspltw VR12, VR59, 3 */
		/* 820616B4h case  176:*/		cpu::op::vspltw<0,3>(regs,&regs.VR12,regs.VR59);
		/* 820616B4h case  176:*/		return 0x820616B8;
		  /* 820616B8h */ case  177:  		/* lvx VR63, <#[R11]> */
		/* 820616B8h case  177:*/		cpu::mem::lvx( regs, &regs.VR63, (uint32)(regs.R11 + 0x00000000) );
		/* 820616B8h case  177:*/		return 0x820616BC;
		  /* 820616BCh */ case  178:  		/* vspltw VR0, VR57, 3 */
		/* 820616BCh case  178:*/		cpu::op::vspltw<0,3>(regs,&regs.VR0,regs.VR57);
		/* 820616BCh case  178:*/		return 0x820616C0;
		  /* 820616C0h */ case  179:  		/* mr VR52, VR10 */
		/* 820616C0h case  179:*/		regs.VR52 = regs.VR10;
		/* 820616C0h case  179:*/		return 0x820616C4;
		  /* 820616C4h */ case  180:  		/* vmrglw VR62, VR62, VR59 */
		/* 820616C4h case  180:*/		cpu::op::vmrglw<0>(regs,&regs.VR62,regs.VR62,regs.VR59);
		/* 820616C4h case  180:*/		return 0x820616C8;
		  /* 820616C8h */ case  181:  		/* mr VR59, VR9 */
		/* 820616C8h case  181:*/		regs.VR59 = regs.VR9;
		/* 820616C8h case  181:*/		return 0x820616CC;
		  /* 820616CCh */ case  182:  		/* vmrglw VR61, VR61, VR57 */
		/* 820616CCh case  182:*/		cpu::op::vmrglw<0>(regs,&regs.VR61,regs.VR61,regs.VR57);
		/* 820616CCh case  182:*/		return 0x820616D0;
		  /* 820616D0h */ case  183:  		/* mr VR57, VR11 */
		/* 820616D0h case  183:*/		regs.VR57 = regs.VR11;
		/* 820616D0h case  183:*/		return 0x820616D4;
		  /* 820616D4h */ case  184:  		/* vmrghw VR50, VR56, VR58 */
		/* 820616D4h case  184:*/		cpu::op::vmrghw<0>(regs,&regs.VR50,regs.VR56,regs.VR58);
		/* 820616D4h case  184:*/		return 0x820616D8;
		  /* 820616D8h */ case  185:  		/* lvx VR54, <#[R10]> */
		/* 820616D8h case  185:*/		cpu::mem::lvx( regs, &regs.VR54, (uint32)(regs.R10 + 0x00000000) );
		/* 820616D8h case  185:*/		return 0x820616DC;
		  /* 820616DCh */ case  186:  		/* vmaddfp VR6, VR5, VR11, VR6 */
		/* 820616DCh case  186:*/		cpu::op::vmaddfp<0>(regs,&regs.VR6,regs.VR5,regs.VR11,regs.VR6);
		/* 820616DCh case  186:*/		return 0x820616E0;
		  /* 820616E0h */ case  187:  		/* vmrghw VR51, VR63, VR60 */
		/* 820616E0h case  187:*/		cpu::op::vmrghw<0>(regs,&regs.VR51,regs.VR63,regs.VR60);
		/* 820616E0h case  187:*/		return 0x820616E4;
		  /* 820616E4h */ case  188:  		/* vmaddfp VR4, VR4, VR10, VR1 */
		/* 820616E4h case  188:*/		cpu::op::vmaddfp<0>(regs,&regs.VR4,regs.VR4,regs.VR10,regs.VR1);
		/* 820616E4h case  188:*/		return 0x820616E8;
		  /* 820616E8h */ case  189:  		/* vmrghw VR49, VR55, VR53 */
		/* 820616E8h case  189:*/		cpu::op::vmrghw<0>(regs,&regs.VR49,regs.VR55,regs.VR53);
		/* 820616E8h case  189:*/		return 0x820616EC;
		  /* 820616ECh */ case  190:  		/* vmaddfp VR7, VR7, VR9, VR2 */
		/* 820616ECh case  190:*/		cpu::op::vmaddfp<0>(regs,&regs.VR7,regs.VR7,regs.VR9,regs.VR2);
		/* 820616ECh case  190:*/		return 0x820616F0;
		  /* 820616F0h */ case  191:  		/* vmrglw VR55, VR55, VR53 */
		/* 820616F0h case  191:*/		cpu::op::vmrglw<0>(regs,&regs.VR55,regs.VR55,regs.VR53);
		/* 820616F0h case  191:*/		return 0x820616F4;
		  /* 820616F4h */ case  192:  		/* vmrghw VR53, VR62, VR61 */
		/* 820616F4h case  192:*/		cpu::op::vmrghw<0>(regs,&regs.VR53,regs.VR62,regs.VR61);
		/* 820616F4h case  192:*/		return 0x820616F8;
		  /* 820616F8h */ case  193:  		/* addi R6, R1, 400 */
		/* 820616F8h case  193:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x190);
		/* 820616F8h case  193:*/		return 0x820616FC;
		  /* 820616FCh */ case  194:  		/* vmaddfp VR11, VR8, VR9, VR3 */
		/* 820616FCh case  194:*/		cpu::op::vmaddfp<0>(regs,&regs.VR11,regs.VR8,regs.VR9,regs.VR3);
		/* 820616FCh case  194:*/		return 0x82061700;
		  /* 82061700h */ case  195:  		/* vmrglw VR62, VR62, VR61 */
		/* 82061700h case  195:*/		cpu::op::vmrglw<0>(regs,&regs.VR62,regs.VR62,regs.VR61);
		/* 82061700h case  195:*/		return 0x82061704;
		  /* 82061704h */ case  196:  		/* vmrglw VR63, VR63, VR60 */
		/* 82061704h case  196:*/		cpu::op::vmrglw<0>(regs,&regs.VR63,regs.VR63,regs.VR60);
		/* 82061704h case  196:*/		return 0x82061708;
		  /* 82061708h */ case  197:  		/* addi R10, R1, 368 */
		/* 82061708h case  197:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x170);
		/* 82061708h case  197:*/		return 0x8206170C;
		  /* 8206170Ch */ case  198:  		/* vmrghw VR61, VR51, VR50 */
		/* 8206170Ch case  198:*/		cpu::op::vmrghw<0>(regs,&regs.VR61,regs.VR51,regs.VR50);
		/* 8206170Ch case  198:*/		return 0x82061710;
		  /* 82061710h */ case  199:  		/* addi R5, R1, 416 */
		/* 82061710h case  199:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x1A0);
		/* 82061710h case  199:*/		return 0x82061714;
		  /* 82061714h */ case  200:  		/* vmrglw VR60, VR56, VR58 */
		/* 82061714h case  200:*/		cpu::op::vmrglw<0>(regs,&regs.VR60,regs.VR56,regs.VR58);
		/* 82061714h case  200:*/		return 0x82061718;
		  /* 82061718h */ case  201:  		/* addi R11, R1, 352 */
		/* 82061718h case  201:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x160);
		/* 82061718h case  201:*/		return 0x8206171C;
		  /* 8206171Ch */ case  202:  		/* vmrghw VR58, VR54, VR52 */
		/* 8206171Ch case  202:*/		cpu::op::vmrghw<0>(regs,&regs.VR58,regs.VR54,regs.VR52);
		/* 8206171Ch case  202:*/		return 0x82061720;
		  /* 82061720h */ case  203:  		/* addi R7, R1, 384 */
		/* 82061720h case  203:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x180);
		/* 82061720h case  203:*/		return 0x82061724;
		  /* 82061724h */ case  204:  		/* vmrghw VR56, VR57, VR59 */
		/* 82061724h case  204:*/		cpu::op::vmrghw<0>(regs,&regs.VR56,regs.VR57,regs.VR59);
		/* 82061724h case  204:*/		return 0x82061728;
		  /* 82061728h */ case  205:  		/* addi R4, R1, 432 */
		/* 82061728h case  205:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x1B0);
		/* 82061728h case  205:*/		return 0x8206172C;
		  /* 8206172Ch */ case  206:  		/* vmrglw VR54, VR54, VR52 */
		/* 8206172Ch case  206:*/		cpu::op::vmrglw<0>(regs,&regs.VR54,regs.VR54,regs.VR52);
		/* 8206172Ch case  206:*/		return 0x82061730;
		  /* 82061730h */ case  207:  		/* stvx VR55, <#[R10]> */
		/* 82061730h case  207:*/		cpu::mem::stvx( regs, regs.VR55, (uint32)(regs.R10 + 0x00000000) );
		/* 82061730h case  207:*/		return 0x82061734;
		  /* 82061734h */ case  208:  		/* vmrglw VR59, VR57, VR59 */
		/* 82061734h case  208:*/		cpu::op::vmrglw<0>(regs,&regs.VR59,regs.VR57,regs.VR59);
		/* 82061734h case  208:*/		return 0x82061738;
		  /* 82061738h */ case  209:  		/* stvx VR62, <#[R6]> */
		/* 82061738h case  209:*/		cpu::mem::stvx( regs, regs.VR62, (uint32)(regs.R6 + 0x00000000) );
		/* 82061738h case  209:*/		return 0x8206173C;
		  /* 8206173Ch */ case  210:  		/* vmaddfp VR13, VR13, VR10, VR6 */
		/* 8206173Ch case  210:*/		cpu::op::vmaddfp<0>(regs,&regs.VR13,regs.VR13,regs.VR10,regs.VR6);
		/* 8206173Ch case  210:*/		return 0x82061740;
		  /* 82061740h */ case  211:  		/* vmrghw VR52, VR63, VR60 */
		/* 82061740h case  211:*/		cpu::op::vmrghw<0>(regs,&regs.VR52,regs.VR63,regs.VR60);
		/* 82061740h case  211:*/		return 0x82061744;
		  /* 82061744h */ case  212:  		/* vmaddfp VR12, VR12, VR9, VR4 */
		/* 82061744h case  212:*/		cpu::op::vmaddfp<0>(regs,&regs.VR12,regs.VR12,regs.VR9,regs.VR4);
		/* 82061744h case  212:*/		return 0x82061748;
		  /* 82061748h */ case  213:  		/* vmrglw VR63, VR63, VR60 */
		/* 82061748h case  213:*/		cpu::op::vmrglw<0>(regs,&regs.VR63,regs.VR63,regs.VR60);
		/* 82061748h case  213:*/		return 0x8206174C;
		  /* 8206174Ch */ case  214:  		/* vmrghw VR60, VR58, VR56 */
		/* 8206174Ch case  214:*/		cpu::op::vmrghw<0>(regs,&regs.VR60,regs.VR58,regs.VR56);
		/* 8206174Ch case  214:*/		return 0x82061750;
		  /* 82061750h */ case  215:  		/* stvx VR61, <#[R5]> */
		/* 82061750h case  215:*/		cpu::mem::stvx( regs, regs.VR61, (uint32)(regs.R5 + 0x00000000) );
		/* 82061750h case  215:*/		return 0x82061754;
		  /* 82061754h */ case  216:  		/* vmrglw VR62, VR58, VR56 */
		/* 82061754h case  216:*/		cpu::op::vmrglw<0>(regs,&regs.VR62,regs.VR58,regs.VR56);
		/* 82061754h case  216:*/		return 0x82061758;
		  /* 82061758h */ case  217:  		/* lis R26, -32215 */
		/* 82061758h case  217:*/		cpu::op::lis<0>(regs,&regs.R26,0xFFFF8229);
		/* 82061758h case  217:*/		return 0x8206175C;
		  /* 8206175Ch */ case  218:  		/* vmrghw VR61, VR54, VR59 */
		/* 8206175Ch case  218:*/		cpu::op::vmrghw<0>(regs,&regs.VR61,regs.VR54,regs.VR59);
		/* 8206175Ch case  218:*/		return 0x82061760;
		  /* 82061760h */ case  219:  		/* stvx VR53, <#[R7]> */
		/* 82061760h case  219:*/		cpu::mem::stvx( regs, regs.VR53, (uint32)(regs.R7 + 0x00000000) );
		/* 82061760h case  219:*/		return 0x82061764;
		  /* 82061764h */ case  220:  		/* vmrglw VR57, VR51, VR50 */
		/* 82061764h case  220:*/		cpu::op::vmrglw<0>(regs,&regs.VR57,regs.VR51,regs.VR50);
		/* 82061764h case  220:*/		return 0x82061768;
		  /* 82061768h */ case  221:  		/* addi R6, R1, 448 */
		/* 82061768h case  221:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x1C0);
		/* 82061768h case  221:*/		return 0x8206176C;
		  /* 8206176Ch */ case  222:  		/* vmrglw VR59, VR54, VR59 */
		/* 8206176Ch case  222:*/		cpu::op::vmrglw<0>(regs,&regs.VR59,regs.VR54,regs.VR59);
		/* 8206176Ch case  222:*/		return 0x82061770;
		  /* 82061770h */ case  223:  		/* rldicr R9, R8, 63, 63 */
		/* 82061770h case  223:*/		cpu::op::rldicr<0,63,63>(regs,&regs.R9,regs.R8);
		/* 82061770h case  223:*/		return 0x82061774;
		  /* 82061774h */ case  224:  		/* stvx VR49, <#[R11]> */
		/* 82061774h case  224:*/		cpu::mem::stvx( regs, regs.VR49, (uint32)(regs.R11 + 0x00000000) );
		/* 82061774h case  224:*/		return 0x82061778;
		  /* 82061778h */ case  225:  		/* addi R3, R1, 544 */
		/* 82061778h case  225:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x220);
		/* 82061778h case  225:*/		return 0x8206177C;
		  /* 8206177Ch */ case  226:  		/* addi R29, R1, 480 */
		/* 8206177Ch case  226:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R1,0x1E0);
		/* 8206177Ch case  226:*/		return 0x82061780;
		  /* 82061780h */ case  227:  		/* lwz R11, <#[R26 - 31240]> */
		/* 82061780h case  227:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0xFFFF85F8) );
		/* 82061780h case  227:*/		return 0x82061784;
		  /* 82061784h */ case  228:  		/* addi R28, R1, 560 */
		/* 82061784h case  228:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R1,0x230);
		/* 82061784h case  228:*/		return 0x82061788;
		  /* 82061788h */ case  229:  		/* lfs FR0, <#[R30]> */
		/* 82061788h case  229:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R30 + 0x00000000) );
		/* 82061788h case  229:*/		return 0x8206178C;
		  /* 8206178Ch */ case  230:  		/* addi R27, R1, 496 */
		/* 8206178Ch case  230:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R1,0x1F0);
		/* 8206178Ch case  230:*/		return 0x82061790;
		  /* 82061790h */ case  231:  		/* addi R10, R1, 576 */
		/* 82061790h case  231:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x240);
		/* 82061790h case  231:*/		return 0x82061794;
		  /* 82061794h */ case  232:  		/* vmaddfp VR0, VR0, VR9, VR13 */
		/* 82061794h case  232:*/		cpu::op::vmaddfp<0>(regs,&regs.VR0,regs.VR0,regs.VR9,regs.VR13);
		/* 82061794h case  232:*/		return 0x82061798;
		  /* 82061798h */ case  233:  		/* addi R8, R1, 512 */
		/* 82061798h case  233:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x200);
		/* 82061798h case  233:*/		return 0x8206179C;
		  /* 8206179Ch */ case  234:  		/* vmrghw VR58, VR7, VR12 */
		/* 8206179Ch case  234:*/		cpu::op::vmrghw<0>(regs,&regs.VR58,regs.VR7,regs.VR12);
		/* 8206179Ch case  234:*/		return 0x820617A0;
		  /* 820617A0h */ case  235:  		/* stvx VR57, <#[R4]> */
		/* 820617A0h case  235:*/		cpu::mem::stvx( regs, regs.VR57, (uint32)(regs.R4 + 0x00000000) );
		/* 820617A0h case  235:*/		return 0x820617A4;
		  /* 820617A4h */ case  236:  		/* vmrglw VR56, VR7, VR12 */
		/* 820617A4h case  236:*/		cpu::op::vmrglw<0>(regs,&regs.VR56,regs.VR7,regs.VR12);
		/* 820617A4h case  236:*/		return 0x820617A8;
		  /* 820617A8h */ case  237:  		/* vmrghw VR55, VR11, VR0 */
		/* 820617A8h case  237:*/		cpu::op::vmrghw<0>(regs,&regs.VR55,regs.VR11,regs.VR0);
		/* 820617A8h case  237:*/		return 0x820617AC;
		  /* 820617ACh */ case  238:  		/* vmrglw VR54, VR11, VR0 */
		/* 820617ACh case  238:*/		cpu::op::vmrglw<0>(regs,&regs.VR54,regs.VR11,regs.VR0);
		/* 820617ACh case  238:*/		return 0x820617B0;
		  /* 820617B0h */ case  239:  		/* vmrghw VR53, VR58, VR55 */
		/* 820617B0h case  239:*/		cpu::op::vmrghw<0>(regs,&regs.VR53,regs.VR58,regs.VR55);
		/* 820617B0h case  239:*/		return 0x820617B4;
		  /* 820617B4h */ case  240:  		/* vmrglw VR58, VR58, VR55 */
		/* 820617B4h case  240:*/		cpu::op::vmrglw<0>(regs,&regs.VR58,regs.VR58,regs.VR55);
		/* 820617B4h case  240:*/		return 0x820617B8;
		  /* 820617B8h */ case  241:  		/* vmrghw VR55, VR56, VR54 */
		/* 820617B8h case  241:*/		cpu::op::vmrghw<0>(regs,&regs.VR55,regs.VR56,regs.VR54);
		/* 820617B8h case  241:*/		return 0x820617BC;
		  /* 820617BCh */ case  242:  		/* vmrglw VR56, VR56, VR54 */
		/* 820617BCh case  242:*/		cpu::op::vmrglw<0>(regs,&regs.VR56,regs.VR56,regs.VR54);
		/* 820617BCh case  242:*/		return 0x820617C0;
		  /* 820617C0h */ case  243:  		/* addi R25, R1, 528 */
		/* 820617C0h case  243:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R1,0x210);
		/* 820617C0h case  243:*/		return 0x820617C4;
		  /* 820617C4h */ case  244:  		/* stvx VR60, <#[R3]> */
		/* 820617C4h case  244:*/		cpu::mem::stvx( regs, regs.VR60, (uint32)(regs.R3 + 0x00000000) );
		/* 820617C4h case  244:*/		return 0x820617C8;
		  /* 820617C8h */ case  245:  		/* addi R5, R1, 464 */
		/* 820617C8h case  245:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x1D0);
		/* 820617C8h case  245:*/		return 0x820617CC;
		  /* 820617CCh */ case  246:  		/* stvx VR52, <#[R6]> */
		/* 820617CCh case  246:*/		cpu::mem::stvx( regs, regs.VR52, (uint32)(regs.R6 + 0x00000000) );
		/* 820617CCh case  246:*/		return 0x820617D0;
		  /* 820617D0h */ case  247:  		/* addi R4, R1, 592 */
		/* 820617D0h case  247:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x250);
		/* 820617D0h case  247:*/		return 0x820617D4;
		  /* 820617D4h */ case  248:  		/* stvx VR61, <#[R10]> */
		/* 820617D4h case  248:*/		cpu::mem::stvx( regs, regs.VR61, (uint32)(regs.R10 + 0x00000000) );
		/* 820617D4h case  248:*/		return 0x820617D8;
		  /* 820617D8h */ case  249:  		/* stvx VR63, <#[R5]> */
		/* 820617D8h case  249:*/		cpu::mem::stvx( regs, regs.VR63, (uint32)(regs.R5 + 0x00000000) );
		/* 820617D8h case  249:*/		return 0x820617DC;
		  /* 820617DCh */ case  250:  		/* li R7, 1 */
		/* 820617DCh case  250:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 820617DCh case  250:*/		return 0x820617E0;
		  /* 820617E0h */ case  251:  		/* stvx VR59, <#[R4]> */
		/* 820617E0h case  251:*/		cpu::mem::stvx( regs, regs.VR59, (uint32)(regs.R4 + 0x00000000) );
		/* 820617E0h case  251:*/		return 0x820617E4;
		  /* 820617E4h */ case  252:  		/* li R6, 4 */
		/* 820617E4h case  252:*/		cpu::op::li<0>(regs,&regs.R6,0x4);
		/* 820617E4h case  252:*/		return 0x820617E8;
		  /* 820617E8h */ case  253:  		/* stvx VR62, <#[R28]> */
		/* 820617E8h case  253:*/		cpu::mem::stvx( regs, regs.VR62, (uint32)(regs.R28 + 0x00000000) );
		/* 820617E8h case  253:*/		return 0x820617EC;
		  /* 820617ECh */ case  254:  		/* rldicr R7, R7, 62, 63 */
		/* 820617ECh case  254:*/		cpu::op::rldicr<0,62,63>(regs,&regs.R7,regs.R7);
		/* 820617ECh case  254:*/		return 0x820617F0;
		  /* 820617F0h */ case  255:  		/* stvx VR53, <#[R29]> */
		/* 820617F0h case  255:*/		cpu::mem::stvx( regs, regs.VR53, (uint32)(regs.R29 + 0x00000000) );
		/* 820617F0h case  255:*/		return 0x820617F4;
		  /* 820617F4h */ case  256:  		/* addi R5, R1, 480 */
		/* 820617F4h case  256:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x1E0);
		/* 820617F4h case  256:*/		return 0x820617F8;
		  /* 820617F8h */ case  257:  		/* stvx VR58, <#[R27]> */
		/* 820617F8h case  257:*/		cpu::mem::stvx( regs, regs.VR58, (uint32)(regs.R27 + 0x00000000) );
		/* 820617F8h case  257:*/		return 0x820617FC;
		  /* 820617FCh */ case  258:  		/* li R4, 4 */
		/* 820617FCh case  258:*/		cpu::op::li<0>(regs,&regs.R4,0x4);
		/* 820617FCh case  258:*/		return 0x82061800;
		  /* 82061800h */ case  259:  		/* stvx VR55, <#[R8]> */
		/* 82061800h case  259:*/		cpu::mem::stvx( regs, regs.VR55, (uint32)(regs.R8 + 0x00000000) );
		/* 82061800h case  259:*/		return 0x82061804;
		  /* 82061804h */ case  260:  		/* stvx VR56, <#[R25]> */
		/* 82061804h case  260:*/		cpu::mem::stvx( regs, regs.VR56, (uint32)(regs.R25 + 0x00000000) );
		/* 82061804h case  260:*/		return 0x82061808;
		  /* 82061808h */ case  261:  		/* stfs FR0, <#[R11 + 1920]> */
		/* 82061808h case  261:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x00000780) );
		/* 82061808h case  261:*/		return 0x8206180C;
		  /* 8206180Ch */ case  262:  		/* lfs FR0, <#[R30 + 4]> */
		/* 8206180Ch case  262:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R30 + 0x00000004) );
		/* 8206180Ch case  262:*/		return 0x82061810;
		  /* 82061810h */ case  263:  		/* stfs FR0, <#[R11 + 1924]> */
		/* 82061810h case  263:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x00000784) );
		/* 82061810h case  263:*/		return 0x82061814;
		  /* 82061814h */ case  264:  		/* lfs FR0, <#[R30 + 8]> */
		/* 82061814h case  264:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R30 + 0x00000008) );
		/* 82061814h case  264:*/		return 0x82061818;
		  /* 82061818h */ case  265:  		/* stfs FR0, <#[R11 + 1928]> */
		/* 82061818h case  265:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x00000788) );
		/* 82061818h case  265:*/		return 0x8206181C;
		  /* 8206181Ch */ case  266:  		/* lfs FR0, <#[R30 + 12]> */
		/* 8206181Ch case  266:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R30 + 0x0000000C) );
		/* 8206181Ch case  266:*/		return 0x82061820;
		  /* 82061820h */ case  267:  		/* stfs FR0, <#[R11 + 1932]> */
		/* 82061820h case  267:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x0000078C) );
		/* 82061820h case  267:*/		return 0x82061824;
		  /* 82061824h */ case  268:  		/* ld R10, <#[R11]> */
		/* 82061824h case  268:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82061824h case  268:*/		return 0x82061828;
		  /* 82061828h */ case  269:  		/* or R10, R10, R9 */
		/* 82061828h case  269:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82061828h case  269:*/		return 0x8206182C;
		  /* 8206182Ch */ case  270:  		/* std R10, <#[R11]> */
		/* 8206182Ch case  270:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8206182Ch case  270:*/		return 0x82061830;
		  /* 82061830h */ case  271:  		/* lfs FR0, <#[R31]> */
		/* 82061830h case  271:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R31 + 0x00000000) );
		/* 82061830h case  271:*/		return 0x82061834;
		  /* 82061834h */ case  272:  		/* lwz R11, <#[R26 - 31240]> */
		/* 82061834h case  272:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0xFFFF85F8) );
		/* 82061834h case  272:*/		return 0x82061838;
		  /* 82061838h */ case  273:  		/* stfs FR0, <#[R11 + 1936]> */
		/* 82061838h case  273:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x00000790) );
		/* 82061838h case  273:*/		return 0x8206183C;
		  /* 8206183Ch */ case  274:  		/* lfs FR0, <#[R31 + 4]> */
		/* 8206183Ch case  274:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R31 + 0x00000004) );
		/* 8206183Ch case  274:*/		return 0x82061840;
		  /* 82061840h */ case  275:  		/* stfs FR0, <#[R11 + 1940]> */
		/* 82061840h case  275:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x00000794) );
		/* 82061840h case  275:*/		return 0x82061844;
		  /* 82061844h */ case  276:  		/* lfs FR0, <#[R31 + 8]> */
		/* 82061844h case  276:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R31 + 0x00000008) );
		/* 82061844h case  276:*/		return 0x82061848;
		  /* 82061848h */ case  277:  		/* stfs FR0, <#[R11 + 1944]> */
		/* 82061848h case  277:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x00000798) );
		/* 82061848h case  277:*/		return 0x8206184C;
		  /* 8206184Ch */ case  278:  		/* lfs FR0, <#[R31 + 12]> */
		/* 8206184Ch case  278:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R31 + 0x0000000C) );
		/* 8206184Ch case  278:*/		return 0x82061850;
		  /* 82061850h */ case  279:  		/* stfs FR0, <#[R11 + 1948]> */
		/* 82061850h case  279:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x0000079C) );
		/* 82061850h case  279:*/		return 0x82061854;
		  /* 82061854h */ case  280:  		/* ld R10, <#[R11]> */
		/* 82061854h case  280:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82061854h case  280:*/		return 0x82061858;
		  /* 82061858h */ case  281:  		/* or R10, R10, R9 */
		/* 82061858h case  281:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82061858h case  281:*/		return 0x8206185C;
		  /* 8206185Ch */ case  282:  		/* std R10, <#[R11]> */
		/* 8206185Ch case  282:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8206185Ch case  282:*/		return 0x82061860;
		  /* 82061860h */ case  283:  		/* lfs FR0, <#[R1 + 176]> */
		/* 82061860h case  283:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x000000B0) );
		/* 82061860h case  283:*/		return 0x82061864;
		  /* 82061864h */ case  284:  		/* lwz R11, <#[R26 - 31240]> */
		/* 82061864h case  284:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0xFFFF85F8) );
		/* 82061864h case  284:*/		return 0x82061868;
		  /* 82061868h */ case  285:  		/* stfs FR0, <#[R11 + 1952]> */
		/* 82061868h case  285:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x000007A0) );
		/* 82061868h case  285:*/		return 0x8206186C;
		  /* 8206186Ch */ case  286:  		/* lfs FR0, <#[R1 + 180]> */
		/* 8206186Ch case  286:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x000000B4) );
		/* 8206186Ch case  286:*/		return 0x82061870;
		  /* 82061870h */ case  287:  		/* stfs FR0, <#[R11 + 1956]> */
		/* 82061870h case  287:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x000007A4) );
		/* 82061870h case  287:*/		return 0x82061874;
		  /* 82061874h */ case  288:  		/* lfs FR0, <#[R1 + 184]> */
		/* 82061874h case  288:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x000000B8) );
		/* 82061874h case  288:*/		return 0x82061878;
		  /* 82061878h */ case  289:  		/* stfs FR0, <#[R11 + 1960]> */
		/* 82061878h case  289:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x000007A8) );
		/* 82061878h case  289:*/		return 0x8206187C;
		  /* 8206187Ch */ case  290:  		/* lfs FR0, <#[R1 + 188]> */
		/* 8206187Ch case  290:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x000000BC) );
		/* 8206187Ch case  290:*/		return 0x82061880;
		  /* 82061880h */ case  291:  		/* stfs FR0, <#[R11 + 1964]> */
		/* 82061880h case  291:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x000007AC) );
		/* 82061880h case  291:*/		return 0x82061884;
		  /* 82061884h */ case  292:  		/* ld R10, <#[R11]> */
		/* 82061884h case  292:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82061884h case  292:*/		return 0x82061888;
		  /* 82061888h */ case  293:  		/* or R10, R10, R9 */
		/* 82061888h case  293:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82061888h case  293:*/		return 0x8206188C;
		  /* 8206188Ch */ case  294:  		/* std R10, <#[R11]> */
		/* 8206188Ch case  294:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8206188Ch case  294:*/		return 0x82061890;
		  /* 82061890h */ case  295:  		/* lwz R3, <#[R26 - 31240]> */
		/* 82061890h case  295:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R26 + 0xFFFF85F8) );
		/* 82061890h case  295:*/		return 0x82061894;
		  /* 82061894h */ case  296:  		/* bl 29092 */
		/* 82061894h case  296:*/		regs.LR = 0x82061898; return 0x82068A38;
		/* 82061894h case  296:*/		return 0x82061898;
		  /* 82061898h */ case  297:  		/* li R7, 1 */
		/* 82061898h case  297:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 82061898h case  297:*/		return 0x8206189C;
		  /* 8206189Ch */ case  298:  		/* li R6, 4 */
		/* 8206189Ch case  298:*/		cpu::op::li<0>(regs,&regs.R6,0x4);
		/* 8206189Ch case  298:*/		return 0x820618A0;
		  /* 820618A0h */ case  299:  		/* lwz R3, <#[R26 - 31240]> */
		/* 820618A0h case  299:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R26 + 0xFFFF85F8) );
		/* 820618A0h case  299:*/		return 0x820618A4;
		  /* 820618A4h */ case  300:  		/* rldicr R7, R7, 61, 63 */
		/* 820618A4h case  300:*/		cpu::op::rldicr<0,61,63>(regs,&regs.R7,regs.R7);
		/* 820618A4h case  300:*/		return 0x820618A8;
		  /* 820618A8h */ case  301:  		/* addi R5, R1, 352 */
		/* 820618A8h case  301:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x160);
		/* 820618A8h case  301:*/		return 0x820618AC;
		  /* 820618ACh */ case  302:  		/* li R4, 8 */
		/* 820618ACh case  302:*/		cpu::op::li<0>(regs,&regs.R4,0x8);
		/* 820618ACh case  302:*/		return 0x820618B0;
		  /* 820618B0h */ case  303:  		/* bl 29064 */
		/* 820618B0h case  303:*/		regs.LR = 0x820618B4; return 0x82068A38;
		/* 820618B0h case  303:*/		return 0x820618B4;
		  /* 820618B4h */ case  304:  		/* li R7, 1 */
		/* 820618B4h case  304:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 820618B4h case  304:*/		return 0x820618B8;
		  /* 820618B8h */ case  305:  		/* li R6, 4 */
		/* 820618B8h case  305:*/		cpu::op::li<0>(regs,&regs.R6,0x4);
		/* 820618B8h case  305:*/		return 0x820618BC;
		  /* 820618BCh */ case  306:  		/* lwz R3, <#[R26 - 31240]> */
		/* 820618BCh case  306:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R26 + 0xFFFF85F8) );
		/* 820618BCh case  306:*/		return 0x820618C0;
		  /* 820618C0h */ case  307:  		/* rldicr R7, R7, 60, 63 */
		/* 820618C0h case  307:*/		cpu::op::rldicr<0,60,63>(regs,&regs.R7,regs.R7);
		/* 820618C0h case  307:*/		return 0x820618C4;
		  /* 820618C4h */ case  308:  		/* addi R5, R1, 416 */
		/* 820618C4h case  308:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x1A0);
		/* 820618C4h case  308:*/		return 0x820618C8;
		  /* 820618C8h */ case  309:  		/* li R4, 12 */
		/* 820618C8h case  309:*/		cpu::op::li<0>(regs,&regs.R4,0xC);
		/* 820618C8h case  309:*/		return 0x820618CC;
		  /* 820618CCh */ case  310:  		/* bl 29036 */
		/* 820618CCh case  310:*/		regs.LR = 0x820618D0; return 0x82068A38;
		/* 820618CCh case  310:*/		return 0x820618D0;
		  /* 820618D0h */ case  311:  		/* li R7, 1 */
		/* 820618D0h case  311:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 820618D0h case  311:*/		return 0x820618D4;
		  /* 820618D4h */ case  312:  		/* li R6, 4 */
		/* 820618D4h case  312:*/		cpu::op::li<0>(regs,&regs.R6,0x4);
		/* 820618D4h case  312:*/		return 0x820618D8;
		  /* 820618D8h */ case  313:  		/* lwz R3, <#[R26 - 31240]> */
		/* 820618D8h case  313:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R26 + 0xFFFF85F8) );
		/* 820618D8h case  313:*/		return 0x820618DC;
		  /* 820618DCh */ case  314:  		/* rldicr R7, R7, 59, 63 */
		/* 820618DCh case  314:*/		cpu::op::rldicr<0,59,63>(regs,&regs.R7,regs.R7);
		/* 820618DCh case  314:*/		return 0x820618E0;
		  /* 820618E0h */ case  315:  		/* addi R5, R1, 544 */
		/* 820618E0h case  315:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x220);
		/* 820618E0h case  315:*/		return 0x820618E4;
		  /* 820618E4h */ case  316:  		/* li R4, 16 */
		/* 820618E4h case  316:*/		cpu::op::li<0>(regs,&regs.R4,0x10);
		/* 820618E4h case  316:*/		return 0x820618E8;
		  /* 820618E8h */ case  317:  		/* bl 29008 */
		/* 820618E8h case  317:*/		regs.LR = 0x820618EC; return 0x82068A38;
		/* 820618E8h case  317:*/		return 0x820618EC;
		  /* 820618ECh */ case  318:  		/* li R11, 1 */
		/* 820618ECh case  318:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820618ECh case  318:*/		return 0x820618F0;
		  /* 820618F0h */ case  319:  		/* li R10, 1 */
		/* 820618F0h case  319:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820618F0h case  319:*/		return 0x820618F4;
		  /* 820618F4h */ case  320:  		/* rldicr R11, R11, 58, 63 */
		/* 820618F4h case  320:*/		cpu::op::rldicr<0,58,63>(regs,&regs.R11,regs.R11);
		/* 820618F4h case  320:*/		return 0x820618F8;
		  /* 820618F8h */ case  321:  		/* rldicr R10, R10, 57, 63 */
		/* 820618F8h case  321:*/		cpu::op::rldicr<0,57,63>(regs,&regs.R10,regs.R10);
		/* 820618F8h case  321:*/		return 0x820618FC;
		  /* 820618FCh */ case  322:  		/* mr R9, R11 */
		/* 820618FCh case  322:*/		regs.R9 = regs.R11;
		/* 820618FCh case  322:*/		return 0x82061900;
		  /* 82061900h */ case  323:  		/* mr R8, R11 */
		/* 82061900h case  323:*/		regs.R8 = regs.R11;
		/* 82061900h case  323:*/		return 0x82061904;
		  /* 82061904h */ case  324:  		/* mr R6, R11 */
		/* 82061904h case  324:*/		regs.R6 = regs.R11;
		/* 82061904h case  324:*/		return 0x82061908;
		  /* 82061908h */ case  325:  		/* lfs FR0, <#[R1 + 160]> */
		/* 82061908h case  325:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x000000A0) );
		/* 82061908h case  325:*/		return 0x8206190C;
		  /* 8206190Ch */ case  326:  		/* mr R7, R11 */
		/* 8206190Ch case  326:*/		regs.R7 = regs.R11;
		/* 8206190Ch case  326:*/		return 0x82061910;
		  /* 82061910h */ case  327:  		/* lwz R11, <#[R26 - 31240]> */
		/* 82061910h case  327:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0xFFFF85F8) );
		/* 82061910h case  327:*/		return 0x82061914;
		  /* 82061914h */ case  328:  		/* lfs FR13, <#[R1 + 164]> */
		/* 82061914h case  328:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R1 + 0x000000A4) );
		/* 82061914h case  328:*/		return 0x82061918;
		  /* 82061918h */ case  329:  		/* li R3, 0 */
		/* 82061918h case  329:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82061918h case  329:*/		return 0x8206191C;
		  /* 8206191Ch */ case  330:  		/* lfs FR12, <#[R1 + 168]> */
		/* 8206191Ch case  330:*/		cpu::mem::load32f( regs, &regs.FR12, (uint32)(regs.R1 + 0x000000A8) );
		/* 8206191Ch case  330:*/		return 0x82061920;
		  /* 82061920h */ case  331:  		/* lfs FR11, <#[R1 + 172]> */
		/* 82061920h case  331:*/		cpu::mem::load32f( regs, &regs.FR11, (uint32)(regs.R1 + 0x000000AC) );
		/* 82061920h case  331:*/		return 0x82061924;
		  /* 82061924h */ case  332:  		/* stfs FR13, <#[R11 + 2244]> */
		/* 82061924h case  332:*/		cpu::mem::store32f( regs, regs.FR13, (uint32)(regs.R11 + 0x000008C4) );
		/* 82061924h case  332:*/		return 0x82061928;
		  /* 82061928h */ case  333:  		/* stfs FR12, <#[R11 + 2248]> */
		/* 82061928h case  333:*/		cpu::mem::store32f( regs, regs.FR12, (uint32)(regs.R11 + 0x000008C8) );
		/* 82061928h case  333:*/		return 0x8206192C;
		  /* 8206192Ch */ case  334:  		/* stfs FR11, <#[R11 + 2252]> */
		/* 8206192Ch case  334:*/		cpu::mem::store32f( regs, regs.FR11, (uint32)(regs.R11 + 0x000008CC) );
		/* 8206192Ch case  334:*/		return 0x82061930;
		  /* 82061930h */ case  335:  		/* stfs FR0, <#[R11 + 2240]> */
		/* 82061930h case  335:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x000008C0) );
		/* 82061930h case  335:*/		return 0x82061934;
		  /* 82061934h */ case  336:  		/* ld R5, <#[R11]> */
		/* 82061934h case  336:*/		cpu::mem::load64( regs, &regs.R5, (uint32)(regs.R11 + 0x00000000) );
		/* 82061934h case  336:*/		return 0x82061938;
		  /* 82061938h */ case  337:  		/* or R9, R5, R9 */
		/* 82061938h case  337:*/		cpu::op::or<0>(regs,&regs.R9,regs.R5,regs.R9);
		/* 82061938h case  337:*/		return 0x8206193C;
		  /* 8206193Ch */ case  338:  		/* std R9, <#[R11]> */
		/* 8206193Ch case  338:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8206193Ch case  338:*/		return 0x82061940;
		  /* 82061940h */ case  339:  		/* lfs FR0, <#[R1 + 112]> */
		/* 82061940h case  339:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000070) );
		/* 82061940h case  339:*/		return 0x82061944;
		  /* 82061944h */ case  340:  		/* lwz R11, <#[R26 - 31240]> */
		/* 82061944h case  340:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0xFFFF85F8) );
		/* 82061944h case  340:*/		return 0x82061948;
	}
	return 0x82061948;
} // Block from 820613F4h-82061948h (341 instructions)

//////////////////////////////////////////////////////
// Block at 82061948h
// Function '?Render@Sample@@UAAJXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82061948( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82061948) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82061948);
		  /* 82061948h */ case    0:  		/* stfs FR0, <#[R11 + 2256]> */
		/* 82061948h case    0:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x000008D0) );
		/* 82061948h case    0:*/		return 0x8206194C;
		  /* 8206194Ch */ case    1:  		/* lfs FR0, <#[R1 + 116]> */
		/* 8206194Ch case    1:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000074) );
		/* 8206194Ch case    1:*/		return 0x82061950;
		  /* 82061950h */ case    2:  		/* stfs FR0, <#[R11 + 2260]> */
		/* 82061950h case    2:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x000008D4) );
		/* 82061950h case    2:*/		return 0x82061954;
		  /* 82061954h */ case    3:  		/* lfs FR0, <#[R1 + 120]> */
		/* 82061954h case    3:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000078) );
		/* 82061954h case    3:*/		return 0x82061958;
		  /* 82061958h */ case    4:  		/* stfs FR0, <#[R11 + 2264]> */
		/* 82061958h case    4:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x000008D8) );
		/* 82061958h case    4:*/		return 0x8206195C;
		  /* 8206195Ch */ case    5:  		/* lfs FR0, <#[R1 + 124]> */
		/* 8206195Ch case    5:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x0000007C) );
		/* 8206195Ch case    5:*/		return 0x82061960;
		  /* 82061960h */ case    6:  		/* stfs FR0, <#[R11 + 2268]> */
		/* 82061960h case    6:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x000008DC) );
		/* 82061960h case    6:*/		return 0x82061964;
		  /* 82061964h */ case    7:  		/* ld R9, <#[R11]> */
		/* 82061964h case    7:*/		cpu::mem::load64( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82061964h case    7:*/		return 0x82061968;
		  /* 82061968h */ case    8:  		/* or R9, R9, R6 */
		/* 82061968h case    8:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R6);
		/* 82061968h case    8:*/		return 0x8206196C;
		  /* 8206196Ch */ case    9:  		/* std R9, <#[R11]> */
		/* 8206196Ch case    9:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8206196Ch case    9:*/		return 0x82061970;
		  /* 82061970h */ case   10:  		/* lfs FR0, <#[R1 + 192]> */
		/* 82061970h case   10:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x000000C0) );
		/* 82061970h case   10:*/		return 0x82061974;
		  /* 82061974h */ case   11:  		/* lwz R11, <#[R26 - 31240]> */
		/* 82061974h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0xFFFF85F8) );
		/* 82061974h case   11:*/		return 0x82061978;
		  /* 82061978h */ case   12:  		/* stfs FR0, <#[R11 + 2272]> */
		/* 82061978h case   12:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x000008E0) );
		/* 82061978h case   12:*/		return 0x8206197C;
		  /* 8206197Ch */ case   13:  		/* lfs FR0, <#[R1 + 196]> */
		/* 8206197Ch case   13:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x000000C4) );
		/* 8206197Ch case   13:*/		return 0x82061980;
		  /* 82061980h */ case   14:  		/* stfs FR0, <#[R11 + 2276]> */
		/* 82061980h case   14:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x000008E4) );
		/* 82061980h case   14:*/		return 0x82061984;
		  /* 82061984h */ case   15:  		/* lfs FR0, <#[R1 + 200]> */
		/* 82061984h case   15:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x000000C8) );
		/* 82061984h case   15:*/		return 0x82061988;
		  /* 82061988h */ case   16:  		/* stfs FR0, <#[R11 + 2280]> */
		/* 82061988h case   16:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x000008E8) );
		/* 82061988h case   16:*/		return 0x8206198C;
		  /* 8206198Ch */ case   17:  		/* lfs FR0, <#[R1 + 204]> */
		/* 8206198Ch case   17:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x000000CC) );
		/* 8206198Ch case   17:*/		return 0x82061990;
		  /* 82061990h */ case   18:  		/* stfs FR0, <#[R11 + 2284]> */
		/* 82061990h case   18:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x000008EC) );
		/* 82061990h case   18:*/		return 0x82061994;
		  /* 82061994h */ case   19:  		/* ld R9, <#[R11]> */
		/* 82061994h case   19:*/		cpu::mem::load64( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82061994h case   19:*/		return 0x82061998;
		  /* 82061998h */ case   20:  		/* or R9, R9, R6 */
		/* 82061998h case   20:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R6);
		/* 82061998h case   20:*/		return 0x8206199C;
		  /* 8206199Ch */ case   21:  		/* std R9, <#[R11]> */
		/* 8206199Ch case   21:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8206199Ch case   21:*/		return 0x820619A0;
		  /* 820619A0h */ case   22:  		/* lfs FR0, <#[R1 + 144]> */
		/* 820619A0h case   22:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000090) );
		/* 820619A0h case   22:*/		return 0x820619A4;
		  /* 820619A4h */ case   23:  		/* lwz R11, <#[R26 - 31240]> */
		/* 820619A4h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0xFFFF85F8) );
		/* 820619A4h case   23:*/		return 0x820619A8;
		  /* 820619A8h */ case   24:  		/* stfs FR0, <#[R11 + 2288]> */
		/* 820619A8h case   24:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x000008F0) );
		/* 820619A8h case   24:*/		return 0x820619AC;
		  /* 820619ACh */ case   25:  		/* lfs FR0, <#[R1 + 148]> */
		/* 820619ACh case   25:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000094) );
		/* 820619ACh case   25:*/		return 0x820619B0;
		  /* 820619B0h */ case   26:  		/* stfs FR0, <#[R11 + 2292]> */
		/* 820619B0h case   26:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x000008F4) );
		/* 820619B0h case   26:*/		return 0x820619B4;
		  /* 820619B4h */ case   27:  		/* lfs FR0, <#[R1 + 152]> */
		/* 820619B4h case   27:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000098) );
		/* 820619B4h case   27:*/		return 0x820619B8;
		  /* 820619B8h */ case   28:  		/* stfs FR0, <#[R11 + 2296]> */
		/* 820619B8h case   28:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x000008F8) );
		/* 820619B8h case   28:*/		return 0x820619BC;
		  /* 820619BCh */ case   29:  		/* lfs FR0, <#[R1 + 156]> */
		/* 820619BCh case   29:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x0000009C) );
		/* 820619BCh case   29:*/		return 0x820619C0;
		  /* 820619C0h */ case   30:  		/* stfs FR0, <#[R11 + 2300]> */
		/* 820619C0h case   30:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x000008FC) );
		/* 820619C0h case   30:*/		return 0x820619C4;
		  /* 820619C4h */ case   31:  		/* ld R9, <#[R11]> */
		/* 820619C4h case   31:*/		cpu::mem::load64( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820619C4h case   31:*/		return 0x820619C8;
		  /* 820619C8h */ case   32:  		/* or R9, R9, R6 */
		/* 820619C8h case   32:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R6);
		/* 820619C8h case   32:*/		return 0x820619CC;
		  /* 820619CCh */ case   33:  		/* std R9, <#[R11]> */
		/* 820619CCh case   33:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820619CCh case   33:*/		return 0x820619D0;
		  /* 820619D0h */ case   34:  		/* lfs FR0, <#[R1 + 128]> */
		/* 820619D0h case   34:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000080) );
		/* 820619D0h case   34:*/		return 0x820619D4;
		  /* 820619D4h */ case   35:  		/* lwz R11, <#[R26 - 31240]> */
		/* 820619D4h case   35:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0xFFFF85F8) );
		/* 820619D4h case   35:*/		return 0x820619D8;
		  /* 820619D8h */ case   36:  		/* stfs FR0, <#[R11 + 2304]> */
		/* 820619D8h case   36:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x00000900) );
		/* 820619D8h case   36:*/		return 0x820619DC;
		  /* 820619DCh */ case   37:  		/* lfs FR0, <#[R1 + 132]> */
		/* 820619DCh case   37:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000084) );
		/* 820619DCh case   37:*/		return 0x820619E0;
		  /* 820619E0h */ case   38:  		/* stfs FR0, <#[R11 + 2308]> */
		/* 820619E0h case   38:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x00000904) );
		/* 820619E0h case   38:*/		return 0x820619E4;
		  /* 820619E4h */ case   39:  		/* lfs FR0, <#[R1 + 136]> */
		/* 820619E4h case   39:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000088) );
		/* 820619E4h case   39:*/		return 0x820619E8;
		  /* 820619E8h */ case   40:  		/* stfs FR0, <#[R11 + 2312]> */
		/* 820619E8h case   40:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x00000908) );
		/* 820619E8h case   40:*/		return 0x820619EC;
		  /* 820619ECh */ case   41:  		/* lfs FR0, <#[R1 + 140]> */
		/* 820619ECh case   41:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x0000008C) );
		/* 820619ECh case   41:*/		return 0x820619F0;
		  /* 820619F0h */ case   42:  		/* stfs FR0, <#[R11 + 2316]> */
		/* 820619F0h case   42:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x0000090C) );
		/* 820619F0h case   42:*/		return 0x820619F4;
		  /* 820619F4h */ case   43:  		/* ld R9, <#[R11]> */
		/* 820619F4h case   43:*/		cpu::mem::load64( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820619F4h case   43:*/		return 0x820619F8;
		  /* 820619F8h */ case   44:  		/* or R9, R9, R10 */
		/* 820619F8h case   44:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 820619F8h case   44:*/		return 0x820619FC;
		  /* 820619FCh */ case   45:  		/* std R9, <#[R11]> */
		/* 820619FCh case   45:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820619FCh case   45:*/		return 0x82061A00;
		  /* 82061A00h */ case   46:  		/* lfs FR0, <#[R1 + 208]> */
		/* 82061A00h case   46:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x000000D0) );
		/* 82061A00h case   46:*/		return 0x82061A04;
		  /* 82061A04h */ case   47:  		/* lwz R11, <#[R26 - 31240]> */
		/* 82061A04h case   47:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0xFFFF85F8) );
		/* 82061A04h case   47:*/		return 0x82061A08;
		  /* 82061A08h */ case   48:  		/* stfs FR0, <#[R11 + 2320]> */
		/* 82061A08h case   48:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x00000910) );
		/* 82061A08h case   48:*/		return 0x82061A0C;
		  /* 82061A0Ch */ case   49:  		/* lfs FR0, <#[R1 + 212]> */
		/* 82061A0Ch case   49:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x000000D4) );
		/* 82061A0Ch case   49:*/		return 0x82061A10;
		  /* 82061A10h */ case   50:  		/* stfs FR0, <#[R11 + 2324]> */
		/* 82061A10h case   50:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x00000914) );
		/* 82061A10h case   50:*/		return 0x82061A14;
		  /* 82061A14h */ case   51:  		/* lfs FR0, <#[R1 + 216]> */
		/* 82061A14h case   51:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x000000D8) );
		/* 82061A14h case   51:*/		return 0x82061A18;
		  /* 82061A18h */ case   52:  		/* stfs FR0, <#[R11 + 2328]> */
		/* 82061A18h case   52:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x00000918) );
		/* 82061A18h case   52:*/		return 0x82061A1C;
		  /* 82061A1Ch */ case   53:  		/* lfs FR0, <#[R1 + 220]> */
		/* 82061A1Ch case   53:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x000000DC) );
		/* 82061A1Ch case   53:*/		return 0x82061A20;
		  /* 82061A20h */ case   54:  		/* stfs FR0, <#[R11 + 2332]> */
		/* 82061A20h case   54:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x0000091C) );
		/* 82061A20h case   54:*/		return 0x82061A24;
		  /* 82061A24h */ case   55:  		/* ld R9, <#[R11]> */
		/* 82061A24h case   55:*/		cpu::mem::load64( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82061A24h case   55:*/		return 0x82061A28;
		  /* 82061A28h */ case   56:  		/* or R10, R9, R10 */
		/* 82061A28h case   56:*/		cpu::op::or<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82061A28h case   56:*/		return 0x82061A2C;
		  /* 82061A2Ch */ case   57:  		/* std R10, <#[R11]> */
		/* 82061A2Ch case   57:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82061A2Ch case   57:*/		return 0x82061A30;
		  /* 82061A30h */ case   58:  		/* addi R1, R1, 816 */
		/* 82061A30h case   58:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x330);
		/* 82061A30h case   58:*/		return 0x82061A34;
		  /* 82061A34h */ case   59:  		/* addi R12, R1, -112 */
		/* 82061A34h case   59:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R1,0xFFFFFF90);
		/* 82061A34h case   59:*/		return 0x82061A38;
		  /* 82061A38h */ case   60:  		/* bl 196420 */
		/* 82061A38h case   60:*/		regs.LR = 0x82061A3C; return 0x8209197C;
		/* 82061A38h case   60:*/		return 0x82061A3C;
		  /* 82061A3Ch */ case   61:  		/* addi R12, R1, -64 */
		/* 82061A3Ch case   61:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R1,0xFFFFFFC0);
		/* 82061A3Ch case   61:*/		return 0x82061A40;
		  /* 82061A40h */ case   62:  		/* bl 195104 */
		/* 82061A40h case   62:*/		regs.LR = 0x82061A44; return 0x82091460;
		/* 82061A40h case   62:*/		return 0x82061A44;
		  /* 82061A44h */ case   63:  		/* b 194648 */
		/* 82061A44h case   63:*/		return 0x8209129C;
		/* 82061A44h case   63:*/		return 0x82061A48;
	}
	return 0x82061A48;
} // Block from 82061948h-82061A48h (64 instructions)

//////////////////////////////////////////////////////
// Block at 82061A48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82061A48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82061A48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82061A48);
		  /* 82061A48h */ case    0:  		/* mfspr R12, LR */
		/* 82061A48h case    0:*/		regs.R12 = regs.LR;
		/* 82061A48h case    0:*/		return 0x82061A4C;
		  /* 82061A4Ch */ case    1:  		/* bl 194564 */
		/* 82061A4Ch case    1:*/		regs.LR = 0x82061A50; return 0x82091250;
		/* 82061A4Ch case    1:*/		return 0x82061A50;
		  /* 82061A50h */ case    2:  		/* stfd FR29, <#[R1 - 80]> */
		/* 82061A50h case    2:*/		cpu::mem::store64f( regs, regs.FR29, (uint32)(regs.R1 + 0xFFFFFFB0) );
		/* 82061A50h case    2:*/		return 0x82061A54;
		  /* 82061A54h */ case    3:  		/* stfd FR30, <#[R1 - 72]> */
		/* 82061A54h case    3:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R1 + 0xFFFFFFB8) );
		/* 82061A54h case    3:*/		return 0x82061A58;
		  /* 82061A58h */ case    4:  		/* stfd FR31, <#[R1 - 64]> */
		/* 82061A58h case    4:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFC0) );
		/* 82061A58h case    4:*/		return 0x82061A5C;
		  /* 82061A5Ch */ case    5:  		/* stwu R1, <#[R1 - 336]> */
		/* 82061A5Ch case    5:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEB0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEB0);
		/* 82061A5Ch case    5:*/		return 0x82061A60;
		  /* 82061A60h */ case    6:  		/* lis R11, -32256 */
		/* 82061A60h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82061A60h case    6:*/		return 0x82061A64;
		  /* 82061A64h */ case    7:  		/* lis R27, -32215 */
		/* 82061A64h case    7:*/		cpu::op::lis<0>(regs,&regs.R27,0xFFFF8229);
		/* 82061A64h case    7:*/		return 0x82061A68;
		  /* 82061A68h */ case    8:  		/* li R10, 0 */
		/* 82061A68h case    8:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82061A68h case    8:*/		return 0x82061A6C;
		  /* 82061A6Ch */ case    9:  		/* li R9, 0 */
		/* 82061A6Ch case    9:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82061A6Ch case    9:*/		return 0x82061A70;
		  /* 82061A70h */ case   10:  		/* li R7, 16512 */
		/* 82061A70h case   10:*/		cpu::op::li<0>(regs,&regs.R7,0x4080);
		/* 82061A70h case   10:*/		return 0x82061A74;
		  /* 82061A74h */ case   11:  		/* lfs FR30, <#[R11 + 1792]> */
		/* 82061A74h case   11:*/		cpu::mem::load32f( regs, &regs.FR30, (uint32)(regs.R11 + 0x00000700) );
		/* 82061A74h case   11:*/		return 0x82061A78;
		  /* 82061A78h */ case   12:  		/* li R6, 63 */
		/* 82061A78h case   12:*/		cpu::op::li<0>(regs,&regs.R6,0x3F);
		/* 82061A78h case   12:*/		return 0x82061A7C;
		  /* 82061A7Ch */ case   13:  		/* li R5, 0 */
		/* 82061A7Ch case   13:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82061A7Ch case   13:*/		return 0x82061A80;
		  /* 82061A80h */ case   14:  		/* fmr FR1, FR30 */
		/* 82061A80h case   14:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR30);
		/* 82061A80h case   14:*/		return 0x82061A84;
		  /* 82061A84h */ case   15:  		/* li R4, 0 */
		/* 82061A84h case   15:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82061A84h case   15:*/		return 0x82061A88;
		  /* 82061A88h */ case   16:  		/* mr R31, R3 */
		/* 82061A88h case   16:*/		regs.R31 = regs.R3;
		/* 82061A88h case   16:*/		return 0x82061A8C;
		  /* 82061A8Ch */ case   17:  		/* lwz R3, <#[R27 - 31240]> */
		/* 82061A8Ch case   17:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0xFFFF85F8) );
		/* 82061A8Ch case   17:*/		return 0x82061A90;
		  /* 82061A90h */ case   18:  		/* bl 61000 */
		/* 82061A90h case   18:*/		regs.LR = 0x82061A94; return 0x820708D8;
		/* 82061A90h case   18:*/		return 0x82061A94;
		  /* 82061A94h */ case   19:  		/* li R4, 1 */
		/* 82061A94h case   19:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82061A94h case   19:*/		return 0x82061A98;
		  /* 82061A98h */ case   20:  		/* lwz R3, <#[R27 - 31240]> */
		/* 82061A98h case   20:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0xFFFF85F8) );
		/* 82061A98h case   20:*/		return 0x82061A9C;
		  /* 82061A9Ch */ case   21:  		/* bl 3868 */
		/* 82061A9Ch case   21:*/		regs.LR = 0x82061AA0; return 0x820629B8;
		/* 82061A9Ch case   21:*/		return 0x82061AA0;
		  /* 82061AA0h */ case   22:  		/* li R4, 0 */
		/* 82061AA0h case   22:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82061AA0h case   22:*/		return 0x82061AA4;
		  /* 82061AA4h */ case   23:  		/* lwz R3, <#[R27 - 31240]> */
		/* 82061AA4h case   23:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0xFFFF85F8) );
		/* 82061AA4h case   23:*/		return 0x82061AA8;
		  /* 82061AA8h */ case   24:  		/* bl 2176 */
		/* 82061AA8h case   24:*/		regs.LR = 0x82061AAC; return 0x82062328;
		/* 82061AA8h case   24:*/		return 0x82061AAC;
		  /* 82061AACh */ case   25:  		/* li R5, 1 */
		/* 82061AACh case   25:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82061AACh case   25:*/		return 0x82061AB0;
		  /* 82061AB0h */ case   26:  		/* li R4, 0 */
		/* 82061AB0h case   26:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82061AB0h case   26:*/		return 0x82061AB4;
		  /* 82061AB4h */ case   27:  		/* lwz R3, <#[R27 - 31240]> */
		/* 82061AB4h case   27:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0xFFFF85F8) );
		/* 82061AB4h case   27:*/		return 0x82061AB8;
		  /* 82061AB8h */ case   28:  		/* bl 8312 */
		/* 82061AB8h case   28:*/		regs.LR = 0x82061ABC; return 0x82063B30;
		/* 82061AB8h case   28:*/		return 0x82061ABC;
		  /* 82061ABCh */ case   29:  		/* li R5, 1 */
		/* 82061ABCh case   29:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82061ABCh case   29:*/		return 0x82061AC0;
		  /* 82061AC0h */ case   30:  		/* li R4, 0 */
		/* 82061AC0h case   30:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82061AC0h case   30:*/		return 0x82061AC4;
		  /* 82061AC4h */ case   31:  		/* lwz R3, <#[R27 - 31240]> */
		/* 82061AC4h case   31:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0xFFFF85F8) );
		/* 82061AC4h case   31:*/		return 0x82061AC8;
		  /* 82061AC8h */ case   32:  		/* bl 8720 */
		/* 82061AC8h case   32:*/		regs.LR = 0x82061ACC; return 0x82063CD8;
		/* 82061AC8h case   32:*/		return 0x82061ACC;
		  /* 82061ACCh */ case   33:  		/* lwz R11, <#[R27 - 31240]> */
		/* 82061ACCh case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFF85F8) );
		/* 82061ACCh case   33:*/		return 0x82061AD0;
		  /* 82061AD0h */ case   34:  		/* li R10, 1 */
		/* 82061AD0h case   34:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82061AD0h case   34:*/		return 0x82061AD4;
		  /* 82061AD4h */ case   35:  		/* mr R9, R11 */
		/* 82061AD4h case   35:*/		regs.R9 = regs.R11;
		/* 82061AD4h case   35:*/		return 0x82061AD8;
		  /* 82061AD8h */ case   36:  		/* li R5, 1 */
		/* 82061AD8h case   36:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82061AD8h case   36:*/		return 0x82061ADC;
		  /* 82061ADCh */ case   37:  		/* li R4, 1 */
		/* 82061ADCh case   37:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82061ADCh case   37:*/		return 0x82061AE0;
		  /* 82061AE0h */ case   38:  		/* lwz R8, <#[R11 + 1164]> */
		/* 82061AE0h case   38:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x0000048C) );
		/* 82061AE0h case   38:*/		return 0x82061AE4;
		  /* 82061AE4h */ case   39:  		/* rlwinm R8, R8, 0, 9, 6 */
		/* 82061AE4h case   39:*/		cpu::op::rlwinm<0,0,9,6>(regs,&regs.R8,regs.R8);
		/* 82061AE4h case   39:*/		return 0x82061AE8;
		  /* 82061AE8h */ case   40:  		/* stw R8, <#[R11 + 1164]> */
		/* 82061AE8h case   40:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x0000048C) );
		/* 82061AE8h case   40:*/		return 0x82061AEC;
		  /* 82061AECh */ case   41:  		/* ld R11, <#[R11 + 24]> */
		/* 82061AECh case   41:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 82061AECh case   41:*/		return 0x82061AF0;
		  /* 82061AF0h */ case   42:  		/* oris R11, R11, 32768 */
		/* 82061AF0h case   42:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8000);
		/* 82061AF0h case   42:*/		return 0x82061AF4;
		  /* 82061AF4h */ case   43:  		/* std R11, <#[R9 + 24]> */
		/* 82061AF4h case   43:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R9 + 0x00000018) );
		/* 82061AF4h case   43:*/		return 0x82061AF8;
		  /* 82061AF8h */ case   44:  		/* lwz R11, <#[R27 - 31240]> */
		/* 82061AF8h case   44:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFF85F8) );
		/* 82061AF8h case   44:*/		return 0x82061AFC;
		  /* 82061AFCh */ case   45:  		/* mr R9, R11 */
		/* 82061AFCh case   45:*/		regs.R9 = regs.R11;
		/* 82061AFCh case   45:*/		return 0x82061B00;
		  /* 82061B00h */ case   46:  		/* lwz R8, <#[R11 + 1152]> */
		/* 82061B00h case   46:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000480) );
		/* 82061B00h case   46:*/		return 0x82061B04;
		  /* 82061B04h */ case   47:  		/* rlwimi R8, R10, 10, 19, 21 */
		/* 82061B04h case   47:*/		cpu::op::rlwimi<0,10,19,21>(regs,&regs.R8,regs.R10);
		/* 82061B04h case   47:*/		return 0x82061B08;
		  /* 82061B08h */ case   48:  		/* stw R8, <#[R11 + 1152]> */
		/* 82061B08h case   48:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000480) );
		/* 82061B08h case   48:*/		return 0x82061B0C;
		  /* 82061B0Ch */ case   49:  		/* ld R11, <#[R11 + 24]> */
		/* 82061B0Ch case   49:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 82061B0Ch case   49:*/		return 0x82061B10;
		  /* 82061B10h */ case   50:  		/* oris R11, R11, 32768 */
		/* 82061B10h case   50:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8000);
		/* 82061B10h case   50:*/		return 0x82061B14;
		  /* 82061B14h */ case   51:  		/* std R11, <#[R9 + 24]> */
		/* 82061B14h case   51:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R9 + 0x00000018) );
		/* 82061B14h case   51:*/		return 0x82061B18;
		  /* 82061B18h */ case   52:  		/* lwz R11, <#[R27 - 31240]> */
		/* 82061B18h case   52:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFF85F8) );
		/* 82061B18h case   52:*/		return 0x82061B1C;
		  /* 82061B1Ch */ case   53:  		/* mr R9, R11 */
		/* 82061B1Ch case   53:*/		regs.R9 = regs.R11;
		/* 82061B1Ch case   53:*/		return 0x82061B20;
		  /* 82061B20h */ case   54:  		/* lwz R8, <#[R11 + 1152]> */
		/* 82061B20h case   54:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000480) );
		/* 82061B20h case   54:*/		return 0x82061B24;
		  /* 82061B24h */ case   55:  		/* rlwimi R8, R10, 13, 16, 18 */
		/* 82061B24h case   55:*/		cpu::op::rlwimi<0,13,16,18>(regs,&regs.R8,regs.R10);
		/* 82061B24h case   55:*/		return 0x82061B28;
		  /* 82061B28h */ case   56:  		/* stw R8, <#[R11 + 1152]> */
		/* 82061B28h case   56:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000480) );
		/* 82061B28h case   56:*/		return 0x82061B2C;
		  /* 82061B2Ch */ case   57:  		/* ld R11, <#[R11 + 24]> */
		/* 82061B2Ch case   57:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 82061B2Ch case   57:*/		return 0x82061B30;
		  /* 82061B30h */ case   58:  		/* oris R11, R11, 32768 */
		/* 82061B30h case   58:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8000);
		/* 82061B30h case   58:*/		return 0x82061B34;
		  /* 82061B34h */ case   59:  		/* std R11, <#[R9 + 24]> */
		/* 82061B34h case   59:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R9 + 0x00000018) );
		/* 82061B34h case   59:*/		return 0x82061B38;
		  /* 82061B38h */ case   60:  		/* lwz R3, <#[R27 - 31240]> */
		/* 82061B38h case   60:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0xFFFF85F8) );
		/* 82061B38h case   60:*/		return 0x82061B3C;
		  /* 82061B3Ch */ case   61:  		/* bl 8180 */
		/* 82061B3Ch case   61:*/		regs.LR = 0x82061B40; return 0x82063B30;
		/* 82061B3Ch case   61:*/		return 0x82061B40;
		  /* 82061B40h */ case   62:  		/* li R5, 1 */
		/* 82061B40h case   62:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82061B40h case   62:*/		return 0x82061B44;
		  /* 82061B44h */ case   63:  		/* li R4, 1 */
		/* 82061B44h case   63:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82061B44h case   63:*/		return 0x82061B48;
		  /* 82061B48h */ case   64:  		/* lwz R3, <#[R27 - 31240]> */
		/* 82061B48h case   64:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0xFFFF85F8) );
		/* 82061B48h case   64:*/		return 0x82061B4C;
		  /* 82061B4Ch */ case   65:  		/* bl 8588 */
		/* 82061B4Ch case   65:*/		regs.LR = 0x82061B50; return 0x82063CD8;
		/* 82061B4Ch case   65:*/		return 0x82061B50;
		  /* 82061B50h */ case   66:  		/* lwz R11, <#[R27 - 31240]> */
		/* 82061B50h case   66:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFF85F8) );
		/* 82061B50h case   66:*/		return 0x82061B54;
		  /* 82061B54h */ case   67:  		/* addi R10, R11, 24 */
		/* 82061B54h case   67:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x18);
		/* 82061B54h case   67:*/		return 0x82061B58;
		  /* 82061B58h */ case   68:  		/* lwz R10, <#[R11 + 1188]> */
		/* 82061B58h case   68:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x000004A4) );
		/* 82061B58h case   68:*/		return 0x82061B5C;
		  /* 82061B5Ch */ case   69:  		/* rlwinm R10, R10, 0, 9, 6 */
		/* 82061B5Ch case   69:*/		cpu::op::rlwinm<0,0,9,6>(regs,&regs.R10,regs.R10);
		/* 82061B5Ch case   69:*/		return 0x82061B60;
		  /* 82061B60h */ case   70:  		/* stw R10, <#[R11 + 1188]> */
		/* 82061B60h case   70:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x000004A4) );
		/* 82061B60h case   70:*/		return 0x82061B64;
		  /* 82061B64h */ case   71:  		/* ld R10, <#[R11 + 24]> */
		/* 82061B64h case   71:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R11 + 0x00000018) );
		/* 82061B64h case   71:*/		return 0x82061B68;
		  /* 82061B68h */ case   72:  		/* oris R10, R10, 16384 */
		/* 82061B68h case   72:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x4000);
		/* 82061B68h case   72:*/		return 0x82061B6C;
		  /* 82061B6Ch */ case   73:  		/* std R10, <#[R11 + 24]> */
		/* 82061B6Ch case   73:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R11 + 0x00000018) );
		/* 82061B6Ch case   73:*/		return 0x82061B70;
		  /* 82061B70h */ case   74:  		/* lwz R11, <#[R27 - 31240]> */
		/* 82061B70h case   74:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFF85F8) );
		/* 82061B70h case   74:*/		return 0x82061B74;
		  /* 82061B74h */ case   75:  		/* mr R10, R11 */
		/* 82061B74h case   75:*/		regs.R10 = regs.R11;
		/* 82061B74h case   75:*/		return 0x82061B78;
		  /* 82061B78h */ case   76:  		/* lwz R9, <#[R11 + 1176]> */
		/* 82061B78h case   76:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000498) );
		/* 82061B78h case   76:*/		return 0x82061B7C;
		  /* 82061B7Ch */ case   77:  		/* rlwinm R9, R9, 0, 22, 18 */
		/* 82061B7Ch case   77:*/		cpu::op::rlwinm<0,0,22,18>(regs,&regs.R9,regs.R9);
		/* 82061B7Ch case   77:*/		return 0x82061B80;
		  /* 82061B80h */ case   78:  		/* stw R9, <#[R11 + 1176]> */
		/* 82061B80h case   78:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000498) );
		/* 82061B80h case   78:*/		return 0x82061B84;
		  /* 82061B84h */ case   79:  		/* ld R11, <#[R11 + 24]> */
		/* 82061B84h case   79:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 82061B84h case   79:*/		return 0x82061B88;
		  /* 82061B88h */ case   80:  		/* oris R11, R11, 16384 */
		/* 82061B88h case   80:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x4000);
		/* 82061B88h case   80:*/		return 0x82061B8C;
		  /* 82061B8Ch */ case   81:  		/* std R11, <#[R10 + 24]> */
		/* 82061B8Ch case   81:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R10 + 0x00000018) );
		/* 82061B8Ch case   81:*/		return 0x82061B90;
		  /* 82061B90h */ case   82:  		/* lwz R11, <#[R27 - 31240]> */
		/* 82061B90h case   82:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFF85F8) );
		/* 82061B90h case   82:*/		return 0x82061B94;
		  /* 82061B94h */ case   83:  		/* mr R10, R11 */
		/* 82061B94h case   83:*/		regs.R10 = regs.R11;
		/* 82061B94h case   83:*/		return 0x82061B98;
		  /* 82061B98h */ case   84:  		/* lwz R9, <#[R11 + 1176]> */
		/* 82061B98h case   84:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000498) );
		/* 82061B98h case   84:*/		return 0x82061B9C;
		  /* 82061B9Ch */ case   85:  		/* rlwinm R9, R9, 0, 19, 15 */
		/* 82061B9Ch case   85:*/		cpu::op::rlwinm<0,0,19,15>(regs,&regs.R9,regs.R9);
		/* 82061B9Ch case   85:*/		return 0x82061BA0;
		  /* 82061BA0h */ case   86:  		/* stw R9, <#[R11 + 1176]> */
		/* 82061BA0h case   86:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000498) );
		/* 82061BA0h case   86:*/		return 0x82061BA4;
		  /* 82061BA4h */ case   87:  		/* ld R11, <#[R11 + 24]> */
		/* 82061BA4h case   87:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 82061BA4h case   87:*/		return 0x82061BA8;
		  /* 82061BA8h */ case   88:  		/* oris R11, R11, 16384 */
		/* 82061BA8h case   88:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x4000);
		/* 82061BA8h case   88:*/		return 0x82061BAC;
		  /* 82061BACh */ case   89:  		/* std R11, <#[R10 + 24]> */
		/* 82061BACh case   89:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R10 + 0x00000018) );
		/* 82061BACh case   89:*/		return 0x82061BB0;
		  /* 82061BB0h */ case   90:  		/* lwz R4, <#[R31 + 804]> */
		/* 82061BB0h case   90:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000324) );
		/* 82061BB0h case   90:*/		return 0x82061BB4;
		  /* 82061BB4h */ case   91:  		/* lwz R3, <#[R27 - 31240]> */
		/* 82061BB4h case   91:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0xFFFF85F8) );
		/* 82061BB4h case   91:*/		return 0x82061BB8;
		  /* 82061BB8h */ case   92:  		/* bl 188952 */
		/* 82061BB8h case   92:*/		regs.LR = 0x82061BBC; return 0x8208FDD0;
		/* 82061BB8h case   92:*/		return 0x82061BBC;
		  /* 82061BBCh */ case   93:  		/* li R11, 1 */
		/* 82061BBCh case   93:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82061BBCh case   93:*/		return 0x82061BC0;
		  /* 82061BC0h */ case   94:  		/* rldicr R11, R11, 63, 63 */
		/* 82061BC0h case   94:*/		cpu::op::rldicr<0,63,63>(regs,&regs.R11,regs.R11);
		/* 82061BC0h case   94:*/		return 0x82061BC4;
		  /* 82061BC4h */ case   95:  		/* lwz R10, <#[R27 - 31240]> */
		/* 82061BC4h case   95:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0xFFFF85F8) );
		/* 82061BC4h case   95:*/		return 0x82061BC8;
		  /* 82061BC8h */ case   96:  		/* lis R9, -32256 */
		/* 82061BC8h case   96:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 82061BC8h case   96:*/		return 0x82061BCC;
		  /* 82061BCCh */ case   97:  		/* lis R8, -32256 */
		/* 82061BCCh case   97:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8200);
		/* 82061BCCh case   97:*/		return 0x82061BD0;
		  /* 82061BD0h */ case   98:  		/* mr R5, R11 */
		/* 82061BD0h case   98:*/		regs.R5 = regs.R11;
		/* 82061BD0h case   98:*/		return 0x82061BD4;
		  /* 82061BD4h */ case   99:  		/* addi R9, R9, 1776 */
		/* 82061BD4h case   99:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x6F0);
		/* 82061BD4h case   99:*/		return 0x82061BD8;
		  /* 82061BD8h */ case  100:  		/* mr R7, R11 */
		/* 82061BD8h case  100:*/		regs.R7 = regs.R11;
		/* 82061BD8h case  100:*/		return 0x82061BDC;
		  /* 82061BDCh */ case  101:  		/* lwz R11, <#[R27 - 31240]> */
		/* 82061BDCh case  101:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFF85F8) );
		/* 82061BDCh case  101:*/		return 0x82061BE0;
		  /* 82061BE0h */ case  102:  		/* lis R3, -32217 */
		/* 82061BE0h case  102:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8227);
		/* 82061BE0h case  102:*/		return 0x82061BE4;
		  /* 82061BE4h */ case  103:  		/* lfs FR31, <#[R8 + 1816]> */
		/* 82061BE4h case  103:*/		cpu::mem::load32f( regs, &regs.FR31, (uint32)(regs.R8 + 0x00000718) );
		/* 82061BE4h case  103:*/		return 0x82061BE8;
		  /* 82061BE8h */ case  104:  		/* lis R6, 16384 */
		/* 82061BE8h case  104:*/		cpu::op::lis<0>(regs,&regs.R6,0x4000);
		/* 82061BE8h case  104:*/		return 0x82061BEC;
		  /* 82061BECh */ case  105:  		/* stfs FR31, <#[R10 + 6016]> */
		/* 82061BECh case  105:*/		cpu::mem::store32f( regs, regs.FR31, (uint32)(regs.R10 + 0x00001780) );
		/* 82061BECh case  105:*/		return 0x82061BF0;
		  /* 82061BF0h */ case  106:  		/* addi R10, R3, 96 */
		/* 82061BF0h case  106:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R3,0x60);
		/* 82061BF0h case  106:*/		return 0x82061BF4;
		  /* 82061BF4h */ case  107:  		/* lfs FR0, <#[R9 + 4]> */
		/* 82061BF4h case  107:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R9 + 0x00000004) );
		/* 82061BF4h case  107:*/		return 0x82061BF8;
		  /* 82061BF8h */ case  108:  		/* li R4, 1 */
		/* 82061BF8h case  108:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82061BF8h case  108:*/		return 0x82061BFC;
		  /* 82061BFCh */ case  109:  		/* stfs FR0, <#[R11 + 6020]> */
		/* 82061BFCh case  109:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x00001784) );
		/* 82061BFCh case  109:*/		return 0x82061C00;
		  /* 82061C00h */ case  110:  		/* lfs FR0, <#[R9 + 8]> */
		/* 82061C00h case  110:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R9 + 0x00000008) );
		/* 82061C00h case  110:*/		return 0x82061C04;
		  /* 82061C04h */ case  111:  		/* stfs FR0, <#[R11 + 6024]> */
		/* 82061C04h case  111:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x00001788) );
		/* 82061C04h case  111:*/		return 0x82061C08;
		  /* 82061C08h */ case  112:  		/* lfs FR0, <#[R9 + 12]> */
		/* 82061C08h case  112:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R9 + 0x0000000C) );
		/* 82061C08h case  112:*/		return 0x82061C0C;
		  /* 82061C0Ch */ case  113:  		/* stfs FR0, <#[R11 + 6028]> */
		/* 82061C0Ch case  113:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x0000178C) );
		/* 82061C0Ch case  113:*/		return 0x82061C10;
		  /* 82061C10h */ case  114:  		/* ld R9, <#[R11 + 8]> */
		/* 82061C10h case  114:*/		cpu::mem::load64( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 82061C10h case  114:*/		return 0x82061C14;
		  /* 82061C14h */ case  115:  		/* or R9, R9, R5 */
		/* 82061C14h case  115:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R5);
		/* 82061C14h case  115:*/		return 0x82061C18;
		  /* 82061C18h */ case  116:  		/* std R9, <#[R11 + 8]> */
		/* 82061C18h case  116:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 82061C18h case  116:*/		return 0x82061C1C;
		  /* 82061C1Ch */ case  117:  		/* lfs FR0, <#[R3 + 96]> */
		/* 82061C1Ch case  117:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R3 + 0x00000060) );
		/* 82061C1Ch case  117:*/		return 0x82061C20;
		  /* 82061C20h */ case  118:  		/* lwz R11, <#[R27 - 31240]> */
		/* 82061C20h case  118:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0xFFFF85F8) );
		/* 82061C20h case  118:*/		return 0x82061C24;
		  /* 82061C24h */ case  119:  		/* stfs FR0, <#[R11 + 6032]> */
		/* 82061C24h case  119:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x00001790) );
		/* 82061C24h case  119:*/		return 0x82061C28;
		  /* 82061C28h */ case  120:  		/* lfs FR0, <#[R10 + 4]> */
		/* 82061C28h case  120:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000004) );
		/* 82061C28h case  120:*/		return 0x82061C2C;
		  /* 82061C2Ch */ case  121:  		/* stfs FR0, <#[R11 + 6036]> */
		/* 82061C2Ch case  121:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x00001794) );
		/* 82061C2Ch case  121:*/		return 0x82061C30;
		  /* 82061C30h */ case  122:  		/* lfs FR0, <#[R10 + 8]> */
		/* 82061C30h case  122:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000008) );
		/* 82061C30h case  122:*/		return 0x82061C34;
		  /* 82061C34h */ case  123:  		/* stfs FR0, <#[R11 + 6040]> */
		/* 82061C34h case  123:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x00001798) );
		/* 82061C34h case  123:*/		return 0x82061C38;
		  /* 82061C38h */ case  124:  		/* lfs FR0, <#[R10 + 12]> */
		/* 82061C38h case  124:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R10 + 0x0000000C) );
		/* 82061C38h case  124:*/		return 0x82061C3C;
		  /* 82061C3Ch */ case  125:  		/* stfs FR0, <#[R11 + 6044]> */
		/* 82061C3Ch case  125:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x0000179C) );
		/* 82061C3Ch case  125:*/		return 0x82061C40;
		  /* 82061C40h */ case  126:  		/* ld R10, <#[R11 + 8]> */
		/* 82061C40h case  126:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82061C40h case  126:*/		return 0x82061C44;
		  /* 82061C44h */ case  127:  		/* or R10, R10, R5 */
		/* 82061C44h case  127:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R5);
		/* 82061C44h case  127:*/		return 0x82061C48;
		  /* 82061C48h */ case  128:  		/* std R10, <#[R11 + 8]> */
		/* 82061C48h case  128:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82061C48h case  128:*/		return 0x82061C4C;
		  /* 82061C4Ch */ case  129:  		/* lwz R3, <#[R27 - 31240]> */
		/* 82061C4Ch case  129:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0xFFFF85F8) );
		/* 82061C4Ch case  129:*/		return 0x82061C50;
		  /* 82061C50h */ case  130:  		/* lwz R5, <#[R31 + 800]> */
		/* 82061C50h case  130:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000320) );
		/* 82061C50h case  130:*/		return 0x82061C54;
		  /* 82061C54h */ case  131:  		/* bl 21276 */
		/* 82061C54h case  131:*/		regs.LR = 0x82061C58; return 0x82066F70;
		/* 82061C54h case  131:*/		return 0x82061C58;
		  /* 82061C58h */ case  132:  		/* li R6, 0 */
		/* 82061C58h case  132:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82061C58h case  132:*/		return 0x82061C5C;
		  /* 82061C5Ch */ case  133:  		/* lwz R3, <#[R27 - 31240]> */
		/* 82061C5Ch case  133:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0xFFFF85F8) );
		/* 82061C5Ch case  133:*/		return 0x82061C60;
		  /* 82061C60h */ case  134:  		/* li R4, 0 */
		/* 82061C60h case  134:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82061C60h case  134:*/		return 0x82061C64;
		  /* 82061C64h */ case  135:  		/* lwz R5, <#[R31 + 636]> */
		/* 82061C64h case  135:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000027C) );
		/* 82061C64h case  135:*/		return 0x82061C68;
		  /* 82061C68h */ case  136:  		/* oris R6, R6, 32768 */
		/* 82061C68h case  136:*/		cpu::op::oris<0>(regs,&regs.R6,regs.R6,0x8000);
		/* 82061C68h case  136:*/		return 0x82061C6C;
		  /* 82061C6Ch */ case  137:  		/* bl 21252 */
		/* 82061C6Ch case  137:*/		regs.LR = 0x82061C70; return 0x82066F70;
		/* 82061C6Ch case  137:*/		return 0x82061C70;
		  /* 82061C70h */ case  138:  		/* lwz R3, <#[R27 - 31240]> */
		/* 82061C70h case  138:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0xFFFF85F8) );
		/* 82061C70h case  138:*/		return 0x82061C74;
		  /* 82061C74h */ case  139:  		/* lwz R4, <#[R31 + 664]> */
		/* 82061C74h case  139:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000298) );
		/* 82061C74h case  139:*/		return 0x82061C78;
		  /* 82061C78h */ case  140:  		/* bl 188568 */
		/* 82061C78h case  140:*/		regs.LR = 0x82061C7C; return 0x8208FD10;
		/* 82061C78h case  140:*/		return 0x82061C7C;
		  /* 82061C7Ch */ case  141:  		/* lwz R3, <#[R27 - 31240]> */
		/* 82061C7Ch case  141:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0xFFFF85F8) );
		/* 82061C7Ch case  141:*/		return 0x82061C80;
		  /* 82061C80h */ case  142:  		/* lwz R4, <#[R31 + 668]> */
		/* 82061C80h case  142:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000029C) );
		/* 82061C80h case  142:*/		return 0x82061C84;
		  /* 82061C84h */ case  143:  		/* bl 188644 */
		/* 82061C84h case  143:*/		regs.LR = 0x82061C88; return 0x8208FD68;
		/* 82061C84h case  143:*/		return 0x82061C88;
		  /* 82061C88h */ case  144:  		/* li R8, 1 */
		/* 82061C88h case  144:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82061C88h case  144:*/		return 0x82061C8C;
		  /* 82061C8Ch */ case  145:  		/* lwz R7, <#[R31 + 652]> */
		/* 82061C8Ch case  145:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x0000028C) );
		/* 82061C8Ch case  145:*/		return 0x82061C90;
		  /* 82061C90h */ case  146:  		/* li R6, 0 */
		/* 82061C90h case  146:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82061C90h case  146:*/		return 0x82061C94;
		  /* 82061C94h */ case  147:  		/* lwz R3, <#[R27 - 31240]> */
		/* 82061C94h case  147:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0xFFFF85F8) );
		/* 82061C94h case  147:*/		return 0x82061C98;
		  /* 82061C98h */ case  148:  		/* li R4, 0 */
		/* 82061C98h case  148:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82061C98h case  148:*/		return 0x82061C9C;
		  /* 82061C9Ch */ case  149:  		/* lwz R5, <#[R31 + 640]> */
		/* 82061C9Ch case  149:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000280) );
		/* 82061C9Ch case  149:*/		return 0x82061CA0;
		  /* 82061CA0h */ case  150:  		/* bl 10672 */
		/* 82061CA0h case  150:*/		regs.LR = 0x82061CA4; return 0x82064650;
		/* 82061CA0h case  150:*/		return 0x82061CA4;
		  /* 82061CA4h */ case  151:  		/* lwz R3, <#[R27 - 31240]> */
		/* 82061CA4h case  151:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0xFFFF85F8) );
		/* 82061CA4h case  151:*/		return 0x82061CA8;
		  /* 82061CA8h */ case  152:  		/* lwz R4, <#[R31 + 644]> */
		/* 82061CA8h case  152:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000284) );
		/* 82061CA8h case  152:*/		return 0x82061CAC;
		  /* 82061CACh */ case  153:  		/* bl 10948 */
		/* 82061CACh case  153:*/		regs.LR = 0x82061CB0; return 0x82064770;
		/* 82061CACh case  153:*/		return 0x82061CB0;
		  /* 82061CB0h */ case  154:  		/* lwz R4, <#[R31 + 648]> */
		/* 82061CB0h case  154:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000288) );
		/* 82061CB0h case  154:*/		return 0x82061CB4;
		  /* 82061CB4h */ case  155:  		/* lis R11, -32256 */
		/* 82061CB4h case  155:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82061CB4h case  155:*/		return 0x82061CB8;
		  /* 82061CB8h */ case  156:  		/* lwz R10, <#[R31 + 660]> */
		/* 82061CB8h case  156:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000294) );
		/* 82061CB8h case  156:*/		return 0x82061CBC;
		  /* 82061CBCh */ case  157:  		/* li R6, 0 */
		/* 82061CBCh case  157:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82061CBCh case  157:*/		return 0x82061CC0;
		  /* 82061CC0h */ case  158:  		/* addi R30, R11, 1568 */
		/* 82061CC0h case  158:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0x620);
		/* 82061CC0h case  158:*/		return 0x82061CC4;
		  /* 82061CC4h */ case  159:  		/* lwz R3, <#[R27 - 31240]> */
		/* 82061CC4h case  159:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0xFFFF85F8) );
		/* 82061CC4h case  159:*/		return 0x82061CC8;
		  /* 82061CC8h */ case  160:  		/* rlwinm R9, R4, 3, 0, 28 */
		/* 82061CC8h case  160:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R9,regs.R4);
		/* 82061CC8h case  160:*/		return 0x82061CCC;
		  /* 82061CCCh */ case  161:  		/* addi R11, R30, 4 */
		/* 82061CCCh case  161:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x4);
		/* 82061CCCh case  161:*/		return 0x82061CD0;
		  /* 82061CD0h */ case  162:  		/* li R5, 0 */
		/* 82061CD0h case  162:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82061CD0h case  162:*/		return 0x82061CD4;
		  /* 82061CD4h */ case  163:  		/* lwzx R8, <#[R9 + R30]> */
		/* 82061CD4h case  163:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + regs.R30 + 0x00000000) );
		/* 82061CD4h case  163:*/		return 0x82061CD8;
		  /* 82061CD8h */ case  164:  		/* mullw R10, R8, R10 */
		/* 82061CD8h case  164:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 82061CD8h case  164:*/		return 0x82061CDC;
		  /* 82061CDCh */ case  165:  		/* lwzx R11, <#[R9 + R11]> */
		/* 82061CDCh case  165:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82061CDCh case  165:*/		return 0x82061CE0;
		  /* 82061CE0h */ case  166:  		/* add R7, R10, R11 */
		/* 82061CE0h case  166:*/		cpu::op::add<0>(regs,&regs.R7,regs.R10,regs.R11);
		/* 82061CE0h case  166:*/		return 0x82061CE4;
		  /* 82061CE4h */ case  167:  		/* bl 61828 */
		/* 82061CE4h case  167:*/		regs.LR = 0x82061CE8; return 0x82070E68;
		/* 82061CE4h case  167:*/		return 0x82061CE8;
		  /* 82061CE8h */ case  168:  		/* li R6, 0 */
		/* 82061CE8h case  168:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82061CE8h case  168:*/		return 0x82061CEC;
		  /* 82061CECh */ case  169:  		/* lwz R3, <#[R27 - 31240]> */
		/* 82061CECh case  169:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0xFFFF85F8) );
		/* 82061CECh case  169:*/		return 0x82061CF0;
		  /* 82061CF0h */ case  170:  		/* li R4, 0 */
		/* 82061CF0h case  170:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82061CF0h case  170:*/		return 0x82061CF4;
		  /* 82061CF4h */ case  171:  		/* lwz R5, <#[R31 + 576]> */
		/* 82061CF4h case  171:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000240) );
		/* 82061CF4h case  171:*/		return 0x82061CF8;
		  /* 82061CF8h */ case  172:  		/* oris R6, R6, 32768 */
		/* 82061CF8h case  172:*/		cpu::op::oris<0>(regs,&regs.R6,regs.R6,0x8000);
		/* 82061CF8h case  172:*/		return 0x82061CFC;
		  /* 82061CFCh */ case  173:  		/* bl 21108 */
		/* 82061CFCh case  173:*/		regs.LR = 0x82061D00; return 0x82066F70;
		/* 82061CFCh case  173:*/		return 0x82061D00;
		  /* 82061D00h */ case  174:  		/* lwz R3, <#[R27 - 31240]> */
		/* 82061D00h case  174:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0xFFFF85F8) );
		/* 82061D00h case  174:*/		return 0x82061D04;
		  /* 82061D04h */ case  175:  		/* lwz R4, <#[R31 + 612]> */
		/* 82061D04h case  175:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000264) );
		/* 82061D04h case  175:*/		return 0x82061D08;
		  /* 82061D08h */ case  176:  		/* bl 188424 */
		/* 82061D08h case  176:*/		regs.LR = 0x82061D0C; return 0x8208FD10;
		/* 82061D08h case  176:*/		return 0x82061D0C;
		  /* 82061D0Ch */ case  177:  		/* lwz R3, <#[R27 - 31240]> */
		/* 82061D0Ch case  177:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0xFFFF85F8) );
		/* 82061D0Ch case  177:*/		return 0x82061D10;
		  /* 82061D10h */ case  178:  		/* lwz R4, <#[R31 + 616]> */
		/* 82061D10h case  178:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000268) );
		/* 82061D10h case  178:*/		return 0x82061D14;
		  /* 82061D14h */ case  179:  		/* bl 188500 */
		/* 82061D14h case  179:*/		regs.LR = 0x82061D18; return 0x8208FD68;
		/* 82061D14h case  179:*/		return 0x82061D18;
		  /* 82061D18h */ case  180:  		/* li R8, 1 */
		/* 82061D18h case  180:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82061D18h case  180:*/		return 0x82061D1C;
		  /* 82061D1Ch */ case  181:  		/* lwz R3, <#[R27 - 31240]> */
		/* 82061D1Ch case  181:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0xFFFF85F8) );
		/* 82061D1Ch case  181:*/		return 0x82061D20;
		  /* 82061D20h */ case  182:  		/* li R6, 0 */
		/* 82061D20h case  182:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82061D20h case  182:*/		return 0x82061D24;
		  /* 82061D24h */ case  183:  		/* lwz R7, <#[R31 + 600]> */
		/* 82061D24h case  183:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000258) );
		/* 82061D24h case  183:*/		return 0x82061D28;
		  /* 82061D28h */ case  184:  		/* li R4, 0 */
		/* 82061D28h case  184:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82061D28h case  184:*/		return 0x82061D2C;
		  /* 82061D2Ch */ case  185:  		/* lwz R5, <#[R31 + 580]> */
		/* 82061D2Ch case  185:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000244) );
		/* 82061D2Ch case  185:*/		return 0x82061D30;
		  /* 82061D30h */ case  186:  		/* bl 10528 */
		/* 82061D30h case  186:*/		regs.LR = 0x82061D34; return 0x82064650;
		/* 82061D30h case  186:*/		return 0x82061D34;
		  /* 82061D34h */ case  187:  		/* li R8, 1 */
		/* 82061D34h case  187:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82061D34h case  187:*/		return 0x82061D38;
		  /* 82061D38h */ case  188:  		/* li R6, 0 */
		/* 82061D38h case  188:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82061D38h case  188:*/		return 0x82061D3C;
		  /* 82061D3Ch */ case  189:  		/* lwz R3, <#[R27 - 31240]> */
		/* 82061D3Ch case  189:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0xFFFF85F8) );
		/* 82061D3Ch case  189:*/		return 0x82061D40;
		  /* 82061D40h */ case  190:  		/* li R4, 1 */
		/* 82061D40h case  190:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82061D40h case  190:*/		return 0x82061D44;
		  /* 82061D44h */ case  191:  		/* lwz R7, <#[R31 + 600]> */
		/* 82061D44h case  191:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000258) );
		/* 82061D44h case  191:*/		return 0x82061D48;
		  /* 82061D48h */ case  192:  		/* lwz R5, <#[R31 + 584]> */
		/* 82061D48h case  192:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000248) );
		/* 82061D48h case  192:*/		return 0x82061D4C;
		  /* 82061D4Ch */ case  193:  		/* bl 10500 */
		/* 82061D4Ch case  193:*/		regs.LR = 0x82061D50; return 0x82064650;
		/* 82061D4Ch case  193:*/		return 0x82061D50;
		  /* 82061D50h */ case  194:  		/* li R8, 1 */
		/* 82061D50h case  194:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82061D50h case  194:*/		return 0x82061D54;
		  /* 82061D54h */ case  195:  		/* li R6, 0 */
		/* 82061D54h case  195:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82061D54h case  195:*/		return 0x82061D58;
		  /* 82061D58h */ case  196:  		/* lwz R3, <#[R27 - 31240]> */
		/* 82061D58h case  196:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0xFFFF85F8) );
		/* 82061D58h case  196:*/		return 0x82061D5C;
		  /* 82061D5Ch */ case  197:  		/* li R4, 2 */
		/* 82061D5Ch case  197:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 82061D5Ch case  197:*/		return 0x82061D60;
		  /* 82061D60h */ case  198:  		/* lwz R7, <#[R31 + 600]> */
		/* 82061D60h case  198:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000258) );
		/* 82061D60h case  198:*/		return 0x82061D64;
		  /* 82061D64h */ case  199:  		/* lwz R5, <#[R31 + 588]> */
		/* 82061D64h case  199:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000024C) );
		/* 82061D64h case  199:*/		return 0x82061D68;
		  /* 82061D68h */ case  200:  		/* bl 10472 */
		/* 82061D68h case  200:*/		regs.LR = 0x82061D6C; return 0x82064650;
		/* 82061D68h case  200:*/		return 0x82061D6C;
		  /* 82061D6Ch */ case  201:  		/* lwz R3, <#[R27 - 31240]> */
		/* 82061D6Ch case  201:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0xFFFF85F8) );
		/* 82061D6Ch case  201:*/		return 0x82061D70;
		  /* 82061D70h */ case  202:  		/* lwz R4, <#[R31 + 592]> */
		/* 82061D70h case  202:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000250) );
		/* 82061D70h case  202:*/		return 0x82061D74;
		  /* 82061D74h */ case  203:  		/* bl 10748 */
		/* 82061D74h case  203:*/		regs.LR = 0x82061D78; return 0x82064770;
		/* 82061D74h case  203:*/		return 0x82061D78;
		  /* 82061D78h */ case  204:  		/* lwz R4, <#[R31 + 596]> */
		/* 82061D78h case  204:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000254) );
		/* 82061D78h case  204:*/		return 0x82061D7C;
		  /* 82061D7Ch */ case  205:  		/* addi R11, R30, 4 */
		/* 82061D7Ch case  205:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x4);
		/* 82061D7Ch case  205:*/		return 0x82061D80;
		  /* 82061D80h */ case  206:  		/* lwz R10, <#[R31 + 608]> */
		/* 82061D80h case  206:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000260) );
		/* 82061D80h case  206:*/		return 0x82061D84;
		  /* 82061D84h */ case  207:  		/* li R6, 0 */
		/* 82061D84h case  207:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82061D84h case  207:*/		return 0x82061D88;
		  /* 82061D88h */ case  208:  		/* rlwinm R9, R4, 3, 0, 28 */
		/* 82061D88h case  208:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R9,regs.R4);
		/* 82061D88h case  208:*/		return 0x82061D8C;
		  /* 82061D8Ch */ case  209:  		/* lwz R3, <#[R27 - 31240]> */
		/* 82061D8Ch case  209:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0xFFFF85F8) );
		/* 82061D8Ch case  209:*/		return 0x82061D90;
		  /* 82061D90h */ case  210:  		/* li R5, 0 */
		/* 82061D90h case  210:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82061D90h case  210:*/		return 0x82061D94;
		  /* 82061D94h */ case  211:  		/* lwzx R8, <#[R9 + R30]> */
		/* 82061D94h case  211:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + regs.R30 + 0x00000000) );
		/* 82061D94h case  211:*/		return 0x82061D98;
		  /* 82061D98h */ case  212:  		/* mullw R10, R8, R10 */
		/* 82061D98h case  212:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 82061D98h case  212:*/		return 0x82061D9C;
		  /* 82061D9Ch */ case  213:  		/* lwzx R11, <#[R9 + R11]> */
		/* 82061D9Ch case  213:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82061D9Ch case  213:*/		return 0x82061DA0;
		  /* 82061DA0h */ case  214:  		/* add R7, R10, R11 */
		/* 82061DA0h case  214:*/		cpu::op::add<0>(regs,&regs.R7,regs.R10,regs.R11);
		/* 82061DA0h case  214:*/		return 0x82061DA4;
		  /* 82061DA4h */ case  215:  		/* bl 61636 */
		/* 82061DA4h case  215:*/		regs.LR = 0x82061DA8; return 0x82070E68;
		/* 82061DA4h case  215:*/		return 0x82061DA8;
		  /* 82061DA8h */ case  216:  		/* lwz R11, <#[R31 + 84]> */
		/* 82061DA8h case  216:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000054) );
		/* 82061DA8h case  216:*/		return 0x82061DAC;
		  /* 82061DACh */ case  217:  		/* addi R30, R31, 104 */
		/* 82061DACh case  217:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x68);
		/* 82061DACh case  217:*/		return 0x82061DB0;
		  /* 82061DB0h */ case  218:  		/* addi R11, R11, 1 */
		/* 82061DB0h case  218:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82061DB0h case  218:*/		return 0x82061DB4;
		  /* 82061DB4h */ case  219:  		/* mr R3, R30 */
		/* 82061DB4h case  219:*/		regs.R3 = regs.R30;
		/* 82061DB4h case  219:*/		return 0x82061DB8;
		  /* 82061DB8h */ case  220:  		/* stw R11, <#[R31 + 84]> */
		/* 82061DB8h case  220:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000054) );
		/* 82061DB8h case  220:*/		return 0x82061DBC;
		  /* 82061DBCh */ case  221:  		/* addi R29, R31, 8 */
		/* 82061DBCh case  221:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R31,0x8);
		/* 82061DBCh case  221:*/		return 0x82061DC0;
		  /* 82061DC0h */ case  222:  		/* bl 182552 */
		/* 82061DC0h case  222:*/		regs.LR = 0x82061DC4; return 0x8208E6D8;
		/* 82061DC0h case  222:*/		return 0x82061DC4;
		  /* 82061DC4h */ case  223:  		/* lis R11, -32256 */
		/* 82061DC4h case  223:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82061DC4h case  223:*/		return 0x82061DC8;
		  /* 82061DC8h */ case  224:  		/* lis R10, -32256 */
		/* 82061DC8h case  224:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82061DC8h case  224:*/		return 0x82061DCC;
		  /* 82061DCCh */ case  225:  		/* fmr FR3, FR31 */
		/* 82061DCCh case  225:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR31);
		/* 82061DCCh case  225:*/		return 0x82061DD0;
		  /* 82061DD0h */ case  226:  		/* mr R3, R30 */
		/* 82061DD0h case  226:*/		regs.R3 = regs.R30;
		/* 82061DD0h case  226:*/		return 0x82061DD4;
		  /* 82061DD4h */ case  227:  		/* fmr FR2, FR31 */
		/* 82061DD4h case  227:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR31);
		/* 82061DD4h case  227:*/		return 0x82061DD8;
		  /* 82061DD8h */ case  228:  		/* addi R7, R10, 2832 */
		/* 82061DD8h case  228:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0xB10);
		/* 82061DD8h case  228:*/		return 0x82061DDC;
		  /* 82061DDCh */ case  229:  		/* fmr FR1, FR31 */
		/* 82061DDCh case  229:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 82061DDCh case  229:*/		return 0x82061DE0;
		  /* 82061DE0h */ case  230:  		/* li R8, 0 */
		/* 82061DE0h case  230:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82061DE0h case  230:*/		return 0x82061DE4;
		  /* 82061DE4h */ case  231:  		/* lfs FR0, <#[R11 + 2848]> */
		/* 82061DE4h case  231:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000B20) );
		/* 82061DE4h case  231:*/		return 0x82061DE8;
		  /* 82061DE8h */ case  232:  		/* li R6, -1 */
		/* 82061DE8h case  232:*/		cpu::op::li<0>(regs,&regs.R6,0xFFFFFFFF);
		/* 82061DE8h case  232:*/		return 0x82061DEC;
		  /* 82061DECh */ case  233:  		/* stfs FR0, <#[R31 + 148]> */
		/* 82061DECh case  233:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R31 + 0x00000094) );
		/* 82061DECh case  233:*/		return 0x82061DF0;
		  /* 82061DF0h */ case  234:  		/* stfs FR0, <#[R31 + 152]> */
		/* 82061DF0h case  234:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R31 + 0x00000098) );
		/* 82061DF0h case  234:*/		return 0x82061DF4;
		  /* 82061DF4h */ case  235:  		/* bl 183772 */
		/* 82061DF4h case  235:*/		regs.LR = 0x82061DF8; return 0x8208EBD0;
		/* 82061DF4h case  235:*/		return 0x82061DF8;
		  /* 82061DF8h */ case  236:  		/* stfs FR30, <#[R31 + 148]> */
		/* 82061DF8h case  236:*/		cpu::mem::store32f( regs, regs.FR30, (uint32)(regs.R31 + 0x00000094) );
		/* 82061DF8h case  236:*/		return 0x82061DFC;
		  /* 82061DFCh */ case  237:  		/* stfs FR30, <#[R31 + 152]> */
		/* 82061DFCh case  237:*/		cpu::mem::store32f( regs, regs.FR30, (uint32)(regs.R31 + 0x00000098) );
		/* 82061DFCh case  237:*/		return 0x82061E00;
		  /* 82061E00h */ case  238:  		/* mr R3, R29 */
		/* 82061E00h case  238:*/		regs.R3 = regs.R29;
		/* 82061E00h case  238:*/		return 0x82061E04;
		  /* 82061E04h */ case  239:  		/* bl -5588 */
		/* 82061E04h case  239:*/		regs.LR = 0x82061E08; return 0x82060830;
		/* 82061E04h case  239:*/		return 0x82061E08;
		  /* 82061E08h */ case  240:  		/* li R28, -256 */
		/* 82061E08h case  240:*/		cpu::op::li<0>(regs,&regs.R28,0xFFFFFF00);
		/* 82061E08h case  240:*/		return 0x82061E0C;
		  /* 82061E0Ch */ case  241:  		/* mr R7, R3 */
		/* 82061E0Ch case  241:*/		regs.R7 = regs.R3;
		/* 82061E0Ch case  241:*/		return 0x82061E10;
		  /* 82061E10h */ case  242:  		/* fmr FR2, FR31 */
		/* 82061E10h case  242:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR31);
		/* 82061E10h case  242:*/		return 0x82061E14;
		  /* 82061E14h */ case  243:  		/* mr R6, R28 */
		/* 82061E14h case  243:*/		regs.R6 = regs.R28;
		/* 82061E14h case  243:*/		return 0x82061E18;
		  /* 82061E18h */ case  244:  		/* fmr FR1, FR31 */
		/* 82061E18h case  244:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 82061E18h case  244:*/		return 0x82061E1C;
		  /* 82061E1Ch */ case  245:  		/* mr R3, R30 */
		/* 82061E1Ch case  245:*/		regs.R3 = regs.R30;
		/* 82061E1Ch case  245:*/		return 0x82061E20;
		  /* 82061E20h */ case  246:  		/* fmr FR3, FR31 */
		/* 82061E20h case  246:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR31);
		/* 82061E20h case  246:*/		return 0x82061E24;
		  /* 82061E24h */ case  247:  		/* li R8, 1 */
		/* 82061E24h case  247:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82061E24h case  247:*/		return 0x82061E28;
	}
	return 0x82061E28;
} // Block from 82061A48h-82061E28h (248 instructions)

//////////////////////////////////////////////////////
// Block at 82061E28h
// Function '??$swprintf_s@$0BA@@@YAHAAY0BA@_WPB_WZZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82061E28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82061E28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82061E28);
		  /* 82061E28h */ case    0:  		/* bl 183720 */
		/* 82061E28h case    0:*/		regs.LR = 0x82061E2C; return 0x8208EBD0;
		/* 82061E28h case    0:*/		return 0x82061E2C;
		  /* 82061E2Ch */ case    1:  		/* mr R3, R29 */
		/* 82061E2Ch case    1:*/		regs.R3 = regs.R29;
		/* 82061E2Ch case    1:*/		return 0x82061E30;
		  /* 82061E30h */ case    2:  		/* bl -6640 */
		/* 82061E30h case    2:*/		regs.LR = 0x82061E34; return 0x82060440;
		/* 82061E30h case    2:*/		return 0x82061E34;
		  /* 82061E34h */ case    3:  		/* lfd FR0, <#[R31 + 32]> */
		/* 82061E34h case    3:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R31 + 0x00000020) );
		/* 82061E34h case    3:*/		return 0x82061E38;
		  /* 82061E38h */ case    4:  		/* fsub FR1, FR1, FR0 */
		/* 82061E38h case    4:*/		cpu::op::fsub<0>(regs,&regs.FR1,regs.FR1,regs.FR0);
		/* 82061E38h case    4:*/		return 0x82061E3C;
		  /* 82061E3Ch */ case    5:  		/* lis R11, -32256 */
		/* 82061E3Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82061E3Ch case    5:*/		return 0x82061E40;
		  /* 82061E40h */ case    6:  		/* lfd FR0, <#[R11 + 2824]> */
		/* 82061E40h case    6:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000B08) );
		/* 82061E40h case    6:*/		return 0x82061E44;
		  /* 82061E44h */ case    7:  		/* fmul FR30, FR1, FR0 */
		/* 82061E44h case    7:*/		cpu::op::fmul<0>(regs,&regs.FR30,regs.FR1,regs.FR0);
		/* 82061E44h case    7:*/		return 0x82061E48;
		  /* 82061E48h */ case    8:  		/* fmul FR29, FR30, FR0 */
		/* 82061E48h case    8:*/		cpu::op::fmul<0>(regs,&regs.FR29,regs.FR30,regs.FR0);
		/* 82061E48h case    8:*/		return 0x82061E4C;
		  /* 82061E4Ch */ case    9:  		/* bl 196756 */
		/* 82061E4Ch case    9:*/		regs.LR = 0x82061E50; return 0x82091EE0;
		/* 82061E4Ch case    9:*/		return 0x82061E50;
		  /* 82061E50h */ case   10:  		/* fctidz FR0, FR1 */
		/* 82061E50h case   10:*/		cpu::op::fctidz<0>(regs,&regs.FR0,regs.FR1);
		/* 82061E50h case   10:*/		return 0x82061E54;
		  /* 82061E54h */ case   11:  		/* li R31, 60 */
		/* 82061E54h case   11:*/		cpu::op::li<0>(regs,&regs.R31,0x3C);
		/* 82061E54h case   11:*/		return 0x82061E58;
		  /* 82061E58h */ case   12:  		/* stfd FR0, <#[R1 + 80]> */
		/* 82061E58h case   12:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 82061E58h case   12:*/		return 0x82061E5C;
		  /* 82061E5Ch */ case   13:  		/* lwz R11, <#[R1 + 84]> */
		/* 82061E5Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82061E5Ch case   13:*/		return 0x82061E60;
		  /* 82061E60h */ case   14:  		/* divwu R10, R11, R31 */
		/* 82061E60h case   14:*/		cpu::op::divwu<0>(regs,&regs.R10,regs.R11,regs.R31);
		/* 82061E60h case   14:*/		return 0x82061E64;
		  /* 82061E64h */ case   15:  		/* fmr FR1, FR30 */
		/* 82061E64h case   15:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR30);
		/* 82061E64h case   15:*/		return 0x82061E68;
		  /* 82061E68h */ case   16:  		/* mulli R10, R10, 60 */
		/* 82061E68h case   16:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x3C);
		/* 82061E68h case   16:*/		return 0x82061E6C;
		  /* 82061E6Ch */ case   17:  		/* subf R29, R10, R11 */
		/* 82061E6Ch case   17:*/		cpu::op::subf<0>(regs,&regs.R29,regs.R10,regs.R11);
		/* 82061E6Ch case   17:*/		return 0x82061E70;
		  /* 82061E70h */ case   18:  		/* bl 196720 */
		/* 82061E70h case   18:*/		regs.LR = 0x82061E74; return 0x82091EE0;
		/* 82061E70h case   18:*/		return 0x82061E74;
		  /* 82061E74h */ case   19:  		/* fctidz FR0, FR1 */
		/* 82061E74h case   19:*/		cpu::op::fctidz<0>(regs,&regs.FR0,regs.FR1);
		/* 82061E74h case   19:*/		return 0x82061E78;
		  /* 82061E78h */ case   20:  		/* stfd FR0, <#[R1 + 80]> */
		/* 82061E78h case   20:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 82061E78h case   20:*/		return 0x82061E7C;
		  /* 82061E7Ch */ case   21:  		/* lwz R11, <#[R1 + 84]> */
		/* 82061E7Ch case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82061E7Ch case   21:*/		return 0x82061E80;
	}
	return 0x82061E80;
} // Block from 82061E28h-82061E80h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82061E80h
// Function '??$sprintf_s@$0FA@@@YAHAAY0FA@DPBDZZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82061E80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82061E80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82061E80);
		  /* 82061E80h */ case    0:  		/* divwu R10, R11, R31 */
		/* 82061E80h case    0:*/		cpu::op::divwu<0>(regs,&regs.R10,regs.R11,regs.R31);
		/* 82061E80h case    0:*/		return 0x82061E84;
		  /* 82061E84h */ case    1:  		/* mulli R10, R10, 60 */
		/* 82061E84h case    1:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x3C);
		/* 82061E84h case    1:*/		return 0x82061E88;
		  /* 82061E88h */ case    2:  		/* fmr FR1, FR29 */
		/* 82061E88h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR29);
		/* 82061E88h case    2:*/		return 0x82061E8C;
		  /* 82061E8Ch */ case    3:  		/* subf R31, R10, R11 */
		/* 82061E8Ch case    3:*/		cpu::op::subf<0>(regs,&regs.R31,regs.R10,regs.R11);
		/* 82061E8Ch case    3:*/		return 0x82061E90;
		  /* 82061E90h */ case    4:  		/* bl 196688 */
		/* 82061E90h case    4:*/		regs.LR = 0x82061E94; return 0x82091EE0;
		/* 82061E90h case    4:*/		return 0x82061E94;
		  /* 82061E94h */ case    5:  		/* fctidz FR0, FR1 */
		/* 82061E94h case    5:*/		cpu::op::fctidz<0>(regs,&regs.FR0,regs.FR1);
		/* 82061E94h case    5:*/		return 0x82061E98;
		  /* 82061E98h */ case    6:  		/* li R11, 24 */
		/* 82061E98h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x18);
		/* 82061E98h case    6:*/		return 0x82061E9C;
		  /* 82061E9Ch */ case    7:  		/* stfd FR0, <#[R1 + 80]> */
		/* 82061E9Ch case    7:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 82061E9Ch case    7:*/		return 0x82061EA0;
		  /* 82061EA0h */ case    8:  		/* lis R10, -32256 */
		/* 82061EA0h case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82061EA0h case    8:*/		return 0x82061EA4;
		  /* 82061EA4h */ case    9:  		/* lwz R9, <#[R1 + 84]> */
		/* 82061EA4h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000054) );
		/* 82061EA4h case    9:*/		return 0x82061EA8;
		  /* 82061EA8h */ case   10:  		/* divwu R11, R9, R11 */
		/* 82061EA8h case   10:*/		cpu::op::divwu<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82061EA8h case   10:*/		return 0x82061EAC;
		  /* 82061EACh */ case   11:  		/* mulli R11, R11, 24 */
		/* 82061EACh case   11:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x18);
		/* 82061EACh case   11:*/		return 0x82061EB0;
		  /* 82061EB0h */ case   12:  		/* lfd FR0, <#[R10 + 2816]> */
		/* 82061EB0h case   12:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000B00) );
		/* 82061EB0h case   12:*/		return 0x82061EB4;
		  /* 82061EB4h */ case   13:  		/* fmul FR1, FR29, FR0 */
		/* 82061EB4h case   13:*/		cpu::op::fmul<0>(regs,&regs.FR1,regs.FR29,regs.FR0);
		/* 82061EB4h case   13:*/		return 0x82061EB8;
		  /* 82061EB8h */ case   14:  		/* subf R26, R11, R9 */
		/* 82061EB8h case   14:*/		cpu::op::subf<0>(regs,&regs.R26,regs.R11,regs.R9);
		/* 82061EB8h case   14:*/		return 0x82061EBC;
		  /* 82061EBCh */ case   15:  		/* bl 196644 */
		/* 82061EBCh case   15:*/		regs.LR = 0x82061EC0; return 0x82091EE0;
		/* 82061EBCh case   15:*/		return 0x82061EC0;
		  /* 82061EC0h */ case   16:  		/* lis R11, -32256 */
		/* 82061EC0h case   16:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82061EC0h case   16:*/		return 0x82061EC4;
		  /* 82061EC4h */ case   17:  		/* fctidz FR0, FR1 */
		/* 82061EC4h case   17:*/		cpu::op::fctidz<0>(regs,&regs.FR0,regs.FR1);
		/* 82061EC4h case   17:*/		return 0x82061EC8;
		  /* 82061EC8h */ case   18:  		/* mr R8, R29 */
		/* 82061EC8h case   18:*/		regs.R8 = regs.R29;
		/* 82061EC8h case   18:*/		return 0x82061ECC;
		  /* 82061ECCh */ case   19:  		/* stfd FR0, <#[R1 + 80]> */
		/* 82061ECCh case   19:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 82061ECCh case   19:*/		return 0x82061ED0;
		  /* 82061ED0h */ case   20:  		/* addi R4, R11, 2760 */
		/* 82061ED0h case   20:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xAC8);
		/* 82061ED0h case   20:*/		return 0x82061ED4;
		  /* 82061ED4h */ case   21:  		/* lwz R5, <#[R1 + 84]> */
		/* 82061ED4h case   21:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000054) );
		/* 82061ED4h case   21:*/		return 0x82061ED8;
	}
	return 0x82061ED8;
} // Block from 82061E80h-82061ED8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82061ED8h
// Function '??$swprintf_s@$0FA@@@YAHAAY0FA@_WPB_WZZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82061ED8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82061ED8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82061ED8);
		  /* 82061ED8h */ case    0:  		/* mr R7, R31 */
		/* 82061ED8h case    0:*/		regs.R7 = regs.R31;
		/* 82061ED8h case    0:*/		return 0x82061EDC;
		  /* 82061EDCh */ case    1:  		/* mr R6, R26 */
		/* 82061EDCh case    1:*/		regs.R6 = regs.R26;
		/* 82061EDCh case    1:*/		return 0x82061EE0;
		  /* 82061EE0h */ case    2:  		/* addi R3, R1, 96 */
		/* 82061EE0h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 82061EE0h case    2:*/		return 0x82061EE4;
		  /* 82061EE4h */ case    3:  		/* bl -6332 */
		/* 82061EE4h case    3:*/		regs.LR = 0x82061EE8; return 0x82060628;
		/* 82061EE4h case    3:*/		return 0x82061EE8;
		  /* 82061EE8h */ case    4:  		/* lis R11, -32256 */
		/* 82061EE8h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82061EE8h case    4:*/		return 0x82061EEC;
		  /* 82061EECh */ case    5:  		/* mr R3, R30 */
		/* 82061EECh case    5:*/		regs.R3 = regs.R30;
		/* 82061EECh case    5:*/		return 0x82061EF0;
		  /* 82061EF0h */ case    6:  		/* lfs FR2, <#[R11 + 2756]> */
		/* 82061EF0h case    6:*/		cpu::mem::load32f( regs, &regs.FR2, (uint32)(regs.R11 + 0x00000AC4) );
		/* 82061EF0h case    6:*/		return 0x82061EF4;
		  /* 82061EF4h */ case    7:  		/* li R8, 1 */
		/* 82061EF4h case    7:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82061EF4h case    7:*/		return 0x82061EF8;
		  /* 82061EF8h */ case    8:  		/* fmr FR3, FR31 */
		/* 82061EF8h case    8:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR31);
		/* 82061EF8h case    8:*/		return 0x82061EFC;
		  /* 82061EFCh */ case    9:  		/* addi R7, R1, 96 */
		/* 82061EFCh case    9:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 82061EFCh case    9:*/		return 0x82061F00;
		  /* 82061F00h */ case   10:  		/* fmr FR1, FR31 */
		/* 82061F00h case   10:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 82061F00h case   10:*/		return 0x82061F04;
		  /* 82061F04h */ case   11:  		/* mr R6, R28 */
		/* 82061F04h case   11:*/		regs.R6 = regs.R28;
		/* 82061F04h case   11:*/		return 0x82061F08;
		  /* 82061F08h */ case   12:  		/* bl 183496 */
		/* 82061F08h case   12:*/		regs.LR = 0x82061F0C; return 0x8208EBD0;
		/* 82061F08h case   12:*/		return 0x82061F0C;
		  /* 82061F0Ch */ case   13:  		/* mr R3, R30 */
		/* 82061F0Ch case   13:*/		regs.R3 = regs.R30;
		/* 82061F0Ch case   13:*/		return 0x82061F10;
		  /* 82061F10h */ case   14:  		/* bl 182928 */
		/* 82061F10h case   14:*/		regs.LR = 0x82061F14; return 0x8208E9A0;
		/* 82061F10h case   14:*/		return 0x82061F14;
		  /* 82061F14h */ case   15:  		/* lwz R3, <#[R27 - 31240]> */
		/* 82061F14h case   15:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R27 + 0xFFFF85F8) );
		/* 82061F14h case   15:*/		return 0x82061F18;
		  /* 82061F18h */ case   16:  		/* bl 54832 */
		/* 82061F18h case   16:*/		regs.LR = 0x82061F1C; return 0x8206F548;
		/* 82061F18h case   16:*/		return 0x82061F1C;
		  /* 82061F1Ch */ case   17:  		/* li R3, 0 */
		/* 82061F1Ch case   17:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82061F1Ch case   17:*/		return 0x82061F20;
		  /* 82061F20h */ case   18:  		/* addi R1, R1, 336 */
		/* 82061F20h case   18:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x150);
		/* 82061F20h case   18:*/		return 0x82061F24;
		  /* 82061F24h */ case   19:  		/* lfd FR29, <#[R1 - 80]> */
		/* 82061F24h case   19:*/		cpu::mem::load64f( regs, &regs.FR29, (uint32)(regs.R1 + 0xFFFFFFB0) );
		/* 82061F24h case   19:*/		return 0x82061F28;
		  /* 82061F28h */ case   20:  		/* lfd FR30, <#[R1 - 72]> */
		/* 82061F28h case   20:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R1 + 0xFFFFFFB8) );
		/* 82061F28h case   20:*/		return 0x82061F2C;
		  /* 82061F2Ch */ case   21:  		/* lfd FR31, <#[R1 - 64]> */
		/* 82061F2Ch case   21:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFC0) );
		/* 82061F2Ch case   21:*/		return 0x82061F30;
	}
	return 0x82061F30;
} // Block from 82061ED8h-82061F30h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82061F30h
// Function '?ResetAllState@D3D@@YAXPAVCDevice@1@H@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82061F30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82061F30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82061F30);
		  /* 82061F30h */ case    0:  		/* b 193392 */
		/* 82061F30h case    0:*/		return 0x820912A0;
		/* 82061F30h case    0:*/		return 0x82061F34;
		  /* 82061F34h */ case    1:  		/* nop */
		/* 82061F34h case    1:*/		cpu::op::nop();
		/* 82061F34h case    1:*/		return 0x82061F38;
	}
	return 0x82061F38;
} // Block from 82061F30h-82061F38h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82061F38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82061F38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82061F38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82061F38);
		  /* 82061F38h */ case    0:  		/* mfspr R12, LR */
		/* 82061F38h case    0:*/		regs.R12 = regs.LR;
		/* 82061F38h case    0:*/		return 0x82061F3C;
		  /* 82061F3Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82061F3Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82061F3Ch case    1:*/		return 0x82061F40;
		  /* 82061F40h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82061F40h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82061F40h case    2:*/		return 0x82061F44;
		  /* 82061F44h */ case    3:  		/* stwu R1, <#[R1 - 912]> */
		/* 82061F44h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFC70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFC70);
		/* 82061F44h case    3:*/		return 0x82061F48;
		  /* 82061F48h */ case    4:  		/* addi R3, R1, 80 */
		/* 82061F48h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82061F48h case    4:*/		return 0x82061F4C;
		  /* 82061F4Ch */ case    5:  		/* bl -5756 */
		/* 82061F4Ch case    5:*/		regs.LR = 0x82061F50; return 0x820608D0;
		/* 82061F4Ch case    5:*/		return 0x82061F50;
		  /* 82061F50h */ case    6:  		/* lis R11, -32217 */
		/* 82061F50h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82061F50h case    6:*/		return 0x82061F54;
		  /* 82061F54h */ case    7:  		/* li R5, 0 */
		/* 82061F54h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82061F54h case    7:*/		return 0x82061F58;
		  /* 82061F58h */ case    8:  		/* addi R31, R11, 6928 */
		/* 82061F58h case    8:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x1B10);
		/* 82061F58h case    8:*/		return 0x82061F5C;
		  /* 82061F5Ch */ case    9:  		/* mr R3, R31 */
		/* 82061F5Ch case    9:*/		regs.R3 = regs.R31;
		/* 82061F5Ch case    9:*/		return 0x82061F60;
		  /* 82061F60h */ case   10:  		/* addi R4, R31, 4 */
		/* 82061F60h case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x4);
		/* 82061F60h case   10:*/		return 0x82061F64;
		  /* 82061F64h */ case   11:  		/* bl 186164 */
		/* 82061F64h case   11:*/		regs.LR = 0x82061F68; return 0x8208F698;
		/* 82061F64h case   11:*/		return 0x82061F68;
		  /* 82061F68h */ case   12:  		/* lis R11, 6184 */
		/* 82061F68h case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0x1828);
		/* 82061F68h case   12:*/		return 0x82061F6C;
		  /* 82061F6Ch */ case   13:  		/* lis R10, 10280 */
		/* 82061F6Ch case   13:*/		cpu::op::lis<0>(regs,&regs.R10,0x2828);
		/* 82061F6Ch case   13:*/		return 0x82061F70;
		  /* 82061F70h */ case   14:  		/* ori R11, R11, 32646 */
		/* 82061F70h case   14:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x7F86);
		/* 82061F70h case   14:*/		return 0x82061F74;
		  /* 82061F74h */ case   15:  		/* ori R10, R10, 32518 */
		/* 82061F74h case   15:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x7F06);
		/* 82061F74h case   15:*/		return 0x82061F78;
		  /* 82061F78h */ case   16:  		/* stw R11, <#[R31 + 8]> */
		/* 82061F78h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82061F78h case   16:*/		return 0x82061F7C;
		  /* 82061F7Ch */ case   17:  		/* addi R3, R1, 80 */
		/* 82061F7Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82061F7Ch case   17:*/		return 0x82061F80;
		  /* 82061F80h */ case   18:  		/* stw R10, <#[R31 + 64]> */
		/* 82061F80h case   18:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000040) );
		/* 82061F80h case   18:*/		return 0x82061F84;
		  /* 82061F84h */ case   19:  		/* bl 185900 */
		/* 82061F84h case   19:*/		regs.LR = 0x82061F88; return 0x8208F5B0;
		/* 82061F84h case   19:*/		return 0x82061F88;
		  /* 82061F88h */ case   20:  		/* addi R3, R1, 80 */
		/* 82061F88h case   20:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82061F88h case   20:*/		return 0x82061F8C;
		  /* 82061F8Ch */ case   21:  		/* bl -6764 */
		/* 82061F8Ch case   21:*/		regs.LR = 0x82061F90; return 0x82060520;
		/* 82061F8Ch case   21:*/		return 0x82061F90;
		  /* 82061F90h */ case   22:  		/* li R3, 0 */
		/* 82061F90h case   22:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82061F90h case   22:*/		return 0x82061F94;
		  /* 82061F94h */ case   23:  		/* addi R1, R1, 912 */
		/* 82061F94h case   23:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x390);
		/* 82061F94h case   23:*/		return 0x82061F98;
		  /* 82061F98h */ case   24:  		/* lwz R12, <#[R1 - 8]> */
		/* 82061F98h case   24:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82061F98h case   24:*/		return 0x82061F9C;
		  /* 82061F9Ch */ case   25:  		/* mtspr LR, R12 */
		/* 82061F9Ch case   25:*/		regs.LR = regs.R12;
		/* 82061F9Ch case   25:*/		return 0x82061FA0;
		  /* 82061FA0h */ case   26:  		/* ld R31, <#[R1 - 16]> */
		/* 82061FA0h case   26:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82061FA0h case   26:*/		return 0x82061FA4;
		  /* 82061FA4h */ case   27:  		/* bclr 20, CR0_LT */
		/* 82061FA4h case   27:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82061FA4h case   27:*/		return 0x82061FA8;
	}
	return 0x82061FA8;
} // Block from 82061F38h-82061FA8h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82061FA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82061FA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82061FA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82061FA8);
		  /* 82061FA8h */ case    0:  		/* mfspr R12, LR */
		/* 82061FA8h case    0:*/		regs.R12 = regs.LR;
		/* 82061FA8h case    0:*/		return 0x82061FAC;
		  /* 82061FACh */ case    1:  		/* bl 193168 */
		/* 82061FACh case    1:*/		regs.LR = 0x82061FB0; return 0x8209123C;
		/* 82061FACh case    1:*/		return 0x82061FB0;
		  /* 82061FB0h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 82061FB0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 82061FB0h case    2:*/		return 0x82061FB4;
		  /* 82061FB4h */ case    3:  		/* mr R31, R3 */
		/* 82061FB4h case    3:*/		regs.R31 = regs.R3;
		/* 82061FB4h case    3:*/		return 0x82061FB8;
		  /* 82061FB8h */ case    4:  		/* lwz R3, <#[R3 + 48]> */
		/* 82061FB8h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000030) );
		/* 82061FB8h case    4:*/		return 0x82061FBC;
		  /* 82061FBCh */ case    5:  		/* mr R25, R4 */
		/* 82061FBCh case    5:*/		regs.R25 = regs.R4;
		/* 82061FBCh case    5:*/		return 0x82061FC0;
		  /* 82061FC0h */ case    6:  		/* mr R24, R5 */
		/* 82061FC0h case    6:*/		regs.R24 = regs.R5;
		/* 82061FC0h case    6:*/		return 0x82061FC4;
		  /* 82061FC4h */ case    7:  		/* mr R23, R6 */
		/* 82061FC4h case    7:*/		regs.R23 = regs.R6;
		/* 82061FC4h case    7:*/		return 0x82061FC8;
		  /* 82061FC8h */ case    8:  		/* mr R22, R7 */
		/* 82061FC8h case    8:*/		regs.R22 = regs.R7;
		/* 82061FC8h case    8:*/		return 0x82061FCC;
		  /* 82061FCCh */ case    9:  		/* lwz R11, <#[R31 + 56]> */
		/* 82061FCCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 82061FCCh case    9:*/		return 0x82061FD0;
		  /* 82061FD0h */ case   10:  		/* cmplw CR6, R3, R11 */
		/* 82061FD0h case   10:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 82061FD0h case   10:*/		return 0x82061FD4;
		  /* 82061FD4h */ case   11:  		/* bc 4, CR6_GT, 12 */
		/* 82061FD4h case   11:*/		if ( !regs.CR[6].gt ) { return 0x82061FE0;  }
		/* 82061FD4h case   11:*/		return 0x82061FD8;
		  /* 82061FD8h */ case   12:  		/* mr R3, R31 */
		/* 82061FD8h case   12:*/		regs.R3 = regs.R31;
		/* 82061FD8h case   12:*/		return 0x82061FDC;
		  /* 82061FDCh */ case   13:  		/* bl 74028 */
		/* 82061FDCh case   13:*/		regs.LR = 0x82061FE0; return 0x82074108;
		/* 82061FDCh case   13:*/		return 0x82061FE0;
	}
	return 0x82061FE0;
} // Block from 82061FA8h-82061FE0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82061FE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82061FE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82061FE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82061FE0);
		  /* 82061FE0h */ case    0:  		/* lbz R11, <#[R31 + 11068]> */
		/* 82061FE0h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B3C) );
		/* 82061FE0h case    0:*/		return 0x82061FE4;
		  /* 82061FE4h */ case    1:  		/* rlwinm. R10, R11, 0, 27, 27 */
		/* 82061FE4h case    1:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R11);
		/* 82061FE4h case    1:*/		return 0x82061FE8;
		  /* 82061FE8h */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 82061FE8h case    2:*/		if ( regs.CR[0].eq ) { return 0x82061FF4;  }
		/* 82061FE8h case    2:*/		return 0x82061FEC;
		  /* 82061FECh */ case    3:  		/* li R11, 1 */
		/* 82061FECh case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82061FECh case    3:*/		return 0x82061FF0;
		  /* 82061FF0h */ case    4:  		/* b 148 */
		/* 82061FF0h case    4:*/		return 0x82062084;
		/* 82061FF0h case    4:*/		return 0x82061FF4;
	}
	return 0x82061FF4;
} // Block from 82061FE0h-82061FF4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82061FF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82061FF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82061FF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82061FF4);
		  /* 82061FF4h */ case    0:  		/* rlwinm. R11, R11, 0, 26, 26 */
		/* 82061FF4h case    0:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R11);
		/* 82061FF4h case    0:*/		return 0x82061FF8;
		  /* 82061FF8h */ case    1:  		/* bc 12, CR0_EQ, 132 */
		/* 82061FF8h case    1:*/		if ( regs.CR[0].eq ) { return 0x8206207C;  }
		/* 82061FF8h case    1:*/		return 0x82061FFC;
		  /* 82061FFCh */ case    2:  		/* lwz R11, <#[R31 + 12816]> */
		/* 82061FFCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003210) );
		/* 82061FFCh case    2:*/		return 0x82062000;
		  /* 82062000h */ case    3:  		/* lwz R10, <#[R31 + 13104]> */
		/* 82062000h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00003330) );
		/* 82062000h case    3:*/		return 0x82062004;
		  /* 82062004h */ case    4:  		/* cmplw CR6, R10, R11 */
		/* 82062004h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82062004h case    4:*/		return 0x82062008;
		  /* 82062008h */ case    5:  		/* bc 12, CR6_EQ, 12 */
		/* 82062008h case    5:*/		if ( regs.CR[6].eq ) { return 0x82062014;  }
		/* 82062008h case    5:*/		return 0x8206200C;
		  /* 8206200Ch */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 8206200Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8206200Ch case    6:*/		return 0x82062010;
		  /* 82062010h */ case    7:  		/* bc 4, CR6_EQ, 108 */
		/* 82062010h case    7:*/		if ( !regs.CR[6].eq ) { return 0x8206207C;  }
		/* 82062010h case    7:*/		return 0x82062014;
	}
	return 0x82062014;
} // Block from 82061FF4h-82062014h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82062014h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062014( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062014) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062014);
		  /* 82062014h */ case    0:  		/* lwz R11, <#[R31 + 12820]> */
		/* 82062014h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003214) );
		/* 82062014h case    0:*/		return 0x82062018;
		  /* 82062018h */ case    1:  		/* lwz R10, <#[R31 + 13108]> */
		/* 82062018h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00003334) );
		/* 82062018h case    1:*/		return 0x8206201C;
		  /* 8206201Ch */ case    2:  		/* cmplw CR6, R10, R11 */
		/* 8206201Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8206201Ch case    2:*/		return 0x82062020;
		  /* 82062020h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 82062020h case    3:*/		if ( regs.CR[6].eq ) { return 0x8206202C;  }
		/* 82062020h case    3:*/		return 0x82062024;
		  /* 82062024h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82062024h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82062024h case    4:*/		return 0x82062028;
		  /* 82062028h */ case    5:  		/* bc 4, CR6_EQ, 84 */
		/* 82062028h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8206207C;  }
		/* 82062028h case    5:*/		return 0x8206202C;
	}
	return 0x8206202C;
} // Block from 82062014h-8206202Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8206202Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206202C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206202C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206202C);
		  /* 8206202Ch */ case    0:  		/* lwz R11, <#[R31 + 12824]> */
		/* 8206202Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003218) );
		/* 8206202Ch case    0:*/		return 0x82062030;
		  /* 82062030h */ case    1:  		/* lwz R10, <#[R31 + 13112]> */
		/* 82062030h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00003338) );
		/* 82062030h case    1:*/		return 0x82062034;
		  /* 82062034h */ case    2:  		/* cmplw CR6, R10, R11 */
		/* 82062034h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82062034h case    2:*/		return 0x82062038;
		  /* 82062038h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 82062038h case    3:*/		if ( regs.CR[6].eq ) { return 0x82062044;  }
		/* 82062038h case    3:*/		return 0x8206203C;
		  /* 8206203Ch */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8206203Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8206203Ch case    4:*/		return 0x82062040;
		  /* 82062040h */ case    5:  		/* bc 4, CR6_EQ, 60 */
		/* 82062040h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8206207C;  }
		/* 82062040h case    5:*/		return 0x82062044;
	}
	return 0x82062044;
} // Block from 8206202Ch-82062044h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82062044h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062044( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062044) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062044);
		  /* 82062044h */ case    0:  		/* lwz R11, <#[R31 + 12828]> */
		/* 82062044h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000321C) );
		/* 82062044h case    0:*/		return 0x82062048;
		  /* 82062048h */ case    1:  		/* lwz R10, <#[R31 + 13116]> */
		/* 82062048h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000333C) );
		/* 82062048h case    1:*/		return 0x8206204C;
		  /* 8206204Ch */ case    2:  		/* cmplw CR6, R10, R11 */
		/* 8206204Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8206204Ch case    2:*/		return 0x82062050;
		  /* 82062050h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 82062050h case    3:*/		if ( regs.CR[6].eq ) { return 0x8206205C;  }
		/* 82062050h case    3:*/		return 0x82062054;
		  /* 82062054h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82062054h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82062054h case    4:*/		return 0x82062058;
	}
	return 0x82062058;
} // Block from 82062044h-82062058h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82062058h
// Function '?SetSurfaceInfo@D3D@@YAXPAVCDevice@1@PAUD3DSurface@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062058( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062058) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062058);
		  /* 82062058h */ case    0:  		/* bc 4, CR6_EQ, 36 */
		/* 82062058h case    0:*/		if ( !regs.CR[6].eq ) { return 0x8206207C;  }
		/* 82062058h case    0:*/		return 0x8206205C;
	}
	return 0x8206205C;
} // Block from 82062058h-8206205Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206205Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206205C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206205C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206205C);
		  /* 8206205Ch */ case    0:  		/* lwz R11, <#[R31 + 12832]> */
		/* 8206205Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003220) );
		/* 8206205Ch case    0:*/		return 0x82062060;
		  /* 82062060h */ case    1:  		/* lwz R10, <#[R31 + 13120]> */
		/* 82062060h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00003340) );
		/* 82062060h case    1:*/		return 0x82062064;
		  /* 82062064h */ case    2:  		/* cmplw CR6, R10, R11 */
		/* 82062064h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82062064h case    2:*/		return 0x82062068;
		  /* 82062068h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 82062068h case    3:*/		if ( regs.CR[6].eq ) { return 0x82062074;  }
		/* 82062068h case    3:*/		return 0x8206206C;
		  /* 8206206Ch */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8206206Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8206206Ch case    4:*/		return 0x82062070;
		  /* 82062070h */ case    5:  		/* bc 4, CR6_EQ, 12 */
		/* 82062070h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8206207C;  }
		/* 82062070h case    5:*/		return 0x82062074;
	}
	return 0x82062074;
} // Block from 8206205Ch-82062074h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82062074h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062074( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062074) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062074);
		  /* 82062074h */ case    0:  		/* li R11, 1 */
		/* 82062074h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82062074h case    0:*/		return 0x82062078;
		  /* 82062078h */ case    1:  		/* b 8 */
		/* 82062078h case    1:*/		return 0x82062080;
		/* 82062078h case    1:*/		return 0x8206207C;
	}
	return 0x8206207C;
} // Block from 82062074h-8206207Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206207Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206207C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206207C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206207C);
		  /* 8206207Ch */ case    0:  		/* li R11, 0 */
		/* 8206207Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8206207Ch case    0:*/		return 0x82062080;
	}
	return 0x82062080;
} // Block from 8206207Ch-82062080h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062080h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062080( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062080) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062080);
		  /* 82062080h */ case    0:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 82062080h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82062080h case    0:*/		return 0x82062084;
	}
	return 0x82062084;
} // Block from 82062080h-82062084h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062084h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062084( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062084) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062084);
		  /* 82062084h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82062084h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82062084h case    0:*/		return 0x82062088;
		  /* 82062088h */ case    1:  		/* li R10, 0 */
		/* 82062088h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82062088h case    1:*/		return 0x8206208C;
		  /* 8206208Ch */ case    2:  		/* bc 4, CR0_EQ, 60 */
		/* 8206208Ch case    2:*/		if ( !regs.CR[0].eq ) { return 0x820620C8;  }
		/* 8206208Ch case    2:*/		return 0x82062090;
		  /* 82062090h */ case    3:  		/* lis R11, 2 */
		/* 82062090h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0x2);
		/* 82062090h case    3:*/		return 0x82062094;
		  /* 82062094h */ case    4:  		/* rlwinm R9, R24, 16, 2, 15 */
		/* 82062094h case    4:*/		cpu::op::rlwinm<0,16,2,15>(regs,&regs.R9,regs.R24);
		/* 82062094h case    4:*/		return 0x82062098;
		  /* 82062098h */ case    5:  		/* ori R11, R11, 8320 */
		/* 82062098h case    5:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2080);
		/* 82062098h case    5:*/		return 0x8206209C;
		  /* 8206209Ch */ case    6:  		/* rlwinm R8, R22, 16, 2, 15 */
		/* 8206209Ch case    6:*/		cpu::op::rlwinm<0,16,2,15>(regs,&regs.R8,regs.R22);
		/* 8206209Ch case    6:*/		return 0x820620A0;
		  /* 820620A0h */ case    7:  		/* stwu R11, <#[R3 + 4]> */
		/* 820620A0h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820620A0h case    7:*/		return 0x820620A4;
		  /* 820620A4h */ case    8:  		/* rlwinm R11, R25, 0, 18, 31 */
		/* 820620A4h case    8:*/		cpu::op::rlwinm<0,0,18,31>(regs,&regs.R11,regs.R25);
		/* 820620A4h case    8:*/		return 0x820620A8;
		  /* 820620A8h */ case    9:  		/* or R11, R9, R11 */
		/* 820620A8h case    9:*/		cpu::op::or<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 820620A8h case    9:*/		return 0x820620AC;
		  /* 820620ACh */ case   10:  		/* rlwinm R9, R23, 0, 18, 31 */
		/* 820620ACh case   10:*/		cpu::op::rlwinm<0,0,18,31>(regs,&regs.R9,regs.R23);
		/* 820620ACh case   10:*/		return 0x820620B0;
		  /* 820620B0h */ case   11:  		/* stwu R10, <#[R3 + 4]> */
		/* 820620B0h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820620B0h case   11:*/		return 0x820620B4;
		  /* 820620B4h */ case   12:  		/* or R9, R8, R9 */
		/* 820620B4h case   12:*/		cpu::op::or<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820620B4h case   12:*/		return 0x820620B8;
		  /* 820620B8h */ case   13:  		/* stwu R11, <#[R3 + 4]> */
		/* 820620B8h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820620B8h case   13:*/		return 0x820620BC;
		  /* 820620BCh */ case   14:  		/* mr R11, R3 */
		/* 820620BCh case   14:*/		regs.R11 = regs.R3;
		/* 820620BCh case   14:*/		return 0x820620C0;
		  /* 820620C0h */ case   15:  		/* stwu R9, <#[R11 + 4]> */
		/* 820620C0h case   15:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820620C0h case   15:*/		return 0x820620C4;
		  /* 820620C4h */ case   16:  		/* b 448 */
		/* 820620C4h case   16:*/		return 0x82062284;
		/* 820620C4h case   16:*/		return 0x820620C8;
	}
	return 0x820620C8;
} // Block from 82062084h-820620C8h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820620C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820620C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820620C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820620C8);
		  /* 820620C8h */ case    0:  		/* lis R11, -16384 */
		/* 820620C8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFFC000);
		/* 820620C8h case    0:*/		return 0x820620CC;
		  /* 820620CCh */ case    1:  		/* lis R9, -16384 */
		/* 820620CCh case    1:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFFC000);
		/* 820620CCh case    1:*/		return 0x820620D0;
		  /* 820620D0h */ case    2:  		/* ori R11, R11, 24832 */
		/* 820620D0h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x6100);
		/* 820620D0h case    2:*/		return 0x820620D4;
		  /* 820620D4h */ case    3:  		/* li R27, 0 */
		/* 820620D4h case    3:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 820620D4h case    3:*/		return 0x820620D8;
		  /* 820620D8h */ case    4:  		/* stwu R11, <#[R3 + 4]> */
		/* 820620D8h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820620D8h case    4:*/		return 0x820620DC;
		  /* 820620DCh */ case    5:  		/* ori R26, R9, 24576 */
		/* 820620DCh case    5:*/		cpu::op::ori<0>(regs,&regs.R26,regs.R9,0x6000);
		/* 820620DCh case    5:*/		return 0x820620E0;
		  /* 820620E0h */ case    6:  		/* stwu R10, <#[R3 + 4]> */
		/* 820620E0h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 820620E0h case    6:*/		return 0x820620E4;
		  /* 820620E4h */ case    7:  		/* lwz R10, <#[R31 + 13124]> */
		/* 820620E4h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00003344) );
		/* 820620E4h case    7:*/		return 0x820620E8;
		  /* 820620E8h */ case    8:  		/* mr R11, R3 */
		/* 820620E8h case    8:*/		regs.R11 = regs.R3;
		/* 820620E8h case    8:*/		return 0x820620EC;
		  /* 820620ECh */ case    9:  		/* cmplwi CR6, R10, 0 */
		/* 820620ECh case    9:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820620ECh case    9:*/		return 0x820620F0;
		  /* 820620F0h */ case   10:  		/* bc 4, CR6_GT, 280 */
		/* 820620F0h case   10:*/		if ( !regs.CR[6].gt ) { return 0x82062208;  }
		/* 820620F0h case   10:*/		return 0x820620F4;
		  /* 820620F4h */ case   11:  		/* li R29, 0 */
		/* 820620F4h case   11:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 820620F4h case   11:*/		return 0x820620F8;
		  /* 820620F8h */ case   12:  		/* addi R30, R31, 13132 */
		/* 820620F8h case   12:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x334C);
		/* 820620F8h case   12:*/		return 0x820620FC;
		  /* 820620FCh */ case   13:  		/* addi R28, R31, 13372 */
		/* 820620FCh case   13:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R31,0x343C);
		/* 820620FCh case   13:*/		return 0x82062100;
		  /* 82062100h */ case   14:  		/* lwz R10, <#[R30 - 4]> */
		/* 82062100h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0xFFFFFFFC) );
		/* 82062100h case   14:*/		return 0x82062104;
		  /* 82062104h */ case   15:  		/* mr R7, R25 */
		/* 82062104h case   15:*/		regs.R7 = regs.R25;
		/* 82062104h case   15:*/		return 0x82062108;
	}
	return 0x82062108;
} // Block from 820620C8h-82062108h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82062108h
// Function '?SetSurfaceClip@D3D@@YAXPAVCDevice@1@HHHH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062108( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062108) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062108);
		  /* 82062108h */ case    0:  		/* lwz R6, <#[R28 - 4]> */
		/* 82062108h case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R28 + 0xFFFFFFFC) );
		/* 82062108h case    0:*/		return 0x8206210C;
		  /* 8206210Ch */ case    1:  		/* lwz R5, <#[R28]> */
		/* 8206210Ch case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R28 + 0x00000000) );
		/* 8206210Ch case    1:*/		return 0x82062110;
		  /* 82062110h */ case    2:  		/* cmpw CR6, R25, R10 */
		/* 82062110h case    2:*/		cpu::op::cmpw<6>(regs,regs.R25,regs.R10);
		/* 82062110h case    2:*/		return 0x82062114;
		  /* 82062114h */ case    3:  		/* bc 12, CR6_GT, 8 */
		/* 82062114h case    3:*/		if ( regs.CR[6].gt ) { return 0x8206211C;  }
		/* 82062114h case    3:*/		return 0x82062118;
		  /* 82062118h */ case    4:  		/* mr R7, R10 */
		/* 82062118h case    4:*/		regs.R7 = regs.R10;
		/* 82062118h case    4:*/		return 0x8206211C;
	}
	return 0x8206211C;
} // Block from 82062108h-8206211Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8206211Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206211C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206211C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206211C);
		  /* 8206211Ch */ case    0:  		/* lwz R10, <#[R30]> */
		/* 8206211Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 8206211Ch case    0:*/		return 0x82062120;
		  /* 82062120h */ case    1:  		/* mr R8, R24 */
		/* 82062120h case    1:*/		regs.R8 = regs.R24;
		/* 82062120h case    1:*/		return 0x82062124;
		  /* 82062124h */ case    2:  		/* cmpw CR6, R24, R10 */
		/* 82062124h case    2:*/		cpu::op::cmpw<6>(regs,regs.R24,regs.R10);
		/* 82062124h case    2:*/		return 0x82062128;
		  /* 82062128h */ case    3:  		/* bc 12, CR6_GT, 8 */
		/* 82062128h case    3:*/		if ( regs.CR[6].gt ) { return 0x82062130;  }
		/* 82062128h case    3:*/		return 0x8206212C;
		  /* 8206212Ch */ case    4:  		/* mr R8, R10 */
		/* 8206212Ch case    4:*/		regs.R8 = regs.R10;
		/* 8206212Ch case    4:*/		return 0x82062130;
	}
	return 0x82062130;
} // Block from 8206211Ch-82062130h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82062130h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062130( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062130) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062130);
		  /* 82062130h */ case    0:  		/* lwz R9, <#[R30 + 4]> */
		/* 82062130h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000004) );
		/* 82062130h case    0:*/		return 0x82062134;
		  /* 82062134h */ case    1:  		/* cmpw CR6, R23, R9 */
		/* 82062134h case    1:*/		cpu::op::cmpw<6>(regs,regs.R23,regs.R9);
		/* 82062134h case    1:*/		return 0x82062138;
		  /* 82062138h */ case    2:  		/* bc 4, CR6_LT, 8 */
		/* 82062138h case    2:*/		if ( !regs.CR[6].lt ) { return 0x82062140;  }
		/* 82062138h case    2:*/		return 0x8206213C;
		  /* 8206213Ch */ case    3:  		/* mr R9, R23 */
		/* 8206213Ch case    3:*/		regs.R9 = regs.R23;
		/* 8206213Ch case    3:*/		return 0x82062140;
	}
	return 0x82062140;
} // Block from 82062130h-82062140h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82062140h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062140( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062140) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062140);
		  /* 82062140h */ case    0:  		/* lwz R10, <#[R30 + 8]> */
		/* 82062140h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 82062140h case    0:*/		return 0x82062144;
		  /* 82062144h */ case    1:  		/* cmpw CR6, R22, R10 */
		/* 82062144h case    1:*/		cpu::op::cmpw<6>(regs,regs.R22,regs.R10);
		/* 82062144h case    1:*/		return 0x82062148;
		  /* 82062148h */ case    2:  		/* bc 4, CR6_LT, 8 */
		/* 82062148h case    2:*/		if ( !regs.CR[6].lt ) { return 0x82062150;  }
		/* 82062148h case    2:*/		return 0x8206214C;
		  /* 8206214Ch */ case    3:  		/* mr R10, R22 */
		/* 8206214Ch case    3:*/		regs.R10 = regs.R22;
		/* 8206214Ch case    3:*/		return 0x82062150;
	}
	return 0x82062150;
} // Block from 82062140h-82062150h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82062150h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062150( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062150) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062150);
		  /* 82062150h */ case    0:  		/* cmpw CR6, R7, R9 */
		/* 82062150h case    0:*/		cpu::op::cmpw<6>(regs,regs.R7,regs.R9);
		/* 82062150h case    0:*/		return 0x82062154;
		  /* 82062154h */ case    1:  		/* bc 4, CR6_LT, 12 */
		/* 82062154h case    1:*/		if ( !regs.CR[6].lt ) { return 0x82062160;  }
		/* 82062154h case    1:*/		return 0x82062158;
		  /* 82062158h */ case    2:  		/* cmpw CR6, R8, R10 */
		/* 82062158h case    2:*/		cpu::op::cmpw<6>(regs,regs.R8,regs.R10);
		/* 82062158h case    2:*/		return 0x8206215C;
		  /* 8206215Ch */ case    3:  		/* bc 12, CR6_LT, 20 */
		/* 8206215Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x82062170;  }
		/* 8206215Ch case    3:*/		return 0x82062160;
	}
	return 0x82062160;
} // Block from 82062150h-82062160h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82062160h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062160( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062160) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062160);
		  /* 82062160h */ case    0:  		/* li R10, 0 */
		/* 82062160h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82062160h case    0:*/		return 0x82062164;
		  /* 82062164h */ case    1:  		/* li R9, 0 */
		/* 82062164h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82062164h case    1:*/		return 0x82062168;
		  /* 82062168h */ case    2:  		/* li R8, 0 */
		/* 82062168h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82062168h case    2:*/		return 0x8206216C;
		  /* 8206216Ch */ case    3:  		/* li R7, 0 */
		/* 8206216Ch case    3:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8206216Ch case    3:*/		return 0x82062170;
	}
	return 0x82062170;
} // Block from 82062160h-82062170h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82062170h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062170( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062170) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062170);
		  /* 82062170h */ case    0:  		/* stwu R26, <#[R11 + 4]> */
		/* 82062170h case    0:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82062170h case    0:*/		return 0x82062174;
		  /* 82062174h */ case    1:  		/* li R3, 3 */
		/* 82062174h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x3);
		/* 82062174h case    1:*/		return 0x82062178;
		  /* 82062178h */ case    2:  		/* mr R4, R26 */
		/* 82062178h case    2:*/		regs.R4 = regs.R26;
		/* 82062178h case    2:*/		return 0x8206217C;
		  /* 8206217Ch */ case    3:  		/* slw R3, R3, R29 */
		/* 8206217Ch case    3:*/		cpu::op::slw<0>(regs,&regs.R3,regs.R3,regs.R29);
		/* 8206217Ch case    3:*/		return 0x82062180;
		  /* 82062180h */ case    4:  		/* stwu R3, <#[R11 + 4]> */
		/* 82062180h case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82062180h case    4:*/		return 0x82062184;
		  /* 82062184h */ case    5:  		/* lis R4, -16381 */
		/* 82062184h case    5:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFFC003);
		/* 82062184h case    5:*/		return 0x82062188;
		  /* 82062188h */ case    6:  		/* neg R6, R6 */
		/* 82062188h case    6:*/		cpu::op::neg<0>(regs,&regs.R6,regs.R6);
		/* 82062188h case    6:*/		return 0x8206218C;
		  /* 8206218Ch */ case    7:  		/* ori R4, R4, 21761 */
		/* 8206218Ch case    7:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0x5501);
		/* 8206218Ch case    7:*/		return 0x82062190;
		  /* 82062190h */ case    8:  		/* li R21, 8320 */
		/* 82062190h case    8:*/		cpu::op::li<0>(regs,&regs.R21,0x2080);
		/* 82062190h case    8:*/		return 0x82062194;
		  /* 82062194h */ case    9:  		/* neg R5, R5 */
		/* 82062194h case    9:*/		cpu::op::neg<0>(regs,&regs.R5,regs.R5);
		/* 82062194h case    9:*/		return 0x82062198;
		  /* 82062198h */ case   10:  		/* stwu R4, <#[R11 + 4]> */
		/* 82062198h case   10:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82062198h case   10:*/		return 0x8206219C;
		  /* 8206219Ch */ case   11:  		/* rlwinm R6, R6, 0, 17, 31 */
		/* 8206219Ch case   11:*/		cpu::op::rlwinm<0,0,17,31>(regs,&regs.R6,regs.R6);
		/* 8206219Ch case   11:*/		return 0x820621A0;
		  /* 820621A0h */ case   12:  		/* rlwinm R5, R5, 16, 1, 15 */
		/* 820621A0h case   12:*/		cpu::op::rlwinm<0,16,1,15>(regs,&regs.R5,regs.R5);
		/* 820621A0h case   12:*/		return 0x820621A4;
		  /* 820621A4h */ case   13:  		/* rlwinm R8, R8, 16, 2, 15 */
		/* 820621A4h case   13:*/		cpu::op::rlwinm<0,16,2,15>(regs,&regs.R8,regs.R8);
		/* 820621A4h case   13:*/		return 0x820621A8;
		  /* 820621A8h */ case   14:  		/* or R6, R5, R6 */
		/* 820621A8h case   14:*/		cpu::op::or<0>(regs,&regs.R6,regs.R5,regs.R6);
		/* 820621A8h case   14:*/		return 0x820621AC;
		  /* 820621ACh */ case   15:  		/* rlwinm R7, R7, 0, 18, 31 */
		/* 820621ACh case   15:*/		cpu::op::rlwinm<0,0,18,31>(regs,&regs.R7,regs.R7);
		/* 820621ACh case   15:*/		return 0x820621B0;
		  /* 820621B0h */ case   16:  		/* stwu R21, <#[R11 + 4]> */
		/* 820621B0h case   16:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820621B0h case   16:*/		return 0x820621B4;
		  /* 820621B4h */ case   17:  		/* rlwinm R10, R10, 16, 2, 15 */
		/* 820621B4h case   17:*/		cpu::op::rlwinm<0,16,2,15>(regs,&regs.R10,regs.R10);
		/* 820621B4h case   17:*/		return 0x820621B8;
		  /* 820621B8h */ case   18:  		/* or R8, R8, R7 */
		/* 820621B8h case   18:*/		cpu::op::or<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 820621B8h case   18:*/		return 0x820621BC;
		  /* 820621BCh */ case   19:  		/* rlwinm R9, R9, 0, 18, 31 */
		/* 820621BCh case   19:*/		cpu::op::rlwinm<0,0,18,31>(regs,&regs.R9,regs.R9);
		/* 820621BCh case   19:*/		return 0x820621C0;
		  /* 820621C0h */ case   20:  		/* or R10, R10, R9 */
		/* 820621C0h case   20:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 820621C0h case   20:*/		return 0x820621C4;
		  /* 820621C4h */ case   21:  		/* stwu R6, <#[R11 + 4]> */
		/* 820621C4h case   21:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820621C4h case   21:*/		return 0x820621C8;
		  /* 820621C8h */ case   22:  		/* stwu R8, <#[R11 + 4]> */
		/* 820621C8h case   22:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820621C8h case   22:*/		return 0x820621CC;
		  /* 820621CCh */ case   23:  		/* stwu R10, <#[R11 + 4]> */
		/* 820621CCh case   23:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820621CCh case   23:*/		return 0x820621D0;
		  /* 820621D0h */ case   24:  		/* lwz R10, <#[R31 + 56]> */
		/* 820621D0h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000038) );
		/* 820621D0h case   24:*/		return 0x820621D4;
		  /* 820621D4h */ case   25:  		/* cmplw CR6, R11, R10 */
		/* 820621D4h case   25:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820621D4h case   25:*/		return 0x820621D8;
		  /* 820621D8h */ case   26:  		/* stw R11, <#[R31 + 48]> */
		/* 820621D8h case   26:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 820621D8h case   26:*/		return 0x820621DC;
		  /* 820621DCh */ case   27:  		/* bc 4, CR6_GT, 16 */
		/* 820621DCh case   27:*/		if ( !regs.CR[6].gt ) { return 0x820621EC;  }
		/* 820621DCh case   27:*/		return 0x820621E0;
		  /* 820621E0h */ case   28:  		/* mr R3, R31 */
		/* 820621E0h case   28:*/		regs.R3 = regs.R31;
		/* 820621E0h case   28:*/		return 0x820621E4;
		  /* 820621E4h */ case   29:  		/* bl 73508 */
		/* 820621E4h case   29:*/		regs.LR = 0x820621E8; return 0x82074108;
		/* 820621E4h case   29:*/		return 0x820621E8;
		  /* 820621E8h */ case   30:  		/* mr R11, R3 */
		/* 820621E8h case   30:*/		regs.R11 = regs.R3;
		/* 820621E8h case   30:*/		return 0x820621EC;
	}
	return 0x820621EC;
} // Block from 82062170h-820621ECh (31 instructions)

//////////////////////////////////////////////////////
// Block at 820621ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820621EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820621EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820621EC);
		  /* 820621ECh */ case    0:  		/* lwz R10, <#[R31 + 13124]> */
		/* 820621ECh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00003344) );
		/* 820621ECh case    0:*/		return 0x820621F0;
		  /* 820621F0h */ case    1:  		/* addi R27, R27, 1 */
		/* 820621F0h case    1:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 820621F0h case    1:*/		return 0x820621F4;
		  /* 820621F4h */ case    2:  		/* addi R28, R28, 8 */
		/* 820621F4h case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x8);
		/* 820621F4h case    2:*/		return 0x820621F8;
		  /* 820621F8h */ case    3:  		/* addi R30, R30, 16 */
		/* 820621F8h case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x10);
		/* 820621F8h case    3:*/		return 0x820621FC;
		  /* 820621FCh */ case    4:  		/* addi R29, R29, 2 */
		/* 820621FCh case    4:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x2);
		/* 820621FCh case    4:*/		return 0x82062200;
		  /* 82062200h */ case    5:  		/* cmplw CR6, R27, R10 */
		/* 82062200h case    5:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R10);
		/* 82062200h case    5:*/		return 0x82062204;
		  /* 82062204h */ case    6:  		/* bc 12, CR6_LT, -260 */
		/* 82062204h case    6:*/		if ( regs.CR[6].lt ) { return 0x82062100;  }
		/* 82062204h case    6:*/		return 0x82062208;
	}
	return 0x82062208;
} // Block from 820621ECh-82062208h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82062208h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062208( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062208) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062208);
		  /* 82062208h */ case    0:  		/* lbz R10, <#[R31 + 11071]> */
		/* 82062208h case    0:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x00002B3F) );
		/* 82062208h case    0:*/		return 0x8206220C;
		  /* 8206220Ch */ case    1:  		/* rlwinm. R10, R10, 0, 26, 26 */
		/* 8206220Ch case    1:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R10,regs.R10);
		/* 8206220Ch case    1:*/		return 0x82062210;
		  /* 82062210h */ case    2:  		/* bc 12, CR0_EQ, 84 */
		/* 82062210h case    2:*/		if ( regs.CR[0].eq ) { return 0x82062264;  }
		/* 82062210h case    2:*/		return 0x82062214;
		  /* 82062214h */ case    3:  		/* lbz R10, <#[R31 + 11068]> */
		/* 82062214h case    3:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x00002B3C) );
		/* 82062214h case    3:*/		return 0x82062218;
		  /* 82062218h */ case    4:  		/* rlwinm. R10, R10, 0, 25, 25 */
		/* 82062218h case    4:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R10,regs.R10);
		/* 82062218h case    4:*/		return 0x8206221C;
		  /* 8206221Ch */ case    5:  		/* bc 12, CR0_EQ, 72 */
		/* 8206221Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x82062264;  }
		/* 8206221Ch case    5:*/		return 0x82062220;
		  /* 82062220h */ case    6:  		/* stwu R26, <#[R11 + 4]> */
		/* 82062220h case    6:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82062220h case    6:*/		return 0x82062224;
		  /* 82062224h */ case    7:  		/* li R9, 1 */
		/* 82062224h case    7:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82062224h case    7:*/		return 0x82062228;
		  /* 82062228h */ case    8:  		/* lis R8, -16382 */
		/* 82062228h case    8:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFFC002);
		/* 82062228h case    8:*/		return 0x8206222C;
		  /* 8206222Ch */ case    9:  		/* mr R10, R26 */
		/* 8206222Ch case    9:*/		regs.R10 = regs.R26;
		/* 8206222Ch case    9:*/		return 0x82062230;
		  /* 82062230h */ case   10:  		/* ori R10, R8, 21761 */
		/* 82062230h case   10:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R8,0x5501);
		/* 82062230h case   10:*/		return 0x82062234;
		  /* 82062234h */ case   11:  		/* li R7, 8321 */
		/* 82062234h case   11:*/		cpu::op::li<0>(regs,&regs.R7,0x2081);
		/* 82062234h case   11:*/		return 0x82062238;
		  /* 82062238h */ case   12:  		/* stwu R9, <#[R11 + 4]> */
		/* 82062238h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82062238h case   12:*/		return 0x8206223C;
		  /* 8206223Ch */ case   13:  		/* rlwinm R6, R25, 0, 18, 31 */
		/* 8206223Ch case   13:*/		cpu::op::rlwinm<0,0,18,31>(regs,&regs.R6,regs.R25);
		/* 8206223Ch case   13:*/		return 0x82062240;
		  /* 82062240h */ case   14:  		/* rlwinm R8, R24, 16, 2, 15 */
		/* 82062240h case   14:*/		cpu::op::rlwinm<0,16,2,15>(regs,&regs.R8,regs.R24);
		/* 82062240h case   14:*/		return 0x82062244;
		  /* 82062244h */ case   15:  		/* rlwinm R5, R22, 16, 2, 15 */
		/* 82062244h case   15:*/		cpu::op::rlwinm<0,16,2,15>(regs,&regs.R5,regs.R22);
		/* 82062244h case   15:*/		return 0x82062248;
		  /* 82062248h */ case   16:  		/* or R8, R8, R6 */
		/* 82062248h case   16:*/		cpu::op::or<0>(regs,&regs.R8,regs.R8,regs.R6);
		/* 82062248h case   16:*/		return 0x8206224C;
		  /* 8206224Ch */ case   17:  		/* rlwinm R6, R23, 0, 18, 31 */
		/* 8206224Ch case   17:*/		cpu::op::rlwinm<0,0,18,31>(regs,&regs.R6,regs.R23);
		/* 8206224Ch case   17:*/		return 0x82062250;
		  /* 82062250h */ case   18:  		/* stwu R10, <#[R11 + 4]> */
		/* 82062250h case   18:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82062250h case   18:*/		return 0x82062254;
		  /* 82062254h */ case   19:  		/* or R9, R5, R6 */
		/* 82062254h case   19:*/		cpu::op::or<0>(regs,&regs.R9,regs.R5,regs.R6);
		/* 82062254h case   19:*/		return 0x82062258;
		  /* 82062258h */ case   20:  		/* stwu R7, <#[R11 + 4]> */
		/* 82062258h case   20:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82062258h case   20:*/		return 0x8206225C;
		  /* 8206225Ch */ case   21:  		/* stwu R8, <#[R11 + 4]> */
		/* 8206225Ch case   21:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206225Ch case   21:*/		return 0x82062260;
		  /* 82062260h */ case   22:  		/* stwu R9, <#[R11 + 4]> */
		/* 82062260h case   22:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82062260h case   22:*/		return 0x82062264;
	}
	return 0x82062264;
} // Block from 82062208h-82062264h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82062264h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062264( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062264) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062264);
		  /* 82062264h */ case    0:  		/* stwu R26, <#[R11 + 4]> */
		/* 82062264h case    0:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82062264h case    0:*/		return 0x82062268;
		  /* 82062268h */ case    1:  		/* lis R10, -16384 */
		/* 82062268h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFC000);
		/* 82062268h case    1:*/		return 0x8206226C;
		  /* 8206226Ch */ case    2:  		/* lwz R9, <#[R31 + 13084]> */
		/* 8206226Ch case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000331C) );
		/* 8206226Ch case    2:*/		return 0x82062270;
		  /* 82062270h */ case    3:  		/* ori R10, R10, 24832 */
		/* 82062270h case    3:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x6100);
		/* 82062270h case    3:*/		return 0x82062274;
		  /* 82062274h */ case    4:  		/* stwu R9, <#[R11 + 4]> */
		/* 82062274h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82062274h case    4:*/		return 0x82062278;
		  /* 82062278h */ case    5:  		/* stwu R10, <#[R11 + 4]> */
		/* 82062278h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82062278h case    5:*/		return 0x8206227C;
		  /* 8206227Ch */ case    6:  		/* lwz R10, <#[R31 + 13088]> */
		/* 8206227Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00003320) );
		/* 8206227Ch case    6:*/		return 0x82062280;
		  /* 82062280h */ case    7:  		/* stwu R10, <#[R11 + 4]> */
		/* 82062280h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82062280h case    7:*/		return 0x82062284;
	}
	return 0x82062284;
} // Block from 82062264h-82062284h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82062284h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062284( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062284) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062284);
		  /* 82062284h */ case    0:  		/* stw R11, <#[R31 + 48]> */
		/* 82062284h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 82062284h case    0:*/		return 0x82062288;
		  /* 82062288h */ case    1:  		/* addi R1, R1, 176 */
		/* 82062288h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 82062288h case    1:*/		return 0x8206228C;
		  /* 8206228Ch */ case    2:  		/* b 192512 */
		/* 8206228Ch case    2:*/		return 0x8209128C;
		/* 8206228Ch case    2:*/		return 0x82062290;
	}
	return 0x82062290;
} // Block from 82062284h-82062290h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82062290h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062290( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062290) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062290);
		  /* 82062290h */ case    0:  		/* lwz R11, <#[R3 + 10568]> */
		/* 82062290h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002948) );
		/* 82062290h case    0:*/		return 0x82062294;
		  /* 82062294h */ case    1:  		/* rlwimi R4, R11, 0, 0, 28 */
		/* 82062294h case    1:*/		cpu::op::rlwimi<0,0,0,28>(regs,&regs.R4,regs.R11);
		/* 82062294h case    1:*/		return 0x82062298;
		  /* 82062298h */ case    2:  		/* stw R4, <#[R3 + 10568]> */
		/* 82062298h case    2:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00002948) );
		/* 82062298h case    2:*/		return 0x8206229C;
		  /* 8206229Ch */ case    3:  		/* ld R11, <#[R3 + 16]> */
		/* 8206229Ch case    3:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8206229Ch case    3:*/		return 0x820622A0;
		  /* 820622A0h */ case    4:  		/* ori R11, R11, 64 */
		/* 820622A0h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x40);
		/* 820622A0h case    4:*/		return 0x820622A4;
		  /* 820622A4h */ case    5:  		/* std R11, <#[R3 + 16]> */
		/* 820622A4h case    5:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820622A4h case    5:*/		return 0x820622A8;
		  /* 820622A8h */ case    6:  		/* bclr 20, CR0_LT */
		/* 820622A8h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820622A8h case    6:*/		return 0x820622AC;
	}
	return 0x820622AC;
} // Block from 82062290h-820622ACh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820622ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820622AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820622AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820622AC);
		  /* 820622ACh */ case    0:  		/* nop */
		/* 820622ACh case    0:*/		cpu::op::nop();
		/* 820622ACh case    0:*/		return 0x820622B0;
	}
	return 0x820622B0;
} // Block from 820622ACh-820622B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820622B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820622B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820622B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820622B0);
		  /* 820622B0h */ case    0:  		/* lwz R11, <#[R3 + 10568]> */
		/* 820622B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002948) );
		/* 820622B0h case    0:*/		return 0x820622B4;
		  /* 820622B4h */ case    1:  		/* rlwinm R3, R11, 0, 29, 31 */
		/* 820622B4h case    1:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R3,regs.R11);
		/* 820622B4h case    1:*/		return 0x820622B8;
		  /* 820622B8h */ case    2:  		/* bclr 20, CR0_LT */
		/* 820622B8h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820622B8h case    2:*/		return 0x820622BC;
	}
	return 0x820622BC;
} // Block from 820622B0h-820622BCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820622BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820622BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820622BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820622BC);
		  /* 820622BCh */ case    0:  		/* nop */
		/* 820622BCh case    0:*/		cpu::op::nop();
		/* 820622BCh case    0:*/		return 0x820622C0;
	}
	return 0x820622C0;
} // Block from 820622BCh-820622C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820622C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820622C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820622C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820622C0);
		  /* 820622C0h */ case    0:  		/* lwz R11, <#[R3 + 10568]> */
		/* 820622C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002948) );
		/* 820622C0h case    0:*/		return 0x820622C4;
		  /* 820622C4h */ case    1:  		/* rlwimi R11, R4, 3, 21, 28 */
		/* 820622C4h case    1:*/		cpu::op::rlwimi<0,3,21,28>(regs,&regs.R11,regs.R4);
		/* 820622C4h case    1:*/		return 0x820622C8;
		  /* 820622C8h */ case    2:  		/* stw R11, <#[R3 + 10568]> */
		/* 820622C8h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002948) );
		/* 820622C8h case    2:*/		return 0x820622CC;
		  /* 820622CCh */ case    3:  		/* ld R11, <#[R3 + 16]> */
		/* 820622CCh case    3:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820622CCh case    3:*/		return 0x820622D0;
		  /* 820622D0h */ case    4:  		/* ori R11, R11, 64 */
		/* 820622D0h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x40);
		/* 820622D0h case    4:*/		return 0x820622D4;
		  /* 820622D4h */ case    5:  		/* std R11, <#[R3 + 16]> */
		/* 820622D4h case    5:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820622D4h case    5:*/		return 0x820622D8;
		  /* 820622D8h */ case    6:  		/* bclr 20, CR0_LT */
		/* 820622D8h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820622D8h case    6:*/		return 0x820622DC;
	}
	return 0x820622DC;
} // Block from 820622C0h-820622DCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820622DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820622DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820622DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820622DC);
		  /* 820622DCh */ case    0:  		/* nop */
		/* 820622DCh case    0:*/		cpu::op::nop();
		/* 820622DCh case    0:*/		return 0x820622E0;
	}
	return 0x820622E0;
} // Block from 820622DCh-820622E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820622E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820622E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820622E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820622E0);
		  /* 820622E0h */ case    0:  		/* lwz R11, <#[R3 + 10568]> */
		/* 820622E0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002948) );
		/* 820622E0h case    0:*/		return 0x820622E4;
		  /* 820622E4h */ case    1:  		/* rlwinm R3, R11, 29, 24, 31 */
		/* 820622E4h case    1:*/		cpu::op::rlwinm<0,29,24,31>(regs,&regs.R3,regs.R11);
		/* 820622E4h case    1:*/		return 0x820622E8;
		  /* 820622E8h */ case    2:  		/* bclr 20, CR0_LT */
		/* 820622E8h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820622E8h case    2:*/		return 0x820622EC;
	}
	return 0x820622EC;
} // Block from 820622E0h-820622ECh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820622ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820622EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820622EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820622EC);
		  /* 820622ECh */ case    0:  		/* nop */
		/* 820622ECh case    0:*/		cpu::op::nop();
		/* 820622ECh case    0:*/		return 0x820622F0;
	}
	return 0x820622F0;
} // Block from 820622ECh-820622F0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820622F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820622F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820622F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820622F0);
		  /* 820622F0h */ case    0:  		/* lwz R11, <#[R3 + 10556]> */
		/* 820622F0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000293C) );
		/* 820622F0h case    0:*/		return 0x820622F4;
		  /* 820622F4h */ case    1:  		/* rlwimi R11, R4, 3, 28, 28 */
		/* 820622F4h case    1:*/		cpu::op::rlwimi<0,3,28,28>(regs,&regs.R11,regs.R4);
		/* 820622F4h case    1:*/		return 0x820622F8;
		  /* 820622F8h */ case    2:  		/* stw R11, <#[R3 + 10556]> */
		/* 820622F8h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000293C) );
		/* 820622F8h case    2:*/		return 0x820622FC;
		  /* 820622FCh */ case    3:  		/* ld R11, <#[R3 + 16]> */
		/* 820622FCh case    3:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820622FCh case    3:*/		return 0x82062300;
		  /* 82062300h */ case    4:  		/* ori R11, R11, 512 */
		/* 82062300h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x200);
		/* 82062300h case    4:*/		return 0x82062304;
		  /* 82062304h */ case    5:  		/* std R11, <#[R3 + 16]> */
		/* 82062304h case    5:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062304h case    5:*/		return 0x82062308;
		  /* 82062308h */ case    6:  		/* oris R11, R11, 4 */
		/* 82062308h case    6:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82062308h case    6:*/		return 0x8206230C;
		  /* 8206230Ch */ case    7:  		/* std R11, <#[R3 + 16]> */
		/* 8206230Ch case    7:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8206230Ch case    7:*/		return 0x82062310;
		  /* 82062310h */ case    8:  		/* bclr 20, CR0_LT */
		/* 82062310h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062310h case    8:*/		return 0x82062314;
	}
	return 0x82062314;
} // Block from 820622F0h-82062314h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82062314h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062314( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062314) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062314);
		  /* 82062314h */ case    0:  		/* nop */
		/* 82062314h case    0:*/		cpu::op::nop();
		/* 82062314h case    0:*/		return 0x82062318;
	}
	return 0x82062318;
} // Block from 82062314h-82062318h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062318h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062318( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062318) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062318);
		  /* 82062318h */ case    0:  		/* lwz R11, <#[R3 + 10556]> */
		/* 82062318h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000293C) );
		/* 82062318h case    0:*/		return 0x8206231C;
		  /* 8206231Ch */ case    1:  		/* rlwinm R3, R11, 29, 31, 31 */
		/* 8206231Ch case    1:*/		cpu::op::rlwinm<0,29,31,31>(regs,&regs.R3,regs.R11);
		/* 8206231Ch case    1:*/		return 0x82062320;
		  /* 82062320h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82062320h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062320h case    2:*/		return 0x82062324;
	}
	return 0x82062324;
} // Block from 82062318h-82062324h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82062324h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062324( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062324) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062324);
		  /* 82062324h */ case    0:  		/* nop */
		/* 82062324h case    0:*/		cpu::op::nop();
		/* 82062324h case    0:*/		return 0x82062328;
	}
	return 0x82062328;
} // Block from 82062324h-82062328h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062328h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062328( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062328) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062328);
		  /* 82062328h */ case    0:  		/* lwz R11, <#[R3 + 12284]> */
		/* 82062328h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002FFC) );
		/* 82062328h case    0:*/		return 0x8206232C;
		  /* 8206232Ch */ case    1:  		/* rlwimi R11, R4, 31, 0, 0 */
		/* 8206232Ch case    1:*/		cpu::op::rlwimi<0,31,0,0>(regs,&regs.R11,regs.R4);
		/* 8206232Ch case    1:*/		return 0x82062330;
		  /* 82062330h */ case    2:  		/* stw R11, <#[R3 + 12284]> */
		/* 82062330h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002FFC) );
		/* 82062330h case    2:*/		return 0x82062334;
		  /* 82062334h */ case    3:  		/* rlwinm. R10, R11, 0, 1, 1 */
		/* 82062334h case    3:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R11);
		/* 82062334h case    3:*/		return 0x82062338;
		  /* 82062338h */ case    4:  		/* lwz R11, <#[R3 + 12280]> */
		/* 82062338h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002FF8) );
		/* 82062338h case    4:*/		return 0x8206233C;
		  /* 8206233Ch */ case    5:  		/* bc 4, CR0_EQ, 36 */
		/* 8206233Ch case    5:*/		if ( !regs.CR[0].eq ) { return 0x82062360;  }
		/* 8206233Ch case    5:*/		return 0x82062340;
		  /* 82062340h */ case    6:  		/* andi. R10, R11, 4112 */
		/* 82062340h case    6:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R11,0x1010);
		/* 82062340h case    6:*/		return 0x82062344;
		  /* 82062344h */ case    7:  		/* rlwinm R9, R11, 4, 12, 27 */
		/* 82062344h case    7:*/		cpu::op::rlwinm<0,4,12,27>(regs,&regs.R9,regs.R11);
		/* 82062344h case    7:*/		return 0x82062348;
		  /* 82062348h */ case    8:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 82062348h case    8:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 82062348h case    8:*/		return 0x8206234C;
		  /* 8206234Ch */ case    9:  		/* or R10, R10, R9 */
		/* 8206234Ch case    9:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8206234Ch case    9:*/		return 0x82062350;
		  /* 82062350h */ case   10:  		/* rlwinm R10, R10, 12, 0, 15 */
		/* 82062350h case   10:*/		cpu::op::rlwinm<0,12,0,15>(regs,&regs.R10,regs.R10);
		/* 82062350h case   10:*/		return 0x82062354;
		  /* 82062354h */ case   11:  		/* rlwinm R10, R10, 0, 12, 10 */
		/* 82062354h case   11:*/		cpu::op::rlwinm<0,0,12,10>(regs,&regs.R10,regs.R10);
		/* 82062354h case   11:*/		return 0x82062358;
		  /* 82062358h */ case   12:  		/* rlwinm R10, R10, 0, 4, 2 */
		/* 82062358h case   12:*/		cpu::op::rlwinm<0,0,4,2>(regs,&regs.R10,regs.R10);
		/* 82062358h case   12:*/		return 0x8206235C;
		  /* 8206235Ch */ case   13:  		/* or R11, R10, R11 */
		/* 8206235Ch case   13:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8206235Ch case   13:*/		return 0x82062360;
	}
	return 0x82062360;
} // Block from 82062328h-82062360h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82062360h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062360( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062360) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062360);
		  /* 82062360h */ case    0:  		/* cmpwi CR6, R4, 0 */
		/* 82062360h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000000);
		/* 82062360h case    0:*/		return 0x82062364;
		  /* 82062364h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 82062364h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82062370;  }
		/* 82062364h case    1:*/		return 0x82062368;
		  /* 82062368h */ case    2:  		/* lis R11, 1 */
		/* 82062368h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0x1);
		/* 82062368h case    2:*/		return 0x8206236C;
		  /* 8206236Ch */ case    3:  		/* ori R11, R11, 1 */
		/* 8206236Ch case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8206236Ch case    3:*/		return 0x82062370;
	}
	return 0x82062370;
} // Block from 82062360h-82062370h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82062370h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062370( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062370) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062370);
		  /* 82062370h */ case    0:  		/* stw R11, <#[R3 + 10588]> */
		/* 82062370h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000295C) );
		/* 82062370h case    0:*/		return 0x82062374;
		  /* 82062374h */ case    1:  		/* stw R11, <#[R3 + 10552]> */
		/* 82062374h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002938) );
		/* 82062374h case    1:*/		return 0x82062378;
		  /* 82062378h */ case    2:  		/* stw R11, <#[R3 + 10584]> */
		/* 82062378h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002958) );
		/* 82062378h case    2:*/		return 0x8206237C;
		  /* 8206237Ch */ case    3:  		/* stw R11, <#[R3 + 10592]> */
		/* 8206237Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002960) );
		/* 8206237Ch case    3:*/		return 0x82062380;
		  /* 82062380h */ case    4:  		/* ld R11, <#[R3 + 16]> */
		/* 82062380h case    4:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062380h case    4:*/		return 0x82062384;
		  /* 82062384h */ case    5:  		/* ori R11, R11, 1024 */
		/* 82062384h case    5:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x400);
		/* 82062384h case    5:*/		return 0x82062388;
		  /* 82062388h */ case    6:  		/* std R11, <#[R3 + 16]> */
		/* 82062388h case    6:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062388h case    6:*/		return 0x8206238C;
		  /* 8206238Ch */ case    7:  		/* ori R11, R11, 4 */
		/* 8206238Ch case    7:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8206238Ch case    7:*/		return 0x82062390;
		  /* 82062390h */ case    8:  		/* std R11, <#[R3 + 16]> */
		/* 82062390h case    8:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062390h case    8:*/		return 0x82062394;
		  /* 82062394h */ case    9:  		/* ori R11, R11, 2 */
		/* 82062394h case    9:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82062394h case    9:*/		return 0x82062398;
		  /* 82062398h */ case   10:  		/* std R11, <#[R3 + 16]> */
		/* 82062398h case   10:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062398h case   10:*/		return 0x8206239C;
		  /* 8206239Ch */ case   11:  		/* ori R11, R11, 1 */
		/* 8206239Ch case   11:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8206239Ch case   11:*/		return 0x820623A0;
		  /* 820623A0h */ case   12:  		/* std R11, <#[R3 + 16]> */
		/* 820623A0h case   12:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820623A0h case   12:*/		return 0x820623A4;
		  /* 820623A4h */ case   13:  		/* bclr 20, CR0_LT */
		/* 820623A4h case   13:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820623A4h case   13:*/		return 0x820623A8;
	}
	return 0x820623A8;
} // Block from 82062370h-820623A8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820623A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820623A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820623A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820623A8);
		  /* 820623A8h */ case    0:  		/* lwz R11, <#[R3 + 12284]> */
		/* 820623A8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002FFC) );
		/* 820623A8h case    0:*/		return 0x820623AC;
		  /* 820623ACh */ case    1:  		/* rlwinm R3, R11, 1, 31, 31 */
		/* 820623ACh case    1:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R3,regs.R11);
		/* 820623ACh case    1:*/		return 0x820623B0;
		  /* 820623B0h */ case    2:  		/* bclr 20, CR0_LT */
		/* 820623B0h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820623B0h case    2:*/		return 0x820623B4;
	}
	return 0x820623B4;
} // Block from 820623A8h-820623B4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820623B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820623B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820623B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820623B4);
		  /* 820623B4h */ case    0:  		/* nop */
		/* 820623B4h case    0:*/		cpu::op::nop();
		/* 820623B4h case    0:*/		return 0x820623B8;
	}
	return 0x820623B8;
} // Block from 820623B4h-820623B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820623B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820623B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820623B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820623B8);
		  /* 820623B8h */ case    0:  		/* lwz R10, <#[R3 + 12280]> */
		/* 820623B8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00002FF8) );
		/* 820623B8h case    0:*/		return 0x820623BC;
		  /* 820623BCh */ case    1:  		/* lwz R11, <#[R3 + 12284]> */
		/* 820623BCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002FFC) );
		/* 820623BCh case    1:*/		return 0x820623C0;
		  /* 820623C0h */ case    2:  		/* rlwimi R10, R4, 5, 24, 26 */
		/* 820623C0h case    2:*/		cpu::op::rlwimi<0,5,24,26>(regs,&regs.R10,regs.R4);
		/* 820623C0h case    2:*/		return 0x820623C4;
		  /* 820623C4h */ case    3:  		/* rlwinm. R9, R11, 0, 0, 0 */
		/* 820623C4h case    3:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R9,regs.R11);
		/* 820623C4h case    3:*/		return 0x820623C8;
		  /* 820623C8h */ case    4:  		/* stw R10, <#[R3 + 12280]> */
		/* 820623C8h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00002FF8) );
		/* 820623C8h case    4:*/		return 0x820623CC;
		  /* 820623CCh */ case    5:  		/* bclr 12, CR0_EQ */
		/* 820623CCh case    5:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 820623CCh case    5:*/		return 0x820623D0;
	}
	return 0x820623D0;
} // Block from 820623B8h-820623D0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820623D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820623D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820623D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820623D0);
		  /* 820623D0h */ case    0:  		/* rlwinm. R10, R11, 0, 1, 1 */
		/* 820623D0h case    0:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R11);
		/* 820623D0h case    0:*/		return 0x820623D4;
		  /* 820623D4h */ case    1:  		/* lwz R11, <#[R3 + 12280]> */
		/* 820623D4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002FF8) );
		/* 820623D4h case    1:*/		return 0x820623D8;
		  /* 820623D8h */ case    2:  		/* bc 4, CR0_EQ, 36 */
		/* 820623D8h case    2:*/		if ( !regs.CR[0].eq ) { return 0x820623FC;  }
		/* 820623D8h case    2:*/		return 0x820623DC;
		  /* 820623DCh */ case    3:  		/* andi. R10, R11, 4112 */
		/* 820623DCh case    3:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R11,0x1010);
		/* 820623DCh case    3:*/		return 0x820623E0;
		  /* 820623E0h */ case    4:  		/* rlwinm R9, R11, 4, 12, 27 */
		/* 820623E0h case    4:*/		cpu::op::rlwinm<0,4,12,27>(regs,&regs.R9,regs.R11);
		/* 820623E0h case    4:*/		return 0x820623E4;
		  /* 820623E4h */ case    5:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 820623E4h case    5:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 820623E4h case    5:*/		return 0x820623E8;
		  /* 820623E8h */ case    6:  		/* or R10, R10, R9 */
		/* 820623E8h case    6:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 820623E8h case    6:*/		return 0x820623EC;
		  /* 820623ECh */ case    7:  		/* rlwinm R10, R10, 12, 0, 15 */
		/* 820623ECh case    7:*/		cpu::op::rlwinm<0,12,0,15>(regs,&regs.R10,regs.R10);
		/* 820623ECh case    7:*/		return 0x820623F0;
	}
	return 0x820623F0;
} // Block from 820623D0h-820623F0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820623F0h
// Function '?SetViewport@D3D@@YAXPAUD3DDevice@@MMMMMMK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820623F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820623F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820623F0);
		  /* 820623F0h */ case    0:  		/* rlwinm R10, R10, 0, 12, 10 */
		/* 820623F0h case    0:*/		cpu::op::rlwinm<0,0,12,10>(regs,&regs.R10,regs.R10);
		/* 820623F0h case    0:*/		return 0x820623F4;
		  /* 820623F4h */ case    1:  		/* rlwinm R10, R10, 0, 4, 2 */
		/* 820623F4h case    1:*/		cpu::op::rlwinm<0,0,4,2>(regs,&regs.R10,regs.R10);
		/* 820623F4h case    1:*/		return 0x820623F8;
		  /* 820623F8h */ case    2:  		/* or R11, R10, R11 */
		/* 820623F8h case    2:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820623F8h case    2:*/		return 0x820623FC;
	}
	return 0x820623FC;
} // Block from 820623F0h-820623FCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820623FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820623FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820623FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820623FC);
		  /* 820623FCh */ case    0:  		/* stw R11, <#[R3 + 10552]> */
		/* 820623FCh case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002938) );
		/* 820623FCh case    0:*/		return 0x82062400;
		  /* 82062400h */ case    1:  		/* stw R11, <#[R3 + 10584]> */
		/* 82062400h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002958) );
		/* 82062400h case    1:*/		return 0x82062404;
		  /* 82062404h */ case    2:  		/* stw R11, <#[R3 + 10588]> */
		/* 82062404h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000295C) );
		/* 82062404h case    2:*/		return 0x82062408;
		  /* 82062408h */ case    3:  		/* stw R11, <#[R3 + 10592]> */
		/* 82062408h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002960) );
		/* 82062408h case    3:*/		return 0x8206240C;
		  /* 8206240Ch */ case    4:  		/* ld R11, <#[R3 + 16]> */
		/* 8206240Ch case    4:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8206240Ch case    4:*/		return 0x82062410;
		  /* 82062410h */ case    5:  		/* ori R11, R11, 1024 */
		/* 82062410h case    5:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x400);
		/* 82062410h case    5:*/		return 0x82062414;
		  /* 82062414h */ case    6:  		/* std R11, <#[R3 + 16]> */
		/* 82062414h case    6:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062414h case    6:*/		return 0x82062418;
		  /* 82062418h */ case    7:  		/* ori R11, R11, 4 */
		/* 82062418h case    7:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82062418h case    7:*/		return 0x8206241C;
		  /* 8206241Ch */ case    8:  		/* std R11, <#[R3 + 16]> */
		/* 8206241Ch case    8:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8206241Ch case    8:*/		return 0x82062420;
		  /* 82062420h */ case    9:  		/* ori R11, R11, 2 */
		/* 82062420h case    9:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82062420h case    9:*/		return 0x82062424;
		  /* 82062424h */ case   10:  		/* std R11, <#[R3 + 16]> */
		/* 82062424h case   10:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062424h case   10:*/		return 0x82062428;
		  /* 82062428h */ case   11:  		/* ori R11, R11, 1 */
		/* 82062428h case   11:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82062428h case   11:*/		return 0x8206242C;
		  /* 8206242Ch */ case   12:  		/* std R11, <#[R3 + 16]> */
		/* 8206242Ch case   12:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8206242Ch case   12:*/		return 0x82062430;
		  /* 82062430h */ case   13:  		/* bclr 20, CR0_LT */
		/* 82062430h case   13:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062430h case   13:*/		return 0x82062434;
	}
	return 0x82062434;
} // Block from 820623FCh-82062434h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82062434h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062434( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062434) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062434);
		  /* 82062434h */ case    0:  		/* nop */
		/* 82062434h case    0:*/		cpu::op::nop();
		/* 82062434h case    0:*/		return 0x82062438;
	}
	return 0x82062438;
} // Block from 82062434h-82062438h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062438h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062438( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062438) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062438);
		  /* 82062438h */ case    0:  		/* lwz R11, <#[R3 + 12280]> */
		/* 82062438h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002FF8) );
		/* 82062438h case    0:*/		return 0x8206243C;
		  /* 8206243Ch */ case    1:  		/* rlwinm R3, R11, 27, 29, 31 */
		/* 8206243Ch case    1:*/		cpu::op::rlwinm<0,27,29,31>(regs,&regs.R3,regs.R11);
		/* 8206243Ch case    1:*/		return 0x82062440;
		  /* 82062440h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82062440h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062440h case    2:*/		return 0x82062444;
	}
	return 0x82062444;
} // Block from 82062438h-82062444h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82062444h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062444( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062444) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062444);
		  /* 82062444h */ case    0:  		/* nop */
		/* 82062444h case    0:*/		cpu::op::nop();
		/* 82062444h case    0:*/		return 0x82062448;
	}
	return 0x82062448;
} // Block from 82062444h-82062448h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062448h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062448( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062448) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062448);
		  /* 82062448h */ case    0:  		/* lwz R10, <#[R3 + 12280]> */
		/* 82062448h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00002FF8) );
		/* 82062448h case    0:*/		return 0x8206244C;
		  /* 8206244Ch */ case    1:  		/* lwz R11, <#[R3 + 12284]> */
		/* 8206244Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002FFC) );
		/* 8206244Ch case    1:*/		return 0x82062450;
		  /* 82062450h */ case    2:  		/* rlwimi R10, R4, 0, 27, 31 */
		/* 82062450h case    2:*/		cpu::op::rlwimi<0,0,27,31>(regs,&regs.R10,regs.R4);
		/* 82062450h case    2:*/		return 0x82062454;
		  /* 82062454h */ case    3:  		/* rlwinm. R9, R11, 0, 0, 0 */
		/* 82062454h case    3:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R9,regs.R11);
		/* 82062454h case    3:*/		return 0x82062458;
		  /* 82062458h */ case    4:  		/* stw R10, <#[R3 + 12280]> */
		/* 82062458h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00002FF8) );
		/* 82062458h case    4:*/		return 0x8206245C;
		  /* 8206245Ch */ case    5:  		/* bclr 12, CR0_EQ */
		/* 8206245Ch case    5:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 8206245Ch case    5:*/		return 0x82062460;
	}
	return 0x82062460;
} // Block from 82062448h-82062460h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82062460h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062460( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062460) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062460);
		  /* 82062460h */ case    0:  		/* rlwinm. R10, R11, 0, 1, 1 */
		/* 82062460h case    0:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R11);
		/* 82062460h case    0:*/		return 0x82062464;
		  /* 82062464h */ case    1:  		/* lwz R11, <#[R3 + 12280]> */
		/* 82062464h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002FF8) );
		/* 82062464h case    1:*/		return 0x82062468;
		  /* 82062468h */ case    2:  		/* bc 4, CR0_EQ, 36 */
		/* 82062468h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8206248C;  }
		/* 82062468h case    2:*/		return 0x8206246C;
		  /* 8206246Ch */ case    3:  		/* andi. R10, R11, 4112 */
		/* 8206246Ch case    3:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R11,0x1010);
		/* 8206246Ch case    3:*/		return 0x82062470;
		  /* 82062470h */ case    4:  		/* rlwinm R9, R11, 4, 12, 27 */
		/* 82062470h case    4:*/		cpu::op::rlwinm<0,4,12,27>(regs,&regs.R9,regs.R11);
		/* 82062470h case    4:*/		return 0x82062474;
		  /* 82062474h */ case    5:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 82062474h case    5:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 82062474h case    5:*/		return 0x82062478;
		  /* 82062478h */ case    6:  		/* or R10, R10, R9 */
		/* 82062478h case    6:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82062478h case    6:*/		return 0x8206247C;
		  /* 8206247Ch */ case    7:  		/* rlwinm R10, R10, 12, 0, 15 */
		/* 8206247Ch case    7:*/		cpu::op::rlwinm<0,12,0,15>(regs,&regs.R10,regs.R10);
		/* 8206247Ch case    7:*/		return 0x82062480;
		  /* 82062480h */ case    8:  		/* rlwinm R10, R10, 0, 12, 10 */
		/* 82062480h case    8:*/		cpu::op::rlwinm<0,0,12,10>(regs,&regs.R10,regs.R10);
		/* 82062480h case    8:*/		return 0x82062484;
		  /* 82062484h */ case    9:  		/* rlwinm R10, R10, 0, 4, 2 */
		/* 82062484h case    9:*/		cpu::op::rlwinm<0,0,4,2>(regs,&regs.R10,regs.R10);
		/* 82062484h case    9:*/		return 0x82062488;
		  /* 82062488h */ case   10:  		/* or R11, R10, R11 */
		/* 82062488h case   10:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82062488h case   10:*/		return 0x8206248C;
	}
	return 0x8206248C;
} // Block from 82062460h-8206248Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8206248Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206248C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206248C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206248C);
		  /* 8206248Ch */ case    0:  		/* stw R11, <#[R3 + 10552]> */
		/* 8206248Ch case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002938) );
		/* 8206248Ch case    0:*/		return 0x82062490;
		  /* 82062490h */ case    1:  		/* stw R11, <#[R3 + 10584]> */
		/* 82062490h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002958) );
		/* 82062490h case    1:*/		return 0x82062494;
		  /* 82062494h */ case    2:  		/* stw R11, <#[R3 + 10588]> */
		/* 82062494h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000295C) );
		/* 82062494h case    2:*/		return 0x82062498;
		  /* 82062498h */ case    3:  		/* stw R11, <#[R3 + 10592]> */
		/* 82062498h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002960) );
		/* 82062498h case    3:*/		return 0x8206249C;
		  /* 8206249Ch */ case    4:  		/* ld R11, <#[R3 + 16]> */
		/* 8206249Ch case    4:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8206249Ch case    4:*/		return 0x820624A0;
		  /* 820624A0h */ case    5:  		/* ori R11, R11, 1024 */
		/* 820624A0h case    5:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x400);
		/* 820624A0h case    5:*/		return 0x820624A4;
		  /* 820624A4h */ case    6:  		/* std R11, <#[R3 + 16]> */
		/* 820624A4h case    6:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820624A4h case    6:*/		return 0x820624A8;
		  /* 820624A8h */ case    7:  		/* ori R11, R11, 4 */
		/* 820624A8h case    7:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820624A8h case    7:*/		return 0x820624AC;
		  /* 820624ACh */ case    8:  		/* std R11, <#[R3 + 16]> */
		/* 820624ACh case    8:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820624ACh case    8:*/		return 0x820624B0;
		  /* 820624B0h */ case    9:  		/* ori R11, R11, 2 */
		/* 820624B0h case    9:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2);
		/* 820624B0h case    9:*/		return 0x820624B4;
		  /* 820624B4h */ case   10:  		/* std R11, <#[R3 + 16]> */
		/* 820624B4h case   10:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820624B4h case   10:*/		return 0x820624B8;
		  /* 820624B8h */ case   11:  		/* ori R11, R11, 1 */
		/* 820624B8h case   11:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820624B8h case   11:*/		return 0x820624BC;
		  /* 820624BCh */ case   12:  		/* std R11, <#[R3 + 16]> */
		/* 820624BCh case   12:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820624BCh case   12:*/		return 0x820624C0;
		  /* 820624C0h */ case   13:  		/* bclr 20, CR0_LT */
		/* 820624C0h case   13:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820624C0h case   13:*/		return 0x820624C4;
	}
	return 0x820624C4;
} // Block from 8206248Ch-820624C4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820624C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820624C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820624C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820624C4);
		  /* 820624C4h */ case    0:  		/* nop */
		/* 820624C4h case    0:*/		cpu::op::nop();
		/* 820624C4h case    0:*/		return 0x820624C8;
	}
	return 0x820624C8;
} // Block from 820624C4h-820624C8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820624C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820624C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820624C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820624C8);
		  /* 820624C8h */ case    0:  		/* lwz R11, <#[R3 + 12280]> */
		/* 820624C8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002FF8) );
		/* 820624C8h case    0:*/		return 0x820624CC;
		  /* 820624CCh */ case    1:  		/* rlwinm R3, R11, 0, 27, 31 */
		/* 820624CCh case    1:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R3,regs.R11);
		/* 820624CCh case    1:*/		return 0x820624D0;
		  /* 820624D0h */ case    2:  		/* bclr 20, CR0_LT */
		/* 820624D0h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820624D0h case    2:*/		return 0x820624D4;
	}
	return 0x820624D4;
} // Block from 820624C8h-820624D4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820624D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820624D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820624D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820624D4);
		  /* 820624D4h */ case    0:  		/* nop */
		/* 820624D4h case    0:*/		cpu::op::nop();
		/* 820624D4h case    0:*/		return 0x820624D8;
	}
	return 0x820624D8;
} // Block from 820624D4h-820624D8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820624D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820624D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820624D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820624D8);
		  /* 820624D8h */ case    0:  		/* lwz R10, <#[R3 + 12280]> */
		/* 820624D8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00002FF8) );
		/* 820624D8h case    0:*/		return 0x820624DC;
		  /* 820624DCh */ case    1:  		/* lwz R11, <#[R3 + 12284]> */
		/* 820624DCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002FFC) );
		/* 820624DCh case    1:*/		return 0x820624E0;
		  /* 820624E0h */ case    2:  		/* rlwimi R10, R4, 8, 19, 23 */
		/* 820624E0h case    2:*/		cpu::op::rlwimi<0,8,19,23>(regs,&regs.R10,regs.R4);
		/* 820624E0h case    2:*/		return 0x820624E4;
		  /* 820624E4h */ case    3:  		/* rlwinm. R9, R11, 0, 0, 0 */
		/* 820624E4h case    3:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R9,regs.R11);
		/* 820624E4h case    3:*/		return 0x820624E8;
		  /* 820624E8h */ case    4:  		/* stw R10, <#[R3 + 12280]> */
		/* 820624E8h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00002FF8) );
		/* 820624E8h case    4:*/		return 0x820624EC;
		  /* 820624ECh */ case    5:  		/* bclr 12, CR0_EQ */
		/* 820624ECh case    5:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 820624ECh case    5:*/		return 0x820624F0;
	}
	return 0x820624F0;
} // Block from 820624D8h-820624F0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820624F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820624F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820624F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820624F0);
		  /* 820624F0h */ case    0:  		/* rlwinm. R10, R11, 0, 1, 1 */
		/* 820624F0h case    0:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R11);
		/* 820624F0h case    0:*/		return 0x820624F4;
		  /* 820624F4h */ case    1:  		/* lwz R11, <#[R3 + 12280]> */
		/* 820624F4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002FF8) );
		/* 820624F4h case    1:*/		return 0x820624F8;
		  /* 820624F8h */ case    2:  		/* bc 4, CR0_EQ, 36 */
		/* 820624F8h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8206251C;  }
		/* 820624F8h case    2:*/		return 0x820624FC;
		  /* 820624FCh */ case    3:  		/* andi. R10, R11, 4112 */
		/* 820624FCh case    3:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R11,0x1010);
		/* 820624FCh case    3:*/		return 0x82062500;
		  /* 82062500h */ case    4:  		/* rlwinm R9, R11, 4, 12, 27 */
		/* 82062500h case    4:*/		cpu::op::rlwinm<0,4,12,27>(regs,&regs.R9,regs.R11);
		/* 82062500h case    4:*/		return 0x82062504;
		  /* 82062504h */ case    5:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 82062504h case    5:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 82062504h case    5:*/		return 0x82062508;
		  /* 82062508h */ case    6:  		/* or R10, R10, R9 */
		/* 82062508h case    6:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82062508h case    6:*/		return 0x8206250C;
		  /* 8206250Ch */ case    7:  		/* rlwinm R10, R10, 12, 0, 15 */
		/* 8206250Ch case    7:*/		cpu::op::rlwinm<0,12,0,15>(regs,&regs.R10,regs.R10);
		/* 8206250Ch case    7:*/		return 0x82062510;
		  /* 82062510h */ case    8:  		/* rlwinm R10, R10, 0, 12, 10 */
		/* 82062510h case    8:*/		cpu::op::rlwinm<0,0,12,10>(regs,&regs.R10,regs.R10);
		/* 82062510h case    8:*/		return 0x82062514;
		  /* 82062514h */ case    9:  		/* rlwinm R10, R10, 0, 4, 2 */
		/* 82062514h case    9:*/		cpu::op::rlwinm<0,0,4,2>(regs,&regs.R10,regs.R10);
		/* 82062514h case    9:*/		return 0x82062518;
		  /* 82062518h */ case   10:  		/* or R11, R10, R11 */
		/* 82062518h case   10:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82062518h case   10:*/		return 0x8206251C;
	}
	return 0x8206251C;
} // Block from 820624F0h-8206251Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8206251Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206251C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206251C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206251C);
		  /* 8206251Ch */ case    0:  		/* stw R11, <#[R3 + 10552]> */
		/* 8206251Ch case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002938) );
		/* 8206251Ch case    0:*/		return 0x82062520;
		  /* 82062520h */ case    1:  		/* stw R11, <#[R3 + 10584]> */
		/* 82062520h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002958) );
		/* 82062520h case    1:*/		return 0x82062524;
		  /* 82062524h */ case    2:  		/* stw R11, <#[R3 + 10588]> */
		/* 82062524h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000295C) );
		/* 82062524h case    2:*/		return 0x82062528;
		  /* 82062528h */ case    3:  		/* stw R11, <#[R3 + 10592]> */
		/* 82062528h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002960) );
		/* 82062528h case    3:*/		return 0x8206252C;
		  /* 8206252Ch */ case    4:  		/* ld R11, <#[R3 + 16]> */
		/* 8206252Ch case    4:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8206252Ch case    4:*/		return 0x82062530;
		  /* 82062530h */ case    5:  		/* ori R11, R11, 1024 */
		/* 82062530h case    5:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x400);
		/* 82062530h case    5:*/		return 0x82062534;
		  /* 82062534h */ case    6:  		/* std R11, <#[R3 + 16]> */
		/* 82062534h case    6:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062534h case    6:*/		return 0x82062538;
		  /* 82062538h */ case    7:  		/* ori R11, R11, 4 */
		/* 82062538h case    7:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82062538h case    7:*/		return 0x8206253C;
		  /* 8206253Ch */ case    8:  		/* std R11, <#[R3 + 16]> */
		/* 8206253Ch case    8:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8206253Ch case    8:*/		return 0x82062540;
		  /* 82062540h */ case    9:  		/* ori R11, R11, 2 */
		/* 82062540h case    9:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82062540h case    9:*/		return 0x82062544;
		  /* 82062544h */ case   10:  		/* std R11, <#[R3 + 16]> */
		/* 82062544h case   10:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062544h case   10:*/		return 0x82062548;
		  /* 82062548h */ case   11:  		/* ori R11, R11, 1 */
		/* 82062548h case   11:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82062548h case   11:*/		return 0x8206254C;
		  /* 8206254Ch */ case   12:  		/* std R11, <#[R3 + 16]> */
		/* 8206254Ch case   12:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8206254Ch case   12:*/		return 0x82062550;
		  /* 82062550h */ case   13:  		/* bclr 20, CR0_LT */
		/* 82062550h case   13:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062550h case   13:*/		return 0x82062554;
	}
	return 0x82062554;
} // Block from 8206251Ch-82062554h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82062554h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062554( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062554) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062554);
		  /* 82062554h */ case    0:  		/* nop */
		/* 82062554h case    0:*/		cpu::op::nop();
		/* 82062554h case    0:*/		return 0x82062558;
	}
	return 0x82062558;
} // Block from 82062554h-82062558h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062558h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062558( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062558) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062558);
		  /* 82062558h */ case    0:  		/* lwz R11, <#[R3 + 12280]> */
		/* 82062558h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002FF8) );
		/* 82062558h case    0:*/		return 0x8206255C;
		  /* 8206255Ch */ case    1:  		/* rlwinm R3, R11, 24, 27, 31 */
		/* 8206255Ch case    1:*/		cpu::op::rlwinm<0,24,27,31>(regs,&regs.R3,regs.R11);
		/* 8206255Ch case    1:*/		return 0x82062560;
		  /* 82062560h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82062560h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062560h case    2:*/		return 0x82062564;
	}
	return 0x82062564;
} // Block from 82062558h-82062564h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82062564h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062564( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062564) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062564);
		  /* 82062564h */ case    0:  		/* nop */
		/* 82062564h case    0:*/		cpu::op::nop();
		/* 82062564h case    0:*/		return 0x82062568;
	}
	return 0x82062568;
} // Block from 82062564h-82062568h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062568h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062568( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062568) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062568);
		  /* 82062568h */ case    0:  		/* lwz R10, <#[R3 + 12280]> */
		/* 82062568h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00002FF8) );
		/* 82062568h case    0:*/		return 0x8206256C;
		  /* 8206256Ch */ case    1:  		/* lwz R11, <#[R3 + 12284]> */
		/* 8206256Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002FFC) );
		/* 8206256Ch case    1:*/		return 0x82062570;
		  /* 82062570h */ case    2:  		/* rlwimi R10, R4, 21, 8, 10 */
		/* 82062570h case    2:*/		cpu::op::rlwimi<0,21,8,10>(regs,&regs.R10,regs.R4);
		/* 82062570h case    2:*/		return 0x82062574;
		  /* 82062574h */ case    3:  		/* rlwinm. R9, R11, 0, 0, 0 */
		/* 82062574h case    3:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R9,regs.R11);
		/* 82062574h case    3:*/		return 0x82062578;
		  /* 82062578h */ case    4:  		/* stw R10, <#[R3 + 12280]> */
		/* 82062578h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00002FF8) );
		/* 82062578h case    4:*/		return 0x8206257C;
		  /* 8206257Ch */ case    5:  		/* bclr 12, CR0_EQ */
		/* 8206257Ch case    5:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 8206257Ch case    5:*/		return 0x82062580;
	}
	return 0x82062580;
} // Block from 82062568h-82062580h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82062580h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062580( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062580) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062580);
		  /* 82062580h */ case    0:  		/* rlwinm. R11, R11, 0, 1, 1 */
		/* 82062580h case    0:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R11);
		/* 82062580h case    0:*/		return 0x82062584;
		  /* 82062584h */ case    1:  		/* bclr 12, CR0_EQ */
		/* 82062584h case    1:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 82062584h case    1:*/		return 0x82062588;
	}
	return 0x82062588;
} // Block from 82062580h-82062588h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82062588h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062588( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062588) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062588);
		  /* 82062588h */ case    0:  		/* rlwinm R11, R10, 0, 0, 31 */
		/* 82062588h case    0:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R10);
		/* 82062588h case    0:*/		return 0x8206258C;
		  /* 8206258Ch */ case    1:  		/* stw R11, <#[R3 + 10552]> */
		/* 8206258Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002938) );
		/* 8206258Ch case    1:*/		return 0x82062590;
		  /* 82062590h */ case    2:  		/* stw R11, <#[R3 + 10584]> */
		/* 82062590h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002958) );
		/* 82062590h case    2:*/		return 0x82062594;
		  /* 82062594h */ case    3:  		/* stw R11, <#[R3 + 10588]> */
		/* 82062594h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000295C) );
		/* 82062594h case    3:*/		return 0x82062598;
		  /* 82062598h */ case    4:  		/* stw R11, <#[R3 + 10592]> */
		/* 82062598h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002960) );
		/* 82062598h case    4:*/		return 0x8206259C;
		  /* 8206259Ch */ case    5:  		/* ld R11, <#[R3 + 16]> */
		/* 8206259Ch case    5:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8206259Ch case    5:*/		return 0x820625A0;
		  /* 820625A0h */ case    6:  		/* ori R11, R11, 1024 */
		/* 820625A0h case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x400);
		/* 820625A0h case    6:*/		return 0x820625A4;
		  /* 820625A4h */ case    7:  		/* std R11, <#[R3 + 16]> */
		/* 820625A4h case    7:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820625A4h case    7:*/		return 0x820625A8;
		  /* 820625A8h */ case    8:  		/* ori R11, R11, 4 */
		/* 820625A8h case    8:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820625A8h case    8:*/		return 0x820625AC;
		  /* 820625ACh */ case    9:  		/* std R11, <#[R3 + 16]> */
		/* 820625ACh case    9:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820625ACh case    9:*/		return 0x820625B0;
		  /* 820625B0h */ case   10:  		/* ori R11, R11, 2 */
		/* 820625B0h case   10:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2);
		/* 820625B0h case   10:*/		return 0x820625B4;
		  /* 820625B4h */ case   11:  		/* std R11, <#[R3 + 16]> */
		/* 820625B4h case   11:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820625B4h case   11:*/		return 0x820625B8;
		  /* 820625B8h */ case   12:  		/* ori R11, R11, 1 */
		/* 820625B8h case   12:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820625B8h case   12:*/		return 0x820625BC;
		  /* 820625BCh */ case   13:  		/* std R11, <#[R3 + 16]> */
		/* 820625BCh case   13:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820625BCh case   13:*/		return 0x820625C0;
		  /* 820625C0h */ case   14:  		/* bclr 20, CR0_LT */
		/* 820625C0h case   14:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820625C0h case   14:*/		return 0x820625C4;
	}
	return 0x820625C4;
} // Block from 82062588h-820625C4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820625C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820625C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820625C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820625C4);
		  /* 820625C4h */ case    0:  		/* nop */
		/* 820625C4h case    0:*/		cpu::op::nop();
		/* 820625C4h case    0:*/		return 0x820625C8;
	}
	return 0x820625C8;
} // Block from 820625C4h-820625C8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820625C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820625C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820625C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820625C8);
		  /* 820625C8h */ case    0:  		/* lwz R11, <#[R3 + 12280]> */
		/* 820625C8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002FF8) );
		/* 820625C8h case    0:*/		return 0x820625CC;
		  /* 820625CCh */ case    1:  		/* rlwinm R3, R11, 11, 29, 31 */
		/* 820625CCh case    1:*/		cpu::op::rlwinm<0,11,29,31>(regs,&regs.R3,regs.R11);
		/* 820625CCh case    1:*/		return 0x820625D0;
		  /* 820625D0h */ case    2:  		/* bclr 20, CR0_LT */
		/* 820625D0h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820625D0h case    2:*/		return 0x820625D4;
	}
	return 0x820625D4;
} // Block from 820625C8h-820625D4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820625D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820625D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820625D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820625D4);
		  /* 820625D4h */ case    0:  		/* nop */
		/* 820625D4h case    0:*/		cpu::op::nop();
		/* 820625D4h case    0:*/		return 0x820625D8;
	}
	return 0x820625D8;
} // Block from 820625D4h-820625D8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820625D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820625D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820625D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820625D8);
		  /* 820625D8h */ case    0:  		/* lwz R10, <#[R3 + 12280]> */
		/* 820625D8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00002FF8) );
		/* 820625D8h case    0:*/		return 0x820625DC;
		  /* 820625DCh */ case    1:  		/* lwz R11, <#[R3 + 12284]> */
		/* 820625DCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002FFC) );
		/* 820625DCh case    1:*/		return 0x820625E0;
		  /* 820625E0h */ case    2:  		/* rlwimi R10, R4, 16, 11, 15 */
		/* 820625E0h case    2:*/		cpu::op::rlwimi<0,16,11,15>(regs,&regs.R10,regs.R4);
		/* 820625E0h case    2:*/		return 0x820625E4;
		  /* 820625E4h */ case    3:  		/* rlwinm. R9, R11, 0, 0, 0 */
		/* 820625E4h case    3:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R9,regs.R11);
		/* 820625E4h case    3:*/		return 0x820625E8;
		  /* 820625E8h */ case    4:  		/* stw R10, <#[R3 + 12280]> */
		/* 820625E8h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00002FF8) );
		/* 820625E8h case    4:*/		return 0x820625EC;
		  /* 820625ECh */ case    5:  		/* bclr 12, CR0_EQ */
		/* 820625ECh case    5:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 820625ECh case    5:*/		return 0x820625F0;
	}
	return 0x820625F0;
} // Block from 820625D8h-820625F0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820625F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820625F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820625F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820625F0);
		  /* 820625F0h */ case    0:  		/* rlwinm. R11, R11, 0, 1, 1 */
		/* 820625F0h case    0:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R11);
		/* 820625F0h case    0:*/		return 0x820625F4;
		  /* 820625F4h */ case    1:  		/* bclr 12, CR0_EQ */
		/* 820625F4h case    1:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 820625F4h case    1:*/		return 0x820625F8;
	}
	return 0x820625F8;
} // Block from 820625F0h-820625F8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820625F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820625F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820625F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820625F8);
		  /* 820625F8h */ case    0:  		/* rlwinm R11, R10, 0, 0, 31 */
		/* 820625F8h case    0:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R10);
		/* 820625F8h case    0:*/		return 0x820625FC;
		  /* 820625FCh */ case    1:  		/* stw R11, <#[R3 + 10552]> */
		/* 820625FCh case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002938) );
		/* 820625FCh case    1:*/		return 0x82062600;
		  /* 82062600h */ case    2:  		/* stw R11, <#[R3 + 10584]> */
		/* 82062600h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002958) );
		/* 82062600h case    2:*/		return 0x82062604;
		  /* 82062604h */ case    3:  		/* stw R11, <#[R3 + 10588]> */
		/* 82062604h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000295C) );
		/* 82062604h case    3:*/		return 0x82062608;
		  /* 82062608h */ case    4:  		/* stw R11, <#[R3 + 10592]> */
		/* 82062608h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002960) );
		/* 82062608h case    4:*/		return 0x8206260C;
		  /* 8206260Ch */ case    5:  		/* ld R11, <#[R3 + 16]> */
		/* 8206260Ch case    5:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8206260Ch case    5:*/		return 0x82062610;
		  /* 82062610h */ case    6:  		/* ori R11, R11, 1024 */
		/* 82062610h case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x400);
		/* 82062610h case    6:*/		return 0x82062614;
		  /* 82062614h */ case    7:  		/* std R11, <#[R3 + 16]> */
		/* 82062614h case    7:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062614h case    7:*/		return 0x82062618;
		  /* 82062618h */ case    8:  		/* ori R11, R11, 4 */
		/* 82062618h case    8:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82062618h case    8:*/		return 0x8206261C;
		  /* 8206261Ch */ case    9:  		/* std R11, <#[R3 + 16]> */
		/* 8206261Ch case    9:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8206261Ch case    9:*/		return 0x82062620;
		  /* 82062620h */ case   10:  		/* ori R11, R11, 2 */
		/* 82062620h case   10:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82062620h case   10:*/		return 0x82062624;
		  /* 82062624h */ case   11:  		/* std R11, <#[R3 + 16]> */
		/* 82062624h case   11:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062624h case   11:*/		return 0x82062628;
		  /* 82062628h */ case   12:  		/* ori R11, R11, 1 */
		/* 82062628h case   12:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82062628h case   12:*/		return 0x8206262C;
		  /* 8206262Ch */ case   13:  		/* std R11, <#[R3 + 16]> */
		/* 8206262Ch case   13:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8206262Ch case   13:*/		return 0x82062630;
		  /* 82062630h */ case   14:  		/* bclr 20, CR0_LT */
		/* 82062630h case   14:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062630h case   14:*/		return 0x82062634;
	}
	return 0x82062634;
} // Block from 820625F8h-82062634h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82062634h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062634( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062634) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062634);
		  /* 82062634h */ case    0:  		/* nop */
		/* 82062634h case    0:*/		cpu::op::nop();
		/* 82062634h case    0:*/		return 0x82062638;
	}
	return 0x82062638;
} // Block from 82062634h-82062638h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062638h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062638( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062638) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062638);
		  /* 82062638h */ case    0:  		/* lhz R11, <#[R3 + 12280]> */
		/* 82062638h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002FF8) );
		/* 82062638h case    0:*/		return 0x8206263C;
		  /* 8206263Ch */ case    1:  		/* rlwinm R3, R11, 0, 27, 31 */
		/* 8206263Ch case    1:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R3,regs.R11);
		/* 8206263Ch case    1:*/		return 0x82062640;
		  /* 82062640h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82062640h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062640h case    2:*/		return 0x82062644;
	}
	return 0x82062644;
} // Block from 82062638h-82062644h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82062644h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062644( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062644) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062644);
		  /* 82062644h */ case    0:  		/* nop */
		/* 82062644h case    0:*/		cpu::op::nop();
		/* 82062644h case    0:*/		return 0x82062648;
	}
	return 0x82062648;
} // Block from 82062644h-82062648h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062648h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062648( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062648) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062648);
		  /* 82062648h */ case    0:  		/* lwz R10, <#[R3 + 12280]> */
		/* 82062648h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00002FF8) );
		/* 82062648h case    0:*/		return 0x8206264C;
		  /* 8206264Ch */ case    1:  		/* lwz R11, <#[R3 + 12284]> */
		/* 8206264Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002FFC) );
		/* 8206264Ch case    1:*/		return 0x82062650;
	}
	return 0x82062650;
} // Block from 82062648h-82062650h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82062650h
// Function 'D3DDevice_SetRenderState_CullMode'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062650( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062650) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062650);
		  /* 82062650h */ case    0:  		/* rlwimi R10, R4, 24, 3, 7 */
		/* 82062650h case    0:*/		cpu::op::rlwimi<0,24,3,7>(regs,&regs.R10,regs.R4);
		/* 82062650h case    0:*/		return 0x82062654;
		  /* 82062654h */ case    1:  		/* rlwinm. R9, R11, 0, 0, 0 */
		/* 82062654h case    1:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R9,regs.R11);
		/* 82062654h case    1:*/		return 0x82062658;
		  /* 82062658h */ case    2:  		/* stw R10, <#[R3 + 12280]> */
		/* 82062658h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00002FF8) );
		/* 82062658h case    2:*/		return 0x8206265C;
		  /* 8206265Ch */ case    3:  		/* bclr 12, CR0_EQ */
		/* 8206265Ch case    3:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 8206265Ch case    3:*/		return 0x82062660;
	}
	return 0x82062660;
} // Block from 82062650h-82062660h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82062660h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062660( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062660) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062660);
		  /* 82062660h */ case    0:  		/* rlwinm. R11, R11, 0, 1, 1 */
		/* 82062660h case    0:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R11);
		/* 82062660h case    0:*/		return 0x82062664;
		  /* 82062664h */ case    1:  		/* bclr 12, CR0_EQ */
		/* 82062664h case    1:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 82062664h case    1:*/		return 0x82062668;
	}
	return 0x82062668;
} // Block from 82062660h-82062668h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82062668h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062668( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062668) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062668);
		  /* 82062668h */ case    0:  		/* rlwinm R11, R10, 0, 0, 31 */
		/* 82062668h case    0:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R10);
		/* 82062668h case    0:*/		return 0x8206266C;
		  /* 8206266Ch */ case    1:  		/* stw R11, <#[R3 + 10552]> */
		/* 8206266Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002938) );
		/* 8206266Ch case    1:*/		return 0x82062670;
	}
	return 0x82062670;
} // Block from 82062668h-82062670h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82062670h
// Function 'D3DDevice_GetRenderState_CullMode'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062670( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062670) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062670);
		  /* 82062670h */ case    0:  		/* stw R11, <#[R3 + 10584]> */
		/* 82062670h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002958) );
		/* 82062670h case    0:*/		return 0x82062674;
		  /* 82062674h */ case    1:  		/* stw R11, <#[R3 + 10588]> */
		/* 82062674h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000295C) );
		/* 82062674h case    1:*/		return 0x82062678;
		  /* 82062678h */ case    2:  		/* stw R11, <#[R3 + 10592]> */
		/* 82062678h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002960) );
		/* 82062678h case    2:*/		return 0x8206267C;
		  /* 8206267Ch */ case    3:  		/* ld R11, <#[R3 + 16]> */
		/* 8206267Ch case    3:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8206267Ch case    3:*/		return 0x82062680;
	}
	return 0x82062680;
} // Block from 82062670h-82062680h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82062680h
// Function 'D3DDevice_SetRenderState_FillMode'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062680( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062680) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062680);
		  /* 82062680h */ case    0:  		/* ori R11, R11, 1024 */
		/* 82062680h case    0:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x400);
		/* 82062680h case    0:*/		return 0x82062684;
		  /* 82062684h */ case    1:  		/* std R11, <#[R3 + 16]> */
		/* 82062684h case    1:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062684h case    1:*/		return 0x82062688;
		  /* 82062688h */ case    2:  		/* ori R11, R11, 4 */
		/* 82062688h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82062688h case    2:*/		return 0x8206268C;
		  /* 8206268Ch */ case    3:  		/* std R11, <#[R3 + 16]> */
		/* 8206268Ch case    3:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8206268Ch case    3:*/		return 0x82062690;
		  /* 82062690h */ case    4:  		/* ori R11, R11, 2 */
		/* 82062690h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82062690h case    4:*/		return 0x82062694;
		  /* 82062694h */ case    5:  		/* std R11, <#[R3 + 16]> */
		/* 82062694h case    5:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062694h case    5:*/		return 0x82062698;
		  /* 82062698h */ case    6:  		/* ori R11, R11, 1 */
		/* 82062698h case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82062698h case    6:*/		return 0x8206269C;
		  /* 8206269Ch */ case    7:  		/* std R11, <#[R3 + 16]> */
		/* 8206269Ch case    7:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8206269Ch case    7:*/		return 0x820626A0;
	}
	return 0x820626A0;
} // Block from 82062680h-820626A0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820626A0h
// Function 'D3DDevice_GetRenderState_FillMode'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820626A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820626A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820626A0);
		  /* 820626A0h */ case    0:  		/* bclr 20, CR0_LT */
		/* 820626A0h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820626A0h case    0:*/		return 0x820626A4;
	}
	return 0x820626A4;
} // Block from 820626A0h-820626A4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820626A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820626A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820626A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820626A4);
		  /* 820626A4h */ case    0:  		/* nop */
		/* 820626A4h case    0:*/		cpu::op::nop();
		/* 820626A4h case    0:*/		return 0x820626A8;
	}
	return 0x820626A8;
} // Block from 820626A4h-820626A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820626A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820626A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820626A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820626A8);
		  /* 820626A8h */ case    0:  		/* lbz R11, <#[R3 + 12280]> */
		/* 820626A8h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002FF8) );
		/* 820626A8h case    0:*/		return 0x820626AC;
		  /* 820626ACh */ case    1:  		/* rlwinm R3, R11, 0, 27, 31 */
		/* 820626ACh case    1:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R3,regs.R11);
		/* 820626ACh case    1:*/		return 0x820626B0;
	}
	return 0x820626B0;
} // Block from 820626A8h-820626B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820626B0h
// Function 'D3DDevice_SetRenderState_AlphaTestEnable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820626B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820626B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820626B0);
		  /* 820626B0h */ case    0:  		/* bclr 20, CR0_LT */
		/* 820626B0h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820626B0h case    0:*/		return 0x820626B4;
	}
	return 0x820626B4;
} // Block from 820626B0h-820626B4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820626B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820626B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820626B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820626B4);
		  /* 820626B4h */ case    0:  		/* nop */
		/* 820626B4h case    0:*/		cpu::op::nop();
		/* 820626B4h case    0:*/		return 0x820626B8;
	}
	return 0x820626B8;
} // Block from 820626B4h-820626B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820626B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820626B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820626B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820626B8);
		  /* 820626B8h */ case    0:  		/* lwz R11, <#[R3 + 12284]> */
		/* 820626B8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002FFC) );
		/* 820626B8h case    0:*/		return 0x820626BC;
		  /* 820626BCh */ case    1:  		/* cmpwi CR6, R4, 0 */
		/* 820626BCh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000000);
		/* 820626BCh case    1:*/		return 0x820626C0;
		  /* 820626C0h */ case    2:  		/* rlwimi R11, R4, 30, 1, 1 */
		/* 820626C0h case    2:*/		cpu::op::rlwimi<0,30,1,1>(regs,&regs.R11,regs.R4);
		/* 820626C0h case    2:*/		return 0x820626C4;
		  /* 820626C4h */ case    3:  		/* stw R11, <#[R3 + 12284]> */
		/* 820626C4h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002FFC) );
		/* 820626C4h case    3:*/		return 0x820626C8;
		  /* 820626C8h */ case    4:  		/* rlwinm R10, R11, 1, 31, 31 */
		/* 820626C8h case    4:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R10,regs.R11);
		/* 820626C8h case    4:*/		return 0x820626CC;
		  /* 820626CCh */ case    5:  		/* lwz R11, <#[R3 + 12280]> */
		/* 820626CCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002FF8) );
		/* 820626CCh case    5:*/		return 0x820626D0;
		  /* 820626D0h */ case    6:  		/* bc 4, CR6_EQ, 36 */
		/* 820626D0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820626F4;  }
		/* 820626D0h case    6:*/		return 0x820626D4;
		  /* 820626D4h */ case    7:  		/* andi. R9, R11, 4112 */
		/* 820626D4h case    7:*/		cpu::op::andi<1>(regs,&regs.R9,regs.R11,0x1010);
		/* 820626D4h case    7:*/		return 0x820626D8;
	}
	return 0x820626D8;
} // Block from 820626B8h-820626D8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820626D8h
// Function 'D3DDevice_GetRenderState_AlphaTestEnable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820626D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820626D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820626D8);
		  /* 820626D8h */ case    0:  		/* rlwinm R8, R11, 4, 12, 27 */
		/* 820626D8h case    0:*/		cpu::op::rlwinm<0,4,12,27>(regs,&regs.R8,regs.R11);
		/* 820626D8h case    0:*/		return 0x820626DC;
		  /* 820626DCh */ case    1:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 820626DCh case    1:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 820626DCh case    1:*/		return 0x820626E0;
		  /* 820626E0h */ case    2:  		/* or R9, R9, R8 */
		/* 820626E0h case    2:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 820626E0h case    2:*/		return 0x820626E4;
		  /* 820626E4h */ case    3:  		/* rlwinm R9, R9, 12, 0, 15 */
		/* 820626E4h case    3:*/		cpu::op::rlwinm<0,12,0,15>(regs,&regs.R9,regs.R9);
		/* 820626E4h case    3:*/		return 0x820626E8;
	}
	return 0x820626E8;
} // Block from 820626D8h-820626E8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820626E8h
// Function 'D3DDevice_SetRenderState_AlphaBlendEnable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820626E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820626E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820626E8);
		  /* 820626E8h */ case    0:  		/* rlwinm R9, R9, 0, 12, 10 */
		/* 820626E8h case    0:*/		cpu::op::rlwinm<0,0,12,10>(regs,&regs.R9,regs.R9);
		/* 820626E8h case    0:*/		return 0x820626EC;
		  /* 820626ECh */ case    1:  		/* rlwinm R9, R9, 0, 4, 2 */
		/* 820626ECh case    1:*/		cpu::op::rlwinm<0,0,4,2>(regs,&regs.R9,regs.R9);
		/* 820626ECh case    1:*/		return 0x820626F0;
		  /* 820626F0h */ case    2:  		/* or R11, R9, R11 */
		/* 820626F0h case    2:*/		cpu::op::or<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 820626F0h case    2:*/		return 0x820626F4;
	}
	return 0x820626F4;
} // Block from 820626E8h-820626F4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820626F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820626F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820626F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820626F4);
		  /* 820626F4h */ case    0:  		/* cmpwi CR6, R10, 0 */
		/* 820626F4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 820626F4h case    0:*/		return 0x820626F8;
		  /* 820626F8h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 820626F8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82062704;  }
		/* 820626F8h case    1:*/		return 0x820626FC;
		  /* 820626FCh */ case    2:  		/* lis R11, 1 */
		/* 820626FCh case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0x1);
		/* 820626FCh case    2:*/		return 0x82062700;
		  /* 82062700h */ case    3:  		/* ori R11, R11, 1 */
		/* 82062700h case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82062700h case    3:*/		return 0x82062704;
	}
	return 0x82062704;
} // Block from 820626F4h-82062704h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82062704h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062704( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062704) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062704);
		  /* 82062704h */ case    0:  		/* stw R11, <#[R3 + 10552]> */
		/* 82062704h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002938) );
		/* 82062704h case    0:*/		return 0x82062708;
		  /* 82062708h */ case    1:  		/* stw R11, <#[R3 + 10584]> */
		/* 82062708h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002958) );
		/* 82062708h case    1:*/		return 0x8206270C;
		  /* 8206270Ch */ case    2:  		/* stw R11, <#[R3 + 10588]> */
		/* 8206270Ch case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000295C) );
		/* 8206270Ch case    2:*/		return 0x82062710;
		  /* 82062710h */ case    3:  		/* stw R11, <#[R3 + 10592]> */
		/* 82062710h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002960) );
		/* 82062710h case    3:*/		return 0x82062714;
		  /* 82062714h */ case    4:  		/* ld R11, <#[R3 + 16]> */
		/* 82062714h case    4:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062714h case    4:*/		return 0x82062718;
		  /* 82062718h */ case    5:  		/* ori R11, R11, 1024 */
		/* 82062718h case    5:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x400);
		/* 82062718h case    5:*/		return 0x8206271C;
		  /* 8206271Ch */ case    6:  		/* std R11, <#[R3 + 16]> */
		/* 8206271Ch case    6:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8206271Ch case    6:*/		return 0x82062720;
		  /* 82062720h */ case    7:  		/* ori R11, R11, 4 */
		/* 82062720h case    7:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82062720h case    7:*/		return 0x82062724;
		  /* 82062724h */ case    8:  		/* std R11, <#[R3 + 16]> */
		/* 82062724h case    8:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062724h case    8:*/		return 0x82062728;
		  /* 82062728h */ case    9:  		/* ori R11, R11, 2 */
		/* 82062728h case    9:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82062728h case    9:*/		return 0x8206272C;
		  /* 8206272Ch */ case   10:  		/* std R11, <#[R3 + 16]> */
		/* 8206272Ch case   10:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8206272Ch case   10:*/		return 0x82062730;
		  /* 82062730h */ case   11:  		/* ori R11, R11, 1 */
		/* 82062730h case   11:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82062730h case   11:*/		return 0x82062734;
		  /* 82062734h */ case   12:  		/* std R11, <#[R3 + 16]> */
		/* 82062734h case   12:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062734h case   12:*/		return 0x82062738;
		  /* 82062738h */ case   13:  		/* bclr 20, CR0_LT */
		/* 82062738h case   13:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062738h case   13:*/		return 0x8206273C;
	}
	return 0x8206273C;
} // Block from 82062704h-8206273Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 8206273Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206273C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206273C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206273C);
		  /* 8206273Ch */ case    0:  		/* nop */
		/* 8206273Ch case    0:*/		cpu::op::nop();
		/* 8206273Ch case    0:*/		return 0x82062740;
	}
	return 0x82062740;
} // Block from 8206273Ch-82062740h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062740h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062740( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062740) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062740);
		  /* 82062740h */ case    0:  		/* lwz R11, <#[R3 + 12284]> */
		/* 82062740h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002FFC) );
		/* 82062740h case    0:*/		return 0x82062744;
		  /* 82062744h */ case    1:  		/* rlwinm R3, R11, 2, 31, 31 */
		/* 82062744h case    1:*/		cpu::op::rlwinm<0,2,31,31>(regs,&regs.R3,regs.R11);
		/* 82062744h case    1:*/		return 0x82062748;
		  /* 82062748h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82062748h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062748h case    2:*/		return 0x8206274C;
	}
	return 0x8206274C;
} // Block from 82062740h-8206274Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206274Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206274C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206274C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206274C);
		  /* 8206274Ch */ case    0:  		/* nop */
		/* 8206274Ch case    0:*/		cpu::op::nop();
		/* 8206274Ch case    0:*/		return 0x82062750;
	}
	return 0x82062750;
} // Block from 8206274Ch-82062750h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062750h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062750( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062750) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062750);
		  /* 82062750h */ case    0:  		/* rldicl R11, R4, 0, 32 */
		/* 82062750h case    0:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R11,regs.R4);
		/* 82062750h case    0:*/		return 0x82062754;
		  /* 82062754h */ case    1:  		/* std R11, <#[R1 - 16]> */
		/* 82062754h case    1:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82062754h case    1:*/		return 0x82062758;
		  /* 82062758h */ case    2:  		/* lfd FR0, <#[R1 - 16]> */
		/* 82062758h case    2:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82062758h case    2:*/		return 0x8206275C;
		  /* 8206275Ch */ case    3:  		/* fcfid FR0, FR0 */
		/* 8206275Ch case    3:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 8206275Ch case    3:*/		return 0x82062760;
		  /* 82062760h */ case    4:  		/* lis R11, -32256 */
		/* 82062760h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82062760h case    4:*/		return 0x82062764;
		  /* 82062764h */ case    5:  		/* frsp FR13, FR0 */
		/* 82062764h case    5:*/		cpu::op::frsp<0>(regs,&regs.FR13,regs.FR0);
		/* 82062764h case    5:*/		return 0x82062768;
	}
	return 0x82062768;
} // Block from 82062750h-82062768h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82062768h
// Function 'D3DDevice_GetRenderState_AlphaBlendEnable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062768( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062768) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062768);
		  /* 82062768h */ case    0:  		/* lfs FR0, <#[R11 + 2968]> */
		/* 82062768h case    0:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000B98) );
		/* 82062768h case    0:*/		return 0x8206276C;
		  /* 8206276Ch */ case    1:  		/* fmuls FR0, FR13, FR0 */
		/* 8206276Ch case    1:*/		cpu::op::fmuls<0>(regs,&regs.FR0,regs.FR13,regs.FR0);
		/* 8206276Ch case    1:*/		return 0x82062770;
		  /* 82062770h */ case    2:  		/* stfs FR0, <#[R3 + 10500]> */
		/* 82062770h case    2:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R3 + 0x00002904) );
		/* 82062770h case    2:*/		return 0x82062774;
		  /* 82062774h */ case    3:  		/* ld R11, <#[R3 + 16]> */
		/* 82062774h case    3:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062774h case    3:*/		return 0x82062778;
	}
	return 0x82062778;
} // Block from 82062768h-82062778h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82062778h
// Function 'D3DDevice_SetRenderState_BlendOp'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062778( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062778) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062778);
		  /* 82062778h */ case    0:  		/* oris R11, R11, 2048 */
		/* 82062778h case    0:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x800);
		/* 82062778h case    0:*/		return 0x8206277C;
		  /* 8206277Ch */ case    1:  		/* std R11, <#[R3 + 16]> */
		/* 8206277Ch case    1:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8206277Ch case    1:*/		return 0x82062780;
		  /* 82062780h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82062780h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062780h case    2:*/		return 0x82062784;
	}
	return 0x82062784;
} // Block from 82062778h-82062784h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82062784h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062784( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062784) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062784);
		  /* 82062784h */ case    0:  		/* nop */
		/* 82062784h case    0:*/		cpu::op::nop();
		/* 82062784h case    0:*/		return 0x82062788;
	}
	return 0x82062788;
} // Block from 82062784h-82062788h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062788h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062788( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062788) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062788);
		  /* 82062788h */ case    0:  		/* lis R11, -32256 */
		/* 82062788h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82062788h case    0:*/		return 0x8206278C;
		  /* 8206278Ch */ case    1:  		/* lfs FR12, <#[R3 + 10500]> */
		/* 8206278Ch case    1:*/		cpu::mem::load32f( regs, &regs.FR12, (uint32)(regs.R3 + 0x00002904) );
		/* 8206278Ch case    1:*/		return 0x82062790;
		  /* 82062790h */ case    2:  		/* lis R10, -32256 */
		/* 82062790h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82062790h case    2:*/		return 0x82062794;
		  /* 82062794h */ case    3:  		/* lfs FR0, <#[R11 + 2972]> */
		/* 82062794h case    3:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000B9C) );
		/* 82062794h case    3:*/		return 0x82062798;
		  /* 82062798h */ case    4:  		/* lfs FR13, <#[R10 + 1820]> */
		/* 82062798h case    4:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R10 + 0x0000071C) );
		/* 82062798h case    4:*/		return 0x8206279C;
		  /* 8206279Ch */ case    5:  		/* fmadds FR0, FR12, FR0, FR13 */
		/* 8206279Ch case    5:*/		cpu::op::fmadds<0>(regs,&regs.FR0,regs.FR12,regs.FR0,regs.FR13);
		/* 8206279Ch case    5:*/		return 0x820627A0;
		  /* 820627A0h */ case    6:  		/* fctidz FR0, FR0 */
		/* 820627A0h case    6:*/		cpu::op::fctidz<0>(regs,&regs.FR0,regs.FR0);
		/* 820627A0h case    6:*/		return 0x820627A4;
		  /* 820627A4h */ case    7:  		/* stfd FR0, <#[R1 - 16]> */
		/* 820627A4h case    7:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820627A4h case    7:*/		return 0x820627A8;
		  /* 820627A8h */ case    8:  		/* lwz R3, <#[R1 - 12]> */
		/* 820627A8h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0xFFFFFFF4) );
		/* 820627A8h case    8:*/		return 0x820627AC;
		  /* 820627ACh */ case    9:  		/* bclr 20, CR0_LT */
		/* 820627ACh case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820627ACh case    9:*/		return 0x820627B0;
	}
	return 0x820627B0;
} // Block from 82062788h-820627B0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820627B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820627B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820627B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820627B0);
		  /* 820627B0h */ case    0:  		/* lwz R11, <#[R3 + 10556]> */
		/* 820627B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000293C) );
		/* 820627B0h case    0:*/		return 0x820627B4;
		  /* 820627B4h */ case    1:  		/* rlwimi R4, R11, 0, 0, 28 */
		/* 820627B4h case    1:*/		cpu::op::rlwimi<0,0,0,28>(regs,&regs.R4,regs.R11);
		/* 820627B4h case    1:*/		return 0x820627B8;
		  /* 820627B8h */ case    2:  		/* stw R4, <#[R3 + 10556]> */
		/* 820627B8h case    2:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x0000293C) );
		/* 820627B8h case    2:*/		return 0x820627BC;
		  /* 820627BCh */ case    3:  		/* ld R11, <#[R3 + 16]> */
		/* 820627BCh case    3:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820627BCh case    3:*/		return 0x820627C0;
		  /* 820627C0h */ case    4:  		/* ori R11, R11, 512 */
		/* 820627C0h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x200);
		/* 820627C0h case    4:*/		return 0x820627C4;
		  /* 820627C4h */ case    5:  		/* std R11, <#[R3 + 16]> */
		/* 820627C4h case    5:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820627C4h case    5:*/		return 0x820627C8;
		  /* 820627C8h */ case    6:  		/* bclr 20, CR0_LT */
		/* 820627C8h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820627C8h case    6:*/		return 0x820627CC;
	}
	return 0x820627CC;
} // Block from 820627B0h-820627CCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820627CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820627CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820627CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820627CC);
		  /* 820627CCh */ case    0:  		/* nop */
		/* 820627CCh case    0:*/		cpu::op::nop();
		/* 820627CCh case    0:*/		return 0x820627D0;
	}
	return 0x820627D0;
} // Block from 820627CCh-820627D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820627D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820627D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820627D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820627D0);
		  /* 820627D0h */ case    0:  		/* lwz R11, <#[R3 + 10556]> */
		/* 820627D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000293C) );
		/* 820627D0h case    0:*/		return 0x820627D4;
		  /* 820627D4h */ case    1:  		/* rlwinm R3, R11, 0, 29, 31 */
		/* 820627D4h case    1:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R3,regs.R11);
		/* 820627D4h case    1:*/		return 0x820627D8;
		  /* 820627D8h */ case    2:  		/* bclr 20, CR0_LT */
		/* 820627D8h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820627D8h case    2:*/		return 0x820627DC;
	}
	return 0x820627DC;
} // Block from 820627D0h-820627DCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820627DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820627DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820627DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820627DC);
		  /* 820627DCh */ case    0:  		/* nop */
		/* 820627DCh case    0:*/		cpu::op::nop();
		/* 820627DCh case    0:*/		return 0x820627E0;
	}
	return 0x820627E0;
} // Block from 820627DCh-820627E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820627E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820627E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820627E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820627E0);
		  /* 820627E0h */ case    0:  		/* rlwinm R11, R4, 8, 24, 31 */
		/* 820627E0h case    0:*/		cpu::op::rlwinm<0,8,24,31>(regs,&regs.R11,regs.R4);
		/* 820627E0h case    0:*/		return 0x820627E4;
		  /* 820627E4h */ case    1:  		/* rlwinm R9, R4, 24, 24, 31 */
		/* 820627E4h case    1:*/		cpu::op::rlwinm<0,24,24,31>(regs,&regs.R9,regs.R4);
		/* 820627E4h case    1:*/		return 0x820627E8;
		  /* 820627E8h */ case    2:  		/* std R11, <#[R1 - 16]> */
		/* 820627E8h case    2:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820627E8h case    2:*/		return 0x820627EC;
		  /* 820627ECh */ case    3:  		/* lfd FR13, <#[R1 - 16]> */
		/* 820627ECh case    3:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820627ECh case    3:*/		return 0x820627F0;
		  /* 820627F0h */ case    4:  		/* std R9, <#[R1 - 16]> */
		/* 820627F0h case    4:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820627F0h case    4:*/		return 0x820627F4;
		  /* 820627F4h */ case    5:  		/* lfd FR0, <#[R1 - 16]> */
		/* 820627F4h case    5:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820627F4h case    5:*/		return 0x820627F8;
	}
	return 0x820627F8;
} // Block from 820627E0h-820627F8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820627F8h
// Function 'D3DDevice_GetRenderState_BlendOp'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820627F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820627F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820627F8);
		  /* 820627F8h */ case    0:  		/* rlwinm R10, R4, 16, 24, 31 */
		/* 820627F8h case    0:*/		cpu::op::rlwinm<0,16,24,31>(regs,&regs.R10,regs.R4);
		/* 820627F8h case    0:*/		return 0x820627FC;
		  /* 820627FCh */ case    1:  		/* rlwinm R11, R4, 0, 24, 31 */
		/* 820627FCh case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R4);
		/* 820627FCh case    1:*/		return 0x82062800;
		  /* 82062800h */ case    2:  		/* std R10, <#[R1 - 8]> */
		/* 82062800h case    2:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82062800h case    2:*/		return 0x82062804;
		  /* 82062804h */ case    3:  		/* lfd FR12, <#[R1 - 8]> */
		/* 82062804h case    3:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82062804h case    3:*/		return 0x82062808;
	}
	return 0x82062808;
} // Block from 820627F8h-82062808h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82062808h
// Function 'D3DDevice_SetRenderState_SrcBlend'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062808( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062808) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062808);
		  /* 82062808h */ case    0:  		/* std R11, <#[R1 - 8]> */
		/* 82062808h case    0:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82062808h case    0:*/		return 0x8206280C;
		  /* 8206280Ch */ case    1:  		/* lfd FR11, <#[R1 - 8]> */
		/* 8206280Ch case    1:*/		cpu::mem::load64f( regs, &regs.FR11, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206280Ch case    1:*/		return 0x82062810;
		  /* 82062810h */ case    2:  		/* fcfid FR11, FR11 */
		/* 82062810h case    2:*/		cpu::op::fcfid<0>(regs,&regs.FR11,regs.FR11);
		/* 82062810h case    2:*/		return 0x82062814;
		  /* 82062814h */ case    3:  		/* lis R10, -32256 */
		/* 82062814h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82062814h case    3:*/		return 0x82062818;
		  /* 82062818h */ case    4:  		/* fcfid FR10, FR0 */
		/* 82062818h case    4:*/		cpu::op::fcfid<0>(regs,&regs.FR10,regs.FR0);
		/* 82062818h case    4:*/		return 0x8206281C;
		  /* 8206281Ch */ case    5:  		/* lfs FR0, <#[R10 + 2968]> */
		/* 8206281Ch case    5:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000B98) );
		/* 8206281Ch case    5:*/		return 0x82062820;
		  /* 82062820h */ case    6:  		/* fcfid FR12, FR12 */
		/* 82062820h case    6:*/		cpu::op::fcfid<0>(regs,&regs.FR12,regs.FR12);
		/* 82062820h case    6:*/		return 0x82062824;
		  /* 82062824h */ case    7:  		/* li R12, 15 */
		/* 82062824h case    7:*/		cpu::op::li<0>(regs,&regs.R12,0xF);
		/* 82062824h case    7:*/		return 0x82062828;
		  /* 82062828h */ case    8:  		/* fcfid FR13, FR13 */
		/* 82062828h case    8:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 82062828h case    8:*/		return 0x8206282C;
		  /* 8206282Ch */ case    9:  		/* frsp FR11, FR11 */
		/* 8206282Ch case    9:*/		cpu::op::frsp<0>(regs,&regs.FR11,regs.FR11);
		/* 8206282Ch case    9:*/		return 0x82062830;
		  /* 82062830h */ case   10:  		/* rldicr R12, R12, 33, 30 */
		/* 82062830h case   10:*/		cpu::op::rldicr<0,33,30>(regs,&regs.R12,regs.R12);
		/* 82062830h case   10:*/		return 0x82062834;
		  /* 82062834h */ case   11:  		/* frsp FR10, FR10 */
		/* 82062834h case   11:*/		cpu::op::frsp<0>(regs,&regs.FR10,regs.FR10);
		/* 82062834h case   11:*/		return 0x82062838;
		  /* 82062838h */ case   12:  		/* frsp FR12, FR12 */
		/* 82062838h case   12:*/		cpu::op::frsp<0>(regs,&regs.FR12,regs.FR12);
		/* 82062838h case   12:*/		return 0x8206283C;
		  /* 8206283Ch */ case   13:  		/* frsp FR13, FR13 */
		/* 8206283Ch case   13:*/		cpu::op::frsp<0>(regs,&regs.FR13,regs.FR13);
		/* 8206283Ch case   13:*/		return 0x82062840;
		  /* 82062840h */ case   14:  		/* fmuls FR11, FR11, FR0 */
		/* 82062840h case   14:*/		cpu::op::fmuls<0>(regs,&regs.FR11,regs.FR11,regs.FR0);
		/* 82062840h case   14:*/		return 0x82062844;
		  /* 82062844h */ case   15:  		/* stfs FR11, <#[R3 + 10472]> */
		/* 82062844h case   15:*/		cpu::mem::store32f( regs, regs.FR11, (uint32)(regs.R3 + 0x000028E8) );
		/* 82062844h case   15:*/		return 0x82062848;
		  /* 82062848h */ case   16:  		/* fmuls FR11, FR10, FR0 */
		/* 82062848h case   16:*/		cpu::op::fmuls<0>(regs,&regs.FR11,regs.FR10,regs.FR0);
		/* 82062848h case   16:*/		return 0x8206284C;
		  /* 8206284Ch */ case   17:  		/* stfs FR11, <#[R3 + 10468]> */
		/* 8206284Ch case   17:*/		cpu::mem::store32f( regs, regs.FR11, (uint32)(regs.R3 + 0x000028E4) );
		/* 8206284Ch case   17:*/		return 0x82062850;
		  /* 82062850h */ case   18:  		/* fmuls FR12, FR12, FR0 */
		/* 82062850h case   18:*/		cpu::op::fmuls<0>(regs,&regs.FR12,regs.FR12,regs.FR0);
		/* 82062850h case   18:*/		return 0x82062854;
		  /* 82062854h */ case   19:  		/* stfs FR12, <#[R3 + 10464]> */
		/* 82062854h case   19:*/		cpu::mem::store32f( regs, regs.FR12, (uint32)(regs.R3 + 0x000028E0) );
		/* 82062854h case   19:*/		return 0x82062858;
		  /* 82062858h */ case   20:  		/* fmuls FR0, FR13, FR0 */
		/* 82062858h case   20:*/		cpu::op::fmuls<0>(regs,&regs.FR0,regs.FR13,regs.FR0);
		/* 82062858h case   20:*/		return 0x8206285C;
		  /* 8206285Ch */ case   21:  		/* stfs FR0, <#[R3 + 10476]> */
		/* 8206285Ch case   21:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R3 + 0x000028EC) );
		/* 8206285Ch case   21:*/		return 0x82062860;
		  /* 82062860h */ case   22:  		/* ld R11, <#[R3 + 16]> */
		/* 82062860h case   22:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062860h case   22:*/		return 0x82062864;
		  /* 82062864h */ case   23:  		/* or R11, R11, R12 */
		/* 82062864h case   23:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 82062864h case   23:*/		return 0x82062868;
		  /* 82062868h */ case   24:  		/* std R11, <#[R3 + 16]> */
		/* 82062868h case   24:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062868h case   24:*/		return 0x8206286C;
		  /* 8206286Ch */ case   25:  		/* bclr 20, CR0_LT */
		/* 8206286Ch case   25:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206286Ch case   25:*/		return 0x82062870;
	}
	return 0x82062870;
} // Block from 82062808h-82062870h (26 instructions)

//////////////////////////////////////////////////////
// Block at 82062870h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062870( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062870) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062870);
		  /* 82062870h */ case    0:  		/* lis R11, -32256 */
		/* 82062870h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82062870h case    0:*/		return 0x82062874;
		  /* 82062874h */ case    1:  		/* lfs FR12, <#[R3 + 10468]> */
		/* 82062874h case    1:*/		cpu::mem::load32f( regs, &regs.FR12, (uint32)(regs.R3 + 0x000028E4) );
		/* 82062874h case    1:*/		return 0x82062878;
		  /* 82062878h */ case    2:  		/* lis R10, -32256 */
		/* 82062878h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82062878h case    2:*/		return 0x8206287C;
		  /* 8206287Ch */ case    3:  		/* lfs FR11, <#[R3 + 10472]> */
		/* 8206287Ch case    3:*/		cpu::mem::load32f( regs, &regs.FR11, (uint32)(regs.R3 + 0x000028E8) );
		/* 8206287Ch case    3:*/		return 0x82062880;
		  /* 82062880h */ case    4:  		/* lfs FR10, <#[R3 + 10464]> */
		/* 82062880h case    4:*/		cpu::mem::load32f( regs, &regs.FR10, (uint32)(regs.R3 + 0x000028E0) );
		/* 82062880h case    4:*/		return 0x82062884;
		  /* 82062884h */ case    5:  		/* lfs FR9, <#[R3 + 10476]> */
		/* 82062884h case    5:*/		cpu::mem::load32f( regs, &regs.FR9, (uint32)(regs.R3 + 0x000028EC) );
		/* 82062884h case    5:*/		return 0x82062888;
	}
	return 0x82062888;
} // Block from 82062870h-82062888h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82062888h
// Function 'D3DDevice_GetRenderState_SrcBlend'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062888( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062888) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062888);
		  /* 82062888h */ case    0:  		/* lfs FR0, <#[R11 + 2972]> */
		/* 82062888h case    0:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000B9C) );
		/* 82062888h case    0:*/		return 0x8206288C;
		  /* 8206288Ch */ case    1:  		/* lfs FR13, <#[R10 + 1820]> */
		/* 8206288Ch case    1:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R10 + 0x0000071C) );
		/* 8206288Ch case    1:*/		return 0x82062890;
		  /* 82062890h */ case    2:  		/* fmadds FR12, FR12, FR0, FR13 */
		/* 82062890h case    2:*/		cpu::op::fmadds<0>(regs,&regs.FR12,regs.FR12,regs.FR0,regs.FR13);
		/* 82062890h case    2:*/		return 0x82062894;
		  /* 82062894h */ case    3:  		/* fmadds FR11, FR11, FR0, FR13 */
		/* 82062894h case    3:*/		cpu::op::fmadds<0>(regs,&regs.FR11,regs.FR11,regs.FR0,regs.FR13);
		/* 82062894h case    3:*/		return 0x82062898;
	}
	return 0x82062898;
} // Block from 82062888h-82062898h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82062898h
// Function 'D3DDevice_SetRenderState_DestBlend'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062898( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062898) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062898);
		  /* 82062898h */ case    0:  		/* fmadds FR10, FR10, FR0, FR13 */
		/* 82062898h case    0:*/		cpu::op::fmadds<0>(regs,&regs.FR10,regs.FR10,regs.FR0,regs.FR13);
		/* 82062898h case    0:*/		return 0x8206289C;
		  /* 8206289Ch */ case    1:  		/* fmadds FR0, FR9, FR0, FR13 */
		/* 8206289Ch case    1:*/		cpu::op::fmadds<0>(regs,&regs.FR0,regs.FR9,regs.FR0,regs.FR13);
		/* 8206289Ch case    1:*/		return 0x820628A0;
		  /* 820628A0h */ case    2:  		/* fctidz FR13, FR12 */
		/* 820628A0h case    2:*/		cpu::op::fctidz<0>(regs,&regs.FR13,regs.FR12);
		/* 820628A0h case    2:*/		return 0x820628A4;
		  /* 820628A4h */ case    3:  		/* stfd FR13, <#[R1 - 16]> */
		/* 820628A4h case    3:*/		cpu::mem::store64f( regs, regs.FR13, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820628A4h case    3:*/		return 0x820628A8;
		  /* 820628A8h */ case    4:  		/* lwz R11, <#[R1 - 12]> */
		/* 820628A8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0xFFFFFFF4) );
		/* 820628A8h case    4:*/		return 0x820628AC;
		  /* 820628ACh */ case    5:  		/* fctidz FR13, FR11 */
		/* 820628ACh case    5:*/		cpu::op::fctidz<0>(regs,&regs.FR13,regs.FR11);
		/* 820628ACh case    5:*/		return 0x820628B0;
		  /* 820628B0h */ case    6:  		/* stfd FR13, <#[R1 - 16]> */
		/* 820628B0h case    6:*/		cpu::mem::store64f( regs, regs.FR13, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820628B0h case    6:*/		return 0x820628B4;
		  /* 820628B4h */ case    7:  		/* lwz R3, <#[R1 - 12]> */
		/* 820628B4h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0xFFFFFFF4) );
		/* 820628B4h case    7:*/		return 0x820628B8;
		  /* 820628B8h */ case    8:  		/* fctidz FR13, FR10 */
		/* 820628B8h case    8:*/		cpu::op::fctidz<0>(regs,&regs.FR13,regs.FR10);
		/* 820628B8h case    8:*/		return 0x820628BC;
		  /* 820628BCh */ case    9:  		/* stfd FR13, <#[R1 - 16]> */
		/* 820628BCh case    9:*/		cpu::mem::store64f( regs, regs.FR13, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820628BCh case    9:*/		return 0x820628C0;
		  /* 820628C0h */ case   10:  		/* fctidz FR0, FR0 */
		/* 820628C0h case   10:*/		cpu::op::fctidz<0>(regs,&regs.FR0,regs.FR0);
		/* 820628C0h case   10:*/		return 0x820628C4;
		  /* 820628C4h */ case   11:  		/* stfd FR0, <#[R1 - 8]> */
		/* 820628C4h case   11:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820628C4h case   11:*/		return 0x820628C8;
		  /* 820628C8h */ case   12:  		/* lwz R10, <#[R1 - 12]> */
		/* 820628C8h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0xFFFFFFF4) );
		/* 820628C8h case   12:*/		return 0x820628CC;
		  /* 820628CCh */ case   13:  		/* lwz R9, <#[R1 - 4]> */
		/* 820628CCh case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0xFFFFFFFC) );
		/* 820628CCh case   13:*/		return 0x820628D0;
		  /* 820628D0h */ case   14:  		/* rlwimi R10, R9, 8, 0, 23 */
		/* 820628D0h case   14:*/		cpu::op::rlwimi<0,8,0,23>(regs,&regs.R10,regs.R9);
		/* 820628D0h case   14:*/		return 0x820628D4;
		  /* 820628D4h */ case   15:  		/* rlwimi R11, R10, 8, 0, 23 */
		/* 820628D4h case   15:*/		cpu::op::rlwimi<0,8,0,23>(regs,&regs.R11,regs.R10);
		/* 820628D4h case   15:*/		return 0x820628D8;
		  /* 820628D8h */ case   16:  		/* rlwimi R3, R11, 8, 0, 23 */
		/* 820628D8h case   16:*/		cpu::op::rlwimi<0,8,0,23>(regs,&regs.R3,regs.R11);
		/* 820628D8h case   16:*/		return 0x820628DC;
		  /* 820628DCh */ case   17:  		/* bclr 20, CR0_LT */
		/* 820628DCh case   17:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820628DCh case   17:*/		return 0x820628E0;
	}
	return 0x820628E0;
} // Block from 82062898h-820628E0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820628E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820628E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820628E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820628E0);
		  /* 820628E0h */ case    0:  		/* lwz R11, <#[R3 + 10680]> */
		/* 820628E0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000029B8) );
		/* 820628E0h case    0:*/		return 0x820628E4;
		  /* 820628E4h */ case    1:  		/* li R12, 1 */
		/* 820628E4h case    1:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 820628E4h case    1:*/		return 0x820628E8;
		  /* 820628E8h */ case    2:  		/* rlwimi R11, R4, 10, 21, 21 */
		/* 820628E8h case    2:*/		cpu::op::rlwimi<0,10,21,21>(regs,&regs.R11,regs.R4);
		/* 820628E8h case    2:*/		return 0x820628EC;
		  /* 820628ECh */ case    3:  		/* rldicr R12, R12, 37, 63 */
		/* 820628ECh case    3:*/		cpu::op::rldicr<0,37,63>(regs,&regs.R12,regs.R12);
		/* 820628ECh case    3:*/		return 0x820628F0;
		  /* 820628F0h */ case    4:  		/* stw R11, <#[R3 + 10680]> */
		/* 820628F0h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x000029B8) );
		/* 820628F0h case    4:*/		return 0x820628F4;
		  /* 820628F4h */ case    5:  		/* ld R11, <#[R3 + 32]> */
		/* 820628F4h case    5:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 820628F4h case    5:*/		return 0x820628F8;
		  /* 820628F8h */ case    6:  		/* or R11, R11, R12 */
		/* 820628F8h case    6:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 820628F8h case    6:*/		return 0x820628FC;
		  /* 820628FCh */ case    7:  		/* std R11, <#[R3 + 32]> */
		/* 820628FCh case    7:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 820628FCh case    7:*/		return 0x82062900;
		  /* 82062900h */ case    8:  		/* bclr 20, CR0_LT */
		/* 82062900h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062900h case    8:*/		return 0x82062904;
	}
	return 0x82062904;
} // Block from 820628E0h-82062904h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82062904h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062904( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062904) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062904);
		  /* 82062904h */ case    0:  		/* nop */
		/* 82062904h case    0:*/		cpu::op::nop();
		/* 82062904h case    0:*/		return 0x82062908;
	}
	return 0x82062908;
} // Block from 82062904h-82062908h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062908h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062908( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062908) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062908);
		  /* 82062908h */ case    0:  		/* lwz R11, <#[R3 + 10680]> */
		/* 82062908h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000029B8) );
		/* 82062908h case    0:*/		return 0x8206290C;
		  /* 8206290Ch */ case    1:  		/* rlwinm R3, R11, 22, 31, 31 */
		/* 8206290Ch case    1:*/		cpu::op::rlwinm<0,22,31,31>(regs,&regs.R3,regs.R11);
		/* 8206290Ch case    1:*/		return 0x82062910;
		  /* 82062910h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82062910h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062910h case    2:*/		return 0x82062914;
	}
	return 0x82062914;
} // Block from 82062908h-82062914h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82062914h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062914( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062914) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062914);
		  /* 82062914h */ case    0:  		/* nop */
		/* 82062914h case    0:*/		cpu::op::nop();
		/* 82062914h case    0:*/		return 0x82062918;
	}
	return 0x82062918;
} // Block from 82062914h-82062918h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062918h
// Function 'D3DDevice_GetRenderState_DestBlend'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062918( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062918) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062918);
		  /* 82062918h */ case    0:  		/* lis R11, -32256 */
		/* 82062918h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82062918h case    0:*/		return 0x8206291C;
		  /* 8206291Ch */ case    1:  		/* stw R4, <#[R1 + 28]> */
		/* 8206291Ch case    1:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000001C) );
		/* 8206291Ch case    1:*/		return 0x82062920;
		  /* 82062920h */ case    2:  		/* lfs FR13, <#[R1 + 28]> */
		/* 82062920h case    2:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R1 + 0x0000001C) );
		/* 82062920h case    2:*/		return 0x82062924;
		  /* 82062924h */ case    3:  		/* li R12, 1 */
		/* 82062924h case    3:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 82062924h case    3:*/		return 0x82062928;
	}
	return 0x82062928;
} // Block from 82062918h-82062928h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82062928h
// Function 'D3DDevice_SetRenderState_BlendOpAlpha'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062928( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062928) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062928);
		  /* 82062928h */ case    0:  		/* rldicr R12, R12, 52, 63 */
		/* 82062928h case    0:*/		cpu::op::rldicr<0,52,63>(regs,&regs.R12,regs.R12);
		/* 82062928h case    0:*/		return 0x8206292C;
		  /* 8206292Ch */ case    1:  		/* lfs FR0, <#[R11 + 2964]> */
		/* 8206292Ch case    1:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000B94) );
		/* 8206292Ch case    1:*/		return 0x82062930;
		  /* 82062930h */ case    2:  		/* fmuls FR0, FR13, FR0 */
		/* 82062930h case    2:*/		cpu::op::fmuls<0>(regs,&regs.FR0,regs.FR13,regs.FR0);
		/* 82062930h case    2:*/		return 0x82062934;
		  /* 82062934h */ case    3:  		/* fctidz FR0, FR0 */
		/* 82062934h case    3:*/		cpu::op::fctidz<0>(regs,&regs.FR0,regs.FR0);
		/* 82062934h case    3:*/		return 0x82062938;
		  /* 82062938h */ case    4:  		/* stfd FR0, <#[R1 - 16]> */
		/* 82062938h case    4:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82062938h case    4:*/		return 0x8206293C;
		  /* 8206293Ch */ case    5:  		/* lwz R11, <#[R1 - 12]> */
		/* 8206293Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0xFFFFFFF4) );
		/* 8206293Ch case    5:*/		return 0x82062940;
		  /* 82062940h */ case    6:  		/* sth R11, <#[R3 + 10606]> */
		/* 82062940h case    6:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R3 + 0x0000296E) );
		/* 82062940h case    6:*/		return 0x82062944;
		  /* 82062944h */ case    7:  		/* ld R11, <#[R3 + 24]> */
		/* 82062944h case    7:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82062944h case    7:*/		return 0x82062948;
		  /* 82062948h */ case    8:  		/* or R11, R11, R12 */
		/* 82062948h case    8:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 82062948h case    8:*/		return 0x8206294C;
		  /* 8206294Ch */ case    9:  		/* std R11, <#[R3 + 24]> */
		/* 8206294Ch case    9:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 8206294Ch case    9:*/		return 0x82062950;
		  /* 82062950h */ case   10:  		/* bclr 20, CR0_LT */
		/* 82062950h case   10:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062950h case   10:*/		return 0x82062954;
	}
	return 0x82062954;
} // Block from 82062928h-82062954h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82062954h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062954( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062954) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062954);
		  /* 82062954h */ case    0:  		/* nop */
		/* 82062954h case    0:*/		cpu::op::nop();
		/* 82062954h case    0:*/		return 0x82062958;
	}
	return 0x82062958;
} // Block from 82062954h-82062958h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062958h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062958( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062958) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062958);
		  /* 82062958h */ case    0:  		/* lhz R11, <#[R3 + 10606]> */
		/* 82062958h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000296E) );
		/* 82062958h case    0:*/		return 0x8206295C;
		  /* 8206295Ch */ case    1:  		/* lis R10, -32256 */
		/* 8206295Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 8206295Ch case    1:*/		return 0x82062960;
		  /* 82062960h */ case    2:  		/* extsw R11, R11 */
		/* 82062960h case    2:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R11);
		/* 82062960h case    2:*/		return 0x82062964;
		  /* 82062964h */ case    3:  		/* std R11, <#[R1 - 16]> */
		/* 82062964h case    3:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82062964h case    3:*/		return 0x82062968;
		  /* 82062968h */ case    4:  		/* lfd FR0, <#[R1 - 16]> */
		/* 82062968h case    4:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82062968h case    4:*/		return 0x8206296C;
		  /* 8206296Ch */ case    5:  		/* fcfid FR13, FR0 */
		/* 8206296Ch case    5:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR0);
		/* 8206296Ch case    5:*/		return 0x82062970;
		  /* 82062970h */ case    6:  		/* lfs FR0, <#[R10 + 2660]> */
		/* 82062970h case    6:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000A64) );
		/* 82062970h case    6:*/		return 0x82062974;
		  /* 82062974h */ case    7:  		/* frsp FR13, FR13 */
		/* 82062974h case    7:*/		cpu::op::frsp<0>(regs,&regs.FR13,regs.FR13);
		/* 82062974h case    7:*/		return 0x82062978;
		  /* 82062978h */ case    8:  		/* fmuls FR0, FR13, FR0 */
		/* 82062978h case    8:*/		cpu::op::fmuls<0>(regs,&regs.FR0,regs.FR13,regs.FR0);
		/* 82062978h case    8:*/		return 0x8206297C;
		  /* 8206297Ch */ case    9:  		/* stfs FR0, <#[R1 - 16]> */
		/* 8206297Ch case    9:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206297Ch case    9:*/		return 0x82062980;
		  /* 82062980h */ case   10:  		/* lwz R3, <#[R1 - 16]> */
		/* 82062980h case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82062980h case   10:*/		return 0x82062984;
		  /* 82062984h */ case   11:  		/* bclr 20, CR0_LT */
		/* 82062984h case   11:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062984h case   11:*/		return 0x82062988;
	}
	return 0x82062988;
} // Block from 82062958h-82062988h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82062988h
// Function 'D3DDevice_GetRenderState_BlendOpAlpha'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062988( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062988) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062988);
		  /* 82062988h */ case    0:  		/* lwz R11, <#[R3 + 24392]> */
		/* 82062988h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00005F48) );
		/* 82062988h case    0:*/		return 0x8206298C;
		  /* 8206298Ch */ case    1:  		/* cmplwi CR6, R4, 0 */
		/* 8206298Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8206298Ch case    1:*/		return 0x82062990;
		  /* 82062990h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 82062990h case    2:*/		if ( regs.CR[6].eq ) { return 0x8206299C;  }
		/* 82062990h case    2:*/		return 0x82062994;
		  /* 82062994h */ case    3:  		/* ori R11, R11, 1 */
		/* 82062994h case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82062994h case    3:*/		return 0x82062998;
	}
	return 0x82062998;
} // Block from 82062988h-82062998h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82062998h
// Function 'D3DDevice_SetRenderState_SrcBlendAlpha'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062998( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062998) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062998);
		  /* 82062998h */ case    0:  		/* b 8 */
		/* 82062998h case    0:*/		return 0x820629A0;
		/* 82062998h case    0:*/		return 0x8206299C;
	}
	return 0x8206299C;
} // Block from 82062998h-8206299Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206299Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206299C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206299C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206299C);
		  /* 8206299Ch */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 8206299Ch case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 8206299Ch case    0:*/		return 0x820629A0;
	}
	return 0x820629A0;
} // Block from 8206299Ch-820629A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820629A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820629A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820629A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820629A0);
		  /* 820629A0h */ case    0:  		/* stw R11, <#[R3 + 24392]> */
		/* 820629A0h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00005F48) );
		/* 820629A0h case    0:*/		return 0x820629A4;
		  /* 820629A4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820629A4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820629A4h case    1:*/		return 0x820629A8;
	}
	return 0x820629A8;
} // Block from 820629A0h-820629A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820629A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820629A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820629A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820629A8);
		  /* 820629A8h */ case    0:  		/* lwz R11, <#[R3 + 24392]> */
		/* 820629A8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00005F48) );
		/* 820629A8h case    0:*/		return 0x820629AC;
		  /* 820629ACh */ case    1:  		/* rlwinm R3, R11, 0, 31, 31 */
		/* 820629ACh case    1:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R3,regs.R11);
		/* 820629ACh case    1:*/		return 0x820629B0;
		  /* 820629B0h */ case    2:  		/* bclr 20, CR0_LT */
		/* 820629B0h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820629B0h case    2:*/		return 0x820629B4;
	}
	return 0x820629B4;
} // Block from 820629A8h-820629B4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820629B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820629B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820629B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820629B4);
		  /* 820629B4h */ case    0:  		/* nop */
		/* 820629B4h case    0:*/		cpu::op::nop();
		/* 820629B4h case    0:*/		return 0x820629B8;
	}
	return 0x820629B8;
} // Block from 820629B4h-820629B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820629B8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820629B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820629B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820629B8);
		  /* 820629B8h */ case    0:  		/* lwz R11, <#[R3 + 12832]> */
		/* 820629B8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00003220) );
		/* 820629B8h case    0:*/		return 0x820629BC;
		  /* 820629BCh */ case    1:  		/* lwz R10, <#[R3 + 10548]> */
		/* 820629BCh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00002934) );
		/* 820629BCh case    1:*/		return 0x820629C0;
		  /* 820629C0h */ case    2:  		/* subfic R11, R11, 0 */
		/* 820629C0h case    2:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x0);
		/* 820629C0h case    2:*/		return 0x820629C4;
		  /* 820629C4h */ case    3:  		/* stw R4, <#[R3 + 12308]> */
		/* 820629C4h case    3:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00003014) );
		/* 820629C4h case    3:*/		return 0x820629C8;
		  /* 820629C8h */ case    4:  		/* subfe R11, R11, R11 */
		/* 820629C8h case    4:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 820629C8h case    4:*/		return 0x820629CC;
		  /* 820629CCh */ case    5:  		/* and R11, R11, R4 */
		/* 820629CCh case    5:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R4);
		/* 820629CCh case    5:*/		return 0x820629D0;
		  /* 820629D0h */ case    6:  		/* rlwimi R10, R11, 1, 30, 30 */
		/* 820629D0h case    6:*/		cpu::op::rlwimi<0,1,30,30>(regs,&regs.R10,regs.R11);
		/* 820629D0h case    6:*/		return 0x820629D4;
		  /* 820629D4h */ case    7:  		/* stw R10, <#[R3 + 10548]> */
		/* 820629D4h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00002934) );
		/* 820629D4h case    7:*/		return 0x820629D8;
		  /* 820629D8h */ case    8:  		/* ld R11, <#[R3 + 16]> */
		/* 820629D8h case    8:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820629D8h case    8:*/		return 0x820629DC;
		  /* 820629DCh */ case    9:  		/* ori R11, R11, 2048 */
		/* 820629DCh case    9:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x800);
		/* 820629DCh case    9:*/		return 0x820629E0;
		  /* 820629E0h */ case   10:  		/* std R11, <#[R3 + 16]> */
		/* 820629E0h case   10:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820629E0h case   10:*/		return 0x820629E4;
		  /* 820629E4h */ case   11:  		/* oris R11, R11, 2 */
		/* 820629E4h case   11:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x2);
		/* 820629E4h case   11:*/		return 0x820629E8;
		  /* 820629E8h */ case   12:  		/* std R11, <#[R3 + 16]> */
		/* 820629E8h case   12:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820629E8h case   12:*/		return 0x820629EC;
		  /* 820629ECh */ case   13:  		/* bclr 20, CR0_LT */
		/* 820629ECh case   13:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820629ECh case   13:*/		return 0x820629F0;
	}
	return 0x820629F0;
} // Block from 820629B8h-820629F0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820629F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820629F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820629F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820629F0);
		  /* 820629F0h */ case    0:  		/* lwz R3, <#[R3 + 12308]> */
		/* 820629F0h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00003014) );
		/* 820629F0h case    0:*/		return 0x820629F4;
		  /* 820629F4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820629F4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820629F4h case    1:*/		return 0x820629F8;
	}
	return 0x820629F8;
} // Block from 820629F0h-820629F8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820629F8h
// Function 'D3DDevice_GetRenderState_SrcBlendAlpha'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820629F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820629F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820629F8);
		  /* 820629F8h */ case    0:  		/* lwz R11, <#[R3 + 10548]> */
		/* 820629F8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002934) );
		/* 820629F8h case    0:*/		return 0x820629FC;
		  /* 820629FCh */ case    1:  		/* rlwimi R11, R4, 2, 29, 29 */
		/* 820629FCh case    1:*/		cpu::op::rlwimi<0,2,29,29>(regs,&regs.R11,regs.R4);
		/* 820629FCh case    1:*/		return 0x82062A00;
		  /* 82062A00h */ case    2:  		/* stw R11, <#[R3 + 10548]> */
		/* 82062A00h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002934) );
		/* 82062A00h case    2:*/		return 0x82062A04;
		  /* 82062A04h */ case    3:  		/* ld R11, <#[R3 + 16]> */
		/* 82062A04h case    3:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062A04h case    3:*/		return 0x82062A08;
	}
	return 0x82062A08;
} // Block from 820629F8h-82062A08h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82062A08h
// Function 'D3DDevice_SetRenderState_DestBlendAlpha'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062A08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062A08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062A08);
		  /* 82062A08h */ case    0:  		/* ori R11, R11, 2048 */
		/* 82062A08h case    0:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x800);
		/* 82062A08h case    0:*/		return 0x82062A0C;
		  /* 82062A0Ch */ case    1:  		/* std R11, <#[R3 + 16]> */
		/* 82062A0Ch case    1:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062A0Ch case    1:*/		return 0x82062A10;
		  /* 82062A10h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82062A10h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062A10h case    2:*/		return 0x82062A14;
	}
	return 0x82062A14;
} // Block from 82062A08h-82062A14h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82062A14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062A14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062A14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062A14);
		  /* 82062A14h */ case    0:  		/* nop */
		/* 82062A14h case    0:*/		cpu::op::nop();
		/* 82062A14h case    0:*/		return 0x82062A18;
	}
	return 0x82062A18;
} // Block from 82062A14h-82062A18h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062A18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062A18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062A18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062A18);
		  /* 82062A18h */ case    0:  		/* lwz R11, <#[R3 + 10548]> */
		/* 82062A18h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002934) );
		/* 82062A18h case    0:*/		return 0x82062A1C;
		  /* 82062A1Ch */ case    1:  		/* rlwinm R3, R11, 30, 31, 31 */
		/* 82062A1Ch case    1:*/		cpu::op::rlwinm<0,30,31,31>(regs,&regs.R3,regs.R11);
		/* 82062A1Ch case    1:*/		return 0x82062A20;
		  /* 82062A20h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82062A20h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062A20h case    2:*/		return 0x82062A24;
	}
	return 0x82062A24;
} // Block from 82062A18h-82062A24h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82062A24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062A24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062A24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062A24);
		  /* 82062A24h */ case    0:  		/* nop */
		/* 82062A24h case    0:*/		cpu::op::nop();
		/* 82062A24h case    0:*/		return 0x82062A28;
	}
	return 0x82062A28;
} // Block from 82062A24h-82062A28h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062A28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062A28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062A28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062A28);
		  /* 82062A28h */ case    0:  		/* lwz R11, <#[R3 + 10548]> */
		/* 82062A28h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002934) );
		/* 82062A28h case    0:*/		return 0x82062A2C;
		  /* 82062A2Ch */ case    1:  		/* rlwimi R11, R4, 4, 25, 27 */
		/* 82062A2Ch case    1:*/		cpu::op::rlwimi<0,4,25,27>(regs,&regs.R11,regs.R4);
		/* 82062A2Ch case    1:*/		return 0x82062A30;
		  /* 82062A30h */ case    2:  		/* stw R11, <#[R3 + 10548]> */
		/* 82062A30h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002934) );
		/* 82062A30h case    2:*/		return 0x82062A34;
		  /* 82062A34h */ case    3:  		/* ld R11, <#[R3 + 16]> */
		/* 82062A34h case    3:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062A34h case    3:*/		return 0x82062A38;
		  /* 82062A38h */ case    4:  		/* ori R11, R11, 2048 */
		/* 82062A38h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x800);
		/* 82062A38h case    4:*/		return 0x82062A3C;
		  /* 82062A3Ch */ case    5:  		/* std R11, <#[R3 + 16]> */
		/* 82062A3Ch case    5:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062A3Ch case    5:*/		return 0x82062A40;
		  /* 82062A40h */ case    6:  		/* oris R11, R11, 2 */
		/* 82062A40h case    6:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82062A40h case    6:*/		return 0x82062A44;
		  /* 82062A44h */ case    7:  		/* std R11, <#[R3 + 16]> */
		/* 82062A44h case    7:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062A44h case    7:*/		return 0x82062A48;
		  /* 82062A48h */ case    8:  		/* bclr 20, CR0_LT */
		/* 82062A48h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062A48h case    8:*/		return 0x82062A4C;
	}
	return 0x82062A4C;
} // Block from 82062A28h-82062A4Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 82062A4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062A4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062A4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062A4C);
		  /* 82062A4Ch */ case    0:  		/* nop */
		/* 82062A4Ch case    0:*/		cpu::op::nop();
		/* 82062A4Ch case    0:*/		return 0x82062A50;
	}
	return 0x82062A50;
} // Block from 82062A4Ch-82062A50h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062A50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062A50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062A50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062A50);
		  /* 82062A50h */ case    0:  		/* lwz R11, <#[R3 + 10548]> */
		/* 82062A50h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002934) );
		/* 82062A50h case    0:*/		return 0x82062A54;
		  /* 82062A54h */ case    1:  		/* rlwinm R3, R11, 28, 29, 31 */
		/* 82062A54h case    1:*/		cpu::op::rlwinm<0,28,29,31>(regs,&regs.R3,regs.R11);
		/* 82062A54h case    1:*/		return 0x82062A58;
		  /* 82062A58h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82062A58h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062A58h case    2:*/		return 0x82062A5C;
	}
	return 0x82062A5C;
} // Block from 82062A50h-82062A5Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82062A5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062A5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062A5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062A5C);
		  /* 82062A5Ch */ case    0:  		/* nop */
		/* 82062A5Ch case    0:*/		cpu::op::nop();
		/* 82062A5Ch case    0:*/		return 0x82062A60;
	}
	return 0x82062A60;
} // Block from 82062A5Ch-82062A60h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062A60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062A60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062A60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062A60);
		  /* 82062A60h */ case    0:  		/* lwz R11, <#[R3 + 12832]> */
		/* 82062A60h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00003220) );
		/* 82062A60h case    0:*/		return 0x82062A64;
		  /* 82062A64h */ case    1:  		/* lwz R10, <#[R3 + 10548]> */
		/* 82062A64h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00002934) );
		/* 82062A64h case    1:*/		return 0x82062A68;
	}
	return 0x82062A68;
} // Block from 82062A60h-82062A68h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82062A68h
// Function 'D3DDevice_GetRenderState_DestBlendAlpha'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062A68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062A68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062A68);
		  /* 82062A68h */ case    0:  		/* subfic R11, R11, 0 */
		/* 82062A68h case    0:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x0);
		/* 82062A68h case    0:*/		return 0x82062A6C;
		  /* 82062A6Ch */ case    1:  		/* stw R4, <#[R3 + 12312]> */
		/* 82062A6Ch case    1:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00003018) );
		/* 82062A6Ch case    1:*/		return 0x82062A70;
		  /* 82062A70h */ case    2:  		/* subfe R11, R11, R11 */
		/* 82062A70h case    2:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82062A70h case    2:*/		return 0x82062A74;
		  /* 82062A74h */ case    3:  		/* and R11, R11, R4 */
		/* 82062A74h case    3:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R4);
		/* 82062A74h case    3:*/		return 0x82062A78;
	}
	return 0x82062A78;
} // Block from 82062A68h-82062A78h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82062A78h
// Function 'D3DDevice_SetRenderState_SeparateAlphaBlendEnable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062A78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062A78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062A78);
		  /* 82062A78h */ case    0:  		/* rlwimi R10, R11, 0, 31, 31 */
		/* 82062A78h case    0:*/		cpu::op::rlwimi<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82062A78h case    0:*/		return 0x82062A7C;
		  /* 82062A7Ch */ case    1:  		/* stw R10, <#[R3 + 10548]> */
		/* 82062A7Ch case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00002934) );
		/* 82062A7Ch case    1:*/		return 0x82062A80;
		  /* 82062A80h */ case    2:  		/* ld R11, <#[R3 + 16]> */
		/* 82062A80h case    2:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062A80h case    2:*/		return 0x82062A84;
		  /* 82062A84h */ case    3:  		/* ori R11, R11, 2048 */
		/* 82062A84h case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x800);
		/* 82062A84h case    3:*/		return 0x82062A88;
		  /* 82062A88h */ case    4:  		/* std R11, <#[R3 + 16]> */
		/* 82062A88h case    4:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062A88h case    4:*/		return 0x82062A8C;
		  /* 82062A8Ch */ case    5:  		/* oris R11, R11, 2 */
		/* 82062A8Ch case    5:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82062A8Ch case    5:*/		return 0x82062A90;
		  /* 82062A90h */ case    6:  		/* std R11, <#[R3 + 16]> */
		/* 82062A90h case    6:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062A90h case    6:*/		return 0x82062A94;
		  /* 82062A94h */ case    7:  		/* bclr 20, CR0_LT */
		/* 82062A94h case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062A94h case    7:*/		return 0x82062A98;
	}
	return 0x82062A98;
} // Block from 82062A78h-82062A98h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82062A98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062A98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062A98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062A98);
		  /* 82062A98h */ case    0:  		/* lwz R3, <#[R3 + 12312]> */
		/* 82062A98h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00003018) );
		/* 82062A98h case    0:*/		return 0x82062A9C;
		  /* 82062A9Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 82062A9Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062A9Ch case    1:*/		return 0x82062AA0;
	}
	return 0x82062AA0;
} // Block from 82062A98h-82062AA0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82062AA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062AA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062AA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062AA0);
		  /* 82062AA0h */ case    0:  		/* lwz R11, <#[R3 + 10548]> */
		/* 82062AA0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002934) );
		/* 82062AA0h case    0:*/		return 0x82062AA4;
		  /* 82062AA4h */ case    1:  		/* rlwimi R11, R4, 7, 24, 24 */
		/* 82062AA4h case    1:*/		cpu::op::rlwimi<0,7,24,24>(regs,&regs.R11,regs.R4);
		/* 82062AA4h case    1:*/		return 0x82062AA8;
		  /* 82062AA8h */ case    2:  		/* stw R11, <#[R3 + 10548]> */
		/* 82062AA8h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002934) );
		/* 82062AA8h case    2:*/		return 0x82062AAC;
		  /* 82062AACh */ case    3:  		/* ld R11, <#[R3 + 16]> */
		/* 82062AACh case    3:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062AACh case    3:*/		return 0x82062AB0;
		  /* 82062AB0h */ case    4:  		/* ori R11, R11, 2048 */
		/* 82062AB0h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x800);
		/* 82062AB0h case    4:*/		return 0x82062AB4;
		  /* 82062AB4h */ case    5:  		/* std R11, <#[R3 + 16]> */
		/* 82062AB4h case    5:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062AB4h case    5:*/		return 0x82062AB8;
		  /* 82062AB8h */ case    6:  		/* oris R11, R11, 2 */
		/* 82062AB8h case    6:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82062AB8h case    6:*/		return 0x82062ABC;
		  /* 82062ABCh */ case    7:  		/* std R11, <#[R3 + 16]> */
		/* 82062ABCh case    7:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062ABCh case    7:*/		return 0x82062AC0;
		  /* 82062AC0h */ case    8:  		/* bclr 20, CR0_LT */
		/* 82062AC0h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062AC0h case    8:*/		return 0x82062AC4;
	}
	return 0x82062AC4;
} // Block from 82062AA0h-82062AC4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82062AC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062AC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062AC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062AC4);
		  /* 82062AC4h */ case    0:  		/* nop */
		/* 82062AC4h case    0:*/		cpu::op::nop();
		/* 82062AC4h case    0:*/		return 0x82062AC8;
	}
	return 0x82062AC8;
} // Block from 82062AC4h-82062AC8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062AC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062AC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062AC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062AC8);
		  /* 82062AC8h */ case    0:  		/* lwz R11, <#[R3 + 10548]> */
		/* 82062AC8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002934) );
		/* 82062AC8h case    0:*/		return 0x82062ACC;
		  /* 82062ACCh */ case    1:  		/* rlwinm R3, R11, 25, 31, 31 */
		/* 82062ACCh case    1:*/		cpu::op::rlwinm<0,25,31,31>(regs,&regs.R3,regs.R11);
		/* 82062ACCh case    1:*/		return 0x82062AD0;
		  /* 82062AD0h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82062AD0h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062AD0h case    2:*/		return 0x82062AD4;
	}
	return 0x82062AD4;
} // Block from 82062AC8h-82062AD4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82062AD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062AD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062AD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062AD4);
		  /* 82062AD4h */ case    0:  		/* nop */
		/* 82062AD4h case    0:*/		cpu::op::nop();
		/* 82062AD4h case    0:*/		return 0x82062AD8;
	}
	return 0x82062AD8;
} // Block from 82062AD4h-82062AD8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062AD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062AD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062AD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062AD8);
		  /* 82062AD8h */ case    0:  		/* lwz R11, <#[R3 + 10548]> */
		/* 82062AD8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002934) );
		/* 82062AD8h case    0:*/		return 0x82062ADC;
		  /* 82062ADCh */ case    1:  		/* rlwimi R11, R4, 8, 21, 23 */
		/* 82062ADCh case    1:*/		cpu::op::rlwimi<0,8,21,23>(regs,&regs.R11,regs.R4);
		/* 82062ADCh case    1:*/		return 0x82062AE0;
		  /* 82062AE0h */ case    2:  		/* stw R11, <#[R3 + 10548]> */
		/* 82062AE0h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002934) );
		/* 82062AE0h case    2:*/		return 0x82062AE4;
		  /* 82062AE4h */ case    3:  		/* ld R11, <#[R3 + 16]> */
		/* 82062AE4h case    3:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062AE4h case    3:*/		return 0x82062AE8;
		  /* 82062AE8h */ case    4:  		/* ori R11, R11, 2048 */
		/* 82062AE8h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x800);
		/* 82062AE8h case    4:*/		return 0x82062AEC;
		  /* 82062AECh */ case    5:  		/* std R11, <#[R3 + 16]> */
		/* 82062AECh case    5:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062AECh case    5:*/		return 0x82062AF0;
		  /* 82062AF0h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82062AF0h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062AF0h case    6:*/		return 0x82062AF4;
	}
	return 0x82062AF4;
} // Block from 82062AD8h-82062AF4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82062AF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062AF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062AF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062AF4);
		  /* 82062AF4h */ case    0:  		/* nop */
		/* 82062AF4h case    0:*/		cpu::op::nop();
		/* 82062AF4h case    0:*/		return 0x82062AF8;
	}
	return 0x82062AF8;
} // Block from 82062AF4h-82062AF8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062AF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062AF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062AF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062AF8);
		  /* 82062AF8h */ case    0:  		/* lwz R11, <#[R3 + 10548]> */
		/* 82062AF8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002934) );
		/* 82062AF8h case    0:*/		return 0x82062AFC;
		  /* 82062AFCh */ case    1:  		/* rlwinm R3, R11, 24, 29, 31 */
		/* 82062AFCh case    1:*/		cpu::op::rlwinm<0,24,29,31>(regs,&regs.R3,regs.R11);
		/* 82062AFCh case    1:*/		return 0x82062B00;
	}
	return 0x82062B00;
} // Block from 82062AF8h-82062B00h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82062B00h
// Function 'D3DDevice_GetRenderState_SeparateAlphaBlendEnable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062B00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062B00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062B00);
		  /* 82062B00h */ case    0:  		/* bclr 20, CR0_LT */
		/* 82062B00h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062B00h case    0:*/		return 0x82062B04;
	}
	return 0x82062B04;
} // Block from 82062B00h-82062B04h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062B04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062B04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062B04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062B04);
		  /* 82062B04h */ case    0:  		/* nop */
		/* 82062B04h case    0:*/		cpu::op::nop();
		/* 82062B04h case    0:*/		return 0x82062B08;
	}
	return 0x82062B08;
} // Block from 82062B04h-82062B08h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062B08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062B08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062B08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062B08);
		  /* 82062B08h */ case    0:  		/* lwz R11, <#[R3 + 10548]> */
		/* 82062B08h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002934) );
		/* 82062B08h case    0:*/		return 0x82062B0C;
		  /* 82062B0Ch */ case    1:  		/* rlwimi R11, R4, 11, 18, 20 */
		/* 82062B0Ch case    1:*/		cpu::op::rlwimi<0,11,18,20>(regs,&regs.R11,regs.R4);
		/* 82062B0Ch case    1:*/		return 0x82062B10;
	}
	return 0x82062B10;
} // Block from 82062B08h-82062B10h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82062B10h
// Function 'D3DDevice_SetRenderState_AlphaRef'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062B10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062B10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062B10);
		  /* 82062B10h */ case    0:  		/* stw R11, <#[R3 + 10548]> */
		/* 82062B10h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002934) );
		/* 82062B10h case    0:*/		return 0x82062B14;
		  /* 82062B14h */ case    1:  		/* ld R11, <#[R3 + 16]> */
		/* 82062B14h case    1:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062B14h case    1:*/		return 0x82062B18;
		  /* 82062B18h */ case    2:  		/* ori R11, R11, 2048 */
		/* 82062B18h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x800);
		/* 82062B18h case    2:*/		return 0x82062B1C;
		  /* 82062B1Ch */ case    3:  		/* std R11, <#[R3 + 16]> */
		/* 82062B1Ch case    3:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062B1Ch case    3:*/		return 0x82062B20;
		  /* 82062B20h */ case    4:  		/* oris R11, R11, 2 */
		/* 82062B20h case    4:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82062B20h case    4:*/		return 0x82062B24;
		  /* 82062B24h */ case    5:  		/* std R11, <#[R3 + 16]> */
		/* 82062B24h case    5:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062B24h case    5:*/		return 0x82062B28;
		  /* 82062B28h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82062B28h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062B28h case    6:*/		return 0x82062B2C;
	}
	return 0x82062B2C;
} // Block from 82062B10h-82062B2Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 82062B2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062B2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062B2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062B2C);
		  /* 82062B2Ch */ case    0:  		/* nop */
		/* 82062B2Ch case    0:*/		cpu::op::nop();
		/* 82062B2Ch case    0:*/		return 0x82062B30;
	}
	return 0x82062B30;
} // Block from 82062B2Ch-82062B30h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062B30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062B30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062B30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062B30);
		  /* 82062B30h */ case    0:  		/* lwz R11, <#[R3 + 10548]> */
		/* 82062B30h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002934) );
		/* 82062B30h case    0:*/		return 0x82062B34;
		  /* 82062B34h */ case    1:  		/* rlwinm R3, R11, 21, 29, 31 */
		/* 82062B34h case    1:*/		cpu::op::rlwinm<0,21,29,31>(regs,&regs.R3,regs.R11);
		/* 82062B34h case    1:*/		return 0x82062B38;
		  /* 82062B38h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82062B38h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062B38h case    2:*/		return 0x82062B3C;
	}
	return 0x82062B3C;
} // Block from 82062B30h-82062B3Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82062B3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062B3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062B3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062B3C);
		  /* 82062B3Ch */ case    0:  		/* nop */
		/* 82062B3Ch case    0:*/		cpu::op::nop();
		/* 82062B3Ch case    0:*/		return 0x82062B40;
	}
	return 0x82062B40;
} // Block from 82062B3Ch-82062B40h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062B40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062B40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062B40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062B40);
		  /* 82062B40h */ case    0:  		/* lwz R11, <#[R3 + 10548]> */
		/* 82062B40h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002934) );
		/* 82062B40h case    0:*/		return 0x82062B44;
		  /* 82062B44h */ case    1:  		/* rlwimi R11, R4, 17, 12, 14 */
		/* 82062B44h case    1:*/		cpu::op::rlwimi<0,17,12,14>(regs,&regs.R11,regs.R4);
		/* 82062B44h case    1:*/		return 0x82062B48;
	}
	return 0x82062B48;
} // Block from 82062B40h-82062B48h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82062B48h
// Function 'D3DDevice_GetRenderState_AlphaRef'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062B48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062B48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062B48);
		  /* 82062B48h */ case    0:  		/* stw R11, <#[R3 + 10548]> */
		/* 82062B48h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002934) );
		/* 82062B48h case    0:*/		return 0x82062B4C;
		  /* 82062B4Ch */ case    1:  		/* ld R11, <#[R3 + 16]> */
		/* 82062B4Ch case    1:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062B4Ch case    1:*/		return 0x82062B50;
		  /* 82062B50h */ case    2:  		/* ori R11, R11, 2048 */
		/* 82062B50h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x800);
		/* 82062B50h case    2:*/		return 0x82062B54;
		  /* 82062B54h */ case    3:  		/* std R11, <#[R3 + 16]> */
		/* 82062B54h case    3:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062B54h case    3:*/		return 0x82062B58;
		  /* 82062B58h */ case    4:  		/* oris R11, R11, 2 */
		/* 82062B58h case    4:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82062B58h case    4:*/		return 0x82062B5C;
		  /* 82062B5Ch */ case    5:  		/* std R11, <#[R3 + 16]> */
		/* 82062B5Ch case    5:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062B5Ch case    5:*/		return 0x82062B60;
		  /* 82062B60h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82062B60h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062B60h case    6:*/		return 0x82062B64;
	}
	return 0x82062B64;
} // Block from 82062B48h-82062B64h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82062B64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062B64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062B64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062B64);
		  /* 82062B64h */ case    0:  		/* nop */
		/* 82062B64h case    0:*/		cpu::op::nop();
		/* 82062B64h case    0:*/		return 0x82062B68;
	}
	return 0x82062B68;
} // Block from 82062B64h-82062B68h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062B68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062B68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062B68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062B68);
		  /* 82062B68h */ case    0:  		/* lwz R11, <#[R3 + 10548]> */
		/* 82062B68h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002934) );
		/* 82062B68h case    0:*/		return 0x82062B6C;
		  /* 82062B6Ch */ case    1:  		/* rlwinm R3, R11, 15, 29, 31 */
		/* 82062B6Ch case    1:*/		cpu::op::rlwinm<0,15,29,31>(regs,&regs.R3,regs.R11);
		/* 82062B6Ch case    1:*/		return 0x82062B70;
	}
	return 0x82062B70;
} // Block from 82062B68h-82062B70h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82062B70h
// Function 'D3DDevice_SetRenderState_AlphaFunc'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062B70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062B70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062B70);
		  /* 82062B70h */ case    0:  		/* bclr 20, CR0_LT */
		/* 82062B70h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062B70h case    0:*/		return 0x82062B74;
	}
	return 0x82062B74;
} // Block from 82062B70h-82062B74h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062B74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062B74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062B74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062B74);
		  /* 82062B74h */ case    0:  		/* nop */
		/* 82062B74h case    0:*/		cpu::op::nop();
		/* 82062B74h case    0:*/		return 0x82062B78;
	}
	return 0x82062B78;
} // Block from 82062B74h-82062B78h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062B78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062B78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062B78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062B78);
		  /* 82062B78h */ case    0:  		/* lwz R11, <#[R3 + 10548]> */
		/* 82062B78h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002934) );
		/* 82062B78h case    0:*/		return 0x82062B7C;
		  /* 82062B7Ch */ case    1:  		/* rlwimi R11, R4, 14, 15, 17 */
		/* 82062B7Ch case    1:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R11,regs.R4);
		/* 82062B7Ch case    1:*/		return 0x82062B80;
		  /* 82062B80h */ case    2:  		/* stw R11, <#[R3 + 10548]> */
		/* 82062B80h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002934) );
		/* 82062B80h case    2:*/		return 0x82062B84;
		  /* 82062B84h */ case    3:  		/* ld R11, <#[R3 + 16]> */
		/* 82062B84h case    3:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062B84h case    3:*/		return 0x82062B88;
		  /* 82062B88h */ case    4:  		/* ori R11, R11, 2048 */
		/* 82062B88h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x800);
		/* 82062B88h case    4:*/		return 0x82062B8C;
		  /* 82062B8Ch */ case    5:  		/* std R11, <#[R3 + 16]> */
		/* 82062B8Ch case    5:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062B8Ch case    5:*/		return 0x82062B90;
	}
	return 0x82062B90;
} // Block from 82062B78h-82062B90h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82062B90h
// Function 'D3DDevice_GetRenderState_AlphaFunc'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062B90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062B90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062B90);
		  /* 82062B90h */ case    0:  		/* bclr 20, CR0_LT */
		/* 82062B90h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062B90h case    0:*/		return 0x82062B94;
	}
	return 0x82062B94;
} // Block from 82062B90h-82062B94h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062B94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062B94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062B94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062B94);
		  /* 82062B94h */ case    0:  		/* nop */
		/* 82062B94h case    0:*/		cpu::op::nop();
		/* 82062B94h case    0:*/		return 0x82062B98;
	}
	return 0x82062B98;
} // Block from 82062B94h-82062B98h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062B98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062B98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062B98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062B98);
		  /* 82062B98h */ case    0:  		/* lwz R11, <#[R3 + 10548]> */
		/* 82062B98h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002934) );
		/* 82062B98h case    0:*/		return 0x82062B9C;
		  /* 82062B9Ch */ case    1:  		/* rlwinm R3, R11, 18, 29, 31 */
		/* 82062B9Ch case    1:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R3,regs.R11);
		/* 82062B9Ch case    1:*/		return 0x82062BA0;
	}
	return 0x82062BA0;
} // Block from 82062B98h-82062BA0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82062BA0h
// Function 'D3DDevice_SetRenderState_BlendFactor'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062BA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062BA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062BA0);
		  /* 82062BA0h */ case    0:  		/* bclr 20, CR0_LT */
		/* 82062BA0h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062BA0h case    0:*/		return 0x82062BA4;
	}
	return 0x82062BA4;
} // Block from 82062BA0h-82062BA4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062BA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062BA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062BA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062BA4);
		  /* 82062BA4h */ case    0:  		/* nop */
		/* 82062BA4h case    0:*/		cpu::op::nop();
		/* 82062BA4h case    0:*/		return 0x82062BA8;
	}
	return 0x82062BA8;
} // Block from 82062BA4h-82062BA8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062BA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062BA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062BA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062BA8);
		  /* 82062BA8h */ case    0:  		/* lwz R11, <#[R3 + 10548]> */
		/* 82062BA8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002934) );
		/* 82062BA8h case    0:*/		return 0x82062BAC;
		  /* 82062BACh */ case    1:  		/* rlwimi R11, R4, 20, 9, 11 */
		/* 82062BACh case    1:*/		cpu::op::rlwimi<0,20,9,11>(regs,&regs.R11,regs.R4);
		/* 82062BACh case    1:*/		return 0x82062BB0;
		  /* 82062BB0h */ case    2:  		/* stw R11, <#[R3 + 10548]> */
		/* 82062BB0h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002934) );
		/* 82062BB0h case    2:*/		return 0x82062BB4;
		  /* 82062BB4h */ case    3:  		/* ld R11, <#[R3 + 16]> */
		/* 82062BB4h case    3:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062BB4h case    3:*/		return 0x82062BB8;
		  /* 82062BB8h */ case    4:  		/* ori R11, R11, 2048 */
		/* 82062BB8h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x800);
		/* 82062BB8h case    4:*/		return 0x82062BBC;
		  /* 82062BBCh */ case    5:  		/* std R11, <#[R3 + 16]> */
		/* 82062BBCh case    5:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062BBCh case    5:*/		return 0x82062BC0;
		  /* 82062BC0h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82062BC0h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062BC0h case    6:*/		return 0x82062BC4;
	}
	return 0x82062BC4;
} // Block from 82062BA8h-82062BC4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82062BC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062BC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062BC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062BC4);
		  /* 82062BC4h */ case    0:  		/* nop */
		/* 82062BC4h case    0:*/		cpu::op::nop();
		/* 82062BC4h case    0:*/		return 0x82062BC8;
	}
	return 0x82062BC8;
} // Block from 82062BC4h-82062BC8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062BC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062BC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062BC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062BC8);
		  /* 82062BC8h */ case    0:  		/* lwz R11, <#[R3 + 10548]> */
		/* 82062BC8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002934) );
		/* 82062BC8h case    0:*/		return 0x82062BCC;
		  /* 82062BCCh */ case    1:  		/* rlwinm R3, R11, 12, 29, 31 */
		/* 82062BCCh case    1:*/		cpu::op::rlwinm<0,12,29,31>(regs,&regs.R3,regs.R11);
		/* 82062BCCh case    1:*/		return 0x82062BD0;
		  /* 82062BD0h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82062BD0h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062BD0h case    2:*/		return 0x82062BD4;
	}
	return 0x82062BD4;
} // Block from 82062BC8h-82062BD4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82062BD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062BD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062BD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062BD4);
		  /* 82062BD4h */ case    0:  		/* nop */
		/* 82062BD4h case    0:*/		cpu::op::nop();
		/* 82062BD4h case    0:*/		return 0x82062BD8;
	}
	return 0x82062BD8;
} // Block from 82062BD4h-82062BD8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062BD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062BD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062BD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062BD8);
		  /* 82062BD8h */ case    0:  		/* lwz R11, <#[R3 + 10548]> */
		/* 82062BD8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002934) );
		/* 82062BD8h case    0:*/		return 0x82062BDC;
		  /* 82062BDCh */ case    1:  		/* rlwimi R11, R4, 23, 6, 8 */
		/* 82062BDCh case    1:*/		cpu::op::rlwimi<0,23,6,8>(regs,&regs.R11,regs.R4);
		/* 82062BDCh case    1:*/		return 0x82062BE0;
		  /* 82062BE0h */ case    2:  		/* stw R11, <#[R3 + 10548]> */
		/* 82062BE0h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002934) );
		/* 82062BE0h case    2:*/		return 0x82062BE4;
		  /* 82062BE4h */ case    3:  		/* ld R11, <#[R3 + 16]> */
		/* 82062BE4h case    3:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062BE4h case    3:*/		return 0x82062BE8;
		  /* 82062BE8h */ case    4:  		/* ori R11, R11, 2048 */
		/* 82062BE8h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x800);
		/* 82062BE8h case    4:*/		return 0x82062BEC;
		  /* 82062BECh */ case    5:  		/* std R11, <#[R3 + 16]> */
		/* 82062BECh case    5:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062BECh case    5:*/		return 0x82062BF0;
		  /* 82062BF0h */ case    6:  		/* oris R11, R11, 2 */
		/* 82062BF0h case    6:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82062BF0h case    6:*/		return 0x82062BF4;
		  /* 82062BF4h */ case    7:  		/* std R11, <#[R3 + 16]> */
		/* 82062BF4h case    7:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062BF4h case    7:*/		return 0x82062BF8;
		  /* 82062BF8h */ case    8:  		/* bclr 20, CR0_LT */
		/* 82062BF8h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062BF8h case    8:*/		return 0x82062BFC;
	}
	return 0x82062BFC;
} // Block from 82062BD8h-82062BFCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 82062BFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062BFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062BFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062BFC);
		  /* 82062BFCh */ case    0:  		/* nop */
		/* 82062BFCh case    0:*/		cpu::op::nop();
		/* 82062BFCh case    0:*/		return 0x82062C00;
	}
	return 0x82062C00;
} // Block from 82062BFCh-82062C00h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062C00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062C00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062C00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062C00);
		  /* 82062C00h */ case    0:  		/* lwz R11, <#[R3 + 10548]> */
		/* 82062C00h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002934) );
		/* 82062C00h case    0:*/		return 0x82062C04;
		  /* 82062C04h */ case    1:  		/* rlwinm R3, R11, 9, 29, 31 */
		/* 82062C04h case    1:*/		cpu::op::rlwinm<0,9,29,31>(regs,&regs.R3,regs.R11);
		/* 82062C04h case    1:*/		return 0x82062C08;
		  /* 82062C08h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82062C08h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062C08h case    2:*/		return 0x82062C0C;
	}
	return 0x82062C0C;
} // Block from 82062C00h-82062C0Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82062C0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062C0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062C0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062C0C);
		  /* 82062C0Ch */ case    0:  		/* nop */
		/* 82062C0Ch case    0:*/		cpu::op::nop();
		/* 82062C0Ch case    0:*/		return 0x82062C10;
	}
	return 0x82062C10;
} // Block from 82062C0Ch-82062C10h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062C10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062C10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062C10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062C10);
		  /* 82062C10h */ case    0:  		/* lwz R11, <#[R3 + 10548]> */
		/* 82062C10h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002934) );
		/* 82062C10h case    0:*/		return 0x82062C14;
		  /* 82062C14h */ case    1:  		/* rlwimi R11, R4, 29, 0, 2 */
		/* 82062C14h case    1:*/		cpu::op::rlwimi<0,29,0,2>(regs,&regs.R11,regs.R4);
		/* 82062C14h case    1:*/		return 0x82062C18;
		  /* 82062C18h */ case    2:  		/* stw R11, <#[R3 + 10548]> */
		/* 82062C18h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002934) );
		/* 82062C18h case    2:*/		return 0x82062C1C;
		  /* 82062C1Ch */ case    3:  		/* ld R11, <#[R3 + 16]> */
		/* 82062C1Ch case    3:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062C1Ch case    3:*/		return 0x82062C20;
		  /* 82062C20h */ case    4:  		/* ori R11, R11, 2048 */
		/* 82062C20h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x800);
		/* 82062C20h case    4:*/		return 0x82062C24;
		  /* 82062C24h */ case    5:  		/* std R11, <#[R3 + 16]> */
		/* 82062C24h case    5:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062C24h case    5:*/		return 0x82062C28;
		  /* 82062C28h */ case    6:  		/* oris R11, R11, 2 */
		/* 82062C28h case    6:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82062C28h case    6:*/		return 0x82062C2C;
		  /* 82062C2Ch */ case    7:  		/* std R11, <#[R3 + 16]> */
		/* 82062C2Ch case    7:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062C2Ch case    7:*/		return 0x82062C30;
		  /* 82062C30h */ case    8:  		/* bclr 20, CR0_LT */
		/* 82062C30h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062C30h case    8:*/		return 0x82062C34;
	}
	return 0x82062C34;
} // Block from 82062C10h-82062C34h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82062C34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062C34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062C34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062C34);
		  /* 82062C34h */ case    0:  		/* nop */
		/* 82062C34h case    0:*/		cpu::op::nop();
		/* 82062C34h case    0:*/		return 0x82062C38;
	}
	return 0x82062C38;
} // Block from 82062C34h-82062C38h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062C38h
// Function 'D3DDevice_GetRenderState_BlendFactor'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062C38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062C38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062C38);
		  /* 82062C38h */ case    0:  		/* lwz R11, <#[R3 + 10548]> */
		/* 82062C38h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002934) );
		/* 82062C38h case    0:*/		return 0x82062C3C;
		  /* 82062C3Ch */ case    1:  		/* rlwinm R3, R11, 3, 29, 31 */
		/* 82062C3Ch case    1:*/		cpu::op::rlwinm<0,3,29,31>(regs,&regs.R3,regs.R11);
		/* 82062C3Ch case    1:*/		return 0x82062C40;
		  /* 82062C40h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82062C40h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062C40h case    2:*/		return 0x82062C44;
	}
	return 0x82062C44;
} // Block from 82062C38h-82062C44h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82062C44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062C44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062C44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062C44);
		  /* 82062C44h */ case    0:  		/* nop */
		/* 82062C44h case    0:*/		cpu::op::nop();
		/* 82062C44h case    0:*/		return 0x82062C48;
	}
	return 0x82062C48;
} // Block from 82062C44h-82062C48h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062C48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062C48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062C48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062C48);
		  /* 82062C48h */ case    0:  		/* lwz R11, <#[R3 + 10548]> */
		/* 82062C48h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002934) );
		/* 82062C48h case    0:*/		return 0x82062C4C;
		  /* 82062C4Ch */ case    1:  		/* rlwimi R11, R4, 26, 3, 5 */
		/* 82062C4Ch case    1:*/		cpu::op::rlwimi<0,26,3,5>(regs,&regs.R11,regs.R4);
		/* 82062C4Ch case    1:*/		return 0x82062C50;
		  /* 82062C50h */ case    2:  		/* stw R11, <#[R3 + 10548]> */
		/* 82062C50h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002934) );
		/* 82062C50h case    2:*/		return 0x82062C54;
		  /* 82062C54h */ case    3:  		/* ld R11, <#[R3 + 16]> */
		/* 82062C54h case    3:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062C54h case    3:*/		return 0x82062C58;
		  /* 82062C58h */ case    4:  		/* ori R11, R11, 2048 */
		/* 82062C58h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x800);
		/* 82062C58h case    4:*/		return 0x82062C5C;
		  /* 82062C5Ch */ case    5:  		/* std R11, <#[R3 + 16]> */
		/* 82062C5Ch case    5:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062C5Ch case    5:*/		return 0x82062C60;
		  /* 82062C60h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82062C60h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062C60h case    6:*/		return 0x82062C64;
	}
	return 0x82062C64;
} // Block from 82062C48h-82062C64h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82062C64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062C64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062C64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062C64);
		  /* 82062C64h */ case    0:  		/* nop */
		/* 82062C64h case    0:*/		cpu::op::nop();
		/* 82062C64h case    0:*/		return 0x82062C68;
	}
	return 0x82062C68;
} // Block from 82062C64h-82062C68h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062C68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062C68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062C68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062C68);
		  /* 82062C68h */ case    0:  		/* lwz R11, <#[R3 + 10548]> */
		/* 82062C68h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002934) );
		/* 82062C68h case    0:*/		return 0x82062C6C;
		  /* 82062C6Ch */ case    1:  		/* rlwinm R3, R11, 6, 29, 31 */
		/* 82062C6Ch case    1:*/		cpu::op::rlwinm<0,6,29,31>(regs,&regs.R3,regs.R11);
		/* 82062C6Ch case    1:*/		return 0x82062C70;
		  /* 82062C70h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82062C70h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062C70h case    2:*/		return 0x82062C74;
	}
	return 0x82062C74;
} // Block from 82062C68h-82062C74h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82062C74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062C74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062C74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062C74);
		  /* 82062C74h */ case    0:  		/* nop */
		/* 82062C74h case    0:*/		cpu::op::nop();
		/* 82062C74h case    0:*/		return 0x82062C78;
	}
	return 0x82062C78;
} // Block from 82062C74h-82062C78h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062C78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062C78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062C78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062C78);
		  /* 82062C78h */ case    0:  		/* stb R4, <#[R3 + 10499]> */
		/* 82062C78h case    0:*/		cpu::mem::store8( regs, regs.R4, (uint32)(regs.R3 + 0x00002903) );
		/* 82062C78h case    0:*/		return 0x82062C7C;
		  /* 82062C7Ch */ case    1:  		/* ld R11, <#[R3 + 16]> */
		/* 82062C7Ch case    1:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062C7Ch case    1:*/		return 0x82062C80;
		  /* 82062C80h */ case    2:  		/* oris R11, R11, 4096 */
		/* 82062C80h case    2:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x1000);
		/* 82062C80h case    2:*/		return 0x82062C84;
		  /* 82062C84h */ case    3:  		/* std R11, <#[R3 + 16]> */
		/* 82062C84h case    3:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062C84h case    3:*/		return 0x82062C88;
		  /* 82062C88h */ case    4:  		/* bclr 20, CR0_LT */
		/* 82062C88h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062C88h case    4:*/		return 0x82062C8C;
	}
	return 0x82062C8C;
} // Block from 82062C78h-82062C8Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82062C8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062C8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062C8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062C8C);
		  /* 82062C8Ch */ case    0:  		/* nop */
		/* 82062C8Ch case    0:*/		cpu::op::nop();
		/* 82062C8Ch case    0:*/		return 0x82062C90;
	}
	return 0x82062C90;
} // Block from 82062C8Ch-82062C90h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062C90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062C90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062C90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062C90);
		  /* 82062C90h */ case    0:  		/* lbz R3, <#[R3 + 10499]> */
		/* 82062C90h case    0:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R3 + 0x00002903) );
		/* 82062C90h case    0:*/		return 0x82062C94;
		  /* 82062C94h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82062C94h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062C94h case    1:*/		return 0x82062C98;
	}
	return 0x82062C98;
} // Block from 82062C90h-82062C98h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82062C98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062C98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062C98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062C98);
		  /* 82062C98h */ case    0:  		/* stb R4, <#[R3 + 10498]> */
		/* 82062C98h case    0:*/		cpu::mem::store8( regs, regs.R4, (uint32)(regs.R3 + 0x00002902) );
		/* 82062C98h case    0:*/		return 0x82062C9C;
		  /* 82062C9Ch */ case    1:  		/* ld R11, <#[R3 + 16]> */
		/* 82062C9Ch case    1:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062C9Ch case    1:*/		return 0x82062CA0;
		  /* 82062CA0h */ case    2:  		/* oris R11, R11, 4096 */
		/* 82062CA0h case    2:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x1000);
		/* 82062CA0h case    2:*/		return 0x82062CA4;
		  /* 82062CA4h */ case    3:  		/* std R11, <#[R3 + 16]> */
		/* 82062CA4h case    3:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062CA4h case    3:*/		return 0x82062CA8;
	}
	return 0x82062CA8;
} // Block from 82062C98h-82062CA8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82062CA8h
// Function 'D3DDevice_SetRenderState_LastPixel'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062CA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062CA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062CA8);
		  /* 82062CA8h */ case    0:  		/* bclr 20, CR0_LT */
		/* 82062CA8h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062CA8h case    0:*/		return 0x82062CAC;
	}
	return 0x82062CAC;
} // Block from 82062CA8h-82062CACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062CACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062CAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062CAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062CAC);
		  /* 82062CACh */ case    0:  		/* nop */
		/* 82062CACh case    0:*/		cpu::op::nop();
		/* 82062CACh case    0:*/		return 0x82062CB0;
	}
	return 0x82062CB0;
} // Block from 82062CACh-82062CB0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062CB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062CB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062CB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062CB0);
		  /* 82062CB0h */ case    0:  		/* lbz R3, <#[R3 + 10498]> */
		/* 82062CB0h case    0:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R3 + 0x00002902) );
		/* 82062CB0h case    0:*/		return 0x82062CB4;
		  /* 82062CB4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82062CB4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062CB4h case    1:*/		return 0x82062CB8;
	}
	return 0x82062CB8;
} // Block from 82062CB0h-82062CB8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82062CB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062CB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062CB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062CB8);
		  /* 82062CB8h */ case    0:  		/* stb R4, <#[R3 + 10497]> */
		/* 82062CB8h case    0:*/		cpu::mem::store8( regs, regs.R4, (uint32)(regs.R3 + 0x00002901) );
		/* 82062CB8h case    0:*/		return 0x82062CBC;
		  /* 82062CBCh */ case    1:  		/* ld R11, <#[R3 + 16]> */
		/* 82062CBCh case    1:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062CBCh case    1:*/		return 0x82062CC0;
		  /* 82062CC0h */ case    2:  		/* oris R11, R11, 4096 */
		/* 82062CC0h case    2:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x1000);
		/* 82062CC0h case    2:*/		return 0x82062CC4;
		  /* 82062CC4h */ case    3:  		/* std R11, <#[R3 + 16]> */
		/* 82062CC4h case    3:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062CC4h case    3:*/		return 0x82062CC8;
		  /* 82062CC8h */ case    4:  		/* bclr 20, CR0_LT */
		/* 82062CC8h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062CC8h case    4:*/		return 0x82062CCC;
	}
	return 0x82062CCC;
} // Block from 82062CB8h-82062CCCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 82062CCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062CCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062CCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062CCC);
		  /* 82062CCCh */ case    0:  		/* nop */
		/* 82062CCCh case    0:*/		cpu::op::nop();
		/* 82062CCCh case    0:*/		return 0x82062CD0;
	}
	return 0x82062CD0;
} // Block from 82062CCCh-82062CD0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062CD0h
// Function 'D3DDevice_GetRenderState_LastPixel'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062CD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062CD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062CD0);
		  /* 82062CD0h */ case    0:  		/* lbz R3, <#[R3 + 10497]> */
		/* 82062CD0h case    0:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R3 + 0x00002901) );
		/* 82062CD0h case    0:*/		return 0x82062CD4;
		  /* 82062CD4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82062CD4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062CD4h case    1:*/		return 0x82062CD8;
	}
	return 0x82062CD8;
} // Block from 82062CD0h-82062CD8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82062CD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062CD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062CD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062CD8);
		  /* 82062CD8h */ case    0:  		/* stb R4, <#[R3 + 10495]> */
		/* 82062CD8h case    0:*/		cpu::mem::store8( regs, regs.R4, (uint32)(regs.R3 + 0x000028FF) );
		/* 82062CD8h case    0:*/		return 0x82062CDC;
		  /* 82062CDCh */ case    1:  		/* ld R11, <#[R3 + 16]> */
		/* 82062CDCh case    1:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062CDCh case    1:*/		return 0x82062CE0;
	}
	return 0x82062CE0;
} // Block from 82062CD8h-82062CE0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82062CE0h
// Function 'D3DDevice_SetRenderState_LineWidth'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062CE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062CE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062CE0);
		  /* 82062CE0h */ case    0:  		/* oris R11, R11, 8192 */
		/* 82062CE0h case    0:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x2000);
		/* 82062CE0h case    0:*/		return 0x82062CE4;
		  /* 82062CE4h */ case    1:  		/* std R11, <#[R3 + 16]> */
		/* 82062CE4h case    1:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062CE4h case    1:*/		return 0x82062CE8;
		  /* 82062CE8h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82062CE8h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062CE8h case    2:*/		return 0x82062CEC;
	}
	return 0x82062CEC;
} // Block from 82062CE0h-82062CECh (3 instructions)

//////////////////////////////////////////////////////
// Block at 82062CECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062CEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062CEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062CEC);
		  /* 82062CECh */ case    0:  		/* nop */
		/* 82062CECh case    0:*/		cpu::op::nop();
		/* 82062CECh case    0:*/		return 0x82062CF0;
	}
	return 0x82062CF0;
} // Block from 82062CECh-82062CF0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062CF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062CF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062CF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062CF0);
		  /* 82062CF0h */ case    0:  		/* lbz R3, <#[R3 + 10495]> */
		/* 82062CF0h case    0:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R3 + 0x000028FF) );
		/* 82062CF0h case    0:*/		return 0x82062CF4;
		  /* 82062CF4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82062CF4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062CF4h case    1:*/		return 0x82062CF8;
	}
	return 0x82062CF8;
} // Block from 82062CF0h-82062CF8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82062CF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062CF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062CF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062CF8);
		  /* 82062CF8h */ case    0:  		/* stb R4, <#[R3 + 10494]> */
		/* 82062CF8h case    0:*/		cpu::mem::store8( regs, regs.R4, (uint32)(regs.R3 + 0x000028FE) );
		/* 82062CF8h case    0:*/		return 0x82062CFC;
		  /* 82062CFCh */ case    1:  		/* ld R11, <#[R3 + 16]> */
		/* 82062CFCh case    1:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062CFCh case    1:*/		return 0x82062D00;
		  /* 82062D00h */ case    2:  		/* oris R11, R11, 8192 */
		/* 82062D00h case    2:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x2000);
		/* 82062D00h case    2:*/		return 0x82062D04;
		  /* 82062D04h */ case    3:  		/* std R11, <#[R3 + 16]> */
		/* 82062D04h case    3:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062D04h case    3:*/		return 0x82062D08;
		  /* 82062D08h */ case    4:  		/* bclr 20, CR0_LT */
		/* 82062D08h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062D08h case    4:*/		return 0x82062D0C;
	}
	return 0x82062D0C;
} // Block from 82062CF8h-82062D0Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82062D0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062D0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062D0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062D0C);
		  /* 82062D0Ch */ case    0:  		/* nop */
		/* 82062D0Ch case    0:*/		cpu::op::nop();
		/* 82062D0Ch case    0:*/		return 0x82062D10;
	}
	return 0x82062D10;
} // Block from 82062D0Ch-82062D10h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062D10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062D10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062D10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062D10);
		  /* 82062D10h */ case    0:  		/* lbz R3, <#[R3 + 10494]> */
		/* 82062D10h case    0:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R3 + 0x000028FE) );
		/* 82062D10h case    0:*/		return 0x82062D14;
		  /* 82062D14h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82062D14h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062D14h case    1:*/		return 0x82062D18;
	}
	return 0x82062D18;
} // Block from 82062D10h-82062D18h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82062D18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062D18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062D18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062D18);
		  /* 82062D18h */ case    0:  		/* stb R4, <#[R3 + 10493]> */
		/* 82062D18h case    0:*/		cpu::mem::store8( regs, regs.R4, (uint32)(regs.R3 + 0x000028FD) );
		/* 82062D18h case    0:*/		return 0x82062D1C;
		  /* 82062D1Ch */ case    1:  		/* ld R11, <#[R3 + 16]> */
		/* 82062D1Ch case    1:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062D1Ch case    1:*/		return 0x82062D20;
	}
	return 0x82062D20;
} // Block from 82062D18h-82062D20h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82062D20h
// Function 'D3DDevice_GetRenderState_LineWidth'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062D20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062D20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062D20);
		  /* 82062D20h */ case    0:  		/* oris R11, R11, 8192 */
		/* 82062D20h case    0:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x2000);
		/* 82062D20h case    0:*/		return 0x82062D24;
		  /* 82062D24h */ case    1:  		/* std R11, <#[R3 + 16]> */
		/* 82062D24h case    1:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062D24h case    1:*/		return 0x82062D28;
		  /* 82062D28h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82062D28h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062D28h case    2:*/		return 0x82062D2C;
	}
	return 0x82062D2C;
} // Block from 82062D20h-82062D2Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82062D2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062D2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062D2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062D2C);
		  /* 82062D2Ch */ case    0:  		/* nop */
		/* 82062D2Ch case    0:*/		cpu::op::nop();
		/* 82062D2Ch case    0:*/		return 0x82062D30;
	}
	return 0x82062D30;
} // Block from 82062D2Ch-82062D30h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062D30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062D30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062D30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062D30);
		  /* 82062D30h */ case    0:  		/* lbz R3, <#[R3 + 10493]> */
		/* 82062D30h case    0:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R3 + 0x000028FD) );
		/* 82062D30h case    0:*/		return 0x82062D34;
		  /* 82062D34h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82062D34h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062D34h case    1:*/		return 0x82062D38;
	}
	return 0x82062D38;
} // Block from 82062D30h-82062D38h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82062D38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062D38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062D38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062D38);
		  /* 82062D38h */ case    0:  		/* lwz R11, <#[R3 + 10564]> */
		/* 82062D38h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002944) );
		/* 82062D38h case    0:*/		return 0x82062D3C;
		  /* 82062D3Ch */ case    1:  		/* subfic R10, R4, 0 */
		/* 82062D3Ch case    1:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R4,0x0);
		/* 82062D3Ch case    1:*/		return 0x82062D40;
		  /* 82062D40h */ case    2:  		/* li R9, 4096 */
		/* 82062D40h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x1000);
		/* 82062D40h case    2:*/		return 0x82062D44;
		  /* 82062D44h */ case    3:  		/* subfe R10, R10, R10 */
		/* 82062D44h case    3:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 82062D44h case    3:*/		return 0x82062D48;
		  /* 82062D48h */ case    4:  		/* rlwinm R11, R11, 0, 0, 25 */
		/* 82062D48h case    4:*/		cpu::op::rlwinm<0,0,0,25>(regs,&regs.R11,regs.R11);
		/* 82062D48h case    4:*/		return 0x82062D4C;
		  /* 82062D4Ch */ case    5:  		/* and R10, R10, R9 */
		/* 82062D4Ch case    5:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82062D4Ch case    5:*/		return 0x82062D50;
		  /* 82062D50h */ case    6:  		/* or R11, R11, R4 */
		/* 82062D50h case    6:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R4);
		/* 82062D50h case    6:*/		return 0x82062D54;
		  /* 82062D54h */ case    7:  		/* li R12, 1 */
		/* 82062D54h case    7:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 82062D54h case    7:*/		return 0x82062D58;
	}
	return 0x82062D58;
} // Block from 82062D38h-82062D58h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82062D58h
// Function 'D3DDevice_SetRenderState_Buffer2Frames'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062D58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062D58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062D58);
		  /* 82062D58h */ case    0:  		/* stw R10, <#[R3 + 10420]> */
		/* 82062D58h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x000028B4) );
		/* 82062D58h case    0:*/		return 0x82062D5C;
		  /* 82062D5Ch */ case    1:  		/* stw R11, <#[R3 + 10564]> */
		/* 82062D5Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002944) );
		/* 82062D5Ch case    1:*/		return 0x82062D60;
		  /* 82062D60h */ case    2:  		/* ld R10, <#[R3 + 16]> */
		/* 82062D60h case    2:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 82062D60h case    2:*/		return 0x82062D64;
		  /* 82062D64h */ case    3:  		/* ori R10, R10, 128 */
		/* 82062D64h case    3:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x80);
		/* 82062D64h case    3:*/		return 0x82062D68;
		  /* 82062D68h */ case    4:  		/* rldicr R12, R12, 44, 63 */
		/* 82062D68h case    4:*/		cpu::op::rldicr<0,44,63>(regs,&regs.R12,regs.R12);
		/* 82062D68h case    4:*/		return 0x82062D6C;
		  /* 82062D6Ch */ case    5:  		/* std R10, <#[R3 + 16]> */
		/* 82062D6Ch case    5:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 82062D6Ch case    5:*/		return 0x82062D70;
		  /* 82062D70h */ case    6:  		/* or R11, R10, R12 */
		/* 82062D70h case    6:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R12);
		/* 82062D70h case    6:*/		return 0x82062D74;
		  /* 82062D74h */ case    7:  		/* std R11, <#[R3 + 16]> */
		/* 82062D74h case    7:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062D74h case    7:*/		return 0x82062D78;
	}
	return 0x82062D78;
} // Block from 82062D58h-82062D78h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82062D78h
// Function 'D3DDevice_GetRenderState_Buffer2Frames'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062D78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062D78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062D78);
		  /* 82062D78h */ case    0:  		/* bclr 20, CR0_LT */
		/* 82062D78h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062D78h case    0:*/		return 0x82062D7C;
	}
	return 0x82062D7C;
} // Block from 82062D78h-82062D7Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062D7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062D7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062D7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062D7C);
		  /* 82062D7Ch */ case    0:  		/* nop */
		/* 82062D7Ch case    0:*/		cpu::op::nop();
		/* 82062D7Ch case    0:*/		return 0x82062D80;
	}
	return 0x82062D80;
} // Block from 82062D7Ch-82062D80h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062D80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062D80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062D80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062D80);
		  /* 82062D80h */ case    0:  		/* lwz R11, <#[R3 + 10564]> */
		/* 82062D80h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002944) );
		/* 82062D80h case    0:*/		return 0x82062D84;
		  /* 82062D84h */ case    1:  		/* rlwinm R3, R11, 0, 26, 31 */
		/* 82062D84h case    1:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R3,regs.R11);
		/* 82062D84h case    1:*/		return 0x82062D88;
	}
	return 0x82062D88;
} // Block from 82062D80h-82062D88h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82062D88h
// Function 'D3DDevice_SetRenderState_ZEnable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062D88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062D88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062D88);
		  /* 82062D88h */ case    0:  		/* bclr 20, CR0_LT */
		/* 82062D88h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062D88h case    0:*/		return 0x82062D8C;
	}
	return 0x82062D8C;
} // Block from 82062D88h-82062D8Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062D8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062D8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062D8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062D8C);
		  /* 82062D8Ch */ case    0:  		/* nop */
		/* 82062D8Ch case    0:*/		cpu::op::nop();
		/* 82062D8Ch case    0:*/		return 0x82062D90;
	}
	return 0x82062D90;
} // Block from 82062D8Ch-82062D90h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062D90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062D90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062D90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062D90);
		  /* 82062D90h */ case    0:  		/* lwz R3, <#[R3 + 12288]> */
		/* 82062D90h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00003000) );
		/* 82062D90h case    0:*/		return 0x82062D94;
		  /* 82062D94h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82062D94h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062D94h case    1:*/		return 0x82062D98;
	}
	return 0x82062D98;
} // Block from 82062D90h-82062D98h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82062D98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062D98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062D98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062D98);
		  /* 82062D98h */ case    0:  		/* lis R11, -32256 */
		/* 82062D98h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82062D98h case    0:*/		return 0x82062D9C;
		  /* 82062D9Ch */ case    1:  		/* stw R4, <#[R1 + 28]> */
		/* 82062D9Ch case    1:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000001C) );
		/* 82062D9Ch case    1:*/		return 0x82062DA0;
		  /* 82062DA0h */ case    2:  		/* lfs FR13, <#[R1 + 28]> */
		/* 82062DA0h case    2:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R1 + 0x0000001C) );
		/* 82062DA0h case    2:*/		return 0x82062DA4;
		  /* 82062DA4h */ case    3:  		/* lis R10, -32256 */
		/* 82062DA4h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82062DA4h case    3:*/		return 0x82062DA8;
		  /* 82062DA8h */ case    4:  		/* lfs FR0, <#[R11 + 2976]> */
		/* 82062DA8h case    4:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000BA0) );
		/* 82062DA8h case    4:*/		return 0x82062DAC;
		  /* 82062DACh */ case    5:  		/* fmuls FR13, FR13, FR0 */
		/* 82062DACh case    5:*/		cpu::op::fmuls<0>(regs,&regs.FR13,regs.FR13,regs.FR0);
		/* 82062DACh case    5:*/		return 0x82062DB0;
		  /* 82062DB0h */ case    6:  		/* lfs FR0, <#[R10 + 1816]> */
		/* 82062DB0h case    6:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000718) );
		/* 82062DB0h case    6:*/		return 0x82062DB4;
		  /* 82062DB4h */ case    7:  		/* fcmpu CR6, FR13, FR0 */
		/* 82062DB4h case    7:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 82062DB4h case    7:*/		return 0x82062DB8;
		  /* 82062DB8h */ case    8:  		/* bc 4, CR6_EQ, 20 */
		/* 82062DB8h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82062DCC;  }
		/* 82062DB8h case    8:*/		return 0x82062DBC;
		  /* 82062DBCh */ case    9:  		/* lfs FR12, <#[R3 + 10836]> */
		/* 82062DBCh case    9:*/		cpu::mem::load32f( regs, &regs.FR12, (uint32)(regs.R3 + 0x00002A54) );
		/* 82062DBCh case    9:*/		return 0x82062DC0;
	}
	return 0x82062DC0;
} // Block from 82062D98h-82062DC0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82062DC0h
// Function 'D3DDevice_GetRenderState_ZEnable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062DC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062DC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062DC0);
		  /* 82062DC0h */ case    0:  		/* li R10, 0 */
		/* 82062DC0h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82062DC0h case    0:*/		return 0x82062DC4;
		  /* 82062DC4h */ case    1:  		/* fcmpu CR6, FR12, FR0 */
		/* 82062DC4h case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR12,regs.FR0);
		/* 82062DC4h case    1:*/		return 0x82062DC8;
	}
	return 0x82062DC8;
} // Block from 82062DC0h-82062DC8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82062DC8h
// Function 'D3DDevice_SetRenderState_ZWriteEnable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062DC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062DC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062DC8);
		  /* 82062DC8h */ case    0:  		/* bc 12, CR6_EQ, 8 */
		/* 82062DC8h case    0:*/		if ( regs.CR[6].eq ) { return 0x82062DD0;  }
		/* 82062DC8h case    0:*/		return 0x82062DCC;
	}
	return 0x82062DCC;
} // Block from 82062DC8h-82062DCCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062DCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062DCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062DCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062DCC);
		  /* 82062DCCh */ case    0:  		/* li R10, 1 */
		/* 82062DCCh case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82062DCCh case    0:*/		return 0x82062DD0;
	}
	return 0x82062DD0;
} // Block from 82062DCCh-82062DD0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062DD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062DD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062DD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062DD0);
		  /* 82062DD0h */ case    0:  		/* lwz R11, <#[R3 + 10568]> */
		/* 82062DD0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002948) );
		/* 82062DD0h case    0:*/		return 0x82062DD4;
		  /* 82062DD4h */ case    1:  		/* fcmpu CR6, FR13, FR0 */
		/* 82062DD4h case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 82062DD4h case    1:*/		return 0x82062DD8;
		  /* 82062DD8h */ case    2:  		/* rlwimi R11, R10, 11, 20, 20 */
		/* 82062DD8h case    2:*/		cpu::op::rlwimi<0,11,20,20>(regs,&regs.R11,regs.R10);
		/* 82062DD8h case    2:*/		return 0x82062DDC;
		  /* 82062DDCh */ case    3:  		/* stw R11, <#[R3 + 10568]> */
		/* 82062DDCh case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002948) );
		/* 82062DDCh case    3:*/		return 0x82062DE0;
		  /* 82062DE0h */ case    4:  		/* bc 4, CR6_EQ, 20 */
		/* 82062DE0h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82062DF4;  }
		/* 82062DE0h case    4:*/		return 0x82062DE4;
		  /* 82062DE4h */ case    5:  		/* lfs FR12, <#[R3 + 10844]> */
		/* 82062DE4h case    5:*/		cpu::mem::load32f( regs, &regs.FR12, (uint32)(regs.R3 + 0x00002A5C) );
		/* 82062DE4h case    5:*/		return 0x82062DE8;
	}
	return 0x82062DE8;
} // Block from 82062DD0h-82062DE8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82062DE8h
// Function 'D3DDevice_GetRenderState_ZWriteEnable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062DE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062DE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062DE8);
		  /* 82062DE8h */ case    0:  		/* li R10, 0 */
		/* 82062DE8h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82062DE8h case    0:*/		return 0x82062DEC;
		  /* 82062DECh */ case    1:  		/* fcmpu CR6, FR12, FR0 */
		/* 82062DECh case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR12,regs.FR0);
		/* 82062DECh case    1:*/		return 0x82062DF0;
		  /* 82062DF0h */ case    2:  		/* bc 12, CR6_EQ, 8 */
		/* 82062DF0h case    2:*/		if ( regs.CR[6].eq ) { return 0x82062DF8;  }
		/* 82062DF0h case    2:*/		return 0x82062DF4;
	}
	return 0x82062DF4;
} // Block from 82062DE8h-82062DF4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82062DF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062DF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062DF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062DF4);
		  /* 82062DF4h */ case    0:  		/* li R10, 1 */
		/* 82062DF4h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82062DF4h case    0:*/		return 0x82062DF8;
	}
	return 0x82062DF8;
} // Block from 82062DF4h-82062DF8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062DF8h
// Function 'D3DDevice_SetRenderState_ZFunc'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062DF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062DF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062DF8);
		  /* 82062DF8h */ case    0:  		/* li R12, 1 */
		/* 82062DF8h case    0:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 82062DF8h case    0:*/		return 0x82062DFC;
		  /* 82062DFCh */ case    1:  		/* stfs FR13, <#[R3 + 10832]> */
		/* 82062DFCh case    1:*/		cpu::mem::store32f( regs, regs.FR13, (uint32)(regs.R3 + 0x00002A50) );
		/* 82062DFCh case    1:*/		return 0x82062E00;
		  /* 82062E00h */ case    2:  		/* rlwimi R11, R10, 12, 19, 19 */
		/* 82062E00h case    2:*/		cpu::op::rlwimi<0,12,19,19>(regs,&regs.R11,regs.R10);
		/* 82062E00h case    2:*/		return 0x82062E04;
		  /* 82062E04h */ case    3:  		/* stfs FR13, <#[R3 + 10840]> */
		/* 82062E04h case    3:*/		cpu::mem::store32f( regs, regs.FR13, (uint32)(regs.R3 + 0x00002A58) );
		/* 82062E04h case    3:*/		return 0x82062E08;
		  /* 82062E08h */ case    4:  		/* rldicr R12, R12, 45, 63 */
		/* 82062E08h case    4:*/		cpu::op::rldicr<0,45,63>(regs,&regs.R12,regs.R12);
		/* 82062E08h case    4:*/		return 0x82062E0C;
		  /* 82062E0Ch */ case    5:  		/* stw R11, <#[R3 + 10568]> */
		/* 82062E0Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002948) );
		/* 82062E0Ch case    5:*/		return 0x82062E10;
		  /* 82062E10h */ case    6:  		/* ld R11, <#[R3 + 32]> */
		/* 82062E10h case    6:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 82062E10h case    6:*/		return 0x82062E14;
		  /* 82062E14h */ case    7:  		/* or R11, R11, R12 */
		/* 82062E14h case    7:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 82062E14h case    7:*/		return 0x82062E18;
		  /* 82062E18h */ case    8:  		/* li R12, 1 */
		/* 82062E18h case    8:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 82062E18h case    8:*/		return 0x82062E1C;
		  /* 82062E1Ch */ case    9:  		/* std R11, <#[R3 + 32]> */
		/* 82062E1Ch case    9:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 82062E1Ch case    9:*/		return 0x82062E20;
	}
	return 0x82062E20;
} // Block from 82062DF8h-82062E20h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82062E20h
// Function 'D3DDevice_GetRenderState_ZFunc'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062E20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062E20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062E20);
		  /* 82062E20h */ case    0:  		/* rldicr R12, R12, 43, 63 */
		/* 82062E20h case    0:*/		cpu::op::rldicr<0,43,63>(regs,&regs.R12,regs.R12);
		/* 82062E20h case    0:*/		return 0x82062E24;
		  /* 82062E24h */ case    1:  		/* or R11, R11, R12 */
		/* 82062E24h case    1:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 82062E24h case    1:*/		return 0x82062E28;
		  /* 82062E28h */ case    2:  		/* std R11, <#[R3 + 32]> */
		/* 82062E28h case    2:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 82062E28h case    2:*/		return 0x82062E2C;
		  /* 82062E2Ch */ case    3:  		/* ld R11, <#[R3 + 16]> */
		/* 82062E2Ch case    3:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062E2Ch case    3:*/		return 0x82062E30;
	}
	return 0x82062E30;
} // Block from 82062E20h-82062E30h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82062E30h
// Function 'D3DDevice_SetRenderState_StencilEnable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062E30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062E30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062E30);
		  /* 82062E30h */ case    0:  		/* ori R11, R11, 64 */
		/* 82062E30h case    0:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x40);
		/* 82062E30h case    0:*/		return 0x82062E34;
		  /* 82062E34h */ case    1:  		/* std R11, <#[R3 + 16]> */
		/* 82062E34h case    1:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062E34h case    1:*/		return 0x82062E38;
		  /* 82062E38h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82062E38h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062E38h case    2:*/		return 0x82062E3C;
	}
	return 0x82062E3C;
} // Block from 82062E30h-82062E3Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82062E3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062E3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062E3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062E3C);
		  /* 82062E3Ch */ case    0:  		/* nop */
		/* 82062E3Ch case    0:*/		cpu::op::nop();
		/* 82062E3Ch case    0:*/		return 0x82062E40;
	}
	return 0x82062E40;
} // Block from 82062E3Ch-82062E40h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062E40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062E40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062E40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062E40);
		  /* 82062E40h */ case    0:  		/* lis R11, -32256 */
		/* 82062E40h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82062E40h case    0:*/		return 0x82062E44;
		  /* 82062E44h */ case    1:  		/* lfs FR13, <#[R3 + 10832]> */
		/* 82062E44h case    1:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R3 + 0x00002A50) );
		/* 82062E44h case    1:*/		return 0x82062E48;
		  /* 82062E48h */ case    2:  		/* lfs FR0, <#[R11 + 2980]> */
		/* 82062E48h case    2:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000BA4) );
		/* 82062E48h case    2:*/		return 0x82062E4C;
		  /* 82062E4Ch */ case    3:  		/* fmuls FR0, FR13, FR0 */
		/* 82062E4Ch case    3:*/		cpu::op::fmuls<0>(regs,&regs.FR0,regs.FR13,regs.FR0);
		/* 82062E4Ch case    3:*/		return 0x82062E50;
		  /* 82062E50h */ case    4:  		/* stfs FR0, <#[R1 - 16]> */
		/* 82062E50h case    4:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82062E50h case    4:*/		return 0x82062E54;
		  /* 82062E54h */ case    5:  		/* lwz R3, <#[R1 - 16]> */
		/* 82062E54h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82062E54h case    5:*/		return 0x82062E58;
		  /* 82062E58h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82062E58h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062E58h case    6:*/		return 0x82062E5C;
	}
	return 0x82062E5C;
} // Block from 82062E40h-82062E5Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 82062E5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062E5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062E5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062E5C);
		  /* 82062E5Ch */ case    0:  		/* nop */
		/* 82062E5Ch case    0:*/		cpu::op::nop();
		/* 82062E5Ch case    0:*/		return 0x82062E60;
	}
	return 0x82062E60;
} // Block from 82062E5Ch-82062E60h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062E60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062E60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062E60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062E60);
		  /* 82062E60h */ case    0:  		/* lis R11, -32256 */
		/* 82062E60h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82062E60h case    0:*/		return 0x82062E64;
		  /* 82062E64h */ case    1:  		/* lfs FR12, <#[R3 + 10832]> */
		/* 82062E64h case    1:*/		cpu::mem::load32f( regs, &regs.FR12, (uint32)(regs.R3 + 0x00002A50) );
		/* 82062E64h case    1:*/		return 0x82062E68;
	}
	return 0x82062E68;
} // Block from 82062E60h-82062E68h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82062E68h
// Function 'D3DDevice_GetRenderState_StencilEnable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062E68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062E68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062E68);
		  /* 82062E68h */ case    0:  		/* stw R4, <#[R1 + 28]> */
		/* 82062E68h case    0:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000001C) );
		/* 82062E68h case    0:*/		return 0x82062E6C;
		  /* 82062E6Ch */ case    1:  		/* lfs FR13, <#[R1 + 28]> */
		/* 82062E6Ch case    1:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R1 + 0x0000001C) );
		/* 82062E6Ch case    1:*/		return 0x82062E70;
	}
	return 0x82062E70;
} // Block from 82062E68h-82062E70h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82062E70h
// Function 'D3DDevice_SetRenderState_TwoSidedStencilMode'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062E70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062E70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062E70);
		  /* 82062E70h */ case    0:  		/* lfs FR0, <#[R11 + 1816]> */
		/* 82062E70h case    0:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000718) );
		/* 82062E70h case    0:*/		return 0x82062E74;
		  /* 82062E74h */ case    1:  		/* fcmpu CR6, FR12, FR0 */
		/* 82062E74h case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR12,regs.FR0);
		/* 82062E74h case    1:*/		return 0x82062E78;
		  /* 82062E78h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 82062E78h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82062E88;  }
		/* 82062E78h case    2:*/		return 0x82062E7C;
		  /* 82062E7Ch */ case    3:  		/* fcmpu CR6, FR13, FR0 */
		/* 82062E7Ch case    3:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 82062E7Ch case    3:*/		return 0x82062E80;
		  /* 82062E80h */ case    4:  		/* li R10, 0 */
		/* 82062E80h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82062E80h case    4:*/		return 0x82062E84;
		  /* 82062E84h */ case    5:  		/* bc 12, CR6_EQ, 8 */
		/* 82062E84h case    5:*/		if ( regs.CR[6].eq ) { return 0x82062E8C;  }
		/* 82062E84h case    5:*/		return 0x82062E88;
	}
	return 0x82062E88;
} // Block from 82062E70h-82062E88h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82062E88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062E88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062E88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062E88);
		  /* 82062E88h */ case    0:  		/* li R10, 1 */
		/* 82062E88h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82062E88h case    0:*/		return 0x82062E8C;
	}
	return 0x82062E8C;
} // Block from 82062E88h-82062E8Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062E8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062E8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062E8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062E8C);
		  /* 82062E8Ch */ case    0:  		/* lwz R11, <#[R3 + 10568]> */
		/* 82062E8Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002948) );
		/* 82062E8Ch case    0:*/		return 0x82062E90;
		  /* 82062E90h */ case    1:  		/* lfs FR12, <#[R3 + 10840]> */
		/* 82062E90h case    1:*/		cpu::mem::load32f( regs, &regs.FR12, (uint32)(regs.R3 + 0x00002A58) );
		/* 82062E90h case    1:*/		return 0x82062E94;
		  /* 82062E94h */ case    2:  		/* fcmpu CR6, FR12, FR0 */
		/* 82062E94h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR12,regs.FR0);
		/* 82062E94h case    2:*/		return 0x82062E98;
	}
	return 0x82062E98;
} // Block from 82062E8Ch-82062E98h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82062E98h
// Function 'D3DDevice_GetRenderState_TwoSidedStencilMode'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062E98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062E98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062E98);
		  /* 82062E98h */ case    0:  		/* rlwimi R11, R10, 11, 20, 20 */
		/* 82062E98h case    0:*/		cpu::op::rlwimi<0,11,20,20>(regs,&regs.R11,regs.R10);
		/* 82062E98h case    0:*/		return 0x82062E9C;
		  /* 82062E9Ch */ case    1:  		/* stw R11, <#[R3 + 10568]> */
		/* 82062E9Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002948) );
		/* 82062E9Ch case    1:*/		return 0x82062EA0;
		  /* 82062EA0h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 82062EA0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82062EB0;  }
		/* 82062EA0h case    2:*/		return 0x82062EA4;
		  /* 82062EA4h */ case    3:  		/* fcmpu CR6, FR13, FR0 */
		/* 82062EA4h case    3:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 82062EA4h case    3:*/		return 0x82062EA8;
	}
	return 0x82062EA8;
} // Block from 82062E98h-82062EA8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82062EA8h
// Function 'D3DDevice_SetRenderState_StencilFunc'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062EA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062EA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062EA8);
		  /* 82062EA8h */ case    0:  		/* li R10, 0 */
		/* 82062EA8h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82062EA8h case    0:*/		return 0x82062EAC;
		  /* 82062EACh */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 82062EACh case    1:*/		if ( regs.CR[6].eq ) { return 0x82062EB4;  }
		/* 82062EACh case    1:*/		return 0x82062EB0;
	}
	return 0x82062EB0;
} // Block from 82062EA8h-82062EB0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82062EB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062EB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062EB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062EB0);
		  /* 82062EB0h */ case    0:  		/* li R10, 1 */
		/* 82062EB0h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82062EB0h case    0:*/		return 0x82062EB4;
	}
	return 0x82062EB4;
} // Block from 82062EB0h-82062EB4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062EB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062EB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062EB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062EB4);
		  /* 82062EB4h */ case    0:  		/* li R12, 1 */
		/* 82062EB4h case    0:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 82062EB4h case    0:*/		return 0x82062EB8;
		  /* 82062EB8h */ case    1:  		/* stfs FR13, <#[R3 + 10836]> */
		/* 82062EB8h case    1:*/		cpu::mem::store32f( regs, regs.FR13, (uint32)(regs.R3 + 0x00002A54) );
		/* 82062EB8h case    1:*/		return 0x82062EBC;
		  /* 82062EBCh */ case    2:  		/* rlwimi R11, R10, 12, 19, 19 */
		/* 82062EBCh case    2:*/		cpu::op::rlwimi<0,12,19,19>(regs,&regs.R11,regs.R10);
		/* 82062EBCh case    2:*/		return 0x82062EC0;
		  /* 82062EC0h */ case    3:  		/* stfs FR13, <#[R3 + 10844]> */
		/* 82062EC0h case    3:*/		cpu::mem::store32f( regs, regs.FR13, (uint32)(regs.R3 + 0x00002A5C) );
		/* 82062EC0h case    3:*/		return 0x82062EC4;
		  /* 82062EC4h */ case    4:  		/* rldicr R12, R12, 44, 63 */
		/* 82062EC4h case    4:*/		cpu::op::rldicr<0,44,63>(regs,&regs.R12,regs.R12);
		/* 82062EC4h case    4:*/		return 0x82062EC8;
	}
	return 0x82062EC8;
} // Block from 82062EB4h-82062EC8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82062EC8h
// Function 'D3DDevice_GetRenderState_StencilFunc'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062EC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062EC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062EC8);
		  /* 82062EC8h */ case    0:  		/* stw R11, <#[R3 + 10568]> */
		/* 82062EC8h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002948) );
		/* 82062EC8h case    0:*/		return 0x82062ECC;
		  /* 82062ECCh */ case    1:  		/* ld R11, <#[R3 + 32]> */
		/* 82062ECCh case    1:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 82062ECCh case    1:*/		return 0x82062ED0;
		  /* 82062ED0h */ case    2:  		/* or R11, R11, R12 */
		/* 82062ED0h case    2:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 82062ED0h case    2:*/		return 0x82062ED4;
		  /* 82062ED4h */ case    3:  		/* li R12, 1 */
		/* 82062ED4h case    3:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 82062ED4h case    3:*/		return 0x82062ED8;
	}
	return 0x82062ED8;
} // Block from 82062EC8h-82062ED8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82062ED8h
// Function 'D3DDevice_SetRenderState_StencilFail'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062ED8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062ED8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062ED8);
		  /* 82062ED8h */ case    0:  		/* std R11, <#[R3 + 32]> */
		/* 82062ED8h case    0:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 82062ED8h case    0:*/		return 0x82062EDC;
		  /* 82062EDCh */ case    1:  		/* rldicr R12, R12, 42, 63 */
		/* 82062EDCh case    1:*/		cpu::op::rldicr<0,42,63>(regs,&regs.R12,regs.R12);
		/* 82062EDCh case    1:*/		return 0x82062EE0;
		  /* 82062EE0h */ case    2:  		/* or R11, R11, R12 */
		/* 82062EE0h case    2:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 82062EE0h case    2:*/		return 0x82062EE4;
		  /* 82062EE4h */ case    3:  		/* std R11, <#[R3 + 32]> */
		/* 82062EE4h case    3:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 82062EE4h case    3:*/		return 0x82062EE8;
		  /* 82062EE8h */ case    4:  		/* ld R11, <#[R3 + 16]> */
		/* 82062EE8h case    4:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062EE8h case    4:*/		return 0x82062EEC;
		  /* 82062EECh */ case    5:  		/* ori R11, R11, 64 */
		/* 82062EECh case    5:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x40);
		/* 82062EECh case    5:*/		return 0x82062EF0;
		  /* 82062EF0h */ case    6:  		/* std R11, <#[R3 + 16]> */
		/* 82062EF0h case    6:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062EF0h case    6:*/		return 0x82062EF4;
		  /* 82062EF4h */ case    7:  		/* bclr 20, CR0_LT */
		/* 82062EF4h case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062EF4h case    7:*/		return 0x82062EF8;
	}
	return 0x82062EF8;
} // Block from 82062ED8h-82062EF8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82062EF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062EF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062EF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062EF8);
		  /* 82062EF8h */ case    0:  		/* lfs FR0, <#[R3 + 10836]> */
		/* 82062EF8h case    0:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R3 + 0x00002A54) );
		/* 82062EF8h case    0:*/		return 0x82062EFC;
		  /* 82062EFCh */ case    1:  		/* stfs FR0, <#[R1 - 16]> */
		/* 82062EFCh case    1:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82062EFCh case    1:*/		return 0x82062F00;
	}
	return 0x82062F00;
} // Block from 82062EF8h-82062F00h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82062F00h
// Function 'D3DDevice_GetRenderState_StencilFail'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062F00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062F00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062F00);
		  /* 82062F00h */ case    0:  		/* lwz R3, <#[R1 - 16]> */
		/* 82062F00h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82062F00h case    0:*/		return 0x82062F04;
		  /* 82062F04h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82062F04h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062F04h case    1:*/		return 0x82062F08;
	}
	return 0x82062F08;
} // Block from 82062F00h-82062F08h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82062F08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062F08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062F08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062F08);
		  /* 82062F08h */ case    0:  		/* lwz R11, <#[R3 + 10568]> */
		/* 82062F08h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002948) );
		/* 82062F08h case    0:*/		return 0x82062F0C;
		  /* 82062F0Ch */ case    1:  		/* rlwimi R11, R4, 15, 16, 16 */
		/* 82062F0Ch case    1:*/		cpu::op::rlwimi<0,15,16,16>(regs,&regs.R11,regs.R4);
		/* 82062F0Ch case    1:*/		return 0x82062F10;
	}
	return 0x82062F10;
} // Block from 82062F08h-82062F10h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82062F10h
// Function 'D3DDevice_SetRenderState_StencilZFail'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062F10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062F10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062F10);
		  /* 82062F10h */ case    0:  		/* stw R11, <#[R3 + 10568]> */
		/* 82062F10h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002948) );
		/* 82062F10h case    0:*/		return 0x82062F14;
		  /* 82062F14h */ case    1:  		/* ld R11, <#[R3 + 16]> */
		/* 82062F14h case    1:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062F14h case    1:*/		return 0x82062F18;
		  /* 82062F18h */ case    2:  		/* ori R11, R11, 64 */
		/* 82062F18h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x40);
		/* 82062F18h case    2:*/		return 0x82062F1C;
		  /* 82062F1Ch */ case    3:  		/* std R11, <#[R3 + 16]> */
		/* 82062F1Ch case    3:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062F1Ch case    3:*/		return 0x82062F20;
		  /* 82062F20h */ case    4:  		/* bclr 20, CR0_LT */
		/* 82062F20h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062F20h case    4:*/		return 0x82062F24;
	}
	return 0x82062F24;
} // Block from 82062F10h-82062F24h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82062F24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062F24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062F24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062F24);
		  /* 82062F24h */ case    0:  		/* nop */
		/* 82062F24h case    0:*/		cpu::op::nop();
		/* 82062F24h case    0:*/		return 0x82062F28;
	}
	return 0x82062F28;
} // Block from 82062F24h-82062F28h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062F28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062F28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062F28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062F28);
		  /* 82062F28h */ case    0:  		/* lwz R11, <#[R3 + 10568]> */
		/* 82062F28h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002948) );
		/* 82062F28h case    0:*/		return 0x82062F2C;
		  /* 82062F2Ch */ case    1:  		/* rlwinm R3, R11, 17, 31, 31 */
		/* 82062F2Ch case    1:*/		cpu::op::rlwinm<0,17,31,31>(regs,&regs.R3,regs.R11);
		/* 82062F2Ch case    1:*/		return 0x82062F30;
		  /* 82062F30h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82062F30h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062F30h case    2:*/		return 0x82062F34;
	}
	return 0x82062F34;
} // Block from 82062F28h-82062F34h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82062F34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062F34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062F34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062F34);
		  /* 82062F34h */ case    0:  		/* nop */
		/* 82062F34h case    0:*/		cpu::op::nop();
		/* 82062F34h case    0:*/		return 0x82062F38;
	}
	return 0x82062F38;
} // Block from 82062F34h-82062F38h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82062F38h
// Function 'D3DDevice_GetRenderState_StencilZFail'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062F38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062F38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062F38);
		  /* 82062F38h */ case    0:  		/* rlwinm R11, R4, 0, 16, 31 */
		/* 82062F38h case    0:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R4);
		/* 82062F38h case    0:*/		return 0x82062F3C;
		  /* 82062F3Ch */ case    1:  		/* stw R11, <#[R3 + 10752]> */
		/* 82062F3Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002A00) );
		/* 82062F3Ch case    1:*/		return 0x82062F40;
		  /* 82062F40h */ case    2:  		/* ld R11, <#[R3 + 32]> */
		/* 82062F40h case    2:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 82062F40h case    2:*/		return 0x82062F44;
		  /* 82062F44h */ case    3:  		/* oris R11, R11, 8 */
		/* 82062F44h case    3:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8);
		/* 82062F44h case    3:*/		return 0x82062F48;
	}
	return 0x82062F48;
} // Block from 82062F38h-82062F48h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82062F48h
// Function 'D3DDevice_SetRenderState_StencilPass'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062F48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062F48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062F48);
		  /* 82062F48h */ case    0:  		/* std R11, <#[R3 + 32]> */
		/* 82062F48h case    0:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 82062F48h case    0:*/		return 0x82062F4C;
		  /* 82062F4Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 82062F4Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062F4Ch case    1:*/		return 0x82062F50;
	}
	return 0x82062F50;
} // Block from 82062F48h-82062F50h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82062F50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062F50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062F50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062F50);
		  /* 82062F50h */ case    0:  		/* lwz R3, <#[R3 + 10752]> */
		/* 82062F50h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00002A00) );
		/* 82062F50h case    0:*/		return 0x82062F54;
		  /* 82062F54h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82062F54h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062F54h case    1:*/		return 0x82062F58;
	}
	return 0x82062F58;
} // Block from 82062F50h-82062F58h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82062F58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062F58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062F58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062F58);
		  /* 82062F58h */ case    0:  		/* lwz R11, <#[R3 + 12816]> */
		/* 82062F58h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00003210) );
		/* 82062F58h case    0:*/		return 0x82062F5C;
		  /* 82062F5Ch */ case    1:  		/* li R12, 1 */
		/* 82062F5Ch case    1:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 82062F5Ch case    1:*/		return 0x82062F60;
		  /* 82062F60h */ case    2:  		/* lwz R9, <#[R3 + 10460]> */
		/* 82062F60h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x000028DC) );
		/* 82062F60h case    2:*/		return 0x82062F64;
		  /* 82062F64h */ case    3:  		/* subfic R11, R11, 0 */
		/* 82062F64h case    3:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x0);
		/* 82062F64h case    3:*/		return 0x82062F68;
	}
	return 0x82062F68;
} // Block from 82062F58h-82062F68h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82062F68h
// Function 'D3DDevice_GetRenderState_StencilPass'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062F68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062F68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062F68);
		  /* 82062F68h */ case    0:  		/* stw R4, <#[R3 + 12292]> */
		/* 82062F68h case    0:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00003004) );
		/* 82062F68h case    0:*/		return 0x82062F6C;
		  /* 82062F6Ch */ case    1:  		/* rldicr R12, R12, 37, 63 */
		/* 82062F6Ch case    1:*/		cpu::op::rldicr<0,37,63>(regs,&regs.R12,regs.R12);
		/* 82062F6Ch case    1:*/		return 0x82062F70;
		  /* 82062F70h */ case    2:  		/* subfe R11, R11, R11 */
		/* 82062F70h case    2:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82062F70h case    2:*/		return 0x82062F74;
		  /* 82062F74h */ case    3:  		/* and R11, R11, R4 */
		/* 82062F74h case    3:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R4);
		/* 82062F74h case    3:*/		return 0x82062F78;
	}
	return 0x82062F78;
} // Block from 82062F68h-82062F78h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82062F78h
// Function 'D3DDevice_SetRenderState_CCWStencilFunc'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062F78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062F78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062F78);
		  /* 82062F78h */ case    0:  		/* rlwimi R11, R9, 0, 0, 27 */
		/* 82062F78h case    0:*/		cpu::op::rlwimi<0,0,0,27>(regs,&regs.R11,regs.R9);
		/* 82062F78h case    0:*/		return 0x82062F7C;
		  /* 82062F7Ch */ case    1:  		/* stw R11, <#[R3 + 10460]> */
		/* 82062F7Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x000028DC) );
		/* 82062F7Ch case    1:*/		return 0x82062F80;
		  /* 82062F80h */ case    2:  		/* ld R11, <#[R3 + 16]> */
		/* 82062F80h case    2:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062F80h case    2:*/		return 0x82062F84;
		  /* 82062F84h */ case    3:  		/* or R11, R11, R12 */
		/* 82062F84h case    3:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 82062F84h case    3:*/		return 0x82062F88;
		  /* 82062F88h */ case    4:  		/* std R11, <#[R3 + 16]> */
		/* 82062F88h case    4:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062F88h case    4:*/		return 0x82062F8C;
		  /* 82062F8Ch */ case    5:  		/* bclr 20, CR0_LT */
		/* 82062F8Ch case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062F8Ch case    5:*/		return 0x82062F90;
	}
	return 0x82062F90;
} // Block from 82062F78h-82062F90h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82062F90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062F90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062F90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062F90);
		  /* 82062F90h */ case    0:  		/* lwz R3, <#[R3 + 12292]> */
		/* 82062F90h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00003004) );
		/* 82062F90h case    0:*/		return 0x82062F94;
		  /* 82062F94h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82062F94h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062F94h case    1:*/		return 0x82062F98;
	}
	return 0x82062F98;
} // Block from 82062F90h-82062F98h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82062F98h
// Function 'D3DDevice_GetRenderState_CCWStencilFunc'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062F98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062F98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062F98);
		  /* 82062F98h */ case    0:  		/* lwz R11, <#[R3 + 12820]> */
		/* 82062F98h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00003214) );
		/* 82062F98h case    0:*/		return 0x82062F9C;
		  /* 82062F9Ch */ case    1:  		/* li R12, 1 */
		/* 82062F9Ch case    1:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 82062F9Ch case    1:*/		return 0x82062FA0;
		  /* 82062FA0h */ case    2:  		/* lwz R9, <#[R3 + 10460]> */
		/* 82062FA0h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x000028DC) );
		/* 82062FA0h case    2:*/		return 0x82062FA4;
		  /* 82062FA4h */ case    3:  		/* subfic R11, R11, 0 */
		/* 82062FA4h case    3:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x0);
		/* 82062FA4h case    3:*/		return 0x82062FA8;
	}
	return 0x82062FA8;
} // Block from 82062F98h-82062FA8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82062FA8h
// Function 'D3DDevice_SetRenderState_CCWStencilFail'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062FA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062FA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062FA8);
		  /* 82062FA8h */ case    0:  		/* stw R4, <#[R3 + 12296]> */
		/* 82062FA8h case    0:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00003008) );
		/* 82062FA8h case    0:*/		return 0x82062FAC;
		  /* 82062FACh */ case    1:  		/* rldicr R12, R12, 37, 63 */
		/* 82062FACh case    1:*/		cpu::op::rldicr<0,37,63>(regs,&regs.R12,regs.R12);
		/* 82062FACh case    1:*/		return 0x82062FB0;
		  /* 82062FB0h */ case    2:  		/* subfe R11, R11, R11 */
		/* 82062FB0h case    2:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82062FB0h case    2:*/		return 0x82062FB4;
		  /* 82062FB4h */ case    3:  		/* and R11, R11, R4 */
		/* 82062FB4h case    3:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R4);
		/* 82062FB4h case    3:*/		return 0x82062FB8;
		  /* 82062FB8h */ case    4:  		/* rlwimi R9, R11, 4, 24, 27 */
		/* 82062FB8h case    4:*/		cpu::op::rlwimi<0,4,24,27>(regs,&regs.R9,regs.R11);
		/* 82062FB8h case    4:*/		return 0x82062FBC;
		  /* 82062FBCh */ case    5:  		/* stw R9, <#[R3 + 10460]> */
		/* 82062FBCh case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x000028DC) );
		/* 82062FBCh case    5:*/		return 0x82062FC0;
		  /* 82062FC0h */ case    6:  		/* ld R11, <#[R3 + 16]> */
		/* 82062FC0h case    6:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062FC0h case    6:*/		return 0x82062FC4;
		  /* 82062FC4h */ case    7:  		/* or R11, R11, R12 */
		/* 82062FC4h case    7:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 82062FC4h case    7:*/		return 0x82062FC8;
		  /* 82062FC8h */ case    8:  		/* std R11, <#[R3 + 16]> */
		/* 82062FC8h case    8:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82062FC8h case    8:*/		return 0x82062FCC;
		  /* 82062FCCh */ case    9:  		/* bclr 20, CR0_LT */
		/* 82062FCCh case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062FCCh case    9:*/		return 0x82062FD0;
	}
	return 0x82062FD0;
} // Block from 82062FA8h-82062FD0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82062FD0h
// Function 'D3DDevice_GetRenderState_CCWStencilFail'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062FD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062FD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062FD0);
		  /* 82062FD0h */ case    0:  		/* lwz R3, <#[R3 + 12296]> */
		/* 82062FD0h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00003008) );
		/* 82062FD0h case    0:*/		return 0x82062FD4;
		  /* 82062FD4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82062FD4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82062FD4h case    1:*/		return 0x82062FD8;
	}
	return 0x82062FD8;
} // Block from 82062FD0h-82062FD8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82062FD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062FD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062FD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062FD8);
		  /* 82062FD8h */ case    0:  		/* lwz R11, <#[R3 + 12824]> */
		/* 82062FD8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00003218) );
		/* 82062FD8h case    0:*/		return 0x82062FDC;
		  /* 82062FDCh */ case    1:  		/* li R12, 1 */
		/* 82062FDCh case    1:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 82062FDCh case    1:*/		return 0x82062FE0;
	}
	return 0x82062FE0;
} // Block from 82062FD8h-82062FE0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82062FE0h
// Function 'D3DDevice_SetRenderState_CCWStencilZFail'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82062FE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82062FE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82062FE0);
		  /* 82062FE0h */ case    0:  		/* lwz R9, <#[R3 + 10460]> */
		/* 82062FE0h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x000028DC) );
		/* 82062FE0h case    0:*/		return 0x82062FE4;
		  /* 82062FE4h */ case    1:  		/* subfic R11, R11, 0 */
		/* 82062FE4h case    1:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x0);
		/* 82062FE4h case    1:*/		return 0x82062FE8;
		  /* 82062FE8h */ case    2:  		/* stw R4, <#[R3 + 12300]> */
		/* 82062FE8h case    2:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x0000300C) );
		/* 82062FE8h case    2:*/		return 0x82062FEC;
		  /* 82062FECh */ case    3:  		/* rldicr R12, R12, 37, 63 */
		/* 82062FECh case    3:*/		cpu::op::rldicr<0,37,63>(regs,&regs.R12,regs.R12);
		/* 82062FECh case    3:*/		return 0x82062FF0;
		  /* 82062FF0h */ case    4:  		/* subfe R11, R11, R11 */
		/* 82062FF0h case    4:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82062FF0h case    4:*/		return 0x82062FF4;
		  /* 82062FF4h */ case    5:  		/* and R11, R11, R4 */
		/* 82062FF4h case    5:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R4);
		/* 82062FF4h case    5:*/		return 0x82062FF8;
		  /* 82062FF8h */ case    6:  		/* rlwimi R9, R11, 8, 20, 23 */
		/* 82062FF8h case    6:*/		cpu::op::rlwimi<0,8,20,23>(regs,&regs.R9,regs.R11);
		/* 82062FF8h case    6:*/		return 0x82062FFC;
		  /* 82062FFCh */ case    7:  		/* stw R9, <#[R3 + 10460]> */
		/* 82062FFCh case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x000028DC) );
		/* 82062FFCh case    7:*/		return 0x82063000;
		  /* 82063000h */ case    8:  		/* ld R11, <#[R3 + 16]> */
		/* 82063000h case    8:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82063000h case    8:*/		return 0x82063004;
		  /* 82063004h */ case    9:  		/* or R11, R11, R12 */
		/* 82063004h case    9:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 82063004h case    9:*/		return 0x82063008;
	}
	return 0x82063008;
} // Block from 82062FE0h-82063008h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82063008h
// Function 'D3DDevice_GetRenderState_CCWStencilZFail'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063008( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063008) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063008);
		  /* 82063008h */ case    0:  		/* std R11, <#[R3 + 16]> */
		/* 82063008h case    0:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82063008h case    0:*/		return 0x8206300C;
		  /* 8206300Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 8206300Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206300Ch case    1:*/		return 0x82063010;
	}
	return 0x82063010;
} // Block from 82063008h-82063010h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063010h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063010( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063010) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063010);
		  /* 82063010h */ case    0:  		/* lwz R3, <#[R3 + 12300]> */
		/* 82063010h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x0000300C) );
		/* 82063010h case    0:*/		return 0x82063014;
		  /* 82063014h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82063014h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063014h case    1:*/		return 0x82063018;
	}
	return 0x82063018;
} // Block from 82063010h-82063018h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063018h
// Function 'D3DDevice_SetRenderState_CCWStencilPass'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063018( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063018) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063018);
		  /* 82063018h */ case    0:  		/* lwz R11, <#[R3 + 12828]> */
		/* 82063018h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000321C) );
		/* 82063018h case    0:*/		return 0x8206301C;
		  /* 8206301Ch */ case    1:  		/* li R12, 1 */
		/* 8206301Ch case    1:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 8206301Ch case    1:*/		return 0x82063020;
		  /* 82063020h */ case    2:  		/* lwz R9, <#[R3 + 10460]> */
		/* 82063020h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x000028DC) );
		/* 82063020h case    2:*/		return 0x82063024;
		  /* 82063024h */ case    3:  		/* subfic R11, R11, 0 */
		/* 82063024h case    3:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x0);
		/* 82063024h case    3:*/		return 0x82063028;
		  /* 82063028h */ case    4:  		/* stw R4, <#[R3 + 12304]> */
		/* 82063028h case    4:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00003010) );
		/* 82063028h case    4:*/		return 0x8206302C;
		  /* 8206302Ch */ case    5:  		/* rldicr R12, R12, 37, 63 */
		/* 8206302Ch case    5:*/		cpu::op::rldicr<0,37,63>(regs,&regs.R12,regs.R12);
		/* 8206302Ch case    5:*/		return 0x82063030;
		  /* 82063030h */ case    6:  		/* subfe R11, R11, R11 */
		/* 82063030h case    6:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82063030h case    6:*/		return 0x82063034;
		  /* 82063034h */ case    7:  		/* and R11, R11, R4 */
		/* 82063034h case    7:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R4);
		/* 82063034h case    7:*/		return 0x82063038;
	}
	return 0x82063038;
} // Block from 82063018h-82063038h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82063038h
// Function 'D3DDevice_GetRenderState_CCWStencilPass'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063038( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063038) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063038);
		  /* 82063038h */ case    0:  		/* rlwimi R9, R11, 12, 16, 19 */
		/* 82063038h case    0:*/		cpu::op::rlwimi<0,12,16,19>(regs,&regs.R9,regs.R11);
		/* 82063038h case    0:*/		return 0x8206303C;
		  /* 8206303Ch */ case    1:  		/* stw R9, <#[R3 + 10460]> */
		/* 8206303Ch case    1:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x000028DC) );
		/* 8206303Ch case    1:*/		return 0x82063040;
		  /* 82063040h */ case    2:  		/* ld R11, <#[R3 + 16]> */
		/* 82063040h case    2:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82063040h case    2:*/		return 0x82063044;
		  /* 82063044h */ case    3:  		/* or R11, R11, R12 */
		/* 82063044h case    3:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 82063044h case    3:*/		return 0x82063048;
	}
	return 0x82063048;
} // Block from 82063038h-82063048h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82063048h
// Function 'D3DDevice_SetRenderState_StencilRef'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063048( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063048) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063048);
		  /* 82063048h */ case    0:  		/* std R11, <#[R3 + 16]> */
		/* 82063048h case    0:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82063048h case    0:*/		return 0x8206304C;
		  /* 8206304Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 8206304Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206304Ch case    1:*/		return 0x82063050;
	}
	return 0x82063050;
} // Block from 82063048h-82063050h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063050h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063050( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063050) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063050);
		  /* 82063050h */ case    0:  		/* lwz R3, <#[R3 + 12304]> */
		/* 82063050h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00003010) );
		/* 82063050h case    0:*/		return 0x82063054;
		  /* 82063054h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82063054h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063054h case    1:*/		return 0x82063058;
	}
	return 0x82063058;
} // Block from 82063050h-82063058h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063058h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063058( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063058) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063058);
		  /* 82063058h */ case    0:  		/* stw R4, <#[R3 + 12316]> */
		/* 82063058h case    0:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x0000301C) );
		/* 82063058h case    0:*/		return 0x8206305C;
		  /* 8206305Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 8206305Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206305Ch case    1:*/		return 0x82063060;
	}
	return 0x82063060;
} // Block from 82063058h-82063060h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063060h
// Function 'D3DDevice_GetRenderState_StencilRef'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063060( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063060) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063060);
		  /* 82063060h */ case    0:  		/* lwz R3, <#[R3 + 12316]> */
		/* 82063060h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x0000301C) );
		/* 82063060h case    0:*/		return 0x82063064;
		  /* 82063064h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82063064h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063064h case    1:*/		return 0x82063068;
	}
	return 0x82063068;
} // Block from 82063060h-82063068h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063068h
// Function 'D3DDevice_SetRenderState_StencilMask'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063068( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063068) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063068);
		  /* 82063068h */ case    0:  		/* lis R11, -32256 */
		/* 82063068h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82063068h case    0:*/		return 0x8206306C;
		  /* 8206306Ch */ case    1:  		/* stw R4, <#[R1 + 28]> */
		/* 8206306Ch case    1:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000001C) );
		/* 8206306Ch case    1:*/		return 0x82063070;
		  /* 82063070h */ case    2:  		/* lfs FR0, <#[R1 + 28]> */
		/* 82063070h case    2:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x0000001C) );
		/* 82063070h case    2:*/		return 0x82063074;
		  /* 82063074h */ case    3:  		/* li R12, 1 */
		/* 82063074h case    3:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 82063074h case    3:*/		return 0x82063078;
		  /* 82063078h */ case    4:  		/* stfs FR0, <#[R3 + 12324]> */
		/* 82063078h case    4:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R3 + 0x00003024) );
		/* 82063078h case    4:*/		return 0x8206307C;
		  /* 8206307Ch */ case    5:  		/* lfs FR13, <#[R11 + 2964]> */
		/* 8206307Ch case    5:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000B94) );
		/* 8206307Ch case    5:*/		return 0x82063080;
	}
	return 0x82063080;
} // Block from 82063068h-82063080h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82063080h
// Function 'D3DDevice_GetRenderState_StencilMask'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063080( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063080) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063080);
		  /* 82063080h */ case    0:  		/* rldicr R12, R12, 54, 63 */
		/* 82063080h case    0:*/		cpu::op::rldicr<0,54,63>(regs,&regs.R12,regs.R12);
		/* 82063080h case    0:*/		return 0x82063084;
		  /* 82063084h */ case    1:  		/* fmuls FR0, FR0, FR13 */
		/* 82063084h case    1:*/		cpu::op::fmuls<0>(regs,&regs.FR0,regs.FR0,regs.FR13);
		/* 82063084h case    1:*/		return 0x82063088;
	}
	return 0x82063088;
} // Block from 82063080h-82063088h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063088h
// Function 'D3DDevice_SetRenderState_StencilWriteMask'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063088( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063088) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063088);
		  /* 82063088h */ case    0:  		/* fctiwz FR0, FR0 */
		/* 82063088h case    0:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR0);
		/* 82063088h case    0:*/		return 0x8206308C;
		  /* 8206308Ch */ case    1:  		/* stfd FR0, <#[R1 - 16]> */
		/* 8206308Ch case    1:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206308Ch case    1:*/		return 0x82063090;
		  /* 82063090h */ case    2:  		/* lwz R11, <#[R1 - 12]> */
		/* 82063090h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0xFFFFFFF4) );
		/* 82063090h case    2:*/		return 0x82063094;
		  /* 82063094h */ case    3:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 82063094h case    3:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 82063094h case    3:*/		return 0x82063098;
		  /* 82063098h */ case    4:  		/* sth R11, <#[R3 + 10598]> */
		/* 82063098h case    4:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R3 + 0x00002966) );
		/* 82063098h case    4:*/		return 0x8206309C;
		  /* 8206309Ch */ case    5:  		/* sth R11, <#[R3 + 10596]> */
		/* 8206309Ch case    5:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R3 + 0x00002964) );
		/* 8206309Ch case    5:*/		return 0x820630A0;
	}
	return 0x820630A0;
} // Block from 82063088h-820630A0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820630A0h
// Function 'D3DDevice_GetRenderState_StencilWriteMask'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820630A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820630A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820630A0);
		  /* 820630A0h */ case    0:  		/* ld R11, <#[R3 + 24]> */
		/* 820630A0h case    0:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820630A0h case    0:*/		return 0x820630A4;
		  /* 820630A4h */ case    1:  		/* or R11, R11, R12 */
		/* 820630A4h case    1:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 820630A4h case    1:*/		return 0x820630A8;
	}
	return 0x820630A8;
} // Block from 820630A0h-820630A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820630A8h
// Function 'D3DDevice_SetRenderState_CCWStencilRef'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820630A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820630A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820630A8);
		  /* 820630A8h */ case    0:  		/* std R11, <#[R3 + 24]> */
		/* 820630A8h case    0:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820630A8h case    0:*/		return 0x820630AC;
		  /* 820630ACh */ case    1:  		/* bclr 20, CR0_LT */
		/* 820630ACh case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820630ACh case    1:*/		return 0x820630B0;
	}
	return 0x820630B0;
} // Block from 820630A8h-820630B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820630B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820630B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820630B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820630B0);
		  /* 820630B0h */ case    0:  		/* lfs FR0, <#[R3 + 12324]> */
		/* 820630B0h case    0:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R3 + 0x00003024) );
		/* 820630B0h case    0:*/		return 0x820630B4;
		  /* 820630B4h */ case    1:  		/* stfs FR0, <#[R1 - 16]> */
		/* 820630B4h case    1:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820630B4h case    1:*/		return 0x820630B8;
		  /* 820630B8h */ case    2:  		/* lwz R3, <#[R1 - 16]> */
		/* 820630B8h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820630B8h case    2:*/		return 0x820630BC;
		  /* 820630BCh */ case    3:  		/* bclr 20, CR0_LT */
		/* 820630BCh case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820630BCh case    3:*/		return 0x820630C0;
	}
	return 0x820630C0;
} // Block from 820630B0h-820630C0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820630C0h
// Function 'D3DDevice_GetRenderState_CCWStencilRef'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820630C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820630C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820630C0);
		  /* 820630C0h */ case    0:  		/* lis R11, -32256 */
		/* 820630C0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820630C0h case    0:*/		return 0x820630C4;
		  /* 820630C4h */ case    1:  		/* stw R4, <#[R1 + 28]> */
		/* 820630C4h case    1:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000001C) );
		/* 820630C4h case    1:*/		return 0x820630C8;
	}
	return 0x820630C8;
} // Block from 820630C0h-820630C8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820630C8h
// Function 'D3DDevice_SetRenderState_CCWStencilMask'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820630C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820630C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820630C8);
		  /* 820630C8h */ case    0:  		/* lfs FR0, <#[R1 + 28]> */
		/* 820630C8h case    0:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x0000001C) );
		/* 820630C8h case    0:*/		return 0x820630CC;
		  /* 820630CCh */ case    1:  		/* li R12, 1 */
		/* 820630CCh case    1:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 820630CCh case    1:*/		return 0x820630D0;
		  /* 820630D0h */ case    2:  		/* stfs FR0, <#[R3 + 12328]> */
		/* 820630D0h case    2:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R3 + 0x00003028) );
		/* 820630D0h case    2:*/		return 0x820630D4;
		  /* 820630D4h */ case    3:  		/* lfs FR13, <#[R11 + 2976]> */
		/* 820630D4h case    3:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000BA0) );
		/* 820630D4h case    3:*/		return 0x820630D8;
		  /* 820630D8h */ case    4:  		/* rldicr R12, R12, 53, 63 */
		/* 820630D8h case    4:*/		cpu::op::rldicr<0,53,63>(regs,&regs.R12,regs.R12);
		/* 820630D8h case    4:*/		return 0x820630DC;
		  /* 820630DCh */ case    5:  		/* fmuls FR0, FR0, FR13 */
		/* 820630DCh case    5:*/		cpu::op::fmuls<0>(regs,&regs.FR0,regs.FR0,regs.FR13);
		/* 820630DCh case    5:*/		return 0x820630E0;
	}
	return 0x820630E0;
} // Block from 820630C8h-820630E0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820630E0h
// Function 'D3DDevice_GetRenderState_CCWStencilMask'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820630E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820630E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820630E0);
		  /* 820630E0h */ case    0:  		/* fctiwz FR0, FR0 */
		/* 820630E0h case    0:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR0);
		/* 820630E0h case    0:*/		return 0x820630E4;
		  /* 820630E4h */ case    1:  		/* stfd FR0, <#[R1 - 16]> */
		/* 820630E4h case    1:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820630E4h case    1:*/		return 0x820630E8;
	}
	return 0x820630E8;
} // Block from 820630E0h-820630E8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820630E8h
// Function 'D3DDevice_SetRenderState_CCWStencilWriteMask'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820630E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820630E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820630E8);
		  /* 820630E8h */ case    0:  		/* lwz R11, <#[R1 - 12]> */
		/* 820630E8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0xFFFFFFF4) );
		/* 820630E8h case    0:*/		return 0x820630EC;
		  /* 820630ECh */ case    1:  		/* sth R11, <#[R3 + 10602]> */
		/* 820630ECh case    1:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R3 + 0x0000296A) );
		/* 820630ECh case    1:*/		return 0x820630F0;
		  /* 820630F0h */ case    2:  		/* ld R11, <#[R3 + 24]> */
		/* 820630F0h case    2:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820630F0h case    2:*/		return 0x820630F4;
		  /* 820630F4h */ case    3:  		/* or R11, R11, R12 */
		/* 820630F4h case    3:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 820630F4h case    3:*/		return 0x820630F8;
		  /* 820630F8h */ case    4:  		/* std R11, <#[R3 + 24]> */
		/* 820630F8h case    4:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820630F8h case    4:*/		return 0x820630FC;
		  /* 820630FCh */ case    5:  		/* bclr 20, CR0_LT */
		/* 820630FCh case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820630FCh case    5:*/		return 0x82063100;
	}
	return 0x82063100;
} // Block from 820630E8h-82063100h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82063100h
// Function 'D3DDevice_GetRenderState_CCWStencilWriteMask'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063100( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063100) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063100);
		  /* 82063100h */ case    0:  		/* lfs FR0, <#[R3 + 12328]> */
		/* 82063100h case    0:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R3 + 0x00003028) );
		/* 82063100h case    0:*/		return 0x82063104;
		  /* 82063104h */ case    1:  		/* stfs FR0, <#[R1 - 16]> */
		/* 82063104h case    1:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82063104h case    1:*/		return 0x82063108;
	}
	return 0x82063108;
} // Block from 82063100h-82063108h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063108h
// Function 'D3DDevice_SetRenderState_ClipPlaneEnable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063108( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063108) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063108);
		  /* 82063108h */ case    0:  		/* lwz R3, <#[R1 - 16]> */
		/* 82063108h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82063108h case    0:*/		return 0x8206310C;
		  /* 8206310Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 8206310Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206310Ch case    1:*/		return 0x82063110;
	}
	return 0x82063110;
} // Block from 82063108h-82063110h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063110h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063110( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063110) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063110);
		  /* 82063110h */ case    0:  		/* lis R11, -32256 */
		/* 82063110h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82063110h case    0:*/		return 0x82063114;
		  /* 82063114h */ case    1:  		/* stw R4, <#[R1 + 28]> */
		/* 82063114h case    1:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000001C) );
		/* 82063114h case    1:*/		return 0x82063118;
		  /* 82063118h */ case    2:  		/* lfs FR0, <#[R1 + 28]> */
		/* 82063118h case    2:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x0000001C) );
		/* 82063118h case    2:*/		return 0x8206311C;
		  /* 8206311Ch */ case    3:  		/* li R12, 1 */
		/* 8206311Ch case    3:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 8206311Ch case    3:*/		return 0x82063120;
		  /* 82063120h */ case    4:  		/* stfs FR0, <#[R3 + 12332]> */
		/* 82063120h case    4:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R3 + 0x0000302C) );
		/* 82063120h case    4:*/		return 0x82063124;
		  /* 82063124h */ case    5:  		/* lfs FR13, <#[R11 + 2976]> */
		/* 82063124h case    5:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000BA0) );
		/* 82063124h case    5:*/		return 0x82063128;
		  /* 82063128h */ case    6:  		/* rldicr R12, R12, 53, 63 */
		/* 82063128h case    6:*/		cpu::op::rldicr<0,53,63>(regs,&regs.R12,regs.R12);
		/* 82063128h case    6:*/		return 0x8206312C;
		  /* 8206312Ch */ case    7:  		/* fmuls FR0, FR0, FR13 */
		/* 8206312Ch case    7:*/		cpu::op::fmuls<0>(regs,&regs.FR0,regs.FR0,regs.FR13);
		/* 8206312Ch case    7:*/		return 0x82063130;
		  /* 82063130h */ case    8:  		/* fctiwz FR0, FR0 */
		/* 82063130h case    8:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR0);
		/* 82063130h case    8:*/		return 0x82063134;
		  /* 82063134h */ case    9:  		/* stfd FR0, <#[R1 - 16]> */
		/* 82063134h case    9:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82063134h case    9:*/		return 0x82063138;
		  /* 82063138h */ case   10:  		/* lwz R11, <#[R1 - 12]> */
		/* 82063138h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0xFFFFFFF4) );
		/* 82063138h case   10:*/		return 0x8206313C;
		  /* 8206313Ch */ case   11:  		/* sth R11, <#[R3 + 10600]> */
		/* 8206313Ch case   11:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R3 + 0x00002968) );
		/* 8206313Ch case   11:*/		return 0x82063140;
		  /* 82063140h */ case   12:  		/* ld R11, <#[R3 + 24]> */
		/* 82063140h case   12:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82063140h case   12:*/		return 0x82063144;
		  /* 82063144h */ case   13:  		/* or R11, R11, R12 */
		/* 82063144h case   13:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 82063144h case   13:*/		return 0x82063148;
		  /* 82063148h */ case   14:  		/* std R11, <#[R3 + 24]> */
		/* 82063148h case   14:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82063148h case   14:*/		return 0x8206314C;
		  /* 8206314Ch */ case   15:  		/* bclr 20, CR0_LT */
		/* 8206314Ch case   15:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206314Ch case   15:*/		return 0x82063150;
	}
	return 0x82063150;
} // Block from 82063110h-82063150h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82063150h
// Function 'D3DDevice_GetRenderState_ClipPlaneEnable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063150( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063150) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063150);
		  /* 82063150h */ case    0:  		/* lfs FR0, <#[R3 + 12332]> */
		/* 82063150h case    0:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R3 + 0x0000302C) );
		/* 82063150h case    0:*/		return 0x82063154;
		  /* 82063154h */ case    1:  		/* stfs FR0, <#[R1 - 16]> */
		/* 82063154h case    1:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82063154h case    1:*/		return 0x82063158;
		  /* 82063158h */ case    2:  		/* lwz R3, <#[R1 - 16]> */
		/* 82063158h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82063158h case    2:*/		return 0x8206315C;
		  /* 8206315Ch */ case    3:  		/* bclr 20, CR0_LT */
		/* 8206315Ch case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206315Ch case    3:*/		return 0x82063160;
	}
	return 0x82063160;
} // Block from 82063150h-82063160h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82063160h
// Function 'D3DDevice_SetRenderState_ScissorTestEnable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063160( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063160) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063160);
		  /* 82063160h */ case    0:  		/* lwz R11, <#[R3 + 10540]> */
		/* 82063160h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000292C) );
		/* 82063160h case    0:*/		return 0x82063164;
		  /* 82063164h */ case    1:  		/* rlwinm R11, R11, 0, 0, 27 */
		/* 82063164h case    1:*/		cpu::op::rlwinm<0,0,0,27>(regs,&regs.R11,regs.R11);
		/* 82063164h case    1:*/		return 0x82063168;
		  /* 82063168h */ case    2:  		/* or R11, R11, R4 */
		/* 82063168h case    2:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R4);
		/* 82063168h case    2:*/		return 0x8206316C;
		  /* 8206316Ch */ case    3:  		/* stw R11, <#[R3 + 10540]> */
		/* 8206316Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000292C) );
		/* 8206316Ch case    3:*/		return 0x82063170;
	}
	return 0x82063170;
} // Block from 82063160h-82063170h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82063170h
// Function 'D3DDevice_GetRenderState_ScissorTestEnable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063170( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063170) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063170);
		  /* 82063170h */ case    0:  		/* ld R11, <#[R3 + 16]> */
		/* 82063170h case    0:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82063170h case    0:*/		return 0x82063174;
		  /* 82063174h */ case    1:  		/* ori R11, R11, 8192 */
		/* 82063174h case    1:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2000);
		/* 82063174h case    1:*/		return 0x82063178;
	}
	return 0x82063178;
} // Block from 82063170h-82063178h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063178h
// Function 'D3DDevice_SetRenderState_SlopeScaleDepthBias'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063178( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063178) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063178);
		  /* 82063178h */ case    0:  		/* std R11, <#[R3 + 16]> */
		/* 82063178h case    0:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82063178h case    0:*/		return 0x8206317C;
		  /* 8206317Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 8206317Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206317Ch case    1:*/		return 0x82063180;
	}
	return 0x82063180;
} // Block from 82063178h-82063180h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063180h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063180( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063180) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063180);
		  /* 82063180h */ case    0:  		/* lwz R11, <#[R3 + 10540]> */
		/* 82063180h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000292C) );
		/* 82063180h case    0:*/		return 0x82063184;
		  /* 82063184h */ case    1:  		/* rlwinm R10, R4, 4, 0, 27 */
		/* 82063184h case    1:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R10,regs.R4);
		/* 82063184h case    1:*/		return 0x82063188;
		  /* 82063188h */ case    2:  		/* rlwinm R11, R11, 0, 28, 23 */
		/* 82063188h case    2:*/		cpu::op::rlwinm<0,0,28,23>(regs,&regs.R11,regs.R11);
		/* 82063188h case    2:*/		return 0x8206318C;
		  /* 8206318Ch */ case    3:  		/* or R11, R11, R10 */
		/* 8206318Ch case    3:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8206318Ch case    3:*/		return 0x82063190;
		  /* 82063190h */ case    4:  		/* stw R11, <#[R3 + 10540]> */
		/* 82063190h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000292C) );
		/* 82063190h case    4:*/		return 0x82063194;
		  /* 82063194h */ case    5:  		/* ld R11, <#[R3 + 16]> */
		/* 82063194h case    5:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82063194h case    5:*/		return 0x82063198;
		  /* 82063198h */ case    6:  		/* ori R11, R11, 8192 */
		/* 82063198h case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2000);
		/* 82063198h case    6:*/		return 0x8206319C;
		  /* 8206319Ch */ case    7:  		/* std R11, <#[R3 + 16]> */
		/* 8206319Ch case    7:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8206319Ch case    7:*/		return 0x820631A0;
		  /* 820631A0h */ case    8:  		/* bclr 20, CR0_LT */
		/* 820631A0h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820631A0h case    8:*/		return 0x820631A4;
	}
	return 0x820631A4;
} // Block from 82063180h-820631A4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820631A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820631A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820631A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820631A4);
		  /* 820631A4h */ case    0:  		/* nop */
		/* 820631A4h case    0:*/		cpu::op::nop();
		/* 820631A4h case    0:*/		return 0x820631A8;
	}
	return 0x820631A8;
} // Block from 820631A4h-820631A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820631A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820631A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820631A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820631A8);
		  /* 820631A8h */ case    0:  		/* lwz R11, <#[R3 + 10540]> */
		/* 820631A8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000292C) );
		/* 820631A8h case    0:*/		return 0x820631AC;
		  /* 820631ACh */ case    1:  		/* rlwinm R10, R4, 8, 0, 23 */
		/* 820631ACh case    1:*/		cpu::op::rlwinm<0,8,0,23>(regs,&regs.R10,regs.R4);
		/* 820631ACh case    1:*/		return 0x820631B0;
		  /* 820631B0h */ case    2:  		/* rlwinm R11, R11, 0, 24, 19 */
		/* 820631B0h case    2:*/		cpu::op::rlwinm<0,0,24,19>(regs,&regs.R11,regs.R11);
		/* 820631B0h case    2:*/		return 0x820631B4;
		  /* 820631B4h */ case    3:  		/* or R11, R11, R10 */
		/* 820631B4h case    3:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820631B4h case    3:*/		return 0x820631B8;
		  /* 820631B8h */ case    4:  		/* stw R11, <#[R3 + 10540]> */
		/* 820631B8h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000292C) );
		/* 820631B8h case    4:*/		return 0x820631BC;
		  /* 820631BCh */ case    5:  		/* ld R11, <#[R3 + 16]> */
		/* 820631BCh case    5:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820631BCh case    5:*/		return 0x820631C0;
		  /* 820631C0h */ case    6:  		/* ori R11, R11, 8192 */
		/* 820631C0h case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2000);
		/* 820631C0h case    6:*/		return 0x820631C4;
		  /* 820631C4h */ case    7:  		/* std R11, <#[R3 + 16]> */
		/* 820631C4h case    7:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820631C4h case    7:*/		return 0x820631C8;
		  /* 820631C8h */ case    8:  		/* bclr 20, CR0_LT */
		/* 820631C8h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820631C8h case    8:*/		return 0x820631CC;
	}
	return 0x820631CC;
} // Block from 820631A8h-820631CCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 820631CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820631CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820631CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820631CC);
		  /* 820631CCh */ case    0:  		/* nop */
		/* 820631CCh case    0:*/		cpu::op::nop();
		/* 820631CCh case    0:*/		return 0x820631D0;
	}
	return 0x820631D0;
} // Block from 820631CCh-820631D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820631D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820631D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820631D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820631D0);
		  /* 820631D0h */ case    0:  		/* lwz R11, <#[R3 + 10540]> */
		/* 820631D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000292C) );
		/* 820631D0h case    0:*/		return 0x820631D4;
		  /* 820631D4h */ case    1:  		/* rlwinm R10, R4, 12, 0, 19 */
		/* 820631D4h case    1:*/		cpu::op::rlwinm<0,12,0,19>(regs,&regs.R10,regs.R4);
		/* 820631D4h case    1:*/		return 0x820631D8;
		  /* 820631D8h */ case    2:  		/* rlwinm R11, R11, 0, 20, 15 */
		/* 820631D8h case    2:*/		cpu::op::rlwinm<0,0,20,15>(regs,&regs.R11,regs.R11);
		/* 820631D8h case    2:*/		return 0x820631DC;
		  /* 820631DCh */ case    3:  		/* or R11, R11, R10 */
		/* 820631DCh case    3:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820631DCh case    3:*/		return 0x820631E0;
		  /* 820631E0h */ case    4:  		/* stw R11, <#[R3 + 10540]> */
		/* 820631E0h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000292C) );
		/* 820631E0h case    4:*/		return 0x820631E4;
		  /* 820631E4h */ case    5:  		/* ld R11, <#[R3 + 16]> */
		/* 820631E4h case    5:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820631E4h case    5:*/		return 0x820631E8;
		  /* 820631E8h */ case    6:  		/* ori R11, R11, 8192 */
		/* 820631E8h case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2000);
		/* 820631E8h case    6:*/		return 0x820631EC;
		  /* 820631ECh */ case    7:  		/* std R11, <#[R3 + 16]> */
		/* 820631ECh case    7:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820631ECh case    7:*/		return 0x820631F0;
		  /* 820631F0h */ case    8:  		/* bclr 20, CR0_LT */
		/* 820631F0h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820631F0h case    8:*/		return 0x820631F4;
	}
	return 0x820631F4;
} // Block from 820631D0h-820631F4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820631F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820631F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820631F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820631F4);
		  /* 820631F4h */ case    0:  		/* nop */
		/* 820631F4h case    0:*/		cpu::op::nop();
		/* 820631F4h case    0:*/		return 0x820631F8;
	}
	return 0x820631F8;
} // Block from 820631F4h-820631F8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820631F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820631F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820631F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820631F8);
		  /* 820631F8h */ case    0:  		/* lwz R11, <#[R3 + 10540]> */
		/* 820631F8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000292C) );
		/* 820631F8h case    0:*/		return 0x820631FC;
		  /* 820631FCh */ case    1:  		/* rlwinm R10, R4, 16, 0, 15 */
		/* 820631FCh case    1:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R10,regs.R4);
		/* 820631FCh case    1:*/		return 0x82063200;
		  /* 82063200h */ case    2:  		/* rlwinm R11, R11, 0, 16, 11 */
		/* 82063200h case    2:*/		cpu::op::rlwinm<0,0,16,11>(regs,&regs.R11,regs.R11);
		/* 82063200h case    2:*/		return 0x82063204;
		  /* 82063204h */ case    3:  		/* or R11, R11, R10 */
		/* 82063204h case    3:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82063204h case    3:*/		return 0x82063208;
		  /* 82063208h */ case    4:  		/* stw R11, <#[R3 + 10540]> */
		/* 82063208h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000292C) );
		/* 82063208h case    4:*/		return 0x8206320C;
		  /* 8206320Ch */ case    5:  		/* ld R11, <#[R3 + 16]> */
		/* 8206320Ch case    5:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8206320Ch case    5:*/		return 0x82063210;
		  /* 82063210h */ case    6:  		/* ori R11, R11, 8192 */
		/* 82063210h case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2000);
		/* 82063210h case    6:*/		return 0x82063214;
		  /* 82063214h */ case    7:  		/* std R11, <#[R3 + 16]> */
		/* 82063214h case    7:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82063214h case    7:*/		return 0x82063218;
		  /* 82063218h */ case    8:  		/* bclr 20, CR0_LT */
		/* 82063218h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063218h case    8:*/		return 0x8206321C;
	}
	return 0x8206321C;
} // Block from 820631F8h-8206321Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8206321Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206321C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206321C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206321C);
		  /* 8206321Ch */ case    0:  		/* nop */
		/* 8206321Ch case    0:*/		cpu::op::nop();
		/* 8206321Ch case    0:*/		return 0x82063220;
	}
	return 0x82063220;
} // Block from 8206321Ch-82063220h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063220h
// Function 'D3DDevice_GetRenderState_SlopeScaleDepthBias'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063220( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063220) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063220);
		  /* 82063220h */ case    0:  		/* lwz R11, <#[R3 + 10540]> */
		/* 82063220h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000292C) );
		/* 82063220h case    0:*/		return 0x82063224;
		  /* 82063224h */ case    1:  		/* rlwinm R10, R4, 20, 0, 11 */
		/* 82063224h case    1:*/		cpu::op::rlwinm<0,20,0,11>(regs,&regs.R10,regs.R4);
		/* 82063224h case    1:*/		return 0x82063228;
		  /* 82063228h */ case    2:  		/* rlwinm R11, R11, 0, 12, 7 */
		/* 82063228h case    2:*/		cpu::op::rlwinm<0,0,12,7>(regs,&regs.R11,regs.R11);
		/* 82063228h case    2:*/		return 0x8206322C;
		  /* 8206322Ch */ case    3:  		/* or R11, R11, R10 */
		/* 8206322Ch case    3:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8206322Ch case    3:*/		return 0x82063230;
		  /* 82063230h */ case    4:  		/* stw R11, <#[R3 + 10540]> */
		/* 82063230h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000292C) );
		/* 82063230h case    4:*/		return 0x82063234;
		  /* 82063234h */ case    5:  		/* ld R11, <#[R3 + 16]> */
		/* 82063234h case    5:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82063234h case    5:*/		return 0x82063238;
		  /* 82063238h */ case    6:  		/* ori R11, R11, 8192 */
		/* 82063238h case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2000);
		/* 82063238h case    6:*/		return 0x8206323C;
		  /* 8206323Ch */ case    7:  		/* std R11, <#[R3 + 16]> */
		/* 8206323Ch case    7:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8206323Ch case    7:*/		return 0x82063240;
	}
	return 0x82063240;
} // Block from 82063220h-82063240h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82063240h
// Function 'D3DDevice_SetRenderState_DepthBias'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063240( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063240) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063240);
		  /* 82063240h */ case    0:  		/* bclr 20, CR0_LT */
		/* 82063240h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063240h case    0:*/		return 0x82063244;
	}
	return 0x82063244;
} // Block from 82063240h-82063244h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063244h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063244( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063244) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063244);
		  /* 82063244h */ case    0:  		/* nop */
		/* 82063244h case    0:*/		cpu::op::nop();
		/* 82063244h case    0:*/		return 0x82063248;
	}
	return 0x82063248;
} // Block from 82063244h-82063248h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063248h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063248( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063248) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063248);
		  /* 82063248h */ case    0:  		/* lwz R11, <#[R3 + 10540]> */
		/* 82063248h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000292C) );
		/* 82063248h case    0:*/		return 0x8206324C;
		  /* 8206324Ch */ case    1:  		/* rlwinm R10, R4, 24, 0, 7 */
		/* 8206324Ch case    1:*/		cpu::op::rlwinm<0,24,0,7>(regs,&regs.R10,regs.R4);
		/* 8206324Ch case    1:*/		return 0x82063250;
		  /* 82063250h */ case    2:  		/* rlwinm R11, R11, 0, 8, 3 */
		/* 82063250h case    2:*/		cpu::op::rlwinm<0,0,8,3>(regs,&regs.R11,regs.R11);
		/* 82063250h case    2:*/		return 0x82063254;
		  /* 82063254h */ case    3:  		/* or R11, R11, R10 */
		/* 82063254h case    3:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82063254h case    3:*/		return 0x82063258;
		  /* 82063258h */ case    4:  		/* stw R11, <#[R3 + 10540]> */
		/* 82063258h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000292C) );
		/* 82063258h case    4:*/		return 0x8206325C;
		  /* 8206325Ch */ case    5:  		/* ld R11, <#[R3 + 16]> */
		/* 8206325Ch case    5:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8206325Ch case    5:*/		return 0x82063260;
		  /* 82063260h */ case    6:  		/* ori R11, R11, 8192 */
		/* 82063260h case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2000);
		/* 82063260h case    6:*/		return 0x82063264;
		  /* 82063264h */ case    7:  		/* std R11, <#[R3 + 16]> */
		/* 82063264h case    7:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82063264h case    7:*/		return 0x82063268;
		  /* 82063268h */ case    8:  		/* bclr 20, CR0_LT */
		/* 82063268h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063268h case    8:*/		return 0x8206326C;
	}
	return 0x8206326C;
} // Block from 82063248h-8206326Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8206326Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206326C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206326C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206326C);
		  /* 8206326Ch */ case    0:  		/* nop */
		/* 8206326Ch case    0:*/		cpu::op::nop();
		/* 8206326Ch case    0:*/		return 0x82063270;
	}
	return 0x82063270;
} // Block from 8206326Ch-82063270h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063270h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063270( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063270) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063270);
		  /* 82063270h */ case    0:  		/* lwz R11, <#[R3 + 10540]> */
		/* 82063270h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000292C) );
		/* 82063270h case    0:*/		return 0x82063274;
		  /* 82063274h */ case    1:  		/* rlwimi R11, R4, 28, 0, 3 */
		/* 82063274h case    1:*/		cpu::op::rlwimi<0,28,0,3>(regs,&regs.R11,regs.R4);
		/* 82063274h case    1:*/		return 0x82063278;
		  /* 82063278h */ case    2:  		/* stw R11, <#[R3 + 10540]> */
		/* 82063278h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000292C) );
		/* 82063278h case    2:*/		return 0x8206327C;
		  /* 8206327Ch */ case    3:  		/* ld R11, <#[R3 + 16]> */
		/* 8206327Ch case    3:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8206327Ch case    3:*/		return 0x82063280;
		  /* 82063280h */ case    4:  		/* ori R11, R11, 8192 */
		/* 82063280h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2000);
		/* 82063280h case    4:*/		return 0x82063284;
		  /* 82063284h */ case    5:  		/* std R11, <#[R3 + 16]> */
		/* 82063284h case    5:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82063284h case    5:*/		return 0x82063288;
		  /* 82063288h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82063288h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063288h case    6:*/		return 0x8206328C;
	}
	return 0x8206328C;
} // Block from 82063270h-8206328Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8206328Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206328C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206328C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206328C);
		  /* 8206328Ch */ case    0:  		/* nop */
		/* 8206328Ch case    0:*/		cpu::op::nop();
		/* 8206328Ch case    0:*/		return 0x82063290;
	}
	return 0x82063290;
} // Block from 8206328Ch-82063290h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063290h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063290( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063290) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063290);
		  /* 82063290h */ case    0:  		/* lwz R11, <#[R3 + 10544]> */
		/* 82063290h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002930) );
		/* 82063290h case    0:*/		return 0x82063294;
		  /* 82063294h */ case    1:  		/* rlwinm R11, R11, 0, 0, 27 */
		/* 82063294h case    1:*/		cpu::op::rlwinm<0,0,0,27>(regs,&regs.R11,regs.R11);
		/* 82063294h case    1:*/		return 0x82063298;
		  /* 82063298h */ case    2:  		/* or R11, R11, R4 */
		/* 82063298h case    2:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R4);
		/* 82063298h case    2:*/		return 0x8206329C;
		  /* 8206329Ch */ case    3:  		/* stw R11, <#[R3 + 10544]> */
		/* 8206329Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002930) );
		/* 8206329Ch case    3:*/		return 0x820632A0;
		  /* 820632A0h */ case    4:  		/* ld R11, <#[R3 + 16]> */
		/* 820632A0h case    4:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820632A0h case    4:*/		return 0x820632A4;
		  /* 820632A4h */ case    5:  		/* ori R11, R11, 4096 */
		/* 820632A4h case    5:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1000);
		/* 820632A4h case    5:*/		return 0x820632A8;
		  /* 820632A8h */ case    6:  		/* std R11, <#[R3 + 16]> */
		/* 820632A8h case    6:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820632A8h case    6:*/		return 0x820632AC;
		  /* 820632ACh */ case    7:  		/* bclr 20, CR0_LT */
		/* 820632ACh case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820632ACh case    7:*/		return 0x820632B0;
	}
	return 0x820632B0;
} // Block from 82063290h-820632B0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820632B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820632B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820632B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820632B0);
		  /* 820632B0h */ case    0:  		/* lwz R11, <#[R3 + 10544]> */
		/* 820632B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002930) );
		/* 820632B0h case    0:*/		return 0x820632B4;
		  /* 820632B4h */ case    1:  		/* rlwinm R10, R4, 4, 0, 27 */
		/* 820632B4h case    1:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R10,regs.R4);
		/* 820632B4h case    1:*/		return 0x820632B8;
		  /* 820632B8h */ case    2:  		/* rlwinm R11, R11, 0, 28, 23 */
		/* 820632B8h case    2:*/		cpu::op::rlwinm<0,0,28,23>(regs,&regs.R11,regs.R11);
		/* 820632B8h case    2:*/		return 0x820632BC;
		  /* 820632BCh */ case    3:  		/* or R11, R11, R10 */
		/* 820632BCh case    3:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820632BCh case    3:*/		return 0x820632C0;
		  /* 820632C0h */ case    4:  		/* stw R11, <#[R3 + 10544]> */
		/* 820632C0h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002930) );
		/* 820632C0h case    4:*/		return 0x820632C4;
		  /* 820632C4h */ case    5:  		/* ld R11, <#[R3 + 16]> */
		/* 820632C4h case    5:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820632C4h case    5:*/		return 0x820632C8;
		  /* 820632C8h */ case    6:  		/* ori R11, R11, 4096 */
		/* 820632C8h case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1000);
		/* 820632C8h case    6:*/		return 0x820632CC;
		  /* 820632CCh */ case    7:  		/* std R11, <#[R3 + 16]> */
		/* 820632CCh case    7:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820632CCh case    7:*/		return 0x820632D0;
		  /* 820632D0h */ case    8:  		/* bclr 20, CR0_LT */
		/* 820632D0h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820632D0h case    8:*/		return 0x820632D4;
	}
	return 0x820632D4;
} // Block from 820632B0h-820632D4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820632D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820632D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820632D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820632D4);
		  /* 820632D4h */ case    0:  		/* nop */
		/* 820632D4h case    0:*/		cpu::op::nop();
		/* 820632D4h case    0:*/		return 0x820632D8;
	}
	return 0x820632D8;
} // Block from 820632D4h-820632D8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820632D8h
// Function 'D3DDevice_GetRenderState_DepthBias'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820632D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820632D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820632D8);
		  /* 820632D8h */ case    0:  		/* lwz R11, <#[R3 + 10544]> */
		/* 820632D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002930) );
		/* 820632D8h case    0:*/		return 0x820632DC;
		  /* 820632DCh */ case    1:  		/* rlwinm R10, R4, 8, 0, 23 */
		/* 820632DCh case    1:*/		cpu::op::rlwinm<0,8,0,23>(regs,&regs.R10,regs.R4);
		/* 820632DCh case    1:*/		return 0x820632E0;
		  /* 820632E0h */ case    2:  		/* rlwinm R11, R11, 0, 24, 19 */
		/* 820632E0h case    2:*/		cpu::op::rlwinm<0,0,24,19>(regs,&regs.R11,regs.R11);
		/* 820632E0h case    2:*/		return 0x820632E4;
		  /* 820632E4h */ case    3:  		/* or R11, R11, R10 */
		/* 820632E4h case    3:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820632E4h case    3:*/		return 0x820632E8;
	}
	return 0x820632E8;
} // Block from 820632D8h-820632E8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820632E8h
// Function 'D3DDevice_SetRenderState_MultiSampleAntiAlias'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820632E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820632E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820632E8);
		  /* 820632E8h */ case    0:  		/* stw R11, <#[R3 + 10544]> */
		/* 820632E8h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002930) );
		/* 820632E8h case    0:*/		return 0x820632EC;
		  /* 820632ECh */ case    1:  		/* ld R11, <#[R3 + 16]> */
		/* 820632ECh case    1:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820632ECh case    1:*/		return 0x820632F0;
		  /* 820632F0h */ case    2:  		/* ori R11, R11, 4096 */
		/* 820632F0h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1000);
		/* 820632F0h case    2:*/		return 0x820632F4;
		  /* 820632F4h */ case    3:  		/* std R11, <#[R3 + 16]> */
		/* 820632F4h case    3:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820632F4h case    3:*/		return 0x820632F8;
		  /* 820632F8h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820632F8h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820632F8h case    4:*/		return 0x820632FC;
	}
	return 0x820632FC;
} // Block from 820632E8h-820632FCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820632FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820632FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820632FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820632FC);
		  /* 820632FCh */ case    0:  		/* nop */
		/* 820632FCh case    0:*/		cpu::op::nop();
		/* 820632FCh case    0:*/		return 0x82063300;
	}
	return 0x82063300;
} // Block from 820632FCh-82063300h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063300h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063300( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063300) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063300);
		  /* 82063300h */ case    0:  		/* lwz R11, <#[R3 + 10544]> */
		/* 82063300h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002930) );
		/* 82063300h case    0:*/		return 0x82063304;
		  /* 82063304h */ case    1:  		/* rlwinm R10, R4, 12, 0, 19 */
		/* 82063304h case    1:*/		cpu::op::rlwinm<0,12,0,19>(regs,&regs.R10,regs.R4);
		/* 82063304h case    1:*/		return 0x82063308;
	}
	return 0x82063308;
} // Block from 82063300h-82063308h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063308h
// Function 'D3DDevice_GetRenderState_MultiSampleAntiAlias'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063308( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063308) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063308);
		  /* 82063308h */ case    0:  		/* rlwinm R11, R11, 0, 20, 15 */
		/* 82063308h case    0:*/		cpu::op::rlwinm<0,0,20,15>(regs,&regs.R11,regs.R11);
		/* 82063308h case    0:*/		return 0x8206330C;
		  /* 8206330Ch */ case    1:  		/* or R11, R11, R10 */
		/* 8206330Ch case    1:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8206330Ch case    1:*/		return 0x82063310;
		  /* 82063310h */ case    2:  		/* stw R11, <#[R3 + 10544]> */
		/* 82063310h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002930) );
		/* 82063310h case    2:*/		return 0x82063314;
		  /* 82063314h */ case    3:  		/* ld R11, <#[R3 + 16]> */
		/* 82063314h case    3:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82063314h case    3:*/		return 0x82063318;
	}
	return 0x82063318;
} // Block from 82063308h-82063318h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82063318h
// Function 'D3DDevice_SetRenderState_MultiSampleMask'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063318( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063318) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063318);
		  /* 82063318h */ case    0:  		/* ori R11, R11, 4096 */
		/* 82063318h case    0:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1000);
		/* 82063318h case    0:*/		return 0x8206331C;
		  /* 8206331Ch */ case    1:  		/* std R11, <#[R3 + 16]> */
		/* 8206331Ch case    1:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8206331Ch case    1:*/		return 0x82063320;
		  /* 82063320h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82063320h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063320h case    2:*/		return 0x82063324;
	}
	return 0x82063324;
} // Block from 82063318h-82063324h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82063324h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063324( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063324) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063324);
		  /* 82063324h */ case    0:  		/* nop */
		/* 82063324h case    0:*/		cpu::op::nop();
		/* 82063324h case    0:*/		return 0x82063328;
	}
	return 0x82063328;
} // Block from 82063324h-82063328h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063328h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063328( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063328) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063328);
		  /* 82063328h */ case    0:  		/* lwz R11, <#[R3 + 10544]> */
		/* 82063328h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002930) );
		/* 82063328h case    0:*/		return 0x8206332C;
		  /* 8206332Ch */ case    1:  		/* rlwinm R10, R4, 16, 0, 15 */
		/* 8206332Ch case    1:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R10,regs.R4);
		/* 8206332Ch case    1:*/		return 0x82063330;
	}
	return 0x82063330;
} // Block from 82063328h-82063330h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063330h
// Function 'D3DDevice_GetRenderState_MultiSampleMask'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063330( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063330) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063330);
		  /* 82063330h */ case    0:  		/* rlwinm R11, R11, 0, 16, 11 */
		/* 82063330h case    0:*/		cpu::op::rlwinm<0,0,16,11>(regs,&regs.R11,regs.R11);
		/* 82063330h case    0:*/		return 0x82063334;
		  /* 82063334h */ case    1:  		/* or R11, R11, R10 */
		/* 82063334h case    1:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82063334h case    1:*/		return 0x82063338;
	}
	return 0x82063338;
} // Block from 82063330h-82063338h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063338h
// Function 'D3DDevice_SetRenderState_ColorWriteEnable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063338( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063338) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063338);
		  /* 82063338h */ case    0:  		/* stw R11, <#[R3 + 10544]> */
		/* 82063338h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002930) );
		/* 82063338h case    0:*/		return 0x8206333C;
		  /* 8206333Ch */ case    1:  		/* ld R11, <#[R3 + 16]> */
		/* 8206333Ch case    1:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8206333Ch case    1:*/		return 0x82063340;
		  /* 82063340h */ case    2:  		/* ori R11, R11, 4096 */
		/* 82063340h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1000);
		/* 82063340h case    2:*/		return 0x82063344;
		  /* 82063344h */ case    3:  		/* std R11, <#[R3 + 16]> */
		/* 82063344h case    3:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82063344h case    3:*/		return 0x82063348;
		  /* 82063348h */ case    4:  		/* bclr 20, CR0_LT */
		/* 82063348h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063348h case    4:*/		return 0x8206334C;
	}
	return 0x8206334C;
} // Block from 82063338h-8206334Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8206334Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206334C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206334C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206334C);
		  /* 8206334Ch */ case    0:  		/* nop */
		/* 8206334Ch case    0:*/		cpu::op::nop();
		/* 8206334Ch case    0:*/		return 0x82063350;
	}
	return 0x82063350;
} // Block from 8206334Ch-82063350h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063350h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063350( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063350) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063350);
		  /* 82063350h */ case    0:  		/* lwz R11, <#[R3 + 10544]> */
		/* 82063350h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002930) );
		/* 82063350h case    0:*/		return 0x82063354;
		  /* 82063354h */ case    1:  		/* rlwinm R10, R4, 20, 0, 11 */
		/* 82063354h case    1:*/		cpu::op::rlwinm<0,20,0,11>(regs,&regs.R10,regs.R4);
		/* 82063354h case    1:*/		return 0x82063358;
		  /* 82063358h */ case    2:  		/* rlwinm R11, R11, 0, 12, 7 */
		/* 82063358h case    2:*/		cpu::op::rlwinm<0,0,12,7>(regs,&regs.R11,regs.R11);
		/* 82063358h case    2:*/		return 0x8206335C;
		  /* 8206335Ch */ case    3:  		/* or R11, R11, R10 */
		/* 8206335Ch case    3:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8206335Ch case    3:*/		return 0x82063360;
		  /* 82063360h */ case    4:  		/* stw R11, <#[R3 + 10544]> */
		/* 82063360h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002930) );
		/* 82063360h case    4:*/		return 0x82063364;
		  /* 82063364h */ case    5:  		/* ld R11, <#[R3 + 16]> */
		/* 82063364h case    5:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82063364h case    5:*/		return 0x82063368;
		  /* 82063368h */ case    6:  		/* ori R11, R11, 4096 */
		/* 82063368h case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1000);
		/* 82063368h case    6:*/		return 0x8206336C;
		  /* 8206336Ch */ case    7:  		/* std R11, <#[R3 + 16]> */
		/* 8206336Ch case    7:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8206336Ch case    7:*/		return 0x82063370;
	}
	return 0x82063370;
} // Block from 82063350h-82063370h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82063370h
// Function 'D3DDevice_GetRenderState_ColorWriteEnable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063370( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063370) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063370);
		  /* 82063370h */ case    0:  		/* bclr 20, CR0_LT */
		/* 82063370h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063370h case    0:*/		return 0x82063374;
	}
	return 0x82063374;
} // Block from 82063370h-82063374h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063374h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063374( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063374) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063374);
		  /* 82063374h */ case    0:  		/* nop */
		/* 82063374h case    0:*/		cpu::op::nop();
		/* 82063374h case    0:*/		return 0x82063378;
	}
	return 0x82063378;
} // Block from 82063374h-82063378h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063378h
// Function 'D3DDevice_SetRenderState_ColorWriteEnable1'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063378( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063378) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063378);
		  /* 82063378h */ case    0:  		/* lwz R11, <#[R3 + 10544]> */
		/* 82063378h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002930) );
		/* 82063378h case    0:*/		return 0x8206337C;
		  /* 8206337Ch */ case    1:  		/* rlwinm R10, R4, 24, 0, 7 */
		/* 8206337Ch case    1:*/		cpu::op::rlwinm<0,24,0,7>(regs,&regs.R10,regs.R4);
		/* 8206337Ch case    1:*/		return 0x82063380;
		  /* 82063380h */ case    2:  		/* rlwinm R11, R11, 0, 8, 3 */
		/* 82063380h case    2:*/		cpu::op::rlwinm<0,0,8,3>(regs,&regs.R11,regs.R11);
		/* 82063380h case    2:*/		return 0x82063384;
		  /* 82063384h */ case    3:  		/* or R11, R11, R10 */
		/* 82063384h case    3:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82063384h case    3:*/		return 0x82063388;
		  /* 82063388h */ case    4:  		/* stw R11, <#[R3 + 10544]> */
		/* 82063388h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002930) );
		/* 82063388h case    4:*/		return 0x8206338C;
		  /* 8206338Ch */ case    5:  		/* ld R11, <#[R3 + 16]> */
		/* 8206338Ch case    5:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8206338Ch case    5:*/		return 0x82063390;
		  /* 82063390h */ case    6:  		/* ori R11, R11, 4096 */
		/* 82063390h case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1000);
		/* 82063390h case    6:*/		return 0x82063394;
		  /* 82063394h */ case    7:  		/* std R11, <#[R3 + 16]> */
		/* 82063394h case    7:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82063394h case    7:*/		return 0x82063398;
		  /* 82063398h */ case    8:  		/* bclr 20, CR0_LT */
		/* 82063398h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063398h case    8:*/		return 0x8206339C;
	}
	return 0x8206339C;
} // Block from 82063378h-8206339Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8206339Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206339C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206339C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206339C);
		  /* 8206339Ch */ case    0:  		/* nop */
		/* 8206339Ch case    0:*/		cpu::op::nop();
		/* 8206339Ch case    0:*/		return 0x820633A0;
	}
	return 0x820633A0;
} // Block from 8206339Ch-820633A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820633A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820633A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820633A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820633A0);
		  /* 820633A0h */ case    0:  		/* lwz R11, <#[R3 + 10544]> */
		/* 820633A0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002930) );
		/* 820633A0h case    0:*/		return 0x820633A4;
		  /* 820633A4h */ case    1:  		/* rlwimi R11, R4, 28, 0, 3 */
		/* 820633A4h case    1:*/		cpu::op::rlwimi<0,28,0,3>(regs,&regs.R11,regs.R4);
		/* 820633A4h case    1:*/		return 0x820633A8;
		  /* 820633A8h */ case    2:  		/* stw R11, <#[R3 + 10544]> */
		/* 820633A8h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002930) );
		/* 820633A8h case    2:*/		return 0x820633AC;
		  /* 820633ACh */ case    3:  		/* ld R11, <#[R3 + 16]> */
		/* 820633ACh case    3:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820633ACh case    3:*/		return 0x820633B0;
	}
	return 0x820633B0;
} // Block from 820633A0h-820633B0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820633B0h
// Function 'D3DDevice_GetRenderState_ColorWriteEnable1'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820633B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820633B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820633B0);
		  /* 820633B0h */ case    0:  		/* ori R11, R11, 4096 */
		/* 820633B0h case    0:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1000);
		/* 820633B0h case    0:*/		return 0x820633B4;
		  /* 820633B4h */ case    1:  		/* std R11, <#[R3 + 16]> */
		/* 820633B4h case    1:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820633B4h case    1:*/		return 0x820633B8;
	}
	return 0x820633B8;
} // Block from 820633B0h-820633B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820633B8h
// Function 'D3DDevice_SetRenderState_ColorWriteEnable2'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820633B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820633B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820633B8);
		  /* 820633B8h */ case    0:  		/* bclr 20, CR0_LT */
		/* 820633B8h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820633B8h case    0:*/		return 0x820633BC;
	}
	return 0x820633BC;
} // Block from 820633B8h-820633BCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820633BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820633BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820633BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820633BC);
		  /* 820633BCh */ case    0:  		/* nop */
		/* 820633BCh case    0:*/		cpu::op::nop();
		/* 820633BCh case    0:*/		return 0x820633C0;
	}
	return 0x820633C0;
} // Block from 820633BCh-820633C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820633C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820633C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820633C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820633C0);
		  /* 820633C0h */ case    0:  		/* lwz R11, <#[R3 + 10540]> */
		/* 820633C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000292C) );
		/* 820633C0h case    0:*/		return 0x820633C4;
		  /* 820633C4h */ case    1:  		/* rlwinm R3, R11, 0, 28, 31 */
		/* 820633C4h case    1:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R3,regs.R11);
		/* 820633C4h case    1:*/		return 0x820633C8;
		  /* 820633C8h */ case    2:  		/* bclr 20, CR0_LT */
		/* 820633C8h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820633C8h case    2:*/		return 0x820633CC;
	}
	return 0x820633CC;
} // Block from 820633C0h-820633CCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820633CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820633CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820633CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820633CC);
		  /* 820633CCh */ case    0:  		/* nop */
		/* 820633CCh case    0:*/		cpu::op::nop();
		/* 820633CCh case    0:*/		return 0x820633D0;
	}
	return 0x820633D0;
} // Block from 820633CCh-820633D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820633D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820633D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820633D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820633D0);
		  /* 820633D0h */ case    0:  		/* lwz R11, <#[R3 + 10540]> */
		/* 820633D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000292C) );
		/* 820633D0h case    0:*/		return 0x820633D4;
		  /* 820633D4h */ case    1:  		/* rlwinm R3, R11, 28, 28, 31 */
		/* 820633D4h case    1:*/		cpu::op::rlwinm<0,28,28,31>(regs,&regs.R3,regs.R11);
		/* 820633D4h case    1:*/		return 0x820633D8;
		  /* 820633D8h */ case    2:  		/* bclr 20, CR0_LT */
		/* 820633D8h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820633D8h case    2:*/		return 0x820633DC;
	}
	return 0x820633DC;
} // Block from 820633D0h-820633DCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820633DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820633DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820633DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820633DC);
		  /* 820633DCh */ case    0:  		/* nop */
		/* 820633DCh case    0:*/		cpu::op::nop();
		/* 820633DCh case    0:*/		return 0x820633E0;
	}
	return 0x820633E0;
} // Block from 820633DCh-820633E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820633E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820633E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820633E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820633E0);
		  /* 820633E0h */ case    0:  		/* lwz R11, <#[R3 + 10540]> */
		/* 820633E0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000292C) );
		/* 820633E0h case    0:*/		return 0x820633E4;
		  /* 820633E4h */ case    1:  		/* rlwinm R3, R11, 24, 28, 31 */
		/* 820633E4h case    1:*/		cpu::op::rlwinm<0,24,28,31>(regs,&regs.R3,regs.R11);
		/* 820633E4h case    1:*/		return 0x820633E8;
		  /* 820633E8h */ case    2:  		/* bclr 20, CR0_LT */
		/* 820633E8h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820633E8h case    2:*/		return 0x820633EC;
	}
	return 0x820633EC;
} // Block from 820633E0h-820633ECh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820633ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820633EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820633EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820633EC);
		  /* 820633ECh */ case    0:  		/* nop */
		/* 820633ECh case    0:*/		cpu::op::nop();
		/* 820633ECh case    0:*/		return 0x820633F0;
	}
	return 0x820633F0;
} // Block from 820633ECh-820633F0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820633F0h
// Function 'D3DDevice_GetRenderState_ColorWriteEnable2'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820633F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820633F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820633F0);
		  /* 820633F0h */ case    0:  		/* lwz R11, <#[R3 + 10540]> */
		/* 820633F0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000292C) );
		/* 820633F0h case    0:*/		return 0x820633F4;
		  /* 820633F4h */ case    1:  		/* rlwinm R3, R11, 20, 28, 31 */
		/* 820633F4h case    1:*/		cpu::op::rlwinm<0,20,28,31>(regs,&regs.R3,regs.R11);
		/* 820633F4h case    1:*/		return 0x820633F8;
	}
	return 0x820633F8;
} // Block from 820633F0h-820633F8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820633F8h
// Function 'D3DDevice_SetRenderState_ColorWriteEnable3'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820633F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820633F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820633F8);
		  /* 820633F8h */ case    0:  		/* bclr 20, CR0_LT */
		/* 820633F8h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820633F8h case    0:*/		return 0x820633FC;
	}
	return 0x820633FC;
} // Block from 820633F8h-820633FCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820633FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820633FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820633FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820633FC);
		  /* 820633FCh */ case    0:  		/* nop */
		/* 820633FCh case    0:*/		cpu::op::nop();
		/* 820633FCh case    0:*/		return 0x82063400;
	}
	return 0x82063400;
} // Block from 820633FCh-82063400h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063400h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063400( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063400) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063400);
		  /* 82063400h */ case    0:  		/* lhz R11, <#[R3 + 10540]> */
		/* 82063400h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000292C) );
		/* 82063400h case    0:*/		return 0x82063404;
		  /* 82063404h */ case    1:  		/* rlwinm R3, R11, 0, 28, 31 */
		/* 82063404h case    1:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R3,regs.R11);
		/* 82063404h case    1:*/		return 0x82063408;
		  /* 82063408h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82063408h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063408h case    2:*/		return 0x8206340C;
	}
	return 0x8206340C;
} // Block from 82063400h-8206340Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206340Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206340C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206340C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206340C);
		  /* 8206340Ch */ case    0:  		/* nop */
		/* 8206340Ch case    0:*/		cpu::op::nop();
		/* 8206340Ch case    0:*/		return 0x82063410;
	}
	return 0x82063410;
} // Block from 8206340Ch-82063410h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063410h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063410( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063410) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063410);
		  /* 82063410h */ case    0:  		/* lwz R11, <#[R3 + 10540]> */
		/* 82063410h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000292C) );
		/* 82063410h case    0:*/		return 0x82063414;
		  /* 82063414h */ case    1:  		/* rlwinm R3, R11, 12, 28, 31 */
		/* 82063414h case    1:*/		cpu::op::rlwinm<0,12,28,31>(regs,&regs.R3,regs.R11);
		/* 82063414h case    1:*/		return 0x82063418;
		  /* 82063418h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82063418h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063418h case    2:*/		return 0x8206341C;
	}
	return 0x8206341C;
} // Block from 82063410h-8206341Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206341Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206341C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206341C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206341C);
		  /* 8206341Ch */ case    0:  		/* nop */
		/* 8206341Ch case    0:*/		cpu::op::nop();
		/* 8206341Ch case    0:*/		return 0x82063420;
	}
	return 0x82063420;
} // Block from 8206341Ch-82063420h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063420h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063420( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063420) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063420);
		  /* 82063420h */ case    0:  		/* lbz R11, <#[R3 + 10540]> */
		/* 82063420h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000292C) );
		/* 82063420h case    0:*/		return 0x82063424;
		  /* 82063424h */ case    1:  		/* rlwinm R3, R11, 0, 28, 31 */
		/* 82063424h case    1:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R3,regs.R11);
		/* 82063424h case    1:*/		return 0x82063428;
		  /* 82063428h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82063428h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063428h case    2:*/		return 0x8206342C;
	}
	return 0x8206342C;
} // Block from 82063420h-8206342Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206342Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206342C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206342C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206342C);
		  /* 8206342Ch */ case    0:  		/* nop */
		/* 8206342Ch case    0:*/		cpu::op::nop();
		/* 8206342Ch case    0:*/		return 0x82063430;
	}
	return 0x82063430;
} // Block from 8206342Ch-82063430h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063430h
// Function 'D3DDevice_GetRenderState_ColorWriteEnable3'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063430( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063430) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063430);
		  /* 82063430h */ case    0:  		/* lwz R11, <#[R3 + 10540]> */
		/* 82063430h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000292C) );
		/* 82063430h case    0:*/		return 0x82063434;
		  /* 82063434h */ case    1:  		/* rlwinm R3, R11, 4, 28, 31 */
		/* 82063434h case    1:*/		cpu::op::rlwinm<0,4,28,31>(regs,&regs.R3,regs.R11);
		/* 82063434h case    1:*/		return 0x82063438;
	}
	return 0x82063438;
} // Block from 82063430h-82063438h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063438h
// Function 'D3DDevice_SetRenderState_PointSpriteEnable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063438( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063438) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063438);
		  /* 82063438h */ case    0:  		/* bclr 20, CR0_LT */
		/* 82063438h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063438h case    0:*/		return 0x8206343C;
	}
	return 0x8206343C;
} // Block from 82063438h-8206343Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206343Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206343C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206343C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206343C);
		  /* 8206343Ch */ case    0:  		/* nop */
		/* 8206343Ch case    0:*/		cpu::op::nop();
		/* 8206343Ch case    0:*/		return 0x82063440;
	}
	return 0x82063440;
} // Block from 8206343Ch-82063440h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063440h
// Function 'D3DDevice_GetRenderState_PointSpriteEnable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063440( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063440) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063440);
		  /* 82063440h */ case    0:  		/* lwz R11, <#[R3 + 10544]> */
		/* 82063440h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002930) );
		/* 82063440h case    0:*/		return 0x82063444;
		  /* 82063444h */ case    1:  		/* rlwinm R3, R11, 0, 28, 31 */
		/* 82063444h case    1:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R3,regs.R11);
		/* 82063444h case    1:*/		return 0x82063448;
	}
	return 0x82063448;
} // Block from 82063440h-82063448h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063448h
// Function 'D3DDevice_SetRenderState_PointSize'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063448( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063448) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063448);
		  /* 82063448h */ case    0:  		/* bclr 20, CR0_LT */
		/* 82063448h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063448h case    0:*/		return 0x8206344C;
	}
	return 0x8206344C;
} // Block from 82063448h-8206344Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206344Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206344C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206344C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206344C);
		  /* 8206344Ch */ case    0:  		/* nop */
		/* 8206344Ch case    0:*/		cpu::op::nop();
		/* 8206344Ch case    0:*/		return 0x82063450;
	}
	return 0x82063450;
} // Block from 8206344Ch-82063450h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063450h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063450( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063450) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063450);
		  /* 82063450h */ case    0:  		/* lwz R11, <#[R3 + 10544]> */
		/* 82063450h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002930) );
		/* 82063450h case    0:*/		return 0x82063454;
		  /* 82063454h */ case    1:  		/* rlwinm R3, R11, 28, 28, 31 */
		/* 82063454h case    1:*/		cpu::op::rlwinm<0,28,28,31>(regs,&regs.R3,regs.R11);
		/* 82063454h case    1:*/		return 0x82063458;
		  /* 82063458h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82063458h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063458h case    2:*/		return 0x8206345C;
	}
	return 0x8206345C;
} // Block from 82063450h-8206345Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206345Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206345C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206345C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206345C);
		  /* 8206345Ch */ case    0:  		/* nop */
		/* 8206345Ch case    0:*/		cpu::op::nop();
		/* 8206345Ch case    0:*/		return 0x82063460;
	}
	return 0x82063460;
} // Block from 8206345Ch-82063460h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063460h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063460( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063460) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063460);
		  /* 82063460h */ case    0:  		/* lwz R11, <#[R3 + 10544]> */
		/* 82063460h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002930) );
		/* 82063460h case    0:*/		return 0x82063464;
		  /* 82063464h */ case    1:  		/* rlwinm R3, R11, 24, 28, 31 */
		/* 82063464h case    1:*/		cpu::op::rlwinm<0,24,28,31>(regs,&regs.R3,regs.R11);
		/* 82063464h case    1:*/		return 0x82063468;
		  /* 82063468h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82063468h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063468h case    2:*/		return 0x8206346C;
	}
	return 0x8206346C;
} // Block from 82063460h-8206346Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206346Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206346C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206346C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206346C);
		  /* 8206346Ch */ case    0:  		/* nop */
		/* 8206346Ch case    0:*/		cpu::op::nop();
		/* 8206346Ch case    0:*/		return 0x82063470;
	}
	return 0x82063470;
} // Block from 8206346Ch-82063470h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063470h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063470( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063470) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063470);
		  /* 82063470h */ case    0:  		/* lwz R11, <#[R3 + 10544]> */
		/* 82063470h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002930) );
		/* 82063470h case    0:*/		return 0x82063474;
		  /* 82063474h */ case    1:  		/* rlwinm R3, R11, 20, 28, 31 */
		/* 82063474h case    1:*/		cpu::op::rlwinm<0,20,28,31>(regs,&regs.R3,regs.R11);
		/* 82063474h case    1:*/		return 0x82063478;
		  /* 82063478h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82063478h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063478h case    2:*/		return 0x8206347C;
	}
	return 0x8206347C;
} // Block from 82063470h-8206347Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206347Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206347C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206347C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206347C);
		  /* 8206347Ch */ case    0:  		/* nop */
		/* 8206347Ch case    0:*/		cpu::op::nop();
		/* 8206347Ch case    0:*/		return 0x82063480;
	}
	return 0x82063480;
} // Block from 8206347Ch-82063480h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063480h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063480( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063480) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063480);
		  /* 82063480h */ case    0:  		/* lhz R11, <#[R3 + 10544]> */
		/* 82063480h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002930) );
		/* 82063480h case    0:*/		return 0x82063484;
		  /* 82063484h */ case    1:  		/* rlwinm R3, R11, 0, 28, 31 */
		/* 82063484h case    1:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R3,regs.R11);
		/* 82063484h case    1:*/		return 0x82063488;
		  /* 82063488h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82063488h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063488h case    2:*/		return 0x8206348C;
	}
	return 0x8206348C;
} // Block from 82063480h-8206348Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206348Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206348C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206348C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206348C);
		  /* 8206348Ch */ case    0:  		/* nop */
		/* 8206348Ch case    0:*/		cpu::op::nop();
		/* 8206348Ch case    0:*/		return 0x82063490;
	}
	return 0x82063490;
} // Block from 8206348Ch-82063490h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063490h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063490( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063490) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063490);
		  /* 82063490h */ case    0:  		/* lwz R11, <#[R3 + 10544]> */
		/* 82063490h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002930) );
		/* 82063490h case    0:*/		return 0x82063494;
		  /* 82063494h */ case    1:  		/* rlwinm R3, R11, 12, 28, 31 */
		/* 82063494h case    1:*/		cpu::op::rlwinm<0,12,28,31>(regs,&regs.R3,regs.R11);
		/* 82063494h case    1:*/		return 0x82063498;
	}
	return 0x82063498;
} // Block from 82063490h-82063498h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063498h
// Function 'D3DDevice_GetRenderState_PointSize'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063498( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063498) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063498);
		  /* 82063498h */ case    0:  		/* bclr 20, CR0_LT */
		/* 82063498h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063498h case    0:*/		return 0x8206349C;
	}
	return 0x8206349C;
} // Block from 82063498h-8206349Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206349Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206349C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206349C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206349C);
		  /* 8206349Ch */ case    0:  		/* nop */
		/* 8206349Ch case    0:*/		cpu::op::nop();
		/* 8206349Ch case    0:*/		return 0x820634A0;
	}
	return 0x820634A0;
} // Block from 8206349Ch-820634A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820634A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820634A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820634A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820634A0);
		  /* 820634A0h */ case    0:  		/* lbz R11, <#[R3 + 10544]> */
		/* 820634A0h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002930) );
		/* 820634A0h case    0:*/		return 0x820634A4;
		  /* 820634A4h */ case    1:  		/* rlwinm R3, R11, 0, 28, 31 */
		/* 820634A4h case    1:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R3,regs.R11);
		/* 820634A4h case    1:*/		return 0x820634A8;
	}
	return 0x820634A8;
} // Block from 820634A0h-820634A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820634A8h
// Function 'D3DDevice_SetRenderState_PointSizeMin'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820634A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820634A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820634A8);
		  /* 820634A8h */ case    0:  		/* bclr 20, CR0_LT */
		/* 820634A8h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820634A8h case    0:*/		return 0x820634AC;
	}
	return 0x820634AC;
} // Block from 820634A8h-820634ACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820634ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820634AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820634AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820634AC);
		  /* 820634ACh */ case    0:  		/* nop */
		/* 820634ACh case    0:*/		cpu::op::nop();
		/* 820634ACh case    0:*/		return 0x820634B0;
	}
	return 0x820634B0;
} // Block from 820634ACh-820634B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820634B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820634B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820634B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820634B0);
		  /* 820634B0h */ case    0:  		/* lwz R11, <#[R3 + 10544]> */
		/* 820634B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002930) );
		/* 820634B0h case    0:*/		return 0x820634B4;
		  /* 820634B4h */ case    1:  		/* rlwinm R3, R11, 4, 28, 31 */
		/* 820634B4h case    1:*/		cpu::op::rlwinm<0,4,28,31>(regs,&regs.R3,regs.R11);
		/* 820634B4h case    1:*/		return 0x820634B8;
		  /* 820634B8h */ case    2:  		/* bclr 20, CR0_LT */
		/* 820634B8h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820634B8h case    2:*/		return 0x820634BC;
	}
	return 0x820634BC;
} // Block from 820634B0h-820634BCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820634BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820634BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820634BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820634BC);
		  /* 820634BCh */ case    0:  		/* nop */
		/* 820634BCh case    0:*/		cpu::op::nop();
		/* 820634BCh case    0:*/		return 0x820634C0;
	}
	return 0x820634C0;
} // Block from 820634BCh-820634C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820634C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820634C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820634C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820634C0);
		  /* 820634C0h */ case    0:  		/* cmplwi CR6, R4, 0 */
		/* 820634C0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820634C0h case    0:*/		return 0x820634C4;
		  /* 820634C4h */ case    1:  		/* li R11, 1087 */
		/* 820634C4h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x43F);
		/* 820634C4h case    1:*/		return 0x820634C8;
		  /* 820634C8h */ case    2:  		/* bc 4, CR6_EQ, 8 */
		/* 820634C8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820634D0;  }
		/* 820634C8h case    2:*/		return 0x820634CC;
		  /* 820634CCh */ case    3:  		/* li R11, 1024 */
		/* 820634CCh case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x400);
		/* 820634CCh case    3:*/		return 0x820634D0;
	}
	return 0x820634D0;
} // Block from 820634C0h-820634D0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820634D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820634D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820634D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820634D0);
		  /* 820634D0h */ case    0:  		/* stw R11, <#[R3 + 10572]> */
		/* 820634D0h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000294C) );
		/* 820634D0h case    0:*/		return 0x820634D4;
		  /* 820634D4h */ case    1:  		/* cntlzw R11, R4 */
		/* 820634D4h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R4);
		/* 820634D4h case    1:*/		return 0x820634D8;
		  /* 820634D8h */ case    2:  		/* lwz R10, <#[R3 + 10564]> */
		/* 820634D8h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00002944) );
		/* 820634D8h case    2:*/		return 0x820634DC;
		  /* 820634DCh */ case    3:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 820634DCh case    3:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 820634DCh case    3:*/		return 0x820634E0;
		  /* 820634E0h */ case    4:  		/* rlwimi R10, R11, 16, 15, 15 */
		/* 820634E0h case    4:*/		cpu::op::rlwimi<0,16,15,15>(regs,&regs.R10,regs.R11);
		/* 820634E0h case    4:*/		return 0x820634E4;
		  /* 820634E4h */ case    5:  		/* stw R10, <#[R3 + 10564]> */
		/* 820634E4h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00002944) );
		/* 820634E4h case    5:*/		return 0x820634E8;
		  /* 820634E8h */ case    6:  		/* ld R11, <#[R3 + 16]> */
		/* 820634E8h case    6:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820634E8h case    6:*/		return 0x820634EC;
		  /* 820634ECh */ case    7:  		/* ori R11, R11, 32 */
		/* 820634ECh case    7:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x20);
		/* 820634ECh case    7:*/		return 0x820634F0;
	}
	return 0x820634F0;
} // Block from 820634D0h-820634F0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820634F0h
// Function 'D3DDevice_GetRenderState_PointSizeMin'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820634F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820634F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820634F0);
		  /* 820634F0h */ case    0:  		/* std R11, <#[R3 + 16]> */
		/* 820634F0h case    0:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820634F0h case    0:*/		return 0x820634F4;
		  /* 820634F4h */ case    1:  		/* ori R11, R11, 128 */
		/* 820634F4h case    1:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x80);
		/* 820634F4h case    1:*/		return 0x820634F8;
		  /* 820634F8h */ case    2:  		/* std R11, <#[R3 + 16]> */
		/* 820634F8h case    2:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820634F8h case    2:*/		return 0x820634FC;
		  /* 820634FCh */ case    3:  		/* bclr 20, CR0_LT */
		/* 820634FCh case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820634FCh case    3:*/		return 0x82063500;
	}
	return 0x82063500;
} // Block from 820634F0h-82063500h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82063500h
// Function 'D3DDevice_SetRenderState_PointSizeMax'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063500( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063500) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063500);
		  /* 82063500h */ case    0:  		/* lwz R11, <#[R3 + 10572]> */
		/* 82063500h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000294C) );
		/* 82063500h case    0:*/		return 0x82063504;
		  /* 82063504h */ case    1:  		/* rlwinm R3, R11, 0, 31, 31 */
		/* 82063504h case    1:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R3,regs.R11);
		/* 82063504h case    1:*/		return 0x82063508;
		  /* 82063508h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82063508h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063508h case    2:*/		return 0x8206350C;
	}
	return 0x8206350C;
} // Block from 82063500h-8206350Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206350Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206350C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206350C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206350C);
		  /* 8206350Ch */ case    0:  		/* nop */
		/* 8206350Ch case    0:*/		cpu::op::nop();
		/* 8206350Ch case    0:*/		return 0x82063510;
	}
	return 0x82063510;
} // Block from 8206350Ch-82063510h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063510h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063510( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063510) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063510);
		  /* 82063510h */ case    0:  		/* lwz R11, <#[R3 + 12816]> */
		/* 82063510h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00003210) );
		/* 82063510h case    0:*/		return 0x82063514;
		  /* 82063514h */ case    1:  		/* stw R4, <#[R3 + 12408]> */
		/* 82063514h case    1:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00003078) );
		/* 82063514h case    1:*/		return 0x82063518;
		  /* 82063518h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82063518h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82063518h case    2:*/		return 0x8206351C;
		  /* 8206351Ch */ case    3:  		/* bclr 12, CR6_EQ */
		/* 8206351Ch case    3:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 8206351Ch case    3:*/		return 0x82063520;
	}
	return 0x82063520;
} // Block from 82063510h-82063520h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82063520h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063520( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063520) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063520);
		  /* 82063520h */ case    0:  		/* lwz R8, <#[R3 + 10372]> */
		/* 82063520h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00002884) );
		/* 82063520h case    0:*/		return 0x82063524;
		  /* 82063524h */ case    1:  		/* rlwinm R11, R8, 16, 28, 31 */
		/* 82063524h case    1:*/		cpu::op::rlwinm<0,16,28,31>(regs,&regs.R11,regs.R8);
		/* 82063524h case    1:*/		return 0x82063528;
		  /* 82063528h */ case    2:  		/* cmplwi CR6, R11, 2 */
		/* 82063528h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 82063528h case    2:*/		return 0x8206352C;
		  /* 8206352Ch */ case    3:  		/* bc 12, CR6_EQ, 28 */
		/* 8206352Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x82063548;  }
		/* 8206352Ch case    3:*/		return 0x82063530;
		  /* 82063530h */ case    4:  		/* cmplwi CR6, R11, 3 */
		/* 82063530h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 82063530h case    4:*/		return 0x82063534;
		  /* 82063534h */ case    5:  		/* bc 12, CR6_EQ, 20 */
		/* 82063534h case    5:*/		if ( regs.CR[6].eq ) { return 0x82063548;  }
		/* 82063534h case    5:*/		return 0x82063538;
		  /* 82063538h */ case    6:  		/* cmplwi CR6, R11, 10 */
		/* 82063538h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000A);
		/* 82063538h case    6:*/		return 0x8206353C;
		  /* 8206353Ch */ case    7:  		/* bc 12, CR6_EQ, 12 */
		/* 8206353Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x82063548;  }
		/* 8206353Ch case    7:*/		return 0x82063540;
		  /* 82063540h */ case    8:  		/* cmplwi CR6, R11, 12 */
		/* 82063540h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000C);
		/* 82063540h case    8:*/		return 0x82063544;
		  /* 82063544h */ case    9:  		/* bclr 4, CR6_EQ */
		/* 82063544h case    9:*/		if ( !regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 82063544h case    9:*/		return 0x82063548;
	}
	return 0x82063548;
} // Block from 82063520h-82063548h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82063548h
// Function 'D3DDevice_GetRenderState_PointSizeMax'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063548( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063548) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063548);
		  /* 82063548h */ case    0:  		/* rlwinm R10, R8, 13, 31, 31 */
		/* 82063548h case    0:*/		cpu::op::rlwinm<0,13,31,31>(regs,&regs.R10,regs.R8);
		/* 82063548h case    0:*/		return 0x8206354C;
		  /* 8206354Ch */ case    1:  		/* xor. R10, R10, R4 */
		/* 8206354Ch case    1:*/		cpu::op::xor<1>(regs,&regs.R10,regs.R10,regs.R4);
		/* 8206354Ch case    1:*/		return 0x82063550;
		  /* 82063550h */ case    2:  		/* bclr 12, CR0_EQ */
		/* 82063550h case    2:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 82063550h case    2:*/		return 0x82063554;
	}
	return 0x82063554;
} // Block from 82063548h-82063554h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82063554h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063554( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063554) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063554);
		  /* 82063554h */ case    0:  		/* rlwinm R9, R11, 31, 1, 31 */
		/* 82063554h case    0:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R9,regs.R11);
		/* 82063554h case    0:*/		return 0x82063558;
	}
	return 0x82063558;
} // Block from 82063554h-82063558h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063558h
// Function 'D3DDevice_SetRenderState_Wrap0'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063558( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063558) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063558);
		  /* 82063558h */ case    0:  		/* addi R10, R4, -1 */
		/* 82063558h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0xFFFFFFFF);
		/* 82063558h case    0:*/		return 0x8206355C;
		  /* 8206355Ch */ case    1:  		/* addi R11, R11, 3 */
		/* 8206355Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x3);
		/* 8206355Ch case    1:*/		return 0x82063560;
		  /* 82063560h */ case    2:  		/* nor R7, R10, R10 */
		/* 82063560h case    2:*/		cpu::op::nor<0>(regs,&regs.R7,regs.R10,regs.R10);
		/* 82063560h case    2:*/		return 0x82063564;
		  /* 82063564h */ case    3:  		/* addi R9, R9, -3 */
		/* 82063564h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFD);
		/* 82063564h case    3:*/		return 0x82063568;
		  /* 82063568h */ case    4:  		/* rlwinm R11, R11, 17, 0, 14 */
		/* 82063568h case    4:*/		cpu::op::rlwinm<0,17,0,14>(regs,&regs.R11,regs.R11);
		/* 82063568h case    4:*/		return 0x8206356C;
		  /* 8206356Ch */ case    5:  		/* rlwinm R7, R7, 16, 0, 15 */
		/* 8206356Ch case    5:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R7,regs.R7);
		/* 8206356Ch case    5:*/		return 0x82063570;
		  /* 82063570h */ case    6:  		/* and R10, R9, R10 */
		/* 82063570h case    6:*/		cpu::op::and<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82063570h case    6:*/		return 0x82063574;
		  /* 82063574h */ case    7:  		/* and R11, R7, R11 */
		/* 82063574h case    7:*/		cpu::op::and<0>(regs,&regs.R11,regs.R7,regs.R11);
		/* 82063574h case    7:*/		return 0x82063578;
	}
	return 0x82063578;
} // Block from 82063558h-82063578h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82063578h
// Function 'D3DDevice_SetRenderState_Wrap1'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063578( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063578) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063578);
		  /* 82063578h */ case    0:  		/* rlwinm R10, R10, 16, 0, 15 */
		/* 82063578h case    0:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R10,regs.R10);
		/* 82063578h case    0:*/		return 0x8206357C;
		  /* 8206357Ch */ case    1:  		/* li R12, 1 */
		/* 8206357Ch case    1:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 8206357Ch case    1:*/		return 0x82063580;
		  /* 82063580h */ case    2:  		/* or R11, R11, R10 */
		/* 82063580h case    2:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82063580h case    2:*/		return 0x82063584;
		  /* 82063584h */ case    3:  		/* rldicr R12, R12, 56, 63 */
		/* 82063584h case    3:*/		cpu::op::rldicr<0,56,63>(regs,&regs.R12,regs.R12);
		/* 82063584h case    3:*/		return 0x82063588;
		  /* 82063588h */ case    4:  		/* rlwimi R11, R8, 0, 16, 11 */
		/* 82063588h case    4:*/		cpu::op::rlwimi<0,0,16,11>(regs,&regs.R11,regs.R8);
		/* 82063588h case    4:*/		return 0x8206358C;
		  /* 8206358Ch */ case    5:  		/* stw R11, <#[R3 + 10372]> */
		/* 8206358Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002884) );
		/* 8206358Ch case    5:*/		return 0x82063590;
		  /* 82063590h */ case    6:  		/* ld R11, <#[R3 + 16]> */
		/* 82063590h case    6:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82063590h case    6:*/		return 0x82063594;
		  /* 82063594h */ case    7:  		/* or R11, R11, R12 */
		/* 82063594h case    7:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 82063594h case    7:*/		return 0x82063598;
		  /* 82063598h */ case    8:  		/* std R11, <#[R3 + 16]> */
		/* 82063598h case    8:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82063598h case    8:*/		return 0x8206359C;
		  /* 8206359Ch */ case    9:  		/* bclr 20, CR0_LT */
		/* 8206359Ch case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206359Ch case    9:*/		return 0x820635A0;
	}
	return 0x820635A0;
} // Block from 82063578h-820635A0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820635A0h
// Function 'D3DDevice_SetRenderState_Wrap2'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820635A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820635A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820635A0);
		  /* 820635A0h */ case    0:  		/* lwz R3, <#[R3 + 12408]> */
		/* 820635A0h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00003078) );
		/* 820635A0h case    0:*/		return 0x820635A4;
		  /* 820635A4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820635A4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820635A4h case    1:*/		return 0x820635A8;
	}
	return 0x820635A8;
} // Block from 820635A0h-820635A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820635A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820635A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820635A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820635A8);
		  /* 820635A8h */ case    0:  		/* lwz R11, <#[R3 + 12820]> */
		/* 820635A8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00003214) );
		/* 820635A8h case    0:*/		return 0x820635AC;
		  /* 820635ACh */ case    1:  		/* stw R4, <#[R3 + 12412]> */
		/* 820635ACh case    1:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x0000307C) );
		/* 820635ACh case    1:*/		return 0x820635B0;
		  /* 820635B0h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 820635B0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820635B0h case    2:*/		return 0x820635B4;
		  /* 820635B4h */ case    3:  		/* bclr 12, CR6_EQ */
		/* 820635B4h case    3:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 820635B4h case    3:*/		return 0x820635B8;
	}
	return 0x820635B8;
} // Block from 820635A8h-820635B8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820635B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820635B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820635B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820635B8);
		  /* 820635B8h */ case    0:  		/* lwz R8, <#[R3 + 10380]> */
		/* 820635B8h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x0000288C) );
		/* 820635B8h case    0:*/		return 0x820635BC;
		  /* 820635BCh */ case    1:  		/* rlwinm R11, R8, 16, 28, 31 */
		/* 820635BCh case    1:*/		cpu::op::rlwinm<0,16,28,31>(regs,&regs.R11,regs.R8);
		/* 820635BCh case    1:*/		return 0x820635C0;
		  /* 820635C0h */ case    2:  		/* cmplwi CR6, R11, 2 */
		/* 820635C0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 820635C0h case    2:*/		return 0x820635C4;
		  /* 820635C4h */ case    3:  		/* bc 12, CR6_EQ, 28 */
		/* 820635C4h case    3:*/		if ( regs.CR[6].eq ) { return 0x820635E0;  }
		/* 820635C4h case    3:*/		return 0x820635C8;
	}
	return 0x820635C8;
} // Block from 820635B8h-820635C8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820635C8h
// Function 'D3DDevice_SetRenderState_Wrap3'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820635C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820635C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820635C8);
		  /* 820635C8h */ case    0:  		/* cmplwi CR6, R11, 3 */
		/* 820635C8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820635C8h case    0:*/		return 0x820635CC;
		  /* 820635CCh */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 820635CCh case    1:*/		if ( regs.CR[6].eq ) { return 0x820635E0;  }
		/* 820635CCh case    1:*/		return 0x820635D0;
		  /* 820635D0h */ case    2:  		/* cmplwi CR6, R11, 10 */
		/* 820635D0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000A);
		/* 820635D0h case    2:*/		return 0x820635D4;
		  /* 820635D4h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 820635D4h case    3:*/		if ( regs.CR[6].eq ) { return 0x820635E0;  }
		/* 820635D4h case    3:*/		return 0x820635D8;
		  /* 820635D8h */ case    4:  		/* cmplwi CR6, R11, 12 */
		/* 820635D8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000C);
		/* 820635D8h case    4:*/		return 0x820635DC;
		  /* 820635DCh */ case    5:  		/* bclr 4, CR6_EQ */
		/* 820635DCh case    5:*/		if ( !regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 820635DCh case    5:*/		return 0x820635E0;
	}
	return 0x820635E0;
} // Block from 820635C8h-820635E0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820635E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820635E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820635E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820635E0);
		  /* 820635E0h */ case    0:  		/* rlwinm R10, R8, 13, 31, 31 */
		/* 820635E0h case    0:*/		cpu::op::rlwinm<0,13,31,31>(regs,&regs.R10,regs.R8);
		/* 820635E0h case    0:*/		return 0x820635E4;
		  /* 820635E4h */ case    1:  		/* xor. R10, R10, R4 */
		/* 820635E4h case    1:*/		cpu::op::xor<1>(regs,&regs.R10,regs.R10,regs.R4);
		/* 820635E4h case    1:*/		return 0x820635E8;
		  /* 820635E8h */ case    2:  		/* bclr 12, CR0_EQ */
		/* 820635E8h case    2:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 820635E8h case    2:*/		return 0x820635EC;
	}
	return 0x820635EC;
} // Block from 820635E0h-820635ECh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820635ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820635EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820635EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820635EC);
		  /* 820635ECh */ case    0:  		/* rlwinm R9, R11, 31, 1, 31 */
		/* 820635ECh case    0:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R9,regs.R11);
		/* 820635ECh case    0:*/		return 0x820635F0;
	}
	return 0x820635F0;
} // Block from 820635ECh-820635F0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820635F0h
// Function 'D3DDevice_SetRenderState_Wrap4'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820635F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820635F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820635F0);
		  /* 820635F0h */ case    0:  		/* addi R10, R4, -1 */
		/* 820635F0h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0xFFFFFFFF);
		/* 820635F0h case    0:*/		return 0x820635F4;
		  /* 820635F4h */ case    1:  		/* addi R11, R11, 3 */
		/* 820635F4h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x3);
		/* 820635F4h case    1:*/		return 0x820635F8;
		  /* 820635F8h */ case    2:  		/* nor R7, R10, R10 */
		/* 820635F8h case    2:*/		cpu::op::nor<0>(regs,&regs.R7,regs.R10,regs.R10);
		/* 820635F8h case    2:*/		return 0x820635FC;
		  /* 820635FCh */ case    3:  		/* addi R9, R9, -3 */
		/* 820635FCh case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFD);
		/* 820635FCh case    3:*/		return 0x82063600;
		  /* 82063600h */ case    4:  		/* rlwinm R11, R11, 17, 0, 14 */
		/* 82063600h case    4:*/		cpu::op::rlwinm<0,17,0,14>(regs,&regs.R11,regs.R11);
		/* 82063600h case    4:*/		return 0x82063604;
		  /* 82063604h */ case    5:  		/* rlwinm R7, R7, 16, 0, 15 */
		/* 82063604h case    5:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R7,regs.R7);
		/* 82063604h case    5:*/		return 0x82063608;
		  /* 82063608h */ case    6:  		/* and R10, R9, R10 */
		/* 82063608h case    6:*/		cpu::op::and<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82063608h case    6:*/		return 0x8206360C;
		  /* 8206360Ch */ case    7:  		/* and R11, R7, R11 */
		/* 8206360Ch case    7:*/		cpu::op::and<0>(regs,&regs.R11,regs.R7,regs.R11);
		/* 8206360Ch case    7:*/		return 0x82063610;
		  /* 82063610h */ case    8:  		/* rlwinm R10, R10, 16, 0, 15 */
		/* 82063610h case    8:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R10,regs.R10);
		/* 82063610h case    8:*/		return 0x82063614;
		  /* 82063614h */ case    9:  		/* li R12, 1 */
		/* 82063614h case    9:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 82063614h case    9:*/		return 0x82063618;
	}
	return 0x82063618;
} // Block from 820635F0h-82063618h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82063618h
// Function 'D3DDevice_SetRenderState_Wrap5'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063618( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063618) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063618);
		  /* 82063618h */ case    0:  		/* or R11, R11, R10 */
		/* 82063618h case    0:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82063618h case    0:*/		return 0x8206361C;
		  /* 8206361Ch */ case    1:  		/* rldicr R12, R12, 54, 63 */
		/* 8206361Ch case    1:*/		cpu::op::rldicr<0,54,63>(regs,&regs.R12,regs.R12);
		/* 8206361Ch case    1:*/		return 0x82063620;
		  /* 82063620h */ case    2:  		/* rlwimi R11, R8, 0, 16, 11 */
		/* 82063620h case    2:*/		cpu::op::rlwimi<0,0,16,11>(regs,&regs.R11,regs.R8);
		/* 82063620h case    2:*/		return 0x82063624;
		  /* 82063624h */ case    3:  		/* stw R11, <#[R3 + 10380]> */
		/* 82063624h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000288C) );
		/* 82063624h case    3:*/		return 0x82063628;
		  /* 82063628h */ case    4:  		/* ld R11, <#[R3 + 16]> */
		/* 82063628h case    4:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82063628h case    4:*/		return 0x8206362C;
		  /* 8206362Ch */ case    5:  		/* or R11, R11, R12 */
		/* 8206362Ch case    5:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 8206362Ch case    5:*/		return 0x82063630;
		  /* 82063630h */ case    6:  		/* std R11, <#[R3 + 16]> */
		/* 82063630h case    6:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82063630h case    6:*/		return 0x82063634;
		  /* 82063634h */ case    7:  		/* bclr 20, CR0_LT */
		/* 82063634h case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063634h case    7:*/		return 0x82063638;
	}
	return 0x82063638;
} // Block from 82063618h-82063638h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82063638h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063638( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063638) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063638);
		  /* 82063638h */ case    0:  		/* lwz R3, <#[R3 + 12412]> */
		/* 82063638h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x0000307C) );
		/* 82063638h case    0:*/		return 0x8206363C;
		  /* 8206363Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 8206363Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206363Ch case    1:*/		return 0x82063640;
	}
	return 0x82063640;
} // Block from 82063638h-82063640h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063640h
// Function 'D3DDevice_SetRenderState_Wrap6'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063640( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063640) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063640);
		  /* 82063640h */ case    0:  		/* lwz R11, <#[R3 + 12824]> */
		/* 82063640h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00003218) );
		/* 82063640h case    0:*/		return 0x82063644;
		  /* 82063644h */ case    1:  		/* stw R4, <#[R3 + 12416]> */
		/* 82063644h case    1:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00003080) );
		/* 82063644h case    1:*/		return 0x82063648;
		  /* 82063648h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82063648h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82063648h case    2:*/		return 0x8206364C;
		  /* 8206364Ch */ case    3:  		/* bclr 12, CR6_EQ */
		/* 8206364Ch case    3:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 8206364Ch case    3:*/		return 0x82063650;
	}
	return 0x82063650;
} // Block from 82063640h-82063650h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82063650h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063650( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063650) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063650);
		  /* 82063650h */ case    0:  		/* lwz R8, <#[R3 + 10384]> */
		/* 82063650h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00002890) );
		/* 82063650h case    0:*/		return 0x82063654;
		  /* 82063654h */ case    1:  		/* rlwinm R11, R8, 16, 28, 31 */
		/* 82063654h case    1:*/		cpu::op::rlwinm<0,16,28,31>(regs,&regs.R11,regs.R8);
		/* 82063654h case    1:*/		return 0x82063658;
		  /* 82063658h */ case    2:  		/* cmplwi CR6, R11, 2 */
		/* 82063658h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 82063658h case    2:*/		return 0x8206365C;
		  /* 8206365Ch */ case    3:  		/* bc 12, CR6_EQ, 28 */
		/* 8206365Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x82063678;  }
		/* 8206365Ch case    3:*/		return 0x82063660;
		  /* 82063660h */ case    4:  		/* cmplwi CR6, R11, 3 */
		/* 82063660h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 82063660h case    4:*/		return 0x82063664;
		  /* 82063664h */ case    5:  		/* bc 12, CR6_EQ, 20 */
		/* 82063664h case    5:*/		if ( regs.CR[6].eq ) { return 0x82063678;  }
		/* 82063664h case    5:*/		return 0x82063668;
	}
	return 0x82063668;
} // Block from 82063650h-82063668h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82063668h
// Function 'D3DDevice_SetRenderState_Wrap7'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063668( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063668) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063668);
		  /* 82063668h */ case    0:  		/* cmplwi CR6, R11, 10 */
		/* 82063668h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000A);
		/* 82063668h case    0:*/		return 0x8206366C;
		  /* 8206366Ch */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 8206366Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x82063678;  }
		/* 8206366Ch case    1:*/		return 0x82063670;
		  /* 82063670h */ case    2:  		/* cmplwi CR6, R11, 12 */
		/* 82063670h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000C);
		/* 82063670h case    2:*/		return 0x82063674;
		  /* 82063674h */ case    3:  		/* bclr 4, CR6_EQ */
		/* 82063674h case    3:*/		if ( !regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 82063674h case    3:*/		return 0x82063678;
	}
	return 0x82063678;
} // Block from 82063668h-82063678h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82063678h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063678( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063678) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063678);
		  /* 82063678h */ case    0:  		/* rlwinm R10, R8, 13, 31, 31 */
		/* 82063678h case    0:*/		cpu::op::rlwinm<0,13,31,31>(regs,&regs.R10,regs.R8);
		/* 82063678h case    0:*/		return 0x8206367C;
		  /* 8206367Ch */ case    1:  		/* xor. R10, R10, R4 */
		/* 8206367Ch case    1:*/		cpu::op::xor<1>(regs,&regs.R10,regs.R10,regs.R4);
		/* 8206367Ch case    1:*/		return 0x82063680;
		  /* 82063680h */ case    2:  		/* bclr 12, CR0_EQ */
		/* 82063680h case    2:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 82063680h case    2:*/		return 0x82063684;
	}
	return 0x82063684;
} // Block from 82063678h-82063684h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82063684h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063684( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063684) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063684);
		  /* 82063684h */ case    0:  		/* rlwinm R9, R11, 31, 1, 31 */
		/* 82063684h case    0:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R9,regs.R11);
		/* 82063684h case    0:*/		return 0x82063688;
	}
	return 0x82063688;
} // Block from 82063684h-82063688h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063688h
// Function 'D3DDevice_SetRenderState_Wrap8'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063688( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063688) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063688);
		  /* 82063688h */ case    0:  		/* addi R10, R4, -1 */
		/* 82063688h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0xFFFFFFFF);
		/* 82063688h case    0:*/		return 0x8206368C;
		  /* 8206368Ch */ case    1:  		/* addi R11, R11, 3 */
		/* 8206368Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x3);
		/* 8206368Ch case    1:*/		return 0x82063690;
		  /* 82063690h */ case    2:  		/* nor R7, R10, R10 */
		/* 82063690h case    2:*/		cpu::op::nor<0>(regs,&regs.R7,regs.R10,regs.R10);
		/* 82063690h case    2:*/		return 0x82063694;
		  /* 82063694h */ case    3:  		/* addi R9, R9, -3 */
		/* 82063694h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFD);
		/* 82063694h case    3:*/		return 0x82063698;
		  /* 82063698h */ case    4:  		/* rlwinm R11, R11, 17, 0, 14 */
		/* 82063698h case    4:*/		cpu::op::rlwinm<0,17,0,14>(regs,&regs.R11,regs.R11);
		/* 82063698h case    4:*/		return 0x8206369C;
		  /* 8206369Ch */ case    5:  		/* rlwinm R7, R7, 16, 0, 15 */
		/* 8206369Ch case    5:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R7,regs.R7);
		/* 8206369Ch case    5:*/		return 0x820636A0;
		  /* 820636A0h */ case    6:  		/* and R10, R9, R10 */
		/* 820636A0h case    6:*/		cpu::op::and<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 820636A0h case    6:*/		return 0x820636A4;
		  /* 820636A4h */ case    7:  		/* and R11, R7, R11 */
		/* 820636A4h case    7:*/		cpu::op::and<0>(regs,&regs.R11,regs.R7,regs.R11);
		/* 820636A4h case    7:*/		return 0x820636A8;
	}
	return 0x820636A8;
} // Block from 82063688h-820636A8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820636A8h
// Function 'D3DDevice_SetRenderState_Wrap9'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820636A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820636A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820636A8);
		  /* 820636A8h */ case    0:  		/* rlwinm R10, R10, 16, 0, 15 */
		/* 820636A8h case    0:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R10,regs.R10);
		/* 820636A8h case    0:*/		return 0x820636AC;
		  /* 820636ACh */ case    1:  		/* li R12, 1 */
		/* 820636ACh case    1:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 820636ACh case    1:*/		return 0x820636B0;
		  /* 820636B0h */ case    2:  		/* or R11, R11, R10 */
		/* 820636B0h case    2:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820636B0h case    2:*/		return 0x820636B4;
		  /* 820636B4h */ case    3:  		/* rldicr R12, R12, 53, 63 */
		/* 820636B4h case    3:*/		cpu::op::rldicr<0,53,63>(regs,&regs.R12,regs.R12);
		/* 820636B4h case    3:*/		return 0x820636B8;
		  /* 820636B8h */ case    4:  		/* rlwimi R11, R8, 0, 16, 11 */
		/* 820636B8h case    4:*/		cpu::op::rlwimi<0,0,16,11>(regs,&regs.R11,regs.R8);
		/* 820636B8h case    4:*/		return 0x820636BC;
		  /* 820636BCh */ case    5:  		/* stw R11, <#[R3 + 10384]> */
		/* 820636BCh case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002890) );
		/* 820636BCh case    5:*/		return 0x820636C0;
		  /* 820636C0h */ case    6:  		/* ld R11, <#[R3 + 16]> */
		/* 820636C0h case    6:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820636C0h case    6:*/		return 0x820636C4;
		  /* 820636C4h */ case    7:  		/* or R11, R11, R12 */
		/* 820636C4h case    7:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 820636C4h case    7:*/		return 0x820636C8;
		  /* 820636C8h */ case    8:  		/* std R11, <#[R3 + 16]> */
		/* 820636C8h case    8:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820636C8h case    8:*/		return 0x820636CC;
		  /* 820636CCh */ case    9:  		/* bclr 20, CR0_LT */
		/* 820636CCh case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820636CCh case    9:*/		return 0x820636D0;
	}
	return 0x820636D0;
} // Block from 820636A8h-820636D0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820636D0h
// Function 'D3DDevice_SetRenderState_Wrap10'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820636D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820636D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820636D0);
		  /* 820636D0h */ case    0:  		/* lwz R3, <#[R3 + 12416]> */
		/* 820636D0h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00003080) );
		/* 820636D0h case    0:*/		return 0x820636D4;
		  /* 820636D4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820636D4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820636D4h case    1:*/		return 0x820636D8;
	}
	return 0x820636D8;
} // Block from 820636D0h-820636D8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820636D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820636D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820636D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820636D8);
		  /* 820636D8h */ case    0:  		/* lwz R11, <#[R3 + 12828]> */
		/* 820636D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000321C) );
		/* 820636D8h case    0:*/		return 0x820636DC;
		  /* 820636DCh */ case    1:  		/* stw R4, <#[R3 + 12420]> */
		/* 820636DCh case    1:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00003084) );
		/* 820636DCh case    1:*/		return 0x820636E0;
		  /* 820636E0h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 820636E0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820636E0h case    2:*/		return 0x820636E4;
		  /* 820636E4h */ case    3:  		/* bclr 12, CR6_EQ */
		/* 820636E4h case    3:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 820636E4h case    3:*/		return 0x820636E8;
	}
	return 0x820636E8;
} // Block from 820636D8h-820636E8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820636E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820636E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820636E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820636E8);
		  /* 820636E8h */ case    0:  		/* lwz R8, <#[R3 + 10388]> */
		/* 820636E8h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00002894) );
		/* 820636E8h case    0:*/		return 0x820636EC;
		  /* 820636ECh */ case    1:  		/* rlwinm R11, R8, 16, 28, 31 */
		/* 820636ECh case    1:*/		cpu::op::rlwinm<0,16,28,31>(regs,&regs.R11,regs.R8);
		/* 820636ECh case    1:*/		return 0x820636F0;
		  /* 820636F0h */ case    2:  		/* cmplwi CR6, R11, 2 */
		/* 820636F0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 820636F0h case    2:*/		return 0x820636F4;
		  /* 820636F4h */ case    3:  		/* bc 12, CR6_EQ, 28 */
		/* 820636F4h case    3:*/		if ( regs.CR[6].eq ) { return 0x82063710;  }
		/* 820636F4h case    3:*/		return 0x820636F8;
	}
	return 0x820636F8;
} // Block from 820636E8h-820636F8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820636F8h
// Function 'D3DDevice_SetRenderState_Wrap11'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820636F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820636F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820636F8);
		  /* 820636F8h */ case    0:  		/* cmplwi CR6, R11, 3 */
		/* 820636F8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 820636F8h case    0:*/		return 0x820636FC;
		  /* 820636FCh */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 820636FCh case    1:*/		if ( regs.CR[6].eq ) { return 0x82063710;  }
		/* 820636FCh case    1:*/		return 0x82063700;
		  /* 82063700h */ case    2:  		/* cmplwi CR6, R11, 10 */
		/* 82063700h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000A);
		/* 82063700h case    2:*/		return 0x82063704;
		  /* 82063704h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 82063704h case    3:*/		if ( regs.CR[6].eq ) { return 0x82063710;  }
		/* 82063704h case    3:*/		return 0x82063708;
		  /* 82063708h */ case    4:  		/* cmplwi CR6, R11, 12 */
		/* 82063708h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000C);
		/* 82063708h case    4:*/		return 0x8206370C;
		  /* 8206370Ch */ case    5:  		/* bclr 4, CR6_EQ */
		/* 8206370Ch case    5:*/		if ( !regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 8206370Ch case    5:*/		return 0x82063710;
	}
	return 0x82063710;
} // Block from 820636F8h-82063710h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82063710h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063710( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063710) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063710);
		  /* 82063710h */ case    0:  		/* rlwinm R10, R8, 13, 31, 31 */
		/* 82063710h case    0:*/		cpu::op::rlwinm<0,13,31,31>(regs,&regs.R10,regs.R8);
		/* 82063710h case    0:*/		return 0x82063714;
		  /* 82063714h */ case    1:  		/* xor. R10, R10, R4 */
		/* 82063714h case    1:*/		cpu::op::xor<1>(regs,&regs.R10,regs.R10,regs.R4);
		/* 82063714h case    1:*/		return 0x82063718;
		  /* 82063718h */ case    2:  		/* bclr 12, CR0_EQ */
		/* 82063718h case    2:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 82063718h case    2:*/		return 0x8206371C;
	}
	return 0x8206371C;
} // Block from 82063710h-8206371Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206371Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206371C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206371C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206371C);
		  /* 8206371Ch */ case    0:  		/* rlwinm R9, R11, 31, 1, 31 */
		/* 8206371Ch case    0:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R9,regs.R11);
		/* 8206371Ch case    0:*/		return 0x82063720;
	}
	return 0x82063720;
} // Block from 8206371Ch-82063720h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063720h
// Function 'D3DDevice_SetRenderState_Wrap12'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063720( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063720) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063720);
		  /* 82063720h */ case    0:  		/* addi R10, R4, -1 */
		/* 82063720h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0xFFFFFFFF);
		/* 82063720h case    0:*/		return 0x82063724;
		  /* 82063724h */ case    1:  		/* addi R11, R11, 3 */
		/* 82063724h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x3);
		/* 82063724h case    1:*/		return 0x82063728;
		  /* 82063728h */ case    2:  		/* nor R7, R10, R10 */
		/* 82063728h case    2:*/		cpu::op::nor<0>(regs,&regs.R7,regs.R10,regs.R10);
		/* 82063728h case    2:*/		return 0x8206372C;
		  /* 8206372Ch */ case    3:  		/* addi R9, R9, -3 */
		/* 8206372Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFD);
		/* 8206372Ch case    3:*/		return 0x82063730;
		  /* 82063730h */ case    4:  		/* rlwinm R11, R11, 17, 0, 14 */
		/* 82063730h case    4:*/		cpu::op::rlwinm<0,17,0,14>(regs,&regs.R11,regs.R11);
		/* 82063730h case    4:*/		return 0x82063734;
		  /* 82063734h */ case    5:  		/* rlwinm R7, R7, 16, 0, 15 */
		/* 82063734h case    5:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R7,regs.R7);
		/* 82063734h case    5:*/		return 0x82063738;
		  /* 82063738h */ case    6:  		/* and R10, R9, R10 */
		/* 82063738h case    6:*/		cpu::op::and<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82063738h case    6:*/		return 0x8206373C;
		  /* 8206373Ch */ case    7:  		/* and R11, R7, R11 */
		/* 8206373Ch case    7:*/		cpu::op::and<0>(regs,&regs.R11,regs.R7,regs.R11);
		/* 8206373Ch case    7:*/		return 0x82063740;
		  /* 82063740h */ case    8:  		/* rlwinm R10, R10, 16, 0, 15 */
		/* 82063740h case    8:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R10,regs.R10);
		/* 82063740h case    8:*/		return 0x82063744;
		  /* 82063744h */ case    9:  		/* li R12, 1 */
		/* 82063744h case    9:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 82063744h case    9:*/		return 0x82063748;
	}
	return 0x82063748;
} // Block from 82063720h-82063748h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82063748h
// Function 'D3DDevice_SetRenderState_Wrap13'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063748( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063748) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063748);
		  /* 82063748h */ case    0:  		/* or R11, R11, R10 */
		/* 82063748h case    0:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82063748h case    0:*/		return 0x8206374C;
		  /* 8206374Ch */ case    1:  		/* rldicr R12, R12, 52, 63 */
		/* 8206374Ch case    1:*/		cpu::op::rldicr<0,52,63>(regs,&regs.R12,regs.R12);
		/* 8206374Ch case    1:*/		return 0x82063750;
		  /* 82063750h */ case    2:  		/* rlwimi R11, R8, 0, 16, 11 */
		/* 82063750h case    2:*/		cpu::op::rlwimi<0,0,16,11>(regs,&regs.R11,regs.R8);
		/* 82063750h case    2:*/		return 0x82063754;
		  /* 82063754h */ case    3:  		/* stw R11, <#[R3 + 10388]> */
		/* 82063754h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002894) );
		/* 82063754h case    3:*/		return 0x82063758;
		  /* 82063758h */ case    4:  		/* ld R11, <#[R3 + 16]> */
		/* 82063758h case    4:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82063758h case    4:*/		return 0x8206375C;
		  /* 8206375Ch */ case    5:  		/* or R11, R11, R12 */
		/* 8206375Ch case    5:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 8206375Ch case    5:*/		return 0x82063760;
		  /* 82063760h */ case    6:  		/* std R11, <#[R3 + 16]> */
		/* 82063760h case    6:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82063760h case    6:*/		return 0x82063764;
		  /* 82063764h */ case    7:  		/* bclr 20, CR0_LT */
		/* 82063764h case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063764h case    7:*/		return 0x82063768;
	}
	return 0x82063768;
} // Block from 82063748h-82063768h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82063768h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063768( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063768) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063768);
		  /* 82063768h */ case    0:  		/* lwz R3, <#[R3 + 12420]> */
		/* 82063768h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00003084) );
		/* 82063768h case    0:*/		return 0x8206376C;
		  /* 8206376Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 8206376Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206376Ch case    1:*/		return 0x82063770;
	}
	return 0x82063770;
} // Block from 82063768h-82063770h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063770h
// Function 'D3DDevice_SetRenderState_Wrap14'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063770( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063770) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063770);
		  /* 82063770h */ case    0:  		/* stw R4, <#[R1 + 28]> */
		/* 82063770h case    0:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000001C) );
		/* 82063770h case    0:*/		return 0x82063774;
		  /* 82063774h */ case    1:  		/* lfs FR0, <#[R1 + 28]> */
		/* 82063774h case    1:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x0000001C) );
		/* 82063774h case    1:*/		return 0x82063778;
		  /* 82063778h */ case    2:  		/* stfs FR0, <#[R3 + 10624]> */
		/* 82063778h case    2:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R3 + 0x00002980) );
		/* 82063778h case    2:*/		return 0x8206377C;
		  /* 8206377Ch */ case    3:  		/* li R12, 1 */
		/* 8206377Ch case    3:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 8206377Ch case    3:*/		return 0x82063780;
		  /* 82063780h */ case    4:  		/* ld R10, <#[R3 + 24]> */
		/* 82063780h case    4:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R3 + 0x00000018) );
		/* 82063780h case    4:*/		return 0x82063784;
		  /* 82063784h */ case    5:  		/* rldicr R12, R12, 47, 63 */
		/* 82063784h case    5:*/		cpu::op::rldicr<0,47,63>(regs,&regs.R12,regs.R12);
		/* 82063784h case    5:*/		return 0x82063788;
		  /* 82063788h */ case    6:  		/* or R11, R10, R12 */
		/* 82063788h case    6:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R12);
		/* 82063788h case    6:*/		return 0x8206378C;
		  /* 8206378Ch */ case    7:  		/* std R11, <#[R3 + 24]> */
		/* 8206378Ch case    7:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 8206378Ch case    7:*/		return 0x82063790;
		  /* 82063790h */ case    8:  		/* bclr 20, CR0_LT */
		/* 82063790h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063790h case    8:*/		return 0x82063794;
	}
	return 0x82063794;
} // Block from 82063770h-82063794h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82063794h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063794( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063794) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063794);
		  /* 82063794h */ case    0:  		/* nop */
		/* 82063794h case    0:*/		cpu::op::nop();
		/* 82063794h case    0:*/		return 0x82063798;
	}
	return 0x82063798;
} // Block from 82063794h-82063798h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063798h
// Function 'D3DDevice_SetRenderState_Wrap15'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063798( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063798) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063798);
		  /* 82063798h */ case    0:  		/* lfs FR0, <#[R3 + 10624]> */
		/* 82063798h case    0:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R3 + 0x00002980) );
		/* 82063798h case    0:*/		return 0x8206379C;
		  /* 8206379Ch */ case    1:  		/* stfs FR0, <#[R1 - 16]> */
		/* 8206379Ch case    1:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206379Ch case    1:*/		return 0x820637A0;
		  /* 820637A0h */ case    2:  		/* lwz R3, <#[R1 - 16]> */
		/* 820637A0h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820637A0h case    2:*/		return 0x820637A4;
		  /* 820637A4h */ case    3:  		/* bclr 20, CR0_LT */
		/* 820637A4h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820637A4h case    3:*/		return 0x820637A8;
	}
	return 0x820637A8;
} // Block from 82063798h-820637A8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820637A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820637A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820637A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820637A8);
		  /* 820637A8h */ case    0:  		/* stw R4, <#[R1 + 28]> */
		/* 820637A8h case    0:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000001C) );
		/* 820637A8h case    0:*/		return 0x820637AC;
		  /* 820637ACh */ case    1:  		/* lfs FR0, <#[R1 + 28]> */
		/* 820637ACh case    1:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x0000001C) );
		/* 820637ACh case    1:*/		return 0x820637B0;
		  /* 820637B0h */ case    2:  		/* stfs FR0, <#[R3 + 10620]> */
		/* 820637B0h case    2:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R3 + 0x0000297C) );
		/* 820637B0h case    2:*/		return 0x820637B4;
		  /* 820637B4h */ case    3:  		/* li R12, 1 */
		/* 820637B4h case    3:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 820637B4h case    3:*/		return 0x820637B8;
	}
	return 0x820637B8;
} // Block from 820637A8h-820637B8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820637B8h
// Function 'D3DDevice_GetRenderState_Wrap0'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820637B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820637B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820637B8);
		  /* 820637B8h */ case    0:  		/* ld R10, <#[R3 + 24]> */
		/* 820637B8h case    0:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R3 + 0x00000018) );
		/* 820637B8h case    0:*/		return 0x820637BC;
		  /* 820637BCh */ case    1:  		/* rldicr R12, R12, 48, 63 */
		/* 820637BCh case    1:*/		cpu::op::rldicr<0,48,63>(regs,&regs.R12,regs.R12);
		/* 820637BCh case    1:*/		return 0x820637C0;
		  /* 820637C0h */ case    2:  		/* or R11, R10, R12 */
		/* 820637C0h case    2:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R12);
		/* 820637C0h case    2:*/		return 0x820637C4;
		  /* 820637C4h */ case    3:  		/* std R11, <#[R3 + 24]> */
		/* 820637C4h case    3:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820637C4h case    3:*/		return 0x820637C8;
	}
	return 0x820637C8;
} // Block from 820637B8h-820637C8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820637C8h
// Function 'D3DDevice_GetRenderState_Wrap1'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820637C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820637C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820637C8);
		  /* 820637C8h */ case    0:  		/* bclr 20, CR0_LT */
		/* 820637C8h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820637C8h case    0:*/		return 0x820637CC;
	}
	return 0x820637CC;
} // Block from 820637C8h-820637CCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820637CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820637CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820637CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820637CC);
		  /* 820637CCh */ case    0:  		/* nop */
		/* 820637CCh case    0:*/		cpu::op::nop();
		/* 820637CCh case    0:*/		return 0x820637D0;
	}
	return 0x820637D0;
} // Block from 820637CCh-820637D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820637D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820637D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820637D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820637D0);
		  /* 820637D0h */ case    0:  		/* lfs FR0, <#[R3 + 10620]> */
		/* 820637D0h case    0:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R3 + 0x0000297C) );
		/* 820637D0h case    0:*/		return 0x820637D4;
		  /* 820637D4h */ case    1:  		/* stfs FR0, <#[R1 - 16]> */
		/* 820637D4h case    1:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820637D4h case    1:*/		return 0x820637D8;
	}
	return 0x820637D8;
} // Block from 820637D0h-820637D8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820637D8h
// Function 'D3DDevice_GetRenderState_Wrap2'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820637D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820637D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820637D8);
		  /* 820637D8h */ case    0:  		/* lwz R3, <#[R1 - 16]> */
		/* 820637D8h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820637D8h case    0:*/		return 0x820637DC;
		  /* 820637DCh */ case    1:  		/* bclr 20, CR0_LT */
		/* 820637DCh case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820637DCh case    1:*/		return 0x820637E0;
	}
	return 0x820637E0;
} // Block from 820637D8h-820637E0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820637E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820637E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820637E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820637E0);
		  /* 820637E0h */ case    0:  		/* lwz R11, <#[R3 + 10616]> */
		/* 820637E0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002978) );
		/* 820637E0h case    0:*/		return 0x820637E4;
		  /* 820637E4h */ case    1:  		/* li R12, 1 */
		/* 820637E4h case    1:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 820637E4h case    1:*/		return 0x820637E8;
	}
	return 0x820637E8;
} // Block from 820637E0h-820637E8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820637E8h
// Function 'D3DDevice_GetRenderState_Wrap3'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820637E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820637E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820637E8);
		  /* 820637E8h */ case    0:  		/* rlwimi R4, R11, 0, 0, 29 */
		/* 820637E8h case    0:*/		cpu::op::rlwimi<0,0,0,29>(regs,&regs.R4,regs.R11);
		/* 820637E8h case    0:*/		return 0x820637EC;
		  /* 820637ECh */ case    1:  		/* rldicr R12, R12, 49, 63 */
		/* 820637ECh case    1:*/		cpu::op::rldicr<0,49,63>(regs,&regs.R12,regs.R12);
		/* 820637ECh case    1:*/		return 0x820637F0;
		  /* 820637F0h */ case    2:  		/* stw R4, <#[R3 + 10616]> */
		/* 820637F0h case    2:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00002978) );
		/* 820637F0h case    2:*/		return 0x820637F4;
		  /* 820637F4h */ case    3:  		/* ld R11, <#[R3 + 24]> */
		/* 820637F4h case    3:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820637F4h case    3:*/		return 0x820637F8;
	}
	return 0x820637F8;
} // Block from 820637E8h-820637F8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820637F8h
// Function 'D3DDevice_GetRenderState_Wrap4'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820637F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820637F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820637F8);
		  /* 820637F8h */ case    0:  		/* or R11, R11, R12 */
		/* 820637F8h case    0:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 820637F8h case    0:*/		return 0x820637FC;
		  /* 820637FCh */ case    1:  		/* std R11, <#[R3 + 24]> */
		/* 820637FCh case    1:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820637FCh case    1:*/		return 0x82063800;
		  /* 82063800h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82063800h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063800h case    2:*/		return 0x82063804;
	}
	return 0x82063804;
} // Block from 820637F8h-82063804h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82063804h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063804( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063804) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063804);
		  /* 82063804h */ case    0:  		/* nop */
		/* 82063804h case    0:*/		cpu::op::nop();
		/* 82063804h case    0:*/		return 0x82063808;
	}
	return 0x82063808;
} // Block from 82063804h-82063808h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063808h
// Function 'D3DDevice_GetRenderState_Wrap5'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063808( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063808) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063808);
		  /* 82063808h */ case    0:  		/* lwz R11, <#[R3 + 10616]> */
		/* 82063808h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002978) );
		/* 82063808h case    0:*/		return 0x8206380C;
		  /* 8206380Ch */ case    1:  		/* rlwinm R3, R11, 0, 30, 31 */
		/* 8206380Ch case    1:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R3,regs.R11);
		/* 8206380Ch case    1:*/		return 0x82063810;
		  /* 82063810h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82063810h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063810h case    2:*/		return 0x82063814;
	}
	return 0x82063814;
} // Block from 82063808h-82063814h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82063814h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063814( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063814) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063814);
		  /* 82063814h */ case    0:  		/* nop */
		/* 82063814h case    0:*/		cpu::op::nop();
		/* 82063814h case    0:*/		return 0x82063818;
	}
	return 0x82063818;
} // Block from 82063814h-82063818h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063818h
// Function 'D3DDevice_GetRenderState_Wrap6'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063818( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063818) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063818);
		  /* 82063818h */ case    0:  		/* lwz R11, <#[R3 + 10688]> */
		/* 82063818h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000029C0) );
		/* 82063818h case    0:*/		return 0x8206381C;
		  /* 8206381Ch */ case    1:  		/* li R12, 1 */
		/* 8206381Ch case    1:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 8206381Ch case    1:*/		return 0x82063820;
		  /* 82063820h */ case    2:  		/* rlwimi R4, R11, 0, 0, 30 */
		/* 82063820h case    2:*/		cpu::op::rlwimi<0,0,0,30>(regs,&regs.R4,regs.R11);
		/* 82063820h case    2:*/		return 0x82063824;
		  /* 82063824h */ case    3:  		/* rldicr R12, R12, 35, 63 */
		/* 82063824h case    3:*/		cpu::op::rldicr<0,35,63>(regs,&regs.R12,regs.R12);
		/* 82063824h case    3:*/		return 0x82063828;
	}
	return 0x82063828;
} // Block from 82063818h-82063828h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82063828h
// Function 'D3DDevice_GetRenderState_Wrap7'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063828( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063828) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063828);
		  /* 82063828h */ case    0:  		/* stw R4, <#[R3 + 10688]> */
		/* 82063828h case    0:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x000029C0) );
		/* 82063828h case    0:*/		return 0x8206382C;
		  /* 8206382Ch */ case    1:  		/* ld R11, <#[R3 + 32]> */
		/* 8206382Ch case    1:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 8206382Ch case    1:*/		return 0x82063830;
		  /* 82063830h */ case    2:  		/* or R11, R11, R12 */
		/* 82063830h case    2:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 82063830h case    2:*/		return 0x82063834;
		  /* 82063834h */ case    3:  		/* std R11, <#[R3 + 32]> */
		/* 82063834h case    3:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 82063834h case    3:*/		return 0x82063838;
	}
	return 0x82063838;
} // Block from 82063828h-82063838h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82063838h
// Function 'D3DDevice_GetRenderState_Wrap8'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063838( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063838) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063838);
		  /* 82063838h */ case    0:  		/* bclr 20, CR0_LT */
		/* 82063838h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063838h case    0:*/		return 0x8206383C;
	}
	return 0x8206383C;
} // Block from 82063838h-8206383Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206383Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206383C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206383C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206383C);
		  /* 8206383Ch */ case    0:  		/* nop */
		/* 8206383Ch case    0:*/		cpu::op::nop();
		/* 8206383Ch case    0:*/		return 0x82063840;
	}
	return 0x82063840;
} // Block from 8206383Ch-82063840h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063840h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063840( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063840) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063840);
		  /* 82063840h */ case    0:  		/* lwz R11, <#[R3 + 10688]> */
		/* 82063840h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000029C0) );
		/* 82063840h case    0:*/		return 0x82063844;
		  /* 82063844h */ case    1:  		/* rlwinm R3, R11, 0, 31, 31 */
		/* 82063844h case    1:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R3,regs.R11);
		/* 82063844h case    1:*/		return 0x82063848;
	}
	return 0x82063848;
} // Block from 82063840h-82063848h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063848h
// Function 'D3DDevice_GetRenderState_Wrap9'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063848( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063848) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063848);
		  /* 82063848h */ case    0:  		/* bclr 20, CR0_LT */
		/* 82063848h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063848h case    0:*/		return 0x8206384C;
	}
	return 0x8206384C;
} // Block from 82063848h-8206384Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206384Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206384C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206384C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206384C);
		  /* 8206384Ch */ case    0:  		/* nop */
		/* 8206384Ch case    0:*/		cpu::op::nop();
		/* 8206384Ch case    0:*/		return 0x82063850;
	}
	return 0x82063850;
} // Block from 8206384Ch-82063850h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063850h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063850( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063850) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063850);
		  /* 82063850h */ case    0:  		/* lwz R11, <#[R3 + 10568]> */
		/* 82063850h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002948) );
		/* 82063850h case    0:*/		return 0x82063854;
		  /* 82063854h */ case    1:  		/* rlwimi R11, R4, 21, 10, 10 */
		/* 82063854h case    1:*/		cpu::op::rlwimi<0,21,10,10>(regs,&regs.R11,regs.R4);
		/* 82063854h case    1:*/		return 0x82063858;
	}
	return 0x82063858;
} // Block from 82063850h-82063858h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063858h
// Function 'D3DDevice_GetRenderState_Wrap10'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063858( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063858) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063858);
		  /* 82063858h */ case    0:  		/* stw R11, <#[R3 + 10568]> */
		/* 82063858h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002948) );
		/* 82063858h case    0:*/		return 0x8206385C;
		  /* 8206385Ch */ case    1:  		/* ld R11, <#[R3 + 16]> */
		/* 8206385Ch case    1:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8206385Ch case    1:*/		return 0x82063860;
		  /* 82063860h */ case    2:  		/* ori R11, R11, 64 */
		/* 82063860h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x40);
		/* 82063860h case    2:*/		return 0x82063864;
		  /* 82063864h */ case    3:  		/* std R11, <#[R3 + 16]> */
		/* 82063864h case    3:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82063864h case    3:*/		return 0x82063868;
	}
	return 0x82063868;
} // Block from 82063858h-82063868h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82063868h
// Function 'D3DDevice_GetRenderState_Wrap11'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063868( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063868) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063868);
		  /* 82063868h */ case    0:  		/* bclr 20, CR0_LT */
		/* 82063868h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063868h case    0:*/		return 0x8206386C;
	}
	return 0x8206386C;
} // Block from 82063868h-8206386Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206386Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206386C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206386C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206386C);
		  /* 8206386Ch */ case    0:  		/* nop */
		/* 8206386Ch case    0:*/		cpu::op::nop();
		/* 8206386Ch case    0:*/		return 0x82063870;
	}
	return 0x82063870;
} // Block from 8206386Ch-82063870h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063870h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063870( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063870) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063870);
		  /* 82063870h */ case    0:  		/* lwz R11, <#[R3 + 10568]> */
		/* 82063870h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002948) );
		/* 82063870h case    0:*/		return 0x82063874;
		  /* 82063874h */ case    1:  		/* rlwinm R3, R11, 11, 31, 31 */
		/* 82063874h case    1:*/		cpu::op::rlwinm<0,11,31,31>(regs,&regs.R3,regs.R11);
		/* 82063874h case    1:*/		return 0x82063878;
	}
	return 0x82063878;
} // Block from 82063870h-82063878h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063878h
// Function 'D3DDevice_GetRenderState_Wrap12'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063878( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063878) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063878);
		  /* 82063878h */ case    0:  		/* bclr 20, CR0_LT */
		/* 82063878h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063878h case    0:*/		return 0x8206387C;
	}
	return 0x8206387C;
} // Block from 82063878h-8206387Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206387Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206387C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206387C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206387C);
		  /* 8206387Ch */ case    0:  		/* nop */
		/* 8206387Ch case    0:*/		cpu::op::nop();
		/* 8206387Ch case    0:*/		return 0x82063880;
	}
	return 0x82063880;
} // Block from 8206387Ch-82063880h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063880h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063880( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063880) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063880);
		  /* 82063880h */ case    0:  		/* li R12, 1 */
		/* 82063880h case    0:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 82063880h case    0:*/		return 0x82063884;
		  /* 82063884h */ case    1:  		/* stw R4, <#[R3 + 10456]> */
		/* 82063884h case    1:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x000028D8) );
		/* 82063884h case    1:*/		return 0x82063888;
	}
	return 0x82063888;
} // Block from 82063880h-82063888h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063888h
// Function 'D3DDevice_GetRenderState_Wrap13'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063888( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063888) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063888);
		  /* 82063888h */ case    0:  		/* ld R10, <#[R3 + 16]> */
		/* 82063888h case    0:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 82063888h case    0:*/		return 0x8206388C;
		  /* 8206388Ch */ case    1:  		/* rldicr R12, R12, 38, 63 */
		/* 8206388Ch case    1:*/		cpu::op::rldicr<0,38,63>(regs,&regs.R12,regs.R12);
		/* 8206388Ch case    1:*/		return 0x82063890;
		  /* 82063890h */ case    2:  		/* or R11, R10, R12 */
		/* 82063890h case    2:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R12);
		/* 82063890h case    2:*/		return 0x82063894;
		  /* 82063894h */ case    3:  		/* std R11, <#[R3 + 16]> */
		/* 82063894h case    3:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82063894h case    3:*/		return 0x82063898;
	}
	return 0x82063898;
} // Block from 82063888h-82063898h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82063898h
// Function 'D3DDevice_GetRenderState_Wrap14'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063898( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063898) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063898);
		  /* 82063898h */ case    0:  		/* bclr 20, CR0_LT */
		/* 82063898h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063898h case    0:*/		return 0x8206389C;
	}
	return 0x8206389C;
} // Block from 82063898h-8206389Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206389Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206389C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206389C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206389C);
		  /* 8206389Ch */ case    0:  		/* nop */
		/* 8206389Ch case    0:*/		cpu::op::nop();
		/* 8206389Ch case    0:*/		return 0x820638A0;
	}
	return 0x820638A0;
} // Block from 8206389Ch-820638A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820638A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820638A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820638A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820638A0);
		  /* 820638A0h */ case    0:  		/* lwz R3, <#[R3 + 10456]> */
		/* 820638A0h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x000028D8) );
		/* 820638A0h case    0:*/		return 0x820638A4;
		  /* 820638A4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820638A4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820638A4h case    1:*/		return 0x820638A8;
	}
	return 0x820638A8;
} // Block from 820638A0h-820638A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820638A8h
// Function 'D3DDevice_GetRenderState_Wrap15'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820638A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820638A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820638A8);
		  /* 820638A8h */ case    0:  		/* lwz R11, <#[R3 + 10556]> */
		/* 820638A8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000293C) );
		/* 820638A8h case    0:*/		return 0x820638AC;
		  /* 820638ACh */ case    1:  		/* rlwimi R11, R4, 4, 27, 27 */
		/* 820638ACh case    1:*/		cpu::op::rlwimi<0,4,27,27>(regs,&regs.R11,regs.R4);
		/* 820638ACh case    1:*/		return 0x820638B0;
		  /* 820638B0h */ case    2:  		/* stw R11, <#[R3 + 10556]> */
		/* 820638B0h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000293C) );
		/* 820638B0h case    2:*/		return 0x820638B4;
		  /* 820638B4h */ case    3:  		/* ld R11, <#[R3 + 16]> */
		/* 820638B4h case    3:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820638B4h case    3:*/		return 0x820638B8;
	}
	return 0x820638B8;
} // Block from 820638A8h-820638B8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820638B8h
// Function 'D3DDevice_SetRenderState_ViewportEnable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820638B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820638B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820638B8);
		  /* 820638B8h */ case    0:  		/* ori R11, R11, 512 */
		/* 820638B8h case    0:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x200);
		/* 820638B8h case    0:*/		return 0x820638BC;
		  /* 820638BCh */ case    1:  		/* std R11, <#[R3 + 16]> */
		/* 820638BCh case    1:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820638BCh case    1:*/		return 0x820638C0;
		  /* 820638C0h */ case    2:  		/* bclr 20, CR0_LT */
		/* 820638C0h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820638C0h case    2:*/		return 0x820638C4;
	}
	return 0x820638C4;
} // Block from 820638B8h-820638C4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820638C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820638C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820638C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820638C4);
		  /* 820638C4h */ case    0:  		/* nop */
		/* 820638C4h case    0:*/		cpu::op::nop();
		/* 820638C4h case    0:*/		return 0x820638C8;
	}
	return 0x820638C8;
} // Block from 820638C4h-820638C8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820638C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820638C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820638C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820638C8);
		  /* 820638C8h */ case    0:  		/* lwz R11, <#[R3 + 10556]> */
		/* 820638C8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000293C) );
		/* 820638C8h case    0:*/		return 0x820638CC;
		  /* 820638CCh */ case    1:  		/* rlwinm R3, R11, 28, 31, 31 */
		/* 820638CCh case    1:*/		cpu::op::rlwinm<0,28,31,31>(regs,&regs.R3,regs.R11);
		/* 820638CCh case    1:*/		return 0x820638D0;
		  /* 820638D0h */ case    2:  		/* bclr 20, CR0_LT */
		/* 820638D0h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820638D0h case    2:*/		return 0x820638D4;
	}
	return 0x820638D4;
} // Block from 820638C8h-820638D4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820638D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820638D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820638D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820638D4);
		  /* 820638D4h */ case    0:  		/* nop */
		/* 820638D4h case    0:*/		cpu::op::nop();
		/* 820638D4h case    0:*/		return 0x820638D8;
	}
	return 0x820638D8;
} // Block from 820638D4h-820638D8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820638D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820638D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820638D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820638D8);
		  /* 820638D8h */ case    0:  		/* lwz R11, <#[R3 + 10556]> */
		/* 820638D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000293C) );
		/* 820638D8h case    0:*/		return 0x820638DC;
		  /* 820638DCh */ case    1:  		/* rlwimi R11, R4, 24, 0, 7 */
		/* 820638DCh case    1:*/		cpu::op::rlwimi<0,24,0,7>(regs,&regs.R11,regs.R4);
		/* 820638DCh case    1:*/		return 0x820638E0;
		  /* 820638E0h */ case    2:  		/* stw R11, <#[R3 + 10556]> */
		/* 820638E0h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000293C) );
		/* 820638E0h case    2:*/		return 0x820638E4;
		  /* 820638E4h */ case    3:  		/* ld R11, <#[R3 + 16]> */
		/* 820638E4h case    3:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820638E4h case    3:*/		return 0x820638E8;
		  /* 820638E8h */ case    4:  		/* ori R11, R11, 512 */
		/* 820638E8h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x200);
		/* 820638E8h case    4:*/		return 0x820638EC;
		  /* 820638ECh */ case    5:  		/* std R11, <#[R3 + 16]> */
		/* 820638ECh case    5:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820638ECh case    5:*/		return 0x820638F0;
		  /* 820638F0h */ case    6:  		/* bclr 20, CR0_LT */
		/* 820638F0h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820638F0h case    6:*/		return 0x820638F4;
	}
	return 0x820638F4;
} // Block from 820638D8h-820638F4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820638F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820638F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820638F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820638F4);
		  /* 820638F4h */ case    0:  		/* nop */
		/* 820638F4h case    0:*/		cpu::op::nop();
		/* 820638F4h case    0:*/		return 0x820638F8;
	}
	return 0x820638F8;
} // Block from 820638F4h-820638F8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820638F8h
// Function 'D3DDevice_GetRenderState_ViewportEnable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820638F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820638F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820638F8);
		  /* 820638F8h */ case    0:  		/* lbz R3, <#[R3 + 10556]> */
		/* 820638F8h case    0:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R3 + 0x0000293C) );
		/* 820638F8h case    0:*/		return 0x820638FC;
		  /* 820638FCh */ case    1:  		/* bclr 20, CR0_LT */
		/* 820638FCh case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820638FCh case    1:*/		return 0x82063900;
	}
	return 0x82063900;
} // Block from 820638F8h-82063900h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063900h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063900( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063900) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063900);
		  /* 82063900h */ case    0:  		/* stw R4, <#[R1 + 28]> */
		/* 82063900h case    0:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000001C) );
		/* 82063900h case    0:*/		return 0x82063904;
		  /* 82063904h */ case    1:  		/* lfs FR0, <#[R1 + 28]> */
		/* 82063904h case    1:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x0000001C) );
		/* 82063904h case    1:*/		return 0x82063908;
	}
	return 0x82063908;
} // Block from 82063900h-82063908h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063908h
// Function 'D3DDevice_SetRenderState_HighPrecisionBlendEnable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063908( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063908) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063908);
		  /* 82063908h */ case    0:  		/* stfs FR0, <#[R3 + 10700]> */
		/* 82063908h case    0:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R3 + 0x000029CC) );
		/* 82063908h case    0:*/		return 0x8206390C;
		  /* 8206390Ch */ case    1:  		/* li R12, 1 */
		/* 8206390Ch case    1:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 8206390Ch case    1:*/		return 0x82063910;
		  /* 82063910h */ case    2:  		/* ld R10, <#[R3 + 32]> */
		/* 82063910h case    2:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R3 + 0x00000020) );
		/* 82063910h case    2:*/		return 0x82063914;
		  /* 82063914h */ case    3:  		/* rldicr R12, R12, 32, 63 */
		/* 82063914h case    3:*/		cpu::op::rldicr<0,32,63>(regs,&regs.R12,regs.R12);
		/* 82063914h case    3:*/		return 0x82063918;
		  /* 82063918h */ case    4:  		/* or R11, R10, R12 */
		/* 82063918h case    4:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R12);
		/* 82063918h case    4:*/		return 0x8206391C;
		  /* 8206391Ch */ case    5:  		/* std R11, <#[R3 + 32]> */
		/* 8206391Ch case    5:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 8206391Ch case    5:*/		return 0x82063920;
		  /* 82063920h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82063920h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063920h case    6:*/		return 0x82063924;
	}
	return 0x82063924;
} // Block from 82063908h-82063924h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82063924h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063924( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063924) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063924);
		  /* 82063924h */ case    0:  		/* nop */
		/* 82063924h case    0:*/		cpu::op::nop();
		/* 82063924h case    0:*/		return 0x82063928;
	}
	return 0x82063928;
} // Block from 82063924h-82063928h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063928h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063928( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063928) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063928);
		  /* 82063928h */ case    0:  		/* lwz R3, <#[R3 + 10700]> */
		/* 82063928h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x000029CC) );
		/* 82063928h case    0:*/		return 0x8206392C;
		  /* 8206392Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 8206392Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206392Ch case    1:*/		return 0x82063930;
	}
	return 0x82063930;
} // Block from 82063928h-82063930h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063930h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063930( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063930) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063930);
		  /* 82063930h */ case    0:  		/* stw R4, <#[R1 + 28]> */
		/* 82063930h case    0:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000001C) );
		/* 82063930h case    0:*/		return 0x82063934;
		  /* 82063934h */ case    1:  		/* lfs FR0, <#[R1 + 28]> */
		/* 82063934h case    1:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x0000001C) );
		/* 82063934h case    1:*/		return 0x82063938;
		  /* 82063938h */ case    2:  		/* stfs FR0, <#[R3 + 10692]> */
		/* 82063938h case    2:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R3 + 0x000029C4) );
		/* 82063938h case    2:*/		return 0x8206393C;
		  /* 8206393Ch */ case    3:  		/* li R12, 1 */
		/* 8206393Ch case    3:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 8206393Ch case    3:*/		return 0x82063940;
		  /* 82063940h */ case    4:  		/* ld R10, <#[R3 + 32]> */
		/* 82063940h case    4:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R3 + 0x00000020) );
		/* 82063940h case    4:*/		return 0x82063944;
		  /* 82063944h */ case    5:  		/* rldicr R12, R12, 34, 63 */
		/* 82063944h case    5:*/		cpu::op::rldicr<0,34,63>(regs,&regs.R12,regs.R12);
		/* 82063944h case    5:*/		return 0x82063948;
		  /* 82063948h */ case    6:  		/* or R11, R10, R12 */
		/* 82063948h case    6:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R12);
		/* 82063948h case    6:*/		return 0x8206394C;
		  /* 8206394Ch */ case    7:  		/* std R11, <#[R3 + 32]> */
		/* 8206394Ch case    7:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 8206394Ch case    7:*/		return 0x82063950;
		  /* 82063950h */ case    8:  		/* bclr 20, CR0_LT */
		/* 82063950h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063950h case    8:*/		return 0x82063954;
	}
	return 0x82063954;
} // Block from 82063930h-82063954h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82063954h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063954( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063954) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063954);
		  /* 82063954h */ case    0:  		/* nop */
		/* 82063954h case    0:*/		cpu::op::nop();
		/* 82063954h case    0:*/		return 0x82063958;
	}
	return 0x82063958;
} // Block from 82063954h-82063958h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063958h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063958( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063958) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063958);
		  /* 82063958h */ case    0:  		/* lwz R3, <#[R3 + 10692]> */
		/* 82063958h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x000029C4) );
		/* 82063958h case    0:*/		return 0x8206395C;
		  /* 8206395Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 8206395Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206395Ch case    1:*/		return 0x82063960;
	}
	return 0x82063960;
} // Block from 82063958h-82063960h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063960h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063960( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063960) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063960);
		  /* 82063960h */ case    0:  		/* stw R4, <#[R1 + 28]> */
		/* 82063960h case    0:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000001C) );
		/* 82063960h case    0:*/		return 0x82063964;
		  /* 82063964h */ case    1:  		/* lfs FR0, <#[R1 + 28]> */
		/* 82063964h case    1:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x0000001C) );
		/* 82063964h case    1:*/		return 0x82063968;
		  /* 82063968h */ case    2:  		/* stfs FR0, <#[R3 + 10704]> */
		/* 82063968h case    2:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R3 + 0x000029D0) );
		/* 82063968h case    2:*/		return 0x8206396C;
		  /* 8206396Ch */ case    3:  		/* ld R11, <#[R3 + 32]> */
		/* 8206396Ch case    3:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 8206396Ch case    3:*/		return 0x82063970;
		  /* 82063970h */ case    4:  		/* oris R11, R11, 32768 */
		/* 82063970h case    4:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8000);
		/* 82063970h case    4:*/		return 0x82063974;
		  /* 82063974h */ case    5:  		/* std R11, <#[R3 + 32]> */
		/* 82063974h case    5:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 82063974h case    5:*/		return 0x82063978;
		  /* 82063978h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82063978h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063978h case    6:*/		return 0x8206397C;
	}
	return 0x8206397C;
} // Block from 82063960h-8206397Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8206397Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206397C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206397C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206397C);
		  /* 8206397Ch */ case    0:  		/* nop */
		/* 8206397Ch case    0:*/		cpu::op::nop();
		/* 8206397Ch case    0:*/		return 0x82063980;
	}
	return 0x82063980;
} // Block from 8206397Ch-82063980h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063980h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063980( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063980) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063980);
		  /* 82063980h */ case    0:  		/* lwz R3, <#[R3 + 10704]> */
		/* 82063980h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x000029D0) );
		/* 82063980h case    0:*/		return 0x82063984;
		  /* 82063984h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82063984h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063984h case    1:*/		return 0x82063988;
	}
	return 0x82063988;
} // Block from 82063980h-82063988h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063988h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063988( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063988) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063988);
		  /* 82063988h */ case    0:  		/* stw R4, <#[R1 + 28]> */
		/* 82063988h case    0:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000001C) );
		/* 82063988h case    0:*/		return 0x8206398C;
		  /* 8206398Ch */ case    1:  		/* lfs FR0, <#[R1 + 28]> */
		/* 8206398Ch case    1:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0x0000001C) );
		/* 8206398Ch case    1:*/		return 0x82063990;
		  /* 82063990h */ case    2:  		/* stfs FR0, <#[R3 + 10696]> */
		/* 82063990h case    2:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R3 + 0x000029C8) );
		/* 82063990h case    2:*/		return 0x82063994;
		  /* 82063994h */ case    3:  		/* li R12, 1 */
		/* 82063994h case    3:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 82063994h case    3:*/		return 0x82063998;
	}
	return 0x82063998;
} // Block from 82063988h-82063998h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82063998h
// Function 'D3DDevice_GetRenderState_HighPrecisionBlendEnable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063998( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063998) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063998);
		  /* 82063998h */ case    0:  		/* ld R10, <#[R3 + 32]> */
		/* 82063998h case    0:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R3 + 0x00000020) );
		/* 82063998h case    0:*/		return 0x8206399C;
		  /* 8206399Ch */ case    1:  		/* rldicr R12, R12, 33, 63 */
		/* 8206399Ch case    1:*/		cpu::op::rldicr<0,33,63>(regs,&regs.R12,regs.R12);
		/* 8206399Ch case    1:*/		return 0x820639A0;
	}
	return 0x820639A0;
} // Block from 82063998h-820639A0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820639A0h
// Function 'D3DDevice_SetRenderState_HighPrecisionBlendEnable1'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820639A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820639A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820639A0);
		  /* 820639A0h */ case    0:  		/* or R11, R10, R12 */
		/* 820639A0h case    0:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R12);
		/* 820639A0h case    0:*/		return 0x820639A4;
		  /* 820639A4h */ case    1:  		/* std R11, <#[R3 + 32]> */
		/* 820639A4h case    1:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 820639A4h case    1:*/		return 0x820639A8;
		  /* 820639A8h */ case    2:  		/* bclr 20, CR0_LT */
		/* 820639A8h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820639A8h case    2:*/		return 0x820639AC;
	}
	return 0x820639AC;
} // Block from 820639A0h-820639ACh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820639ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820639AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820639AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820639AC);
		  /* 820639ACh */ case    0:  		/* nop */
		/* 820639ACh case    0:*/		cpu::op::nop();
		/* 820639ACh case    0:*/		return 0x820639B0;
	}
	return 0x820639B0;
} // Block from 820639ACh-820639B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820639B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820639B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820639B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820639B0);
		  /* 820639B0h */ case    0:  		/* lwz R3, <#[R3 + 10696]> */
		/* 820639B0h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x000029C8) );
		/* 820639B0h case    0:*/		return 0x820639B4;
		  /* 820639B4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820639B4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820639B4h case    1:*/		return 0x820639B8;
	}
	return 0x820639B8;
} // Block from 820639B0h-820639B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820639B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820639B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820639B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820639B8);
		  /* 820639B8h */ case    0:  		/* lwz R11, <#[R3 + 12284]> */
		/* 820639B8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002FFC) );
		/* 820639B8h case    0:*/		return 0x820639BC;
		  /* 820639BCh */ case    1:  		/* rlwimi R11, R4, 20, 9, 11 */
		/* 820639BCh case    1:*/		cpu::op::rlwimi<0,20,9,11>(regs,&regs.R11,regs.R4);
		/* 820639BCh case    1:*/		return 0x820639C0;
		  /* 820639C0h */ case    2:  		/* stw R11, <#[R3 + 12284]> */
		/* 820639C0h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002FFC) );
		/* 820639C0h case    2:*/		return 0x820639C4;
		  /* 820639C4h */ case    3:  		/* ld R11, <#[R3 + 16]> */
		/* 820639C4h case    3:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820639C4h case    3:*/		return 0x820639C8;
		  /* 820639C8h */ case    4:  		/* oris R11, R11, 2 */
		/* 820639C8h case    4:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x2);
		/* 820639C8h case    4:*/		return 0x820639CC;
		  /* 820639CCh */ case    5:  		/* std R11, <#[R3 + 16]> */
		/* 820639CCh case    5:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820639CCh case    5:*/		return 0x820639D0;
		  /* 820639D0h */ case    6:  		/* bclr 20, CR0_LT */
		/* 820639D0h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820639D0h case    6:*/		return 0x820639D4;
	}
	return 0x820639D4;
} // Block from 820639B8h-820639D4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820639D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820639D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820639D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820639D4);
		  /* 820639D4h */ case    0:  		/* nop */
		/* 820639D4h case    0:*/		cpu::op::nop();
		/* 820639D4h case    0:*/		return 0x820639D8;
	}
	return 0x820639D8;
} // Block from 820639D4h-820639D8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820639D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820639D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820639D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820639D8);
		  /* 820639D8h */ case    0:  		/* lwz R11, <#[R3 + 12284]> */
		/* 820639D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002FFC) );
		/* 820639D8h case    0:*/		return 0x820639DC;
		  /* 820639DCh */ case    1:  		/* rlwinm R3, R11, 12, 29, 31 */
		/* 820639DCh case    1:*/		cpu::op::rlwinm<0,12,29,31>(regs,&regs.R3,regs.R11);
		/* 820639DCh case    1:*/		return 0x820639E0;
		  /* 820639E0h */ case    2:  		/* bclr 20, CR0_LT */
		/* 820639E0h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820639E0h case    2:*/		return 0x820639E4;
	}
	return 0x820639E4;
} // Block from 820639D8h-820639E4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820639E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820639E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820639E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820639E4);
		  /* 820639E4h */ case    0:  		/* nop */
		/* 820639E4h case    0:*/		cpu::op::nop();
		/* 820639E4h case    0:*/		return 0x820639E8;
	}
	return 0x820639E8;
} // Block from 820639E4h-820639E8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820639E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820639E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820639E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820639E8);
		  /* 820639E8h */ case    0:  		/* lwz R11, <#[R3 + 12284]> */
		/* 820639E8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002FFC) );
		/* 820639E8h case    0:*/		return 0x820639EC;
		  /* 820639ECh */ case    1:  		/* lbz R10, <#[R3 + 11071]> */
		/* 820639ECh case    1:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R3 + 0x00002B3F) );
		/* 820639ECh case    1:*/		return 0x820639F0;
		  /* 820639F0h */ case    2:  		/* rlwimi R11, R4, 17, 12, 14 */
		/* 820639F0h case    2:*/		cpu::op::rlwimi<0,17,12,14>(regs,&regs.R11,regs.R4);
		/* 820639F0h case    2:*/		return 0x820639F4;
		  /* 820639F4h */ case    3:  		/* rlwinm. R10, R10, 0, 26, 26 */
		/* 820639F4h case    3:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R10,regs.R10);
		/* 820639F4h case    3:*/		return 0x820639F8;
		  /* 820639F8h */ case    4:  		/* stw R11, <#[R3 + 12284]> */
		/* 820639F8h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002FFC) );
		/* 820639F8h case    4:*/		return 0x820639FC;
		  /* 820639FCh */ case    5:  		/* bc 4, CR0_EQ, 36 */
		/* 820639FCh case    5:*/		if ( !regs.CR[0].eq ) { return 0x82063A20;  }
		/* 820639FCh case    5:*/		return 0x82063A00;
		  /* 82063A00h */ case    6:  		/* rlwinm R11, R11, 0, 12, 14 */
		/* 82063A00h case    6:*/		cpu::op::rlwinm<0,0,12,14>(regs,&regs.R11,regs.R11);
		/* 82063A00h case    6:*/		return 0x82063A04;
		  /* 82063A04h */ case    7:  		/* lis R10, 4 */
		/* 82063A04h case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0x4);
		/* 82063A04h case    7:*/		return 0x82063A08;
		  /* 82063A08h */ case    8:  		/* cmplw CR6, R11, R10 */
		/* 82063A08h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82063A08h case    8:*/		return 0x82063A0C;
		  /* 82063A0Ch */ case    9:  		/* bc 4, CR6_EQ, 20 */
		/* 82063A0Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x82063A20;  }
		/* 82063A0Ch case    9:*/		return 0x82063A10;
		  /* 82063A10h */ case   10:  		/* ld R11, <#[R3 + 40]> */
		/* 82063A10h case   10:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000028) );
		/* 82063A10h case   10:*/		return 0x82063A14;
		  /* 82063A14h */ case   11:  		/* li R12, -257 */
		/* 82063A14h case   11:*/		cpu::op::li<0>(regs,&regs.R12,0xFFFFFEFF);
		/* 82063A14h case   11:*/		return 0x82063A18;
		  /* 82063A18h */ case   12:  		/* and R11, R11, R12 */
		/* 82063A18h case   12:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 82063A18h case   12:*/		return 0x82063A1C;
		  /* 82063A1Ch */ case   13:  		/* b 12 */
		/* 82063A1Ch case   13:*/		return 0x82063A28;
		/* 82063A1Ch case   13:*/		return 0x82063A20;
	}
	return 0x82063A20;
} // Block from 820639E8h-82063A20h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82063A20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063A20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063A20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063A20);
		  /* 82063A20h */ case    0:  		/* ld R11, <#[R3 + 40]> */
		/* 82063A20h case    0:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000028) );
		/* 82063A20h case    0:*/		return 0x82063A24;
		  /* 82063A24h */ case    1:  		/* ori R11, R11, 256 */
		/* 82063A24h case    1:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x100);
		/* 82063A24h case    1:*/		return 0x82063A28;
	}
	return 0x82063A28;
} // Block from 82063A20h-82063A28h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063A28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063A28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063A28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063A28);
		  /* 82063A28h */ case    0:  		/* std R11, <#[R3 + 40]> */
		/* 82063A28h case    0:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000028) );
		/* 82063A28h case    0:*/		return 0x82063A2C;
		  /* 82063A2Ch */ case    1:  		/* ld R11, <#[R3 + 16]> */
		/* 82063A2Ch case    1:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82063A2Ch case    1:*/		return 0x82063A30;
	}
	return 0x82063A30;
} // Block from 82063A28h-82063A30h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063A30h
// Function 'D3DDevice_GetRenderState_HighPrecisionBlendEnable1'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063A30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063A30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063A30);
		  /* 82063A30h */ case    0:  		/* ori R11, R11, 256 */
		/* 82063A30h case    0:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x100);
		/* 82063A30h case    0:*/		return 0x82063A34;
		  /* 82063A34h */ case    1:  		/* std R11, <#[R3 + 16]> */
		/* 82063A34h case    1:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82063A34h case    1:*/		return 0x82063A38;
	}
	return 0x82063A38;
} // Block from 82063A30h-82063A38h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063A38h
// Function 'D3DDevice_SetRenderState_HighPrecisionBlendEnable2'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063A38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063A38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063A38);
		  /* 82063A38h */ case    0:  		/* bclr 20, CR0_LT */
		/* 82063A38h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063A38h case    0:*/		return 0x82063A3C;
	}
	return 0x82063A3C;
} // Block from 82063A38h-82063A3Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063A3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063A3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063A3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063A3C);
		  /* 82063A3Ch */ case    0:  		/* nop */
		/* 82063A3Ch case    0:*/		cpu::op::nop();
		/* 82063A3Ch case    0:*/		return 0x82063A40;
	}
	return 0x82063A40;
} // Block from 82063A3Ch-82063A40h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063A40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063A40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063A40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063A40);
		  /* 82063A40h */ case    0:  		/* lwz R11, <#[R3 + 12284]> */
		/* 82063A40h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002FFC) );
		/* 82063A40h case    0:*/		return 0x82063A44;
		  /* 82063A44h */ case    1:  		/* rlwinm R3, R11, 15, 29, 31 */
		/* 82063A44h case    1:*/		cpu::op::rlwinm<0,15,29,31>(regs,&regs.R3,regs.R11);
		/* 82063A44h case    1:*/		return 0x82063A48;
		  /* 82063A48h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82063A48h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063A48h case    2:*/		return 0x82063A4C;
	}
	return 0x82063A4C;
} // Block from 82063A40h-82063A4Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82063A4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063A4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063A4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063A4C);
		  /* 82063A4Ch */ case    0:  		/* nop */
		/* 82063A4Ch case    0:*/		cpu::op::nop();
		/* 82063A4Ch case    0:*/		return 0x82063A50;
	}
	return 0x82063A50;
} // Block from 82063A4Ch-82063A50h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063A50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063A50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063A50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063A50);
		  /* 82063A50h */ case    0:  		/* lwz R11, <#[R3 + 10560]> */
		/* 82063A50h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002940) );
		/* 82063A50h case    0:*/		return 0x82063A54;
		  /* 82063A54h */ case    1:  		/* rlwimi R11, R4, 3, 28, 28 */
		/* 82063A54h case    1:*/		cpu::op::rlwimi<0,3,28,28>(regs,&regs.R11,regs.R4);
		/* 82063A54h case    1:*/		return 0x82063A58;
		  /* 82063A58h */ case    2:  		/* stw R11, <#[R3 + 10560]> */
		/* 82063A58h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002940) );
		/* 82063A58h case    2:*/		return 0x82063A5C;
		  /* 82063A5Ch */ case    3:  		/* ld R11, <#[R3 + 16]> */
		/* 82063A5Ch case    3:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82063A5Ch case    3:*/		return 0x82063A60;
		  /* 82063A60h */ case    4:  		/* ori R11, R11, 256 */
		/* 82063A60h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x100);
		/* 82063A60h case    4:*/		return 0x82063A64;
		  /* 82063A64h */ case    5:  		/* std R11, <#[R3 + 16]> */
		/* 82063A64h case    5:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82063A64h case    5:*/		return 0x82063A68;
		  /* 82063A68h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82063A68h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063A68h case    6:*/		return 0x82063A6C;
	}
	return 0x82063A6C;
} // Block from 82063A50h-82063A6Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 82063A6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063A6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063A6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063A6C);
		  /* 82063A6Ch */ case    0:  		/* nop */
		/* 82063A6Ch case    0:*/		cpu::op::nop();
		/* 82063A6Ch case    0:*/		return 0x82063A70;
	}
	return 0x82063A70;
} // Block from 82063A6Ch-82063A70h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063A70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063A70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063A70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063A70);
		  /* 82063A70h */ case    0:  		/* lwz R11, <#[R3 + 10560]> */
		/* 82063A70h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002940) );
		/* 82063A70h case    0:*/		return 0x82063A74;
		  /* 82063A74h */ case    1:  		/* rlwinm R3, R11, 29, 31, 31 */
		/* 82063A74h case    1:*/		cpu::op::rlwinm<0,29,31,31>(regs,&regs.R3,regs.R11);
		/* 82063A74h case    1:*/		return 0x82063A78;
		  /* 82063A78h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82063A78h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063A78h case    2:*/		return 0x82063A7C;
	}
	return 0x82063A7C;
} // Block from 82063A70h-82063A7Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82063A7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063A7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063A7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063A7C);
		  /* 82063A7Ch */ case    0:  		/* nop */
		/* 82063A7Ch case    0:*/		cpu::op::nop();
		/* 82063A7Ch case    0:*/		return 0x82063A80;
	}
	return 0x82063A80;
} // Block from 82063A7Ch-82063A80h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063A80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063A80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063A80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063A80);
		  /* 82063A80h */ case    0:  		/* lwz R11, <#[R3 + 10560]> */
		/* 82063A80h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002940) );
		/* 82063A80h case    0:*/		return 0x82063A84;
		  /* 82063A84h */ case    1:  		/* rlwimi R11, R4, 2, 29, 29 */
		/* 82063A84h case    1:*/		cpu::op::rlwimi<0,2,29,29>(regs,&regs.R11,regs.R4);
		/* 82063A84h case    1:*/		return 0x82063A88;
		  /* 82063A88h */ case    2:  		/* stw R11, <#[R3 + 10560]> */
		/* 82063A88h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002940) );
		/* 82063A88h case    2:*/		return 0x82063A8C;
		  /* 82063A8Ch */ case    3:  		/* ld R11, <#[R3 + 16]> */
		/* 82063A8Ch case    3:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82063A8Ch case    3:*/		return 0x82063A90;
		  /* 82063A90h */ case    4:  		/* ori R11, R11, 256 */
		/* 82063A90h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x100);
		/* 82063A90h case    4:*/		return 0x82063A94;
		  /* 82063A94h */ case    5:  		/* std R11, <#[R3 + 16]> */
		/* 82063A94h case    5:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82063A94h case    5:*/		return 0x82063A98;
		  /* 82063A98h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82063A98h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063A98h case    6:*/		return 0x82063A9C;
	}
	return 0x82063A9C;
} // Block from 82063A80h-82063A9Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 82063A9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063A9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063A9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063A9C);
		  /* 82063A9Ch */ case    0:  		/* nop */
		/* 82063A9Ch case    0:*/		cpu::op::nop();
		/* 82063A9Ch case    0:*/		return 0x82063AA0;
	}
	return 0x82063AA0;
} // Block from 82063A9Ch-82063AA0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063AA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063AA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063AA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063AA0);
		  /* 82063AA0h */ case    0:  		/* lwz R11, <#[R3 + 10560]> */
		/* 82063AA0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002940) );
		/* 82063AA0h case    0:*/		return 0x82063AA4;
		  /* 82063AA4h */ case    1:  		/* rlwinm R3, R11, 30, 31, 31 */
		/* 82063AA4h case    1:*/		cpu::op::rlwinm<0,30,31,31>(regs,&regs.R3,regs.R11);
		/* 82063AA4h case    1:*/		return 0x82063AA8;
		  /* 82063AA8h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82063AA8h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063AA8h case    2:*/		return 0x82063AAC;
	}
	return 0x82063AAC;
} // Block from 82063AA0h-82063AACh (3 instructions)

//////////////////////////////////////////////////////
// Block at 82063AACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063AAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063AAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063AAC);
		  /* 82063AACh */ case    0:  		/* nop */
		/* 82063AACh case    0:*/		cpu::op::nop();
		/* 82063AACh case    0:*/		return 0x82063AB0;
	}
	return 0x82063AB0;
} // Block from 82063AACh-82063AB0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063AB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063AB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063AB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063AB0);
		  /* 82063AB0h */ case    0:  		/* lwz R11, <#[R3 + 10560]> */
		/* 82063AB0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002940) );
		/* 82063AB0h case    0:*/		return 0x82063AB4;
		  /* 82063AB4h */ case    1:  		/* rlwimi R11, R4, 5, 26, 26 */
		/* 82063AB4h case    1:*/		cpu::op::rlwimi<0,5,26,26>(regs,&regs.R11,regs.R4);
		/* 82063AB4h case    1:*/		return 0x82063AB8;
		  /* 82063AB8h */ case    2:  		/* stw R11, <#[R3 + 10560]> */
		/* 82063AB8h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002940) );
		/* 82063AB8h case    2:*/		return 0x82063ABC;
		  /* 82063ABCh */ case    3:  		/* ld R11, <#[R3 + 16]> */
		/* 82063ABCh case    3:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82063ABCh case    3:*/		return 0x82063AC0;
		  /* 82063AC0h */ case    4:  		/* ori R11, R11, 256 */
		/* 82063AC0h case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x100);
		/* 82063AC0h case    4:*/		return 0x82063AC4;
		  /* 82063AC4h */ case    5:  		/* std R11, <#[R3 + 16]> */
		/* 82063AC4h case    5:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82063AC4h case    5:*/		return 0x82063AC8;
	}
	return 0x82063AC8;
} // Block from 82063AB0h-82063AC8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82063AC8h
// Function 'D3DDevice_GetRenderState_HighPrecisionBlendEnable2'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063AC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063AC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063AC8);
		  /* 82063AC8h */ case    0:  		/* bclr 20, CR0_LT */
		/* 82063AC8h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063AC8h case    0:*/		return 0x82063ACC;
	}
	return 0x82063ACC;
} // Block from 82063AC8h-82063ACCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063ACCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063ACC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063ACC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063ACC);
		  /* 82063ACCh */ case    0:  		/* nop */
		/* 82063ACCh case    0:*/		cpu::op::nop();
		/* 82063ACCh case    0:*/		return 0x82063AD0;
	}
	return 0x82063AD0;
} // Block from 82063ACCh-82063AD0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063AD0h
// Function 'D3DDevice_SetRenderState_HighPrecisionBlendEnable3'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063AD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063AD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063AD0);
		  /* 82063AD0h */ case    0:  		/* lwz R11, <#[R3 + 10560]> */
		/* 82063AD0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002940) );
		/* 82063AD0h case    0:*/		return 0x82063AD4;
		  /* 82063AD4h */ case    1:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 82063AD4h case    1:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 82063AD4h case    1:*/		return 0x82063AD8;
		  /* 82063AD8h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82063AD8h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063AD8h case    2:*/		return 0x82063ADC;
	}
	return 0x82063ADC;
} // Block from 82063AD0h-82063ADCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 82063ADCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063ADC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063ADC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063ADC);
		  /* 82063ADCh */ case    0:  		/* nop */
		/* 82063ADCh case    0:*/		cpu::op::nop();
		/* 82063ADCh case    0:*/		return 0x82063AE0;
	}
	return 0x82063AE0;
} // Block from 82063ADCh-82063AE0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063AE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063AE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063AE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063AE0);
		  /* 82063AE0h */ case    0:  		/* stb R4, <#[R3 + 10562]> */
		/* 82063AE0h case    0:*/		cpu::mem::store8( regs, regs.R4, (uint32)(regs.R3 + 0x00002942) );
		/* 82063AE0h case    0:*/		return 0x82063AE4;
		  /* 82063AE4h */ case    1:  		/* ld R11, <#[R3 + 16]> */
		/* 82063AE4h case    1:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82063AE4h case    1:*/		return 0x82063AE8;
		  /* 82063AE8h */ case    2:  		/* ori R11, R11, 256 */
		/* 82063AE8h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x100);
		/* 82063AE8h case    2:*/		return 0x82063AEC;
		  /* 82063AECh */ case    3:  		/* std R11, <#[R3 + 16]> */
		/* 82063AECh case    3:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82063AECh case    3:*/		return 0x82063AF0;
		  /* 82063AF0h */ case    4:  		/* bclr 20, CR0_LT */
		/* 82063AF0h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063AF0h case    4:*/		return 0x82063AF4;
	}
	return 0x82063AF4;
} // Block from 82063AE0h-82063AF4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82063AF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063AF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063AF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063AF4);
		  /* 82063AF4h */ case    0:  		/* nop */
		/* 82063AF4h case    0:*/		cpu::op::nop();
		/* 82063AF4h case    0:*/		return 0x82063AF8;
	}
	return 0x82063AF8;
} // Block from 82063AF4h-82063AF8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063AF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063AF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063AF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063AF8);
		  /* 82063AF8h */ case    0:  		/* lbz R3, <#[R3 + 10562]> */
		/* 82063AF8h case    0:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R3 + 0x00002942) );
		/* 82063AF8h case    0:*/		return 0x82063AFC;
		  /* 82063AFCh */ case    1:  		/* bclr 20, CR0_LT */
		/* 82063AFCh case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063AFCh case    1:*/		return 0x82063B00;
	}
	return 0x82063B00;
} // Block from 82063AF8h-82063B00h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063B00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063B00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063B00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063B00);
		  /* 82063B00h */ case    0:  		/* stw R4, <#[R3 + 14000]> */
		/* 82063B00h case    0:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x000036B0) );
		/* 82063B00h case    0:*/		return 0x82063B04;
		  /* 82063B04h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82063B04h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063B04h case    1:*/		return 0x82063B08;
	}
	return 0x82063B08;
} // Block from 82063B00h-82063B08h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063B08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063B08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063B08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063B08);
		  /* 82063B08h */ case    0:  		/* lwz R3, <#[R3 + 14000]> */
		/* 82063B08h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x000036B0) );
		/* 82063B08h case    0:*/		return 0x82063B0C;
		  /* 82063B0Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 82063B0Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063B0Ch case    1:*/		return 0x82063B10;
	}
	return 0x82063B10;
} // Block from 82063B08h-82063B10h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063B10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063B10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063B10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063B10);
		  /* 82063B10h */ case    0:  		/* lwz R11, <#[R3 + 12284]> */
		/* 82063B10h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002FFC) );
		/* 82063B10h case    0:*/		return 0x82063B14;
		  /* 82063B14h */ case    1:  		/* rlwimi R11, R4, 23, 2, 8 */
		/* 82063B14h case    1:*/		cpu::op::rlwimi<0,23,2,8>(regs,&regs.R11,regs.R4);
		/* 82063B14h case    1:*/		return 0x82063B18;
		  /* 82063B18h */ case    2:  		/* stw R11, <#[R3 + 12284]> */
		/* 82063B18h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002FFC) );
		/* 82063B18h case    2:*/		return 0x82063B1C;
		  /* 82063B1Ch */ case    3:  		/* bclr 20, CR0_LT */
		/* 82063B1Ch case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063B1Ch case    3:*/		return 0x82063B20;
	}
	return 0x82063B20;
} // Block from 82063B10h-82063B20h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82063B20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063B20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063B20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063B20);
		  /* 82063B20h */ case    0:  		/* lwz R11, <#[R3 + 12284]> */
		/* 82063B20h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002FFC) );
		/* 82063B20h case    0:*/		return 0x82063B24;
		  /* 82063B24h */ case    1:  		/* rlwinm R3, R11, 9, 25, 31 */
		/* 82063B24h case    1:*/		cpu::op::rlwinm<0,9,25,31>(regs,&regs.R3,regs.R11);
		/* 82063B24h case    1:*/		return 0x82063B28;
		  /* 82063B28h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82063B28h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063B28h case    2:*/		return 0x82063B2C;
	}
	return 0x82063B2C;
} // Block from 82063B20h-82063B2Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82063B2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063B2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063B2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063B2C);
		  /* 82063B2Ch */ case    0:  		/* nop */
		/* 82063B2Ch case    0:*/		cpu::op::nop();
		/* 82063B2Ch case    0:*/		return 0x82063B30;
	}
	return 0x82063B30;
} // Block from 82063B2Ch-82063B30h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063B30h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063B30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063B30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063B30);
		  /* 82063B30h */ case    0:  		/* mfspr R12, LR */
		/* 82063B30h case    0:*/		regs.R12 = regs.LR;
		/* 82063B30h case    0:*/		return 0x82063B34;
		  /* 82063B34h */ case    1:  		/* bl 186152 */
		/* 82063B34h case    1:*/		regs.LR = 0x82063B38; return 0x8209125C;
		/* 82063B34h case    1:*/		return 0x82063B38;
		  /* 82063B38h */ case    2:  		/* addi R11, R4, 48 */
		/* 82063B38h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x30);
		/* 82063B38h case    2:*/		return 0x82063B3C;
		  /* 82063B3Ch */ case    3:  		/* add R10, R3, R4 */
		/* 82063B3Ch case    3:*/		cpu::op::add<0>(regs,&regs.R10,regs.R3,regs.R4);
		/* 82063B3Ch case    3:*/		return 0x82063B40;
		  /* 82063B40h */ case    4:  		/* mulli R11, R11, 24 */
		/* 82063B40h case    4:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x18);
		/* 82063B40h case    4:*/		return 0x82063B44;
		  /* 82063B44h */ case    5:  		/* lbz R9, <#[R10 + 10864]> */
		/* 82063B44h case    5:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R10 + 0x00002A70) );
		/* 82063B44h case    5:*/		return 0x82063B48;
		  /* 82063B48h */ case    6:  		/* add R11, R11, R3 */
		/* 82063B48h case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 82063B48h case    6:*/		return 0x82063B4C;
		  /* 82063B4Ch */ case    7:  		/* lis R8, -32256 */
		/* 82063B4Ch case    7:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8200);
		/* 82063B4Ch case    7:*/		return 0x82063B50;
		  /* 82063B50h */ case    8:  		/* rlwinm R9, R9, 2, 0, 31 */
		/* 82063B50h case    8:*/		cpu::op::rlwinm<0,2,0,31>(regs,&regs.R9,regs.R9);
		/* 82063B50h case    8:*/		return 0x82063B54;
		  /* 82063B54h */ case    9:  		/* addi R8, R8, 2896 */
		/* 82063B54h case    9:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xB50);
		/* 82063B54h case    9:*/		return 0x82063B58;
		  /* 82063B58h */ case   10:  		/* rlwinm R7, R5, 30, 2, 31 */
		/* 82063B58h case   10:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R7,regs.R5);
		/* 82063B58h case   10:*/		return 0x82063B5C;
		  /* 82063B5Ch */ case   11:  		/* lwz R6, <#[R11 + 16]> */
		/* 82063B5Ch case   11:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000010) );
		/* 82063B5Ch case   11:*/		return 0x82063B60;
	}
	return 0x82063B60;
} // Block from 82063B30h-82063B60h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82063B60h
// Function 'D3DDevice_GetRenderState_HighPrecisionBlendEnable3'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063B60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063B60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063B60);
		  /* 82063B60h */ case    0:  		/* addi R4, R4, 32 */
		/* 82063B60h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x20);
		/* 82063B60h case    0:*/		return 0x82063B64;
		  /* 82063B64h */ case    1:  		/* lwz R31, <#[R11 + 12]> */
		/* 82063B64h case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x0000000C) );
		/* 82063B64h case    1:*/		return 0x82063B68;
	}
	return 0x82063B68;
} // Block from 82063B60h-82063B68h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063B68h
// Function 'D3DDevice_SetRenderState_MinTessellationLevel'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063B68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063B68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063B68);
		  /* 82063B68h */ case    0:  		/* li R30, 1 */
		/* 82063B68h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 82063B68h case    0:*/		return 0x82063B6C;
		  /* 82063B6Ch */ case    1:  		/* mr R29, R6 */
		/* 82063B6Ch case    1:*/		regs.R29 = regs.R6;
		/* 82063B6Ch case    1:*/		return 0x82063B70;
		  /* 82063B70h */ case    2:  		/* rlwinm R6, R6, 22, 31, 31 */
		/* 82063B70h case    2:*/		cpu::op::rlwinm<0,22,31,31>(regs,&regs.R6,regs.R6);
		/* 82063B70h case    2:*/		return 0x82063B74;
		  /* 82063B74h */ case    3:  		/* lwzx R8, <#[R9 + R8]> */
		/* 82063B74h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 82063B74h case    3:*/		return 0x82063B78;
		  /* 82063B78h */ case    4:  		/* rlwimi R29, R7, 11, 20, 20 */
		/* 82063B78h case    4:*/		cpu::op::rlwimi<0,11,20,20>(regs,&regs.R29,regs.R7);
		/* 82063B78h case    4:*/		return 0x82063B7C;
		  /* 82063B7Ch */ case    5:  		/* or R9, R6, R7 */
		/* 82063B7Ch case    5:*/		cpu::op::or<0>(regs,&regs.R9,regs.R6,regs.R7);
		/* 82063B7Ch case    5:*/		return 0x82063B80;
		  /* 82063B80h */ case    6:  		/* stw R29, <#[R11 + 16]> */
		/* 82063B80h case    6:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000010) );
		/* 82063B80h case    6:*/		return 0x82063B84;
		  /* 82063B84h */ case    7:  		/* rldicr R6, R30, 63, 63 */
		/* 82063B84h case    7:*/		cpu::op::rldicr<0,63,63>(regs,&regs.R6,regs.R30);
		/* 82063B84h case    7:*/		return 0x82063B88;
		  /* 82063B88h */ case    8:  		/* addi R9, R9, -1 */
		/* 82063B88h case    8:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 82063B88h case    8:*/		return 0x82063B8C;
		  /* 82063B8Ch */ case    9:  		/* andc R9, R8, R9 */
		/* 82063B8Ch case    9:*/		cpu::op::andc<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 82063B8Ch case    9:*/		return 0x82063B90;
	}
	return 0x82063B90;
} // Block from 82063B68h-82063B90h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82063B90h
// Function 'D3DDevice_GetRenderState_MinTessellationLevel'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063B90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063B90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063B90);
		  /* 82063B90h */ case    0:  		/* rldicl R8, R4, 0, 32 */
		/* 82063B90h case    0:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R8,regs.R4);
		/* 82063B90h case    0:*/		return 0x82063B94;
		  /* 82063B94h */ case    1:  		/* rlwinm R9, R9, 4, 0, 27 */
		/* 82063B94h case    1:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R9,regs.R9);
		/* 82063B94h case    1:*/		return 0x82063B98;
		  /* 82063B98h */ case    2:  		/* srd R8, R6, R8 */
		/* 82063B98h case    2:*/		cpu::op::srd<0>(regs,&regs.R8,regs.R6,regs.R8);
		/* 82063B98h case    2:*/		return 0x82063B9C;
		  /* 82063B9Ch */ case    3:  		/* or R9, R9, R7 */
		/* 82063B9Ch case    3:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 82063B9Ch case    3:*/		return 0x82063BA0;
	}
	return 0x82063BA0;
} // Block from 82063B90h-82063BA0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82063BA0h
// Function 'D3DDevice_SetRenderState_MaxTessellationLevel'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063BA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063BA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063BA0);
		  /* 82063BA0h */ case    0:  		/* or R9, R9, R5 */
		/* 82063BA0h case    0:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R5);
		/* 82063BA0h case    0:*/		return 0x82063BA4;
		  /* 82063BA4h */ case    1:  		/* rlwimi R31, R9, 21, 9, 10 */
		/* 82063BA4h case    1:*/		cpu::op::rlwimi<0,21,9,10>(regs,&regs.R31,regs.R9);
		/* 82063BA4h case    1:*/		return 0x82063BA8;
		  /* 82063BA8h */ case    2:  		/* rlwimi R31, R9, 21, 4, 6 */
		/* 82063BA8h case    2:*/		cpu::op::rlwimi<0,21,4,6>(regs,&regs.R31,regs.R9);
		/* 82063BA8h case    2:*/		return 0x82063BAC;
		  /* 82063BACh */ case    3:  		/* stw R31, <#[R11 + 12]> */
		/* 82063BACh case    3:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x0000000C) );
		/* 82063BACh case    3:*/		return 0x82063BB0;
		  /* 82063BB0h */ case    4:  		/* lbz R9, <#[R10 + 10890]> */
		/* 82063BB0h case    4:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R10 + 0x00002A8A) );
		/* 82063BB0h case    4:*/		return 0x82063BB4;
		  /* 82063BB4h */ case    5:  		/* rlwinm R10, R31, 0, 0, 31 */
		/* 82063BB4h case    5:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R31);
		/* 82063BB4h case    5:*/		return 0x82063BB8;
		  /* 82063BB8h */ case    6:  		/* mr R7, R10 */
		/* 82063BB8h case    6:*/		regs.R7 = regs.R10;
		/* 82063BB8h case    6:*/		return 0x82063BBC;
		  /* 82063BBCh */ case    7:  		/* mr R6, R10 */
		/* 82063BBCh case    7:*/		regs.R6 = regs.R10;
		/* 82063BBCh case    7:*/		return 0x82063BC0;
		  /* 82063BC0h */ case    8:  		/* rlwinm R10, R9, 30, 2, 31 */
		/* 82063BC0h case    8:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R10,regs.R9);
		/* 82063BC0h case    8:*/		return 0x82063BC4;
		  /* 82063BC4h */ case    9:  		/* rlwimi R6, R7, 31, 13, 31 */
		/* 82063BC4h case    9:*/		cpu::op::rlwimi<0,31,13,31>(regs,&regs.R6,regs.R7);
		/* 82063BC4h case    9:*/		return 0x82063BC8;
	}
	return 0x82063BC8;
} // Block from 82063BA0h-82063BC8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82063BC8h
// Function 'D3DDevice_GetRenderState_MaxTessellationLevel'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063BC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063BC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063BC8);
		  /* 82063BC8h */ case    0:  		/* addi R10, R10, -1 */
		/* 82063BC8h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82063BC8h case    0:*/		return 0x82063BCC;
		  /* 82063BCCh */ case    1:  		/* rlwimi R6, R7, 31, 1, 11 */
		/* 82063BCCh case    1:*/		cpu::op::rlwimi<0,31,1,11>(regs,&regs.R6,regs.R7);
		/* 82063BCCh case    1:*/		return 0x82063BD0;
		  /* 82063BD0h */ case    2:  		/* andc R9, R9, R10 */
		/* 82063BD0h case    2:*/		cpu::op::andc<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 82063BD0h case    2:*/		return 0x82063BD4;
		  /* 82063BD4h */ case    3:  		/* rlwinm R7, R6, 13, 20, 31 */
		/* 82063BD4h case    3:*/		cpu::op::rlwinm<0,13,20,31>(regs,&regs.R7,regs.R6);
		/* 82063BD4h case    3:*/		return 0x82063BD8;
	}
	return 0x82063BD8;
} // Block from 82063BC8h-82063BD8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82063BD8h
// Function 'D3DDevice_SetRenderState_TessellationMode'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063BD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063BD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063BD8);
		  /* 82063BD8h */ case    0:  		/* and R10, R7, R10 */
		/* 82063BD8h case    0:*/		cpu::op::and<0>(regs,&regs.R10,regs.R7,regs.R10);
		/* 82063BD8h case    0:*/		return 0x82063BDC;
		  /* 82063BDCh */ case    1:  		/* add R10, R10, R9 */
		/* 82063BDCh case    1:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82063BDCh case    1:*/		return 0x82063BE0;
		  /* 82063BE0h */ case    2:  		/* rlwimi R10, R29, 0, 0, 29 */
		/* 82063BE0h case    2:*/		cpu::op::rlwimi<0,0,0,29>(regs,&regs.R10,regs.R29);
		/* 82063BE0h case    2:*/		return 0x82063BE4;
		  /* 82063BE4h */ case    3:  		/* stw R10, <#[R11 + 16]> */
		/* 82063BE4h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 82063BE4h case    3:*/		return 0x82063BE8;
		  /* 82063BE8h */ case    4:  		/* ld R11, <#[R3 + 24]> */
		/* 82063BE8h case    4:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82063BE8h case    4:*/		return 0x82063BEC;
		  /* 82063BECh */ case    5:  		/* or R11, R8, R11 */
		/* 82063BECh case    5:*/		cpu::op::or<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 82063BECh case    5:*/		return 0x82063BF0;
		  /* 82063BF0h */ case    6:  		/* std R11, <#[R3 + 24]> */
		/* 82063BF0h case    6:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82063BF0h case    6:*/		return 0x82063BF4;
		  /* 82063BF4h */ case    7:  		/* b 186040 */
		/* 82063BF4h case    7:*/		return 0x820912AC;
		/* 82063BF4h case    7:*/		return 0x82063BF8;
	}
	return 0x82063BF8;
} // Block from 82063BD8h-82063BF8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82063BF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063BF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063BF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063BF8);
		  /* 82063BF8h */ case    0:  		/* addi R11, R4, 48 */
		/* 82063BF8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x30);
		/* 82063BF8h case    0:*/		return 0x82063BFC;
		  /* 82063BFCh */ case    1:  		/* mulli R11, R11, 24 */
		/* 82063BFCh case    1:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x18);
		/* 82063BFCh case    1:*/		return 0x82063C00;
	}
	return 0x82063C00;
} // Block from 82063BF8h-82063C00h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063C00h
// Function 'D3DDevice_GetRenderState_TessellationMode'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063C00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063C00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063C00);
		  /* 82063C00h */ case    0:  		/* add R11, R11, R3 */
		/* 82063C00h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 82063C00h case    0:*/		return 0x82063C04;
		  /* 82063C04h */ case    1:  		/* lwz R10, <#[R11 + 16]> */
		/* 82063C04h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 82063C04h case    1:*/		return 0x82063C08;
		  /* 82063C08h */ case    2:  		/* lwz R9, <#[R11 + 12]> */
		/* 82063C08h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 82063C08h case    2:*/		return 0x82063C0C;
		  /* 82063C0Ch */ case    3:  		/* rlwinm R11, R10, 21, 31, 31 */
		/* 82063C0Ch case    3:*/		cpu::op::rlwinm<0,21,31,31>(regs,&regs.R11,regs.R10);
		/* 82063C0Ch case    3:*/		return 0x82063C10;
	}
	return 0x82063C10;
} // Block from 82063C00h-82063C10h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82063C10h
// Function 'D3DDevice_SetRenderState_HalfPixelOffset'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063C10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063C10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063C10);
		  /* 82063C10h */ case    0:  		/* rlwinm R10, R9, 11, 21, 31 */
		/* 82063C10h case    0:*/		cpu::op::rlwinm<0,11,21,31>(regs,&regs.R10,regs.R9);
		/* 82063C10h case    0:*/		return 0x82063C14;
		  /* 82063C14h */ case    1:  		/* addi R11, R11, -1 */
		/* 82063C14h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82063C14h case    1:*/		return 0x82063C18;
		  /* 82063C18h */ case    2:  		/* and R10, R10, R11 */
		/* 82063C18h case    2:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 82063C18h case    2:*/		return 0x82063C1C;
		  /* 82063C1Ch */ case    3:  		/* nor R11, R11, R11 */
		/* 82063C1Ch case    3:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82063C1Ch case    3:*/		return 0x82063C20;
		  /* 82063C20h */ case    4:  		/* rlwimi R10, R11, 0, 29, 29 */
		/* 82063C20h case    4:*/		cpu::op::rlwimi<0,0,29,29>(regs,&regs.R10,regs.R11);
		/* 82063C20h case    4:*/		return 0x82063C24;
		  /* 82063C24h */ case    5:  		/* rlwinm R3, R10, 0, 29, 31 */
		/* 82063C24h case    5:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R3,regs.R10);
		/* 82063C24h case    5:*/		return 0x82063C28;
		  /* 82063C28h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82063C28h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063C28h case    6:*/		return 0x82063C2C;
	}
	return 0x82063C2C;
} // Block from 82063C10h-82063C2Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 82063C2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063C2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063C2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063C2C);
		  /* 82063C2Ch */ case    0:  		/* nop */
		/* 82063C2Ch case    0:*/		cpu::op::nop();
		/* 82063C2Ch case    0:*/		return 0x82063C30;
	}
	return 0x82063C30;
} // Block from 82063C2Ch-82063C30h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063C30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063C30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063C30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063C30);
		  /* 82063C30h */ case    0:  		/* std R30, <#[R1 - 16]> */
		/* 82063C30h case    0:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82063C30h case    0:*/		return 0x82063C34;
		  /* 82063C34h */ case    1:  		/* std R31, <#[R1 - 8]> */
		/* 82063C34h case    1:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82063C34h case    1:*/		return 0x82063C38;
	}
	return 0x82063C38;
} // Block from 82063C30h-82063C38h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063C38h
// Function 'D3DDevice_GetRenderState_HalfPixelOffset'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063C38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063C38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063C38);
		  /* 82063C38h */ case    0:  		/* add R11, R3, R4 */
		/* 82063C38h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R4);
		/* 82063C38h case    0:*/		return 0x82063C3C;
		  /* 82063C3Ch */ case    1:  		/* addi R10, R4, 48 */
		/* 82063C3Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x30);
		/* 82063C3Ch case    1:*/		return 0x82063C40;
		  /* 82063C40h */ case    2:  		/* rlwinm R8, R5, 1, 0, 30 */
		/* 82063C40h case    2:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R8,regs.R5);
		/* 82063C40h case    2:*/		return 0x82063C44;
		  /* 82063C44h */ case    3:  		/* mulli R10, R10, 24 */
		/* 82063C44h case    3:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x18);
		/* 82063C44h case    3:*/		return 0x82063C48;
	}
	return 0x82063C48;
} // Block from 82063C38h-82063C48h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82063C48h
// Function 'D3DDevice_SetRenderState_PrimitiveResetEnable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063C48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063C48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063C48);
		  /* 82063C48h */ case    0:  		/* lbz R9, <#[R11 + 10890]> */
		/* 82063C48h case    0:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00002A8A) );
		/* 82063C48h case    0:*/		return 0x82063C4C;
		  /* 82063C4Ch */ case    1:  		/* add R10, R10, R3 */
		/* 82063C4Ch case    1:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R3);
		/* 82063C4Ch case    1:*/		return 0x82063C50;
		  /* 82063C50h */ case    2:  		/* rlwinm R9, R9, 0, 31, 29 */
		/* 82063C50h case    2:*/		cpu::op::rlwinm<0,0,31,29>(regs,&regs.R9,regs.R9);
		/* 82063C50h case    2:*/		return 0x82063C54;
		  /* 82063C54h */ case    3:  		/* addi R7, R4, 32 */
		/* 82063C54h case    3:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R4,0x20);
		/* 82063C54h case    3:*/		return 0x82063C58;
		  /* 82063C58h */ case    4:  		/* or R6, R9, R8 */
		/* 82063C58h case    4:*/		cpu::op::or<0>(regs,&regs.R6,regs.R9,regs.R8);
		/* 82063C58h case    4:*/		return 0x82063C5C;
		  /* 82063C5Ch */ case    5:  		/* li R5, 1 */
		/* 82063C5Ch case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82063C5Ch case    5:*/		return 0x82063C60;
		  /* 82063C60h */ case    6:  		/* lwz R8, <#[R10 + 12]> */
		/* 82063C60h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x0000000C) );
		/* 82063C60h case    6:*/		return 0x82063C64;
		  /* 82063C64h */ case    7:  		/* rlwinm R9, R6, 30, 2, 31 */
		/* 82063C64h case    7:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R9,regs.R6);
		/* 82063C64h case    7:*/		return 0x82063C68;
	}
	return 0x82063C68;
} // Block from 82063C48h-82063C68h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82063C68h
// Function 'D3DDevice_GetRenderState_PrimitiveResetEnable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063C68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063C68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063C68);
		  /* 82063C68h */ case    0:  		/* lwz R4, <#[R10 + 16]> */
		/* 82063C68h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000010) );
		/* 82063C68h case    0:*/		return 0x82063C6C;
		  /* 82063C6Ch */ case    1:  		/* rldicr R5, R5, 63, 63 */
		/* 82063C6Ch case    1:*/		cpu::op::rldicr<0,63,63>(regs,&regs.R5,regs.R5);
		/* 82063C6Ch case    1:*/		return 0x82063C70;
		  /* 82063C70h */ case    2:  		/* mr R31, R8 */
		/* 82063C70h case    2:*/		regs.R31 = regs.R8;
		/* 82063C70h case    2:*/		return 0x82063C74;
		  /* 82063C74h */ case    3:  		/* mr R30, R8 */
		/* 82063C74h case    3:*/		regs.R30 = regs.R8;
		/* 82063C74h case    3:*/		return 0x82063C78;
	}
	return 0x82063C78;
} // Block from 82063C68h-82063C78h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82063C78h
// Function 'D3DDevice_SetRenderState_PrimitiveResetIndex'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063C78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063C78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063C78);
		  /* 82063C78h */ case    0:  		/* addi R9, R9, -1 */
		/* 82063C78h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 82063C78h case    0:*/		return 0x82063C7C;
		  /* 82063C7Ch */ case    1:  		/* rlwimi R30, R31, 31, 13, 31 */
		/* 82063C7Ch case    1:*/		cpu::op::rlwimi<0,31,13,31>(regs,&regs.R30,regs.R31);
		/* 82063C7Ch case    1:*/		return 0x82063C80;
		  /* 82063C80h */ case    2:  		/* andc R8, R6, R9 */
		/* 82063C80h case    2:*/		cpu::op::andc<0>(regs,&regs.R8,regs.R6,regs.R9);
		/* 82063C80h case    2:*/		return 0x82063C84;
		  /* 82063C84h */ case    3:  		/* rlwimi R30, R31, 31, 1, 11 */
		/* 82063C84h case    3:*/		cpu::op::rlwimi<0,31,1,11>(regs,&regs.R30,regs.R31);
		/* 82063C84h case    3:*/		return 0x82063C88;
		  /* 82063C88h */ case    4:  		/* rldicl R7, R7, 0, 32 */
		/* 82063C88h case    4:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R7,regs.R7);
		/* 82063C88h case    4:*/		return 0x82063C8C;
		  /* 82063C8Ch */ case    5:  		/* rlwinm R31, R30, 13, 20, 31 */
		/* 82063C8Ch case    5:*/		cpu::op::rlwinm<0,13,20,31>(regs,&regs.R31,regs.R30);
		/* 82063C8Ch case    5:*/		return 0x82063C90;
		  /* 82063C90h */ case    6:  		/* srd R7, R5, R7 */
		/* 82063C90h case    6:*/		cpu::op::srd<0>(regs,&regs.R7,regs.R5,regs.R7);
		/* 82063C90h case    6:*/		return 0x82063C94;
		  /* 82063C94h */ case    7:  		/* and R9, R31, R9 */
		/* 82063C94h case    7:*/		cpu::op::and<0>(regs,&regs.R9,regs.R31,regs.R9);
		/* 82063C94h case    7:*/		return 0x82063C98;
	}
	return 0x82063C98;
} // Block from 82063C78h-82063C98h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82063C98h
// Function 'D3DDevice_GetRenderState_PrimitiveResetIndex'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063C98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063C98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063C98);
		  /* 82063C98h */ case    0:  		/* add R8, R9, R8 */
		/* 82063C98h case    0:*/		cpu::op::add<0>(regs,&regs.R8,regs.R9,regs.R8);
		/* 82063C98h case    0:*/		return 0x82063C9C;
		  /* 82063C9Ch */ case    1:  		/* addi R9, R11, 10890 */
		/* 82063C9Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x2A8A);
		/* 82063C9Ch case    1:*/		return 0x82063CA0;
	}
	return 0x82063CA0;
} // Block from 82063C98h-82063CA0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063CA0h
// Function 'D3DDevice_SetRenderState_AlphaToMaskEnable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063CA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063CA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063CA0);
		  /* 82063CA0h */ case    0:  		/* rlwimi R8, R4, 0, 0, 29 */
		/* 82063CA0h case    0:*/		cpu::op::rlwimi<0,0,0,29>(regs,&regs.R8,regs.R4);
		/* 82063CA0h case    0:*/		return 0x82063CA4;
		  /* 82063CA4h */ case    1:  		/* stw R8, <#[R10 + 16]> */
		/* 82063CA4h case    1:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000010) );
		/* 82063CA4h case    1:*/		return 0x82063CA8;
		  /* 82063CA8h */ case    2:  		/* stb R6, <#[R11 + 10890]> */
		/* 82063CA8h case    2:*/		cpu::mem::store8( regs, regs.R6, (uint32)(regs.R11 + 0x00002A8A) );
		/* 82063CA8h case    2:*/		return 0x82063CAC;
		  /* 82063CACh */ case    3:  		/* ld R11, <#[R3 + 24]> */
		/* 82063CACh case    3:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82063CACh case    3:*/		return 0x82063CB0;
		  /* 82063CB0h */ case    4:  		/* or R11, R7, R11 */
		/* 82063CB0h case    4:*/		cpu::op::or<0>(regs,&regs.R11,regs.R7,regs.R11);
		/* 82063CB0h case    4:*/		return 0x82063CB4;
		  /* 82063CB4h */ case    5:  		/* std R11, <#[R3 + 24]> */
		/* 82063CB4h case    5:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82063CB4h case    5:*/		return 0x82063CB8;
		  /* 82063CB8h */ case    6:  		/* ld R30, <#[R1 - 16]> */
		/* 82063CB8h case    6:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82063CB8h case    6:*/		return 0x82063CBC;
		  /* 82063CBCh */ case    7:  		/* ld R31, <#[R1 - 8]> */
		/* 82063CBCh case    7:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82063CBCh case    7:*/		return 0x82063CC0;
	}
	return 0x82063CC0;
} // Block from 82063CA0h-82063CC0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82063CC0h
// Function 'D3DDevice_GetRenderState_AlphaToMaskEnable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063CC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063CC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063CC0);
		  /* 82063CC0h */ case    0:  		/* bclr 20, CR0_LT */
		/* 82063CC0h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063CC0h case    0:*/		return 0x82063CC4;
	}
	return 0x82063CC4;
} // Block from 82063CC0h-82063CC4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063CC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063CC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063CC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063CC4);
		  /* 82063CC4h */ case    0:  		/* nop */
		/* 82063CC4h case    0:*/		cpu::op::nop();
		/* 82063CC4h case    0:*/		return 0x82063CC8;
	}
	return 0x82063CC8;
} // Block from 82063CC4h-82063CC8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063CC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063CC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063CC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063CC8);
		  /* 82063CC8h */ case    0:  		/* add R11, R3, R4 */
		/* 82063CC8h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R4);
		/* 82063CC8h case    0:*/		return 0x82063CCC;
		  /* 82063CCCh */ case    1:  		/* lbz R11, <#[R11 + 10890]> */
		/* 82063CCCh case    1:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00002A8A) );
		/* 82063CCCh case    1:*/		return 0x82063CD0;
	}
	return 0x82063CD0;
} // Block from 82063CC8h-82063CD0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063CD0h
// Function 'D3DDevice_SetRenderState_AlphaToMaskOffsets'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063CD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063CD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063CD0);
		  /* 82063CD0h */ case    0:  		/* rlwinm R3, R11, 31, 31, 31 */
		/* 82063CD0h case    0:*/		cpu::op::rlwinm<0,31,31,31>(regs,&regs.R3,regs.R11);
		/* 82063CD0h case    0:*/		return 0x82063CD4;
		  /* 82063CD4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82063CD4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063CD4h case    1:*/		return 0x82063CD8;
	}
	return 0x82063CD8;
} // Block from 82063CD0h-82063CD8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063CD8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063CD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063CD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063CD8);
		  /* 82063CD8h */ case    0:  		/* mfspr R12, LR */
		/* 82063CD8h case    0:*/		regs.R12 = regs.LR;
		/* 82063CD8h case    0:*/		return 0x82063CDC;
		  /* 82063CDCh */ case    1:  		/* bl 185728 */
		/* 82063CDCh case    1:*/		regs.LR = 0x82063CE0; return 0x8209125C;
		/* 82063CDCh case    1:*/		return 0x82063CE0;
		  /* 82063CE0h */ case    2:  		/* addi R11, R4, 48 */
		/* 82063CE0h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x30);
		/* 82063CE0h case    2:*/		return 0x82063CE4;
		  /* 82063CE4h */ case    3:  		/* add R10, R3, R4 */
		/* 82063CE4h case    3:*/		cpu::op::add<0>(regs,&regs.R10,regs.R3,regs.R4);
		/* 82063CE4h case    3:*/		return 0x82063CE8;
		  /* 82063CE8h */ case    4:  		/* mulli R11, R11, 24 */
		/* 82063CE8h case    4:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x18);
		/* 82063CE8h case    4:*/		return 0x82063CEC;
		  /* 82063CECh */ case    5:  		/* lbz R9, <#[R10 + 10864]> */
		/* 82063CECh case    5:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R10 + 0x00002A70) );
		/* 82063CECh case    5:*/		return 0x82063CF0;
	}
	return 0x82063CF0;
} // Block from 82063CD8h-82063CF0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82063CF0h
// Function 'D3DDevice_GetRenderState_AlphaToMaskOffsets'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063CF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063CF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063CF0);
		  /* 82063CF0h */ case    0:  		/* add R11, R11, R3 */
		/* 82063CF0h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 82063CF0h case    0:*/		return 0x82063CF4;
		  /* 82063CF4h */ case    1:  		/* lis R8, -32256 */
		/* 82063CF4h case    1:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8200);
		/* 82063CF4h case    1:*/		return 0x82063CF8;
	}
	return 0x82063CF8;
} // Block from 82063CF0h-82063CF8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063CF8h
// Function 'D3DDevice_SetRenderState_GuardBand_X'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063CF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063CF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063CF8);
		  /* 82063CF8h */ case    0:  		/* rlwinm R9, R9, 2, 0, 31 */
		/* 82063CF8h case    0:*/		cpu::op::rlwinm<0,2,0,31>(regs,&regs.R9,regs.R9);
		/* 82063CF8h case    0:*/		return 0x82063CFC;
		  /* 82063CFCh */ case    1:  		/* addi R8, R8, 2896 */
		/* 82063CFCh case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xB50);
		/* 82063CFCh case    1:*/		return 0x82063D00;
		  /* 82063D00h */ case    2:  		/* rlwinm R7, R5, 30, 2, 31 */
		/* 82063D00h case    2:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R7,regs.R5);
		/* 82063D00h case    2:*/		return 0x82063D04;
		  /* 82063D04h */ case    3:  		/* lwz R6, <#[R11 + 16]> */
		/* 82063D04h case    3:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000010) );
		/* 82063D04h case    3:*/		return 0x82063D08;
		  /* 82063D08h */ case    4:  		/* addi R4, R4, 32 */
		/* 82063D08h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x20);
		/* 82063D08h case    4:*/		return 0x82063D0C;
		  /* 82063D0Ch */ case    5:  		/* lwz R31, <#[R11 + 12]> */
		/* 82063D0Ch case    5:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x0000000C) );
		/* 82063D0Ch case    5:*/		return 0x82063D10;
		  /* 82063D10h */ case    6:  		/* li R30, 1 */
		/* 82063D10h case    6:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 82063D10h case    6:*/		return 0x82063D14;
		  /* 82063D14h */ case    7:  		/* mr R29, R6 */
		/* 82063D14h case    7:*/		regs.R29 = regs.R6;
		/* 82063D14h case    7:*/		return 0x82063D18;
		  /* 82063D18h */ case    8:  		/* rlwinm R6, R6, 21, 31, 31 */
		/* 82063D18h case    8:*/		cpu::op::rlwinm<0,21,31,31>(regs,&regs.R6,regs.R6);
		/* 82063D18h case    8:*/		return 0x82063D1C;
		  /* 82063D1Ch */ case    9:  		/* lwzx R8, <#[R9 + R8]> */
		/* 82063D1Ch case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 82063D1Ch case    9:*/		return 0x82063D20;
	}
	return 0x82063D20;
} // Block from 82063CF8h-82063D20h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82063D20h
// Function 'D3DDevice_GetRenderState_GuardBand_X'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063D20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063D20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063D20);
		  /* 82063D20h */ case    0:  		/* rlwimi R29, R7, 10, 21, 21 */
		/* 82063D20h case    0:*/		cpu::op::rlwimi<0,10,21,21>(regs,&regs.R29,regs.R7);
		/* 82063D20h case    0:*/		return 0x82063D24;
		  /* 82063D24h */ case    1:  		/* or R9, R6, R7 */
		/* 82063D24h case    1:*/		cpu::op::or<0>(regs,&regs.R9,regs.R6,regs.R7);
		/* 82063D24h case    1:*/		return 0x82063D28;
	}
	return 0x82063D28;
} // Block from 82063D20h-82063D28h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063D28h
// Function 'D3DDevice_SetRenderState_GuardBand_Y'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063D28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063D28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063D28);
		  /* 82063D28h */ case    0:  		/* stw R29, <#[R11 + 16]> */
		/* 82063D28h case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000010) );
		/* 82063D28h case    0:*/		return 0x82063D2C;
		  /* 82063D2Ch */ case    1:  		/* rldicr R6, R30, 63, 63 */
		/* 82063D2Ch case    1:*/		cpu::op::rldicr<0,63,63>(regs,&regs.R6,regs.R30);
		/* 82063D2Ch case    1:*/		return 0x82063D30;
		  /* 82063D30h */ case    2:  		/* addi R9, R9, -1 */
		/* 82063D30h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 82063D30h case    2:*/		return 0x82063D34;
		  /* 82063D34h */ case    3:  		/* andc R9, R8, R9 */
		/* 82063D34h case    3:*/		cpu::op::andc<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 82063D34h case    3:*/		return 0x82063D38;
		  /* 82063D38h */ case    4:  		/* rldicl R8, R4, 0, 32 */
		/* 82063D38h case    4:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R8,regs.R4);
		/* 82063D38h case    4:*/		return 0x82063D3C;
		  /* 82063D3Ch */ case    5:  		/* rlwinm R9, R9, 6, 0, 25 */
		/* 82063D3Ch case    5:*/		cpu::op::rlwinm<0,6,0,25>(regs,&regs.R9,regs.R9);
		/* 82063D3Ch case    5:*/		return 0x82063D40;
		  /* 82063D40h */ case    6:  		/* srd R8, R6, R8 */
		/* 82063D40h case    6:*/		cpu::op::srd<0>(regs,&regs.R8,regs.R6,regs.R8);
		/* 82063D40h case    6:*/		return 0x82063D44;
		  /* 82063D44h */ case    7:  		/* or R9, R9, R7 */
		/* 82063D44h case    7:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 82063D44h case    7:*/		return 0x82063D48;
		  /* 82063D48h */ case    8:  		/* or R9, R9, R5 */
		/* 82063D48h case    8:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R5);
		/* 82063D48h case    8:*/		return 0x82063D4C;
		  /* 82063D4Ch */ case    9:  		/* rlwimi R31, R9, 19, 11, 12 */
		/* 82063D4Ch case    9:*/		cpu::op::rlwimi<0,19,11,12>(regs,&regs.R31,regs.R9);
		/* 82063D4Ch case    9:*/		return 0x82063D50;
	}
	return 0x82063D50;
} // Block from 82063D28h-82063D50h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82063D50h
// Function 'D3DDevice_GetRenderState_GuardBand_Y'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063D50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063D50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063D50);
		  /* 82063D50h */ case    0:  		/* rlwimi R31, R9, 19, 4, 6 */
		/* 82063D50h case    0:*/		cpu::op::rlwimi<0,19,4,6>(regs,&regs.R31,regs.R9);
		/* 82063D50h case    0:*/		return 0x82063D54;
		  /* 82063D54h */ case    1:  		/* stw R31, <#[R11 + 12]> */
		/* 82063D54h case    1:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x0000000C) );
		/* 82063D54h case    1:*/		return 0x82063D58;
	}
	return 0x82063D58;
} // Block from 82063D50h-82063D58h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063D58h
// Function 'D3DDevice_SetRenderState_DiscardBand_X'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063D58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063D58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063D58);
		  /* 82063D58h */ case    0:  		/* lbz R9, <#[R10 + 10890]> */
		/* 82063D58h case    0:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R10 + 0x00002A8A) );
		/* 82063D58h case    0:*/		return 0x82063D5C;
		  /* 82063D5Ch */ case    1:  		/* rlwinm R10, R31, 0, 0, 31 */
		/* 82063D5Ch case    1:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R31);
		/* 82063D5Ch case    1:*/		return 0x82063D60;
		  /* 82063D60h */ case    2:  		/* mr R7, R10 */
		/* 82063D60h case    2:*/		regs.R7 = regs.R10;
		/* 82063D60h case    2:*/		return 0x82063D64;
		  /* 82063D64h */ case    3:  		/* mr R6, R10 */
		/* 82063D64h case    3:*/		regs.R6 = regs.R10;
		/* 82063D64h case    3:*/		return 0x82063D68;
		  /* 82063D68h */ case    4:  		/* rlwinm R10, R9, 30, 2, 31 */
		/* 82063D68h case    4:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R10,regs.R9);
		/* 82063D68h case    4:*/		return 0x82063D6C;
		  /* 82063D6Ch */ case    5:  		/* rlwimi R6, R7, 31, 13, 31 */
		/* 82063D6Ch case    5:*/		cpu::op::rlwimi<0,31,13,31>(regs,&regs.R6,regs.R7);
		/* 82063D6Ch case    5:*/		return 0x82063D70;
		  /* 82063D70h */ case    6:  		/* addi R10, R10, -1 */
		/* 82063D70h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82063D70h case    6:*/		return 0x82063D74;
		  /* 82063D74h */ case    7:  		/* rlwimi R6, R7, 31, 1, 11 */
		/* 82063D74h case    7:*/		cpu::op::rlwimi<0,31,1,11>(regs,&regs.R6,regs.R7);
		/* 82063D74h case    7:*/		return 0x82063D78;
	}
	return 0x82063D78;
} // Block from 82063D58h-82063D78h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82063D78h
// Function 'D3DDevice_GetRenderState_DiscardBand_X'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063D78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063D78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063D78);
		  /* 82063D78h */ case    0:  		/* andc R9, R9, R10 */
		/* 82063D78h case    0:*/		cpu::op::andc<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 82063D78h case    0:*/		return 0x82063D7C;
		  /* 82063D7Ch */ case    1:  		/* rlwinm R7, R6, 13, 20, 31 */
		/* 82063D7Ch case    1:*/		cpu::op::rlwinm<0,13,20,31>(regs,&regs.R7,regs.R6);
		/* 82063D7Ch case    1:*/		return 0x82063D80;
	}
	return 0x82063D80;
} // Block from 82063D78h-82063D80h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063D80h
// Function 'D3DDevice_SetRenderState_DiscardBand_Y'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063D80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063D80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063D80);
		  /* 82063D80h */ case    0:  		/* and R10, R7, R10 */
		/* 82063D80h case    0:*/		cpu::op::and<0>(regs,&regs.R10,regs.R7,regs.R10);
		/* 82063D80h case    0:*/		return 0x82063D84;
		  /* 82063D84h */ case    1:  		/* add R10, R10, R9 */
		/* 82063D84h case    1:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82063D84h case    1:*/		return 0x82063D88;
		  /* 82063D88h */ case    2:  		/* rlwimi R10, R29, 0, 0, 29 */
		/* 82063D88h case    2:*/		cpu::op::rlwimi<0,0,0,29>(regs,&regs.R10,regs.R29);
		/* 82063D88h case    2:*/		return 0x82063D8C;
		  /* 82063D8Ch */ case    3:  		/* stw R10, <#[R11 + 16]> */
		/* 82063D8Ch case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 82063D8Ch case    3:*/		return 0x82063D90;
		  /* 82063D90h */ case    4:  		/* ld R11, <#[R3 + 24]> */
		/* 82063D90h case    4:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82063D90h case    4:*/		return 0x82063D94;
		  /* 82063D94h */ case    5:  		/* or R11, R8, R11 */
		/* 82063D94h case    5:*/		cpu::op::or<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 82063D94h case    5:*/		return 0x82063D98;
		  /* 82063D98h */ case    6:  		/* std R11, <#[R3 + 24]> */
		/* 82063D98h case    6:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82063D98h case    6:*/		return 0x82063D9C;
		  /* 82063D9Ch */ case    7:  		/* b 185616 */
		/* 82063D9Ch case    7:*/		return 0x820912AC;
		/* 82063D9Ch case    7:*/		return 0x82063DA0;
	}
	return 0x82063DA0;
} // Block from 82063D80h-82063DA0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82063DA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063DA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063DA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063DA0);
		  /* 82063DA0h */ case    0:  		/* addi R11, R4, 48 */
		/* 82063DA0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x30);
		/* 82063DA0h case    0:*/		return 0x82063DA4;
		  /* 82063DA4h */ case    1:  		/* mulli R11, R11, 24 */
		/* 82063DA4h case    1:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x18);
		/* 82063DA4h case    1:*/		return 0x82063DA8;
	}
	return 0x82063DA8;
} // Block from 82063DA0h-82063DA8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063DA8h
// Function 'D3DDevice_GetRenderState_DiscardBand_Y'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063DA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063DA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063DA8);
		  /* 82063DA8h */ case    0:  		/* add R11, R11, R3 */
		/* 82063DA8h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 82063DA8h case    0:*/		return 0x82063DAC;
		  /* 82063DACh */ case    1:  		/* lwz R10, <#[R11 + 16]> */
		/* 82063DACh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 82063DACh case    1:*/		return 0x82063DB0;
	}
	return 0x82063DB0;
} // Block from 82063DA8h-82063DB0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063DB0h
// Function 'D3DDevice_SetRenderState_HiZEnable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063DB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063DB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063DB0);
		  /* 82063DB0h */ case    0:  		/* lwz R9, <#[R11 + 12]> */
		/* 82063DB0h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 82063DB0h case    0:*/		return 0x82063DB4;
		  /* 82063DB4h */ case    1:  		/* rlwinm R11, R10, 22, 31, 31 */
		/* 82063DB4h case    1:*/		cpu::op::rlwinm<0,22,31,31>(regs,&regs.R11,regs.R10);
		/* 82063DB4h case    1:*/		return 0x82063DB8;
		  /* 82063DB8h */ case    2:  		/* rlwinm R10, R9, 13, 19, 31 */
		/* 82063DB8h case    2:*/		cpu::op::rlwinm<0,13,19,31>(regs,&regs.R10,regs.R9);
		/* 82063DB8h case    2:*/		return 0x82063DBC;
		  /* 82063DBCh */ case    3:  		/* addi R11, R11, -1 */
		/* 82063DBCh case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82063DBCh case    3:*/		return 0x82063DC0;
		  /* 82063DC0h */ case    4:  		/* and R10, R10, R11 */
		/* 82063DC0h case    4:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 82063DC0h case    4:*/		return 0x82063DC4;
		  /* 82063DC4h */ case    5:  		/* nor R11, R11, R11 */
		/* 82063DC4h case    5:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82063DC4h case    5:*/		return 0x82063DC8;
		  /* 82063DC8h */ case    6:  		/* rlwimi R10, R11, 0, 29, 29 */
		/* 82063DC8h case    6:*/		cpu::op::rlwimi<0,0,29,29>(regs,&regs.R10,regs.R11);
		/* 82063DC8h case    6:*/		return 0x82063DCC;
		  /* 82063DCCh */ case    7:  		/* rlwinm R3, R10, 0, 29, 31 */
		/* 82063DCCh case    7:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R3,regs.R10);
		/* 82063DCCh case    7:*/		return 0x82063DD0;
	}
	return 0x82063DD0;
} // Block from 82063DB0h-82063DD0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82063DD0h
// Function 'D3DDevice_GetRenderState_HiZEnable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063DD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063DD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063DD0);
		  /* 82063DD0h */ case    0:  		/* bclr 20, CR0_LT */
		/* 82063DD0h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063DD0h case    0:*/		return 0x82063DD4;
	}
	return 0x82063DD4;
} // Block from 82063DD0h-82063DD4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063DD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063DD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063DD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063DD4);
		  /* 82063DD4h */ case    0:  		/* nop */
		/* 82063DD4h case    0:*/		cpu::op::nop();
		/* 82063DD4h case    0:*/		return 0x82063DD8;
	}
	return 0x82063DD8;
} // Block from 82063DD4h-82063DD8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063DD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063DD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063DD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063DD8);
		  /* 82063DD8h */ case    0:  		/* std R30, <#[R1 - 16]> */
		/* 82063DD8h case    0:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82063DD8h case    0:*/		return 0x82063DDC;
		  /* 82063DDCh */ case    1:  		/* std R31, <#[R1 - 8]> */
		/* 82063DDCh case    1:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82063DDCh case    1:*/		return 0x82063DE0;
	}
	return 0x82063DE0;
} // Block from 82063DD8h-82063DE0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063DE0h
// Function 'D3DDevice_SetRenderState_HiZWriteEnable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063DE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063DE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063DE0);
		  /* 82063DE0h */ case    0:  		/* add R11, R3, R4 */
		/* 82063DE0h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R4);
		/* 82063DE0h case    0:*/		return 0x82063DE4;
		  /* 82063DE4h */ case    1:  		/* addi R10, R4, 48 */
		/* 82063DE4h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x30);
		/* 82063DE4h case    1:*/		return 0x82063DE8;
		  /* 82063DE8h */ case    2:  		/* addi R7, R4, 32 */
		/* 82063DE8h case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R4,0x20);
		/* 82063DE8h case    2:*/		return 0x82063DEC;
		  /* 82063DECh */ case    3:  		/* mulli R10, R10, 24 */
		/* 82063DECh case    3:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x18);
		/* 82063DECh case    3:*/		return 0x82063DF0;
		  /* 82063DF0h */ case    4:  		/* lbz R9, <#[R11 + 10890]> */
		/* 82063DF0h case    4:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00002A8A) );
		/* 82063DF0h case    4:*/		return 0x82063DF4;
		  /* 82063DF4h */ case    5:  		/* add R10, R10, R3 */
		/* 82063DF4h case    5:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R3);
		/* 82063DF4h case    5:*/		return 0x82063DF8;
		  /* 82063DF8h */ case    6:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 82063DF8h case    6:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 82063DF8h case    6:*/		return 0x82063DFC;
		  /* 82063DFCh */ case    7:  		/* li R8, 1 */
		/* 82063DFCh case    7:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82063DFCh case    7:*/		return 0x82063E00;
		  /* 82063E00h */ case    8:  		/* or R6, R9, R5 */
		/* 82063E00h case    8:*/		cpu::op::or<0>(regs,&regs.R6,regs.R9,regs.R5);
		/* 82063E00h case    8:*/		return 0x82063E04;
		  /* 82063E04h */ case    9:  		/* rldicr R31, R8, 63, 63 */
		/* 82063E04h case    9:*/		cpu::op::rldicr<0,63,63>(regs,&regs.R31,regs.R8);
		/* 82063E04h case    9:*/		return 0x82063E08;
		  /* 82063E08h */ case   10:  		/* lwz R5, <#[R10 + 12]> */
		/* 82063E08h case   10:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + 0x0000000C) );
		/* 82063E08h case   10:*/		return 0x82063E0C;
		  /* 82063E0Ch */ case   11:  		/* rlwinm R9, R6, 30, 2, 31 */
		/* 82063E0Ch case   11:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R9,regs.R6);
		/* 82063E0Ch case   11:*/		return 0x82063E10;
		  /* 82063E10h */ case   12:  		/* lwz R4, <#[R10 + 16]> */
		/* 82063E10h case   12:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000010) );
		/* 82063E10h case   12:*/		return 0x82063E14;
		  /* 82063E14h */ case   13:  		/* mr R30, R5 */
		/* 82063E14h case   13:*/		regs.R30 = regs.R5;
		/* 82063E14h case   13:*/		return 0x82063E18;
		  /* 82063E18h */ case   14:  		/* addi R9, R9, -1 */
		/* 82063E18h case   14:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 82063E18h case   14:*/		return 0x82063E1C;
		  /* 82063E1Ch */ case   15:  		/* rlwimi R5, R30, 31, 13, 31 */
		/* 82063E1Ch case   15:*/		cpu::op::rlwimi<0,31,13,31>(regs,&regs.R5,regs.R30);
		/* 82063E1Ch case   15:*/		return 0x82063E20;
		  /* 82063E20h */ case   16:  		/* andc R8, R6, R9 */
		/* 82063E20h case   16:*/		cpu::op::andc<0>(regs,&regs.R8,regs.R6,regs.R9);
		/* 82063E20h case   16:*/		return 0x82063E24;
		  /* 82063E24h */ case   17:  		/* rlwimi R5, R30, 31, 1, 11 */
		/* 82063E24h case   17:*/		cpu::op::rlwimi<0,31,1,11>(regs,&regs.R5,regs.R30);
		/* 82063E24h case   17:*/		return 0x82063E28;
		  /* 82063E28h */ case   18:  		/* rldicl R30, R7, 0, 32 */
		/* 82063E28h case   18:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R30,regs.R7);
		/* 82063E28h case   18:*/		return 0x82063E2C;
		  /* 82063E2Ch */ case   19:  		/* rlwinm R7, R5, 13, 20, 31 */
		/* 82063E2Ch case   19:*/		cpu::op::rlwinm<0,13,20,31>(regs,&regs.R7,regs.R5);
		/* 82063E2Ch case   19:*/		return 0x82063E30;
		  /* 82063E30h */ case   20:  		/* srd R5, R31, R30 */
		/* 82063E30h case   20:*/		cpu::op::srd<0>(regs,&regs.R5,regs.R31,regs.R30);
		/* 82063E30h case   20:*/		return 0x82063E34;
		  /* 82063E34h */ case   21:  		/* and R7, R7, R9 */
		/* 82063E34h case   21:*/		cpu::op::and<0>(regs,&regs.R7,regs.R7,regs.R9);
		/* 82063E34h case   21:*/		return 0x82063E38;
	}
	return 0x82063E38;
} // Block from 82063DE0h-82063E38h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82063E38h
// Function 'D3DDevice_GetRenderState_HiZWriteEnable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063E38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063E38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063E38);
		  /* 82063E38h */ case    0:  		/* addi R9, R11, 10890 */
		/* 82063E38h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x2A8A);
		/* 82063E38h case    0:*/		return 0x82063E3C;
		  /* 82063E3Ch */ case    1:  		/* add R8, R7, R8 */
		/* 82063E3Ch case    1:*/		cpu::op::add<0>(regs,&regs.R8,regs.R7,regs.R8);
		/* 82063E3Ch case    1:*/		return 0x82063E40;
		  /* 82063E40h */ case    2:  		/* rlwimi R8, R4, 0, 0, 29 */
		/* 82063E40h case    2:*/		cpu::op::rlwimi<0,0,0,29>(regs,&regs.R8,regs.R4);
		/* 82063E40h case    2:*/		return 0x82063E44;
		  /* 82063E44h */ case    3:  		/* stw R8, <#[R10 + 16]> */
		/* 82063E44h case    3:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000010) );
		/* 82063E44h case    3:*/		return 0x82063E48;
	}
	return 0x82063E48;
} // Block from 82063E38h-82063E48h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82063E48h
// Function 'D3DDevice_SetRenderState_HiStencilEnable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063E48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063E48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063E48);
		  /* 82063E48h */ case    0:  		/* stb R6, <#[R11 + 10890]> */
		/* 82063E48h case    0:*/		cpu::mem::store8( regs, regs.R6, (uint32)(regs.R11 + 0x00002A8A) );
		/* 82063E48h case    0:*/		return 0x82063E4C;
		  /* 82063E4Ch */ case    1:  		/* ld R11, <#[R3 + 24]> */
		/* 82063E4Ch case    1:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82063E4Ch case    1:*/		return 0x82063E50;
		  /* 82063E50h */ case    2:  		/* or R11, R5, R11 */
		/* 82063E50h case    2:*/		cpu::op::or<0>(regs,&regs.R11,regs.R5,regs.R11);
		/* 82063E50h case    2:*/		return 0x82063E54;
		  /* 82063E54h */ case    3:  		/* std R11, <#[R3 + 24]> */
		/* 82063E54h case    3:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82063E54h case    3:*/		return 0x82063E58;
		  /* 82063E58h */ case    4:  		/* ld R30, <#[R1 - 16]> */
		/* 82063E58h case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82063E58h case    4:*/		return 0x82063E5C;
		  /* 82063E5Ch */ case    5:  		/* ld R31, <#[R1 - 8]> */
		/* 82063E5Ch case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82063E5Ch case    5:*/		return 0x82063E60;
		  /* 82063E60h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82063E60h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063E60h case    6:*/		return 0x82063E64;
	}
	return 0x82063E64;
} // Block from 82063E48h-82063E64h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82063E64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063E64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063E64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063E64);
		  /* 82063E64h */ case    0:  		/* nop */
		/* 82063E64h case    0:*/		cpu::op::nop();
		/* 82063E64h case    0:*/		return 0x82063E68;
	}
	return 0x82063E68;
} // Block from 82063E64h-82063E68h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063E68h
// Function 'D3DDevice_GetRenderState_HiStencilEnable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063E68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063E68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063E68);
		  /* 82063E68h */ case    0:  		/* add R11, R3, R4 */
		/* 82063E68h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R4);
		/* 82063E68h case    0:*/		return 0x82063E6C;
		  /* 82063E6Ch */ case    1:  		/* lbz R11, <#[R11 + 10890]> */
		/* 82063E6Ch case    1:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00002A8A) );
		/* 82063E6Ch case    1:*/		return 0x82063E70;
		  /* 82063E70h */ case    2:  		/* rlwinm R3, R11, 0, 31, 31 */
		/* 82063E70h case    2:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R3,regs.R11);
		/* 82063E70h case    2:*/		return 0x82063E74;
		  /* 82063E74h */ case    3:  		/* bclr 20, CR0_LT */
		/* 82063E74h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063E74h case    3:*/		return 0x82063E78;
	}
	return 0x82063E78;
} // Block from 82063E68h-82063E78h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82063E78h
// Function 'D3DDevice_SetRenderState_HiStencilWriteEnable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063E78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063E78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063E78);
		  /* 82063E78h */ case    0:  		/* addi R11, R4, 48 */
		/* 82063E78h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x30);
		/* 82063E78h case    0:*/		return 0x82063E7C;
		  /* 82063E7Ch */ case    1:  		/* addi R10, R4, 32 */
		/* 82063E7Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x20);
		/* 82063E7Ch case    1:*/		return 0x82063E80;
		  /* 82063E80h */ case    2:  		/* mulli R11, R11, 24 */
		/* 82063E80h case    2:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x18);
		/* 82063E80h case    2:*/		return 0x82063E84;
		  /* 82063E84h */ case    3:  		/* add R11, R11, R3 */
		/* 82063E84h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 82063E84h case    3:*/		return 0x82063E88;
		  /* 82063E88h */ case    4:  		/* li R9, 1 */
		/* 82063E88h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82063E88h case    4:*/		return 0x82063E8C;
		  /* 82063E8Ch */ case    5:  		/* rldicl R10, R10, 0, 32 */
		/* 82063E8Ch case    5:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R10,regs.R10);
		/* 82063E8Ch case    5:*/		return 0x82063E90;
		  /* 82063E90h */ case    6:  		/* rldicr R9, R9, 63, 63 */
		/* 82063E90h case    6:*/		cpu::op::rldicr<0,63,63>(regs,&regs.R9,regs.R9);
		/* 82063E90h case    6:*/		return 0x82063E94;
		  /* 82063E94h */ case    7:  		/* lwz R8, <#[R11 + 12]> */
		/* 82063E94h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x0000000C) );
		/* 82063E94h case    7:*/		return 0x82063E98;
	}
	return 0x82063E98;
} // Block from 82063E78h-82063E98h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82063E98h
// Function 'D3DDevice_GetRenderState_HiStencilWriteEnable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063E98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063E98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063E98);
		  /* 82063E98h */ case    0:  		/* srd R10, R9, R10 */
		/* 82063E98h case    0:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82063E98h case    0:*/		return 0x82063E9C;
		  /* 82063E9Ch */ case    1:  		/* rlwimi R8, R5, 23, 7, 8 */
		/* 82063E9Ch case    1:*/		cpu::op::rlwimi<0,23,7,8>(regs,&regs.R8,regs.R5);
		/* 82063E9Ch case    1:*/		return 0x82063EA0;
		  /* 82063EA0h */ case    2:  		/* stw R8, <#[R11 + 12]> */
		/* 82063EA0h case    2:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x0000000C) );
		/* 82063EA0h case    2:*/		return 0x82063EA4;
		  /* 82063EA4h */ case    3:  		/* ld R11, <#[R3 + 24]> */
		/* 82063EA4h case    3:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82063EA4h case    3:*/		return 0x82063EA8;
	}
	return 0x82063EA8;
} // Block from 82063E98h-82063EA8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82063EA8h
// Function 'D3DDevice_SetRenderState_HiStencilFunc'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063EA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063EA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063EA8);
		  /* 82063EA8h */ case    0:  		/* or R11, R10, R11 */
		/* 82063EA8h case    0:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82063EA8h case    0:*/		return 0x82063EAC;
		  /* 82063EACh */ case    1:  		/* std R11, <#[R3 + 24]> */
		/* 82063EACh case    1:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82063EACh case    1:*/		return 0x82063EB0;
		  /* 82063EB0h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82063EB0h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063EB0h case    2:*/		return 0x82063EB4;
	}
	return 0x82063EB4;
} // Block from 82063EA8h-82063EB4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82063EB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063EB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063EB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063EB4);
		  /* 82063EB4h */ case    0:  		/* nop */
		/* 82063EB4h case    0:*/		cpu::op::nop();
		/* 82063EB4h case    0:*/		return 0x82063EB8;
	}
	return 0x82063EB8;
} // Block from 82063EB4h-82063EB8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063EB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063EB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063EB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063EB8);
		  /* 82063EB8h */ case    0:  		/* mulli R11, R4, 24 */
		/* 82063EB8h case    0:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R4,0x18);
		/* 82063EB8h case    0:*/		return 0x82063EBC;
		  /* 82063EBCh */ case    1:  		/* add R11, R11, R3 */
		/* 82063EBCh case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 82063EBCh case    1:*/		return 0x82063EC0;
		  /* 82063EC0h */ case    2:  		/* lwz R11, <#[R11 + 1164]> */
		/* 82063EC0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000048C) );
		/* 82063EC0h case    2:*/		return 0x82063EC4;
		  /* 82063EC4h */ case    3:  		/* rlwinm R3, R11, 9, 30, 31 */
		/* 82063EC4h case    3:*/		cpu::op::rlwinm<0,9,30,31>(regs,&regs.R3,regs.R11);
		/* 82063EC4h case    3:*/		return 0x82063EC8;
	}
	return 0x82063EC8;
} // Block from 82063EB8h-82063EC8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82063EC8h
// Function 'D3DDevice_GetRenderState_HiStencilFunc'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063EC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063EC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063EC8);
		  /* 82063EC8h */ case    0:  		/* bclr 20, CR0_LT */
		/* 82063EC8h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063EC8h case    0:*/		return 0x82063ECC;
	}
	return 0x82063ECC;
} // Block from 82063EC8h-82063ECCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063ECCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063ECC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063ECC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063ECC);
		  /* 82063ECCh */ case    0:  		/* nop */
		/* 82063ECCh case    0:*/		cpu::op::nop();
		/* 82063ECCh case    0:*/		return 0x82063ED0;
	}
	return 0x82063ED0;
} // Block from 82063ECCh-82063ED0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063ED0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063ED0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063ED0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063ED0);
		  /* 82063ED0h */ case    0:  		/* std R30, <#[R1 - 16]> */
		/* 82063ED0h case    0:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82063ED0h case    0:*/		return 0x82063ED4;
		  /* 82063ED4h */ case    1:  		/* std R31, <#[R1 - 8]> */
		/* 82063ED4h case    1:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82063ED4h case    1:*/		return 0x82063ED8;
	}
	return 0x82063ED8;
} // Block from 82063ED0h-82063ED8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063ED8h
// Function 'D3DDevice_SetRenderState_HiStencilRef'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063ED8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063ED8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063ED8);
		  /* 82063ED8h */ case    0:  		/* add R11, R3, R4 */
		/* 82063ED8h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R4);
		/* 82063ED8h case    0:*/		return 0x82063EDC;
		  /* 82063EDCh */ case    1:  		/* addi R10, R4, 48 */
		/* 82063EDCh case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x30);
		/* 82063EDCh case    1:*/		return 0x82063EE0;
		  /* 82063EE0h */ case    2:  		/* rlwinm R8, R5, 2, 0, 29 */
		/* 82063EE0h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R5);
		/* 82063EE0h case    2:*/		return 0x82063EE4;
		  /* 82063EE4h */ case    3:  		/* mulli R10, R10, 24 */
		/* 82063EE4h case    3:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x18);
		/* 82063EE4h case    3:*/		return 0x82063EE8;
		  /* 82063EE8h */ case    4:  		/* lbz R9, <#[R11 + 10890]> */
		/* 82063EE8h case    4:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00002A8A) );
		/* 82063EE8h case    4:*/		return 0x82063EEC;
		  /* 82063EECh */ case    5:  		/* add R10, R10, R3 */
		/* 82063EECh case    5:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R3);
		/* 82063EECh case    5:*/		return 0x82063EF0;
	}
	return 0x82063EF0;
} // Block from 82063ED8h-82063EF0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82063EF0h
// Function 'D3DDevice_GetRenderState_HiStencilRef'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063EF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063EF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063EF0);
		  /* 82063EF0h */ case    0:  		/* rlwinm R9, R9, 0, 30, 28 */
		/* 82063EF0h case    0:*/		cpu::op::rlwinm<0,0,30,28>(regs,&regs.R9,regs.R9);
		/* 82063EF0h case    0:*/		return 0x82063EF4;
		  /* 82063EF4h */ case    1:  		/* addi R7, R4, 32 */
		/* 82063EF4h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R4,0x20);
		/* 82063EF4h case    1:*/		return 0x82063EF8;
	}
	return 0x82063EF8;
} // Block from 82063EF0h-82063EF8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063EF8h
// Function 'D3DDevice_SetRenderState_PresentInterval'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063EF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063EF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063EF8);
		  /* 82063EF8h */ case    0:  		/* or R6, R9, R8 */
		/* 82063EF8h case    0:*/		cpu::op::or<0>(regs,&regs.R6,regs.R9,regs.R8);
		/* 82063EF8h case    0:*/		return 0x82063EFC;
		  /* 82063EFCh */ case    1:  		/* li R5, 1 */
		/* 82063EFCh case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82063EFCh case    1:*/		return 0x82063F00;
	}
	return 0x82063F00;
} // Block from 82063EF8h-82063F00h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063F00h
// Function 'D3DDevice_GetRenderState_PresentInterval'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063F00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063F00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063F00);
		  /* 82063F00h */ case    0:  		/* lwz R8, <#[R10 + 12]> */
		/* 82063F00h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x0000000C) );
		/* 82063F00h case    0:*/		return 0x82063F04;
		  /* 82063F04h */ case    1:  		/* rlwinm R9, R6, 30, 2, 31 */
		/* 82063F04h case    1:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R9,regs.R6);
		/* 82063F04h case    1:*/		return 0x82063F08;
	}
	return 0x82063F08;
} // Block from 82063F00h-82063F08h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82063F08h
// Function 'D3DDevice_SetRenderState_PresentImmediateThreshold'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063F08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063F08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063F08);
		  /* 82063F08h */ case    0:  		/* lwz R4, <#[R10 + 16]> */
		/* 82063F08h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000010) );
		/* 82063F08h case    0:*/		return 0x82063F0C;
		  /* 82063F0Ch */ case    1:  		/* rldicr R5, R5, 63, 63 */
		/* 82063F0Ch case    1:*/		cpu::op::rldicr<0,63,63>(regs,&regs.R5,regs.R5);
		/* 82063F0Ch case    1:*/		return 0x82063F10;
		  /* 82063F10h */ case    2:  		/* mr R31, R8 */
		/* 82063F10h case    2:*/		regs.R31 = regs.R8;
		/* 82063F10h case    2:*/		return 0x82063F14;
		  /* 82063F14h */ case    3:  		/* mr R30, R8 */
		/* 82063F14h case    3:*/		regs.R30 = regs.R8;
		/* 82063F14h case    3:*/		return 0x82063F18;
	}
	return 0x82063F18;
} // Block from 82063F08h-82063F18h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82063F18h
// Function 'D3DDevice_GetRenderState_PresentImmediateThreshold'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063F18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063F18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063F18);
		  /* 82063F18h */ case    0:  		/* addi R9, R9, -1 */
		/* 82063F18h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 82063F18h case    0:*/		return 0x82063F1C;
		  /* 82063F1Ch */ case    1:  		/* rlwimi R30, R31, 31, 13, 31 */
		/* 82063F1Ch case    1:*/		cpu::op::rlwimi<0,31,13,31>(regs,&regs.R30,regs.R31);
		/* 82063F1Ch case    1:*/		return 0x82063F20;
		  /* 82063F20h */ case    2:  		/* andc R8, R6, R9 */
		/* 82063F20h case    2:*/		cpu::op::andc<0>(regs,&regs.R8,regs.R6,regs.R9);
		/* 82063F20h case    2:*/		return 0x82063F24;
		  /* 82063F24h */ case    3:  		/* rlwimi R30, R31, 31, 1, 11 */
		/* 82063F24h case    3:*/		cpu::op::rlwimi<0,31,1,11>(regs,&regs.R30,regs.R31);
		/* 82063F24h case    3:*/		return 0x82063F28;
	}
	return 0x82063F28;
} // Block from 82063F18h-82063F28h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82063F28h
// Function 'D3DDevice_SetSamplerState_MinFilter'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063F28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063F28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063F28);
		  /* 82063F28h */ case    0:  		/* rldicl R7, R7, 0, 32 */
		/* 82063F28h case    0:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R7,regs.R7);
		/* 82063F28h case    0:*/		return 0x82063F2C;
		  /* 82063F2Ch */ case    1:  		/* rlwinm R31, R30, 13, 20, 31 */
		/* 82063F2Ch case    1:*/		cpu::op::rlwinm<0,13,20,31>(regs,&regs.R31,regs.R30);
		/* 82063F2Ch case    1:*/		return 0x82063F30;
		  /* 82063F30h */ case    2:  		/* srd R7, R5, R7 */
		/* 82063F30h case    2:*/		cpu::op::srd<0>(regs,&regs.R7,regs.R5,regs.R7);
		/* 82063F30h case    2:*/		return 0x82063F34;
		  /* 82063F34h */ case    3:  		/* and R9, R31, R9 */
		/* 82063F34h case    3:*/		cpu::op::and<0>(regs,&regs.R9,regs.R31,regs.R9);
		/* 82063F34h case    3:*/		return 0x82063F38;
		  /* 82063F38h */ case    4:  		/* add R8, R9, R8 */
		/* 82063F38h case    4:*/		cpu::op::add<0>(regs,&regs.R8,regs.R9,regs.R8);
		/* 82063F38h case    4:*/		return 0x82063F3C;
		  /* 82063F3Ch */ case    5:  		/* addi R9, R11, 10890 */
		/* 82063F3Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x2A8A);
		/* 82063F3Ch case    5:*/		return 0x82063F40;
		  /* 82063F40h */ case    6:  		/* rlwimi R8, R4, 0, 0, 29 */
		/* 82063F40h case    6:*/		cpu::op::rlwimi<0,0,0,29>(regs,&regs.R8,regs.R4);
		/* 82063F40h case    6:*/		return 0x82063F44;
		  /* 82063F44h */ case    7:  		/* stw R8, <#[R10 + 16]> */
		/* 82063F44h case    7:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000010) );
		/* 82063F44h case    7:*/		return 0x82063F48;
		  /* 82063F48h */ case    8:  		/* stb R6, <#[R11 + 10890]> */
		/* 82063F48h case    8:*/		cpu::mem::store8( regs, regs.R6, (uint32)(regs.R11 + 0x00002A8A) );
		/* 82063F48h case    8:*/		return 0x82063F4C;
		  /* 82063F4Ch */ case    9:  		/* ld R11, <#[R3 + 24]> */
		/* 82063F4Ch case    9:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82063F4Ch case    9:*/		return 0x82063F50;
		  /* 82063F50h */ case   10:  		/* or R11, R7, R11 */
		/* 82063F50h case   10:*/		cpu::op::or<0>(regs,&regs.R11,regs.R7,regs.R11);
		/* 82063F50h case   10:*/		return 0x82063F54;
		  /* 82063F54h */ case   11:  		/* std R11, <#[R3 + 24]> */
		/* 82063F54h case   11:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82063F54h case   11:*/		return 0x82063F58;
		  /* 82063F58h */ case   12:  		/* ld R30, <#[R1 - 16]> */
		/* 82063F58h case   12:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82063F58h case   12:*/		return 0x82063F5C;
		  /* 82063F5Ch */ case   13:  		/* ld R31, <#[R1 - 8]> */
		/* 82063F5Ch case   13:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82063F5Ch case   13:*/		return 0x82063F60;
		  /* 82063F60h */ case   14:  		/* bclr 20, CR0_LT */
		/* 82063F60h case   14:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063F60h case   14:*/		return 0x82063F64;
	}
	return 0x82063F64;
} // Block from 82063F28h-82063F64h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82063F64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063F64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063F64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063F64);
		  /* 82063F64h */ case    0:  		/* nop */
		/* 82063F64h case    0:*/		cpu::op::nop();
		/* 82063F64h case    0:*/		return 0x82063F68;
	}
	return 0x82063F68;
} // Block from 82063F64h-82063F68h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063F68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063F68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063F68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063F68);
		  /* 82063F68h */ case    0:  		/* add R11, R3, R4 */
		/* 82063F68h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R4);
		/* 82063F68h case    0:*/		return 0x82063F6C;
		  /* 82063F6Ch */ case    1:  		/* lbz R11, <#[R11 + 10890]> */
		/* 82063F6Ch case    1:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00002A8A) );
		/* 82063F6Ch case    1:*/		return 0x82063F70;
		  /* 82063F70h */ case    2:  		/* rlwinm R3, R11, 30, 31, 31 */
		/* 82063F70h case    2:*/		cpu::op::rlwinm<0,30,31,31>(regs,&regs.R3,regs.R11);
		/* 82063F70h case    2:*/		return 0x82063F74;
		  /* 82063F74h */ case    3:  		/* bclr 20, CR0_LT */
		/* 82063F74h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063F74h case    3:*/		return 0x82063F78;
	}
	return 0x82063F78;
} // Block from 82063F68h-82063F78h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82063F78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063F78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063F78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063F78);
		  /* 82063F78h */ case    0:  		/* addi R11, R4, 48 */
		/* 82063F78h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x30);
		/* 82063F78h case    0:*/		return 0x82063F7C;
		  /* 82063F7Ch */ case    1:  		/* mulli R11, R11, 24 */
		/* 82063F7Ch case    1:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x18);
		/* 82063F7Ch case    1:*/		return 0x82063F80;
		  /* 82063F80h */ case    2:  		/* add R11, R11, R3 */
		/* 82063F80h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 82063F80h case    2:*/		return 0x82063F84;
		  /* 82063F84h */ case    3:  		/* lwz R10, <#[R11 + 16]> */
		/* 82063F84h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 82063F84h case    3:*/		return 0x82063F88;
		  /* 82063F88h */ case    4:  		/* rlwinm. R9, R10, 0, 20, 20 */
		/* 82063F88h case    4:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R9,regs.R10);
		/* 82063F88h case    4:*/		return 0x82063F8C;
		  /* 82063F8Ch */ case    5:  		/* bc 4, CR0_EQ, 12 */
		/* 82063F8Ch case    5:*/		if ( !regs.CR[0].eq ) { return 0x82063F98;  }
		/* 82063F8Ch case    5:*/		return 0x82063F90;
		  /* 82063F90h */ case    6:  		/* rlwinm. R10, R10, 0, 21, 21 */
		/* 82063F90h case    6:*/		cpu::op::rlwinm<1,0,21,21>(regs,&regs.R10,regs.R10);
		/* 82063F90h case    6:*/		return 0x82063F94;
		  /* 82063F94h */ case    7:  		/* bc 12, CR0_EQ, 64 */
		/* 82063F94h case    7:*/		if ( regs.CR[0].eq ) { return 0x82063FD4;  }
		/* 82063F94h case    7:*/		return 0x82063F98;
	}
	return 0x82063F98;
} // Block from 82063F78h-82063F98h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82063F98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063F98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063F98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063F98);
		  /* 82063F98h */ case    0:  		/* lis R10, -32256 */
		/* 82063F98h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82063F98h case    0:*/		return 0x82063F9C;
		  /* 82063F9Ch */ case    1:  		/* lwz R9, <#[R11 + 12]> */
		/* 82063F9Ch case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 82063F9Ch case    1:*/		return 0x82063FA0;
		  /* 82063FA0h */ case    2:  		/* rlwinm R8, R5, 2, 0, 29 */
		/* 82063FA0h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R5);
		/* 82063FA0h case    2:*/		return 0x82063FA4;
		  /* 82063FA4h */ case    3:  		/* addi R10, R10, 2896 */
		/* 82063FA4h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xB50);
		/* 82063FA4h case    3:*/		return 0x82063FA8;
		  /* 82063FA8h */ case    4:  		/* addi R7, R4, 32 */
		/* 82063FA8h case    4:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R4,0x20);
		/* 82063FA8h case    4:*/		return 0x82063FAC;
		  /* 82063FACh */ case    5:  		/* li R6, 1 */
		/* 82063FACh case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 82063FACh case    5:*/		return 0x82063FB0;
		  /* 82063FB0h */ case    6:  		/* rldicl R7, R7, 0, 32 */
		/* 82063FB0h case    6:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R7,regs.R7);
		/* 82063FB0h case    6:*/		return 0x82063FB4;
		  /* 82063FB4h */ case    7:  		/* rldicr R6, R6, 63, 63 */
		/* 82063FB4h case    7:*/		cpu::op::rldicr<0,63,63>(regs,&regs.R6,regs.R6);
		/* 82063FB4h case    7:*/		return 0x82063FB8;
		  /* 82063FB8h */ case    8:  		/* lwzx R10, <#[R8 + R10]> */
		/* 82063FB8h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 82063FB8h case    8:*/		return 0x82063FBC;
		  /* 82063FBCh */ case    9:  		/* srd R8, R6, R7 */
		/* 82063FBCh case    9:*/		cpu::op::srd<0>(regs,&regs.R8,regs.R6,regs.R7);
		/* 82063FBCh case    9:*/		return 0x82063FC0;
		  /* 82063FC0h */ case   10:  		/* rlwimi R9, R10, 25, 4, 6 */
		/* 82063FC0h case   10:*/		cpu::op::rlwimi<0,25,4,6>(regs,&regs.R9,regs.R10);
		/* 82063FC0h case   10:*/		return 0x82063FC4;
		  /* 82063FC4h */ case   11:  		/* stw R9, <#[R11 + 12]> */
		/* 82063FC4h case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 82063FC4h case   11:*/		return 0x82063FC8;
		  /* 82063FC8h */ case   12:  		/* ld R11, <#[R3 + 24]> */
		/* 82063FC8h case   12:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82063FC8h case   12:*/		return 0x82063FCC;
		  /* 82063FCCh */ case   13:  		/* or R11, R8, R11 */
		/* 82063FCCh case   13:*/		cpu::op::or<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 82063FCCh case   13:*/		return 0x82063FD0;
		  /* 82063FD0h */ case   14:  		/* std R11, <#[R3 + 24]> */
		/* 82063FD0h case   14:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82063FD0h case   14:*/		return 0x82063FD4;
	}
	return 0x82063FD4;
} // Block from 82063F98h-82063FD4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82063FD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063FD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063FD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063FD4);
		  /* 82063FD4h */ case    0:  		/* add R11, R3, R4 */
		/* 82063FD4h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R4);
		/* 82063FD4h case    0:*/		return 0x82063FD8;
		  /* 82063FD8h */ case    1:  		/* stb R5, <#[R11 + 10864]> */
		/* 82063FD8h case    1:*/		cpu::mem::store8( regs, regs.R5, (uint32)(regs.R11 + 0x00002A70) );
		/* 82063FD8h case    1:*/		return 0x82063FDC;
		  /* 82063FDCh */ case    2:  		/* bclr 20, CR0_LT */
		/* 82063FDCh case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063FDCh case    2:*/		return 0x82063FE0;
	}
	return 0x82063FE0;
} // Block from 82063FD4h-82063FE0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82063FE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063FE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063FE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063FE0);
		  /* 82063FE0h */ case    0:  		/* add R11, R3, R4 */
		/* 82063FE0h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R4);
		/* 82063FE0h case    0:*/		return 0x82063FE4;
		  /* 82063FE4h */ case    1:  		/* lbz R3, <#[R11 + 10864]> */
		/* 82063FE4h case    1:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R11 + 0x00002A70) );
		/* 82063FE4h case    1:*/		return 0x82063FE8;
		  /* 82063FE8h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82063FE8h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82063FE8h case    2:*/		return 0x82063FEC;
	}
	return 0x82063FEC;
} // Block from 82063FE0h-82063FECh (3 instructions)

//////////////////////////////////////////////////////
// Block at 82063FECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063FEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063FEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063FEC);
		  /* 82063FECh */ case    0:  		/* nop */
		/* 82063FECh case    0:*/		cpu::op::nop();
		/* 82063FECh case    0:*/		return 0x82063FF0;
	}
	return 0x82063FF0;
} // Block from 82063FECh-82063FF0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82063FF0h
// Function 'D3DDevice_GetSamplerState_MinFilter'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82063FF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82063FF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82063FF0);
		  /* 82063FF0h */ case    0:  		/* stw R5, <#[R1 + 36]> */
		/* 82063FF0h case    0:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x00000024) );
		/* 82063FF0h case    0:*/		return 0x82063FF4;
		  /* 82063FF4h */ case    1:  		/* lis R10, -32256 */
		/* 82063FF4h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82063FF4h case    1:*/		return 0x82063FF8;
		  /* 82063FF8h */ case    2:  		/* addi R11, R4, 48 */
		/* 82063FF8h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x30);
		/* 82063FF8h case    2:*/		return 0x82063FFC;
		  /* 82063FFCh */ case    3:  		/* addi R9, R4, 32 */
		/* 82063FFCh case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R4,0x20);
		/* 82063FFCh case    3:*/		return 0x82064000;
		  /* 82064000h */ case    4:  		/* mulli R11, R11, 24 */
		/* 82064000h case    4:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x18);
		/* 82064000h case    4:*/		return 0x82064004;
		  /* 82064004h */ case    5:  		/* lfs FR0, <#[R10 + 2984]> */
		/* 82064004h case    5:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000BA8) );
		/* 82064004h case    5:*/		return 0x82064008;
		  /* 82064008h */ case    6:  		/* add R11, R11, R3 */
		/* 82064008h case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 82064008h case    6:*/		return 0x8206400C;
		  /* 8206400Ch */ case    7:  		/* li R10, 1 */
		/* 8206400Ch case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8206400Ch case    7:*/		return 0x82064010;
		  /* 82064010h */ case    8:  		/* rldicl R9, R9, 0, 32 */
		/* 82064010h case    8:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R9,regs.R9);
		/* 82064010h case    8:*/		return 0x82064014;
		  /* 82064014h */ case    9:  		/* rldicr R10, R10, 63, 63 */
		/* 82064014h case    9:*/		cpu::op::rldicr<0,63,63>(regs,&regs.R10,regs.R10);
		/* 82064014h case    9:*/		return 0x82064018;
		  /* 82064018h */ case   10:  		/* lwz R8, <#[R11 + 20]> */
		/* 82064018h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000014) );
		/* 82064018h case   10:*/		return 0x8206401C;
		  /* 8206401Ch */ case   11:  		/* srd R10, R10, R9 */
		/* 8206401Ch case   11:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8206401Ch case   11:*/		return 0x82064020;
		  /* 82064020h */ case   12:  		/* lfs FR13, <#[R1 + 36]> */
		/* 82064020h case   12:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000024) );
		/* 82064020h case   12:*/		return 0x82064024;
		  /* 82064024h */ case   13:  		/* fmuls FR0, FR13, FR0 */
		/* 82064024h case   13:*/		cpu::op::fmuls<0>(regs,&regs.FR0,regs.FR13,regs.FR0);
		/* 82064024h case   13:*/		return 0x82064028;
	}
	return 0x82064028;
} // Block from 82063FF0h-82064028h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82064028h
// Function 'D3DDevice_SetSamplerState_MinFilterZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064028( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064028) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064028);
		  /* 82064028h */ case    0:  		/* fctidz FR0, FR0 */
		/* 82064028h case    0:*/		cpu::op::fctidz<0>(regs,&regs.FR0,regs.FR0);
		/* 82064028h case    0:*/		return 0x8206402C;
		  /* 8206402Ch */ case    1:  		/* stfd FR0, <#[R1 - 16]> */
		/* 8206402Ch case    1:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206402Ch case    1:*/		return 0x82064030;
		  /* 82064030h */ case    2:  		/* lwz R9, <#[R1 - 12]> */
		/* 82064030h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0xFFFFFFF4) );
		/* 82064030h case    2:*/		return 0x82064034;
		  /* 82064034h */ case    3:  		/* rlwimi R8, R9, 5, 23, 26 */
		/* 82064034h case    3:*/		cpu::op::rlwimi<0,5,23,26>(regs,&regs.R8,regs.R9);
		/* 82064034h case    3:*/		return 0x82064038;
		  /* 82064038h */ case    4:  		/* stw R8, <#[R11 + 20]> */
		/* 82064038h case    4:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000014) );
		/* 82064038h case    4:*/		return 0x8206403C;
		  /* 8206403Ch */ case    5:  		/* ld R11, <#[R3 + 24]> */
		/* 8206403Ch case    5:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 8206403Ch case    5:*/		return 0x82064040;
		  /* 82064040h */ case    6:  		/* or R11, R10, R11 */
		/* 82064040h case    6:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82064040h case    6:*/		return 0x82064044;
		  /* 82064044h */ case    7:  		/* std R11, <#[R3 + 24]> */
		/* 82064044h case    7:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82064044h case    7:*/		return 0x82064048;
		  /* 82064048h */ case    8:  		/* bclr 20, CR0_LT */
		/* 82064048h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82064048h case    8:*/		return 0x8206404C;
	}
	return 0x8206404C;
} // Block from 82064028h-8206404Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8206404Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206404C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206404C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206404C);
		  /* 8206404Ch */ case    0:  		/* nop */
		/* 8206404Ch case    0:*/		cpu::op::nop();
		/* 8206404Ch case    0:*/		return 0x82064050;
	}
	return 0x82064050;
} // Block from 8206404Ch-82064050h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82064050h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064050( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064050) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064050);
		  /* 82064050h */ case    0:  		/* mulli R11, R4, 24 */
		/* 82064050h case    0:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R4,0x18);
		/* 82064050h case    0:*/		return 0x82064054;
		  /* 82064054h */ case    1:  		/* add R11, R11, R3 */
		/* 82064054h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 82064054h case    1:*/		return 0x82064058;
		  /* 82064058h */ case    2:  		/* lis R10, -32256 */
		/* 82064058h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82064058h case    2:*/		return 0x8206405C;
		  /* 8206405Ch */ case    3:  		/* lwz R11, <#[R11 + 1172]> */
		/* 8206405Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000494) );
		/* 8206405Ch case    3:*/		return 0x82064060;
		  /* 82064060h */ case    4:  		/* lfs FR0, <#[R10 + 2660]> */
		/* 82064060h case    4:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000A64) );
		/* 82064060h case    4:*/		return 0x82064064;
		  /* 82064064h */ case    5:  		/* rlwinm R11, R11, 23, 0, 8 */
		/* 82064064h case    5:*/		cpu::op::rlwinm<0,23,0,8>(regs,&regs.R11,regs.R11);
		/* 82064064h case    5:*/		return 0x82064068;
		  /* 82064068h */ case    6:  		/* srawi R11, R11, 28 */
		/* 82064068h case    6:*/		cpu::op::srawi<0,28>(regs,&regs.R11,regs.R11);
		/* 82064068h case    6:*/		return 0x8206406C;
		  /* 8206406Ch */ case    7:  		/* extsw R11, R11 */
		/* 8206406Ch case    7:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R11);
		/* 8206406Ch case    7:*/		return 0x82064070;
		  /* 82064070h */ case    8:  		/* std R11, <#[R1 - 16]> */
		/* 82064070h case    8:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82064070h case    8:*/		return 0x82064074;
		  /* 82064074h */ case    9:  		/* lfd FR13, <#[R1 - 16]> */
		/* 82064074h case    9:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82064074h case    9:*/		return 0x82064078;
		  /* 82064078h */ case   10:  		/* fcfid FR13, FR13 */
		/* 82064078h case   10:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 82064078h case   10:*/		return 0x8206407C;
		  /* 8206407Ch */ case   11:  		/* frsp FR13, FR13 */
		/* 8206407Ch case   11:*/		cpu::op::frsp<0>(regs,&regs.FR13,regs.FR13);
		/* 8206407Ch case   11:*/		return 0x82064080;
		  /* 82064080h */ case   12:  		/* fmuls FR0, FR13, FR0 */
		/* 82064080h case   12:*/		cpu::op::fmuls<0>(regs,&regs.FR0,regs.FR13,regs.FR0);
		/* 82064080h case   12:*/		return 0x82064084;
		  /* 82064084h */ case   13:  		/* fneg FR0, FR0 */
		/* 82064084h case   13:*/		cpu::op::fneg<0>(regs,&regs.FR0,regs.FR0);
		/* 82064084h case   13:*/		return 0x82064088;
		  /* 82064088h */ case   14:  		/* stfs FR0, <#[R1 - 16]> */
		/* 82064088h case   14:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82064088h case   14:*/		return 0x8206408C;
		  /* 8206408Ch */ case   15:  		/* lwz R3, <#[R1 - 16]> */
		/* 8206408Ch case   15:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206408Ch case   15:*/		return 0x82064090;
		  /* 82064090h */ case   16:  		/* bclr 20, CR0_LT */
		/* 82064090h case   16:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82064090h case   16:*/		return 0x82064094;
	}
	return 0x82064094;
} // Block from 82064050h-82064094h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82064094h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064094( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064094) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064094);
		  /* 82064094h */ case    0:  		/* nop */
		/* 82064094h case    0:*/		cpu::op::nop();
		/* 82064094h case    0:*/		return 0x82064098;
	}
	return 0x82064098;
} // Block from 82064094h-82064098h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82064098h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064098( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064098) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064098);
		  /* 82064098h */ case    0:  		/* stw R5, <#[R1 + 36]> */
		/* 82064098h case    0:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x00000024) );
		/* 82064098h case    0:*/		return 0x8206409C;
		  /* 8206409Ch */ case    1:  		/* lis R10, -32256 */
		/* 8206409Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 8206409Ch case    1:*/		return 0x820640A0;
		  /* 820640A0h */ case    2:  		/* addi R11, R4, 48 */
		/* 820640A0h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x30);
		/* 820640A0h case    2:*/		return 0x820640A4;
		  /* 820640A4h */ case    3:  		/* addi R9, R4, 32 */
		/* 820640A4h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R4,0x20);
		/* 820640A4h case    3:*/		return 0x820640A8;
		  /* 820640A8h */ case    4:  		/* mulli R11, R11, 24 */
		/* 820640A8h case    4:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x18);
		/* 820640A8h case    4:*/		return 0x820640AC;
		  /* 820640ACh */ case    5:  		/* lfs FR0, <#[R10 + 2728]> */
		/* 820640ACh case    5:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000AA8) );
		/* 820640ACh case    5:*/		return 0x820640B0;
		  /* 820640B0h */ case    6:  		/* add R11, R11, R3 */
		/* 820640B0h case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 820640B0h case    6:*/		return 0x820640B4;
		  /* 820640B4h */ case    7:  		/* li R10, 1 */
		/* 820640B4h case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820640B4h case    7:*/		return 0x820640B8;
		  /* 820640B8h */ case    8:  		/* rldicl R9, R9, 0, 32 */
		/* 820640B8h case    8:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R9,regs.R9);
		/* 820640B8h case    8:*/		return 0x820640BC;
		  /* 820640BCh */ case    9:  		/* rldicr R10, R10, 63, 63 */
		/* 820640BCh case    9:*/		cpu::op::rldicr<0,63,63>(regs,&regs.R10,regs.R10);
		/* 820640BCh case    9:*/		return 0x820640C0;
	}
	return 0x820640C0;
} // Block from 82064098h-820640C0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820640C0h
// Function 'D3DDevice_GetSamplerState_MinFilterZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820640C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820640C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820640C0);
		  /* 820640C0h */ case    0:  		/* lwz R8, <#[R11 + 16]> */
		/* 820640C0h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000010) );
		/* 820640C0h case    0:*/		return 0x820640C4;
		  /* 820640C4h */ case    1:  		/* srd R10, R10, R9 */
		/* 820640C4h case    1:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 820640C4h case    1:*/		return 0x820640C8;
		  /* 820640C8h */ case    2:  		/* lfs FR13, <#[R1 + 36]> */
		/* 820640C8h case    2:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000024) );
		/* 820640C8h case    2:*/		return 0x820640CC;
		  /* 820640CCh */ case    3:  		/* fmuls FR0, FR13, FR0 */
		/* 820640CCh case    3:*/		cpu::op::fmuls<0>(regs,&regs.FR0,regs.FR13,regs.FR0);
		/* 820640CCh case    3:*/		return 0x820640D0;
	}
	return 0x820640D0;
} // Block from 820640C0h-820640D0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820640D0h
// Function 'D3DDevice_SetSamplerState_MagFilter'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820640D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820640D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820640D0);
		  /* 820640D0h */ case    0:  		/* fctidz FR0, FR0 */
		/* 820640D0h case    0:*/		cpu::op::fctidz<0>(regs,&regs.FR0,regs.FR0);
		/* 820640D0h case    0:*/		return 0x820640D4;
		  /* 820640D4h */ case    1:  		/* stfd FR0, <#[R1 - 16]> */
		/* 820640D4h case    1:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820640D4h case    1:*/		return 0x820640D8;
		  /* 820640D8h */ case    2:  		/* lwz R9, <#[R1 - 12]> */
		/* 820640D8h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0xFFFFFFF4) );
		/* 820640D8h case    2:*/		return 0x820640DC;
		  /* 820640DCh */ case    3:  		/* rlwimi R8, R9, 12, 10, 19 */
		/* 820640DCh case    3:*/		cpu::op::rlwimi<0,12,10,19>(regs,&regs.R8,regs.R9);
		/* 820640DCh case    3:*/		return 0x820640E0;
		  /* 820640E0h */ case    4:  		/* stw R8, <#[R11 + 16]> */
		/* 820640E0h case    4:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000010) );
		/* 820640E0h case    4:*/		return 0x820640E4;
		  /* 820640E4h */ case    5:  		/* ld R11, <#[R3 + 24]> */
		/* 820640E4h case    5:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820640E4h case    5:*/		return 0x820640E8;
		  /* 820640E8h */ case    6:  		/* or R11, R10, R11 */
		/* 820640E8h case    6:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820640E8h case    6:*/		return 0x820640EC;
		  /* 820640ECh */ case    7:  		/* std R11, <#[R3 + 24]> */
		/* 820640ECh case    7:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820640ECh case    7:*/		return 0x820640F0;
		  /* 820640F0h */ case    8:  		/* bclr 20, CR0_LT */
		/* 820640F0h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820640F0h case    8:*/		return 0x820640F4;
	}
	return 0x820640F4;
} // Block from 820640D0h-820640F4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820640F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820640F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820640F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820640F4);
		  /* 820640F4h */ case    0:  		/* nop */
		/* 820640F4h case    0:*/		cpu::op::nop();
		/* 820640F4h case    0:*/		return 0x820640F8;
	}
	return 0x820640F8;
} // Block from 820640F4h-820640F8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820640F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820640F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820640F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820640F8);
		  /* 820640F8h */ case    0:  		/* mulli R11, R4, 24 */
		/* 820640F8h case    0:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R4,0x18);
		/* 820640F8h case    0:*/		return 0x820640FC;
		  /* 820640FCh */ case    1:  		/* add R11, R11, R3 */
		/* 820640FCh case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 820640FCh case    1:*/		return 0x82064100;
		  /* 82064100h */ case    2:  		/* lis R10, -32256 */
		/* 82064100h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82064100h case    2:*/		return 0x82064104;
		  /* 82064104h */ case    3:  		/* lwz R11, <#[R11 + 1168]> */
		/* 82064104h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000490) );
		/* 82064104h case    3:*/		return 0x82064108;
		  /* 82064108h */ case    4:  		/* lfs FR0, <#[R10 + 2988]> */
		/* 82064108h case    4:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000BAC) );
		/* 82064108h case    4:*/		return 0x8206410C;
		  /* 8206410Ch */ case    5:  		/* rlwinm R11, R11, 10, 0, 21 */
		/* 8206410Ch case    5:*/		cpu::op::rlwinm<0,10,0,21>(regs,&regs.R11,regs.R11);
		/* 8206410Ch case    5:*/		return 0x82064110;
		  /* 82064110h */ case    6:  		/* srawi R11, R11, 22 */
		/* 82064110h case    6:*/		cpu::op::srawi<0,22>(regs,&regs.R11,regs.R11);
		/* 82064110h case    6:*/		return 0x82064114;
		  /* 82064114h */ case    7:  		/* extsw R11, R11 */
		/* 82064114h case    7:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R11);
		/* 82064114h case    7:*/		return 0x82064118;
		  /* 82064118h */ case    8:  		/* std R11, <#[R1 - 16]> */
		/* 82064118h case    8:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82064118h case    8:*/		return 0x8206411C;
		  /* 8206411Ch */ case    9:  		/* lfd FR13, <#[R1 - 16]> */
		/* 8206411Ch case    9:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206411Ch case    9:*/		return 0x82064120;
		  /* 82064120h */ case   10:  		/* fcfid FR13, FR13 */
		/* 82064120h case   10:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 82064120h case   10:*/		return 0x82064124;
		  /* 82064124h */ case   11:  		/* frsp FR13, FR13 */
		/* 82064124h case   11:*/		cpu::op::frsp<0>(regs,&regs.FR13,regs.FR13);
		/* 82064124h case   11:*/		return 0x82064128;
		  /* 82064128h */ case   12:  		/* fmuls FR0, FR13, FR0 */
		/* 82064128h case   12:*/		cpu::op::fmuls<0>(regs,&regs.FR0,regs.FR13,regs.FR0);
		/* 82064128h case   12:*/		return 0x8206412C;
		  /* 8206412Ch */ case   13:  		/* stfs FR0, <#[R1 - 16]> */
		/* 8206412Ch case   13:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206412Ch case   13:*/		return 0x82064130;
		  /* 82064130h */ case   14:  		/* lwz R3, <#[R1 - 16]> */
		/* 82064130h case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82064130h case   14:*/		return 0x82064134;
		  /* 82064134h */ case   15:  		/* bclr 20, CR0_LT */
		/* 82064134h case   15:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82064134h case   15:*/		return 0x82064138;
	}
	return 0x82064138;
} // Block from 820640F8h-82064138h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82064138h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064138( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064138) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064138);
		  /* 82064138h */ case    0:  		/* addi R11, R4, 3230 */
		/* 82064138h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0xC9E);
		/* 82064138h case    0:*/		return 0x8206413C;
		  /* 8206413Ch */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8206413Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8206413Ch case    1:*/		return 0x82064140;
		  /* 82064140h */ case    2:  		/* lwzx R11, <#[R11 + R3]> */
		/* 82064140h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 82064140h case    2:*/		return 0x82064144;
		  /* 82064144h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 82064144h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82064144h case    3:*/		return 0x82064148;
		  /* 82064148h */ case    4:  		/* bc 12, CR6_EQ, 80 */
		/* 82064148h case    4:*/		if ( regs.CR[6].eq ) { return 0x82064198;  }
		/* 82064148h case    4:*/		return 0x8206414C;
		  /* 8206414Ch */ case    5:  		/* lwz R11, <#[R11 + 44]> */
		/* 8206414Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000002C) );
		/* 8206414Ch case    5:*/		return 0x82064150;
		  /* 82064150h */ case    6:  		/* addi R10, R4, 48 */
		/* 82064150h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x30);
		/* 82064150h case    6:*/		return 0x82064154;
		  /* 82064154h */ case    7:  		/* rlwinm R11, R11, 30, 28, 31 */
		/* 82064154h case    7:*/		cpu::op::rlwinm<0,30,28,31>(regs,&regs.R11,regs.R11);
		/* 82064154h case    7:*/		return 0x82064158;
		  /* 82064158h */ case    8:  		/* mulli R10, R10, 24 */
		/* 82064158h case    8:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x18);
		/* 82064158h case    8:*/		return 0x8206415C;
		  /* 8206415Ch */ case    9:  		/* add R10, R10, R3 */
		/* 8206415Ch case    9:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R3);
		/* 8206415Ch case    9:*/		return 0x82064160;
		  /* 82064160h */ case   10:  		/* cmplw CR6, R11, R5 */
		/* 82064160h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R5);
		/* 82064160h case   10:*/		return 0x82064164;
		  /* 82064164h */ case   11:  		/* bc 12, CR6_GT, 8 */
		/* 82064164h case   11:*/		if ( regs.CR[6].gt ) { return 0x8206416C;  }
		/* 82064164h case   11:*/		return 0x82064168;
		  /* 82064168h */ case   12:  		/* mr R11, R5 */
		/* 82064168h case   12:*/		regs.R11 = regs.R5;
		/* 82064168h case   12:*/		return 0x8206416C;
	}
	return 0x8206416C;
} // Block from 82064138h-8206416Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8206416Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206416C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206416C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206416C);
		  /* 8206416Ch */ case    0:  		/* lwz R9, <#[R10 + 16]> */
		/* 8206416Ch case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000010) );
		/* 8206416Ch case    0:*/		return 0x82064170;
		  /* 82064170h */ case    1:  		/* addi R8, R4, 32 */
		/* 82064170h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R4,0x20);
		/* 82064170h case    1:*/		return 0x82064174;
		  /* 82064174h */ case    2:  		/* li R7, 1 */
		/* 82064174h case    2:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 82064174h case    2:*/		return 0x82064178;
		  /* 82064178h */ case    3:  		/* rlwimi R9, R11, 2, 26, 29 */
		/* 82064178h case    3:*/		cpu::op::rlwimi<0,2,26,29>(regs,&regs.R9,regs.R11);
		/* 82064178h case    3:*/		return 0x8206417C;
		  /* 8206417Ch */ case    4:  		/* rldicr R11, R7, 63, 63 */
		/* 8206417Ch case    4:*/		cpu::op::rldicr<0,63,63>(regs,&regs.R11,regs.R7);
		/* 8206417Ch case    4:*/		return 0x82064180;
		  /* 82064180h */ case    5:  		/* stw R9, <#[R10 + 16]> */
		/* 82064180h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000010) );
		/* 82064180h case    5:*/		return 0x82064184;
		  /* 82064184h */ case    6:  		/* rldicl R10, R8, 0, 32 */
		/* 82064184h case    6:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R10,regs.R8);
		/* 82064184h case    6:*/		return 0x82064188;
		  /* 82064188h */ case    7:  		/* srd R11, R11, R10 */
		/* 82064188h case    7:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82064188h case    7:*/		return 0x8206418C;
		  /* 8206418Ch */ case    8:  		/* ld R10, <#[R3 + 24]> */
		/* 8206418Ch case    8:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R3 + 0x00000018) );
		/* 8206418Ch case    8:*/		return 0x82064190;
		  /* 82064190h */ case    9:  		/* or R11, R11, R10 */
		/* 82064190h case    9:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82064190h case    9:*/		return 0x82064194;
		  /* 82064194h */ case   10:  		/* std R11, <#[R3 + 24]> */
		/* 82064194h case   10:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82064194h case   10:*/		return 0x82064198;
	}
	return 0x82064198;
} // Block from 8206416Ch-82064198h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82064198h
// Function 'D3DDevice_GetSamplerState_MagFilter'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064198( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064198) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064198);
		  /* 82064198h */ case    0:  		/* add R11, R3, R4 */
		/* 82064198h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R4);
		/* 82064198h case    0:*/		return 0x8206419C;
		  /* 8206419Ch */ case    1:  		/* stb R5, <#[R11 + 12356]> */
		/* 8206419Ch case    1:*/		cpu::mem::store8( regs, regs.R5, (uint32)(regs.R11 + 0x00003044) );
		/* 8206419Ch case    1:*/		return 0x820641A0;
		  /* 820641A0h */ case    2:  		/* bclr 20, CR0_LT */
		/* 820641A0h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820641A0h case    2:*/		return 0x820641A4;
	}
	return 0x820641A4;
} // Block from 82064198h-820641A4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820641A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820641A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820641A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820641A4);
		  /* 820641A4h */ case    0:  		/* nop */
		/* 820641A4h case    0:*/		cpu::op::nop();
		/* 820641A4h case    0:*/		return 0x820641A8;
	}
	return 0x820641A8;
} // Block from 820641A4h-820641A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820641A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820641A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820641A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820641A8);
		  /* 820641A8h */ case    0:  		/* add R11, R3, R4 */
		/* 820641A8h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R4);
		/* 820641A8h case    0:*/		return 0x820641AC;
		  /* 820641ACh */ case    1:  		/* lbz R3, <#[R11 + 12356]> */
		/* 820641ACh case    1:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R11 + 0x00003044) );
		/* 820641ACh case    1:*/		return 0x820641B0;
		  /* 820641B0h */ case    2:  		/* bclr 20, CR0_LT */
		/* 820641B0h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820641B0h case    2:*/		return 0x820641B4;
	}
	return 0x820641B4;
} // Block from 820641A8h-820641B4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820641B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820641B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820641B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820641B4);
		  /* 820641B4h */ case    0:  		/* nop */
		/* 820641B4h case    0:*/		cpu::op::nop();
		/* 820641B4h case    0:*/		return 0x820641B8;
	}
	return 0x820641B8;
} // Block from 820641B4h-820641B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820641B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820641B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820641B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820641B8);
		  /* 820641B8h */ case    0:  		/* addi R11, R4, 3230 */
		/* 820641B8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0xC9E);
		/* 820641B8h case    0:*/		return 0x820641BC;
		  /* 820641BCh */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 820641BCh case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 820641BCh case    1:*/		return 0x820641C0;
		  /* 820641C0h */ case    2:  		/* lwzx R11, <#[R11 + R3]> */
		/* 820641C0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 820641C0h case    2:*/		return 0x820641C4;
		  /* 820641C4h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 820641C4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820641C4h case    3:*/		return 0x820641C8;
		  /* 820641C8h */ case    4:  		/* bc 12, CR6_EQ, 80 */
		/* 820641C8h case    4:*/		if ( regs.CR[6].eq ) { return 0x82064218;  }
		/* 820641C8h case    4:*/		return 0x820641CC;
		  /* 820641CCh */ case    5:  		/* lwz R11, <#[R11 + 44]> */
		/* 820641CCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000002C) );
		/* 820641CCh case    5:*/		return 0x820641D0;
	}
	return 0x820641D0;
} // Block from 820641B8h-820641D0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820641D0h
// Function 'D3DDevice_SetSamplerState_MagFilterZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820641D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820641D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820641D0);
		  /* 820641D0h */ case    0:  		/* addi R10, R4, 48 */
		/* 820641D0h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x30);
		/* 820641D0h case    0:*/		return 0x820641D4;
		  /* 820641D4h */ case    1:  		/* rlwinm R11, R11, 26, 28, 31 */
		/* 820641D4h case    1:*/		cpu::op::rlwinm<0,26,28,31>(regs,&regs.R11,regs.R11);
		/* 820641D4h case    1:*/		return 0x820641D8;
		  /* 820641D8h */ case    2:  		/* mulli R10, R10, 24 */
		/* 820641D8h case    2:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x18);
		/* 820641D8h case    2:*/		return 0x820641DC;
		  /* 820641DCh */ case    3:  		/* add R10, R10, R3 */
		/* 820641DCh case    3:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R3);
		/* 820641DCh case    3:*/		return 0x820641E0;
		  /* 820641E0h */ case    4:  		/* cmplw CR6, R11, R5 */
		/* 820641E0h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R5);
		/* 820641E0h case    4:*/		return 0x820641E4;
		  /* 820641E4h */ case    5:  		/* bc 12, CR6_LT, 8 */
		/* 820641E4h case    5:*/		if ( regs.CR[6].lt ) { return 0x820641EC;  }
		/* 820641E4h case    5:*/		return 0x820641E8;
		  /* 820641E8h */ case    6:  		/* mr R11, R5 */
		/* 820641E8h case    6:*/		regs.R11 = regs.R5;
		/* 820641E8h case    6:*/		return 0x820641EC;
	}
	return 0x820641EC;
} // Block from 820641D0h-820641ECh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820641ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820641EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820641EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820641EC);
		  /* 820641ECh */ case    0:  		/* lwz R9, <#[R10 + 16]> */
		/* 820641ECh case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000010) );
		/* 820641ECh case    0:*/		return 0x820641F0;
		  /* 820641F0h */ case    1:  		/* addi R8, R4, 32 */
		/* 820641F0h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R4,0x20);
		/* 820641F0h case    1:*/		return 0x820641F4;
		  /* 820641F4h */ case    2:  		/* li R7, 1 */
		/* 820641F4h case    2:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 820641F4h case    2:*/		return 0x820641F8;
		  /* 820641F8h */ case    3:  		/* rlwimi R9, R11, 6, 22, 25 */
		/* 820641F8h case    3:*/		cpu::op::rlwimi<0,6,22,25>(regs,&regs.R9,regs.R11);
		/* 820641F8h case    3:*/		return 0x820641FC;
		  /* 820641FCh */ case    4:  		/* rldicr R11, R7, 63, 63 */
		/* 820641FCh case    4:*/		cpu::op::rldicr<0,63,63>(regs,&regs.R11,regs.R7);
		/* 820641FCh case    4:*/		return 0x82064200;
		  /* 82064200h */ case    5:  		/* stw R9, <#[R10 + 16]> */
		/* 82064200h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000010) );
		/* 82064200h case    5:*/		return 0x82064204;
		  /* 82064204h */ case    6:  		/* rldicl R10, R8, 0, 32 */
		/* 82064204h case    6:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R10,regs.R8);
		/* 82064204h case    6:*/		return 0x82064208;
		  /* 82064208h */ case    7:  		/* srd R11, R11, R10 */
		/* 82064208h case    7:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82064208h case    7:*/		return 0x8206420C;
		  /* 8206420Ch */ case    8:  		/* ld R10, <#[R3 + 24]> */
		/* 8206420Ch case    8:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R3 + 0x00000018) );
		/* 8206420Ch case    8:*/		return 0x82064210;
		  /* 82064210h */ case    9:  		/* or R11, R11, R10 */
		/* 82064210h case    9:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82064210h case    9:*/		return 0x82064214;
		  /* 82064214h */ case   10:  		/* std R11, <#[R3 + 24]> */
		/* 82064214h case   10:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82064214h case   10:*/		return 0x82064218;
	}
	return 0x82064218;
} // Block from 820641ECh-82064218h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82064218h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064218( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064218) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064218);
		  /* 82064218h */ case    0:  		/* add R11, R3, R4 */
		/* 82064218h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R4);
		/* 82064218h case    0:*/		return 0x8206421C;
		  /* 8206421Ch */ case    1:  		/* stb R5, <#[R11 + 12382]> */
		/* 8206421Ch case    1:*/		cpu::mem::store8( regs, regs.R5, (uint32)(regs.R11 + 0x0000305E) );
		/* 8206421Ch case    1:*/		return 0x82064220;
		  /* 82064220h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82064220h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82064220h case    2:*/		return 0x82064224;
	}
	return 0x82064224;
} // Block from 82064218h-82064224h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82064224h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064224( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064224) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064224);
		  /* 82064224h */ case    0:  		/* nop */
		/* 82064224h case    0:*/		cpu::op::nop();
		/* 82064224h case    0:*/		return 0x82064228;
	}
	return 0x82064228;
} // Block from 82064224h-82064228h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82064228h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064228( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064228) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064228);
		  /* 82064228h */ case    0:  		/* add R11, R3, R4 */
		/* 82064228h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R4);
		/* 82064228h case    0:*/		return 0x8206422C;
		  /* 8206422Ch */ case    1:  		/* lbz R3, <#[R11 + 12382]> */
		/* 8206422Ch case    1:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R11 + 0x0000305E) );
		/* 8206422Ch case    1:*/		return 0x82064230;
		  /* 82064230h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82064230h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82064230h case    2:*/		return 0x82064234;
	}
	return 0x82064234;
} // Block from 82064228h-82064234h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82064234h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064234( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064234) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064234);
		  /* 82064234h */ case    0:  		/* nop */
		/* 82064234h case    0:*/		cpu::op::nop();
		/* 82064234h case    0:*/		return 0x82064238;
	}
	return 0x82064238;
} // Block from 82064234h-82064238h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82064238h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064238( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064238) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064238);
		  /* 82064238h */ case    0:  		/* addi R11, R4, 48 */
		/* 82064238h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x30);
		/* 82064238h case    0:*/		return 0x8206423C;
		  /* 8206423Ch */ case    1:  		/* addic R10, R5, -1 */
		/* 8206423Ch case    1:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R5,0xFFFFFFFF);
		/* 8206423Ch case    1:*/		return 0x82064240;
		  /* 82064240h */ case    2:  		/* mulli R11, R11, 24 */
		/* 82064240h case    2:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x18);
		/* 82064240h case    2:*/		return 0x82064244;
		  /* 82064244h */ case    3:  		/* add R11, R11, R3 */
		/* 82064244h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 82064244h case    3:*/		return 0x82064248;
		  /* 82064248h */ case    4:  		/* subfe R10, R10, R5 */
		/* 82064248h case    4:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R5);
		/* 82064248h case    4:*/		return 0x8206424C;
		  /* 8206424Ch */ case    5:  		/* addi R9, R4, 32 */
		/* 8206424Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R4,0x20);
		/* 8206424Ch case    5:*/		return 0x82064250;
		  /* 82064250h */ case    6:  		/* li R8, 1 */
		/* 82064250h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82064250h case    6:*/		return 0x82064254;
		  /* 82064254h */ case    7:  		/* rldicl R9, R9, 0, 32 */
		/* 82064254h case    7:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R9,regs.R9);
		/* 82064254h case    7:*/		return 0x82064258;
		  /* 82064258h */ case    8:  		/* lwz R7, <#[R11 + 20]> */
		/* 82064258h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000014) );
		/* 82064258h case    8:*/		return 0x8206425C;
		  /* 8206425Ch */ case    9:  		/* rldicr R8, R8, 63, 63 */
		/* 8206425Ch case    9:*/		cpu::op::rldicr<0,63,63>(regs,&regs.R8,regs.R8);
		/* 8206425Ch case    9:*/		return 0x82064260;
	}
	return 0x82064260;
} // Block from 82064238h-82064260h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82064260h
// Function 'D3DDevice_GetSamplerState_MagFilterZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064260( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064260) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064260);
		  /* 82064260h */ case    0:  		/* rlwimi R10, R7, 0, 0, 29 */
		/* 82064260h case    0:*/		cpu::op::rlwimi<0,0,0,29>(regs,&regs.R10,regs.R7);
		/* 82064260h case    0:*/		return 0x82064264;
		  /* 82064264h */ case    1:  		/* stw R10, <#[R11 + 20]> */
		/* 82064264h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000014) );
		/* 82064264h case    1:*/		return 0x82064268;
		  /* 82064268h */ case    2:  		/* srd R11, R8, R9 */
		/* 82064268h case    2:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R8,regs.R9);
		/* 82064268h case    2:*/		return 0x8206426C;
		  /* 8206426Ch */ case    3:  		/* ld R10, <#[R3 + 24]> */
		/* 8206426Ch case    3:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R3 + 0x00000018) );
		/* 8206426Ch case    3:*/		return 0x82064270;
	}
	return 0x82064270;
} // Block from 82064260h-82064270h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82064270h
// Function 'D3DDevice_SetSamplerState_MipFilter'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064270( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064270) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064270);
		  /* 82064270h */ case    0:  		/* or R11, R11, R10 */
		/* 82064270h case    0:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82064270h case    0:*/		return 0x82064274;
		  /* 82064274h */ case    1:  		/* std R11, <#[R3 + 24]> */
		/* 82064274h case    1:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82064274h case    1:*/		return 0x82064278;
		  /* 82064278h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82064278h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82064278h case    2:*/		return 0x8206427C;
	}
	return 0x8206427C;
} // Block from 82064270h-8206427Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206427Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206427C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206427C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206427C);
		  /* 8206427Ch */ case    0:  		/* nop */
		/* 8206427Ch case    0:*/		cpu::op::nop();
		/* 8206427Ch case    0:*/		return 0x82064280;
	}
	return 0x82064280;
} // Block from 8206427Ch-82064280h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82064280h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064280( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064280) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064280);
		  /* 82064280h */ case    0:  		/* mulli R11, R4, 24 */
		/* 82064280h case    0:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R4,0x18);
		/* 82064280h case    0:*/		return 0x82064284;
		  /* 82064284h */ case    1:  		/* add R11, R11, R3 */
		/* 82064284h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 82064284h case    1:*/		return 0x82064288;
		  /* 82064288h */ case    2:  		/* li R10, -1 */
		/* 82064288h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 82064288h case    2:*/		return 0x8206428C;
		  /* 8206428Ch */ case    3:  		/* lwz R11, <#[R11 + 1172]> */
		/* 8206428Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000494) );
		/* 8206428Ch case    3:*/		return 0x82064290;
		  /* 82064290h */ case    4:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 82064290h case    4:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 82064290h case    4:*/		return 0x82064294;
		  /* 82064294h */ case    5:  		/* subfic R11, R11, 0 */
		/* 82064294h case    5:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x0);
		/* 82064294h case    5:*/		return 0x82064298;
		  /* 82064298h */ case    6:  		/* subfe R11, R11, R11 */
		/* 82064298h case    6:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82064298h case    6:*/		return 0x8206429C;
		  /* 8206429Ch */ case    7:  		/* and R3, R11, R10 */
		/* 8206429Ch case    7:*/		cpu::op::and<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 8206429Ch case    7:*/		return 0x820642A0;
		  /* 820642A0h */ case    8:  		/* bclr 20, CR0_LT */
		/* 820642A0h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820642A0h case    8:*/		return 0x820642A4;
	}
	return 0x820642A4;
} // Block from 82064280h-820642A4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820642A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820642A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820642A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820642A4);
		  /* 820642A4h */ case    0:  		/* nop */
		/* 820642A4h case    0:*/		cpu::op::nop();
		/* 820642A4h case    0:*/		return 0x820642A8;
	}
	return 0x820642A8;
} // Block from 820642A4h-820642A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820642A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820642A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820642A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820642A8);
		  /* 820642A8h */ case    0:  		/* addi R11, R4, 48 */
		/* 820642A8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x30);
		/* 820642A8h case    0:*/		return 0x820642AC;
		  /* 820642ACh */ case    1:  		/* addi R10, R4, 32 */
		/* 820642ACh case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x20);
		/* 820642ACh case    1:*/		return 0x820642B0;
	}
	return 0x820642B0;
} // Block from 820642A8h-820642B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820642B0h
// Function 'D3DDevice_GetSamplerState_MipFilter'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820642B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820642B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820642B0);
		  /* 820642B0h */ case    0:  		/* mulli R11, R11, 24 */
		/* 820642B0h case    0:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x18);
		/* 820642B0h case    0:*/		return 0x820642B4;
		  /* 820642B4h */ case    1:  		/* lwzx R9, <#[R11 + R3]> */
		/* 820642B4h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 820642B4h case    1:*/		return 0x820642B8;
		  /* 820642B8h */ case    2:  		/* rlwimi R9, R5, 10, 19, 21 */
		/* 820642B8h case    2:*/		cpu::op::rlwimi<0,10,19,21>(regs,&regs.R9,regs.R5);
		/* 820642B8h case    2:*/		return 0x820642BC;
		  /* 820642BCh */ case    3:  		/* li R8, 1 */
		/* 820642BCh case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820642BCh case    3:*/		return 0x820642C0;
		  /* 820642C0h */ case    4:  		/* stwx R9, <#[R11 + R3]> */
		/* 820642C0h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 820642C0h case    4:*/		return 0x820642C4;
		  /* 820642C4h */ case    5:  		/* rldicl R11, R10, 0, 32 */
		/* 820642C4h case    5:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R11,regs.R10);
		/* 820642C4h case    5:*/		return 0x820642C8;
	}
	return 0x820642C8;
} // Block from 820642B0h-820642C8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820642C8h
// Function 'D3DDevice_SetSamplerState_SeparateZFilterEnable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820642C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820642C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820642C8);
		  /* 820642C8h */ case    0:  		/* rldicr R10, R8, 63, 63 */
		/* 820642C8h case    0:*/		cpu::op::rldicr<0,63,63>(regs,&regs.R10,regs.R8);
		/* 820642C8h case    0:*/		return 0x820642CC;
		  /* 820642CCh */ case    1:  		/* srd R11, R10, R11 */
		/* 820642CCh case    1:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820642CCh case    1:*/		return 0x820642D0;
		  /* 820642D0h */ case    2:  		/* ld R10, <#[R3 + 24]> */
		/* 820642D0h case    2:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R3 + 0x00000018) );
		/* 820642D0h case    2:*/		return 0x820642D4;
		  /* 820642D4h */ case    3:  		/* or R11, R11, R10 */
		/* 820642D4h case    3:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820642D4h case    3:*/		return 0x820642D8;
		  /* 820642D8h */ case    4:  		/* std R11, <#[R3 + 24]> */
		/* 820642D8h case    4:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820642D8h case    4:*/		return 0x820642DC;
		  /* 820642DCh */ case    5:  		/* bclr 20, CR0_LT */
		/* 820642DCh case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820642DCh case    5:*/		return 0x820642E0;
	}
	return 0x820642E0;
} // Block from 820642C8h-820642E0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820642E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820642E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820642E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820642E0);
		  /* 820642E0h */ case    0:  		/* addi R11, R4, 48 */
		/* 820642E0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x30);
		/* 820642E0h case    0:*/		return 0x820642E4;
		  /* 820642E4h */ case    1:  		/* mulli R11, R11, 24 */
		/* 820642E4h case    1:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x18);
		/* 820642E4h case    1:*/		return 0x820642E8;
		  /* 820642E8h */ case    2:  		/* lwzx R11, <#[R11 + R3]> */
		/* 820642E8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 820642E8h case    2:*/		return 0x820642EC;
		  /* 820642ECh */ case    3:  		/* rlwinm R3, R11, 22, 29, 31 */
		/* 820642ECh case    3:*/		cpu::op::rlwinm<0,22,29,31>(regs,&regs.R3,regs.R11);
		/* 820642ECh case    3:*/		return 0x820642F0;
		  /* 820642F0h */ case    4:  		/* bclr 20, CR0_LT */
		/* 820642F0h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820642F0h case    4:*/		return 0x820642F4;
	}
	return 0x820642F4;
} // Block from 820642E0h-820642F4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820642F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820642F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820642F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820642F4);
		  /* 820642F4h */ case    0:  		/* nop */
		/* 820642F4h case    0:*/		cpu::op::nop();
		/* 820642F4h case    0:*/		return 0x820642F8;
	}
	return 0x820642F8;
} // Block from 820642F4h-820642F8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820642F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820642F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820642F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820642F8);
		  /* 820642F8h */ case    0:  		/* addi R11, R4, 48 */
		/* 820642F8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x30);
		/* 820642F8h case    0:*/		return 0x820642FC;
		  /* 820642FCh */ case    1:  		/* addi R10, R4, 32 */
		/* 820642FCh case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x20);
		/* 820642FCh case    1:*/		return 0x82064300;
		  /* 82064300h */ case    2:  		/* mulli R11, R11, 24 */
		/* 82064300h case    2:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x18);
		/* 82064300h case    2:*/		return 0x82064304;
		  /* 82064304h */ case    3:  		/* lwzx R9, <#[R11 + R3]> */
		/* 82064304h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 82064304h case    3:*/		return 0x82064308;
		  /* 82064308h */ case    4:  		/* rlwimi R9, R5, 13, 16, 18 */
		/* 82064308h case    4:*/		cpu::op::rlwimi<0,13,16,18>(regs,&regs.R9,regs.R5);
		/* 82064308h case    4:*/		return 0x8206430C;
		  /* 8206430Ch */ case    5:  		/* li R8, 1 */
		/* 8206430Ch case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 8206430Ch case    5:*/		return 0x82064310;
		  /* 82064310h */ case    6:  		/* stwx R9, <#[R11 + R3]> */
		/* 82064310h case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 82064310h case    6:*/		return 0x82064314;
		  /* 82064314h */ case    7:  		/* rldicl R11, R10, 0, 32 */
		/* 82064314h case    7:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R11,regs.R10);
		/* 82064314h case    7:*/		return 0x82064318;
		  /* 82064318h */ case    8:  		/* rldicr R10, R8, 63, 63 */
		/* 82064318h case    8:*/		cpu::op::rldicr<0,63,63>(regs,&regs.R10,regs.R8);
		/* 82064318h case    8:*/		return 0x8206431C;
		  /* 8206431Ch */ case    9:  		/* srd R11, R10, R11 */
		/* 8206431Ch case    9:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8206431Ch case    9:*/		return 0x82064320;
		  /* 82064320h */ case   10:  		/* ld R10, <#[R3 + 24]> */
		/* 82064320h case   10:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R3 + 0x00000018) );
		/* 82064320h case   10:*/		return 0x82064324;
		  /* 82064324h */ case   11:  		/* or R11, R11, R10 */
		/* 82064324h case   11:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82064324h case   11:*/		return 0x82064328;
		  /* 82064328h */ case   12:  		/* std R11, <#[R3 + 24]> */
		/* 82064328h case   12:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82064328h case   12:*/		return 0x8206432C;
		  /* 8206432Ch */ case   13:  		/* bclr 20, CR0_LT */
		/* 8206432Ch case   13:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206432Ch case   13:*/		return 0x82064330;
	}
	return 0x82064330;
} // Block from 820642F8h-82064330h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82064330h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064330( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064330) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064330);
		  /* 82064330h */ case    0:  		/* addi R11, R4, 48 */
		/* 82064330h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x30);
		/* 82064330h case    0:*/		return 0x82064334;
		  /* 82064334h */ case    1:  		/* mulli R11, R11, 24 */
		/* 82064334h case    1:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x18);
		/* 82064334h case    1:*/		return 0x82064338;
		  /* 82064338h */ case    2:  		/* lwzx R11, <#[R11 + R3]> */
		/* 82064338h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 82064338h case    2:*/		return 0x8206433C;
		  /* 8206433Ch */ case    3:  		/* rlwinm R3, R11, 19, 29, 31 */
		/* 8206433Ch case    3:*/		cpu::op::rlwinm<0,19,29,31>(regs,&regs.R3,regs.R11);
		/* 8206433Ch case    3:*/		return 0x82064340;
		  /* 82064340h */ case    4:  		/* bclr 20, CR0_LT */
		/* 82064340h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82064340h case    4:*/		return 0x82064344;
	}
	return 0x82064344;
} // Block from 82064330h-82064344h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82064344h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064344( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064344) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064344);
		  /* 82064344h */ case    0:  		/* nop */
		/* 82064344h case    0:*/		cpu::op::nop();
		/* 82064344h case    0:*/		return 0x82064348;
	}
	return 0x82064348;
} // Block from 82064344h-82064348h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82064348h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064348( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064348) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064348);
		  /* 82064348h */ case    0:  		/* addi R11, R4, 48 */
		/* 82064348h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x30);
		/* 82064348h case    0:*/		return 0x8206434C;
		  /* 8206434Ch */ case    1:  		/* addi R10, R4, 32 */
		/* 8206434Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x20);
		/* 8206434Ch case    1:*/		return 0x82064350;
		  /* 82064350h */ case    2:  		/* mulli R11, R11, 24 */
		/* 82064350h case    2:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x18);
		/* 82064350h case    2:*/		return 0x82064354;
		  /* 82064354h */ case    3:  		/* lwzx R9, <#[R11 + R3]> */
		/* 82064354h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 82064354h case    3:*/		return 0x82064358;
		  /* 82064358h */ case    4:  		/* rlwimi R9, R5, 16, 13, 15 */
		/* 82064358h case    4:*/		cpu::op::rlwimi<0,16,13,15>(regs,&regs.R9,regs.R5);
		/* 82064358h case    4:*/		return 0x8206435C;
		  /* 8206435Ch */ case    5:  		/* li R8, 1 */
		/* 8206435Ch case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 8206435Ch case    5:*/		return 0x82064360;
	}
	return 0x82064360;
} // Block from 82064348h-82064360h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82064360h
// Function 'D3DDevice_GetSamplerState_SeparateZFilterEnable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064360( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064360) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064360);
		  /* 82064360h */ case    0:  		/* stwx R9, <#[R11 + R3]> */
		/* 82064360h case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 82064360h case    0:*/		return 0x82064364;
		  /* 82064364h */ case    1:  		/* rldicl R11, R10, 0, 32 */
		/* 82064364h case    1:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R11,regs.R10);
		/* 82064364h case    1:*/		return 0x82064368;
		  /* 82064368h */ case    2:  		/* rldicr R10, R8, 63, 63 */
		/* 82064368h case    2:*/		cpu::op::rldicr<0,63,63>(regs,&regs.R10,regs.R8);
		/* 82064368h case    2:*/		return 0x8206436C;
		  /* 8206436Ch */ case    3:  		/* srd R11, R10, R11 */
		/* 8206436Ch case    3:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8206436Ch case    3:*/		return 0x82064370;
	}
	return 0x82064370;
} // Block from 82064360h-82064370h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82064370h
// Function 'D3DDevice_SetSamplerState_MaxAnisotropy'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064370( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064370) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064370);
		  /* 82064370h */ case    0:  		/* ld R10, <#[R3 + 24]> */
		/* 82064370h case    0:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R3 + 0x00000018) );
		/* 82064370h case    0:*/		return 0x82064374;
		  /* 82064374h */ case    1:  		/* or R11, R11, R10 */
		/* 82064374h case    1:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82064374h case    1:*/		return 0x82064378;
		  /* 82064378h */ case    2:  		/* std R11, <#[R3 + 24]> */
		/* 82064378h case    2:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82064378h case    2:*/		return 0x8206437C;
		  /* 8206437Ch */ case    3:  		/* bclr 20, CR0_LT */
		/* 8206437Ch case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206437Ch case    3:*/		return 0x82064380;
	}
	return 0x82064380;
} // Block from 82064370h-82064380h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82064380h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064380( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064380) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064380);
		  /* 82064380h */ case    0:  		/* addi R11, R4, 48 */
		/* 82064380h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x30);
		/* 82064380h case    0:*/		return 0x82064384;
		  /* 82064384h */ case    1:  		/* mulli R11, R11, 24 */
		/* 82064384h case    1:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x18);
		/* 82064384h case    1:*/		return 0x82064388;
		  /* 82064388h */ case    2:  		/* lhzx R11, <#[R11 + R3]> */
		/* 82064388h case    2:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 82064388h case    2:*/		return 0x8206438C;
		  /* 8206438Ch */ case    3:  		/* rlwinm R3, R11, 0, 29, 31 */
		/* 8206438Ch case    3:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R3,regs.R11);
		/* 8206438Ch case    3:*/		return 0x82064390;
		  /* 82064390h */ case    4:  		/* bclr 20, CR0_LT */
		/* 82064390h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82064390h case    4:*/		return 0x82064394;
	}
	return 0x82064394;
} // Block from 82064380h-82064394h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82064394h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064394( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064394) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064394);
		  /* 82064394h */ case    0:  		/* nop */
		/* 82064394h case    0:*/		cpu::op::nop();
		/* 82064394h case    0:*/		return 0x82064398;
	}
	return 0x82064398;
} // Block from 82064394h-82064398h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82064398h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064398( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064398) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064398);
		  /* 82064398h */ case    0:  		/* addi R11, R4, 48 */
		/* 82064398h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x30);
		/* 82064398h case    0:*/		return 0x8206439C;
		  /* 8206439Ch */ case    1:  		/* addi R10, R4, 32 */
		/* 8206439Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x20);
		/* 8206439Ch case    1:*/		return 0x820643A0;
		  /* 820643A0h */ case    2:  		/* mulli R11, R11, 24 */
		/* 820643A0h case    2:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x18);
		/* 820643A0h case    2:*/		return 0x820643A4;
		  /* 820643A4h */ case    3:  		/* add R11, R11, R3 */
		/* 820643A4h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 820643A4h case    3:*/		return 0x820643A8;
		  /* 820643A8h */ case    4:  		/* li R9, 1 */
		/* 820643A8h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 820643A8h case    4:*/		return 0x820643AC;
		  /* 820643ACh */ case    5:  		/* rldicl R10, R10, 0, 32 */
		/* 820643ACh case    5:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R10,regs.R10);
		/* 820643ACh case    5:*/		return 0x820643B0;
		  /* 820643B0h */ case    6:  		/* rldicr R9, R9, 63, 63 */
		/* 820643B0h case    6:*/		cpu::op::rldicr<0,63,63>(regs,&regs.R9,regs.R9);
		/* 820643B0h case    6:*/		return 0x820643B4;
		  /* 820643B4h */ case    7:  		/* lwz R8, <#[R11 + 20]> */
		/* 820643B4h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000014) );
		/* 820643B4h case    7:*/		return 0x820643B8;
		  /* 820643B8h */ case    8:  		/* srd R10, R9, R10 */
		/* 820643B8h case    8:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 820643B8h case    8:*/		return 0x820643BC;
		  /* 820643BCh */ case    9:  		/* rlwimi R8, R5, 3, 27, 28 */
		/* 820643BCh case    9:*/		cpu::op::rlwimi<0,3,27,28>(regs,&regs.R8,regs.R5);
		/* 820643BCh case    9:*/		return 0x820643C0;
		  /* 820643C0h */ case   10:  		/* stw R8, <#[R11 + 20]> */
		/* 820643C0h case   10:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000014) );
		/* 820643C0h case   10:*/		return 0x820643C4;
		  /* 820643C4h */ case   11:  		/* ld R11, <#[R3 + 24]> */
		/* 820643C4h case   11:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820643C4h case   11:*/		return 0x820643C8;
		  /* 820643C8h */ case   12:  		/* or R11, R10, R11 */
		/* 820643C8h case   12:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820643C8h case   12:*/		return 0x820643CC;
		  /* 820643CCh */ case   13:  		/* std R11, <#[R3 + 24]> */
		/* 820643CCh case   13:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820643CCh case   13:*/		return 0x820643D0;
		  /* 820643D0h */ case   14:  		/* bclr 20, CR0_LT */
		/* 820643D0h case   14:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820643D0h case   14:*/		return 0x820643D4;
	}
	return 0x820643D4;
} // Block from 82064398h-820643D4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820643D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820643D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820643D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820643D4);
		  /* 820643D4h */ case    0:  		/* nop */
		/* 820643D4h case    0:*/		cpu::op::nop();
		/* 820643D4h case    0:*/		return 0x820643D8;
	}
	return 0x820643D8;
} // Block from 820643D4h-820643D8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820643D8h
// Function 'D3DDevice_GetSamplerState_MaxAnisotropy'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820643D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820643D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820643D8);
		  /* 820643D8h */ case    0:  		/* mulli R11, R4, 24 */
		/* 820643D8h case    0:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R4,0x18);
		/* 820643D8h case    0:*/		return 0x820643DC;
		  /* 820643DCh */ case    1:  		/* add R11, R11, R3 */
		/* 820643DCh case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 820643DCh case    1:*/		return 0x820643E0;
		  /* 820643E0h */ case    2:  		/* lwz R11, <#[R11 + 1172]> */
		/* 820643E0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000494) );
		/* 820643E0h case    2:*/		return 0x820643E4;
		  /* 820643E4h */ case    3:  		/* rlwinm R3, R11, 29, 30, 31 */
		/* 820643E4h case    3:*/		cpu::op::rlwinm<0,29,30,31>(regs,&regs.R3,regs.R11);
		/* 820643E4h case    3:*/		return 0x820643E8;
	}
	return 0x820643E8;
} // Block from 820643D8h-820643E8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820643E8h
// Function 'D3DDevice_SetSamplerState_AnisotropyBias'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820643E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820643E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820643E8);
		  /* 820643E8h */ case    0:  		/* bclr 20, CR0_LT */
		/* 820643E8h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820643E8h case    0:*/		return 0x820643EC;
	}
	return 0x820643EC;
} // Block from 820643E8h-820643ECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820643ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820643EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820643EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820643EC);
		  /* 820643ECh */ case    0:  		/* nop */
		/* 820643ECh case    0:*/		cpu::op::nop();
		/* 820643ECh case    0:*/		return 0x820643F0;
	}
	return 0x820643F0;
} // Block from 820643ECh-820643F0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820643F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820643F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820643F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820643F0);
		  /* 820643F0h */ case    0:  		/* addi R11, R4, 48 */
		/* 820643F0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x30);
		/* 820643F0h case    0:*/		return 0x820643F4;
		  /* 820643F4h */ case    1:  		/* addi R10, R4, 32 */
		/* 820643F4h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x20);
		/* 820643F4h case    1:*/		return 0x820643F8;
		  /* 820643F8h */ case    2:  		/* mulli R11, R11, 24 */
		/* 820643F8h case    2:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x18);
		/* 820643F8h case    2:*/		return 0x820643FC;
		  /* 820643FCh */ case    3:  		/* add R11, R11, R3 */
		/* 820643FCh case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 820643FCh case    3:*/		return 0x82064400;
		  /* 82064400h */ case    4:  		/* li R9, 1 */
		/* 82064400h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82064400h case    4:*/		return 0x82064404;
		  /* 82064404h */ case    5:  		/* rldicl R10, R10, 0, 32 */
		/* 82064404h case    5:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R10,regs.R10);
		/* 82064404h case    5:*/		return 0x82064408;
		  /* 82064408h */ case    6:  		/* rldicr R9, R9, 63, 63 */
		/* 82064408h case    6:*/		cpu::op::rldicr<0,63,63>(regs,&regs.R9,regs.R9);
		/* 82064408h case    6:*/		return 0x8206440C;
		  /* 8206440Ch */ case    7:  		/* lwz R8, <#[R11 + 16]> */
		/* 8206440Ch case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000010) );
		/* 8206440Ch case    7:*/		return 0x82064410;
		  /* 82064410h */ case    8:  		/* srd R10, R9, R10 */
		/* 82064410h case    8:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82064410h case    8:*/		return 0x82064414;
		  /* 82064414h */ case    9:  		/* rlwimi R8, R5, 22, 5, 9 */
		/* 82064414h case    9:*/		cpu::op::rlwimi<0,22,5,9>(regs,&regs.R8,regs.R5);
		/* 82064414h case    9:*/		return 0x82064418;
		  /* 82064418h */ case   10:  		/* stw R8, <#[R11 + 16]> */
		/* 82064418h case   10:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000010) );
		/* 82064418h case   10:*/		return 0x8206441C;
		  /* 8206441Ch */ case   11:  		/* ld R11, <#[R3 + 24]> */
		/* 8206441Ch case   11:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 8206441Ch case   11:*/		return 0x82064420;
		  /* 82064420h */ case   12:  		/* or R11, R10, R11 */
		/* 82064420h case   12:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82064420h case   12:*/		return 0x82064424;
		  /* 82064424h */ case   13:  		/* std R11, <#[R3 + 24]> */
		/* 82064424h case   13:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82064424h case   13:*/		return 0x82064428;
		  /* 82064428h */ case   14:  		/* bclr 20, CR0_LT */
		/* 82064428h case   14:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82064428h case   14:*/		return 0x8206442C;
	}
	return 0x8206442C;
} // Block from 820643F0h-8206442Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8206442Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206442C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206442C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206442C);
		  /* 8206442Ch */ case    0:  		/* nop */
		/* 8206442Ch case    0:*/		cpu::op::nop();
		/* 8206442Ch case    0:*/		return 0x82064430;
	}
	return 0x82064430;
} // Block from 8206442Ch-82064430h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82064430h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064430( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064430) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064430);
		  /* 82064430h */ case    0:  		/* mulli R11, R4, 24 */
		/* 82064430h case    0:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R4,0x18);
		/* 82064430h case    0:*/		return 0x82064434;
		  /* 82064434h */ case    1:  		/* add R11, R11, R3 */
		/* 82064434h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 82064434h case    1:*/		return 0x82064438;
		  /* 82064438h */ case    2:  		/* lwz R11, <#[R11 + 1168]> */
		/* 82064438h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000490) );
		/* 82064438h case    2:*/		return 0x8206443C;
		  /* 8206443Ch */ case    3:  		/* rlwinm R11, R11, 5, 0, 26 */
		/* 8206443Ch case    3:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R11);
		/* 8206443Ch case    3:*/		return 0x82064440;
		  /* 82064440h */ case    4:  		/* srawi R3, R11, 27 */
		/* 82064440h case    4:*/		cpu::op::srawi<0,27>(regs,&regs.R3,regs.R11);
		/* 82064440h case    4:*/		return 0x82064444;
		  /* 82064444h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82064444h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82064444h case    5:*/		return 0x82064448;
	}
	return 0x82064448;
} // Block from 82064430h-82064448h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82064448h
// Function 'D3DDevice_GetSamplerState_AnisotropyBias'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064448( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064448) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064448);
		  /* 82064448h */ case    0:  		/* addi R11, R4, 48 */
		/* 82064448h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x30);
		/* 82064448h case    0:*/		return 0x8206444C;
		  /* 8206444Ch */ case    1:  		/* addi R10, R4, 32 */
		/* 8206444Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x20);
		/* 8206444Ch case    1:*/		return 0x82064450;
		  /* 82064450h */ case    2:  		/* mulli R11, R11, 24 */
		/* 82064450h case    2:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x18);
		/* 82064450h case    2:*/		return 0x82064454;
		  /* 82064454h */ case    3:  		/* add R11, R11, R3 */
		/* 82064454h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 82064454h case    3:*/		return 0x82064458;
		  /* 82064458h */ case    4:  		/* li R9, 1 */
		/* 82064458h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82064458h case    4:*/		return 0x8206445C;
		  /* 8206445Ch */ case    5:  		/* rldicl R10, R10, 0, 32 */
		/* 8206445Ch case    5:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R10,regs.R10);
		/* 8206445Ch case    5:*/		return 0x82064460;
		  /* 82064460h */ case    6:  		/* rldicr R9, R9, 63, 63 */
		/* 82064460h case    6:*/		cpu::op::rldicr<0,63,63>(regs,&regs.R9,regs.R9);
		/* 82064460h case    6:*/		return 0x82064464;
		  /* 82064464h */ case    7:  		/* lwz R8, <#[R11 + 16]> */
		/* 82064464h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000010) );
		/* 82064464h case    7:*/		return 0x82064468;
		  /* 82064468h */ case    8:  		/* srd R10, R9, R10 */
		/* 82064468h case    8:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82064468h case    8:*/		return 0x8206446C;
		  /* 8206446Ch */ case    9:  		/* rlwimi R8, R5, 27, 0, 4 */
		/* 8206446Ch case    9:*/		cpu::op::rlwimi<0,27,0,4>(regs,&regs.R8,regs.R5);
		/* 8206446Ch case    9:*/		return 0x82064470;
		  /* 82064470h */ case   10:  		/* stw R8, <#[R11 + 16]> */
		/* 82064470h case   10:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000010) );
		/* 82064470h case   10:*/		return 0x82064474;
		  /* 82064474h */ case   11:  		/* ld R11, <#[R3 + 24]> */
		/* 82064474h case   11:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82064474h case   11:*/		return 0x82064478;
		  /* 82064478h */ case   12:  		/* or R11, R10, R11 */
		/* 82064478h case   12:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82064478h case   12:*/		return 0x8206447C;
		  /* 8206447Ch */ case   13:  		/* std R11, <#[R3 + 24]> */
		/* 8206447Ch case   13:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 8206447Ch case   13:*/		return 0x82064480;
		  /* 82064480h */ case   14:  		/* bclr 20, CR0_LT */
		/* 82064480h case   14:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82064480h case   14:*/		return 0x82064484;
	}
	return 0x82064484;
} // Block from 82064448h-82064484h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82064484h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064484( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064484) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064484);
		  /* 82064484h */ case    0:  		/* nop */
		/* 82064484h case    0:*/		cpu::op::nop();
		/* 82064484h case    0:*/		return 0x82064488;
	}
	return 0x82064488;
} // Block from 82064484h-82064488h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82064488h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064488( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064488) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064488);
		  /* 82064488h */ case    0:  		/* mulli R11, R4, 24 */
		/* 82064488h case    0:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R4,0x18);
		/* 82064488h case    0:*/		return 0x8206448C;
		  /* 8206448Ch */ case    1:  		/* add R11, R11, R3 */
		/* 8206448Ch case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 8206448Ch case    1:*/		return 0x82064490;
	}
	return 0x82064490;
} // Block from 82064488h-82064490h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82064490h
// Function 'D3DDevice_SetSamplerState_MipMapLodBias'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064490( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064490) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064490);
		  /* 82064490h */ case    0:  		/* lwz R11, <#[R11 + 1168]> */
		/* 82064490h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000490) );
		/* 82064490h case    0:*/		return 0x82064494;
		  /* 82064494h */ case    1:  		/* srawi R3, R11, 27 */
		/* 82064494h case    1:*/		cpu::op::srawi<0,27>(regs,&regs.R3,regs.R11);
		/* 82064494h case    1:*/		return 0x82064498;
		  /* 82064498h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82064498h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82064498h case    2:*/		return 0x8206449C;
	}
	return 0x8206449C;
} // Block from 82064490h-8206449Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206449Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206449C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206449C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206449C);
		  /* 8206449Ch */ case    0:  		/* nop */
		/* 8206449Ch case    0:*/		cpu::op::nop();
		/* 8206449Ch case    0:*/		return 0x820644A0;
	}
	return 0x820644A0;
} // Block from 8206449Ch-820644A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820644A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820644A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820644A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820644A0);
		  /* 820644A0h */ case    0:  		/* addi R11, R4, 48 */
		/* 820644A0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x30);
		/* 820644A0h case    0:*/		return 0x820644A4;
		  /* 820644A4h */ case    1:  		/* addi R10, R4, 32 */
		/* 820644A4h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x20);
		/* 820644A4h case    1:*/		return 0x820644A8;
		  /* 820644A8h */ case    2:  		/* mulli R11, R11, 24 */
		/* 820644A8h case    2:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x18);
		/* 820644A8h case    2:*/		return 0x820644AC;
		  /* 820644ACh */ case    3:  		/* add R11, R11, R3 */
		/* 820644ACh case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 820644ACh case    3:*/		return 0x820644B0;
		  /* 820644B0h */ case    4:  		/* li R9, 1 */
		/* 820644B0h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 820644B0h case    4:*/		return 0x820644B4;
		  /* 820644B4h */ case    5:  		/* rldicl R10, R10, 0, 32 */
		/* 820644B4h case    5:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R10,regs.R10);
		/* 820644B4h case    5:*/		return 0x820644B8;
		  /* 820644B8h */ case    6:  		/* rldicr R9, R9, 63, 63 */
		/* 820644B8h case    6:*/		cpu::op::rldicr<0,63,63>(regs,&regs.R9,regs.R9);
		/* 820644B8h case    6:*/		return 0x820644BC;
		  /* 820644BCh */ case    7:  		/* lwz R8, <#[R11 + 20]> */
		/* 820644BCh case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000014) );
		/* 820644BCh case    7:*/		return 0x820644C0;
		  /* 820644C0h */ case    8:  		/* srd R10, R9, R10 */
		/* 820644C0h case    8:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 820644C0h case    8:*/		return 0x820644C4;
		  /* 820644C4h */ case    9:  		/* rlwimi R8, R5, 2, 29, 29 */
		/* 820644C4h case    9:*/		cpu::op::rlwimi<0,2,29,29>(regs,&regs.R8,regs.R5);
		/* 820644C4h case    9:*/		return 0x820644C8;
		  /* 820644C8h */ case   10:  		/* stw R8, <#[R11 + 20]> */
		/* 820644C8h case   10:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000014) );
		/* 820644C8h case   10:*/		return 0x820644CC;
		  /* 820644CCh */ case   11:  		/* ld R11, <#[R3 + 24]> */
		/* 820644CCh case   11:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820644CCh case   11:*/		return 0x820644D0;
		  /* 820644D0h */ case   12:  		/* or R11, R10, R11 */
		/* 820644D0h case   12:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820644D0h case   12:*/		return 0x820644D4;
		  /* 820644D4h */ case   13:  		/* std R11, <#[R3 + 24]> */
		/* 820644D4h case   13:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820644D4h case   13:*/		return 0x820644D8;
		  /* 820644D8h */ case   14:  		/* bclr 20, CR0_LT */
		/* 820644D8h case   14:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820644D8h case   14:*/		return 0x820644DC;
	}
	return 0x820644DC;
} // Block from 820644A0h-820644DCh (15 instructions)

//////////////////////////////////////////////////////
// Block at 820644DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820644DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820644DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820644DC);
		  /* 820644DCh */ case    0:  		/* nop */
		/* 820644DCh case    0:*/		cpu::op::nop();
		/* 820644DCh case    0:*/		return 0x820644E0;
	}
	return 0x820644E0;
} // Block from 820644DCh-820644E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820644E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820644E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820644E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820644E0);
		  /* 820644E0h */ case    0:  		/* mulli R11, R4, 24 */
		/* 820644E0h case    0:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R4,0x18);
		/* 820644E0h case    0:*/		return 0x820644E4;
		  /* 820644E4h */ case    1:  		/* add R11, R11, R3 */
		/* 820644E4h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 820644E4h case    1:*/		return 0x820644E8;
		  /* 820644E8h */ case    2:  		/* lwz R11, <#[R11 + 1172]> */
		/* 820644E8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000494) );
		/* 820644E8h case    2:*/		return 0x820644EC;
		  /* 820644ECh */ case    3:  		/* rlwinm R3, R11, 30, 31, 31 */
		/* 820644ECh case    3:*/		cpu::op::rlwinm<0,30,31,31>(regs,&regs.R3,regs.R11);
		/* 820644ECh case    3:*/		return 0x820644F0;
	}
	return 0x820644F0;
} // Block from 820644E0h-820644F0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820644F0h
// Function 'D3DDevice_GetSamplerState_MipMapLodBias'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820644F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820644F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820644F0);
		  /* 820644F0h */ case    0:  		/* bclr 20, CR0_LT */
		/* 820644F0h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820644F0h case    0:*/		return 0x820644F4;
	}
	return 0x820644F4;
} // Block from 820644F0h-820644F4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820644F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820644F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820644F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820644F4);
		  /* 820644F4h */ case    0:  		/* nop */
		/* 820644F4h case    0:*/		cpu::op::nop();
		/* 820644F4h case    0:*/		return 0x820644F8;
	}
	return 0x820644F8;
} // Block from 820644F4h-820644F8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820644F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820644F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820644F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820644F8);
		  /* 820644F8h */ case    0:  		/* addi R11, R4, 48 */
		/* 820644F8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x30);
		/* 820644F8h case    0:*/		return 0x820644FC;
		  /* 820644FCh */ case    1:  		/* cntlzw R10, R5 */
		/* 820644FCh case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R5);
		/* 820644FCh case    1:*/		return 0x82064500;
		  /* 82064500h */ case    2:  		/* mulli R11, R11, 24 */
		/* 82064500h case    2:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x18);
		/* 82064500h case    2:*/		return 0x82064504;
		  /* 82064504h */ case    3:  		/* add R11, R11, R3 */
		/* 82064504h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 82064504h case    3:*/		return 0x82064508;
		  /* 82064508h */ case    4:  		/* rlwinm R10, R10, 27, 31, 31 */
		/* 82064508h case    4:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R10,regs.R10);
		/* 82064508h case    4:*/		return 0x8206450C;
		  /* 8206450Ch */ case    5:  		/* addi R9, R4, 32 */
		/* 8206450Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R4,0x20);
		/* 8206450Ch case    5:*/		return 0x82064510;
		  /* 82064510h */ case    6:  		/* li R8, 1 */
		/* 82064510h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82064510h case    6:*/		return 0x82064514;
		  /* 82064514h */ case    7:  		/* rldicl R9, R9, 0, 32 */
		/* 82064514h case    7:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R9,regs.R9);
		/* 82064514h case    7:*/		return 0x82064518;
		  /* 82064518h */ case    8:  		/* lwz R7, <#[R11 + 4]> */
		/* 82064518h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 82064518h case    8:*/		return 0x8206451C;
		  /* 8206451Ch */ case    9:  		/* rldicr R8, R8, 63, 63 */
		/* 8206451Ch case    9:*/		cpu::op::rldicr<0,63,63>(regs,&regs.R8,regs.R8);
		/* 8206451Ch case    9:*/		return 0x82064520;
		  /* 82064520h */ case   10:  		/* rlwimi R7, R10, 11, 20, 20 */
		/* 82064520h case   10:*/		cpu::op::rlwimi<0,11,20,20>(regs,&regs.R7,regs.R10);
		/* 82064520h case   10:*/		return 0x82064524;
		  /* 82064524h */ case   11:  		/* stw R7, <#[R11 + 4]> */
		/* 82064524h case   11:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 82064524h case   11:*/		return 0x82064528;
		  /* 82064528h */ case   12:  		/* srd R11, R8, R9 */
		/* 82064528h case   12:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R8,regs.R9);
		/* 82064528h case   12:*/		return 0x8206452C;
		  /* 8206452Ch */ case   13:  		/* ld R10, <#[R3 + 24]> */
		/* 8206452Ch case   13:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R3 + 0x00000018) );
		/* 8206452Ch case   13:*/		return 0x82064530;
		  /* 82064530h */ case   14:  		/* or R11, R11, R10 */
		/* 82064530h case   14:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82064530h case   14:*/		return 0x82064534;
		  /* 82064534h */ case   15:  		/* std R11, <#[R3 + 24]> */
		/* 82064534h case   15:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82064534h case   15:*/		return 0x82064538;
	}
	return 0x82064538;
} // Block from 820644F8h-82064538h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82064538h
// Function 'D3DDevice_SetSamplerState_MaxMipLevel'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064538( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064538) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064538);
		  /* 82064538h */ case    0:  		/* bclr 20, CR0_LT */
		/* 82064538h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82064538h case    0:*/		return 0x8206453C;
	}
	return 0x8206453C;
} // Block from 82064538h-8206453Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206453Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206453C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206453C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206453C);
		  /* 8206453Ch */ case    0:  		/* nop */
		/* 8206453Ch case    0:*/		cpu::op::nop();
		/* 8206453Ch case    0:*/		return 0x82064540;
	}
	return 0x82064540;
} // Block from 8206453Ch-82064540h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82064540h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064540( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064540) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064540);
		  /* 82064540h */ case    0:  		/* mulli R11, R4, 24 */
		/* 82064540h case    0:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R4,0x18);
		/* 82064540h case    0:*/		return 0x82064544;
		  /* 82064544h */ case    1:  		/* add R11, R11, R3 */
		/* 82064544h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 82064544h case    1:*/		return 0x82064548;
		  /* 82064548h */ case    2:  		/* lwz R11, <#[R11 + 1156]> */
		/* 82064548h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000484) );
		/* 82064548h case    2:*/		return 0x8206454C;
		  /* 8206454Ch */ case    3:  		/* nor R11, R11, R11 */
		/* 8206454Ch case    3:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8206454Ch case    3:*/		return 0x82064550;
		  /* 82064550h */ case    4:  		/* rlwinm R3, R11, 21, 31, 31 */
		/* 82064550h case    4:*/		cpu::op::rlwinm<0,21,31,31>(regs,&regs.R3,regs.R11);
		/* 82064550h case    4:*/		return 0x82064554;
		  /* 82064554h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82064554h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82064554h case    5:*/		return 0x82064558;
	}
	return 0x82064558;
} // Block from 82064540h-82064558h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82064558h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064558( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064558) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064558);
		  /* 82064558h */ case    0:  		/* mfspr R12, LR */
		/* 82064558h case    0:*/		regs.R12 = regs.LR;
		/* 82064558h case    0:*/		return 0x8206455C;
		  /* 8206455Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8206455Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206455Ch case    1:*/		return 0x82064560;
		  /* 82064560h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82064560h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82064560h case    2:*/		return 0x82064564;
		  /* 82064564h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82064564h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82064564h case    3:*/		return 0x82064568;
		  /* 82064568h */ case    4:  		/* stwu R1, <#[R1 - 128]> */
		/* 82064568h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82064568h case    4:*/		return 0x8206456C;
		  /* 8206456Ch */ case    5:  		/* lfs FR0, <#[R3 + 13024]> */
		/* 8206456Ch case    5:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R3 + 0x000032E0) );
		/* 8206456Ch case    5:*/		return 0x82064570;
		  /* 82064570h */ case    6:  		/* mr R9, R4 */
		/* 82064570h case    6:*/		regs.R9 = regs.R4;
		/* 82064570h case    6:*/		return 0x82064574;
		  /* 82064574h */ case    7:  		/* lfs FR13, <#[R3 + 13032]> */
		/* 82064574h case    7:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R3 + 0x000032E8) );
		/* 82064574h case    7:*/		return 0x82064578;
		  /* 82064578h */ case    8:  		/* fctiwz FR0, FR0 */
		/* 82064578h case    8:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR0);
		/* 82064578h case    8:*/		return 0x8206457C;
		  /* 8206457Ch */ case    9:  		/* fctiwz FR13, FR13 */
		/* 8206457Ch case    9:*/		cpu::op::fctiwz<0>(regs,&regs.FR13,regs.FR13);
		/* 8206457Ch case    9:*/		return 0x82064580;
		  /* 82064580h */ case   10:  		/* stfd FR0, <#[R1 + 80]> */
		/* 82064580h case   10:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 82064580h case   10:*/		return 0x82064584;
		  /* 82064584h */ case   11:  		/* stfd FR13, <#[R1 + 88]> */
		/* 82064584h case   11:*/		cpu::mem::store64f( regs, regs.FR13, (uint32)(regs.R1 + 0x00000058) );
		/* 82064584h case   11:*/		return 0x82064588;
		  /* 82064588h */ case   12:  		/* lwz R11, <#[R4]> */
		/* 82064588h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 82064588h case   12:*/		return 0x8206458C;
		  /* 8206458Ch */ case   13:  		/* lfs FR0, <#[R3 + 13036]> */
		/* 8206458Ch case   13:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R3 + 0x000032EC) );
		/* 8206458Ch case   13:*/		return 0x82064590;
		  /* 82064590h */ case   14:  		/* lwz R4, <#[R1 + 84]> */
		/* 82064590h case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000054) );
		/* 82064590h case   14:*/		return 0x82064594;
		  /* 82064594h */ case   15:  		/* lfs FR13, <#[R3 + 13028]> */
		/* 82064594h case   15:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R3 + 0x000032E4) );
		/* 82064594h case   15:*/		return 0x82064598;
		  /* 82064598h */ case   16:  		/* lwz R8, <#[R1 + 92]> */
		/* 82064598h case   16:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x0000005C) );
		/* 82064598h case   16:*/		return 0x8206459C;
		  /* 8206459Ch */ case   17:  		/* fctiwz FR0, FR0 */
		/* 8206459Ch case   17:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR0);
		/* 8206459Ch case   17:*/		return 0x820645A0;
		  /* 820645A0h */ case   18:  		/* lwz R10, <#[R9 + 4]> */
		/* 820645A0h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000004) );
		/* 820645A0h case   18:*/		return 0x820645A4;
		  /* 820645A4h */ case   19:  		/* fctiwz FR13, FR13 */
		/* 820645A4h case   19:*/		cpu::op::fctiwz<0>(regs,&regs.FR13,regs.FR13);
		/* 820645A4h case   19:*/		return 0x820645A8;
	}
	return 0x820645A8;
} // Block from 82064558h-820645A8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 820645A8h
// Function 'D3DDevice_GetSamplerState_MaxMipLevel'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820645A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820645A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820645A8);
		  /* 820645A8h */ case    0:  		/* lwz R31, <#[R9 + 8]> */
		/* 820645A8h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R9 + 0x00000008) );
		/* 820645A8h case    0:*/		return 0x820645AC;
		  /* 820645ACh */ case    1:  		/* lwz R30, <#[R9 + 12]> */
		/* 820645ACh case    1:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R9 + 0x0000000C) );
		/* 820645ACh case    1:*/		return 0x820645B0;
		  /* 820645B0h */ case    2:  		/* stfd FR0, <#[R1 + 88]> */
		/* 820645B0h case    2:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 820645B0h case    2:*/		return 0x820645B4;
		  /* 820645B4h */ case    3:  		/* stfd FR13, <#[R1 + 80]> */
		/* 820645B4h case    3:*/		cpu::mem::store64f( regs, regs.FR13, (uint32)(regs.R1 + 0x00000050) );
		/* 820645B4h case    3:*/		return 0x820645B8;
	}
	return 0x820645B8;
} // Block from 820645A8h-820645B8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820645B8h
// Function 'D3DDevice_SetSamplerState_MinMipLevel'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820645B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820645B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820645B8);
		  /* 820645B8h */ case    0:  		/* lwz R9, <#[R1 + 92]> */
		/* 820645B8h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x0000005C) );
		/* 820645B8h case    0:*/		return 0x820645BC;
		  /* 820645BCh */ case    1:  		/* lwz R5, <#[R1 + 84]> */
		/* 820645BCh case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000054) );
		/* 820645BCh case    1:*/		return 0x820645C0;
		  /* 820645C0h */ case    2:  		/* lwz R6, <#[R3 + 12288]> */
		/* 820645C0h case    2:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R3 + 0x00003000) );
		/* 820645C0h case    2:*/		return 0x820645C4;
		  /* 820645C4h */ case    3:  		/* stw R11, <#[R3 + 13052]> */
		/* 820645C4h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x000032FC) );
		/* 820645C4h case    3:*/		return 0x820645C8;
		  /* 820645C8h */ case    4:  		/* cmpwi CR6, R6, 0 */
		/* 820645C8h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x00000000);
		/* 820645C8h case    4:*/		return 0x820645CC;
		  /* 820645CCh */ case    5:  		/* stw R10, <#[R3 + 13056]> */
		/* 820645CCh case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00003300) );
		/* 820645CCh case    5:*/		return 0x820645D0;
		  /* 820645D0h */ case    6:  		/* add R6, R8, R4 */
		/* 820645D0h case    6:*/		cpu::op::add<0>(regs,&regs.R6,regs.R8,regs.R4);
		/* 820645D0h case    6:*/		return 0x820645D4;
		  /* 820645D4h */ case    7:  		/* stw R31, <#[R3 + 13060]> */
		/* 820645D4h case    7:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00003304) );
		/* 820645D4h case    7:*/		return 0x820645D8;
		  /* 820645D8h */ case    8:  		/* stw R30, <#[R3 + 13064]> */
		/* 820645D8h case    8:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00003308) );
		/* 820645D8h case    8:*/		return 0x820645DC;
		  /* 820645DCh */ case    9:  		/* add R7, R9, R5 */
		/* 820645DCh case    9:*/		cpu::op::add<0>(regs,&regs.R7,regs.R9,regs.R5);
		/* 820645DCh case    9:*/		return 0x820645E0;
		  /* 820645E0h */ case   10:  		/* bc 12, CR6_EQ, 52 */
		/* 820645E0h case   10:*/		if ( regs.CR[6].eq ) { return 0x82064614;  }
		/* 820645E0h case   10:*/		return 0x820645E4;
		  /* 820645E4h */ case   11:  		/* cmpw CR6, R4, R11 */
		/* 820645E4h case   11:*/		cpu::op::cmpw<6>(regs,regs.R4,regs.R11);
		/* 820645E4h case   11:*/		return 0x820645E8;
		  /* 820645E8h */ case   12:  		/* bc 12, CR6_GT, 8 */
		/* 820645E8h case   12:*/		if ( regs.CR[6].gt ) { return 0x820645F0;  }
		/* 820645E8h case   12:*/		return 0x820645EC;
		  /* 820645ECh */ case   13:  		/* mr R4, R11 */
		/* 820645ECh case   13:*/		regs.R4 = regs.R11;
		/* 820645ECh case   13:*/		return 0x820645F0;
	}
	return 0x820645F0;
} // Block from 820645B8h-820645F0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820645F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820645F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820645F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820645F0);
		  /* 820645F0h */ case    0:  		/* cmpw CR6, R5, R10 */
		/* 820645F0h case    0:*/		cpu::op::cmpw<6>(regs,regs.R5,regs.R10);
		/* 820645F0h case    0:*/		return 0x820645F4;
		  /* 820645F4h */ case    1:  		/* bc 12, CR6_GT, 8 */
		/* 820645F4h case    1:*/		if ( regs.CR[6].gt ) { return 0x820645FC;  }
		/* 820645F4h case    1:*/		return 0x820645F8;
		  /* 820645F8h */ case    2:  		/* mr R5, R10 */
		/* 820645F8h case    2:*/		regs.R5 = regs.R10;
		/* 820645F8h case    2:*/		return 0x820645FC;
	}
	return 0x820645FC;
} // Block from 820645F0h-820645FCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 820645FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820645FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820645FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820645FC);
		  /* 820645FCh */ case    0:  		/* cmpw CR6, R6, R31 */
		/* 820645FCh case    0:*/		cpu::op::cmpw<6>(regs,regs.R6,regs.R31);
		/* 820645FCh case    0:*/		return 0x82064600;
		  /* 82064600h */ case    1:  		/* bc 12, CR6_LT, 8 */
		/* 82064600h case    1:*/		if ( regs.CR[6].lt ) { return 0x82064608;  }
		/* 82064600h case    1:*/		return 0x82064604;
		  /* 82064604h */ case    2:  		/* mr R6, R31 */
		/* 82064604h case    2:*/		regs.R6 = regs.R31;
		/* 82064604h case    2:*/		return 0x82064608;
	}
	return 0x82064608;
} // Block from 820645FCh-82064608h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82064608h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064608( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064608) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064608);
		  /* 82064608h */ case    0:  		/* cmpw CR6, R7, R30 */
		/* 82064608h case    0:*/		cpu::op::cmpw<6>(regs,regs.R7,regs.R30);
		/* 82064608h case    0:*/		return 0x8206460C;
		  /* 8206460Ch */ case    1:  		/* bc 12, CR6_LT, 8 */
		/* 8206460Ch case    1:*/		if ( regs.CR[6].lt ) { return 0x82064614;  }
		/* 8206460Ch case    1:*/		return 0x82064610;
		  /* 82064610h */ case    2:  		/* mr R7, R30 */
		/* 82064610h case    2:*/		regs.R7 = regs.R30;
		/* 82064610h case    2:*/		return 0x82064614;
	}
	return 0x82064614;
} // Block from 82064608h-82064614h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82064614h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064614( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064614) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064614);
		  /* 82064614h */ case    0:  		/* lwz R11, <#[R3 + 10436]> */
		/* 82064614h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000028C4) );
		/* 82064614h case    0:*/		return 0x82064618;
		  /* 82064618h */ case    1:  		/* lwz R10, <#[R3 + 10440]> */
		/* 82064618h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x000028C8) );
		/* 82064618h case    1:*/		return 0x8206461C;
		  /* 8206461Ch */ case    2:  		/* rlwimi R11, R5, 16, 1, 15 */
		/* 8206461Ch case    2:*/		cpu::op::rlwimi<0,16,1,15>(regs,&regs.R11,regs.R5);
		/* 8206461Ch case    2:*/		return 0x82064620;
		  /* 82064620h */ case    3:  		/* rlwimi R10, R7, 16, 1, 15 */
		/* 82064620h case    3:*/		cpu::op::rlwimi<0,16,1,15>(regs,&regs.R10,regs.R7);
		/* 82064620h case    3:*/		return 0x82064624;
		  /* 82064624h */ case    4:  		/* rlwimi R11, R4, 0, 17, 31 */
		/* 82064624h case    4:*/		cpu::op::rlwimi<0,0,17,31>(regs,&regs.R11,regs.R4);
		/* 82064624h case    4:*/		return 0x82064628;
	}
	return 0x82064628;
} // Block from 82064614h-82064628h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82064628h
// Function 'D3DDevice_GetSamplerState_MinMipLevel'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064628( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064628) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064628);
		  /* 82064628h */ case    0:  		/* rlwimi R10, R6, 0, 17, 31 */
		/* 82064628h case    0:*/		cpu::op::rlwimi<0,0,17,31>(regs,&regs.R10,regs.R6);
		/* 82064628h case    0:*/		return 0x8206462C;
		  /* 8206462Ch */ case    1:  		/* stw R11, <#[R3 + 10436]> */
		/* 8206462Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x000028C4) );
		/* 8206462Ch case    1:*/		return 0x82064630;
		  /* 82064630h */ case    2:  		/* stw R10, <#[R3 + 10440]> */
		/* 82064630h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x000028C8) );
		/* 82064630h case    2:*/		return 0x82064634;
		  /* 82064634h */ case    3:  		/* bl -9868 */
		/* 82064634h case    3:*/		regs.LR = 0x82064638; return 0x82061FA8;
		/* 82064634h case    3:*/		return 0x82064638;
	}
	return 0x82064638;
} // Block from 82064628h-82064638h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82064638h
// Function 'D3DDevice_SetSamplerState_BorderColor'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064638( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064638) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064638);
		  /* 82064638h */ case    0:  		/* addi R1, R1, 128 */
		/* 82064638h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82064638h case    0:*/		return 0x8206463C;
		  /* 8206463Ch */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8206463Ch case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206463Ch case    1:*/		return 0x82064640;
		  /* 82064640h */ case    2:  		/* mtspr LR, R12 */
		/* 82064640h case    2:*/		regs.LR = regs.R12;
		/* 82064640h case    2:*/		return 0x82064644;
		  /* 82064644h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 82064644h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82064644h case    3:*/		return 0x82064648;
		  /* 82064648h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 82064648h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82064648h case    4:*/		return 0x8206464C;
		  /* 8206464Ch */ case    5:  		/* bclr 20, CR0_LT */
		/* 8206464Ch case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206464Ch case    5:*/		return 0x82064650;
	}
	return 0x82064650;
} // Block from 82064638h-82064650h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82064650h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064650( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064650) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064650);
		  /* 82064650h */ case    0:  		/* mfspr R12, LR */
		/* 82064650h case    0:*/		regs.R12 = regs.LR;
		/* 82064650h case    0:*/		return 0x82064654;
		  /* 82064654h */ case    1:  		/* bl 183292 */
		/* 82064654h case    1:*/		regs.LR = 0x82064658; return 0x82091250;
		/* 82064654h case    1:*/		return 0x82064658;
		  /* 82064658h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82064658h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82064658h case    2:*/		return 0x8206465C;
		  /* 8206465Ch */ case    3:  		/* mr R31, R3 */
		/* 8206465Ch case    3:*/		regs.R31 = regs.R3;
		/* 8206465Ch case    3:*/		return 0x82064660;
		  /* 82064660h */ case    4:  		/* mr R29, R4 */
		/* 82064660h case    4:*/		regs.R29 = regs.R4;
		/* 82064660h case    4:*/		return 0x82064664;
		  /* 82064664h */ case    5:  		/* mr R30, R5 */
		/* 82064664h case    5:*/		regs.R30 = regs.R5;
		/* 82064664h case    5:*/		return 0x82064668;
		  /* 82064668h */ case    6:  		/* mr R26, R7 */
		/* 82064668h case    6:*/		regs.R26 = regs.R7;
		/* 82064668h case    6:*/		return 0x8206466C;
		  /* 8206466Ch */ case    7:  		/* cmplwi CR6, R5, 0 */
		/* 8206466Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 8206466Ch case    7:*/		return 0x82064670;
		  /* 82064670h */ case    8:  		/* bc 12, CR6_EQ, 80 */
		/* 82064670h case    8:*/		if ( regs.CR[6].eq ) { return 0x820646C0;  }
		/* 82064670h case    8:*/		return 0x82064674;
		  /* 82064674h */ case    9:  		/* lwz R10, <#[R5 + 24]> */
		/* 82064674h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000018) );
		/* 82064674h case    9:*/		return 0x82064678;
		  /* 82064678h */ case   10:  		/* subfic R11, R4, 17 */
		/* 82064678h case   10:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R4,0x11);
		/* 82064678h case   10:*/		return 0x8206467C;
		  /* 8206467Ch */ case   11:  		/* lwz R5, <#[R5 + 28]> */
		/* 8206467Ch case   11:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + 0x0000001C) );
		/* 8206467Ch case   11:*/		return 0x82064680;
	}
	return 0x82064680;
} // Block from 82064650h-82064680h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82064680h
// Function 'D3DDevice_GetSamplerState_BorderColor'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064680( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064680) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064680);
		  /* 82064680h */ case    0:  		/* add R10, R10, R6 */
		/* 82064680h case    0:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R6);
		/* 82064680h case    0:*/		return 0x82064684;
		  /* 82064684h */ case    1:  		/* addi R4, R11, 222 */
		/* 82064684h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xDE);
		/* 82064684h case    1:*/		return 0x82064688;
		  /* 82064688h */ case    2:  		/* rlwinm R7, R10, 12, 20, 31 */
		/* 82064688h case    2:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R7,regs.R10);
		/* 82064688h case    2:*/		return 0x8206468C;
		  /* 8206468Ch */ case    3:  		/* rlwinm R9, R11, 3, 0, 28 */
		/* 8206468Ch case    3:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R9,regs.R11);
		/* 8206468Ch case    3:*/		return 0x82064690;
		  /* 82064690h */ case    4:  		/* addi R11, R7, 512 */
		/* 82064690h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R7,0x200);
		/* 82064690h case    4:*/		return 0x82064694;
		  /* 82064694h */ case    5:  		/* rlwinm R10, R10, 0, 3, 31 */
		/* 82064694h case    5:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R10,regs.R10);
		/* 82064694h case    5:*/		return 0x82064698;
		  /* 82064698h */ case    6:  		/* rlwinm R11, R11, 0, 19, 19 */
		/* 82064698h case    6:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R11,regs.R11);
		/* 82064698h case    6:*/		return 0x8206469C;
		  /* 8206469Ch */ case    7:  		/* rlwinm R7, R4, 3, 0, 28 */
		/* 8206469Ch case    7:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R7,regs.R4);
		/* 8206469Ch case    7:*/		return 0x820646A0;
		  /* 820646A0h */ case    8:  		/* add R9, R9, R3 */
		/* 820646A0h case    8:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R3);
		/* 820646A0h case    8:*/		return 0x820646A4;
		  /* 820646A4h */ case    9:  		/* add R11, R11, R10 */
		/* 820646A4h case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820646A4h case    9:*/		return 0x820646A8;
	}
	return 0x820646A8;
} // Block from 82064680h-820646A8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820646A8h
// Function 'D3DDevice_SetSamplerState_AddressU'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820646A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820646A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820646A8);
		  /* 820646A8h */ case    0:  		/* subf R6, R6, R5 */
		/* 820646A8h case    0:*/		cpu::op::subf<0>(regs,&regs.R6,regs.R6,regs.R5);
		/* 820646A8h case    0:*/		return 0x820646AC;
		  /* 820646ACh */ case    1:  		/* stwx R11, <#[R7 + R3]> */
		/* 820646ACh case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R7 + regs.R3 + 0x00000000) );
		/* 820646ACh case    1:*/		return 0x820646B0;
		  /* 820646B0h */ case    2:  		/* stw R6, <#[R9 + 1780]> */
		/* 820646B0h case    2:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R9 + 0x000006F4) );
		/* 820646B0h case    2:*/		return 0x820646B4;
		  /* 820646B4h */ case    3:  		/* ld R11, <#[R3 + 24]> */
		/* 820646B4h case    3:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820646B4h case    3:*/		return 0x820646B8;
		  /* 820646B8h */ case    4:  		/* or R11, R11, R8 */
		/* 820646B8h case    4:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 820646B8h case    4:*/		return 0x820646BC;
		  /* 820646BCh */ case    5:  		/* std R11, <#[R3 + 24]> */
		/* 820646BCh case    5:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 820646BCh case    5:*/		return 0x820646C0;
	}
	return 0x820646C0;
} // Block from 820646A8h-820646C0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820646C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820646C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820646C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820646C0);
		  /* 820646C0h */ case    0:  		/* addi R11, R29, 3209 */
		/* 820646C0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0xC89);
		/* 820646C0h case    0:*/		return 0x820646C4;
		  /* 820646C4h */ case    1:  		/* rlwinm R27, R11, 2, 0, 29 */
		/* 820646C4h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R27,regs.R11);
		/* 820646C4h case    1:*/		return 0x820646C8;
		  /* 820646C8h */ case    2:  		/* lwzx R28, <#[R27 + R31]> */
		/* 820646C8h case    2:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R27 + regs.R31 + 0x00000000) );
		/* 820646C8h case    2:*/		return 0x820646CC;
		  /* 820646CCh */ case    3:  		/* cmplwi CR6, R28, 0 */
		/* 820646CCh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 820646CCh case    3:*/		return 0x820646D0;
		  /* 820646D0h */ case    4:  		/* bc 12, CR6_EQ, 104 */
		/* 820646D0h case    4:*/		if ( regs.CR[6].eq ) { return 0x82064738;  }
		/* 820646D0h case    4:*/		return 0x820646D4;
		  /* 820646D4h */ case    5:  		/* lwz R11, <#[R31 + 11036]> */
		/* 820646D4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B1C) );
		/* 820646D4h case    5:*/		return 0x820646D8;
		  /* 820646D8h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 820646D8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820646D8h case    6:*/		return 0x820646DC;
		  /* 820646DCh */ case    7:  		/* bc 12, CR6_EQ, 12 */
		/* 820646DCh case    7:*/		if ( regs.CR[6].eq ) { return 0x820646E8;  }
		/* 820646DCh case    7:*/		return 0x820646E0;
	}
	return 0x820646E0;
} // Block from 820646C0h-820646E0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820646E0h
// Function 'D3DDevice_GetSamplerState_AddressU'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820646E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820646E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820646E0);
		  /* 820646E0h */ case    0:  		/* stw R11, <#[R28 + 8]> */
		/* 820646E0h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 820646E0h case    0:*/		return 0x820646E4;
		  /* 820646E4h */ case    1:  		/* b 84 */
		/* 820646E4h case    1:*/		return 0x82064738;
		/* 820646E4h case    1:*/		return 0x820646E8;
	}
	return 0x820646E8;
} // Block from 820646E0h-820646E8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820646E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820646E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820646E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820646E8);
		  /* 820646E8h */ case    0:  		/* lwz R11, <#[R31 + 11040]> */
		/* 820646E8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B20) );
		/* 820646E8h case    0:*/		return 0x820646EC;
		  /* 820646ECh */ case    1:  		/* lwz R10, <#[R28]> */
		/* 820646ECh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000000) );
		/* 820646ECh case    1:*/		return 0x820646F0;
		  /* 820646F0h */ case    2:  		/* and. R11, R11, R10 */
		/* 820646F0h case    2:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820646F0h case    2:*/		return 0x820646F4;
		  /* 820646F4h */ case    3:  		/* bc 12, CR0_EQ, 68 */
		/* 820646F4h case    3:*/		if ( regs.CR[0].eq ) { return 0x82064738;  }
		/* 820646F4h case    3:*/		return 0x820646F8;
	}
	return 0x820646F8;
} // Block from 820646E8h-820646F8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820646F8h
// Function 'D3DDevice_SetSamplerState_AddressV'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820646F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820646F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820646F8);
		  /* 820646F8h */ case    0:  		/* lwz R11, <#[R31 + 13932]> */
		/* 820646F8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000366C) );
		/* 820646F8h case    0:*/		return 0x820646FC;
		  /* 820646FCh */ case    1:  		/* lwz R3, <#[R31 + 13928]> */
		/* 820646FCh case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00003668) );
		/* 820646FCh case    1:*/		return 0x82064700;
		  /* 82064700h */ case    2:  		/* cmplw CR6, R3, R11 */
		/* 82064700h case    2:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 82064700h case    2:*/		return 0x82064704;
		  /* 82064704h */ case    3:  		/* bc 12, CR6_LT, 12 */
		/* 82064704h case    3:*/		if ( regs.CR[6].lt ) { return 0x82064710;  }
		/* 82064704h case    3:*/		return 0x82064708;
		  /* 82064708h */ case    4:  		/* mr R3, R31 */
		/* 82064708h case    4:*/		regs.R3 = regs.R31;
		/* 82064708h case    4:*/		return 0x8206470C;
		  /* 8206470Ch */ case    5:  		/* bl 66148 */
		/* 8206470Ch case    5:*/		regs.LR = 0x82064710; return 0x82074970;
		/* 8206470Ch case    5:*/		return 0x82064710;
	}
	return 0x82064710;
} // Block from 820646F8h-82064710h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82064710h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064710( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064710) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064710);
		  /* 82064710h */ case    0:  		/* lwz R11, <#[R1 + 80]> */
		/* 82064710h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82064710h case    0:*/		return 0x82064714;
		  /* 82064714h */ case    1:  		/* li R10, -1 */
		/* 82064714h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 82064714h case    1:*/		return 0x82064718;
		  /* 82064718h */ case    2:  		/* addi R9, R3, 8 */
		/* 82064718h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R3,0x8);
		/* 82064718h case    2:*/		return 0x8206471C;
		  /* 8206471Ch */ case    3:  		/* rlwimi R11, R28, 30, 2, 31 */
		/* 8206471Ch case    3:*/		cpu::op::rlwimi<0,30,2,31>(regs,&regs.R11,regs.R28);
		/* 8206471Ch case    3:*/		return 0x82064720;
		  /* 82064720h */ case    4:  		/* stw R10, <#[R1 + 84]> */
		/* 82064720h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 82064720h case    4:*/		return 0x82064724;
		  /* 82064724h */ case    5:  		/* rlwinm R11, R11, 0, 2, 0 */
		/* 82064724h case    5:*/		cpu::op::rlwinm<0,0,2,0>(regs,&regs.R11,regs.R11);
		/* 82064724h case    5:*/		return 0x82064728;
		  /* 82064728h */ case    6:  		/* stw R11, <#[R1 + 80]> */
		/* 82064728h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82064728h case    6:*/		return 0x8206472C;
		  /* 8206472Ch */ case    7:  		/* ld R11, <#[R1 + 80]> */
		/* 8206472Ch case    7:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8206472Ch case    7:*/		return 0x82064730;
	}
	return 0x82064730;
} // Block from 82064710h-82064730h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82064730h
// Function 'D3DDevice_GetSamplerState_AddressV'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064730( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064730) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064730);
		  /* 82064730h */ case    0:  		/* std R11, <#[R3]> */
		/* 82064730h case    0:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82064730h case    0:*/		return 0x82064734;
		  /* 82064734h */ case    1:  		/* stw R9, <#[R31 + 13928]> */
		/* 82064734h case    1:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00003668) );
		/* 82064734h case    1:*/		return 0x82064738;
	}
	return 0x82064738;
} // Block from 82064730h-82064738h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82064738h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064738( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064738) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064738);
		  /* 82064738h */ case    0:  		/* add R11, R31, R29 */
		/* 82064738h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R31,regs.R29);
		/* 82064738h case    0:*/		return 0x8206473C;
		  /* 8206473Ch */ case    1:  		/* stwx R30, <#[R27 + R31]> */
		/* 8206473Ch case    1:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R27 + regs.R31 + 0x00000000) );
		/* 8206473Ch case    1:*/		return 0x82064740;
		  /* 82064740h */ case    2:  		/* rlwinm R9, R26, 30, 24, 31 */
		/* 82064740h case    2:*/		cpu::op::rlwinm<0,30,24,31>(regs,&regs.R9,regs.R26);
		/* 82064740h case    2:*/		return 0x82064744;
		  /* 82064744h */ case    3:  		/* rlwinm. R10, R26, 30, 2, 31 */
		/* 82064744h case    3:*/		cpu::op::rlwinm<1,30,2,31>(regs,&regs.R10,regs.R26);
		/* 82064744h case    3:*/		return 0x82064748;
	}
	return 0x82064748;
} // Block from 82064738h-82064748h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82064748h
// Function 'D3DDevice_SetSamplerState_AddressW'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064748( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064748) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064748);
		  /* 82064748h */ case    0:  		/* stb R9, <#[R11 + 12904]> */
		/* 82064748h case    0:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R11 + 0x00003268) );
		/* 82064748h case    0:*/		return 0x8206474C;
		  /* 8206474Ch */ case    1:  		/* bc 12, CR0_EQ, 28 */
		/* 8206474Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82064768;  }
		/* 8206474Ch case    1:*/		return 0x82064750;
		  /* 82064750h */ case    2:  		/* lbz R11, <#[R11 + 12264]> */
		/* 82064750h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00002FE8) );
		/* 82064750h case    2:*/		return 0x82064754;
		  /* 82064754h */ case    3:  		/* cmplw CR6, R10, R11 */
		/* 82064754h case    3:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82064754h case    3:*/		return 0x82064758;
		  /* 82064758h */ case    4:  		/* bc 12, CR6_EQ, 16 */
		/* 82064758h case    4:*/		if ( regs.CR[6].eq ) { return 0x82064768;  }
		/* 82064758h case    4:*/		return 0x8206475C;
		  /* 8206475Ch */ case    5:  		/* ld R11, <#[R31 + 16]> */
		/* 8206475Ch case    5:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8206475Ch case    5:*/		return 0x82064760;
		  /* 82064760h */ case    6:  		/* oris R11, R11, 8 */
		/* 82064760h case    6:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8);
		/* 82064760h case    6:*/		return 0x82064764;
		  /* 82064764h */ case    7:  		/* std R11, <#[R31 + 16]> */
		/* 82064764h case    7:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82064764h case    7:*/		return 0x82064768;
	}
	return 0x82064768;
} // Block from 82064748h-82064768h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82064768h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064768( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064768) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064768);
		  /* 82064768h */ case    0:  		/* addi R1, R1, 144 */
		/* 82064768h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82064768h case    0:*/		return 0x8206476C;
		  /* 8206476Ch */ case    1:  		/* b 183092 */
		/* 8206476Ch case    1:*/		return 0x820912A0;
		/* 8206476Ch case    1:*/		return 0x82064770;
	}
	return 0x82064770;
} // Block from 82064768h-82064770h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82064770h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064770( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064770) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064770);
		  /* 82064770h */ case    0:  		/* mfspr R12, LR */
		/* 82064770h case    0:*/		regs.R12 = regs.LR;
		/* 82064770h case    0:*/		return 0x82064774;
		  /* 82064774h */ case    1:  		/* bl 183016 */
		/* 82064774h case    1:*/		regs.LR = 0x82064778; return 0x8209125C;
		/* 82064774h case    1:*/		return 0x82064778;
		  /* 82064778h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82064778h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82064778h case    2:*/		return 0x8206477C;
		  /* 8206477Ch */ case    3:  		/* lwz R30, <#[R3 + 12812]> */
		/* 8206477Ch case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x0000320C) );
		/* 8206477Ch case    3:*/		return 0x82064780;
	}
	return 0x82064780;
} // Block from 82064770h-82064780h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82064780h
// Function 'D3DDevice_GetSamplerState_AddressW'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064780( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064780) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064780);
		  /* 82064780h */ case    0:  		/* mr R31, R3 */
		/* 82064780h case    0:*/		regs.R31 = regs.R3;
		/* 82064780h case    0:*/		return 0x82064784;
		  /* 82064784h */ case    1:  		/* mr R29, R4 */
		/* 82064784h case    1:*/		regs.R29 = regs.R4;
		/* 82064784h case    1:*/		return 0x82064788;
		  /* 82064788h */ case    2:  		/* cmplwi CR6, R30, 0 */
		/* 82064788h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82064788h case    2:*/		return 0x8206478C;
		  /* 8206478Ch */ case    3:  		/* bc 12, CR6_EQ, 104 */
		/* 8206478Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x820647F4;  }
		/* 8206478Ch case    3:*/		return 0x82064790;
		  /* 82064790h */ case    4:  		/* lwz R11, <#[R3 + 11036]> */
		/* 82064790h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002B1C) );
		/* 82064790h case    4:*/		return 0x82064794;
		  /* 82064794h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82064794h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82064794h case    5:*/		return 0x82064798;
	}
	return 0x82064798;
} // Block from 82064780h-82064798h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82064798h
// Function 'D3DDevice_SetSamplerState_TrilinearThreshold'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064798( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064798) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064798);
		  /* 82064798h */ case    0:  		/* bc 12, CR6_EQ, 12 */
		/* 82064798h case    0:*/		if ( regs.CR[6].eq ) { return 0x820647A4;  }
		/* 82064798h case    0:*/		return 0x8206479C;
		  /* 8206479Ch */ case    1:  		/* stw R11, <#[R30 + 8]> */
		/* 8206479Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 8206479Ch case    1:*/		return 0x820647A0;
		  /* 820647A0h */ case    2:  		/* b 84 */
		/* 820647A0h case    2:*/		return 0x820647F4;
		/* 820647A0h case    2:*/		return 0x820647A4;
	}
	return 0x820647A4;
} // Block from 82064798h-820647A4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820647A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820647A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820647A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820647A4);
		  /* 820647A4h */ case    0:  		/* lwz R11, <#[R31 + 11040]> */
		/* 820647A4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B20) );
		/* 820647A4h case    0:*/		return 0x820647A8;
		  /* 820647A8h */ case    1:  		/* lwz R10, <#[R30]> */
		/* 820647A8h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 820647A8h case    1:*/		return 0x820647AC;
		  /* 820647ACh */ case    2:  		/* and. R11, R11, R10 */
		/* 820647ACh case    2:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820647ACh case    2:*/		return 0x820647B0;
		  /* 820647B0h */ case    3:  		/* bc 12, CR0_EQ, 68 */
		/* 820647B0h case    3:*/		if ( regs.CR[0].eq ) { return 0x820647F4;  }
		/* 820647B0h case    3:*/		return 0x820647B4;
		  /* 820647B4h */ case    4:  		/* lwz R11, <#[R31 + 13932]> */
		/* 820647B4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000366C) );
		/* 820647B4h case    4:*/		return 0x820647B8;
		  /* 820647B8h */ case    5:  		/* lwz R3, <#[R31 + 13928]> */
		/* 820647B8h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00003668) );
		/* 820647B8h case    5:*/		return 0x820647BC;
		  /* 820647BCh */ case    6:  		/* cmplw CR6, R3, R11 */
		/* 820647BCh case    6:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 820647BCh case    6:*/		return 0x820647C0;
		  /* 820647C0h */ case    7:  		/* bc 12, CR6_LT, 12 */
		/* 820647C0h case    7:*/		if ( regs.CR[6].lt ) { return 0x820647CC;  }
		/* 820647C0h case    7:*/		return 0x820647C4;
		  /* 820647C4h */ case    8:  		/* mr R3, R31 */
		/* 820647C4h case    8:*/		regs.R3 = regs.R31;
		/* 820647C4h case    8:*/		return 0x820647C8;
		  /* 820647C8h */ case    9:  		/* bl 65960 */
		/* 820647C8h case    9:*/		regs.LR = 0x820647CC; return 0x82074970;
		/* 820647C8h case    9:*/		return 0x820647CC;
	}
	return 0x820647CC;
} // Block from 820647A4h-820647CCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 820647CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820647CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820647CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820647CC);
		  /* 820647CCh */ case    0:  		/* lwz R11, <#[R1 + 80]> */
		/* 820647CCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820647CCh case    0:*/		return 0x820647D0;
		  /* 820647D0h */ case    1:  		/* li R10, -1 */
		/* 820647D0h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 820647D0h case    1:*/		return 0x820647D4;
		  /* 820647D4h */ case    2:  		/* addi R9, R3, 8 */
		/* 820647D4h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R3,0x8);
		/* 820647D4h case    2:*/		return 0x820647D8;
	}
	return 0x820647D8;
} // Block from 820647CCh-820647D8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820647D8h
// Function 'D3DDevice_GetSamplerState_TrilinearThreshold'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820647D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820647D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820647D8);
		  /* 820647D8h */ case    0:  		/* rlwimi R11, R30, 30, 2, 31 */
		/* 820647D8h case    0:*/		cpu::op::rlwimi<0,30,2,31>(regs,&regs.R11,regs.R30);
		/* 820647D8h case    0:*/		return 0x820647DC;
		  /* 820647DCh */ case    1:  		/* stw R10, <#[R1 + 84]> */
		/* 820647DCh case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 820647DCh case    1:*/		return 0x820647E0;
		  /* 820647E0h */ case    2:  		/* rlwinm R11, R11, 0, 2, 0 */
		/* 820647E0h case    2:*/		cpu::op::rlwinm<0,0,2,0>(regs,&regs.R11,regs.R11);
		/* 820647E0h case    2:*/		return 0x820647E4;
		  /* 820647E4h */ case    3:  		/* stw R11, <#[R1 + 80]> */
		/* 820647E4h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820647E4h case    3:*/		return 0x820647E8;
		  /* 820647E8h */ case    4:  		/* ld R11, <#[R1 + 80]> */
		/* 820647E8h case    4:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820647E8h case    4:*/		return 0x820647EC;
		  /* 820647ECh */ case    5:  		/* std R11, <#[R3]> */
		/* 820647ECh case    5:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820647ECh case    5:*/		return 0x820647F0;
	}
	return 0x820647F0;
} // Block from 820647D8h-820647F0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820647F0h
// Function 'D3DDevice_SetSamplerState_HGradientExpBias'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820647F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820647F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820647F0);
		  /* 820647F0h */ case    0:  		/* stw R9, <#[R31 + 13928]> */
		/* 820647F0h case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00003668) );
		/* 820647F0h case    0:*/		return 0x820647F4;
	}
	return 0x820647F4;
} // Block from 820647F0h-820647F4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820647F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820647F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820647F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820647F4);
		  /* 820647F4h */ case    0:  		/* stw R29, <#[R31 + 12812]> */
		/* 820647F4h case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x0000320C) );
		/* 820647F4h case    0:*/		return 0x820647F8;
		  /* 820647F8h */ case    1:  		/* addi R1, R1, 128 */
		/* 820647F8h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820647F8h case    1:*/		return 0x820647FC;
		  /* 820647FCh */ case    2:  		/* b 182960 */
		/* 820647FCh case    2:*/		return 0x820912AC;
		/* 820647FCh case    2:*/		return 0x82064800;
	}
	return 0x82064800;
} // Block from 820647F4h-82064800h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82064800h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064800( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064800) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064800);
		  /* 82064800h */ case    0:  		/* mfspr R12, LR */
		/* 82064800h case    0:*/		regs.R12 = regs.LR;
		/* 82064800h case    0:*/		return 0x82064804;
		  /* 82064804h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82064804h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82064804h case    1:*/		return 0x82064808;
		  /* 82064808h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82064808h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82064808h case    2:*/		return 0x8206480C;
		  /* 8206480Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8206480Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8206480Ch case    3:*/		return 0x82064810;
		  /* 82064810h */ case    4:  		/* addi R11, R4, 3204 */
		/* 82064810h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0xC84);
		/* 82064810h case    4:*/		return 0x82064814;
		  /* 82064814h */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82064814h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82064814h case    5:*/		return 0x82064818;
		  /* 82064818h */ case    6:  		/* lwzx R31, <#[R11 + R3]> */
		/* 82064818h case    6:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 82064818h case    6:*/		return 0x8206481C;
		  /* 8206481Ch */ case    7:  		/* cmplwi CR6, R31, 0 */
		/* 8206481Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8206481Ch case    7:*/		return 0x82064820;
		  /* 82064820h */ case    8:  		/* bc 12, CR6_EQ, 12 */
		/* 82064820h case    8:*/		if ( regs.CR[6].eq ) { return 0x8206482C;  }
		/* 82064820h case    8:*/		return 0x82064824;
		  /* 82064824h */ case    9:  		/* mr R3, R31 */
		/* 82064824h case    9:*/		regs.R3 = regs.R31;
		/* 82064824h case    9:*/		return 0x82064828;
		  /* 82064828h */ case   10:  		/* bl 52656 */
		/* 82064828h case   10:*/		regs.LR = 0x8206482C; return 0x820715D8;
		/* 82064828h case   10:*/		return 0x8206482C;
	}
	return 0x8206482C;
} // Block from 82064800h-8206482Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8206482Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206482C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206482C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206482C);
		  /* 8206482Ch */ case    0:  		/* mr R3, R31 */
		/* 8206482Ch case    0:*/		regs.R3 = regs.R31;
		/* 8206482Ch case    0:*/		return 0x82064830;
	}
	return 0x82064830;
} // Block from 8206482Ch-82064830h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82064830h
// Function 'D3DDevice_GetSamplerState_HGradientExpBias'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064830( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064830) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064830);
		  /* 82064830h */ case    0:  		/* addi R1, R1, 96 */
		/* 82064830h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82064830h case    0:*/		return 0x82064834;
		  /* 82064834h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82064834h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82064834h case    1:*/		return 0x82064838;
		  /* 82064838h */ case    2:  		/* mtspr LR, R12 */
		/* 82064838h case    2:*/		regs.LR = regs.R12;
		/* 82064838h case    2:*/		return 0x8206483C;
		  /* 8206483Ch */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 8206483Ch case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206483Ch case    3:*/		return 0x82064840;
		  /* 82064840h */ case    4:  		/* bclr 20, CR0_LT */
		/* 82064840h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82064840h case    4:*/		return 0x82064844;
	}
	return 0x82064844;
} // Block from 82064830h-82064844h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82064844h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064844( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064844) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064844);
		  /* 82064844h */ case    0:  		/* nop */
		/* 82064844h case    0:*/		cpu::op::nop();
		/* 82064844h case    0:*/		return 0x82064848;
	}
	return 0x82064848;
} // Block from 82064844h-82064848h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82064848h
// Function 'D3DDevice_SetSamplerState_VGradientExpBias'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064848( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064848) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064848);
		  /* 82064848h */ case    0:  		/* mfspr R12, LR */
		/* 82064848h case    0:*/		regs.R12 = regs.LR;
		/* 82064848h case    0:*/		return 0x8206484C;
		  /* 8206484Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8206484Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206484Ch case    1:*/		return 0x82064850;
		  /* 82064850h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82064850h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82064850h case    2:*/		return 0x82064854;
		  /* 82064854h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82064854h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82064854h case    3:*/		return 0x82064858;
		  /* 82064858h */ case    4:  		/* lwz R31, <#[R3 + 12832]> */
		/* 82064858h case    4:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x00003220) );
		/* 82064858h case    4:*/		return 0x8206485C;
		  /* 8206485Ch */ case    5:  		/* cmplwi CR6, R31, 0 */
		/* 8206485Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8206485Ch case    5:*/		return 0x82064860;
		  /* 82064860h */ case    6:  		/* bc 12, CR6_EQ, 12 */
		/* 82064860h case    6:*/		if ( regs.CR[6].eq ) { return 0x8206486C;  }
		/* 82064860h case    6:*/		return 0x82064864;
		  /* 82064864h */ case    7:  		/* mr R3, R31 */
		/* 82064864h case    7:*/		regs.R3 = regs.R31;
		/* 82064864h case    7:*/		return 0x82064868;
		  /* 82064868h */ case    8:  		/* bl 52592 */
		/* 82064868h case    8:*/		regs.LR = 0x8206486C; return 0x820715D8;
		/* 82064868h case    8:*/		return 0x8206486C;
	}
	return 0x8206486C;
} // Block from 82064848h-8206486Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8206486Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206486C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206486C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206486C);
		  /* 8206486Ch */ case    0:  		/* mr R3, R31 */
		/* 8206486Ch case    0:*/		regs.R3 = regs.R31;
		/* 8206486Ch case    0:*/		return 0x82064870;
		  /* 82064870h */ case    1:  		/* addi R1, R1, 96 */
		/* 82064870h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82064870h case    1:*/		return 0x82064874;
		  /* 82064874h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 82064874h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82064874h case    2:*/		return 0x82064878;
		  /* 82064878h */ case    3:  		/* mtspr LR, R12 */
		/* 82064878h case    3:*/		regs.LR = regs.R12;
		/* 82064878h case    3:*/		return 0x8206487C;
		  /* 8206487Ch */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 8206487Ch case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206487Ch case    4:*/		return 0x82064880;
		  /* 82064880h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82064880h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82064880h case    5:*/		return 0x82064884;
	}
	return 0x82064884;
} // Block from 8206486Ch-82064884h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82064884h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064884( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064884) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064884);
		  /* 82064884h */ case    0:  		/* nop */
		/* 82064884h case    0:*/		cpu::op::nop();
		/* 82064884h case    0:*/		return 0x82064888;
	}
	return 0x82064888;
} // Block from 82064884h-82064888h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82064888h
// Function 'D3DDevice_GetSamplerState_VGradientExpBias'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064888( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064888) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064888);
		  /* 82064888h */ case    0:  		/* mfspr R12, LR */
		/* 82064888h case    0:*/		regs.R12 = regs.LR;
		/* 82064888h case    0:*/		return 0x8206488C;
		  /* 8206488Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8206488Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206488Ch case    1:*/		return 0x82064890;
		  /* 82064890h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82064890h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82064890h case    2:*/		return 0x82064894;
		  /* 82064894h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82064894h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82064894h case    3:*/		return 0x82064898;
		  /* 82064898h */ case    4:  		/* stwu R1, <#[R1 - 1648]> */
		/* 82064898h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFF990) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFF990);
		/* 82064898h case    4:*/		return 0x8206489C;
		  /* 8206489Ch */ case    5:  		/* mr R31, R3 */
		/* 8206489Ch case    5:*/		regs.R31 = regs.R3;
		/* 8206489Ch case    5:*/		return 0x820648A0;
	}
	return 0x820648A0;
} // Block from 82064888h-820648A0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820648A0h
// Function 'D3DDevice_SetSamplerState_WhiteBorderColorW'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820648A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820648A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820648A0);
		  /* 820648A0h */ case    0:  		/* mr R4, R5 */
		/* 820648A0h case    0:*/		regs.R4 = regs.R5;
		/* 820648A0h case    0:*/		return 0x820648A4;
		  /* 820648A4h */ case    1:  		/* li R5, 0 */
		/* 820648A4h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 820648A4h case    1:*/		return 0x820648A8;
		  /* 820648A8h */ case    2:  		/* addi R3, R1, 80 */
		/* 820648A8h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 820648A8h case    2:*/		return 0x820648AC;
		  /* 820648ACh */ case    3:  		/* bl 67244 */
		/* 820648ACh case    3:*/		regs.LR = 0x820648B0; return 0x82074F58;
		/* 820648ACh case    3:*/		return 0x820648B0;
		  /* 820648B0h */ case    4:  		/* addi R30, R31, 15408 */
		/* 820648B0h case    4:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x3C30);
		/* 820648B0h case    4:*/		return 0x820648B4;
		  /* 820648B4h */ case    5:  		/* addi R11, R1, 80 */
		/* 820648B4h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 820648B4h case    5:*/		return 0x820648B8;
		  /* 820648B8h */ case    6:  		/* mr R10, R30 */
		/* 820648B8h case    6:*/		regs.R10 = regs.R30;
		/* 820648B8h case    6:*/		return 0x820648BC;
		  /* 820648BCh */ case    7:  		/* addi R8, R11, 1536 */
		/* 820648BCh case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x600);
		/* 820648BCh case    7:*/		return 0x820648C0;
		  /* 820648C0h */ case    8:  		/* lbz R9, <#[R11]> */
		/* 820648C0h case    8:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820648C0h case    8:*/		return 0x820648C4;
		  /* 820648C4h */ case    9:  		/* lbz R7, <#[R10]> */
		/* 820648C4h case    9:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 820648C4h case    9:*/		return 0x820648C8;
		  /* 820648C8h */ case   10:  		/* subf. R9, R7, R9 */
		/* 820648C8h case   10:*/		cpu::op::subf<1>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820648C8h case   10:*/		return 0x820648CC;
		  /* 820648CCh */ case   11:  		/* bc 4, CR0_EQ, 20 */
		/* 820648CCh case   11:*/		if ( !regs.CR[0].eq ) { return 0x820648E0;  }
		/* 820648CCh case   11:*/		return 0x820648D0;
		  /* 820648D0h */ case   12:  		/* addi R11, R11, 1 */
		/* 820648D0h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820648D0h case   12:*/		return 0x820648D4;
		  /* 820648D4h */ case   13:  		/* addi R10, R10, 1 */
		/* 820648D4h case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820648D4h case   13:*/		return 0x820648D8;
		  /* 820648D8h */ case   14:  		/* cmpw CR6, R11, R8 */
		/* 820648D8h case   14:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R8);
		/* 820648D8h case   14:*/		return 0x820648DC;
		  /* 820648DCh */ case   15:  		/* bc 4, CR6_EQ, -28 */
		/* 820648DCh case   15:*/		if ( !regs.CR[6].eq ) { return 0x820648C0;  }
		/* 820648DCh case   15:*/		return 0x820648E0;
	}
	return 0x820648E0;
} // Block from 820648A0h-820648E0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820648E0h
// Function 'D3DDevice_GetSamplerState_WhiteBorderColorW'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820648E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820648E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820648E0);
		  /* 820648E0h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820648E0h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820648E0h case    0:*/		return 0x820648E4;
		  /* 820648E4h */ case    1:  		/* bc 12, CR0_EQ, 92 */
		/* 820648E4h case    1:*/		if ( regs.CR[0].eq ) { return 0x82064940;  }
		/* 820648E4h case    1:*/		return 0x820648E8;
		  /* 820648E8h */ case    2:  		/* bl 2131472 */
		/* 820648E8h case    2:*/		regs.LR = 0x820648EC; return 0x8226CEF8;
		/* 820648E8h case    2:*/		return 0x820648EC;
		  /* 820648ECh */ case    3:  		/* cmpwi CR6, R3, 2 */
		/* 820648ECh case    3:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000002);
		/* 820648ECh case    3:*/		return 0x820648F0;
		  /* 820648F0h */ case    4:  		/* bc 12, CR6_EQ, 52 */
		/* 820648F0h case    4:*/		if ( regs.CR[6].eq ) { return 0x82064924;  }
		/* 820648F0h case    4:*/		return 0x820648F4;
		  /* 820648F4h */ case    5:  		/* lwz R3, <#[R31 + 24364]> */
		/* 820648F4h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00005F2C) );
		/* 820648F4h case    5:*/		return 0x820648F8;
	}
	return 0x820648F8;
} // Block from 820648E0h-820648F8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820648F8h
// Function 'D3DDevice_SetSamplerState_PointBorderEnable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820648F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820648F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820648F8);
		  /* 820648F8h */ case    0:  		/* cmplwi CR6, R3, 0 */
		/* 820648F8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820648F8h case    0:*/		return 0x820648FC;
		  /* 820648FCh */ case    1:  		/* bc 12, CR6_EQ, 28 */
		/* 820648FCh case    1:*/		if ( regs.CR[6].eq ) { return 0x82064918;  }
		/* 820648FCh case    1:*/		return 0x82064900;
		  /* 82064900h */ case    2:  		/* lwz R11, <#[R31 + 24368]> */
		/* 82064900h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00005F30) );
		/* 82064900h case    2:*/		return 0x82064904;
		  /* 82064904h */ case    3:  		/* rlwinm. R11, R11, 0, 0, 0 */
		/* 82064904h case    3:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R11,regs.R11);
		/* 82064904h case    3:*/		return 0x82064908;
		  /* 82064908h */ case    4:  		/* bc 4, CR0_EQ, 16 */
		/* 82064908h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82064918;  }
		/* 82064908h case    4:*/		return 0x8206490C;
		  /* 8206490Ch */ case    5:  		/* li R5, 1536 */
		/* 8206490Ch case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x600);
		/* 8206490Ch case    5:*/		return 0x82064910;
		  /* 82064910h */ case    6:  		/* mr R4, R30 */
		/* 82064910h case    6:*/		regs.R4 = regs.R30;
		/* 82064910h case    6:*/		return 0x82064914;
		  /* 82064914h */ case    7:  		/* bl 144884 */
		/* 82064914h case    7:*/		regs.LR = 0x82064918; return 0x82087F08;
		/* 82064914h case    7:*/		return 0x82064918;
	}
	return 0x82064918;
} // Block from 820648F8h-82064918h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82064918h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064918( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064918) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064918);
		  /* 82064918h */ case    0:  		/* lwz R11, <#[R31 + 24368]> */
		/* 82064918h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00005F30) );
		/* 82064918h case    0:*/		return 0x8206491C;
		  /* 8206491Ch */ case    1:  		/* oris R11, R11, 32768 */
		/* 8206491Ch case    1:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8000);
		/* 8206491Ch case    1:*/		return 0x82064920;
		  /* 82064920h */ case    2:  		/* stw R11, <#[R31 + 24368]> */
		/* 82064920h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00005F30) );
		/* 82064920h case    2:*/		return 0x82064924;
	}
	return 0x82064924;
} // Block from 82064918h-82064924h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82064924h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064924( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064924) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064924);
		  /* 82064924h */ case    0:  		/* addi R4, R1, 80 */
		/* 82064924h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 82064924h case    0:*/		return 0x82064928;
		  /* 82064928h */ case    1:  		/* li R5, 1536 */
		/* 82064928h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x600);
		/* 82064928h case    1:*/		return 0x8206492C;
		  /* 8206492Ch */ case    2:  		/* mr R3, R30 */
		/* 8206492Ch case    2:*/		regs.R3 = regs.R30;
		/* 8206492Ch case    2:*/		return 0x82064930;
		  /* 82064930h */ case    3:  		/* bl 184448 */
		/* 82064930h case    3:*/		regs.LR = 0x82064934; return 0x820919B0;
		/* 82064930h case    3:*/		return 0x82064934;
		  /* 82064934h */ case    4:  		/* lwz R11, <#[R31 + 17116]> */
		/* 82064934h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000042DC) );
		/* 82064934h case    4:*/		return 0x82064938;
		  /* 82064938h */ case    5:  		/* ori R11, R11, 2 */
		/* 82064938h case    5:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82064938h case    5:*/		return 0x8206493C;
		  /* 8206493Ch */ case    6:  		/* stw R11, <#[R31 + 17116]> */
		/* 8206493Ch case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000042DC) );
		/* 8206493Ch case    6:*/		return 0x82064940;
	}
	return 0x82064940;
} // Block from 82064924h-82064940h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82064940h
// Function 'D3DDevice_GetSamplerState_PointBorderEnable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064940( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064940) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064940);
		  /* 82064940h */ case    0:  		/* addi R1, R1, 1648 */
		/* 82064940h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x670);
		/* 82064940h case    0:*/		return 0x82064944;
		  /* 82064944h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82064944h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82064944h case    1:*/		return 0x82064948;
		  /* 82064948h */ case    2:  		/* mtspr LR, R12 */
		/* 82064948h case    2:*/		regs.LR = regs.R12;
		/* 82064948h case    2:*/		return 0x8206494C;
		  /* 8206494Ch */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 8206494Ch case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8206494Ch case    3:*/		return 0x82064950;
		  /* 82064950h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 82064950h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82064950h case    4:*/		return 0x82064954;
		  /* 82064954h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82064954h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82064954h case    5:*/		return 0x82064958;
	}
	return 0x82064958;
} // Block from 82064940h-82064958h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82064958h
// Function 'D3DDevice_SetScissorRect'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064958( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064958) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064958);
		  /* 82064958h */ case    0:  		/* mfspr R12, LR */
		/* 82064958h case    0:*/		regs.R12 = regs.LR;
		/* 82064958h case    0:*/		return 0x8206495C;
		  /* 8206495Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8206495Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206495Ch case    1:*/		return 0x82064960;
		  /* 82064960h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82064960h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82064960h case    2:*/		return 0x82064964;
		  /* 82064964h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82064964h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82064964h case    3:*/		return 0x82064968;
		  /* 82064968h */ case    4:  		/* stwu R1, <#[R1 - 1648]> */
		/* 82064968h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFF990) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFF990);
		/* 82064968h case    4:*/		return 0x8206496C;
		  /* 8206496Ch */ case    5:  		/* mr R31, R3 */
		/* 8206496Ch case    5:*/		regs.R31 = regs.R3;
		/* 8206496Ch case    5:*/		return 0x82064970;
		  /* 82064970h */ case    6:  		/* mr R4, R5 */
		/* 82064970h case    6:*/		regs.R4 = regs.R5;
		/* 82064970h case    6:*/		return 0x82064974;
		  /* 82064974h */ case    7:  		/* li R5, 0 */
		/* 82064974h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82064974h case    7:*/		return 0x82064978;
		  /* 82064978h */ case    8:  		/* addi R3, R1, 80 */
		/* 82064978h case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82064978h case    8:*/		return 0x8206497C;
		  /* 8206497Ch */ case    9:  		/* bl 67188 */
		/* 8206497Ch case    9:*/		regs.LR = 0x82064980; return 0x82074FF0;
		/* 8206497Ch case    9:*/		return 0x82064980;
		  /* 82064980h */ case   10:  		/* addi R30, R31, 15408 */
		/* 82064980h case   10:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x3C30);
		/* 82064980h case   10:*/		return 0x82064984;
		  /* 82064984h */ case   11:  		/* addi R11, R1, 80 */
		/* 82064984h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 82064984h case   11:*/		return 0x82064988;
		  /* 82064988h */ case   12:  		/* mr R10, R30 */
		/* 82064988h case   12:*/		regs.R10 = regs.R30;
		/* 82064988h case   12:*/		return 0x8206498C;
		  /* 8206498Ch */ case   13:  		/* addi R8, R11, 1536 */
		/* 8206498Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x600);
		/* 8206498Ch case   13:*/		return 0x82064990;
		  /* 82064990h */ case   14:  		/* lbz R9, <#[R11]> */
		/* 82064990h case   14:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82064990h case   14:*/		return 0x82064994;
		  /* 82064994h */ case   15:  		/* lbz R7, <#[R10]> */
		/* 82064994h case   15:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 82064994h case   15:*/		return 0x82064998;
		  /* 82064998h */ case   16:  		/* subf. R9, R7, R9 */
		/* 82064998h case   16:*/		cpu::op::subf<1>(regs,&regs.R9,regs.R7,regs.R9);
		/* 82064998h case   16:*/		return 0x8206499C;
		  /* 8206499Ch */ case   17:  		/* bc 4, CR0_EQ, 20 */
		/* 8206499Ch case   17:*/		if ( !regs.CR[0].eq ) { return 0x820649B0;  }
		/* 8206499Ch case   17:*/		return 0x820649A0;
		  /* 820649A0h */ case   18:  		/* addi R11, R11, 1 */
		/* 820649A0h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820649A0h case   18:*/		return 0x820649A4;
		  /* 820649A4h */ case   19:  		/* addi R10, R10, 1 */
		/* 820649A4h case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820649A4h case   19:*/		return 0x820649A8;
		  /* 820649A8h */ case   20:  		/* cmpw CR6, R11, R8 */
		/* 820649A8h case   20:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R8);
		/* 820649A8h case   20:*/		return 0x820649AC;
		  /* 820649ACh */ case   21:  		/* bc 4, CR6_EQ, -28 */
		/* 820649ACh case   21:*/		if ( !regs.CR[6].eq ) { return 0x82064990;  }
		/* 820649ACh case   21:*/		return 0x820649B0;
	}
	return 0x820649B0;
} // Block from 82064958h-820649B0h (22 instructions)

//////////////////////////////////////////////////////
// Block at 820649B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820649B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820649B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820649B0);
		  /* 820649B0h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 820649B0h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 820649B0h case    0:*/		return 0x820649B4;
		  /* 820649B4h */ case    1:  		/* bc 12, CR0_EQ, 92 */
		/* 820649B4h case    1:*/		if ( regs.CR[0].eq ) { return 0x82064A10;  }
		/* 820649B4h case    1:*/		return 0x820649B8;
		  /* 820649B8h */ case    2:  		/* bl 2131264 */
		/* 820649B8h case    2:*/		regs.LR = 0x820649BC; return 0x8226CEF8;
		/* 820649B8h case    2:*/		return 0x820649BC;
		  /* 820649BCh */ case    3:  		/* cmpwi CR6, R3, 2 */
		/* 820649BCh case    3:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000002);
		/* 820649BCh case    3:*/		return 0x820649C0;
		  /* 820649C0h */ case    4:  		/* bc 12, CR6_EQ, 52 */
		/* 820649C0h case    4:*/		if ( regs.CR[6].eq ) { return 0x820649F4;  }
		/* 820649C0h case    4:*/		return 0x820649C4;
		  /* 820649C4h */ case    5:  		/* lwz R3, <#[R31 + 24364]> */
		/* 820649C4h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00005F2C) );
		/* 820649C4h case    5:*/		return 0x820649C8;
		  /* 820649C8h */ case    6:  		/* cmplwi CR6, R3, 0 */
		/* 820649C8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 820649C8h case    6:*/		return 0x820649CC;
		  /* 820649CCh */ case    7:  		/* bc 12, CR6_EQ, 28 */
		/* 820649CCh case    7:*/		if ( regs.CR[6].eq ) { return 0x820649E8;  }
		/* 820649CCh case    7:*/		return 0x820649D0;
		  /* 820649D0h */ case    8:  		/* lwz R11, <#[R31 + 24368]> */
		/* 820649D0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00005F30) );
		/* 820649D0h case    8:*/		return 0x820649D4;
		  /* 820649D4h */ case    9:  		/* rlwinm. R11, R11, 0, 0, 0 */
		/* 820649D4h case    9:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R11,regs.R11);
		/* 820649D4h case    9:*/		return 0x820649D8;
		  /* 820649D8h */ case   10:  		/* bc 4, CR0_EQ, 16 */
		/* 820649D8h case   10:*/		if ( !regs.CR[0].eq ) { return 0x820649E8;  }
		/* 820649D8h case   10:*/		return 0x820649DC;
		  /* 820649DCh */ case   11:  		/* li R5, 1536 */
		/* 820649DCh case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x600);
		/* 820649DCh case   11:*/		return 0x820649E0;
		  /* 820649E0h */ case   12:  		/* mr R4, R30 */
		/* 820649E0h case   12:*/		regs.R4 = regs.R30;
		/* 820649E0h case   12:*/		return 0x820649E4;
		  /* 820649E4h */ case   13:  		/* bl 144676 */
		/* 820649E4h case   13:*/		regs.LR = 0x820649E8; return 0x82087F08;
		/* 820649E4h case   13:*/		return 0x820649E8;
	}
	return 0x820649E8;
} // Block from 820649B0h-820649E8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820649E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820649E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820649E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820649E8);
		  /* 820649E8h */ case    0:  		/* lwz R11, <#[R31 + 24368]> */
		/* 820649E8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00005F30) );
		/* 820649E8h case    0:*/		return 0x820649EC;
		  /* 820649ECh */ case    1:  		/* oris R11, R11, 32768 */
		/* 820649ECh case    1:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8000);
		/* 820649ECh case    1:*/		return 0x820649F0;
		  /* 820649F0h */ case    2:  		/* stw R11, <#[R31 + 24368]> */
		/* 820649F0h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00005F30) );
		/* 820649F0h case    2:*/		return 0x820649F4;
	}
	return 0x820649F4;
} // Block from 820649E8h-820649F4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820649F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820649F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820649F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820649F4);
		  /* 820649F4h */ case    0:  		/* addi R4, R1, 80 */
		/* 820649F4h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 820649F4h case    0:*/		return 0x820649F8;
		  /* 820649F8h */ case    1:  		/* li R5, 1536 */
		/* 820649F8h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x600);
		/* 820649F8h case    1:*/		return 0x820649FC;
		  /* 820649FCh */ case    2:  		/* mr R3, R30 */
		/* 820649FCh case    2:*/		regs.R3 = regs.R30;
		/* 820649FCh case    2:*/		return 0x82064A00;
		  /* 82064A00h */ case    3:  		/* bl 184240 */
		/* 82064A00h case    3:*/		regs.LR = 0x82064A04; return 0x820919B0;
		/* 82064A00h case    3:*/		return 0x82064A04;
		  /* 82064A04h */ case    4:  		/* lwz R11, <#[R31 + 17116]> */
		/* 82064A04h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000042DC) );
		/* 82064A04h case    4:*/		return 0x82064A08;
		  /* 82064A08h */ case    5:  		/* ori R11, R11, 2 */
		/* 82064A08h case    5:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82064A08h case    5:*/		return 0x82064A0C;
		  /* 82064A0Ch */ case    6:  		/* stw R11, <#[R31 + 17116]> */
		/* 82064A0Ch case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000042DC) );
		/* 82064A0Ch case    6:*/		return 0x82064A10;
	}
	return 0x82064A10;
} // Block from 820649F4h-82064A10h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82064A10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064A10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064A10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064A10);
		  /* 82064A10h */ case    0:  		/* addi R1, R1, 1648 */
		/* 82064A10h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x670);
		/* 82064A10h case    0:*/		return 0x82064A14;
		  /* 82064A14h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82064A14h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82064A14h case    1:*/		return 0x82064A18;
		  /* 82064A18h */ case    2:  		/* mtspr LR, R12 */
		/* 82064A18h case    2:*/		regs.LR = regs.R12;
		/* 82064A18h case    2:*/		return 0x82064A1C;
		  /* 82064A1Ch */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 82064A1Ch case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82064A1Ch case    3:*/		return 0x82064A20;
		  /* 82064A20h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 82064A20h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82064A20h case    4:*/		return 0x82064A24;
		  /* 82064A24h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82064A24h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82064A24h case    5:*/		return 0x82064A28;
	}
	return 0x82064A28;
} // Block from 82064A10h-82064A28h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82064A28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064A28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064A28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064A28);
		  /* 82064A28h */ case    0:  		/* mfspr R12, LR */
		/* 82064A28h case    0:*/		regs.R12 = regs.LR;
		/* 82064A28h case    0:*/		return 0x82064A2C;
		  /* 82064A2Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82064A2Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82064A2Ch case    1:*/		return 0x82064A30;
		  /* 82064A30h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82064A30h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82064A30h case    2:*/		return 0x82064A34;
		  /* 82064A34h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82064A34h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82064A34h case    3:*/		return 0x82064A38;
		  /* 82064A38h */ case    4:  		/* mr R31, R3 */
		/* 82064A38h case    4:*/		regs.R31 = regs.R3;
		/* 82064A38h case    4:*/		return 0x82064A3C;
		  /* 82064A3Ch */ case    5:  		/* cmpwi CR6, R4, 0 */
		/* 82064A3Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000000);
		/* 82064A3Ch case    5:*/		return 0x82064A40;
		  /* 82064A40h */ case    6:  		/* bc 4, CR6_EQ, 112 */
		/* 82064A40h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82064AB0;  }
		/* 82064A40h case    6:*/		return 0x82064A44;
		  /* 82064A44h */ case    7:  		/* lwz R11, <#[R3 + 56]> */
		/* 82064A44h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000038) );
		/* 82064A44h case    7:*/		return 0x82064A48;
		  /* 82064A48h */ case    8:  		/* lwz R3, <#[R3 + 48]> */
		/* 82064A48h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000030) );
		/* 82064A48h case    8:*/		return 0x82064A4C;
		  /* 82064A4Ch */ case    9:  		/* cmplw CR6, R3, R11 */
		/* 82064A4Ch case    9:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 82064A4Ch case    9:*/		return 0x82064A50;
	}
	return 0x82064A50;
} // Block from 82064A28h-82064A50h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82064A50h
// Function 'D3DDevice_SetStreamSource'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064A50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064A50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064A50);
		  /* 82064A50h */ case    0:  		/* bc 4, CR6_GT, 12 */
		/* 82064A50h case    0:*/		if ( !regs.CR[6].gt ) { return 0x82064A5C;  }
		/* 82064A50h case    0:*/		return 0x82064A54;
		  /* 82064A54h */ case    1:  		/* mr R3, R31 */
		/* 82064A54h case    1:*/		regs.R3 = regs.R31;
		/* 82064A54h case    1:*/		return 0x82064A58;
		  /* 82064A58h */ case    2:  		/* bl 63152 */
		/* 82064A58h case    2:*/		regs.LR = 0x82064A5C; return 0x82074108;
		/* 82064A58h case    2:*/		return 0x82064A5C;
	}
	return 0x82064A5C;
} // Block from 82064A50h-82064A5Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82064A5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064A5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064A5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064A5C);
		  /* 82064A5Ch */ case    0:  		/* lis R11, -16384 */
		/* 82064A5Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFFC000);
		/* 82064A5Ch case    0:*/		return 0x82064A60;
		  /* 82064A60h */ case    1:  		/* lis R10, -16384 */
		/* 82064A60h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFC000);
		/* 82064A60h case    1:*/		return 0x82064A64;
		  /* 82064A64h */ case    2:  		/* ori R11, R11, 24576 */
		/* 82064A64h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x6000);
		/* 82064A64h case    2:*/		return 0x82064A68;
		  /* 82064A68h */ case    3:  		/* ori R10, R10, 25088 */
		/* 82064A68h case    3:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x6200);
		/* 82064A68h case    3:*/		return 0x82064A6C;
		  /* 82064A6Ch */ case    4:  		/* stwu R11, <#[R3 + 4]> */
		/* 82064A6Ch case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82064A6Ch case    4:*/		return 0x82064A70;
		  /* 82064A70h */ case    5:  		/* li R11, -1 */
		/* 82064A70h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 82064A70h case    5:*/		return 0x82064A74;
		  /* 82064A74h */ case    6:  		/* lwz R9, <#[R31 + 13084]> */
		/* 82064A74h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000331C) );
		/* 82064A74h case    6:*/		return 0x82064A78;
		  /* 82064A78h */ case    7:  		/* lis R8, -16384 */
		/* 82064A78h case    7:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFFC000);
		/* 82064A78h case    7:*/		return 0x82064A7C;
		  /* 82064A7Ch */ case    8:  		/* lis R7, -16384 */
		/* 82064A7Ch case    8:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFFC000);
		/* 82064A7Ch case    8:*/		return 0x82064A80;
		  /* 82064A80h */ case    9:  		/* ori R8, R8, 24832 */
		/* 82064A80h case    9:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x6100);
		/* 82064A80h case    9:*/		return 0x82064A84;
		  /* 82064A84h */ case   10:  		/* ori R7, R7, 25344 */
		/* 82064A84h case   10:*/		cpu::op::ori<0>(regs,&regs.R7,regs.R7,0x6300);
		/* 82064A84h case   10:*/		return 0x82064A88;
		  /* 82064A88h */ case   11:  		/* li R6, 0 */
		/* 82064A88h case   11:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82064A88h case   11:*/		return 0x82064A8C;
		  /* 82064A8Ch */ case   12:  		/* stwu R9, <#[R3 + 4]> */
		/* 82064A8Ch case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82064A8Ch case   12:*/		return 0x82064A90;
		  /* 82064A90h */ case   13:  		/* stwu R10, <#[R3 + 4]> */
		/* 82064A90h case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82064A90h case   13:*/		return 0x82064A94;
		  /* 82064A94h */ case   14:  		/* stwu R11, <#[R3 + 4]> */
		/* 82064A94h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82064A94h case   14:*/		return 0x82064A98;
		  /* 82064A98h */ case   15:  		/* stwu R8, <#[R3 + 4]> */
		/* 82064A98h case   15:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82064A98h case   15:*/		return 0x82064A9C;
		  /* 82064A9Ch */ case   16:  		/* lwz R11, <#[R31 + 13088]> */
		/* 82064A9Ch case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003320) );
		/* 82064A9Ch case   16:*/		return 0x82064AA0;
		  /* 82064AA0h */ case   17:  		/* stwu R11, <#[R3 + 4]> */
		/* 82064AA0h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82064AA0h case   17:*/		return 0x82064AA4;
		  /* 82064AA4h */ case   18:  		/* stwu R7, <#[R3 + 4]> */
		/* 82064AA4h case   18:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82064AA4h case   18:*/		return 0x82064AA8;
		  /* 82064AA8h */ case   19:  		/* stwu R6, <#[R3 + 4]> */
		/* 82064AA8h case   19:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x00000004) );
		regs.R3 = (uint32)(regs.R3 + 0x00000004);
		/* 82064AA8h case   19:*/		return 0x82064AAC;
		  /* 82064AACh */ case   20:  		/* stw R3, <#[R31 + 48]> */
		/* 82064AACh case   20:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 82064AACh case   20:*/		return 0x82064AB0;
	}
	return 0x82064AB0;
} // Block from 82064A5Ch-82064AB0h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82064AB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064AB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064AB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064AB0);
		  /* 82064AB0h */ case    0:  		/* lwz R11, <#[R31 + 10440]> */
		/* 82064AB0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000028C8) );
		/* 82064AB0h case    0:*/		return 0x82064AB4;
		  /* 82064AB4h */ case    1:  		/* mr R3, R31 */
		/* 82064AB4h case    1:*/		regs.R3 = regs.R31;
		/* 82064AB4h case    1:*/		return 0x82064AB8;
		  /* 82064AB8h */ case    2:  		/* lwz R10, <#[R31 + 10436]> */
		/* 82064AB8h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000028C4) );
		/* 82064AB8h case    2:*/		return 0x82064ABC;
		  /* 82064ABCh */ case    3:  		/* rlwinm R9, R11, 1, 0, 30 */
		/* 82064ABCh case    3:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R9,regs.R11);
		/* 82064ABCh case    3:*/		return 0x82064AC0;
		  /* 82064AC0h */ case    4:  		/* rlwinm R11, R11, 17, 0, 14 */
		/* 82064AC0h case    4:*/		cpu::op::rlwinm<0,17,0,14>(regs,&regs.R11,regs.R11);
		/* 82064AC0h case    4:*/		return 0x82064AC4;
		  /* 82064AC4h */ case    5:  		/* rlwinm R8, R10, 1, 0, 30 */
		/* 82064AC4h case    5:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R8,regs.R10);
		/* 82064AC4h case    5:*/		return 0x82064AC8;
		  /* 82064AC8h */ case    6:  		/* srawi R7, R9, 17 */
		/* 82064AC8h case    6:*/		cpu::op::srawi<0,17>(regs,&regs.R7,regs.R9);
		/* 82064AC8h case    6:*/		return 0x82064ACC;
		  /* 82064ACCh */ case    7:  		/* rlwinm R10, R10, 17, 0, 14 */
		/* 82064ACCh case    7:*/		cpu::op::rlwinm<0,17,0,14>(regs,&regs.R10,regs.R10);
		/* 82064ACCh case    7:*/		return 0x82064AD0;
		  /* 82064AD0h */ case    8:  		/* srawi R6, R11, 17 */
		/* 82064AD0h case    8:*/		cpu::op::srawi<0,17>(regs,&regs.R6,regs.R11);
		/* 82064AD0h case    8:*/		return 0x82064AD4;
		  /* 82064AD4h */ case    9:  		/* srawi R5, R8, 17 */
		/* 82064AD4h case    9:*/		cpu::op::srawi<0,17>(regs,&regs.R5,regs.R8);
		/* 82064AD4h case    9:*/		return 0x82064AD8;
		  /* 82064AD8h */ case   10:  		/* srawi R4, R10, 17 */
		/* 82064AD8h case   10:*/		cpu::op::srawi<0,17>(regs,&regs.R4,regs.R10);
		/* 82064AD8h case   10:*/		return 0x82064ADC;
		  /* 82064ADCh */ case   11:  		/* bl -11060 */
		/* 82064ADCh case   11:*/		regs.LR = 0x82064AE0; return 0x82061FA8;
		/* 82064ADCh case   11:*/		return 0x82064AE0;
		  /* 82064AE0h */ case   12:  		/* lwz R11, <#[R31 + 11044]> */
		/* 82064AE0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B24) );
		/* 82064AE0h case   12:*/		return 0x82064AE4;
		  /* 82064AE4h */ case   13:  		/* mr R3, R31 */
		/* 82064AE4h case   13:*/		regs.R3 = regs.R31;
		/* 82064AE4h case   13:*/		return 0x82064AE8;
		  /* 82064AE8h */ case   14:  		/* rlwinm R4, R11, 20, 30, 31 */
		/* 82064AE8h case   14:*/		cpu::op::rlwinm<0,20,30,31>(regs,&regs.R4,regs.R11);
		/* 82064AE8h case   14:*/		return 0x82064AEC;
		  /* 82064AECh */ case   15:  		/* bl 67788 */
		/* 82064AECh case   15:*/		regs.LR = 0x82064AF0; return 0x820753B8;
		/* 82064AECh case   15:*/		return 0x82064AF0;
		  /* 82064AF0h */ case   16:  		/* li R11, -1 */
		/* 82064AF0h case   16:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 82064AF0h case   16:*/		return 0x82064AF4;
		  /* 82064AF4h */ case   17:  		/* std R11, <#[R31]> */
		/* 82064AF4h case   17:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82064AF4h case   17:*/		return 0x82064AF8;
		  /* 82064AF8h */ case   18:  		/* std R11, <#[R31 + 8]> */
		/* 82064AF8h case   18:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82064AF8h case   18:*/		return 0x82064AFC;
		  /* 82064AFCh */ case   19:  		/* std R11, <#[R31 + 16]> */
		/* 82064AFCh case   19:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82064AFCh case   19:*/		return 0x82064B00;
		  /* 82064B00h */ case   20:  		/* std R11, <#[R31 + 24]> */
		/* 82064B00h case   20:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 82064B00h case   20:*/		return 0x82064B04;
		  /* 82064B04h */ case   21:  		/* std R11, <#[R31 + 32]> */
		/* 82064B04h case   21:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 82064B04h case   21:*/		return 0x82064B08;
		  /* 82064B08h */ case   22:  		/* addi R1, R1, 96 */
		/* 82064B08h case   22:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82064B08h case   22:*/		return 0x82064B0C;
		  /* 82064B0Ch */ case   23:  		/* lwz R12, <#[R1 - 8]> */
		/* 82064B0Ch case   23:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82064B0Ch case   23:*/		return 0x82064B10;
		  /* 82064B10h */ case   24:  		/* mtspr LR, R12 */
		/* 82064B10h case   24:*/		regs.LR = regs.R12;
		/* 82064B10h case   24:*/		return 0x82064B14;
		  /* 82064B14h */ case   25:  		/* ld R31, <#[R1 - 16]> */
		/* 82064B14h case   25:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82064B14h case   25:*/		return 0x82064B18;
		  /* 82064B18h */ case   26:  		/* bclr 20, CR0_LT */
		/* 82064B18h case   26:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82064B18h case   26:*/		return 0x82064B1C;
	}
	return 0x82064B1C;
} // Block from 82064AB0h-82064B1Ch (27 instructions)

//////////////////////////////////////////////////////
// Block at 82064B1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064B1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064B1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064B1C);
		  /* 82064B1Ch */ case    0:  		/* nop */
		/* 82064B1Ch case    0:*/		cpu::op::nop();
		/* 82064B1Ch case    0:*/		return 0x82064B20;
	}
	return 0x82064B20;
} // Block from 82064B1Ch-82064B20h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82064B20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064B20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064B20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064B20);
		  /* 82064B20h */ case    0:  		/* mfspr R12, LR */
		/* 82064B20h case    0:*/		regs.R12 = regs.LR;
		/* 82064B20h case    0:*/		return 0x82064B24;
		  /* 82064B24h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82064B24h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82064B24h case    1:*/		return 0x82064B28;
		  /* 82064B28h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82064B28h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82064B28h case    2:*/		return 0x82064B2C;
		  /* 82064B2Ch */ case    3:  		/* addi R12, R1, -16 */
		/* 82064B2Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R1,0xFFFFFFF0);
		/* 82064B2Ch case    3:*/		return 0x82064B30;
		  /* 82064B30h */ case    4:  		/* bl 182496 */
		/* 82064B30h case    4:*/		regs.LR = 0x82064B34; return 0x82091410;
		/* 82064B30h case    4:*/		return 0x82064B34;
		  /* 82064B34h */ case    5:  		/* stwu R1, <#[R1 - 160]> */
		/* 82064B34h case    5:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82064B34h case    5:*/		return 0x82064B38;
		  /* 82064B38h */ case    6:  		/* lwz R10, <#[R3 + 12816]> */
		/* 82064B38h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00003210) );
		/* 82064B38h case    6:*/		return 0x82064B3C;
		  /* 82064B3Ch */ case    7:  		/* mr R31, R3 */
		/* 82064B3Ch case    7:*/		regs.R31 = regs.R3;
		/* 82064B3Ch case    7:*/		return 0x82064B40;
		  /* 82064B40h */ case    8:  		/* fmr FR31, FR1 */
		/* 82064B40h case    8:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR1);
		/* 82064B40h case    8:*/		return 0x82064B44;
		  /* 82064B44h */ case    9:  		/* fmr FR30, FR2 */
		/* 82064B44h case    9:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR2);
		/* 82064B44h case    9:*/		return 0x82064B48;
		  /* 82064B48h */ case   10:  		/* mr R9, R10 */
		/* 82064B48h case   10:*/		regs.R9 = regs.R10;
		/* 82064B48h case   10:*/		return 0x82064B4C;
		  /* 82064B4Ch */ case   11:  		/* fmr FR29, FR5 */
		/* 82064B4Ch case   11:*/		cpu::op::fmr<0>(regs,&regs.FR29,regs.FR5);
		/* 82064B4Ch case   11:*/		return 0x82064B50;
		  /* 82064B50h */ case   12:  		/* cmplwi CR0, R10, 0 */
		/* 82064B50h case   12:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 82064B50h case   12:*/		return 0x82064B54;
		  /* 82064B54h */ case   13:  		/* fmr FR28, FR6 */
		/* 82064B54h case   13:*/		cpu::op::fmr<0>(regs,&regs.FR28,regs.FR6);
		/* 82064B54h case   13:*/		return 0x82064B58;
		  /* 82064B58h */ case   14:  		/* bc 4, CR0_EQ, 16 */
		/* 82064B58h case   14:*/		if ( !regs.CR[0].eq ) { return 0x82064B68;  }
		/* 82064B58h case   14:*/		return 0x82064B5C;
		  /* 82064B5Ch */ case   15:  		/* lwz R9, <#[R3 + 12832]> */
		/* 82064B5Ch case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00003220) );
		/* 82064B5Ch case   15:*/		return 0x82064B60;
		  /* 82064B60h */ case   16:  		/* cmplwi CR6, R9, 0 */
		/* 82064B60h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82064B60h case   16:*/		return 0x82064B64;
		  /* 82064B64h */ case   17:  		/* bc 12, CR6_EQ, 504 */
		/* 82064B64h case   17:*/		if ( regs.CR[6].eq ) { return 0x82064D5C;  }
		/* 82064B64h case   17:*/		return 0x82064B68;
	}
	return 0x82064B68;
} // Block from 82064B20h-82064B68h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82064B68h
// Function 'D3DDevice_SetIndices'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064B68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064B68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064B68);
		  /* 82064B68h */ case    0:  		/* lbz R11, <#[R31 + 11068]> */
		/* 82064B68h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B3C) );
		/* 82064B68h case    0:*/		return 0x82064B6C;
		  /* 82064B6Ch */ case    1:  		/* rlwinm. R8, R11, 0, 27, 27 */
		/* 82064B6Ch case    1:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R8,regs.R11);
		/* 82064B6Ch case    1:*/		return 0x82064B70;
		  /* 82064B70h */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 82064B70h case    2:*/		if ( regs.CR[0].eq ) { return 0x82064B7C;  }
		/* 82064B70h case    2:*/		return 0x82064B74;
		  /* 82064B74h */ case    3:  		/* li R11, 1 */
		/* 82064B74h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82064B74h case    3:*/		return 0x82064B78;
		  /* 82064B78h */ case    4:  		/* b 144 */
		/* 82064B78h case    4:*/		return 0x82064C08;
		/* 82064B78h case    4:*/		return 0x82064B7C;
	}
	return 0x82064B7C;
} // Block from 82064B68h-82064B7Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82064B7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064B7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064B7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064B7C);
		  /* 82064B7Ch */ case    0:  		/* rlwinm. R11, R11, 0, 26, 26 */
		/* 82064B7Ch case    0:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R11);
		/* 82064B7Ch case    0:*/		return 0x82064B80;
		  /* 82064B80h */ case    1:  		/* bc 12, CR0_EQ, 128 */
		/* 82064B80h case    1:*/		if ( regs.CR[0].eq ) { return 0x82064C00;  }
		/* 82064B80h case    1:*/		return 0x82064B84;
		  /* 82064B84h */ case    2:  		/* lwz R11, <#[R31 + 13104]> */
		/* 82064B84h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003330) );
		/* 82064B84h case    2:*/		return 0x82064B88;
		  /* 82064B88h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 82064B88h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82064B88h case    3:*/		return 0x82064B8C;
		  /* 82064B8Ch */ case    4:  		/* bc 12, CR6_EQ, 12 */
		/* 82064B8Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x82064B98;  }
		/* 82064B8Ch case    4:*/		return 0x82064B90;
		  /* 82064B90h */ case    5:  		/* cmplwi CR6, R10, 0 */
		/* 82064B90h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82064B90h case    5:*/		return 0x82064B94;
		  /* 82064B94h */ case    6:  		/* bc 4, CR6_EQ, 108 */
		/* 82064B94h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82064C00;  }
		/* 82064B94h case    6:*/		return 0x82064B98;
	}
	return 0x82064B98;
} // Block from 82064B7Ch-82064B98h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82064B98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064B98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064B98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064B98);
		  /* 82064B98h */ case    0:  		/* lwz R11, <#[R31 + 12820]> */
		/* 82064B98h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003214) );
		/* 82064B98h case    0:*/		return 0x82064B9C;
		  /* 82064B9Ch */ case    1:  		/* lwz R10, <#[R31 + 13108]> */
		/* 82064B9Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00003334) );
		/* 82064B9Ch case    1:*/		return 0x82064BA0;
		  /* 82064BA0h */ case    2:  		/* cmplw CR6, R10, R11 */
		/* 82064BA0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82064BA0h case    2:*/		return 0x82064BA4;
		  /* 82064BA4h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 82064BA4h case    3:*/		if ( regs.CR[6].eq ) { return 0x82064BB0;  }
		/* 82064BA4h case    3:*/		return 0x82064BA8;
		  /* 82064BA8h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82064BA8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82064BA8h case    4:*/		return 0x82064BAC;
		  /* 82064BACh */ case    5:  		/* bc 4, CR6_EQ, 84 */
		/* 82064BACh case    5:*/		if ( !regs.CR[6].eq ) { return 0x82064C00;  }
		/* 82064BACh case    5:*/		return 0x82064BB0;
	}
	return 0x82064BB0;
} // Block from 82064B98h-82064BB0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82064BB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064BB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064BB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064BB0);
		  /* 82064BB0h */ case    0:  		/* lwz R11, <#[R31 + 12824]> */
		/* 82064BB0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003218) );
		/* 82064BB0h case    0:*/		return 0x82064BB4;
		  /* 82064BB4h */ case    1:  		/* lwz R10, <#[R31 + 13112]> */
		/* 82064BB4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00003338) );
		/* 82064BB4h case    1:*/		return 0x82064BB8;
		  /* 82064BB8h */ case    2:  		/* cmplw CR6, R10, R11 */
		/* 82064BB8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82064BB8h case    2:*/		return 0x82064BBC;
		  /* 82064BBCh */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 82064BBCh case    3:*/		if ( regs.CR[6].eq ) { return 0x82064BC8;  }
		/* 82064BBCh case    3:*/		return 0x82064BC0;
		  /* 82064BC0h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82064BC0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82064BC0h case    4:*/		return 0x82064BC4;
		  /* 82064BC4h */ case    5:  		/* bc 4, CR6_EQ, 60 */
		/* 82064BC4h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82064C00;  }
		/* 82064BC4h case    5:*/		return 0x82064BC8;
	}
	return 0x82064BC8;
} // Block from 82064BB0h-82064BC8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82064BC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064BC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064BC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064BC8);
		  /* 82064BC8h */ case    0:  		/* lwz R11, <#[R31 + 12828]> */
		/* 82064BC8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000321C) );
		/* 82064BC8h case    0:*/		return 0x82064BCC;
		  /* 82064BCCh */ case    1:  		/* lwz R10, <#[R31 + 13116]> */
		/* 82064BCCh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000333C) );
		/* 82064BCCh case    1:*/		return 0x82064BD0;
		  /* 82064BD0h */ case    2:  		/* cmplw CR6, R10, R11 */
		/* 82064BD0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82064BD0h case    2:*/		return 0x82064BD4;
		  /* 82064BD4h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 82064BD4h case    3:*/		if ( regs.CR[6].eq ) { return 0x82064BE0;  }
		/* 82064BD4h case    3:*/		return 0x82064BD8;
		  /* 82064BD8h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82064BD8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82064BD8h case    4:*/		return 0x82064BDC;
		  /* 82064BDCh */ case    5:  		/* bc 4, CR6_EQ, 36 */
		/* 82064BDCh case    5:*/		if ( !regs.CR[6].eq ) { return 0x82064C00;  }
		/* 82064BDCh case    5:*/		return 0x82064BE0;
	}
	return 0x82064BE0;
} // Block from 82064BC8h-82064BE0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82064BE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064BE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064BE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064BE0);
		  /* 82064BE0h */ case    0:  		/* lwz R11, <#[R31 + 12832]> */
		/* 82064BE0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003220) );
		/* 82064BE0h case    0:*/		return 0x82064BE4;
		  /* 82064BE4h */ case    1:  		/* lwz R10, <#[R31 + 13120]> */
		/* 82064BE4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00003340) );
		/* 82064BE4h case    1:*/		return 0x82064BE8;
		  /* 82064BE8h */ case    2:  		/* cmplw CR6, R10, R11 */
		/* 82064BE8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82064BE8h case    2:*/		return 0x82064BEC;
		  /* 82064BECh */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 82064BECh case    3:*/		if ( regs.CR[6].eq ) { return 0x82064BF8;  }
		/* 82064BECh case    3:*/		return 0x82064BF0;
		  /* 82064BF0h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82064BF0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82064BF0h case    4:*/		return 0x82064BF4;
		  /* 82064BF4h */ case    5:  		/* bc 4, CR6_EQ, 12 */
		/* 82064BF4h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82064C00;  }
		/* 82064BF4h case    5:*/		return 0x82064BF8;
	}
	return 0x82064BF8;
} // Block from 82064BE0h-82064BF8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82064BF8h
// Function 'D3DDevice_SetRenderTarget'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064BF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064BF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064BF8);
		  /* 82064BF8h */ case    0:  		/* li R11, 1 */
		/* 82064BF8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82064BF8h case    0:*/		return 0x82064BFC;
		  /* 82064BFCh */ case    1:  		/* b 8 */
		/* 82064BFCh case    1:*/		return 0x82064C04;
		/* 82064BFCh case    1:*/		return 0x82064C00;
	}
	return 0x82064C00;
} // Block from 82064BF8h-82064C00h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82064C00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064C00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064C00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064C00);
		  /* 82064C00h */ case    0:  		/* li R11, 0 */
		/* 82064C00h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82064C00h case    0:*/		return 0x82064C04;
	}
	return 0x82064C04;
} // Block from 82064C00h-82064C04h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82064C04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064C04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064C04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064C04);
		  /* 82064C04h */ case    0:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 82064C04h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82064C04h case    0:*/		return 0x82064C08;
	}
	return 0x82064C08;
} // Block from 82064C04h-82064C08h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82064C08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064C08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064C08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064C08);
		  /* 82064C08h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82064C08h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82064C08h case    0:*/		return 0x82064C0C;
		  /* 82064C0Ch */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 82064C0Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82064C1C;  }
		/* 82064C0Ch case    1:*/		return 0x82064C10;
		  /* 82064C10h */ case    2:  		/* lwz R11, <#[R31 + 13556]> */
		/* 82064C10h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000034F4) );
		/* 82064C10h case    2:*/		return 0x82064C14;
		  /* 82064C14h */ case    3:  		/* lwz R7, <#[R31 + 13560]> */
		/* 82064C14h case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x000034F8) );
		/* 82064C14h case    3:*/		return 0x82064C18;
		  /* 82064C18h */ case    4:  		/* b 24 */
		/* 82064C18h case    4:*/		return 0x82064C30;
		/* 82064C18h case    4:*/		return 0x82064C1C;
	}
	return 0x82064C1C;
} // Block from 82064C08h-82064C1Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82064C1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064C1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064C1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064C1C);
		  /* 82064C1Ch */ case    0:  		/* lwz R10, <#[R9 + 36]> */
		/* 82064C1Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000024) );
		/* 82064C1Ch case    0:*/		return 0x82064C20;
		  /* 82064C20h */ case    1:  		/* rlwinm R11, R10, 14, 18, 31 */
		/* 82064C20h case    1:*/		cpu::op::rlwinm<0,14,18,31>(regs,&regs.R11,regs.R10);
		/* 82064C20h case    1:*/		return 0x82064C24;
		  /* 82064C24h */ case    2:  		/* rlwinm R10, R10, 29, 17, 31 */
		/* 82064C24h case    2:*/		cpu::op::rlwinm<0,29,17,31>(regs,&regs.R10,regs.R10);
		/* 82064C24h case    2:*/		return 0x82064C28;
		  /* 82064C28h */ case    3:  		/* addi R11, R11, 1 */
		/* 82064C28h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82064C28h case    3:*/		return 0x82064C2C;
		  /* 82064C2Ch */ case    4:  		/* addi R7, R10, 1 */
		/* 82064C2Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0x1);
		/* 82064C2Ch case    4:*/		return 0x82064C30;
	}
	return 0x82064C30;
} // Block from 82064C1Ch-82064C30h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82064C30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064C30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064C30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064C30);
		  /* 82064C30h */ case    0:  		/* fctiwz FR0, FR31 */
		/* 82064C30h case    0:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR31);
		/* 82064C30h case    0:*/		return 0x82064C34;
		  /* 82064C34h */ case    1:  		/* stfd FR0, <#[R1 + 80]> */
		/* 82064C34h case    1:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 82064C34h case    1:*/		return 0x82064C38;
		  /* 82064C38h */ case    2:  		/* fctiwz FR0, FR3 */
		/* 82064C38h case    2:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR3);
		/* 82064C38h case    2:*/		return 0x82064C3C;
		  /* 82064C3Ch */ case    3:  		/* stfd FR0, <#[R1 + 88]> */
		/* 82064C3Ch case    3:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 82064C3Ch case    3:*/		return 0x82064C40;
		  /* 82064C40h */ case    4:  		/* lwz R10, <#[R1 + 92]> */
		/* 82064C40h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000005C) );
		/* 82064C40h case    4:*/		return 0x82064C44;
		  /* 82064C44h */ case    5:  		/* fctiwz FR0, FR30 */
		/* 82064C44h case    5:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR30);
		/* 82064C44h case    5:*/		return 0x82064C48;
		  /* 82064C48h */ case    6:  		/* lwz R6, <#[R1 + 84]> */
		/* 82064C48h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000054) );
		/* 82064C48h case    6:*/		return 0x82064C4C;
		  /* 82064C4Ch */ case    7:  		/* add R10, R10, R6 */
		/* 82064C4Ch case    7:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R6);
		/* 82064C4Ch case    7:*/		return 0x82064C50;
		  /* 82064C50h */ case    8:  		/* stfd FR0, <#[R1 + 88]> */
		/* 82064C50h case    8:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 82064C50h case    8:*/		return 0x82064C54;
		  /* 82064C54h */ case    9:  		/* lwz R8, <#[R1 + 92]> */
		/* 82064C54h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x0000005C) );
		/* 82064C54h case    9:*/		return 0x82064C58;
		  /* 82064C58h */ case   10:  		/* cmpw CR6, R10, R11 */
		/* 82064C58h case   10:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R11);
		/* 82064C58h case   10:*/		return 0x82064C5C;
		  /* 82064C5Ch */ case   11:  		/* bc 4, CR6_LT, 8 */
		/* 82064C5Ch case   11:*/		if ( !regs.CR[6].lt ) { return 0x82064C64;  }
		/* 82064C5Ch case   11:*/		return 0x82064C60;
		  /* 82064C60h */ case   12:  		/* mr R11, R10 */
		/* 82064C60h case   12:*/		regs.R11 = regs.R10;
		/* 82064C60h case   12:*/		return 0x82064C64;
	}
	return 0x82064C64;
} // Block from 82064C30h-82064C64h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82064C64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064C64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064C64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064C64);
		  /* 82064C64h */ case    0:  		/* fctiwz FR0, FR4 */
		/* 82064C64h case    0:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR4);
		/* 82064C64h case    0:*/		return 0x82064C68;
		  /* 82064C68h */ case    1:  		/* stfd FR0, <#[R1 + 88]> */
		/* 82064C68h case    1:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 82064C68h case    1:*/		return 0x82064C6C;
		  /* 82064C6Ch */ case    2:  		/* lwz R9, <#[R1 + 92]> */
		/* 82064C6Ch case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x0000005C) );
		/* 82064C6Ch case    2:*/		return 0x82064C70;
		  /* 82064C70h */ case    3:  		/* add R9, R9, R8 */
		/* 82064C70h case    3:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 82064C70h case    3:*/		return 0x82064C74;
		  /* 82064C74h */ case    4:  		/* cmpw CR6, R9, R7 */
		/* 82064C74h case    4:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R7);
		/* 82064C74h case    4:*/		return 0x82064C78;
		  /* 82064C78h */ case    5:  		/* bc 12, CR6_LT, 8 */
		/* 82064C78h case    5:*/		if ( regs.CR[6].lt ) { return 0x82064C80;  }
		/* 82064C78h case    5:*/		return 0x82064C7C;
		  /* 82064C7Ch */ case    6:  		/* mr R9, R7 */
		/* 82064C7Ch case    6:*/		regs.R9 = regs.R7;
		/* 82064C7Ch case    6:*/		return 0x82064C80;
	}
	return 0x82064C80;
} // Block from 82064C64h-82064C80h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82064C80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064C80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064C80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064C80);
		  /* 82064C80h */ case    0:  		/* subf. R11, R6, R11 */
		/* 82064C80h case    0:*/		cpu::op::subf<1>(regs,&regs.R11,regs.R6,regs.R11);
		/* 82064C80h case    0:*/		return 0x82064C84;
		  /* 82064C84h */ case    1:  		/* subf R10, R8, R9 */
		/* 82064C84h case    1:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R8,regs.R9);
		/* 82064C84h case    1:*/		return 0x82064C88;
		  /* 82064C88h */ case    2:  		/* bc 12, CR0_LT, 12 */
		/* 82064C88h case    2:*/		if ( regs.CR[0].lt ) { return 0x82064C94;  }
		/* 82064C88h case    2:*/		return 0x82064C8C;
		  /* 82064C8Ch */ case    3:  		/* cmpwi CR6, R10, 0 */
		/* 82064C8Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 82064C8Ch case    3:*/		return 0x82064C90;
		  /* 82064C90h */ case    4:  		/* bc 4, CR6_LT, 12 */
		/* 82064C90h case    4:*/		if ( !regs.CR[6].lt ) { return 0x82064C9C;  }
		/* 82064C90h case    4:*/		return 0x82064C94;
	}
	return 0x82064C94;
} // Block from 82064C80h-82064C94h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82064C94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064C94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064C94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064C94);
		  /* 82064C94h */ case    0:  		/* li R11, 0 */
		/* 82064C94h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82064C94h case    0:*/		return 0x82064C98;
		  /* 82064C98h */ case    1:  		/* li R10, 0 */
		/* 82064C98h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82064C98h case    1:*/		return 0x82064C9C;
	}
	return 0x82064C9C;
} // Block from 82064C94h-82064C9Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82064C9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064C9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064C9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064C9C);
		  /* 82064C9Ch */ case    0:  		/* extsw R11, R11 */
		/* 82064C9Ch case    0:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R11);
		/* 82064C9Ch case    0:*/		return 0x82064CA0;
		  /* 82064CA0h */ case    1:  		/* stfs FR31, <#[R31 + 13024]> */
		/* 82064CA0h case    1:*/		cpu::mem::store32f( regs, regs.FR31, (uint32)(regs.R31 + 0x000032E0) );
		/* 82064CA0h case    1:*/		return 0x82064CA4;
		  /* 82064CA4h */ case    2:  		/* extsw R10, R10 */
		/* 82064CA4h case    2:*/		cpu::op::extsw<0>(regs,&regs.R10,regs.R10);
		/* 82064CA4h case    2:*/		return 0x82064CA8;
		  /* 82064CA8h */ case    3:  		/* stfs FR30, <#[R31 + 13028]> */
		/* 82064CA8h case    3:*/		cpu::mem::store32f( regs, regs.FR30, (uint32)(regs.R31 + 0x000032E4) );
		/* 82064CA8h case    3:*/		return 0x82064CAC;
		  /* 82064CACh */ case    4:  		/* std R11, <#[R1 + 80]> */
		/* 82064CACh case    4:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82064CACh case    4:*/		return 0x82064CB0;
		  /* 82064CB0h */ case    5:  		/* lfd FR13, <#[R1 + 80]> */
		/* 82064CB0h case    5:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000050) );
		/* 82064CB0h case    5:*/		return 0x82064CB4;
		  /* 82064CB4h */ case    6:  		/* std R10, <#[R1 + 88]> */
		/* 82064CB4h case    6:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 82064CB4h case    6:*/		return 0x82064CB8;
		  /* 82064CB8h */ case    7:  		/* lfd FR0, <#[R1 + 88]> */
		/* 82064CB8h case    7:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 82064CB8h case    7:*/		return 0x82064CBC;
		  /* 82064CBCh */ case    8:  		/* fcfid FR0, FR0 */
		/* 82064CBCh case    8:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 82064CBCh case    8:*/		return 0x82064CC0;
		  /* 82064CC0h */ case    9:  		/* li R11, 0 */
		/* 82064CC0h case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82064CC0h case    9:*/		return 0x82064CC4;
		  /* 82064CC4h */ case   10:  		/* frsp FR27, FR0 */
		/* 82064CC4h case   10:*/		cpu::op::frsp<0>(regs,&regs.FR27,regs.FR0);
		/* 82064CC4h case   10:*/		return 0x82064CC8;
		  /* 82064CC8h */ case   11:  		/* stfs FR29, <#[R31 + 13040]> */
		/* 82064CC8h case   11:*/		cpu::mem::store32f( regs, regs.FR29, (uint32)(regs.R31 + 0x000032F0) );
		/* 82064CC8h case   11:*/		return 0x82064CCC;
		  /* 82064CCCh */ case   12:  		/* fcfid FR0, FR13 */
		/* 82064CCCh case   12:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR13);
		/* 82064CCCh case   12:*/		return 0x82064CD0;
		  /* 82064CD0h */ case   13:  		/* stfs FR28, <#[R31 + 13044]> */
		/* 82064CD0h case   13:*/		cpu::mem::store32f( regs, regs.FR28, (uint32)(regs.R31 + 0x000032F4) );
		/* 82064CD0h case   13:*/		return 0x82064CD4;
		  /* 82064CD4h */ case   14:  		/* stfs FR27, <#[R31 + 13036]> */
		/* 82064CD4h case   14:*/		cpu::mem::store32f( regs, regs.FR27, (uint32)(regs.R31 + 0x000032EC) );
		/* 82064CD4h case   14:*/		return 0x82064CD8;
		  /* 82064CD8h */ case   15:  		/* stw R11, <#[R31 + 13048]> */
		/* 82064CD8h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000032F8) );
		/* 82064CD8h case   15:*/		return 0x82064CDC;
		  /* 82064CDCh */ case   16:  		/* addi R4, R31, 13052 */
		/* 82064CDCh case   16:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0x32FC);
		/* 82064CDCh case   16:*/		return 0x82064CE0;
		  /* 82064CE0h */ case   17:  		/* mr R3, R31 */
		/* 82064CE0h case   17:*/		regs.R3 = regs.R31;
		/* 82064CE0h case   17:*/		return 0x82064CE4;
		  /* 82064CE4h */ case   18:  		/* frsp FR26, FR0 */
		/* 82064CE4h case   18:*/		cpu::op::frsp<0>(regs,&regs.FR26,regs.FR0);
		/* 82064CE4h case   18:*/		return 0x82064CE8;
		  /* 82064CE8h */ case   19:  		/* stfs FR26, <#[R31 + 13032]> */
		/* 82064CE8h case   19:*/		cpu::mem::store32f( regs, regs.FR26, (uint32)(regs.R31 + 0x000032E8) );
		/* 82064CE8h case   19:*/		return 0x82064CEC;
		  /* 82064CECh */ case   20:  		/* bl -1940 */
		/* 82064CECh case   20:*/		regs.LR = 0x82064CF0; return 0x82064558;
		/* 82064CECh case   20:*/		return 0x82064CF0;
		  /* 82064CF0h */ case   21:  		/* lis R11, -32256 */
		/* 82064CF0h case   21:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82064CF0h case   21:*/		return 0x82064CF4;
		  /* 82064CF4h */ case   22:  		/* fsubs FR0, FR28, FR29 */
		/* 82064CF4h case   22:*/		cpu::op::fsubs<0>(regs,&regs.FR0,regs.FR28,regs.FR29);
		/* 82064CF4h case   22:*/		return 0x82064CF8;
		  /* 82064CF8h */ case   23:  		/* stfs FR0, <#[R31 + 10520]> */
		/* 82064CF8h case   23:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R31 + 0x00002918) );
		/* 82064CF8h case   23:*/		return 0x82064CFC;
		  /* 82064CFCh */ case   24:  		/* stfs FR29, <#[R31 + 10524]> */
		/* 82064CFCh case   24:*/		cpu::mem::store32f( regs, regs.FR29, (uint32)(regs.R31 + 0x0000291C) );
		/* 82064CFCh case   24:*/		return 0x82064D00;
		  /* 82064D00h */ case   25:  		/* lfs FR0, <#[R11 + 1820]> */
		/* 82064D00h case   25:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x0000071C) );
		/* 82064D00h case   25:*/		return 0x82064D04;
		  /* 82064D04h */ case   26:  		/* fmuls FR13, FR26, FR0 */
		/* 82064D04h case   26:*/		cpu::op::fmuls<0>(regs,&regs.FR13,regs.FR26,regs.FR0);
		/* 82064D04h case   26:*/		return 0x82064D08;
		  /* 82064D08h */ case   27:  		/* stfs FR13, <#[R31 + 10504]> */
		/* 82064D08h case   27:*/		cpu::mem::store32f( regs, regs.FR13, (uint32)(regs.R31 + 0x00002908) );
		/* 82064D08h case   27:*/		return 0x82064D0C;
		  /* 82064D0Ch */ case   28:  		/* fmuls FR0, FR27, FR0 */
		/* 82064D0Ch case   28:*/		cpu::op::fmuls<0>(regs,&regs.FR0,regs.FR27,regs.FR0);
		/* 82064D0Ch case   28:*/		return 0x82064D10;
		  /* 82064D10h */ case   29:  		/* fadds FR13, FR13, FR31 */
		/* 82064D10h case   29:*/		cpu::op::fadds<0>(regs,&regs.FR13,regs.FR13,regs.FR31);
		/* 82064D10h case   29:*/		return 0x82064D14;
		  /* 82064D14h */ case   30:  		/* stfs FR13, <#[R31 + 10508]> */
		/* 82064D14h case   30:*/		cpu::mem::store32f( regs, regs.FR13, (uint32)(regs.R31 + 0x0000290C) );
		/* 82064D14h case   30:*/		return 0x82064D18;
		  /* 82064D18h */ case   31:  		/* fneg FR13, FR0 */
		/* 82064D18h case   31:*/		cpu::op::fneg<0>(regs,&regs.FR13,regs.FR0);
		/* 82064D18h case   31:*/		return 0x82064D1C;
		  /* 82064D1Ch */ case   32:  		/* stfs FR13, <#[R31 + 10512]> */
		/* 82064D1Ch case   32:*/		cpu::mem::store32f( regs, regs.FR13, (uint32)(regs.R31 + 0x00002910) );
		/* 82064D1Ch case   32:*/		return 0x82064D20;
		  /* 82064D20h */ case   33:  		/* fadds FR0, FR0, FR30 */
		/* 82064D20h case   33:*/		cpu::op::fadds<0>(regs,&regs.FR0,regs.FR0,regs.FR30);
		/* 82064D20h case   33:*/		return 0x82064D24;
		  /* 82064D24h */ case   34:  		/* stfs FR0, <#[R31 + 10516]> */
		/* 82064D24h case   34:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R31 + 0x00002914) );
		/* 82064D24h case   34:*/		return 0x82064D28;
		  /* 82064D28h */ case   35:  		/* ld R11, <#[R31 + 16]> */
		/* 82064D28h case   35:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82064D28h case   35:*/		return 0x82064D2C;
		  /* 82064D2Ch */ case   36:  		/* oris R11, R11, 1024 */
		/* 82064D2Ch case   36:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x400);
		/* 82064D2Ch case   36:*/		return 0x82064D30;
		  /* 82064D30h */ case   37:  		/* std R11, <#[R31 + 16]> */
		/* 82064D30h case   37:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82064D30h case   37:*/		return 0x82064D34;
		  /* 82064D34h */ case   38:  		/* oris R11, R11, 512 */
		/* 82064D34h case   38:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x200);
		/* 82064D34h case   38:*/		return 0x82064D38;
		  /* 82064D38h */ case   39:  		/* std R11, <#[R31 + 16]> */
		/* 82064D38h case   39:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82064D38h case   39:*/		return 0x82064D3C;
		  /* 82064D3Ch */ case   40:  		/* oris R11, R11, 256 */
		/* 82064D3Ch case   40:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x100);
		/* 82064D3Ch case   40:*/		return 0x82064D40;
		  /* 82064D40h */ case   41:  		/* std R11, <#[R31 + 16]> */
		/* 82064D40h case   41:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82064D40h case   41:*/		return 0x82064D44;
		  /* 82064D44h */ case   42:  		/* oris R11, R11, 128 */
		/* 82064D44h case   42:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x80);
		/* 82064D44h case   42:*/		return 0x82064D48;
		  /* 82064D48h */ case   43:  		/* std R11, <#[R31 + 16]> */
		/* 82064D48h case   43:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82064D48h case   43:*/		return 0x82064D4C;
		  /* 82064D4Ch */ case   44:  		/* oris R11, R11, 64 */
		/* 82064D4Ch case   44:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x40);
		/* 82064D4Ch case   44:*/		return 0x82064D50;
		  /* 82064D50h */ case   45:  		/* std R11, <#[R31 + 16]> */
		/* 82064D50h case   45:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82064D50h case   45:*/		return 0x82064D54;
		  /* 82064D54h */ case   46:  		/* oris R11, R11, 32 */
		/* 82064D54h case   46:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x20);
		/* 82064D54h case   46:*/		return 0x82064D58;
		  /* 82064D58h */ case   47:  		/* std R11, <#[R31 + 16]> */
		/* 82064D58h case   47:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82064D58h case   47:*/		return 0x82064D5C;
	}
	return 0x82064D5C;
} // Block from 82064C9Ch-82064D5Ch (48 instructions)

//////////////////////////////////////////////////////
// Block at 82064D5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064D5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064D5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064D5C);
		  /* 82064D5Ch */ case    0:  		/* addi R1, R1, 160 */
		/* 82064D5Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 82064D5Ch case    0:*/		return 0x82064D60;
		  /* 82064D60h */ case    1:  		/* addi R12, R1, -16 */
		/* 82064D60h case    1:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R1,0xFFFFFFF0);
		/* 82064D60h case    1:*/		return 0x82064D64;
		  /* 82064D64h */ case    2:  		/* bl 182008 */
		/* 82064D64h case    2:*/		regs.LR = 0x82064D68; return 0x8209145C;
		/* 82064D64h case    2:*/		return 0x82064D68;
		  /* 82064D68h */ case    3:  		/* lwz R12, <#[R1 - 8]> */
		/* 82064D68h case    3:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82064D68h case    3:*/		return 0x82064D6C;
		  /* 82064D6Ch */ case    4:  		/* mtspr LR, R12 */
		/* 82064D6Ch case    4:*/		regs.LR = regs.R12;
		/* 82064D6Ch case    4:*/		return 0x82064D70;
		  /* 82064D70h */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 82064D70h case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82064D70h case    5:*/		return 0x82064D74;
		  /* 82064D74h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82064D74h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82064D74h case    6:*/		return 0x82064D78;
	}
	return 0x82064D78;
} // Block from 82064D5Ch-82064D78h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82064D78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064D78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064D78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064D78);
		  /* 82064D78h */ case    0:  		/* stw R4, <#[R3 + 12288]> */
		/* 82064D78h case    0:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00003000) );
		/* 82064D78h case    0:*/		return 0x82064D7C;
		  /* 82064D7Ch */ case    1:  		/* addi R4, R3, 13052 */
		/* 82064D7Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R3,0x32FC);
		/* 82064D7Ch case    1:*/		return 0x82064D80;
		  /* 82064D80h */ case    2:  		/* b -2088 */
		/* 82064D80h case    2:*/		return 0x82064558;
		/* 82064D80h case    2:*/		return 0x82064D84;
		  /* 82064D84h */ case    3:  		/* nop */
		/* 82064D84h case    3:*/		cpu::op::nop();
		/* 82064D84h case    3:*/		return 0x82064D88;
	}
	return 0x82064D88;
} // Block from 82064D78h-82064D88h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82064D88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064D88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064D88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064D88);
		  /* 82064D88h */ case    0:  		/* mfspr R12, LR */
		/* 82064D88h case    0:*/		regs.R12 = regs.LR;
		/* 82064D88h case    0:*/		return 0x82064D8C;
		  /* 82064D8Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82064D8Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82064D8Ch case    1:*/		return 0x82064D90;
		  /* 82064D90h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82064D90h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82064D90h case    2:*/		return 0x82064D94;
		  /* 82064D94h */ case    3:  		/* lwz R9, <#[R4 + 12]> */
		/* 82064D94h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x0000000C) );
		/* 82064D94h case    3:*/		return 0x82064D98;
		  /* 82064D98h */ case    4:  		/* li R10, 0 */
		/* 82064D98h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82064D98h case    4:*/		return 0x82064D9C;
		  /* 82064D9Ch */ case    5:  		/* lwz R11, <#[R4]> */
		/* 82064D9Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 82064D9Ch case    5:*/		return 0x82064DA0;
		  /* 82064DA0h */ case    6:  		/* lfs FR6, <#[R4 + 20]> */
		/* 82064DA0h case    6:*/		cpu::mem::load32f( regs, &regs.FR6, (uint32)(regs.R4 + 0x00000014) );
		/* 82064DA0h case    6:*/		return 0x82064DA4;
		  /* 82064DA4h */ case    7:  		/* lwz R7, <#[R4 + 4]> */
		/* 82064DA4h case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R4 + 0x00000004) );
		/* 82064DA4h case    7:*/		return 0x82064DA8;
		  /* 82064DA8h */ case    8:  		/* lfs FR5, <#[R4 + 16]> */
		/* 82064DA8h case    8:*/		cpu::mem::load32f( regs, &regs.FR5, (uint32)(regs.R4 + 0x00000010) );
		/* 82064DA8h case    8:*/		return 0x82064DAC;
		  /* 82064DACh */ case    9:  		/* lwz R8, <#[R4 + 8]> */
		/* 82064DACh case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R4 + 0x00000008) );
		/* 82064DACh case    9:*/		return 0x82064DB0;
		  /* 82064DB0h */ case   10:  		/* std R9, <#[R1 + 88]> */
		/* 82064DB0h case   10:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000058) );
		/* 82064DB0h case   10:*/		return 0x82064DB4;
		  /* 82064DB4h */ case   11:  		/* lfd FR13, <#[R1 + 88]> */
		/* 82064DB4h case   11:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000058) );
		/* 82064DB4h case   11:*/		return 0x82064DB8;
		  /* 82064DB8h */ case   12:  		/* std R11, <#[R1 + 80]> */
		/* 82064DB8h case   12:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82064DB8h case   12:*/		return 0x82064DBC;
		  /* 82064DBCh */ case   13:  		/* lfd FR0, <#[R1 + 80]> */
		/* 82064DBCh case   13:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 82064DBCh case   13:*/		return 0x82064DC0;
		  /* 82064DC0h */ case   14:  		/* std R7, <#[R1 + 88]> */
		/* 82064DC0h case   14:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R1 + 0x00000058) );
		/* 82064DC0h case   14:*/		return 0x82064DC4;
		  /* 82064DC4h */ case   15:  		/* lfd FR11, <#[R1 + 88]> */
		/* 82064DC4h case   15:*/		cpu::mem::load64f( regs, &regs.FR11, (uint32)(regs.R1 + 0x00000058) );
		/* 82064DC4h case   15:*/		return 0x82064DC8;
		  /* 82064DC8h */ case   16:  		/* std R8, <#[R1 + 80]> */
		/* 82064DC8h case   16:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R1 + 0x00000050) );
		/* 82064DC8h case   16:*/		return 0x82064DCC;
		  /* 82064DCCh */ case   17:  		/* lfd FR12, <#[R1 + 80]> */
		/* 82064DCCh case   17:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R1 + 0x00000050) );
		/* 82064DCCh case   17:*/		return 0x82064DD0;
		  /* 82064DD0h */ case   18:  		/* fcfid FR11, FR11 */
		/* 82064DD0h case   18:*/		cpu::op::fcfid<0>(regs,&regs.FR11,regs.FR11);
		/* 82064DD0h case   18:*/		return 0x82064DD4;
		  /* 82064DD4h */ case   19:  		/* mr R11, R7 */
		/* 82064DD4h case   19:*/		regs.R11 = regs.R7;
		/* 82064DD4h case   19:*/		return 0x82064DD8;
		  /* 82064DD8h */ case   20:  		/* fcfid FR12, FR12 */
		/* 82064DD8h case   20:*/		cpu::op::fcfid<0>(regs,&regs.FR12,regs.FR12);
		/* 82064DD8h case   20:*/		return 0x82064DDC;
		  /* 82064DDCh */ case   21:  		/* fcfid FR13, FR13 */
		/* 82064DDCh case   21:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 82064DDCh case   21:*/		return 0x82064DE0;
		  /* 82064DE0h */ case   22:  		/* fcfid FR0, FR0 */
		/* 82064DE0h case   22:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 82064DE0h case   22:*/		return 0x82064DE4;
		  /* 82064DE4h */ case   23:  		/* frsp FR2, FR11 */
		/* 82064DE4h case   23:*/		cpu::op::frsp<0>(regs,&regs.FR2,regs.FR11);
		/* 82064DE4h case   23:*/		return 0x82064DE8;
		  /* 82064DE8h */ case   24:  		/* frsp FR3, FR12 */
		/* 82064DE8h case   24:*/		cpu::op::frsp<0>(regs,&regs.FR3,regs.FR12);
		/* 82064DE8h case   24:*/		return 0x82064DEC;
		  /* 82064DECh */ case   25:  		/* frsp FR4, FR13 */
		/* 82064DECh case   25:*/		cpu::op::frsp<0>(regs,&regs.FR4,regs.FR13);
		/* 82064DECh case   25:*/		return 0x82064DF0;
		  /* 82064DF0h */ case   26:  		/* frsp FR1, FR0 */
		/* 82064DF0h case   26:*/		cpu::op::frsp<0>(regs,&regs.FR1,regs.FR0);
		/* 82064DF0h case   26:*/		return 0x82064DF4;
		  /* 82064DF4h */ case   27:  		/* bl -724 */
		/* 82064DF4h case   27:*/		regs.LR = 0x82064DF8; return 0x82064B20;
		/* 82064DF4h case   27:*/		return 0x82064DF8;
		  /* 82064DF8h */ case   28:  		/* addi R1, R1, 112 */
		/* 82064DF8h case   28:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82064DF8h case   28:*/		return 0x82064DFC;
		  /* 82064DFCh */ case   29:  		/* lwz R12, <#[R1 - 8]> */
		/* 82064DFCh case   29:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82064DFCh case   29:*/		return 0x82064E00;
		  /* 82064E00h */ case   30:  		/* mtspr LR, R12 */
		/* 82064E00h case   30:*/		regs.LR = regs.R12;
		/* 82064E00h case   30:*/		return 0x82064E04;
		  /* 82064E04h */ case   31:  		/* bclr 20, CR0_LT */
		/* 82064E04h case   31:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82064E04h case   31:*/		return 0x82064E08;
	}
	return 0x82064E08;
} // Block from 82064D88h-82064E08h (32 instructions)

//////////////////////////////////////////////////////
// Block at 82064E08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064E08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064E08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064E08);
		  /* 82064E08h */ case    0:  		/* lwz R10, <#[R4 + 24]> */
		/* 82064E08h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000018) );
		/* 82064E08h case    0:*/		return 0x82064E0C;
		  /* 82064E0Ch */ case    1:  		/* lfs FR6, <#[R4 + 20]> */
		/* 82064E0Ch case    1:*/		cpu::mem::load32f( regs, &regs.FR6, (uint32)(regs.R4 + 0x00000014) );
		/* 82064E0Ch case    1:*/		return 0x82064E10;
		  /* 82064E10h */ case    2:  		/* lfs FR5, <#[R4 + 16]> */
		/* 82064E10h case    2:*/		cpu::mem::load32f( regs, &regs.FR5, (uint32)(regs.R4 + 0x00000010) );
		/* 82064E10h case    2:*/		return 0x82064E14;
		  /* 82064E14h */ case    3:  		/* lfs FR4, <#[R4 + 12]> */
		/* 82064E14h case    3:*/		cpu::mem::load32f( regs, &regs.FR4, (uint32)(regs.R4 + 0x0000000C) );
		/* 82064E14h case    3:*/		return 0x82064E18;
		  /* 82064E18h */ case    4:  		/* lfs FR3, <#[R4 + 8]> */
		/* 82064E18h case    4:*/		cpu::mem::load32f( regs, &regs.FR3, (uint32)(regs.R4 + 0x00000008) );
		/* 82064E18h case    4:*/		return 0x82064E1C;
		  /* 82064E1Ch */ case    5:  		/* lfs FR2, <#[R4 + 4]> */
		/* 82064E1Ch case    5:*/		cpu::mem::load32f( regs, &regs.FR2, (uint32)(regs.R4 + 0x00000004) );
		/* 82064E1Ch case    5:*/		return 0x82064E20;
		  /* 82064E20h */ case    6:  		/* lfs FR1, <#[R4]> */
		/* 82064E20h case    6:*/		cpu::mem::load32f( regs, &regs.FR1, (uint32)(regs.R4 + 0x00000000) );
		/* 82064E20h case    6:*/		return 0x82064E24;
		  /* 82064E24h */ case    7:  		/* b -772 */
		/* 82064E24h case    7:*/		return 0x82064B20;
		/* 82064E24h case    7:*/		return 0x82064E28;
		  /* 82064E28h */ case    8:  		/* lwz R10, <#[R4 + 24]> */
		/* 82064E28h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000018) );
		/* 82064E28h case    8:*/		return 0x82064E2C;
		  /* 82064E2Ch */ case    9:  		/* rlwinm. R11, R10, 16, 30, 31 */
		/* 82064E2Ch case    9:*/		cpu::op::rlwinm<1,16,30,31>(regs,&regs.R11,regs.R10);
		/* 82064E2Ch case    9:*/		return 0x82064E30;
		  /* 82064E30h */ case   10:  		/* bc 4, CR0_EQ, 12 */
		/* 82064E30h case   10:*/		if ( !regs.CR[0].eq ) { return 0x82064E3C;  }
		/* 82064E30h case   10:*/		return 0x82064E34;
		  /* 82064E34h */ case   11:  		/* li R11, 0 */
		/* 82064E34h case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82064E34h case   11:*/		return 0x82064E38;
		  /* 82064E38h */ case   12:  		/* b 28 */
		/* 82064E38h case   12:*/		return 0x82064E54;
		/* 82064E38h case   12:*/		return 0x82064E3C;
	}
	return 0x82064E3C;
} // Block from 82064E08h-82064E3Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 82064E3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064E3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064E3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064E3C);
		  /* 82064E3Ch */ case    0:  		/* cmplwi CR6, R11, 1 */
		/* 82064E3Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82064E3Ch case    0:*/		return 0x82064E40;
		  /* 82064E40h */ case    1:  		/* lis R11, 0 */
		/* 82064E40h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0x0);
		/* 82064E40h case    1:*/		return 0x82064E44;
		  /* 82064E44h */ case    2:  		/* bc 4, CR6_EQ, 12 */
		/* 82064E44h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82064E50;  }
		/* 82064E44h case    2:*/		return 0x82064E48;
		  /* 82064E48h */ case    3:  		/* ori R11, R11, 32769 */
		/* 82064E48h case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x8001);
		/* 82064E48h case    3:*/		return 0x82064E4C;
		  /* 82064E4Ch */ case    4:  		/* b 8 */
		/* 82064E4Ch case    4:*/		return 0x82064E54;
		/* 82064E4Ch case    4:*/		return 0x82064E50;
	}
	return 0x82064E50;
} // Block from 82064E3Ch-82064E50h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82064E50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064E50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064E50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064E50);
		  /* 82064E50h */ case    0:  		/* ori R11, R11, 49155 */
		/* 82064E50h case    0:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xC003);
		/* 82064E50h case    0:*/		return 0x82064E54;
	}
	return 0x82064E54;
} // Block from 82064E50h-82064E54h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82064E54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064E54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064E54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064E54);
		  /* 82064E54h */ case    0:  		/* li R12, 1 */
		/* 82064E54h case    0:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 82064E54h case    0:*/		return 0x82064E58;
		  /* 82064E58h */ case    1:  		/* stw R11, <#[R3 + 10684]> */
		/* 82064E58h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x000029BC) );
		/* 82064E58h case    1:*/		return 0x82064E5C;
		  /* 82064E5Ch */ case    2:  		/* stw R10, <#[R3 + 10368]> */
		/* 82064E5Ch case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00002880) );
		/* 82064E5Ch case    2:*/		return 0x82064E60;
		  /* 82064E60h */ case    3:  		/* lis R11, -32256 */
		/* 82064E60h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82064E60h case    3:*/		return 0x82064E64;
		  /* 82064E64h */ case    4:  		/* rldicr R12, R12, 57, 63 */
		/* 82064E64h case    4:*/		cpu::op::rldicr<0,57,63>(regs,&regs.R12,regs.R12);
		/* 82064E64h case    4:*/		return 0x82064E68;
		  /* 82064E68h */ case    5:  		/* ld R9, <#[R3 + 16]> */
		/* 82064E68h case    5:*/		cpu::mem::load64( regs, &regs.R9, (uint32)(regs.R3 + 0x00000010) );
		/* 82064E68h case    5:*/		return 0x82064E6C;
		  /* 82064E6Ch */ case    6:  		/* lis R10, -32256 */
		/* 82064E6Ch case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82064E6Ch case    6:*/		return 0x82064E70;
		  /* 82064E70h */ case    7:  		/* or R9, R9, R12 */
		/* 82064E70h case    7:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R12);
		/* 82064E70h case    7:*/		return 0x82064E74;
		  /* 82064E74h */ case    8:  		/* std R9, <#[R3 + 16]> */
		/* 82064E74h case    8:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R3 + 0x00000010) );
		/* 82064E74h case    8:*/		return 0x82064E78;
		  /* 82064E78h */ case    9:  		/* li R12, 1 */
		/* 82064E78h case    9:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 82064E78h case    9:*/		return 0x82064E7C;
		  /* 82064E7Ch */ case   10:  		/* ld R8, <#[R3 + 32]> */
		/* 82064E7Ch case   10:*/		cpu::mem::load64( regs, &regs.R8, (uint32)(regs.R3 + 0x00000020) );
		/* 82064E7Ch case   10:*/		return 0x82064E80;
		  /* 82064E80h */ case   11:  		/* addi R9, R11, 2876 */
		/* 82064E80h case   11:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xB3C);
		/* 82064E80h case   11:*/		return 0x82064E84;
		  /* 82064E84h */ case   12:  		/* rldicr R12, R12, 36, 63 */
		/* 82064E84h case   12:*/		cpu::op::rldicr<0,36,63>(regs,&regs.R12,regs.R12);
		/* 82064E84h case   12:*/		return 0x82064E88;
		  /* 82064E88h */ case   13:  		/* addi R4, R10, 2852 */
		/* 82064E88h case   13:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0xB24);
		/* 82064E88h case   13:*/		return 0x82064E8C;
		  /* 82064E8Ch */ case   14:  		/* or R8, R8, R12 */
		/* 82064E8Ch case   14:*/		cpu::op::or<0>(regs,&regs.R8,regs.R8,regs.R12);
		/* 82064E8Ch case   14:*/		return 0x82064E90;
		  /* 82064E90h */ case   15:  		/* std R8, <#[R3 + 32]> */
		/* 82064E90h case   15:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R3 + 0x00000020) );
		/* 82064E90h case   15:*/		return 0x82064E94;
		  /* 82064E94h */ case   16:  		/* lwz R11, <#[R11 + 2876]> */
		/* 82064E94h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000B3C) );
		/* 82064E94h case   16:*/		return 0x82064E98;
		  /* 82064E98h */ case   17:  		/* stw R11, <#[R3 + 13052]> */
		/* 82064E98h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x000032FC) );
		/* 82064E98h case   17:*/		return 0x82064E9C;
		  /* 82064E9Ch */ case   18:  		/* lwz R11, <#[R9 + 4]> */
		/* 82064E9Ch case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 82064E9Ch case   18:*/		return 0x82064EA0;
		  /* 82064EA0h */ case   19:  		/* stw R11, <#[R3 + 13056]> */
		/* 82064EA0h case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00003300) );
		/* 82064EA0h case   19:*/		return 0x82064EA4;
		  /* 82064EA4h */ case   20:  		/* lwz R11, <#[R9 + 8]> */
		/* 82064EA4h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000008) );
		/* 82064EA4h case   20:*/		return 0x82064EA8;
		  /* 82064EA8h */ case   21:  		/* stw R11, <#[R3 + 13060]> */
		/* 82064EA8h case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00003304) );
		/* 82064EA8h case   21:*/		return 0x82064EAC;
		  /* 82064EACh */ case   22:  		/* lwz R11, <#[R9 + 12]> */
		/* 82064EACh case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x0000000C) );
		/* 82064EACh case   22:*/		return 0x82064EB0;
		  /* 82064EB0h */ case   23:  		/* stw R11, <#[R3 + 13064]> */
		/* 82064EB0h case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00003308) );
		/* 82064EB0h case   23:*/		return 0x82064EB4;
		  /* 82064EB4h */ case   24:  		/* b -300 */
		/* 82064EB4h case   24:*/		return 0x82064D88;
		/* 82064EB4h case   24:*/		return 0x82064EB8;
	}
	return 0x82064EB8;
} // Block from 82064E54h-82064EB8h (25 instructions)

//////////////////////////////////////////////////////
// Block at 82064EB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064EB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064EB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064EB8);
		  /* 82064EB8h */ case    0:  		/* mfspr R12, LR */
		/* 82064EB8h case    0:*/		regs.R12 = regs.LR;
		/* 82064EB8h case    0:*/		return 0x82064EBC;
		  /* 82064EBCh */ case    1:  		/* bl 181152 */
		/* 82064EBCh case    1:*/		regs.LR = 0x82064EC0; return 0x8209125C;
		/* 82064EBCh case    1:*/		return 0x82064EC0;
		  /* 82064EC0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82064EC0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82064EC0h case    2:*/		return 0x82064EC4;
		  /* 82064EC4h */ case    3:  		/* addi R11, R4, 3204 */
		/* 82064EC4h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0xC84);
		/* 82064EC4h case    3:*/		return 0x82064EC8;
		  /* 82064EC8h */ case    4:  		/* mr R31, R3 */
		/* 82064EC8h case    4:*/		regs.R31 = regs.R3;
		/* 82064EC8h case    4:*/		return 0x82064ECC;
		  /* 82064ECCh */ case    5:  		/* rlwinm R6, R11, 2, 0, 29 */
		/* 82064ECCh case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R6,regs.R11);
		/* 82064ECCh case    5:*/		return 0x82064ED0;
		  /* 82064ED0h */ case    6:  		/* cmplwi CR6, R5, 0 */
		/* 82064ED0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 82064ED0h case    6:*/		return 0x82064ED4;
		  /* 82064ED4h */ case    7:  		/* stwx R5, <#[R6 + R3]> */
		/* 82064ED4h case    7:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R6 + regs.R3 + 0x00000000) );
		/* 82064ED4h case    7:*/		return 0x82064ED8;
		  /* 82064ED8h */ case    8:  		/* bc 12, CR6_EQ, 272 */
		/* 82064ED8h case    8:*/		if ( regs.CR[6].eq ) { return 0x82064FE8;  }
		/* 82064ED8h case    8:*/		return 0x82064EDC;
		  /* 82064EDCh */ case    9:  		/* cmplwi CR6, R4, 0 */
		/* 82064EDCh case    9:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82064EDCh case    9:*/		return 0x82064EE0;
		  /* 82064EE0h */ case   10:  		/* li R11, 0 */
		/* 82064EE0h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82064EE0h case   10:*/		return 0x82064EE4;
		  /* 82064EE4h */ case   11:  		/* bc 12, CR6_EQ, 8 */
		/* 82064EE4h case   11:*/		if ( regs.CR[6].eq ) { return 0x82064EEC;  }
		/* 82064EE4h case   11:*/		return 0x82064EE8;
		  /* 82064EE8h */ case   12:  		/* addi R11, R4, 1 */
		/* 82064EE8h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x1);
		/* 82064EE8h case   12:*/		return 0x82064EEC;
	}
	return 0x82064EEC;
} // Block from 82064EB8h-82064EECh (13 instructions)

//////////////////////////////////////////////////////
// Block at 82064EECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064EEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064EEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064EEC);
		  /* 82064EECh */ case    0:  		/* addi R10, R11, 2593 */
		/* 82064EECh case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xA21);
		/* 82064EECh case    0:*/		return 0x82064EF0;
		  /* 82064EF0h */ case    1:  		/* lwz R7, <#[R5 + 28]> */
		/* 82064EF0h case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R5 + 0x0000001C) );
		/* 82064EF0h case    1:*/		return 0x82064EF4;
		  /* 82064EF4h */ case    2:  		/* lis R9, 2 */
		/* 82064EF4h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0x2);
		/* 82064EF4h case    2:*/		return 0x82064EF8;
		  /* 82064EF8h */ case    3:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82064EF8h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82064EF8h case    3:*/		return 0x82064EFC;
		  /* 82064EFCh */ case    4:  		/* ori R8, R9, 263 */
		/* 82064EFCh case    4:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R9,0x107);
		/* 82064EFCh case    4:*/		return 0x82064F00;
		  /* 82064F00h */ case    5:  		/* li R9, 1 */
		/* 82064F00h case    5:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82064F00h case    5:*/		return 0x82064F04;
		  /* 82064F04h */ case    6:  		/* add R3, R11, R8 */
		/* 82064F04h case    6:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R8);
		/* 82064F04h case    6:*/		return 0x82064F08;
		  /* 82064F08h */ case    7:  		/* rldicr R9, R9, 63, 63 */
		/* 82064F08h case    7:*/		cpu::op::rldicr<0,63,63>(regs,&regs.R9,regs.R9);
		/* 82064F08h case    7:*/		return 0x82064F0C;
		  /* 82064F0Ch */ case    8:  		/* stwx R7, <#[R10 + R31]> */
		/* 82064F0Ch case    8:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 82064F0Ch case    8:*/		return 0x82064F10;
		  /* 82064F10h */ case    9:  		/* srawi R11, R3, 16 */
		/* 82064F10h case    9:*/		cpu::op::srawi<0,16>(regs,&regs.R11,regs.R3);
		/* 82064F10h case    9:*/		return 0x82064F14;
		  /* 82064F14h */ case   10:  		/* rldicl R10, R3, 0, 56 */
		/* 82064F14h case   10:*/		cpu::op::rldicl<0,0,56>(regs,&regs.R10,regs.R3);
		/* 82064F14h case   10:*/		return 0x82064F18;
		  /* 82064F18h */ case   11:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 82064F18h case   11:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 82064F18h case   11:*/		return 0x82064F1C;
		  /* 82064F1Ch */ case   12:  		/* srd R7, R9, R10 */
		/* 82064F1Ch case   12:*/		cpu::op::srd<0>(regs,&regs.R7,regs.R9,regs.R10);
		/* 82064F1Ch case   12:*/		return 0x82064F20;
		  /* 82064F20h */ case   13:  		/* addi R10, R4, 3102 */
		/* 82064F20h case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0xC1E);
		/* 82064F20h case   13:*/		return 0x82064F24;
		  /* 82064F24h */ case   14:  		/* ldx R3, <#[R11 + R31]> */
		/* 82064F24h case   14:*/		cpu::mem::load64( regs, &regs.R3, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82064F24h case   14:*/		return 0x82064F28;
		  /* 82064F28h */ case   15:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82064F28h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82064F28h case   15:*/		return 0x82064F2C;
		  /* 82064F2Ch */ case   16:  		/* or R7, R7, R3 */
		/* 82064F2Ch case   16:*/		cpu::op::or<0>(regs,&regs.R7,regs.R7,regs.R3);
		/* 82064F2Ch case   16:*/		return 0x82064F30;
		  /* 82064F30h */ case   17:  		/* stdx R7, <#[R11 + R31]> */
		/* 82064F30h case   17:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82064F30h case   17:*/		return 0x82064F34;
		  /* 82064F34h */ case   18:  		/* lwzx R11, <#[R6 + R31]> */
		/* 82064F34h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + regs.R31 + 0x00000000) );
		/* 82064F34h case   18:*/		return 0x82064F38;
		  /* 82064F38h */ case   19:  		/* cmplwi CR6, R11, 0 */
		/* 82064F38h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82064F38h case   19:*/		return 0x82064F3C;
		  /* 82064F3Ch */ case   20:  		/* lwzx R7, <#[R10 + R31]> */
		/* 82064F3Ch case   20:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 82064F3Ch case   20:*/		return 0x82064F40;
		  /* 82064F40h */ case   21:  		/* stwx R7, <#[R10 + R31]> */
		/* 82064F40h case   21:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 82064F40h case   21:*/		return 0x82064F44;
		  /* 82064F44h */ case   22:  		/* bc 12, CR6_EQ, 164 */
		/* 82064F44h case   22:*/		if ( regs.CR[6].eq ) { return 0x82064FE8;  }
		/* 82064F44h case   22:*/		return 0x82064F48;
		  /* 82064F48h */ case   23:  		/* subfic R11, R4, 0 */
		/* 82064F48h case   23:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R4,0x0);
		/* 82064F48h case   23:*/		return 0x82064F4C;
		  /* 82064F4Ch */ case   24:  		/* addi R10, R4, 1 */
		/* 82064F4Ch case   24:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x1);
		/* 82064F4Ch case   24:*/		return 0x82064F50;
		  /* 82064F50h */ case   25:  		/* subfe R11, R11, R11 */
		/* 82064F50h case   25:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82064F50h case   25:*/		return 0x82064F54;
		  /* 82064F54h */ case   26:  		/* and R3, R11, R10 */
		/* 82064F54h case   26:*/		cpu::op::and<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 82064F54h case   26:*/		return 0x82064F58;
		  /* 82064F58h */ case   27:  		/* addi R11, R3, 2593 */
		/* 82064F58h case   27:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0xA21);
		/* 82064F58h case   27:*/		return 0x82064F5C;
		  /* 82064F5Ch */ case   28:  		/* rlwinm R30, R11, 2, 0, 29 */
		/* 82064F5Ch case   28:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R11);
		/* 82064F5Ch case   28:*/		return 0x82064F60;
		  /* 82064F60h */ case   29:  		/* lwzx R6, <#[R30 + R31]> */
		/* 82064F60h case   29:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R30 + regs.R31 + 0x00000000) );
		/* 82064F60h case   29:*/		return 0x82064F64;
		  /* 82064F64h */ case   30:  		/* rlwinm R11, R6, 16, 28, 31 */
		/* 82064F64h case   30:*/		cpu::op::rlwinm<0,16,28,31>(regs,&regs.R11,regs.R6);
		/* 82064F64h case   30:*/		return 0x82064F68;
		  /* 82064F68h */ case   31:  		/* cmplwi CR6, R11, 2 */
		/* 82064F68h case   31:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 82064F68h case   31:*/		return 0x82064F6C;
		  /* 82064F6Ch */ case   32:  		/* bc 12, CR6_EQ, 28 */
		/* 82064F6Ch case   32:*/		if ( regs.CR[6].eq ) { return 0x82064F88;  }
		/* 82064F6Ch case   32:*/		return 0x82064F70;
		  /* 82064F70h */ case   33:  		/* cmplwi CR6, R11, 3 */
		/* 82064F70h case   33:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 82064F70h case   33:*/		return 0x82064F74;
		  /* 82064F74h */ case   34:  		/* bc 12, CR6_EQ, 20 */
		/* 82064F74h case   34:*/		if ( regs.CR[6].eq ) { return 0x82064F88;  }
		/* 82064F74h case   34:*/		return 0x82064F78;
		  /* 82064F78h */ case   35:  		/* cmplwi CR6, R11, 10 */
		/* 82064F78h case   35:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000A);
		/* 82064F78h case   35:*/		return 0x82064F7C;
		  /* 82064F7Ch */ case   36:  		/* bc 12, CR6_EQ, 12 */
		/* 82064F7Ch case   36:*/		if ( regs.CR[6].eq ) { return 0x82064F88;  }
		/* 82064F7Ch case   36:*/		return 0x82064F80;
		  /* 82064F80h */ case   37:  		/* cmplwi CR6, R11, 12 */
		/* 82064F80h case   37:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000C);
		/* 82064F80h case   37:*/		return 0x82064F84;
		  /* 82064F84h */ case   38:  		/* bc 4, CR6_EQ, 100 */
		/* 82064F84h case   38:*/		if ( !regs.CR[6].eq ) { return 0x82064FE8;  }
		/* 82064F84h case   38:*/		return 0x82064F88;
	}
	return 0x82064F88;
} // Block from 82064EECh-82064F88h (39 instructions)

//////////////////////////////////////////////////////
// Block at 82064F88h
// Function 'D3DDevice_SetDepthStencilSurface'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064F88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064F88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064F88);
		  /* 82064F88h */ case    0:  		/* rlwinm R10, R6, 13, 31, 31 */
		/* 82064F88h case    0:*/		cpu::op::rlwinm<0,13,31,31>(regs,&regs.R10,regs.R6);
		/* 82064F88h case    0:*/		return 0x82064F8C;
		  /* 82064F8Ch */ case    1:  		/* xor. R10, R10, R7 */
		/* 82064F8Ch case    1:*/		cpu::op::xor<1>(regs,&regs.R10,regs.R10,regs.R7);
		/* 82064F8Ch case    1:*/		return 0x82064F90;
		  /* 82064F90h */ case    2:  		/* bc 12, CR0_EQ, 88 */
		/* 82064F90h case    2:*/		if ( regs.CR[0].eq ) { return 0x82064FE8;  }
		/* 82064F90h case    2:*/		return 0x82064F94;
		  /* 82064F94h */ case    3:  		/* addi R10, R7, -1 */
		/* 82064F94h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R7,0xFFFFFFFF);
		/* 82064F94h case    3:*/		return 0x82064F98;
		  /* 82064F98h */ case    4:  		/* rlwinm R7, R11, 31, 1, 31 */
		/* 82064F98h case    4:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R7,regs.R11);
		/* 82064F98h case    4:*/		return 0x82064F9C;
		  /* 82064F9Ch */ case    5:  		/* nor R29, R10, R10 */
		/* 82064F9Ch case    5:*/		cpu::op::nor<0>(regs,&regs.R29,regs.R10,regs.R10);
		/* 82064F9Ch case    5:*/		return 0x82064FA0;
		  /* 82064FA0h */ case    6:  		/* addi R11, R11, 3 */
		/* 82064FA0h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x3);
		/* 82064FA0h case    6:*/		return 0x82064FA4;
		  /* 82064FA4h */ case    7:  		/* addi R7, R7, -3 */
		/* 82064FA4h case    7:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0xFFFFFFFD);
		/* 82064FA4h case    7:*/		return 0x82064FA8;
		  /* 82064FA8h */ case    8:  		/* rlwinm R11, R11, 17, 0, 14 */
		/* 82064FA8h case    8:*/		cpu::op::rlwinm<0,17,0,14>(regs,&regs.R11,regs.R11);
		/* 82064FA8h case    8:*/		return 0x82064FAC;
		  /* 82064FACh */ case    9:  		/* and R10, R7, R10 */
		/* 82064FACh case    9:*/		cpu::op::and<0>(regs,&regs.R10,regs.R7,regs.R10);
		/* 82064FACh case    9:*/		return 0x82064FB0;
		  /* 82064FB0h */ case   10:  		/* rlwinm R29, R29, 16, 0, 15 */
		/* 82064FB0h case   10:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R29,regs.R29);
		/* 82064FB0h case   10:*/		return 0x82064FB4;
		  /* 82064FB4h */ case   11:  		/* rlwinm R10, R10, 16, 0, 15 */
		/* 82064FB4h case   11:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R10,regs.R10);
		/* 82064FB4h case   11:*/		return 0x82064FB8;
		  /* 82064FB8h */ case   12:  		/* and R11, R29, R11 */
		/* 82064FB8h case   12:*/		cpu::op::and<0>(regs,&regs.R11,regs.R29,regs.R11);
		/* 82064FB8h case   12:*/		return 0x82064FBC;
		  /* 82064FBCh */ case   13:  		/* add R8, R3, R8 */
		/* 82064FBCh case   13:*/		cpu::op::add<0>(regs,&regs.R8,regs.R3,regs.R8);
		/* 82064FBCh case   13:*/		return 0x82064FC0;
		  /* 82064FC0h */ case   14:  		/* or R10, R11, R10 */
		/* 82064FC0h case   14:*/		cpu::op::or<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 82064FC0h case   14:*/		return 0x82064FC4;
		  /* 82064FC4h */ case   15:  		/* srawi R11, R8, 16 */
		/* 82064FC4h case   15:*/		cpu::op::srawi<0,16>(regs,&regs.R11,regs.R8);
		/* 82064FC4h case   15:*/		return 0x82064FC8;
		  /* 82064FC8h */ case   16:  		/* rlwimi R10, R6, 0, 16, 11 */
		/* 82064FC8h case   16:*/		cpu::op::rlwimi<0,0,16,11>(regs,&regs.R10,regs.R6);
		/* 82064FC8h case   16:*/		return 0x82064FCC;
		  /* 82064FCCh */ case   17:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 82064FCCh case   17:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 82064FCCh case   17:*/		return 0x82064FD0;
		  /* 82064FD0h */ case   18:  		/* stwx R10, <#[R30 + R31]> */
		/* 82064FD0h case   18:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + regs.R31 + 0x00000000) );
		/* 82064FD0h case   18:*/		return 0x82064FD4;
		  /* 82064FD4h */ case   19:  		/* rldicl R10, R8, 0, 56 */
		/* 82064FD4h case   19:*/		cpu::op::rldicl<0,0,56>(regs,&regs.R10,regs.R8);
		/* 82064FD4h case   19:*/		return 0x82064FD8;
		  /* 82064FD8h */ case   20:  		/* srd R10, R9, R10 */
		/* 82064FD8h case   20:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82064FD8h case   20:*/		return 0x82064FDC;
		  /* 82064FDCh */ case   21:  		/* ldx R9, <#[R11 + R31]> */
		/* 82064FDCh case   21:*/		cpu::mem::load64( regs, &regs.R9, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82064FDCh case   21:*/		return 0x82064FE0;
		  /* 82064FE0h */ case   22:  		/* or R10, R10, R9 */
		/* 82064FE0h case   22:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82064FE0h case   22:*/		return 0x82064FE4;
		  /* 82064FE4h */ case   23:  		/* stdx R10, <#[R11 + R31]> */
		/* 82064FE4h case   23:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82064FE4h case   23:*/		return 0x82064FE8;
	}
	return 0x82064FE8;
} // Block from 82064F88h-82064FE8h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82064FE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82064FE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82064FE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82064FE8);
		  /* 82064FE8h */ case    0:  		/* cmplwi CR6, R4, 0 */
		/* 82064FE8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82064FE8h case    0:*/		return 0x82064FEC;
		  /* 82064FECh */ case    1:  		/* bc 4, CR6_EQ, 444 */
		/* 82064FECh case    1:*/		if ( !regs.CR[6].eq ) { return 0x820651A8;  }
		/* 82064FECh case    1:*/		return 0x82064FF0;
		  /* 82064FF0h */ case    2:  		/* cmplwi CR6, R5, 0 */
		/* 82064FF0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 82064FF0h case    2:*/		return 0x82064FF4;
		  /* 82064FF4h */ case    3:  		/* bc 4, CR6_EQ, 64 */
		/* 82064FF4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82065034;  }
		/* 82064FF4h case    3:*/		return 0x82064FF8;
		  /* 82064FF8h */ case    4:  		/* lwz R10, <#[R31 + 10372]> */
		/* 82064FF8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00002884) );
		/* 82064FF8h case    4:*/		return 0x82064FFC;
		  /* 82064FFCh */ case    5:  		/* rlwinm R11, R10, 16, 28, 31 */
		/* 82064FFCh case    5:*/		cpu::op::rlwinm<0,16,28,31>(regs,&regs.R11,regs.R10);
		/* 82064FFCh case    5:*/		return 0x82065000;
		  /* 82065000h */ case    6:  		/* cmplwi CR6, R11, 5 */
		/* 82065000h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000005);
		/* 82065000h case    6:*/		return 0x82065004;
		  /* 82065004h */ case    7:  		/* bc 12, CR6_EQ, 20 */
		/* 82065004h case    7:*/		if ( regs.CR[6].eq ) { return 0x82065018;  }
		/* 82065004h case    7:*/		return 0x82065008;
		  /* 82065008h */ case    8:  		/* cmplwi CR6, R11, 7 */
		/* 82065008h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000007);
		/* 82065008h case    8:*/		return 0x8206500C;
		  /* 8206500Ch */ case    9:  		/* bc 12, CR6_EQ, 12 */
		/* 8206500Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x82065018;  }
		/* 8206500Ch case    9:*/		return 0x82065010;
		  /* 82065010h */ case   10:  		/* cmplwi CR6, R11, 15 */
		/* 82065010h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000F);
		/* 82065010h case   10:*/		return 0x82065014;
		  /* 82065014h */ case   11:  		/* bc 4, CR6_EQ, 32 */
		/* 82065014h case   11:*/		if ( !regs.CR[6].eq ) { return 0x82065034;  }
		/* 82065014h case   11:*/		return 0x82065018;
	}
	return 0x82065018;
} // Block from 82064FE8h-82065018h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82065018h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065018( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065018) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065018);
		  /* 82065018h */ case    0:  		/* li R12, 1 */
		/* 82065018h case    0:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 82065018h case    0:*/		return 0x8206501C;
		  /* 8206501Ch */ case    1:  		/* rlwinm R11, R10, 0, 16, 11 */
		/* 8206501Ch case    1:*/		cpu::op::rlwinm<0,0,16,11>(regs,&regs.R11,regs.R10);
		/* 8206501Ch case    1:*/		return 0x82065020;
		  /* 82065020h */ case    2:  		/* rldicr R12, R12, 56, 63 */
		/* 82065020h case    2:*/		cpu::op::rldicr<0,56,63>(regs,&regs.R12,regs.R12);
		/* 82065020h case    2:*/		return 0x82065024;
		  /* 82065024h */ case    3:  		/* stw R11, <#[R31 + 10372]> */
		/* 82065024h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00002884) );
		/* 82065024h case    3:*/		return 0x82065028;
		  /* 82065028h */ case    4:  		/* ld R11, <#[R31 + 16]> */
		/* 82065028h case    4:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82065028h case    4:*/		return 0x8206502C;
		  /* 8206502Ch */ case    5:  		/* or R11, R11, R12 */
		/* 8206502Ch case    5:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 8206502Ch case    5:*/		return 0x82065030;
		  /* 82065030h */ case    6:  		/* std R11, <#[R31 + 16]> */
		/* 82065030h case    6:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82065030h case    6:*/		return 0x82065034;
	}
	return 0x82065034;
} // Block from 82065018h-82065034h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82065034h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065034( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065034) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065034);
		  /* 82065034h */ case    0:  		/* lbz R11, <#[R31 + 11071]> */
		/* 82065034h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B3F) );
		/* 82065034h case    0:*/		return 0x82065038;
		  /* 82065038h */ case    1:  		/* cmplwi CR6, R5, 0 */
		/* 82065038h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 82065038h case    1:*/		return 0x8206503C;
		  /* 8206503Ch */ case    2:  		/* andi. R10, R11, 247 */
		/* 8206503Ch case    2:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R11,0xF7);
		/* 8206503Ch case    2:*/		return 0x82065040;
		  /* 82065040h */ case    3:  		/* stb R10, <#[R31 + 11071]> */
		/* 82065040h case    3:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R31 + 0x00002B3F) );
		/* 82065040h case    3:*/		return 0x82065044;
		  /* 82065044h */ case    4:  		/* bc 12, CR6_EQ, 64 */
		/* 82065044h case    4:*/		if ( regs.CR[6].eq ) { return 0x82065084;  }
		/* 82065044h case    4:*/		return 0x82065048;
		  /* 82065048h */ case    5:  		/* lhz R11, <#[R5 + 28]> */
		/* 82065048h case    5:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R5 + 0x0000001C) );
		/* 82065048h case    5:*/		return 0x8206504C;
		  /* 8206504Ch */ case    6:  		/* rlwinm R11, R11, 0, 28, 31 */
		/* 8206504Ch case    6:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R11,regs.R11);
		/* 8206504Ch case    6:*/		return 0x82065050;
		  /* 82065050h */ case    7:  		/* cmplwi CR6, R11, 5 */
		/* 82065050h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000005);
		/* 82065050h case    7:*/		return 0x82065054;
		  /* 82065054h */ case    8:  		/* bc 12, CR6_EQ, 20 */
		/* 82065054h case    8:*/		if ( regs.CR[6].eq ) { return 0x82065068;  }
		/* 82065054h case    8:*/		return 0x82065058;
		  /* 82065058h */ case    9:  		/* cmplwi CR6, R11, 7 */
		/* 82065058h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000007);
		/* 82065058h case    9:*/		return 0x8206505C;
		  /* 8206505Ch */ case   10:  		/* bc 12, CR6_EQ, 12 */
		/* 8206505Ch case   10:*/		if ( regs.CR[6].eq ) { return 0x82065068;  }
		/* 8206505Ch case   10:*/		return 0x82065060;
		  /* 82065060h */ case   11:  		/* cmplwi CR6, R11, 15 */
		/* 82065060h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000F);
		/* 82065060h case   11:*/		return 0x82065064;
		  /* 82065064h */ case   12:  		/* bc 4, CR6_EQ, 24 */
		/* 82065064h case   12:*/		if ( !regs.CR[6].eq ) { return 0x8206507C;  }
		/* 82065064h case   12:*/		return 0x82065068;
	}
	return 0x82065068;
} // Block from 82065034h-82065068h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82065068h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065068( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065068) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065068);
		  /* 82065068h */ case    0:  		/* ori R11, R10, 8 */
		/* 82065068h case    0:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R10,0x8);
		/* 82065068h case    0:*/		return 0x8206506C;
		  /* 8206506Ch */ case    1:  		/* stb R11, <#[R31 + 11071]> */
		/* 8206506Ch case    1:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00002B3F) );
		/* 8206506Ch case    1:*/		return 0x82065070;
		  /* 82065070h */ case    2:  		/* ld R11, <#[R31 + 16]> */
		/* 82065070h case    2:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82065070h case    2:*/		return 0x82065074;
		  /* 82065074h */ case    3:  		/* oris R11, R11, 16 */
		/* 82065074h case    3:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x10);
		/* 82065074h case    3:*/		return 0x82065078;
		  /* 82065078h */ case    4:  		/* std R11, <#[R31 + 16]> */
		/* 82065078h case    4:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82065078h case    4:*/		return 0x8206507C;
	}
	return 0x8206507C;
} // Block from 82065068h-8206507Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8206507Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206507C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206507C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206507C);
		  /* 8206507Ch */ case    0:  		/* mr R4, R5 */
		/* 8206507Ch case    0:*/		regs.R4 = regs.R5;
		/* 8206507Ch case    0:*/		return 0x82065080;
		  /* 82065080h */ case    1:  		/* b 16 */
		/* 82065080h case    1:*/		return 0x82065090;
		/* 82065080h case    1:*/		return 0x82065084;
	}
	return 0x82065084;
} // Block from 8206507Ch-82065084h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82065084h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065084( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065084) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065084);
		  /* 82065084h */ case    0:  		/* lwz R4, <#[R31 + 12832]> */
		/* 82065084h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00003220) );
		/* 82065084h case    0:*/		return 0x82065088;
		  /* 82065088h */ case    1:  		/* cmplwi CR6, R4, 0 */
		/* 82065088h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82065088h case    1:*/		return 0x8206508C;
		  /* 8206508Ch */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 8206508Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x82065098;  }
		/* 8206508Ch case    2:*/		return 0x82065090;
	}
	return 0x82065090;
} // Block from 82065084h-82065090h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82065090h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065090( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065090) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065090);
		  /* 82065090h */ case    0:  		/* mr R3, R31 */
		/* 82065090h case    0:*/		regs.R3 = regs.R31;
		/* 82065090h case    0:*/		return 0x82065094;
		  /* 82065094h */ case    1:  		/* bl -620 */
		/* 82065094h case    1:*/		regs.LR = 0x82065098; return 0x82064E28;
		/* 82065094h case    1:*/		return 0x82065098;
	}
	return 0x82065098;
} // Block from 82065090h-82065098h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82065098h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065098( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065098) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065098);
		  /* 82065098h */ case    0:  		/* lwz R11, <#[R31 + 13092]> */
		/* 82065098h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003324) );
		/* 82065098h case    0:*/		return 0x8206509C;
		  /* 8206509Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 8206509Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8206509Ch case    1:*/		return 0x820650A0;
		  /* 820650A0h */ case    2:  		/* bc 4, CR6_EQ, 208 */
		/* 820650A0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82065170;  }
		/* 820650A0h case    2:*/		return 0x820650A4;
		  /* 820650A4h */ case    3:  		/* lbz R11, <#[R31 + 11068]> */
		/* 820650A4h case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B3C) );
		/* 820650A4h case    3:*/		return 0x820650A8;
		  /* 820650A8h */ case    4:  		/* rlwinm. R10, R11, 0, 28, 28 */
		/* 820650A8h case    4:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R10,regs.R11);
		/* 820650A8h case    4:*/		return 0x820650AC;
		  /* 820650ACh */ case    5:  		/* bc 4, CR0_EQ, 196 */
		/* 820650ACh case    5:*/		if ( !regs.CR[0].eq ) { return 0x82065170;  }
		/* 820650ACh case    5:*/		return 0x820650B0;
		  /* 820650B0h */ case    6:  		/* rlwinm. R10, R11, 0, 29, 29 */
		/* 820650B0h case    6:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R11);
		/* 820650B0h case    6:*/		return 0x820650B4;
		  /* 820650B4h */ case    7:  		/* bc 4, CR0_EQ, 188 */
		/* 820650B4h case    7:*/		if ( !regs.CR[0].eq ) { return 0x82065170;  }
		/* 820650B4h case    7:*/		return 0x820650B8;
		  /* 820650B8h */ case    8:  		/* lbz R10, <#[R31 + 12563]> */
		/* 820650B8h case    8:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x00003113) );
		/* 820650B8h case    8:*/		return 0x820650BC;
		  /* 820650BCh */ case    9:  		/* cmplwi CR0, R10, 0 */
		/* 820650BCh case    9:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 820650BCh case    9:*/		return 0x820650C0;
		  /* 820650C0h */ case   10:  		/* bc 4, CR0_EQ, 176 */
		/* 820650C0h case   10:*/		if ( !regs.CR[0].eq ) { return 0x82065170;  }
		/* 820650C0h case   10:*/		return 0x820650C4;
		  /* 820650C4h */ case   11:  		/* rlwinm. R10, R11, 0, 27, 27 */
		/* 820650C4h case   11:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R11);
		/* 820650C4h case   11:*/		return 0x820650C8;
		  /* 820650C8h */ case   12:  		/* bc 12, CR0_EQ, 12 */
		/* 820650C8h case   12:*/		if ( regs.CR[0].eq ) { return 0x820650D4;  }
		/* 820650C8h case   12:*/		return 0x820650CC;
		  /* 820650CCh */ case   13:  		/* li R11, 1 */
		/* 820650CCh case   13:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820650CCh case   13:*/		return 0x820650D0;
		  /* 820650D0h */ case   14:  		/* b 148 */
		/* 820650D0h case   14:*/		return 0x82065164;
		/* 820650D0h case   14:*/		return 0x820650D4;
	}
	return 0x820650D4;
} // Block from 82065098h-820650D4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820650D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820650D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820650D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820650D4);
		  /* 820650D4h */ case    0:  		/* rlwinm. R11, R11, 0, 26, 26 */
		/* 820650D4h case    0:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R11);
		/* 820650D4h case    0:*/		return 0x820650D8;
		  /* 820650D8h */ case    1:  		/* bc 12, CR0_EQ, 132 */
		/* 820650D8h case    1:*/		if ( regs.CR[0].eq ) { return 0x8206515C;  }
		/* 820650D8h case    1:*/		return 0x820650DC;
		  /* 820650DCh */ case    2:  		/* lwz R11, <#[R31 + 12816]> */
		/* 820650DCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003210) );
		/* 820650DCh case    2:*/		return 0x820650E0;
		  /* 820650E0h */ case    3:  		/* lwz R10, <#[R31 + 13104]> */
		/* 820650E0h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00003330) );
		/* 820650E0h case    3:*/		return 0x820650E4;
		  /* 820650E4h */ case    4:  		/* cmplw CR6, R10, R11 */
		/* 820650E4h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820650E4h case    4:*/		return 0x820650E8;
		  /* 820650E8h */ case    5:  		/* bc 12, CR6_EQ, 12 */
		/* 820650E8h case    5:*/		if ( regs.CR[6].eq ) { return 0x820650F4;  }
		/* 820650E8h case    5:*/		return 0x820650EC;
		  /* 820650ECh */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 820650ECh case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820650ECh case    6:*/		return 0x820650F0;
		  /* 820650F0h */ case    7:  		/* bc 4, CR6_EQ, 108 */
		/* 820650F0h case    7:*/		if ( !regs.CR[6].eq ) { return 0x8206515C;  }
		/* 820650F0h case    7:*/		return 0x820650F4;
	}
	return 0x820650F4;
} // Block from 820650D4h-820650F4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820650F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820650F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820650F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820650F4);
		  /* 820650F4h */ case    0:  		/* lwz R11, <#[R31 + 12820]> */
		/* 820650F4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003214) );
		/* 820650F4h case    0:*/		return 0x820650F8;
		  /* 820650F8h */ case    1:  		/* lwz R10, <#[R31 + 13108]> */
		/* 820650F8h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00003334) );
		/* 820650F8h case    1:*/		return 0x820650FC;
		  /* 820650FCh */ case    2:  		/* cmplw CR6, R10, R11 */
		/* 820650FCh case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820650FCh case    2:*/		return 0x82065100;
		  /* 82065100h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 82065100h case    3:*/		if ( regs.CR[6].eq ) { return 0x8206510C;  }
		/* 82065100h case    3:*/		return 0x82065104;
		  /* 82065104h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82065104h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82065104h case    4:*/		return 0x82065108;
		  /* 82065108h */ case    5:  		/* bc 4, CR6_EQ, 84 */
		/* 82065108h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8206515C;  }
		/* 82065108h case    5:*/		return 0x8206510C;
	}
	return 0x8206510C;
} // Block from 820650F4h-8206510Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8206510Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206510C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206510C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206510C);
		  /* 8206510Ch */ case    0:  		/* lwz R11, <#[R31 + 12824]> */
		/* 8206510Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003218) );
		/* 8206510Ch case    0:*/		return 0x82065110;
		  /* 82065110h */ case    1:  		/* lwz R10, <#[R31 + 13112]> */
		/* 82065110h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00003338) );
		/* 82065110h case    1:*/		return 0x82065114;
		  /* 82065114h */ case    2:  		/* cmplw CR6, R10, R11 */
		/* 82065114h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82065114h case    2:*/		return 0x82065118;
		  /* 82065118h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 82065118h case    3:*/		if ( regs.CR[6].eq ) { return 0x82065124;  }
		/* 82065118h case    3:*/		return 0x8206511C;
		  /* 8206511Ch */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8206511Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8206511Ch case    4:*/		return 0x82065120;
		  /* 82065120h */ case    5:  		/* bc 4, CR6_EQ, 60 */
		/* 82065120h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8206515C;  }
		/* 82065120h case    5:*/		return 0x82065124;
	}
	return 0x82065124;
} // Block from 8206510Ch-82065124h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82065124h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065124( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065124) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065124);
		  /* 82065124h */ case    0:  		/* lwz R11, <#[R31 + 12828]> */
		/* 82065124h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000321C) );
		/* 82065124h case    0:*/		return 0x82065128;
		  /* 82065128h */ case    1:  		/* lwz R10, <#[R31 + 13116]> */
		/* 82065128h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000333C) );
		/* 82065128h case    1:*/		return 0x8206512C;
		  /* 8206512Ch */ case    2:  		/* cmplw CR6, R10, R11 */
		/* 8206512Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8206512Ch case    2:*/		return 0x82065130;
		  /* 82065130h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 82065130h case    3:*/		if ( regs.CR[6].eq ) { return 0x8206513C;  }
		/* 82065130h case    3:*/		return 0x82065134;
		  /* 82065134h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82065134h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82065134h case    4:*/		return 0x82065138;
		  /* 82065138h */ case    5:  		/* bc 4, CR6_EQ, 36 */
		/* 82065138h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8206515C;  }
		/* 82065138h case    5:*/		return 0x8206513C;
	}
	return 0x8206513C;
} // Block from 82065124h-8206513Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8206513Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206513C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206513C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206513C);
		  /* 8206513Ch */ case    0:  		/* lwz R11, <#[R31 + 12832]> */
		/* 8206513Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003220) );
		/* 8206513Ch case    0:*/		return 0x82065140;
		  /* 82065140h */ case    1:  		/* lwz R10, <#[R31 + 13120]> */
		/* 82065140h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00003340) );
		/* 82065140h case    1:*/		return 0x82065144;
		  /* 82065144h */ case    2:  		/* cmplw CR6, R10, R11 */
		/* 82065144h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82065144h case    2:*/		return 0x82065148;
		  /* 82065148h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 82065148h case    3:*/		if ( regs.CR[6].eq ) { return 0x82065154;  }
		/* 82065148h case    3:*/		return 0x8206514C;
		  /* 8206514Ch */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8206514Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8206514Ch case    4:*/		return 0x82065150;
		  /* 82065150h */ case    5:  		/* bc 4, CR6_EQ, 12 */
		/* 82065150h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8206515C;  }
		/* 82065150h case    5:*/		return 0x82065154;
	}
	return 0x82065154;
} // Block from 8206513Ch-82065154h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82065154h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065154( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065154) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065154);
		  /* 82065154h */ case    0:  		/* li R11, 1 */
		/* 82065154h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82065154h case    0:*/		return 0x82065158;
		  /* 82065158h */ case    1:  		/* b 8 */
		/* 82065158h case    1:*/		return 0x82065160;
		/* 82065158h case    1:*/		return 0x8206515C;
	}
	return 0x8206515C;
} // Block from 82065154h-8206515Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206515Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206515C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206515C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206515C);
		  /* 8206515Ch */ case    0:  		/* li R11, 0 */
		/* 8206515Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8206515Ch case    0:*/		return 0x82065160;
	}
	return 0x82065160;
} // Block from 8206515Ch-82065160h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82065160h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065160( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065160) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065160);
		  /* 82065160h */ case    0:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 82065160h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82065160h case    0:*/		return 0x82065164;
	}
	return 0x82065164;
} // Block from 82065160h-82065164h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82065164h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065164( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065164) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065164);
		  /* 82065164h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82065164h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82065164h case    0:*/		return 0x82065168;
		  /* 82065168h */ case    1:  		/* li R11, 1 */
		/* 82065168h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82065168h case    1:*/		return 0x8206516C;
		  /* 8206516Ch */ case    2:  		/* bc 4, CR0_EQ, 8 */
		/* 8206516Ch case    2:*/		if ( !regs.CR[0].eq ) { return 0x82065174;  }
		/* 8206516Ch case    2:*/		return 0x82065170;
	}
	return 0x82065170;
} // Block from 82065164h-82065170h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82065170h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065170( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065170) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065170);
		  /* 82065170h */ case    0:  		/* li R11, 0 */
		/* 82065170h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82065170h case    0:*/		return 0x82065174;
	}
	return 0x82065174;
} // Block from 82065170h-82065174h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82065174h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065174( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065174) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065174);
		  /* 82065174h */ case    0:  		/* lbz R10, <#[R31 + 11068]> */
		/* 82065174h case    0:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x00002B3C) );
		/* 82065174h case    0:*/		return 0x82065178;
		  /* 82065178h */ case    1:  		/* lwz R9, <#[R31 + 12292]> */
		/* 82065178h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00003004) );
		/* 82065178h case    1:*/		return 0x8206517C;
		  /* 8206517Ch */ case    2:  		/* rlwimi R10, R11, 0, 31, 31 */
		/* 8206517Ch case    2:*/		cpu::op::rlwimi<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 8206517Ch case    2:*/		return 0x82065180;
		  /* 82065180h */ case    3:  		/* stb R10, <#[R31 + 11068]> */
		/* 82065180h case    3:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R31 + 0x00002B3C) );
		/* 82065180h case    3:*/		return 0x82065184;
		  /* 82065184h */ case    4:  		/* lwz R10, <#[R31 + 12816]> */
		/* 82065184h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00003210) );
		/* 82065184h case    4:*/		return 0x82065188;
		  /* 82065188h */ case    5:  		/* subfic R10, R10, 0 */
		/* 82065188h case    5:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R10,0x0);
		/* 82065188h case    5:*/		return 0x8206518C;
		  /* 8206518Ch */ case    6:  		/* subfe R10, R10, R10 */
		/* 8206518Ch case    6:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8206518Ch case    6:*/		return 0x82065190;
		  /* 82065190h */ case    7:  		/* lwz R11, <#[R31 + 10460]> */
		/* 82065190h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000028DC) );
		/* 82065190h case    7:*/		return 0x82065194;
		  /* 82065194h */ case    8:  		/* stw R9, <#[R31 + 12292]> */
		/* 82065194h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00003004) );
		/* 82065194h case    8:*/		return 0x82065198;
		  /* 82065198h */ case    9:  		/* and R10, R10, R9 */
		/* 82065198h case    9:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82065198h case    9:*/		return 0x8206519C;
		  /* 8206519Ch */ case   10:  		/* rlwimi R11, R10, 0, 28, 31 */
		/* 8206519Ch case   10:*/		cpu::op::rlwimi<0,0,28,31>(regs,&regs.R11,regs.R10);
		/* 8206519Ch case   10:*/		return 0x820651A0;
		  /* 820651A0h */ case   11:  		/* stw R11, <#[R31 + 10460]> */
		/* 820651A0h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x000028DC) );
		/* 820651A0h case   11:*/		return 0x820651A4;
		  /* 820651A4h */ case   12:  		/* b 136 */
		/* 820651A4h case   12:*/		return 0x8206522C;
		/* 820651A4h case   12:*/		return 0x820651A8;
	}
	return 0x820651A8;
} // Block from 82065174h-820651A8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820651A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820651A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820651A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820651A8);
		  /* 820651A8h */ case    0:  		/* cmplwi CR6, R4, 1 */
		/* 820651A8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000001);
		/* 820651A8h case    0:*/		return 0x820651AC;
		  /* 820651ACh */ case    1:  		/* bc 4, CR6_EQ, 40 */
		/* 820651ACh case    1:*/		if ( !regs.CR[6].eq ) { return 0x820651D4;  }
		/* 820651ACh case    1:*/		return 0x820651B0;
		  /* 820651B0h */ case    2:  		/* lwz R11, <#[R31 + 12820]> */
		/* 820651B0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003214) );
		/* 820651B0h case    2:*/		return 0x820651B4;
		  /* 820651B4h */ case    3:  		/* lwz R10, <#[R31 + 12296]> */
		/* 820651B4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00003008) );
		/* 820651B4h case    3:*/		return 0x820651B8;
		  /* 820651B8h */ case    4:  		/* subfic R11, R11, 0 */
		/* 820651B8h case    4:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x0);
		/* 820651B8h case    4:*/		return 0x820651BC;
		  /* 820651BCh */ case    5:  		/* lwz R9, <#[R31 + 10460]> */
		/* 820651BCh case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x000028DC) );
		/* 820651BCh case    5:*/		return 0x820651C0;
		  /* 820651C0h */ case    6:  		/* subfe R11, R11, R11 */
		/* 820651C0h case    6:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 820651C0h case    6:*/		return 0x820651C4;
		  /* 820651C4h */ case    7:  		/* and R11, R11, R10 */
		/* 820651C4h case    7:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820651C4h case    7:*/		return 0x820651C8;
		  /* 820651C8h */ case    8:  		/* stw R10, <#[R31 + 12296]> */
		/* 820651C8h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00003008) );
		/* 820651C8h case    8:*/		return 0x820651CC;
		  /* 820651CCh */ case    9:  		/* rlwimi R9, R11, 4, 24, 27 */
		/* 820651CCh case    9:*/		cpu::op::rlwimi<0,4,24,27>(regs,&regs.R9,regs.R11);
		/* 820651CCh case    9:*/		return 0x820651D0;
		  /* 820651D0h */ case   10:  		/* b 88 */
		/* 820651D0h case   10:*/		return 0x82065228;
		/* 820651D0h case   10:*/		return 0x820651D4;
	}
	return 0x820651D4;
} // Block from 820651A8h-820651D4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820651D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820651D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820651D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820651D4);
		  /* 820651D4h */ case    0:  		/* cmplwi CR6, R4, 2 */
		/* 820651D4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000002);
		/* 820651D4h case    0:*/		return 0x820651D8;
		  /* 820651D8h */ case    1:  		/* bc 4, CR6_EQ, 40 */
		/* 820651D8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82065200;  }
		/* 820651D8h case    1:*/		return 0x820651DC;
		  /* 820651DCh */ case    2:  		/* lwz R11, <#[R31 + 12824]> */
		/* 820651DCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003218) );
		/* 820651DCh case    2:*/		return 0x820651E0;
		  /* 820651E0h */ case    3:  		/* lwz R10, <#[R31 + 12300]> */
		/* 820651E0h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000300C) );
		/* 820651E0h case    3:*/		return 0x820651E4;
		  /* 820651E4h */ case    4:  		/* subfic R11, R11, 0 */
		/* 820651E4h case    4:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x0);
		/* 820651E4h case    4:*/		return 0x820651E8;
		  /* 820651E8h */ case    5:  		/* lwz R9, <#[R31 + 10460]> */
		/* 820651E8h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x000028DC) );
		/* 820651E8h case    5:*/		return 0x820651EC;
		  /* 820651ECh */ case    6:  		/* subfe R11, R11, R11 */
		/* 820651ECh case    6:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 820651ECh case    6:*/		return 0x820651F0;
		  /* 820651F0h */ case    7:  		/* and R11, R11, R10 */
		/* 820651F0h case    7:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820651F0h case    7:*/		return 0x820651F4;
		  /* 820651F4h */ case    8:  		/* stw R10, <#[R31 + 12300]> */
		/* 820651F4h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x0000300C) );
		/* 820651F4h case    8:*/		return 0x820651F8;
		  /* 820651F8h */ case    9:  		/* rlwimi R9, R11, 8, 20, 23 */
		/* 820651F8h case    9:*/		cpu::op::rlwimi<0,8,20,23>(regs,&regs.R9,regs.R11);
		/* 820651F8h case    9:*/		return 0x820651FC;
		  /* 820651FCh */ case   10:  		/* b 44 */
		/* 820651FCh case   10:*/		return 0x82065228;
		/* 820651FCh case   10:*/		return 0x82065200;
	}
	return 0x82065200;
} // Block from 820651D4h-82065200h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82065200h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065200( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065200) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065200);
		  /* 82065200h */ case    0:  		/* cmplwi CR6, R4, 3 */
		/* 82065200h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000003);
		/* 82065200h case    0:*/		return 0x82065204;
		  /* 82065204h */ case    1:  		/* bc 4, CR6_EQ, 60 */
		/* 82065204h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82065240;  }
		/* 82065204h case    1:*/		return 0x82065208;
		  /* 82065208h */ case    2:  		/* lwz R11, <#[R31 + 12828]> */
		/* 82065208h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000321C) );
		/* 82065208h case    2:*/		return 0x8206520C;
		  /* 8206520Ch */ case    3:  		/* lwz R10, <#[R31 + 12304]> */
		/* 8206520Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00003010) );
		/* 8206520Ch case    3:*/		return 0x82065210;
		  /* 82065210h */ case    4:  		/* subfic R11, R11, 0 */
		/* 82065210h case    4:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x0);
		/* 82065210h case    4:*/		return 0x82065214;
		  /* 82065214h */ case    5:  		/* lwz R9, <#[R31 + 10460]> */
		/* 82065214h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x000028DC) );
		/* 82065214h case    5:*/		return 0x82065218;
		  /* 82065218h */ case    6:  		/* subfe R11, R11, R11 */
		/* 82065218h case    6:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82065218h case    6:*/		return 0x8206521C;
		  /* 8206521Ch */ case    7:  		/* and R11, R11, R10 */
		/* 8206521Ch case    7:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8206521Ch case    7:*/		return 0x82065220;
		  /* 82065220h */ case    8:  		/* stw R10, <#[R31 + 12304]> */
		/* 82065220h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00003010) );
		/* 82065220h case    8:*/		return 0x82065224;
		  /* 82065224h */ case    9:  		/* rlwimi R9, R11, 12, 16, 19 */
		/* 82065224h case    9:*/		cpu::op::rlwimi<0,12,16,19>(regs,&regs.R9,regs.R11);
		/* 82065224h case    9:*/		return 0x82065228;
	}
	return 0x82065228;
} // Block from 82065200h-82065228h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82065228h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065228( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065228) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065228);
		  /* 82065228h */ case    0:  		/* stw R9, <#[R31 + 10460]> */
		/* 82065228h case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x000028DC) );
		/* 82065228h case    0:*/		return 0x8206522C;
	}
	return 0x8206522C;
} // Block from 82065228h-8206522Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206522Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206522C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206522C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206522C);
		  /* 8206522Ch */ case    0:  		/* li R12, 1 */
		/* 8206522Ch case    0:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 8206522Ch case    0:*/		return 0x82065230;
		  /* 82065230h */ case    1:  		/* ld R11, <#[R31 + 16]> */
		/* 82065230h case    1:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82065230h case    1:*/		return 0x82065234;
		  /* 82065234h */ case    2:  		/* rldicr R12, R12, 37, 63 */
		/* 82065234h case    2:*/		cpu::op::rldicr<0,37,63>(regs,&regs.R12,regs.R12);
		/* 82065234h case    2:*/		return 0x82065238;
		  /* 82065238h */ case    3:  		/* or R11, R11, R12 */
		/* 82065238h case    3:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 82065238h case    3:*/		return 0x8206523C;
		  /* 8206523Ch */ case    4:  		/* std R11, <#[R31 + 16]> */
		/* 8206523Ch case    4:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8206523Ch case    4:*/		return 0x82065240;
	}
	return 0x82065240;
} // Block from 8206522Ch-82065240h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82065240h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065240( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065240) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065240);
		  /* 82065240h */ case    0:  		/* addi R1, R1, 112 */
		/* 82065240h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82065240h case    0:*/		return 0x82065244;
		  /* 82065244h */ case    1:  		/* b 180328 */
		/* 82065244h case    1:*/		return 0x820912AC;
		/* 82065244h case    1:*/		return 0x82065248;
	}
	return 0x82065248;
} // Block from 82065240h-82065248h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82065248h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065248( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065248) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065248);
		  /* 82065248h */ case    0:  		/* mfspr R12, LR */
		/* 82065248h case    0:*/		regs.R12 = regs.LR;
		/* 82065248h case    0:*/		return 0x8206524C;
		  /* 8206524Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8206524Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206524Ch case    1:*/		return 0x82065250;
		  /* 82065250h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82065250h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82065250h case    2:*/		return 0x82065254;
		  /* 82065254h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82065254h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82065254h case    3:*/		return 0x82065258;
		  /* 82065258h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82065258h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82065258h case    4:*/		return 0x8206525C;
		  /* 8206525Ch */ case    5:  		/* mr R31, R3 */
		/* 8206525Ch case    5:*/		regs.R31 = regs.R3;
		/* 8206525Ch case    5:*/		return 0x82065260;
	}
	return 0x82065260;
} // Block from 82065248h-82065260h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82065260h
// Function 'D3DDevice_SetGammaRamp'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065260( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065260) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065260);
		  /* 82065260h */ case    0:  		/* stw R4, <#[R3 + 12832]> */
		/* 82065260h case    0:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00003220) );
		/* 82065260h case    0:*/		return 0x82065264;
		  /* 82065264h */ case    1:  		/* mr R30, R4 */
		/* 82065264h case    1:*/		regs.R30 = regs.R4;
		/* 82065264h case    1:*/		return 0x82065268;
		  /* 82065268h */ case    2:  		/* cmplwi CR6, R4, 0 */
		/* 82065268h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82065268h case    2:*/		return 0x8206526C;
		  /* 8206526Ch */ case    3:  		/* bc 12, CR6_EQ, 288 */
		/* 8206526Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x8206538C;  }
		/* 8206526Ch case    3:*/		return 0x82065270;
		  /* 82065270h */ case    4:  		/* lwz R11, <#[R3 + 12816]> */
		/* 82065270h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00003210) );
		/* 82065270h case    4:*/		return 0x82065274;
		  /* 82065274h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82065274h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82065274h case    5:*/		return 0x82065278;
		  /* 82065278h */ case    6:  		/* bc 4, CR6_EQ, 8 */
		/* 82065278h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82065280;  }
		/* 82065278h case    6:*/		return 0x8206527C;
		  /* 8206527Ch */ case    7:  		/* bl -1108 */
		/* 8206527Ch case    7:*/		regs.LR = 0x82065280; return 0x82064E28;
		/* 8206527Ch case    7:*/		return 0x82065280;
	}
	return 0x82065280;
} // Block from 82065260h-82065280h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82065280h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065280( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065280) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065280);
		  /* 82065280h */ case    0:  		/* lwz R11, <#[R30 + 28]> */
		/* 82065280h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 82065280h case    0:*/		return 0x82065284;
		  /* 82065284h */ case    1:  		/* stw R11, <#[R31 + 10376]> */
		/* 82065284h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00002888) );
		/* 82065284h case    1:*/		return 0x82065288;
		  /* 82065288h */ case    2:  		/* lbz R10, <#[R31 + 11070]> */
		/* 82065288h case    2:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x00002B3E) );
		/* 82065288h case    2:*/		return 0x8206528C;
		  /* 8206528Ch */ case    3:  		/* lbz R9, <#[R31 + 11071]> */
		/* 8206528Ch case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R31 + 0x00002B3F) );
		/* 8206528Ch case    3:*/		return 0x82065290;
		  /* 82065290h */ case    4:  		/* rlwinm. R9, R9, 0, 26, 26 */
		/* 82065290h case    4:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R9,regs.R9);
		/* 82065290h case    4:*/		return 0x82065294;
		  /* 82065294h */ case    5:  		/* lwz R11, <#[R30 + 32]> */
		/* 82065294h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000020) );
		/* 82065294h case    5:*/		return 0x82065298;
		  /* 82065298h */ case    6:  		/* stw R11, <#[R31 + 10560]> */
		/* 82065298h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00002940) );
		/* 82065298h case    6:*/		return 0x8206529C;
		  /* 8206529Ch */ case    7:  		/* lwz R11, <#[R30 + 32]> */
		/* 8206529Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000020) );
		/* 8206529Ch case    7:*/		return 0x820652A0;
		  /* 820652A0h */ case    8:  		/* rlwimi R10, R11, 5, 26, 26 */
		/* 820652A0h case    8:*/		cpu::op::rlwimi<0,5,26,26>(regs,&regs.R10,regs.R11);
		/* 820652A0h case    8:*/		return 0x820652A4;
		  /* 820652A4h */ case    9:  		/* stb R10, <#[R31 + 11070]> */
		/* 820652A4h case    9:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R31 + 0x00002B3E) );
		/* 820652A4h case    9:*/		return 0x820652A8;
		  /* 820652A8h */ case   10:  		/* bc 12, CR0_EQ, 192 */
		/* 820652A8h case   10:*/		if ( regs.CR[0].eq ) { return 0x82065368;  }
		/* 820652A8h case   10:*/		return 0x820652AC;
		  /* 820652ACh */ case   11:  		/* lbz R11, <#[R31 + 11068]> */
		/* 820652ACh case   11:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B3C) );
		/* 820652ACh case   11:*/		return 0x820652B0;
		  /* 820652B0h */ case   12:  		/* rlwinm. R10, R11, 0, 27, 27 */
		/* 820652B0h case   12:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R11);
		/* 820652B0h case   12:*/		return 0x820652B4;
		  /* 820652B4h */ case   13:  		/* bc 12, CR0_EQ, 12 */
		/* 820652B4h case   13:*/		if ( regs.CR[0].eq ) { return 0x820652C0;  }
		/* 820652B4h case   13:*/		return 0x820652B8;
		  /* 820652B8h */ case   14:  		/* li R11, 1 */
		/* 820652B8h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820652B8h case   14:*/		return 0x820652BC;
		  /* 820652BCh */ case   15:  		/* b 148 */
		/* 820652BCh case   15:*/		return 0x82065350;
		/* 820652BCh case   15:*/		return 0x820652C0;
	}
	return 0x820652C0;
} // Block from 82065280h-820652C0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820652C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820652C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820652C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820652C0);
		  /* 820652C0h */ case    0:  		/* rlwinm. R11, R11, 0, 26, 26 */
		/* 820652C0h case    0:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R11);
		/* 820652C0h case    0:*/		return 0x820652C4;
		  /* 820652C4h */ case    1:  		/* bc 12, CR0_EQ, 132 */
		/* 820652C4h case    1:*/		if ( regs.CR[0].eq ) { return 0x82065348;  }
		/* 820652C4h case    1:*/		return 0x820652C8;
		  /* 820652C8h */ case    2:  		/* lwz R11, <#[R31 + 12816]> */
		/* 820652C8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003210) );
		/* 820652C8h case    2:*/		return 0x820652CC;
		  /* 820652CCh */ case    3:  		/* lwz R10, <#[R31 + 13104]> */
		/* 820652CCh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00003330) );
		/* 820652CCh case    3:*/		return 0x820652D0;
		  /* 820652D0h */ case    4:  		/* cmplw CR6, R10, R11 */
		/* 820652D0h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820652D0h case    4:*/		return 0x820652D4;
		  /* 820652D4h */ case    5:  		/* bc 12, CR6_EQ, 12 */
		/* 820652D4h case    5:*/		if ( regs.CR[6].eq ) { return 0x820652E0;  }
		/* 820652D4h case    5:*/		return 0x820652D8;
		  /* 820652D8h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 820652D8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820652D8h case    6:*/		return 0x820652DC;
		  /* 820652DCh */ case    7:  		/* bc 4, CR6_EQ, 108 */
		/* 820652DCh case    7:*/		if ( !regs.CR[6].eq ) { return 0x82065348;  }
		/* 820652DCh case    7:*/		return 0x820652E0;
	}
	return 0x820652E0;
} // Block from 820652C0h-820652E0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820652E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820652E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820652E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820652E0);
		  /* 820652E0h */ case    0:  		/* lwz R11, <#[R31 + 12820]> */
		/* 820652E0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003214) );
		/* 820652E0h case    0:*/		return 0x820652E4;
		  /* 820652E4h */ case    1:  		/* lwz R10, <#[R31 + 13108]> */
		/* 820652E4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00003334) );
		/* 820652E4h case    1:*/		return 0x820652E8;
		  /* 820652E8h */ case    2:  		/* cmplw CR6, R10, R11 */
		/* 820652E8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820652E8h case    2:*/		return 0x820652EC;
		  /* 820652ECh */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 820652ECh case    3:*/		if ( regs.CR[6].eq ) { return 0x820652F8;  }
		/* 820652ECh case    3:*/		return 0x820652F0;
		  /* 820652F0h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 820652F0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820652F0h case    4:*/		return 0x820652F4;
		  /* 820652F4h */ case    5:  		/* bc 4, CR6_EQ, 84 */
		/* 820652F4h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82065348;  }
		/* 820652F4h case    5:*/		return 0x820652F8;
	}
	return 0x820652F8;
} // Block from 820652E0h-820652F8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820652F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820652F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820652F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820652F8);
		  /* 820652F8h */ case    0:  		/* lwz R11, <#[R31 + 12824]> */
		/* 820652F8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003218) );
		/* 820652F8h case    0:*/		return 0x820652FC;
		  /* 820652FCh */ case    1:  		/* lwz R10, <#[R31 + 13112]> */
		/* 820652FCh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00003338) );
		/* 820652FCh case    1:*/		return 0x82065300;
		  /* 82065300h */ case    2:  		/* cmplw CR6, R10, R11 */
		/* 82065300h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82065300h case    2:*/		return 0x82065304;
		  /* 82065304h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 82065304h case    3:*/		if ( regs.CR[6].eq ) { return 0x82065310;  }
		/* 82065304h case    3:*/		return 0x82065308;
		  /* 82065308h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82065308h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82065308h case    4:*/		return 0x8206530C;
		  /* 8206530Ch */ case    5:  		/* bc 4, CR6_EQ, 60 */
		/* 8206530Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x82065348;  }
		/* 8206530Ch case    5:*/		return 0x82065310;
	}
	return 0x82065310;
} // Block from 820652F8h-82065310h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82065310h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065310( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065310) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065310);
		  /* 82065310h */ case    0:  		/* lwz R11, <#[R31 + 12828]> */
		/* 82065310h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000321C) );
		/* 82065310h case    0:*/		return 0x82065314;
		  /* 82065314h */ case    1:  		/* lwz R10, <#[R31 + 13116]> */
		/* 82065314h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000333C) );
		/* 82065314h case    1:*/		return 0x82065318;
		  /* 82065318h */ case    2:  		/* cmplw CR6, R10, R11 */
		/* 82065318h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82065318h case    2:*/		return 0x8206531C;
		  /* 8206531Ch */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 8206531Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x82065328;  }
		/* 8206531Ch case    3:*/		return 0x82065320;
		  /* 82065320h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82065320h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82065320h case    4:*/		return 0x82065324;
		  /* 82065324h */ case    5:  		/* bc 4, CR6_EQ, 36 */
		/* 82065324h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82065348;  }
		/* 82065324h case    5:*/		return 0x82065328;
	}
	return 0x82065328;
} // Block from 82065310h-82065328h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82065328h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065328( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065328) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065328);
		  /* 82065328h */ case    0:  		/* lwz R11, <#[R31 + 12832]> */
		/* 82065328h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003220) );
		/* 82065328h case    0:*/		return 0x8206532C;
		  /* 8206532Ch */ case    1:  		/* lwz R10, <#[R31 + 13120]> */
		/* 8206532Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00003340) );
		/* 8206532Ch case    1:*/		return 0x82065330;
	}
	return 0x82065330;
} // Block from 82065328h-82065330h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82065330h
// Function 'D3DDevice_SetPWLGamma'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065330( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065330) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065330);
		  /* 82065330h */ case    0:  		/* cmplw CR6, R10, R11 */
		/* 82065330h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82065330h case    0:*/		return 0x82065334;
		  /* 82065334h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 82065334h case    1:*/		if ( regs.CR[6].eq ) { return 0x82065340;  }
		/* 82065334h case    1:*/		return 0x82065338;
		  /* 82065338h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82065338h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82065338h case    2:*/		return 0x8206533C;
		  /* 8206533Ch */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 8206533Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x82065348;  }
		/* 8206533Ch case    3:*/		return 0x82065340;
	}
	return 0x82065340;
} // Block from 82065330h-82065340h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82065340h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065340( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065340) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065340);
		  /* 82065340h */ case    0:  		/* li R11, 1 */
		/* 82065340h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82065340h case    0:*/		return 0x82065344;
		  /* 82065344h */ case    1:  		/* b 8 */
		/* 82065344h case    1:*/		return 0x8206534C;
		/* 82065344h case    1:*/		return 0x82065348;
	}
	return 0x82065348;
} // Block from 82065340h-82065348h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82065348h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065348( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065348) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065348);
		  /* 82065348h */ case    0:  		/* li R11, 0 */
		/* 82065348h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82065348h case    0:*/		return 0x8206534C;
	}
	return 0x8206534C;
} // Block from 82065348h-8206534Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206534Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206534C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206534C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206534C);
		  /* 8206534Ch */ case    0:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 8206534Ch case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8206534Ch case    0:*/		return 0x82065350;
	}
	return 0x82065350;
} // Block from 8206534Ch-82065350h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82065350h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065350( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065350) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065350);
		  /* 82065350h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82065350h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82065350h case    0:*/		return 0x82065354;
		  /* 82065354h */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 82065354h case    1:*/		if ( regs.CR[0].eq ) { return 0x82065368;  }
		/* 82065354h case    1:*/		return 0x82065358;
		  /* 82065358h */ case    2:  		/* lwz R11, <#[R31 + 10368]> */
		/* 82065358h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002880) );
		/* 82065358h case    2:*/		return 0x8206535C;
		  /* 8206535Ch */ case    3:  		/* lwz R10, <#[R31 + 13548]> */
		/* 8206535Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x000034EC) );
		/* 8206535Ch case    3:*/		return 0x82065360;
		  /* 82065360h */ case    4:  		/* rlwimi R11, R10, 18, 0, 13 */
		/* 82065360h case    4:*/		cpu::op::rlwimi<0,18,0,13>(regs,&regs.R11,regs.R10);
		/* 82065360h case    4:*/		return 0x82065364;
		  /* 82065364h */ case    5:  		/* stw R11, <#[R31 + 10368]> */
		/* 82065364h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00002880) );
		/* 82065364h case    5:*/		return 0x82065368;
	}
	return 0x82065368;
} // Block from 82065350h-82065368h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82065368h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065368( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065368) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065368);
		  /* 82065368h */ case    0:  		/* li R12, 1 */
		/* 82065368h case    0:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 82065368h case    0:*/		return 0x8206536C;
		  /* 8206536Ch */ case    1:  		/* ld R11, <#[R31 + 16]> */
		/* 8206536Ch case    1:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8206536Ch case    1:*/		return 0x82065370;
		  /* 82065370h */ case    2:  		/* rldicr R12, R12, 55, 63 */
		/* 82065370h case    2:*/		cpu::op::rldicr<0,55,63>(regs,&regs.R12,regs.R12);
		/* 82065370h case    2:*/		return 0x82065374;
		  /* 82065374h */ case    3:  		/* or R11, R11, R12 */
		/* 82065374h case    3:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 82065374h case    3:*/		return 0x82065378;
		  /* 82065378h */ case    4:  		/* std R11, <#[R31 + 16]> */
		/* 82065378h case    4:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82065378h case    4:*/		return 0x8206537C;
		  /* 8206537Ch */ case    5:  		/* ori R11, R11, 256 */
		/* 8206537Ch case    5:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x100);
		/* 8206537Ch case    5:*/		return 0x82065380;
		  /* 82065380h */ case    6:  		/* std R11, <#[R31 + 16]> */
		/* 82065380h case    6:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82065380h case    6:*/		return 0x82065384;
		  /* 82065384h */ case    7:  		/* oris R11, R11, 2 */
		/* 82065384h case    7:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82065384h case    7:*/		return 0x82065388;
		  /* 82065388h */ case    8:  		/* b 36 */
		/* 82065388h case    8:*/		return 0x820653AC;
		/* 82065388h case    8:*/		return 0x8206538C;
	}
	return 0x8206538C;
} // Block from 82065368h-8206538Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8206538Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206538C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206538C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206538C);
		  /* 8206538Ch */ case    0:  		/* lwz R11, <#[R31 + 10560]> */
		/* 8206538Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002940) );
		/* 8206538Ch case    0:*/		return 0x82065390;
		  /* 82065390h */ case    1:  		/* lbz R10, <#[R31 + 11070]> */
		/* 82065390h case    1:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x00002B3E) );
		/* 82065390h case    1:*/		return 0x82065394;
		  /* 82065394h */ case    2:  		/* rlwinm R11, R11, 0, 0, 27 */
		/* 82065394h case    2:*/		cpu::op::rlwinm<0,0,0,27>(regs,&regs.R11,regs.R11);
		/* 82065394h case    2:*/		return 0x82065398;
		  /* 82065398h */ case    3:  		/* andi. R10, R10, 223 */
		/* 82065398h case    3:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R10,0xDF);
		/* 82065398h case    3:*/		return 0x8206539C;
		  /* 8206539Ch */ case    4:  		/* stw R11, <#[R31 + 10560]> */
		/* 8206539Ch case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00002940) );
		/* 8206539Ch case    4:*/		return 0x820653A0;
		  /* 820653A0h */ case    5:  		/* stb R10, <#[R31 + 11070]> */
		/* 820653A0h case    5:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R31 + 0x00002B3E) );
		/* 820653A0h case    5:*/		return 0x820653A4;
		  /* 820653A4h */ case    6:  		/* ld R11, <#[R31 + 16]> */
		/* 820653A4h case    6:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820653A4h case    6:*/		return 0x820653A8;
		  /* 820653A8h */ case    7:  		/* ori R11, R11, 256 */
		/* 820653A8h case    7:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x100);
		/* 820653A8h case    7:*/		return 0x820653AC;
	}
	return 0x820653AC;
} // Block from 8206538Ch-820653ACh (8 instructions)

//////////////////////////////////////////////////////
// Block at 820653ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820653AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820653AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820653AC);
		  /* 820653ACh */ case    0:  		/* std R11, <#[R31 + 16]> */
		/* 820653ACh case    0:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820653ACh case    0:*/		return 0x820653B0;
		  /* 820653B0h */ case    1:  		/* lwz R11, <#[R31 + 13092]> */
		/* 820653B0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003324) );
		/* 820653B0h case    1:*/		return 0x820653B4;
		  /* 820653B4h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 820653B4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820653B4h case    2:*/		return 0x820653B8;
		  /* 820653B8h */ case    3:  		/* bc 4, CR6_EQ, 208 */
		/* 820653B8h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82065488;  }
		/* 820653B8h case    3:*/		return 0x820653BC;
		  /* 820653BCh */ case    4:  		/* lbz R11, <#[R31 + 11068]> */
		/* 820653BCh case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B3C) );
		/* 820653BCh case    4:*/		return 0x820653C0;
		  /* 820653C0h */ case    5:  		/* rlwinm. R10, R11, 0, 28, 28 */
		/* 820653C0h case    5:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R10,regs.R11);
		/* 820653C0h case    5:*/		return 0x820653C4;
		  /* 820653C4h */ case    6:  		/* bc 4, CR0_EQ, 196 */
		/* 820653C4h case    6:*/		if ( !regs.CR[0].eq ) { return 0x82065488;  }
		/* 820653C4h case    6:*/		return 0x820653C8;
		  /* 820653C8h */ case    7:  		/* rlwinm. R10, R11, 0, 29, 29 */
		/* 820653C8h case    7:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R11);
		/* 820653C8h case    7:*/		return 0x820653CC;
		  /* 820653CCh */ case    8:  		/* bc 4, CR0_EQ, 188 */
		/* 820653CCh case    8:*/		if ( !regs.CR[0].eq ) { return 0x82065488;  }
		/* 820653CCh case    8:*/		return 0x820653D0;
		  /* 820653D0h */ case    9:  		/* lbz R10, <#[R31 + 12563]> */
		/* 820653D0h case    9:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x00003113) );
		/* 820653D0h case    9:*/		return 0x820653D4;
		  /* 820653D4h */ case   10:  		/* cmplwi CR0, R10, 0 */
		/* 820653D4h case   10:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 820653D4h case   10:*/		return 0x820653D8;
		  /* 820653D8h */ case   11:  		/* bc 4, CR0_EQ, 176 */
		/* 820653D8h case   11:*/		if ( !regs.CR[0].eq ) { return 0x82065488;  }
		/* 820653D8h case   11:*/		return 0x820653DC;
		  /* 820653DCh */ case   12:  		/* rlwinm. R10, R11, 0, 27, 27 */
		/* 820653DCh case   12:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R11);
		/* 820653DCh case   12:*/		return 0x820653E0;
		  /* 820653E0h */ case   13:  		/* bc 12, CR0_EQ, 12 */
		/* 820653E0h case   13:*/		if ( regs.CR[0].eq ) { return 0x820653EC;  }
		/* 820653E0h case   13:*/		return 0x820653E4;
		  /* 820653E4h */ case   14:  		/* li R11, 1 */
		/* 820653E4h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820653E4h case   14:*/		return 0x820653E8;
		  /* 820653E8h */ case   15:  		/* b 148 */
		/* 820653E8h case   15:*/		return 0x8206547C;
		/* 820653E8h case   15:*/		return 0x820653EC;
	}
	return 0x820653EC;
} // Block from 820653ACh-820653ECh (16 instructions)

//////////////////////////////////////////////////////
// Block at 820653ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820653EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820653EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820653EC);
		  /* 820653ECh */ case    0:  		/* rlwinm. R11, R11, 0, 26, 26 */
		/* 820653ECh case    0:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R11);
		/* 820653ECh case    0:*/		return 0x820653F0;
		  /* 820653F0h */ case    1:  		/* bc 12, CR0_EQ, 132 */
		/* 820653F0h case    1:*/		if ( regs.CR[0].eq ) { return 0x82065474;  }
		/* 820653F0h case    1:*/		return 0x820653F4;
		  /* 820653F4h */ case    2:  		/* lwz R11, <#[R31 + 12816]> */
		/* 820653F4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003210) );
		/* 820653F4h case    2:*/		return 0x820653F8;
		  /* 820653F8h */ case    3:  		/* lwz R10, <#[R31 + 13104]> */
		/* 820653F8h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00003330) );
		/* 820653F8h case    3:*/		return 0x820653FC;
		  /* 820653FCh */ case    4:  		/* cmplw CR6, R10, R11 */
		/* 820653FCh case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820653FCh case    4:*/		return 0x82065400;
	}
	return 0x82065400;
} // Block from 820653ECh-82065400h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82065400h
// Function '?ClearRects@D3D@@YAXPAVCDevice@1@KPBU_D3DRECT@@PBU__vector4@@MTGPU_SURFACEINFO@@TGPU_COLORINFO@@KK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065400( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065400) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065400);
		  /* 82065400h */ case    0:  		/* bc 12, CR6_EQ, 12 */
		/* 82065400h case    0:*/		if ( regs.CR[6].eq ) { return 0x8206540C;  }
		/* 82065400h case    0:*/		return 0x82065404;
		  /* 82065404h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82065404h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82065404h case    1:*/		return 0x82065408;
		  /* 82065408h */ case    2:  		/* bc 4, CR6_EQ, 108 */
		/* 82065408h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82065474;  }
		/* 82065408h case    2:*/		return 0x8206540C;
	}
	return 0x8206540C;
} // Block from 82065400h-8206540Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206540Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206540C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206540C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206540C);
		  /* 8206540Ch */ case    0:  		/* lwz R11, <#[R31 + 12820]> */
		/* 8206540Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003214) );
		/* 8206540Ch case    0:*/		return 0x82065410;
		  /* 82065410h */ case    1:  		/* lwz R10, <#[R31 + 13108]> */
		/* 82065410h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00003334) );
		/* 82065410h case    1:*/		return 0x82065414;
		  /* 82065414h */ case    2:  		/* cmplw CR6, R10, R11 */
		/* 82065414h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82065414h case    2:*/		return 0x82065418;
		  /* 82065418h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 82065418h case    3:*/		if ( regs.CR[6].eq ) { return 0x82065424;  }
		/* 82065418h case    3:*/		return 0x8206541C;
		  /* 8206541Ch */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8206541Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8206541Ch case    4:*/		return 0x82065420;
		  /* 82065420h */ case    5:  		/* bc 4, CR6_EQ, 84 */
		/* 82065420h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82065474;  }
		/* 82065420h case    5:*/		return 0x82065424;
	}
	return 0x82065424;
} // Block from 8206540Ch-82065424h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82065424h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065424( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065424) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065424);
		  /* 82065424h */ case    0:  		/* lwz R11, <#[R31 + 12824]> */
		/* 82065424h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003218) );
		/* 82065424h case    0:*/		return 0x82065428;
		  /* 82065428h */ case    1:  		/* lwz R10, <#[R31 + 13112]> */
		/* 82065428h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00003338) );
		/* 82065428h case    1:*/		return 0x8206542C;
		  /* 8206542Ch */ case    2:  		/* cmplw CR6, R10, R11 */
		/* 8206542Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8206542Ch case    2:*/		return 0x82065430;
		  /* 82065430h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 82065430h case    3:*/		if ( regs.CR[6].eq ) { return 0x8206543C;  }
		/* 82065430h case    3:*/		return 0x82065434;
		  /* 82065434h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82065434h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82065434h case    4:*/		return 0x82065438;
		  /* 82065438h */ case    5:  		/* bc 4, CR6_EQ, 60 */
		/* 82065438h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82065474;  }
		/* 82065438h case    5:*/		return 0x8206543C;
	}
	return 0x8206543C;
} // Block from 82065424h-8206543Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8206543Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206543C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206543C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206543C);
		  /* 8206543Ch */ case    0:  		/* lwz R11, <#[R31 + 12828]> */
		/* 8206543Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000321C) );
		/* 8206543Ch case    0:*/		return 0x82065440;
		  /* 82065440h */ case    1:  		/* lwz R10, <#[R31 + 13116]> */
		/* 82065440h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000333C) );
		/* 82065440h case    1:*/		return 0x82065444;
		  /* 82065444h */ case    2:  		/* cmplw CR6, R10, R11 */
		/* 82065444h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82065444h case    2:*/		return 0x82065448;
		  /* 82065448h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 82065448h case    3:*/		if ( regs.CR[6].eq ) { return 0x82065454;  }
		/* 82065448h case    3:*/		return 0x8206544C;
		  /* 8206544Ch */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 8206544Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8206544Ch case    4:*/		return 0x82065450;
		  /* 82065450h */ case    5:  		/* bc 4, CR6_EQ, 36 */
		/* 82065450h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82065474;  }
		/* 82065450h case    5:*/		return 0x82065454;
	}
	return 0x82065454;
} // Block from 8206543Ch-82065454h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82065454h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065454( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065454) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065454);
		  /* 82065454h */ case    0:  		/* lwz R11, <#[R31 + 12832]> */
		/* 82065454h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003220) );
		/* 82065454h case    0:*/		return 0x82065458;
		  /* 82065458h */ case    1:  		/* lwz R10, <#[R31 + 13120]> */
		/* 82065458h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00003340) );
		/* 82065458h case    1:*/		return 0x8206545C;
		  /* 8206545Ch */ case    2:  		/* cmplw CR6, R10, R11 */
		/* 8206545Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8206545Ch case    2:*/		return 0x82065460;
		  /* 82065460h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 82065460h case    3:*/		if ( regs.CR[6].eq ) { return 0x8206546C;  }
		/* 82065460h case    3:*/		return 0x82065464;
		  /* 82065464h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82065464h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82065464h case    4:*/		return 0x82065468;
		  /* 82065468h */ case    5:  		/* bc 4, CR6_EQ, 12 */
		/* 82065468h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82065474;  }
		/* 82065468h case    5:*/		return 0x8206546C;
	}
	return 0x8206546C;
} // Block from 82065454h-8206546Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8206546Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206546C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206546C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206546C);
		  /* 8206546Ch */ case    0:  		/* li R11, 1 */
		/* 8206546Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8206546Ch case    0:*/		return 0x82065470;
		  /* 82065470h */ case    1:  		/* b 8 */
		/* 82065470h case    1:*/		return 0x82065478;
		/* 82065470h case    1:*/		return 0x82065474;
	}
	return 0x82065474;
} // Block from 8206546Ch-82065474h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82065474h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065474( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065474) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065474);
		  /* 82065474h */ case    0:  		/* li R11, 0 */
		/* 82065474h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82065474h case    0:*/		return 0x82065478;
	}
	return 0x82065478;
} // Block from 82065474h-82065478h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82065478h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065478( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065478) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065478);
		  /* 82065478h */ case    0:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 82065478h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82065478h case    0:*/		return 0x8206547C;
	}
	return 0x8206547C;
} // Block from 82065478h-8206547Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206547Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206547C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206547C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206547C);
		  /* 8206547Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8206547Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8206547Ch case    0:*/		return 0x82065480;
		  /* 82065480h */ case    1:  		/* li R11, 1 */
		/* 82065480h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82065480h case    1:*/		return 0x82065484;
		  /* 82065484h */ case    2:  		/* bc 4, CR0_EQ, 8 */
		/* 82065484h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8206548C;  }
		/* 82065484h case    2:*/		return 0x82065488;
	}
	return 0x82065488;
} // Block from 8206547Ch-82065488h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82065488h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065488( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065488) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065488);
		  /* 82065488h */ case    0:  		/* li R11, 0 */
		/* 82065488h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82065488h case    0:*/		return 0x8206548C;
	}
	return 0x8206548C;
} // Block from 82065488h-8206548Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206548Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206548C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206548C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206548C);
		  /* 8206548Ch */ case    0:  		/* lbz R10, <#[R31 + 11068]> */
		/* 8206548Ch case    0:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x00002B3C) );
		/* 8206548Ch case    0:*/		return 0x82065490;
		  /* 82065490h */ case    1:  		/* lwz R9, <#[R31 + 12308]> */
		/* 82065490h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00003014) );
		/* 82065490h case    1:*/		return 0x82065494;
		  /* 82065494h */ case    2:  		/* rlwimi R10, R11, 0, 31, 31 */
		/* 82065494h case    2:*/		cpu::op::rlwimi<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 82065494h case    2:*/		return 0x82065498;
		  /* 82065498h */ case    3:  		/* stb R10, <#[R31 + 11068]> */
		/* 82065498h case    3:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R31 + 0x00002B3C) );
		/* 82065498h case    3:*/		return 0x8206549C;
		  /* 8206549Ch */ case    4:  		/* lwz R11, <#[R31 + 10548]> */
		/* 8206549Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002934) );
		/* 8206549Ch case    4:*/		return 0x820654A0;
		  /* 820654A0h */ case    5:  		/* lwz R10, <#[R31 + 12832]> */
		/* 820654A0h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00003220) );
		/* 820654A0h case    5:*/		return 0x820654A4;
		  /* 820654A4h */ case    6:  		/* subfic R10, R10, 0 */
		/* 820654A4h case    6:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R10,0x0);
		/* 820654A4h case    6:*/		return 0x820654A8;
		  /* 820654A8h */ case    7:  		/* subfe R10, R10, R10 */
		/* 820654A8h case    7:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 820654A8h case    7:*/		return 0x820654AC;
		  /* 820654ACh */ case    8:  		/* stw R9, <#[R31 + 12308]> */
		/* 820654ACh case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00003014) );
		/* 820654ACh case    8:*/		return 0x820654B0;
		  /* 820654B0h */ case    9:  		/* and R10, R10, R9 */
		/* 820654B0h case    9:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 820654B0h case    9:*/		return 0x820654B4;
		  /* 820654B4h */ case   10:  		/* rlwimi R11, R10, 1, 30, 30 */
		/* 820654B4h case   10:*/		cpu::op::rlwimi<0,1,30,30>(regs,&regs.R11,regs.R10);
		/* 820654B4h case   10:*/		return 0x820654B8;
		  /* 820654B8h */ case   11:  		/* stw R11, <#[R31 + 10548]> */
		/* 820654B8h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00002934) );
		/* 820654B8h case   11:*/		return 0x820654BC;
		  /* 820654BCh */ case   12:  		/* ld R11, <#[R31 + 16]> */
		/* 820654BCh case   12:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820654BCh case   12:*/		return 0x820654C0;
		  /* 820654C0h */ case   13:  		/* ori R11, R11, 2048 */
		/* 820654C0h case   13:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x800);
		/* 820654C0h case   13:*/		return 0x820654C4;
		  /* 820654C4h */ case   14:  		/* std R11, <#[R31 + 16]> */
		/* 820654C4h case   14:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820654C4h case   14:*/		return 0x820654C8;
		  /* 820654C8h */ case   15:  		/* oris R11, R11, 2 */
		/* 820654C8h case   15:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x2);
		/* 820654C8h case   15:*/		return 0x820654CC;
		  /* 820654CCh */ case   16:  		/* std R11, <#[R31 + 16]> */
		/* 820654CCh case   16:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820654CCh case   16:*/		return 0x820654D0;
		  /* 820654D0h */ case   17:  		/* lwz R11, <#[R31 + 12312]> */
		/* 820654D0h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00003018) );
		/* 820654D0h case   17:*/		return 0x820654D4;
		  /* 820654D4h */ case   18:  		/* lwz R10, <#[R31 + 10548]> */
		/* 820654D4h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00002934) );
		/* 820654D4h case   18:*/		return 0x820654D8;
		  /* 820654D8h */ case   19:  		/* lwz R9, <#[R31 + 12832]> */
		/* 820654D8h case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00003220) );
		/* 820654D8h case   19:*/		return 0x820654DC;
		  /* 820654DCh */ case   20:  		/* subfic R9, R9, 0 */
		/* 820654DCh case   20:*/		cpu::op::subfic<0>(regs,&regs.R9,regs.R9,0x0);
		/* 820654DCh case   20:*/		return 0x820654E0;
		  /* 820654E0h */ case   21:  		/* subfe R9, R9, R9 */
		/* 820654E0h case   21:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 820654E0h case   21:*/		return 0x820654E4;
		  /* 820654E4h */ case   22:  		/* stw R11, <#[R31 + 12312]> */
		/* 820654E4h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00003018) );
		/* 820654E4h case   22:*/		return 0x820654E8;
		  /* 820654E8h */ case   23:  		/* and R11, R9, R11 */
		/* 820654E8h case   23:*/		cpu::op::and<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 820654E8h case   23:*/		return 0x820654EC;
		  /* 820654ECh */ case   24:  		/* rlwimi R11, R10, 0, 0, 30 */
		/* 820654ECh case   24:*/		cpu::op::rlwimi<0,0,0,30>(regs,&regs.R11,regs.R10);
		/* 820654ECh case   24:*/		return 0x820654F0;
		  /* 820654F0h */ case   25:  		/* stw R11, <#[R31 + 10548]> */
		/* 820654F0h case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00002934) );
		/* 820654F0h case   25:*/		return 0x820654F4;
		  /* 820654F4h */ case   26:  		/* ld R11, <#[R31 + 16]> */
		/* 820654F4h case   26:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820654F4h case   26:*/		return 0x820654F8;
		  /* 820654F8h */ case   27:  		/* ori R11, R11, 2048 */
		/* 820654F8h case   27:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x800);
		/* 820654F8h case   27:*/		return 0x820654FC;
		  /* 820654FCh */ case   28:  		/* std R11, <#[R31 + 16]> */
		/* 820654FCh case   28:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820654FCh case   28:*/		return 0x82065500;
		  /* 82065500h */ case   29:  		/* oris R11, R11, 2 */
		/* 82065500h case   29:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82065500h case   29:*/		return 0x82065504;
		  /* 82065504h */ case   30:  		/* std R11, <#[R31 + 16]> */
		/* 82065504h case   30:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82065504h case   30:*/		return 0x82065508;
		  /* 82065508h */ case   31:  		/* addi R1, R1, 112 */
		/* 82065508h case   31:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82065508h case   31:*/		return 0x8206550C;
		  /* 8206550Ch */ case   32:  		/* lwz R12, <#[R1 - 8]> */
		/* 8206550Ch case   32:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206550Ch case   32:*/		return 0x82065510;
		  /* 82065510h */ case   33:  		/* mtspr LR, R12 */
		/* 82065510h case   33:*/		regs.LR = regs.R12;
		/* 82065510h case   33:*/		return 0x82065514;
		  /* 82065514h */ case   34:  		/* ld R30, <#[R1 - 24]> */
		/* 82065514h case   34:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82065514h case   34:*/		return 0x82065518;
		  /* 82065518h */ case   35:  		/* ld R31, <#[R1 - 16]> */
		/* 82065518h case   35:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82065518h case   35:*/		return 0x8206551C;
		  /* 8206551Ch */ case   36:  		/* bclr 20, CR0_LT */
		/* 8206551Ch case   36:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206551Ch case   36:*/		return 0x82065520;
	}
	return 0x82065520;
} // Block from 8206548Ch-82065520h (37 instructions)

//////////////////////////////////////////////////////
// Block at 82065520h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065520( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065520) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065520);
		  /* 82065520h */ case    0:  		/* lwz R11, <#[R3 + 40]> */
		/* 82065520h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000028) );
		/* 82065520h case    0:*/		return 0x82065524;
		  /* 82065524h */ case    1:  		/* lwz R10, <#[R3 + 48]> */
		/* 82065524h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000030) );
		/* 82065524h case    1:*/		return 0x82065528;
		  /* 82065528h */ case    2:  		/* rlwinm R11, R11, 2, 30, 30 */
		/* 82065528h case    2:*/		cpu::op::rlwinm<0,2,30,30>(regs,&regs.R11,regs.R11);
		/* 82065528h case    2:*/		return 0x8206552C;
		  /* 8206552Ch */ case    3:  		/* rlwinm. R10, R10, 23, 30, 31 */
		/* 8206552Ch case    3:*/		cpu::op::rlwinm<1,23,30,31>(regs,&regs.R10,regs.R10);
		/* 8206552Ch case    3:*/		return 0x82065530;
		  /* 82065530h */ case    4:  		/* addi R11, R11, 1 */
		/* 82065530h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82065530h case    4:*/		return 0x82065534;
		  /* 82065534h */ case    5:  		/* bc 4, CR0_EQ, 32 */
		/* 82065534h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82065554;  }
		/* 82065534h case    5:*/		return 0x82065538;
		  /* 82065538h */ case    6:  		/* lwz R10, <#[R3 + 36]> */
		/* 82065538h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000024) );
		/* 82065538h case    6:*/		return 0x8206553C;
		  /* 8206553Ch */ case    7:  		/* li R9, 1 */
		/* 8206553Ch case    7:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8206553Ch case    7:*/		return 0x82065540;
		  /* 82065540h */ case    8:  		/* rlwinm R10, R10, 0, 8, 31 */
		/* 82065540h case    8:*/		cpu::op::rlwinm<0,0,8,31>(regs,&regs.R10,regs.R10);
		/* 82065540h case    8:*/		return 0x82065544;
		  /* 82065544h */ case    9:  		/* add R11, R10, R11 */
		/* 82065544h case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82065544h case    9:*/		return 0x82065548;
		  /* 82065548h */ case   10:  		/* stw R11, <#[R4]> */
		/* 82065548h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 82065548h case   10:*/		return 0x8206554C;
		  /* 8206554Ch */ case   11:  		/* stw R9, <#[R5]> */
		/* 8206554Ch case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R5 + 0x00000000) );
		/* 8206554Ch case   11:*/		return 0x82065550;
		  /* 82065550h */ case   12:  		/* b 96 */
		/* 82065550h case   12:*/		return 0x820655B0;
		/* 82065550h case   12:*/		return 0x82065554;
	}
	return 0x82065554;
} // Block from 82065520h-82065554h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82065554h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065554( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065554) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065554);
		  /* 82065554h */ case    0:  		/* cmplwi CR6, R10, 2 */
		/* 82065554h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000002);
		/* 82065554h case    0:*/		return 0x82065558;
		  /* 82065558h */ case    1:  		/* lwz R10, <#[R3 + 36]> */
		/* 82065558h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000024) );
		/* 82065558h case    1:*/		return 0x8206555C;
		  /* 8206555Ch */ case    2:  		/* bc 4, CR6_EQ, 52 */
		/* 8206555Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x82065590;  }
		/* 8206555Ch case    2:*/		return 0x82065560;
		  /* 82065560h */ case    3:  		/* rlwinm R10, R10, 0, 21, 31 */
		/* 82065560h case    3:*/		cpu::op::rlwinm<0,0,21,31>(regs,&regs.R10,regs.R10);
		/* 82065560h case    3:*/		return 0x82065564;
		  /* 82065564h */ case    4:  		/* add R10, R10, R11 */
		/* 82065564h case    4:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 82065564h case    4:*/		return 0x82065568;
		  /* 82065568h */ case    5:  		/* stw R10, <#[R4]> */
		/* 82065568h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 82065568h case    5:*/		return 0x8206556C;
		  /* 8206556Ch */ case    6:  		/* lwz R10, <#[R3 + 36]> */
		/* 8206556Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000024) );
		/* 8206556Ch case    6:*/		return 0x82065570;
		  /* 82065570h */ case    7:  		/* rlwinm R10, R10, 21, 21, 31 */
		/* 82065570h case    7:*/		cpu::op::rlwinm<0,21,21,31>(regs,&regs.R10,regs.R10);
		/* 82065570h case    7:*/		return 0x82065574;
		  /* 82065574h */ case    8:  		/* add R10, R10, R11 */
		/* 82065574h case    8:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 82065574h case    8:*/		return 0x82065578;
		  /* 82065578h */ case    9:  		/* stw R10, <#[R5]> */
		/* 82065578h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R5 + 0x00000000) );
		/* 82065578h case    9:*/		return 0x8206557C;
		  /* 8206557Ch */ case   10:  		/* lwz R10, <#[R3 + 36]> */
		/* 8206557Ch case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000024) );
		/* 8206557Ch case   10:*/		return 0x82065580;
		  /* 82065580h */ case   11:  		/* rlwinm R10, R10, 10, 22, 31 */
		/* 82065580h case   11:*/		cpu::op::rlwinm<0,10,22,31>(regs,&regs.R10,regs.R10);
		/* 82065580h case   11:*/		return 0x82065584;
		  /* 82065584h */ case   12:  		/* add R11, R10, R11 */
		/* 82065584h case   12:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82065584h case   12:*/		return 0x82065588;
		  /* 82065588h */ case   13:  		/* stw R11, <#[R6]> */
		/* 82065588h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000000) );
		/* 82065588h case   13:*/		return 0x8206558C;
		  /* 8206558Ch */ case   14:  		/* bclr 20, CR0_LT */
		/* 8206558Ch case   14:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206558Ch case   14:*/		return 0x82065590;
	}
	return 0x82065590;
} // Block from 82065554h-82065590h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82065590h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065590( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065590) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065590);
		  /* 82065590h */ case    0:  		/* rlwinm R10, R10, 0, 19, 31 */
		/* 82065590h case    0:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R10,regs.R10);
		/* 82065590h case    0:*/		return 0x82065594;
		  /* 82065594h */ case    1:  		/* li R9, 1 */
		/* 82065594h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82065594h case    1:*/		return 0x82065598;
		  /* 82065598h */ case    2:  		/* add R10, R10, R11 */
		/* 82065598h case    2:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 82065598h case    2:*/		return 0x8206559C;
		  /* 8206559Ch */ case    3:  		/* stw R10, <#[R4]> */
		/* 8206559Ch case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 8206559Ch case    3:*/		return 0x820655A0;
		  /* 820655A0h */ case    4:  		/* lwz R10, <#[R3 + 36]> */
		/* 820655A0h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000024) );
		/* 820655A0h case    4:*/		return 0x820655A4;
		  /* 820655A4h */ case    5:  		/* rlwinm R10, R10, 19, 19, 31 */
		/* 820655A4h case    5:*/		cpu::op::rlwinm<0,19,19,31>(regs,&regs.R10,regs.R10);
		/* 820655A4h case    5:*/		return 0x820655A8;
		  /* 820655A8h */ case    6:  		/* add R11, R10, R11 */
		/* 820655A8h case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820655A8h case    6:*/		return 0x820655AC;
		  /* 820655ACh */ case    7:  		/* stw R11, <#[R5]> */
		/* 820655ACh case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 820655ACh case    7:*/		return 0x820655B0;
	}
	return 0x820655B0;
} // Block from 82065590h-820655B0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820655B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820655B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820655B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820655B0);
		  /* 820655B0h */ case    0:  		/* stw R9, <#[R6]> */
		/* 820655B0h case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R6 + 0x00000000) );
		/* 820655B0h case    0:*/		return 0x820655B4;
		  /* 820655B4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820655B4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820655B4h case    1:*/		return 0x820655B8;
	}
	return 0x820655B8;
} // Block from 820655B0h-820655B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820655B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820655B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820655B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820655B8);
		  /* 820655B8h */ case    0:  		/* lwz R11, <#[R3 + 12]> */
		/* 820655B8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 820655B8h case    0:*/		return 0x820655BC;
		  /* 820655BCh */ case    1:  		/* lwz R10, <#[R3 + 20]> */
		/* 820655BCh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000014) );
		/* 820655BCh case    1:*/		return 0x820655C0;
		  /* 820655C0h */ case    2:  		/* rlwinm R11, R11, 2, 30, 30 */
		/* 820655C0h case    2:*/		cpu::op::rlwinm<0,2,30,30>(regs,&regs.R11,regs.R11);
		/* 820655C0h case    2:*/		return 0x820655C4;
		  /* 820655C4h */ case    3:  		/* rlwinm. R10, R10, 23, 30, 31 */
		/* 820655C4h case    3:*/		cpu::op::rlwinm<1,23,30,31>(regs,&regs.R10,regs.R10);
		/* 820655C4h case    3:*/		return 0x820655C8;
		  /* 820655C8h */ case    4:  		/* addi R11, R11, 1 */
		/* 820655C8h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820655C8h case    4:*/		return 0x820655CC;
		  /* 820655CCh */ case    5:  		/* bc 4, CR0_EQ, 36 */
		/* 820655CCh case    5:*/		if ( !regs.CR[0].eq ) { return 0x820655F0;  }
		/* 820655CCh case    5:*/		return 0x820655D0;
		  /* 820655D0h */ case    6:  		/* lwz R10, <#[R3 + 8]> */
		/* 820655D0h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 820655D0h case    6:*/		return 0x820655D4;
		  /* 820655D4h */ case    7:  		/* li R9, 1 */
		/* 820655D4h case    7:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 820655D4h case    7:*/		return 0x820655D8;
		  /* 820655D8h */ case    8:  		/* rlwinm R10, R10, 0, 8, 31 */
		/* 820655D8h case    8:*/		cpu::op::rlwinm<0,0,8,31>(regs,&regs.R10,regs.R10);
		/* 820655D8h case    8:*/		return 0x820655DC;
		  /* 820655DCh */ case    9:  		/* add R11, R10, R11 */
		/* 820655DCh case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820655DCh case    9:*/		return 0x820655E0;
		  /* 820655E0h */ case   10:  		/* stw R11, <#[R4]> */
		/* 820655E0h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 820655E0h case   10:*/		return 0x820655E4;
		  /* 820655E4h */ case   11:  		/* stw R9, <#[R5]> */
		/* 820655E4h case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R5 + 0x00000000) );
		/* 820655E4h case   11:*/		return 0x820655E8;
		  /* 820655E8h */ case   12:  		/* stw R9, <#[R6]> */
		/* 820655E8h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R6 + 0x00000000) );
		/* 820655E8h case   12:*/		return 0x820655EC;
		  /* 820655ECh */ case   13:  		/* bclr 20, CR0_LT */
		/* 820655ECh case   13:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820655ECh case   13:*/		return 0x820655F0;
	}
	return 0x820655F0;
} // Block from 820655B8h-820655F0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820655F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820655F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820655F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820655F0);
		  /* 820655F0h */ case    0:  		/* cmplwi CR6, R10, 2 */
		/* 820655F0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000002);
		/* 820655F0h case    0:*/		return 0x820655F4;
		  /* 820655F4h */ case    1:  		/* lwz R10, <#[R3 + 8]> */
		/* 820655F4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 820655F4h case    1:*/		return 0x820655F8;
		  /* 820655F8h */ case    2:  		/* bc 4, CR6_EQ, 48 */
		/* 820655F8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82065628;  }
		/* 820655F8h case    2:*/		return 0x820655FC;
		  /* 820655FCh */ case    3:  		/* rlwinm R10, R10, 0, 21, 31 */
		/* 820655FCh case    3:*/		cpu::op::rlwinm<0,0,21,31>(regs,&regs.R10,regs.R10);
		/* 820655FCh case    3:*/		return 0x82065600;
		  /* 82065600h */ case    4:  		/* add R10, R10, R11 */
		/* 82065600h case    4:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 82065600h case    4:*/		return 0x82065604;
		  /* 82065604h */ case    5:  		/* stw R10, <#[R4]> */
		/* 82065604h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 82065604h case    5:*/		return 0x82065608;
		  /* 82065608h */ case    6:  		/* lwz R10, <#[R3 + 8]> */
		/* 82065608h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 82065608h case    6:*/		return 0x8206560C;
		  /* 8206560Ch */ case    7:  		/* rlwinm R10, R10, 21, 21, 31 */
		/* 8206560Ch case    7:*/		cpu::op::rlwinm<0,21,21,31>(regs,&regs.R10,regs.R10);
		/* 8206560Ch case    7:*/		return 0x82065610;
		  /* 82065610h */ case    8:  		/* add R10, R10, R11 */
		/* 82065610h case    8:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 82065610h case    8:*/		return 0x82065614;
		  /* 82065614h */ case    9:  		/* stw R10, <#[R5]> */
		/* 82065614h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R5 + 0x00000000) );
		/* 82065614h case    9:*/		return 0x82065618;
		  /* 82065618h */ case   10:  		/* lwz R10, <#[R3 + 8]> */
		/* 82065618h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 82065618h case   10:*/		return 0x8206561C;
		  /* 8206561Ch */ case   11:  		/* rlwinm R10, R10, 10, 22, 31 */
		/* 8206561Ch case   11:*/		cpu::op::rlwinm<0,10,22,31>(regs,&regs.R10,regs.R10);
		/* 8206561Ch case   11:*/		return 0x82065620;
		  /* 82065620h */ case   12:  		/* add R11, R10, R11 */
		/* 82065620h case   12:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82065620h case   12:*/		return 0x82065624;
		  /* 82065624h */ case   13:  		/* b 44 */
		/* 82065624h case   13:*/		return 0x82065650;
		/* 82065624h case   13:*/		return 0x82065628;
	}
	return 0x82065628;
} // Block from 820655F0h-82065628h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82065628h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065628( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065628) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065628);
		  /* 82065628h */ case    0:  		/* rlwinm R10, R10, 0, 19, 31 */
		/* 82065628h case    0:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R10,regs.R10);
		/* 82065628h case    0:*/		return 0x8206562C;
		  /* 8206562Ch */ case    1:  		/* add R10, R10, R11 */
		/* 8206562Ch case    1:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8206562Ch case    1:*/		return 0x82065630;
		  /* 82065630h */ case    2:  		/* stw R10, <#[R4]> */
		/* 82065630h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 82065630h case    2:*/		return 0x82065634;
		  /* 82065634h */ case    3:  		/* lwz R10, <#[R3 + 8]> */
		/* 82065634h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 82065634h case    3:*/		return 0x82065638;
		  /* 82065638h */ case    4:  		/* rlwinm R10, R10, 19, 19, 31 */
		/* 82065638h case    4:*/		cpu::op::rlwinm<0,19,19,31>(regs,&regs.R10,regs.R10);
		/* 82065638h case    4:*/		return 0x8206563C;
		  /* 8206563Ch */ case    5:  		/* add R11, R10, R11 */
		/* 8206563Ch case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8206563Ch case    5:*/		return 0x82065640;
		  /* 82065640h */ case    6:  		/* stw R11, <#[R5]> */
		/* 82065640h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 82065640h case    6:*/		return 0x82065644;
		  /* 82065644h */ case    7:  		/* lwz R11, <#[R3 + 8]> */
		/* 82065644h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82065644h case    7:*/		return 0x82065648;
		  /* 82065648h */ case    8:  		/* rlwinm R11, R11, 6, 26, 31 */
		/* 82065648h case    8:*/		cpu::op::rlwinm<0,6,26,31>(regs,&regs.R11,regs.R11);
		/* 82065648h case    8:*/		return 0x8206564C;
		  /* 8206564Ch */ case    9:  		/* addi R11, R11, 1 */
		/* 8206564Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8206564Ch case    9:*/		return 0x82065650;
	}
	return 0x82065650;
} // Block from 82065628h-82065650h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82065650h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065650( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065650) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065650);
		  /* 82065650h */ case    0:  		/* stw R11, <#[R6]> */
		/* 82065650h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000000) );
		/* 82065650h case    0:*/		return 0x82065654;
		  /* 82065654h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82065654h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82065654h case    1:*/		return 0x82065658;
	}
	return 0x82065658;
} // Block from 82065650h-82065658h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82065658h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065658( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065658) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065658);
		  /* 82065658h */ case    0:  		/* rlwinm R9, R5, 0, 26, 31 */
		/* 82065658h case    0:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R9,regs.R5);
		/* 82065658h case    0:*/		return 0x8206565C;
		  /* 8206565Ch */ case    1:  		/* li R8, 4 */
		/* 8206565Ch case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 8206565Ch case    1:*/		return 0x82065660;
		  /* 82065660h */ case    2:  		/* mr R11, R3 */
		/* 82065660h case    2:*/		regs.R11 = regs.R3;
		/* 82065660h case    2:*/		return 0x82065664;
		  /* 82065664h */ case    3:  		/* mr R10, R4 */
		/* 82065664h case    3:*/		regs.R10 = regs.R4;
		/* 82065664h case    3:*/		return 0x82065668;
		  /* 82065668h */ case    4:  		/* cmpwi CR6, R6, 1 */
		/* 82065668h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x00000001);
		/* 82065668h case    4:*/		return 0x8206566C;
		  /* 8206566Ch */ case    5:  		/* bc 12, CR6_LT, 8 */
		/* 8206566Ch case    5:*/		if ( regs.CR[6].lt ) { return 0x82065674;  }
		/* 8206566Ch case    5:*/		return 0x82065670;
		  /* 82065670h */ case    6:  		/* rlwinm R10, R4, 1, 0, 30 */
		/* 82065670h case    6:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R4);
		/* 82065670h case    6:*/		return 0x82065674;
	}
	return 0x82065674;
} // Block from 82065658h-82065674h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82065674h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065674( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065674) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065674);
		  /* 82065674h */ case    0:  		/* cmpwi CR6, R6, 2 */
		/* 82065674h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x00000002);
		/* 82065674h case    0:*/		return 0x82065678;
		  /* 82065678h */ case    1:  		/* bc 4, CR6_EQ, 8 */
		/* 82065678h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82065680;  }
		/* 82065678h case    1:*/		return 0x8206567C;
		  /* 8206567Ch */ case    2:  		/* rlwinm R11, R3, 1, 0, 30 */
		/* 8206567Ch case    2:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R3);
		/* 8206567Ch case    2:*/		return 0x82065680;
	}
	return 0x82065680;
} // Block from 82065674h-82065680h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82065680h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065680( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065680) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065680);
		  /* 82065680h */ case    0:  		/* addi R11, R11, 79 */
		/* 82065680h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4F);
		/* 82065680h case    0:*/		return 0x82065684;
		  /* 82065684h */ case    1:  		/* li R7, 80 */
		/* 82065684h case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x50);
		/* 82065684h case    1:*/		return 0x82065688;
		  /* 82065688h */ case    2:  		/* addi R10, R10, 15 */
		/* 82065688h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xF);
		/* 82065688h case    2:*/		return 0x8206568C;
		  /* 8206568Ch */ case    3:  		/* divwu R7, R11, R7 */
		/* 8206568Ch case    3:*/		cpu::op::divwu<0>(regs,&regs.R7,regs.R11,regs.R7);
		/* 8206568Ch case    3:*/		return 0x82065690;
		  /* 82065690h */ case    4:  		/* rlwinm R11, R10, 0, 0, 27 */
		/* 82065690h case    4:*/		cpu::op::rlwinm<0,0,0,27>(regs,&regs.R11,regs.R10);
		/* 82065690h case    4:*/		return 0x82065694;
		  /* 82065694h */ case    5:  		/* mulli R10, R7, 80 */
		/* 82065694h case    5:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R7,0x50);
		/* 82065694h case    5:*/		return 0x82065698;
		  /* 82065698h */ case    6:  		/* cmpwi CR6, R9, 21 */
		/* 82065698h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000015);
		/* 82065698h case    6:*/		return 0x8206569C;
		  /* 8206569Ch */ case    7:  		/* bc 12, CR6_EQ, 20 */
		/* 8206569Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x820656B0;  }
		/* 8206569Ch case    7:*/		return 0x820656A0;
		  /* 820656A0h */ case    8:  		/* cmpwi CR6, R9, 32 */
		/* 820656A0h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000020);
		/* 820656A0h case    8:*/		return 0x820656A4;
		  /* 820656A4h */ case    9:  		/* bc 12, CR6_EQ, 12 */
		/* 820656A4h case    9:*/		if ( regs.CR[6].eq ) { return 0x820656B0;  }
		/* 820656A4h case    9:*/		return 0x820656A8;
		  /* 820656A8h */ case   10:  		/* cmpwi CR6, R9, 37 */
		/* 820656A8h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000025);
		/* 820656A8h case   10:*/		return 0x820656AC;
		  /* 820656ACh */ case   11:  		/* bc 4, CR6_EQ, 8 */
		/* 820656ACh case   11:*/		if ( !regs.CR[6].eq ) { return 0x820656B4;  }
		/* 820656ACh case   11:*/		return 0x820656B0;
	}
	return 0x820656B0;
} // Block from 82065680h-820656B0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820656B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820656B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820656B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820656B0);
		  /* 820656B0h */ case    0:  		/* li R8, 8 */
		/* 820656B0h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x8);
		/* 820656B0h case    0:*/		return 0x820656B4;
	}
	return 0x820656B4;
} // Block from 820656B0h-820656B4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820656B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820656B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820656B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820656B4);
		  /* 820656B4h */ case    0:  		/* mullw R11, R11, R10 */
		/* 820656B4h case    0:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820656B4h case    0:*/		return 0x820656B8;
	}
	return 0x820656B8;
} // Block from 820656B4h-820656B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820656B8h
// Function '?ClearRect@D3D@@YAXPAVCDevice@1@JJJJPBU__vector4@@MTGPU_SURFACEINFO@@TGPU_COLORINFO@@KKKK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820656B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820656B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820656B8);
		  /* 820656B8h */ case    0:  		/* mullw R11, R11, R8 */
		/* 820656B8h case    0:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 820656B8h case    0:*/		return 0x820656BC;
		  /* 820656BCh */ case    1:  		/* li R10, 5120 */
		/* 820656BCh case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1400);
		/* 820656BCh case    1:*/		return 0x820656C0;
		  /* 820656C0h */ case    2:  		/* divwu R3, R11, R10 */
		/* 820656C0h case    2:*/		cpu::op::divwu<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 820656C0h case    2:*/		return 0x820656C4;
		  /* 820656C4h */ case    3:  		/* bclr 20, CR0_LT */
		/* 820656C4h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820656C4h case    3:*/		return 0x820656C8;
	}
	return 0x820656C8;
} // Block from 820656B8h-820656C8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820656C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820656C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820656C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820656C8);
		  /* 820656C8h */ case    0:  		/* cmplwi CR6, R3, 44 */
		/* 820656C8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x0000002C);
		/* 820656C8h case    0:*/		return 0x820656CC;
		  /* 820656CCh */ case    1:  		/* bc 12, CR6_GT, 84 */
		/* 820656CCh case    1:*/		if ( regs.CR[6].gt ) { return 0x82065720;  }
		/* 820656CCh case    1:*/		return 0x820656D0;
		  /* 820656D0h */ case    2:  		/* bc 12, CR6_EQ, 72 */
		/* 820656D0h case    2:*/		if ( regs.CR[6].eq ) { return 0x82065718;  }
		/* 820656D0h case    2:*/		return 0x820656D4;
		  /* 820656D4h */ case    3:  		/* cmplwi CR6, R3, 11 */
		/* 820656D4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x0000000B);
		/* 820656D4h case    3:*/		return 0x820656D8;
		  /* 820656D8h */ case    4:  		/* bc 12, CR6_LT, 112 */
		/* 820656D8h case    4:*/		if ( regs.CR[6].lt ) { return 0x82065748;  }
		/* 820656D8h case    4:*/		return 0x820656DC;
		  /* 820656DCh */ case    5:  		/* cmplwi CR6, R3, 12 */
		/* 820656DCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x0000000C);
		/* 820656DCh case    5:*/		return 0x820656E0;
		  /* 820656E0h */ case    6:  		/* bc 4, CR6_GT, 36 */
		/* 820656E0h case    6:*/		if ( !regs.CR[6].gt ) { return 0x82065704;  }
		/* 820656E0h case    6:*/		return 0x820656E4;
		  /* 820656E4h */ case    7:  		/* cmplwi CR6, R3, 17 */
		/* 820656E4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000011);
		/* 820656E4h case    7:*/		return 0x820656E8;
		  /* 820656E8h */ case    8:  		/* bc 4, CR6_GT, 96 */
		/* 820656E8h case    8:*/		if ( !regs.CR[6].gt ) { return 0x82065748;  }
		/* 820656E8h case    8:*/		return 0x820656EC;
		  /* 820656ECh */ case    9:  		/* cmplwi CR6, R3, 20 */
		/* 820656ECh case    9:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000014);
		/* 820656ECh case    9:*/		return 0x820656F0;
		  /* 820656F0h */ case   10:  		/* bc 4, CR6_GT, 96 */
		/* 820656F0h case   10:*/		if ( !regs.CR[6].gt ) { return 0x82065750;  }
		/* 820656F0h case   10:*/		return 0x820656F4;
		  /* 820656F4h */ case   11:  		/* cmplwi CR6, R3, 39 */
		/* 820656F4h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000027);
		/* 820656F4h case   11:*/		return 0x820656F8;
		  /* 820656F8h */ case   12:  		/* bc 12, CR6_EQ, 32 */
		/* 820656F8h case   12:*/		if ( regs.CR[6].eq ) { return 0x82065718;  }
		/* 820656F8h case   12:*/		return 0x820656FC;
		  /* 820656FCh */ case   13:  		/* cmplwi CR6, R3, 40 */
		/* 820656FCh case   13:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000028);
		/* 820656FCh case   13:*/		return 0x82065700;
		  /* 82065700h */ case   14:  		/* bc 4, CR6_EQ, 72 */
		/* 82065700h case   14:*/		if ( !regs.CR[6].eq ) { return 0x82065748;  }
		/* 82065700h case   14:*/		return 0x82065704;
	}
	return 0x82065704;
} // Block from 820656C8h-82065704h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82065704h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065704( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065704) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065704);
		  /* 82065704h */ case    0:  		/* li R11, 2 */
		/* 82065704h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 82065704h case    0:*/		return 0x82065708;
		  /* 82065708h */ case    1:  		/* li R10, 1 */
		/* 82065708h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82065708h case    1:*/		return 0x8206570C;
		  /* 8206570Ch */ case    2:  		/* stw R11, <#[R4]> */
		/* 8206570Ch case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 8206570Ch case    2:*/		return 0x82065710;
		  /* 82065710h */ case    3:  		/* stw R10, <#[R5]> */
		/* 82065710h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R5 + 0x00000000) );
		/* 82065710h case    3:*/		return 0x82065714;
		  /* 82065714h */ case    4:  		/* bclr 20, CR0_LT */
		/* 82065714h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82065714h case    4:*/		return 0x82065718;
	}
	return 0x82065718;
} // Block from 82065704h-82065718h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82065718h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065718( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065718) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065718);
		  /* 82065718h */ case    0:  		/* li R11, 4 */
		/* 82065718h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x4);
		/* 82065718h case    0:*/		return 0x8206571C;
		  /* 8206571Ch */ case    1:  		/* b -20 */
		/* 8206571Ch case    1:*/		return 0x82065708;
		/* 8206571Ch case    1:*/		return 0x82065720;
	}
	return 0x82065720;
} // Block from 82065718h-82065720h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82065720h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065720( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065720) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065720);
		  /* 82065720h */ case    0:  		/* cmplwi CR6, R3, 49 */
		/* 82065720h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000031);
		/* 82065720h case    0:*/		return 0x82065724;
		  /* 82065724h */ case    1:  		/* bc 12, CR6_EQ, 44 */
		/* 82065724h case    1:*/		if ( regs.CR[6].eq ) { return 0x82065750;  }
		/* 82065724h case    1:*/		return 0x82065728;
		  /* 82065728h */ case    2:  		/* cmplwi CR6, R3, 50 */
		/* 82065728h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000032);
		/* 82065728h case    2:*/		return 0x8206572C;
		  /* 8206572Ch */ case    3:  		/* bc 4, CR6_GT, 28 */
		/* 8206572Ch case    3:*/		if ( !regs.CR[6].gt ) { return 0x82065748;  }
		/* 8206572Ch case    3:*/		return 0x82065730;
		  /* 82065730h */ case    4:  		/* cmplwi CR6, R3, 53 */
		/* 82065730h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000035);
		/* 82065730h case    4:*/		return 0x82065734;
		  /* 82065734h */ case    5:  		/* bc 4, CR6_GT, 28 */
		/* 82065734h case    5:*/		if ( !regs.CR[6].gt ) { return 0x82065750;  }
		/* 82065734h case    5:*/		return 0x82065738;
		  /* 82065738h */ case    6:  		/* cmplwi CR6, R3, 57 */
		/* 82065738h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000039);
		/* 82065738h case    6:*/		return 0x8206573C;
		  /* 8206573Ch */ case    7:  		/* bc 4, CR6_GT, 12 */
		/* 8206573Ch case    7:*/		if ( !regs.CR[6].gt ) { return 0x82065748;  }
		/* 8206573Ch case    7:*/		return 0x82065740;
		  /* 82065740h */ case    8:  		/* cmplwi CR6, R3, 61 */
		/* 82065740h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x0000003D);
		/* 82065740h case    8:*/		return 0x82065744;
		  /* 82065744h */ case    9:  		/* bc 4, CR6_GT, 12 */
		/* 82065744h case    9:*/		if ( !regs.CR[6].gt ) { return 0x82065750;  }
		/* 82065744h case    9:*/		return 0x82065748;
	}
	return 0x82065748;
} // Block from 82065720h-82065748h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82065748h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065748( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065748) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065748);
		  /* 82065748h */ case    0:  		/* li R11, 1 */
		/* 82065748h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82065748h case    0:*/		return 0x8206574C;
		  /* 8206574Ch */ case    1:  		/* b 8 */
		/* 8206574Ch case    1:*/		return 0x82065754;
		/* 8206574Ch case    1:*/		return 0x82065750;
	}
	return 0x82065750;
} // Block from 82065748h-82065750h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82065750h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065750( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065750) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065750);
		  /* 82065750h */ case    0:  		/* li R11, 4 */
		/* 82065750h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x4);
		/* 82065750h case    0:*/		return 0x82065754;
	}
	return 0x82065754;
} // Block from 82065750h-82065754h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82065754h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065754( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065754) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065754);
		  /* 82065754h */ case    0:  		/* stw R11, <#[R4]> */
		/* 82065754h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 82065754h case    0:*/		return 0x82065758;
		  /* 82065758h */ case    1:  		/* stw R11, <#[R5]> */
		/* 82065758h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 82065758h case    1:*/		return 0x8206575C;
		  /* 8206575Ch */ case    2:  		/* bclr 20, CR0_LT */
		/* 8206575Ch case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206575Ch case    2:*/		return 0x82065760;
	}
	return 0x82065760;
} // Block from 82065754h-82065760h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82065760h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065760( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065760) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065760);
		  /* 82065760h */ case    0:  		/* rlwinm R9, R6, 1, 0, 30 */
		/* 82065760h case    0:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R9,regs.R6);
		/* 82065760h case    0:*/		return 0x82065764;
		  /* 82065764h */ case    1:  		/* subf R8, R9, R5 */
		/* 82065764h case    1:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R9,regs.R5);
		/* 82065764h case    1:*/		return 0x82065768;
		  /* 82065768h */ case    2:  		/* cmpwi CR6, R8, 1 */
		/* 82065768h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000001);
		/* 82065768h case    2:*/		return 0x8206576C;
		  /* 8206576Ch */ case    3:  		/* mr R11, R8 */
		/* 8206576Ch case    3:*/		regs.R11 = regs.R8;
		/* 8206576Ch case    3:*/		return 0x82065770;
		  /* 82065770h */ case    4:  		/* bc 12, CR6_GT, 8 */
		/* 82065770h case    4:*/		if ( regs.CR[6].gt ) { return 0x82065778;  }
		/* 82065770h case    4:*/		return 0x82065774;
		  /* 82065774h */ case    5:  		/* li R11, 1 */
		/* 82065774h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82065774h case    5:*/		return 0x82065778;
	}
	return 0x82065778;
} // Block from 82065760h-82065778h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82065778h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065778( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065778) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065778);
		  /* 82065778h */ case    0:  		/* subf R7, R9, R4 */
		/* 82065778h case    0:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R9,regs.R4);
		/* 82065778h case    0:*/		return 0x8206577C;
		  /* 8206577Ch */ case    1:  		/* cmplw CR6, R7, R11 */
		/* 8206577Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 8206577Ch case    1:*/		return 0x82065780;
		  /* 82065780h */ case    2:  		/* bc 4, CR6_GT, 12 */
		/* 82065780h case    2:*/		if ( !regs.CR[6].gt ) { return 0x8206578C;  }
		/* 82065780h case    2:*/		return 0x82065784;
		  /* 82065784h */ case    3:  		/* mr R10, R7 */
		/* 82065784h case    3:*/		regs.R10 = regs.R7;
		/* 82065784h case    3:*/		return 0x82065788;
		  /* 82065788h */ case    4:  		/* b 20 */
		/* 82065788h case    4:*/		return 0x8206579C;
		/* 82065788h case    4:*/		return 0x8206578C;
	}
	return 0x8206578C;
} // Block from 82065778h-8206578Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8206578Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206578C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206578C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206578C);
		  /* 8206578Ch */ case    0:  		/* cmpwi CR6, R8, 1 */
		/* 8206578Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000001);
		/* 8206578Ch case    0:*/		return 0x82065790;
		  /* 82065790h */ case    1:  		/* mr R10, R8 */
		/* 82065790h case    1:*/		regs.R10 = regs.R8;
		/* 82065790h case    1:*/		return 0x82065794;
		  /* 82065794h */ case    2:  		/* bc 12, CR6_GT, 8 */
		/* 82065794h case    2:*/		if ( regs.CR[6].gt ) { return 0x8206579C;  }
		/* 82065794h case    2:*/		return 0x82065798;
		  /* 82065798h */ case    3:  		/* li R10, 1 */
		/* 82065798h case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82065798h case    3:*/		return 0x8206579C;
	}
	return 0x8206579C;
} // Block from 8206578Ch-8206579Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8206579Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206579C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206579C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206579C);
		  /* 8206579Ch */ case    0:  		/* subf R11, R9, R3 */
		/* 8206579Ch case    0:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R9,regs.R3);
		/* 8206579Ch case    0:*/		return 0x820657A0;
		  /* 820657A0h */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 820657A0h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 820657A0h case    1:*/		return 0x820657A4;
		  /* 820657A4h */ case    2:  		/* bc 12, CR6_GT, 52 */
		/* 820657A4h case    2:*/		if ( regs.CR[6].gt ) { return 0x820657D8;  }
		/* 820657A4h case    2:*/		return 0x820657A8;
		  /* 820657A8h */ case    3:  		/* cmpwi CR6, R8, 1 */
		/* 820657A8h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000001);
		/* 820657A8h case    3:*/		return 0x820657AC;
		  /* 820657ACh */ case    4:  		/* mr R11, R8 */
		/* 820657ACh case    4:*/		regs.R11 = regs.R8;
		/* 820657ACh case    4:*/		return 0x820657B0;
		  /* 820657B0h */ case    5:  		/* bc 12, CR6_GT, 8 */
		/* 820657B0h case    5:*/		if ( regs.CR[6].gt ) { return 0x820657B8;  }
		/* 820657B0h case    5:*/		return 0x820657B4;
		  /* 820657B4h */ case    6:  		/* li R11, 1 */
		/* 820657B4h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820657B4h case    6:*/		return 0x820657B8;
	}
	return 0x820657B8;
} // Block from 8206579Ch-820657B8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820657B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820657B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820657B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820657B8);
		  /* 820657B8h */ case    0:  		/* cmplw CR6, R7, R11 */
		/* 820657B8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 820657B8h case    0:*/		return 0x820657BC;
		  /* 820657BCh */ case    1:  		/* bc 4, CR6_GT, 12 */
		/* 820657BCh case    1:*/		if ( !regs.CR[6].gt ) { return 0x820657C8;  }
		/* 820657BCh case    1:*/		return 0x820657C0;
		  /* 820657C0h */ case    2:  		/* mr R11, R7 */
		/* 820657C0h case    2:*/		regs.R11 = regs.R7;
		/* 820657C0h case    2:*/		return 0x820657C4;
		  /* 820657C4h */ case    3:  		/* b 20 */
		/* 820657C4h case    3:*/		return 0x820657D8;
		/* 820657C4h case    3:*/		return 0x820657C8;
	}
	return 0x820657C8;
} // Block from 820657B8h-820657C8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820657C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820657C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820657C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820657C8);
		  /* 820657C8h */ case    0:  		/* cmpwi CR6, R8, 1 */
		/* 820657C8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000001);
		/* 820657C8h case    0:*/		return 0x820657CC;
		  /* 820657CCh */ case    1:  		/* mr R11, R8 */
		/* 820657CCh case    1:*/		regs.R11 = regs.R8;
		/* 820657CCh case    1:*/		return 0x820657D0;
		  /* 820657D0h */ case    2:  		/* bc 12, CR6_GT, 8 */
		/* 820657D0h case    2:*/		if ( regs.CR[6].gt ) { return 0x820657D8;  }
		/* 820657D0h case    2:*/		return 0x820657D4;
		  /* 820657D4h */ case    3:  		/* li R11, 1 */
		/* 820657D4h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 820657D4h case    3:*/		return 0x820657D8;
	}
	return 0x820657D8;
} // Block from 820657C8h-820657D8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820657D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820657D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820657D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820657D8);
		  /* 820657D8h */ case    0:  		/* cntlzw R11, R11 */
		/* 820657D8h case    0:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820657D8h case    0:*/		return 0x820657DC;
		  /* 820657DCh */ case    1:  		/* subfic R3, R11, 32 */
		/* 820657DCh case    1:*/		cpu::op::subfic<0>(regs,&regs.R3,regs.R11,0x20);
		/* 820657DCh case    1:*/		return 0x820657E0;
		  /* 820657E0h */ case    2:  		/* bclr 20, CR0_LT */
		/* 820657E0h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820657E0h case    2:*/		return 0x820657E4;
	}
	return 0x820657E4;
} // Block from 820657D8h-820657E4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820657E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820657E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820657E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820657E4);
		  /* 820657E4h */ case    0:  		/* nop */
		/* 820657E4h case    0:*/		cpu::op::nop();
		/* 820657E4h case    0:*/		return 0x820657E8;
	}
	return 0x820657E8;
} // Block from 820657E4h-820657E8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820657E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820657E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820657E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820657E8);
		  /* 820657E8h */ case    0:  		/* mfspr R12, LR */
		/* 820657E8h case    0:*/		regs.R12 = regs.LR;
		/* 820657E8h case    0:*/		return 0x820657EC;
		  /* 820657ECh */ case    1:  		/* bl 178776 */
		/* 820657ECh case    1:*/		regs.LR = 0x820657F0; return 0x82091244;
		/* 820657ECh case    1:*/		return 0x820657F0;
		  /* 820657F0h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 820657F0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 820657F0h case    2:*/		return 0x820657F4;
		  /* 820657F4h */ case    3:  		/* subfic R11, R8, 0 */
		/* 820657F4h case    3:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R8,0x0);
		/* 820657F4h case    3:*/		return 0x820657F8;
		  /* 820657F8h */ case    4:  		/* mr R31, R3 */
		/* 820657F8h case    4:*/		regs.R31 = regs.R3;
		/* 820657F8h case    4:*/		return 0x820657FC;
		  /* 820657FCh */ case    5:  		/* subfe R11, R11, R11 */
		/* 820657FCh case    5:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 820657FCh case    5:*/		return 0x82065800;
		  /* 82065800h */ case    6:  		/* mr R30, R4 */
		/* 82065800h case    6:*/		regs.R30 = regs.R4;
		/* 82065800h case    6:*/		return 0x82065804;
		  /* 82065804h */ case    7:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 82065804h case    7:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 82065804h case    7:*/		return 0x82065808;
		  /* 82065808h */ case    8:  		/* mr R29, R5 */
		/* 82065808h case    8:*/		regs.R29 = regs.R5;
		/* 82065808h case    8:*/		return 0x8206580C;
		  /* 8206580Ch */ case    9:  		/* mr R26, R6 */
		/* 8206580Ch case    9:*/		regs.R26 = regs.R6;
		/* 8206580Ch case    9:*/		return 0x82065810;
		  /* 82065810h */ case   10:  		/* mr R28, R8 */
		/* 82065810h case   10:*/		regs.R28 = regs.R8;
		/* 82065810h case   10:*/		return 0x82065814;
		  /* 82065814h */ case   11:  		/* mr R23, R9 */
		/* 82065814h case   11:*/		regs.R23 = regs.R9;
		/* 82065814h case   11:*/		return 0x82065818;
		  /* 82065818h */ case   12:  		/* li R25, 32 */
		/* 82065818h case   12:*/		cpu::op::li<0>(regs,&regs.R25,0x20);
		/* 82065818h case   12:*/		return 0x8206581C;
		  /* 8206581Ch */ case   13:  		/* cmplwi CR6, R8, 2 */
		/* 8206581Ch case   13:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000002);
		/* 8206581Ch case   13:*/		return 0x82065820;
		  /* 82065820h */ case   14:  		/* addi R24, R11, 1 */
		/* 82065820h case   14:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R11,0x1);
		/* 82065820h case   14:*/		return 0x82065824;
		  /* 82065824h */ case   15:  		/* li R27, 4 */
		/* 82065824h case   15:*/		cpu::op::li<0>(regs,&regs.R27,0x4);
		/* 82065824h case   15:*/		return 0x82065828;
		  /* 82065828h */ case   16:  		/* bc 12, CR6_EQ, 8 */
		/* 82065828h case   16:*/		if ( regs.CR[6].eq ) { return 0x82065830;  }
		/* 82065828h case   16:*/		return 0x8206582C;
		  /* 8206582Ch */ case   17:  		/* li R27, 1 */
		/* 8206582Ch case   17:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 8206582Ch case   17:*/		return 0x82065830;
	}
	return 0x82065830;
} // Block from 820657E8h-82065830h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82065830h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065830( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065830) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065830);
		  /* 82065830h */ case    0:  		/* addi R5, R1, 80 */
		/* 82065830h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 82065830h case    0:*/		return 0x82065834;
		  /* 82065834h */ case    1:  		/* addi R4, R1, 84 */
		/* 82065834h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x54);
		/* 82065834h case    1:*/		return 0x82065838;
		  /* 82065838h */ case    2:  		/* mr R3, R7 */
		/* 82065838h case    2:*/		regs.R3 = regs.R7;
		/* 82065838h case    2:*/		return 0x8206583C;
		  /* 8206583Ch */ case    3:  		/* bl -372 */
		/* 8206583Ch case    3:*/		regs.LR = 0x82065840; return 0x820656C8;
		/* 8206583Ch case    3:*/		return 0x82065840;
		  /* 82065840h */ case    4:  		/* lwz R9, <#[R1 + 80]> */
		/* 82065840h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 82065840h case    4:*/		return 0x82065844;
		  /* 82065844h */ case    5:  		/* lwz R11, <#[R1 + 84]> */
		/* 82065844h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82065844h case    5:*/		return 0x82065848;
		  /* 82065848h */ case    6:  		/* cmpwi CR6, R23, 0 */
		/* 82065848h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R23,0x00000000);
		/* 82065848h case    6:*/		return 0x8206584C;
		  /* 8206584Ch */ case    7:  		/* bc 4, CR6_EQ, 44 */
		/* 8206584Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x82065878;  }
		/* 8206584Ch case    7:*/		return 0x82065850;
		  /* 82065850h */ case    8:  		/* mullw R10, R11, R9 */
		/* 82065850h case    8:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R11,regs.R9);
		/* 82065850h case    8:*/		return 0x82065854;
		  /* 82065854h */ case    9:  		/* mullw R10, R10, R26 */
		/* 82065854h case    9:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R10,regs.R26);
		/* 82065854h case    9:*/		return 0x82065858;
		  /* 82065858h */ case   10:  		/* rlwinm. R10, R10, 29, 3, 31 */
		/* 82065858h case   10:*/		cpu::op::rlwinm<1,29,3,31>(regs,&regs.R10,regs.R10);
		/* 82065858h case   10:*/		return 0x8206585C;
		  /* 8206585Ch */ case   11:  		/* bc 12, CR0_EQ, 28 */
		/* 8206585Ch case   11:*/		if ( regs.CR[0].eq ) { return 0x82065878;  }
		/* 8206585Ch case   11:*/		return 0x82065860;
		  /* 82065860h */ case   12:  		/* li R8, 256 */
		/* 82065860h case   12:*/		cpu::op::li<0>(regs,&regs.R8,0x100);
		/* 82065860h case   12:*/		return 0x82065864;
		  /* 82065864h */ case   13:  		/* twi 6, R10, 0 */
		/* 82065864h case   13:*/		cpu::op::tw<6>(regs, 0x82065864, regs.R10, 0x00000000);
		/* 82065864h case   13:*/		return 0x82065868;
		  /* 82065868h */ case   14:  		/* divwu R10, R8, R10 */
		/* 82065868h case   14:*/		cpu::op::divwu<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 82065868h case   14:*/		return 0x8206586C;
		  /* 8206586Ch */ case   15:  		/* cmplwi CR6, R10, 32 */
		/* 8206586Ch case   15:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000020);
		/* 8206586Ch case   15:*/		return 0x82065870;
		  /* 82065870h */ case   16:  		/* bc 12, CR6_LT, 8 */
		/* 82065870h case   16:*/		if ( regs.CR[6].lt ) { return 0x82065878;  }
		/* 82065870h case   16:*/		return 0x82065874;
		  /* 82065874h */ case   17:  		/* mr R25, R10 */
		/* 82065874h case   17:*/		regs.R25 = regs.R10;
		/* 82065874h case   17:*/		return 0x82065878;
	}
	return 0x82065878;
} // Block from 82065830h-82065878h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82065878h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065878( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065878) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065878);
		  /* 82065878h */ case    0:  		/* mullw R11, R11, R25 */
		/* 82065878h case    0:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R25);
		/* 82065878h case    0:*/		return 0x8206587C;
		  /* 8206587Ch */ case    1:  		/* lwz R10, <#[R31]> */
		/* 8206587Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8206587Ch case    1:*/		return 0x82065880;
		  /* 82065880h */ case    2:  		/* add R10, R10, R11 */
		/* 82065880h case    2:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 82065880h case    2:*/		return 0x82065884;
		  /* 82065884h */ case    3:  		/* addi R8, R11, -1 */
		/* 82065884h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFFF);
		/* 82065884h case    3:*/		return 0x82065888;
		  /* 82065888h */ case    4:  		/* addi R10, R10, -1 */
		/* 82065888h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82065888h case    4:*/		return 0x8206588C;
		  /* 8206588Ch */ case    5:  		/* mullw R11, R9, R24 */
		/* 8206588Ch case    5:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R9,regs.R24);
		/* 8206588Ch case    5:*/		return 0x82065890;
		  /* 82065890h */ case    6:  		/* andc R10, R10, R8 */
		/* 82065890h case    6:*/		cpu::op::andc<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 82065890h case    6:*/		return 0x82065894;
		  /* 82065894h */ case    7:  		/* addi R9, R11, -1 */
		/* 82065894h case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFFF);
		/* 82065894h case    7:*/		return 0x82065898;
		  /* 82065898h */ case    8:  		/* stw R10, <#[R31]> */
		/* 82065898h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82065898h case    8:*/		return 0x8206589C;
		  /* 8206589Ch */ case    9:  		/* addi R8, R27, -1 */
		/* 8206589Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R27,0xFFFFFFFF);
		/* 8206589Ch case    9:*/		return 0x820658A0;
		  /* 820658A0h */ case   10:  		/* lwz R10, <#[R30]> */
		/* 820658A0h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 820658A0h case   10:*/		return 0x820658A4;
		  /* 820658A4h */ case   11:  		/* add R11, R10, R11 */
		/* 820658A4h case   11:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820658A4h case   11:*/		return 0x820658A8;
		  /* 820658A8h */ case   12:  		/* addi R11, R11, -1 */
		/* 820658A8h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820658A8h case   12:*/		return 0x820658AC;
		  /* 820658ACh */ case   13:  		/* cmplwi CR6, R28, 2 */
		/* 820658ACh case   13:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000002);
		/* 820658ACh case   13:*/		return 0x820658B0;
		  /* 820658B0h */ case   14:  		/* andc R11, R11, R9 */
		/* 820658B0h case   14:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 820658B0h case   14:*/		return 0x820658B4;
		  /* 820658B4h */ case   15:  		/* stw R11, <#[R30]> */
		/* 820658B4h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 820658B4h case   15:*/		return 0x820658B8;
		  /* 820658B8h */ case   16:  		/* lwz R11, <#[R29]> */
		/* 820658B8h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 820658B8h case   16:*/		return 0x820658BC;
		  /* 820658BCh */ case   17:  		/* add R11, R11, R27 */
		/* 820658BCh case   17:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R27);
		/* 820658BCh case   17:*/		return 0x820658C0;
		  /* 820658C0h */ case   18:  		/* addi R11, R11, -1 */
		/* 820658C0h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820658C0h case   18:*/		return 0x820658C4;
		  /* 820658C4h */ case   19:  		/* andc R11, R11, R8 */
		/* 820658C4h case   19:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 820658C4h case   19:*/		return 0x820658C8;
		  /* 820658C8h */ case   20:  		/* stw R11, <#[R29]> */
		/* 820658C8h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 820658C8h case   20:*/		return 0x820658CC;
		  /* 820658CCh */ case   21:  		/* lwz R10, <#[R30]> */
		/* 820658CCh case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 820658CCh case   21:*/		return 0x820658D0;
		  /* 820658D0h */ case   22:  		/* lwz R9, <#[R31]> */
		/* 820658D0h case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 820658D0h case   22:*/		return 0x820658D4;
		  /* 820658D4h */ case   23:  		/* mullw R9, R9, R26 */
		/* 820658D4h case   23:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R9,regs.R26);
		/* 820658D4h case   23:*/		return 0x820658D8;
		  /* 820658D8h */ case   24:  		/* rlwinm R9, R9, 29, 3, 31 */
		/* 820658D8h case   24:*/		cpu::op::rlwinm<0,29,3,31>(regs,&regs.R9,regs.R9);
		/* 820658D8h case   24:*/		return 0x820658DC;
		  /* 820658DCh */ case   25:  		/* mullw R10, R9, R10 */
		/* 820658DCh case   25:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 820658DCh case   25:*/		return 0x820658E0;
		  /* 820658E0h */ case   26:  		/* bc 12, CR6_EQ, 20 */
		/* 820658E0h case   26:*/		if ( regs.CR[6].eq ) { return 0x820658F4;  }
		/* 820658E0h case   26:*/		return 0x820658E4;
		  /* 820658E4h */ case   27:  		/* addi R10, R10, 4095 */
		/* 820658E4h case   27:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFF);
		/* 820658E4h case   27:*/		return 0x820658E8;
		  /* 820658E8h */ case   28:  		/* rlwinm R10, R10, 0, 0, 19 */
		/* 820658E8h case   28:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R10,regs.R10);
		/* 820658E8h case   28:*/		return 0x820658EC;
		  /* 820658ECh */ case   29:  		/* mullw R3, R10, R11 */
		/* 820658ECh case   29:*/		cpu::op::mullw<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 820658ECh case   29:*/		return 0x820658F0;
		  /* 820658F0h */ case   30:  		/* b 16 */
		/* 820658F0h case   30:*/		return 0x82065900;
		/* 820658F0h case   30:*/		return 0x820658F4;
	}
	return 0x820658F4;
} // Block from 82065878h-820658F4h (31 instructions)

//////////////////////////////////////////////////////
// Block at 820658F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820658F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820658F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820658F4);
		  /* 820658F4h */ case    0:  		/* mullw R11, R11, R10 */
		/* 820658F4h case    0:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820658F4h case    0:*/		return 0x820658F8;
		  /* 820658F8h */ case    1:  		/* addi R11, R11, 4095 */
		/* 820658F8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFF);
		/* 820658F8h case    1:*/		return 0x820658FC;
		  /* 820658FCh */ case    2:  		/* rlwinm R3, R11, 0, 0, 19 */
		/* 820658FCh case    2:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R3,regs.R11);
		/* 820658FCh case    2:*/		return 0x82065900;
	}
	return 0x82065900;
} // Block from 820658F4h-82065900h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82065900h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065900( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065900) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065900);
		  /* 82065900h */ case    0:  		/* addi R1, R1, 176 */
		/* 82065900h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 82065900h case    0:*/		return 0x82065904;
		  /* 82065904h */ case    1:  		/* b 178576 */
		/* 82065904h case    1:*/		return 0x82091294;
		/* 82065904h case    1:*/		return 0x82065908;
	}
	return 0x82065908;
} // Block from 82065900h-82065908h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82065908h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065908( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065908) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065908);
		  /* 82065908h */ case    0:  		/* mfspr R12, LR */
		/* 82065908h case    0:*/		regs.R12 = regs.LR;
		/* 82065908h case    0:*/		return 0x8206590C;
		  /* 8206590Ch */ case    1:  		/* bl 178452 */
		/* 8206590Ch case    1:*/		regs.LR = 0x82065910; return 0x82091220;
		/* 8206590Ch case    1:*/		return 0x82065910;
	}
	return 0x82065910;
} // Block from 82065908h-82065910h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82065910h
// Function '?ClearSurface@D3D@@YAXPAVCDevice@1@KKJJJJPBU__vector4@@MK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065910( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065910) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065910);
		  /* 82065910h */ case    0:  		/* stwu R1, <#[R1 - 256]> */
		/* 82065910h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF00) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF00);
		/* 82065910h case    0:*/		return 0x82065914;
		  /* 82065914h */ case    1:  		/* mr R22, R8 */
		/* 82065914h case    1:*/		regs.R22 = regs.R8;
		/* 82065914h case    1:*/		return 0x82065918;
		  /* 82065918h */ case    2:  		/* stw R5, <#[R1 + 292]> */
		/* 82065918h case    2:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x00000124) );
		/* 82065918h case    2:*/		return 0x8206591C;
		  /* 8206591Ch */ case    3:  		/* mr R24, R4 */
		/* 8206591Ch case    3:*/		regs.R24 = regs.R4;
		/* 8206591Ch case    3:*/		return 0x82065920;
		  /* 82065920h */ case    4:  		/* stw R10, <#[R1 + 332]> */
		/* 82065920h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x0000014C) );
		/* 82065920h case    4:*/		return 0x82065924;
		  /* 82065924h */ case    5:  		/* mr R15, R6 */
		/* 82065924h case    5:*/		regs.R15 = regs.R6;
		/* 82065924h case    5:*/		return 0x82065928;
		  /* 82065928h */ case    6:  		/* mr R20, R7 */
		/* 82065928h case    6:*/		regs.R20 = regs.R7;
		/* 82065928h case    6:*/		return 0x8206592C;
		  /* 8206592Ch */ case    7:  		/* mr R16, R9 */
		/* 8206592Ch case    7:*/		regs.R16 = regs.R9;
		/* 8206592Ch case    7:*/		return 0x82065930;
		  /* 82065930h */ case    8:  		/* mr R8, R10 */
		/* 82065930h case    8:*/		regs.R8 = regs.R10;
		/* 82065930h case    8:*/		return 0x82065934;
		  /* 82065934h */ case    9:  		/* li R19, 1 */
		/* 82065934h case    9:*/		cpu::op::li<0>(regs,&regs.R19,0x1);
		/* 82065934h case    9:*/		return 0x82065938;
		  /* 82065938h */ case   10:  		/* li R17, 0 */
		/* 82065938h case   10:*/		cpu::op::li<0>(regs,&regs.R17,0x0);
		/* 82065938h case   10:*/		return 0x8206593C;
		  /* 8206593Ch */ case   11:  		/* cmplwi CR6, R22, 1 */
		/* 8206593Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000001);
		/* 8206593Ch case   11:*/		return 0x82065940;
		  /* 82065940h */ case   12:  		/* bc 4, CR6_EQ, 20 */
		/* 82065940h case   12:*/		if ( !regs.CR[6].eq ) { return 0x82065954;  }
		/* 82065940h case   12:*/		return 0x82065944;
		  /* 82065944h */ case   13:  		/* cmplwi CR6, R5, 1 */
		/* 82065944h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000001);
		/* 82065944h case   13:*/		return 0x82065948;
		  /* 82065948h */ case   14:  		/* bc 4, CR6_GT, 12 */
		/* 82065948h case   14:*/		if ( !regs.CR[6].gt ) { return 0x82065954;  }
		/* 82065948h case   14:*/		return 0x8206594C;
		  /* 8206594Ch */ case   15:  		/* stw R19, <#[R1 + 92]> */
		/* 8206594Ch case   15:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R1 + 0x0000005C) );
		/* 8206594Ch case   15:*/		return 0x82065950;
		  /* 82065950h */ case   16:  		/* b 20 */
		/* 82065950h case   16:*/		return 0x82065964;
		/* 82065950h case   16:*/		return 0x82065954;
	}
	return 0x82065954;
} // Block from 82065910h-82065954h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82065954h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065954( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065954) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065954);
		  /* 82065954h */ case    0:  		/* stw R17, <#[R1 + 92]> */
		/* 82065954h case    0:*/		cpu::mem::store32( regs, regs.R17, (uint32)(regs.R1 + 0x0000005C) );
		/* 82065954h case    0:*/		return 0x82065958;
		  /* 82065958h */ case    1:  		/* cmplwi CR6, R22, 3 */
		/* 82065958h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000003);
		/* 82065958h case    1:*/		return 0x8206595C;
		  /* 8206595Ch */ case    2:  		/* mr R14, R17 */
		/* 8206595Ch case    2:*/		regs.R14 = regs.R17;
		/* 8206595Ch case    2:*/		return 0x82065960;
		  /* 82065960h */ case    3:  		/* bc 4, CR6_EQ, 8 */
		/* 82065960h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82065968;  }
		/* 82065960h case    3:*/		return 0x82065964;
	}
	return 0x82065964;
} // Block from 82065954h-82065964h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82065964h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065964( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065964) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065964);
		  /* 82065964h */ case    0:  		/* mr R14, R19 */
		/* 82065964h case    0:*/		regs.R14 = regs.R19;
		/* 82065964h case    0:*/		return 0x82065968;
	}
	return 0x82065968;
} // Block from 82065964h-82065968h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82065968h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065968( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065968) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065968);
		  /* 82065968h */ case    0:  		/* cmpwi CR6, R14, 0 */
		/* 82065968h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R14,0x00000000);
		/* 82065968h case    0:*/		return 0x8206596C;
		  /* 8206596Ch */ case    1:  		/* mr R28, R19 */
		/* 8206596Ch case    1:*/		regs.R28 = regs.R19;
		/* 8206596Ch case    1:*/		return 0x82065970;
		  /* 82065970h */ case    2:  		/* bc 4, CR6_EQ, 8 */
		/* 82065970h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82065978;  }
		/* 82065970h case    2:*/		return 0x82065974;
		  /* 82065974h */ case    3:  		/* mr R28, R5 */
		/* 82065974h case    3:*/		regs.R28 = regs.R5;
		/* 82065974h case    3:*/		return 0x82065978;
	}
	return 0x82065978;
} // Block from 82065968h-82065978h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82065978h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065978( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065978) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065978);
		  /* 82065978h */ case    0:  		/* lwz R31, <#[R1 + 340]> */
		/* 82065978h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000154) );
		/* 82065978h case    0:*/		return 0x8206597C;
		  /* 8206597Ch */ case    1:  		/* lis R10, -32256 */
		/* 8206597Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 8206597Ch case    1:*/		return 0x82065980;
		  /* 82065980h */ case    2:  		/* rlwinm R7, R20, 1, 0, 30 */
		/* 82065980h case    2:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R7,regs.R20);
		/* 82065980h case    2:*/		return 0x82065984;
		  /* 82065984h */ case    3:  		/* rlwinm R11, R31, 1, 0, 30 */
		/* 82065984h case    3:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R31);
		/* 82065984h case    3:*/		return 0x82065988;
		  /* 82065988h */ case    4:  		/* addi R10, R10, 2992 */
		/* 82065988h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xBB0);
		/* 82065988h case    4:*/		return 0x8206598C;
		  /* 8206598Ch */ case    5:  		/* subf R23, R11, R3 */
		/* 8206598Ch case    5:*/		cpu::op::subf<0>(regs,&regs.R23,regs.R11,regs.R3);
		/* 8206598Ch case    5:*/		return 0x82065990;
		  /* 82065990h */ case    6:  		/* subf R25, R11, R24 */
		/* 82065990h case    6:*/		cpu::op::subf<0>(regs,&regs.R25,regs.R11,regs.R24);
		/* 82065990h case    6:*/		return 0x82065994;
		  /* 82065994h */ case    7:  		/* addi R9, R23, -1 */
		/* 82065994h case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R23,0xFFFFFFFF);
		/* 82065994h case    7:*/		return 0x82065998;
		  /* 82065998h */ case    8:  		/* addi R6, R25, -1 */
		/* 82065998h case    8:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R25,0xFFFFFFFF);
		/* 82065998h case    8:*/		return 0x8206599C;
		  /* 8206599Ch */ case    9:  		/* addi R5, R10, 1 */
		/* 8206599Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0x1);
		/* 8206599Ch case    9:*/		return 0x820659A0;
		  /* 820659A0h */ case   10:  		/* cntlzw R10, R9 */
		/* 820659A0h case   10:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R9);
		/* 820659A0h case   10:*/		return 0x820659A4;
		  /* 820659A4h */ case   11:  		/* cntlzw R9, R6 */
		/* 820659A4h case   11:*/		cpu::op::cntlzw<0>(regs,&regs.R9,regs.R6);
		/* 820659A4h case   11:*/		return 0x820659A8;
		  /* 820659A8h */ case   12:  		/* subf R10, R10, R31 */
		/* 820659A8h case   12:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R10,regs.R31);
		/* 820659A8h case   12:*/		return 0x820659AC;
		  /* 820659ACh */ case   13:  		/* subf R9, R9, R31 */
		/* 820659ACh case   13:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R9,regs.R31);
		/* 820659ACh case   13:*/		return 0x820659B0;
		  /* 820659B0h */ case   14:  		/* lbzx R21, <#[R7 + R5]> */
		/* 820659B0h case   14:*/		cpu::mem::load8z( regs, &regs.R21, (uint32)(regs.R7 + regs.R5 + 0x00000000) );
		/* 820659B0h case   14:*/		return 0x820659B4;
		  /* 820659B4h */ case   15:  		/* addi R29, R10, 32 */
		/* 820659B4h case   15:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R10,0x20);
		/* 820659B4h case   15:*/		return 0x820659B8;
		  /* 820659B8h */ case   16:  		/* addi R30, R9, 32 */
		/* 820659B8h case   16:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R9,0x20);
		/* 820659B8h case   16:*/		return 0x820659BC;
		  /* 820659BCh */ case   17:  		/* cmplwi CR6, R22, 2 */
		/* 820659BCh case   17:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000002);
		/* 820659BCh case   17:*/		return 0x820659C0;
		  /* 820659C0h */ case   18:  		/* bc 4, CR6_EQ, 32 */
		/* 820659C0h case   18:*/		if ( !regs.CR[6].eq ) { return 0x820659E0;  }
		/* 820659C0h case   18:*/		return 0x820659C4;
		  /* 820659C4h */ case   19:  		/* subf R26, R11, R28 */
		/* 820659C4h case   19:*/		cpu::op::subf<0>(regs,&regs.R26,regs.R11,regs.R28);
		/* 820659C4h case   19:*/		return 0x820659C8;
		  /* 820659C8h */ case   20:  		/* lwz R27, <#[R1 + 356]> */
		/* 820659C8h case   20:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000164) );
		/* 820659C8h case   20:*/		return 0x820659CC;
		  /* 820659CCh */ case   21:  		/* addi R11, R26, -1 */
		/* 820659CCh case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0xFFFFFFFF);
		/* 820659CCh case   21:*/		return 0x820659D0;
		  /* 820659D0h */ case   22:  		/* cntlzw R11, R11 */
		/* 820659D0h case   22:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820659D0h case   22:*/		return 0x820659D4;
		  /* 820659D4h */ case   23:  		/* subf R11, R11, R31 */
		/* 820659D4h case   23:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 820659D4h case   23:*/		return 0x820659D8;
		  /* 820659D8h */ case   24:  		/* addi R11, R11, 32 */
		/* 820659D8h case   24:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x20);
		/* 820659D8h case   24:*/		return 0x820659DC;
		  /* 820659DCh */ case   25:  		/* b 28 */
		/* 820659DCh case   25:*/		return 0x820659F8;
		/* 820659DCh case   25:*/		return 0x820659E0;
	}
	return 0x820659E0;
} // Block from 82065978h-820659E0h (26 instructions)

//////////////////////////////////////////////////////
// Block at 820659E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820659E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820659E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820659E0);
		  /* 820659E0h */ case    0:  		/* subfic R11, R22, 0 */
		/* 820659E0h case    0:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R22,0x0);
		/* 820659E0h case    0:*/		return 0x820659E4;
		  /* 820659E4h */ case    1:  		/* lwz R10, <#[R1 + 356]> */
		/* 820659E4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000164) );
		/* 820659E4h case    1:*/		return 0x820659E8;
		  /* 820659E8h */ case    2:  		/* mr R26, R19 */
		/* 820659E8h case    2:*/		regs.R26 = regs.R19;
		/* 820659E8h case    2:*/		return 0x820659EC;
		  /* 820659ECh */ case    3:  		/* subfe R9, R11, R11 */
		/* 820659ECh case    3:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R11,regs.R11);
		/* 820659ECh case    3:*/		return 0x820659F0;
		  /* 820659F0h */ case    4:  		/* mr R11, R17 */
		/* 820659F0h case    4:*/		regs.R11 = regs.R17;
		/* 820659F0h case    4:*/		return 0x820659F4;
		  /* 820659F4h */ case    5:  		/* and R27, R9, R10 */
		/* 820659F4h case    5:*/		cpu::op::and<0>(regs,&regs.R27,regs.R9,regs.R10);
		/* 820659F4h case    5:*/		return 0x820659F8;
	}
	return 0x820659F8;
} // Block from 820659E0h-820659F8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820659F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820659F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820659F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820659F8);
		  /* 820659F8h */ case    0:  		/* slw R11, R19, R11 */
		/* 820659F8h case    0:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R19,regs.R11);
		/* 820659F8h case    0:*/		return 0x820659FC;
		  /* 820659FCh */ case    1:  		/* stw R11, <#[R1 + 80]> */
		/* 820659FCh case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820659FCh case    1:*/		return 0x82065A00;
		  /* 82065A00h */ case    2:  		/* slw R10, R19, R29 */
		/* 82065A00h case    2:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R19,regs.R29);
		/* 82065A00h case    2:*/		return 0x82065A04;
		  /* 82065A04h */ case    3:  		/* slw R11, R19, R30 */
		/* 82065A04h case    3:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R19,regs.R30);
		/* 82065A04h case    3:*/		return 0x82065A08;
		  /* 82065A08h */ case    4:  		/* stw R10, <#[R1 + 88]> */
		/* 82065A08h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 82065A08h case    4:*/		return 0x82065A0C;
		  /* 82065A0Ch */ case    5:  		/* stw R11, <#[R1 + 84]> */
		/* 82065A0Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82065A0Ch case    5:*/		return 0x82065A10;
		  /* 82065A10h */ case    6:  		/* cmplwi CR6, R10, 16 */
		/* 82065A10h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000010);
		/* 82065A10h case    6:*/		return 0x82065A14;
		  /* 82065A14h */ case    7:  		/* bc 4, CR6_GT, 12 */
		/* 82065A14h case    7:*/		if ( !regs.CR[6].gt ) { return 0x82065A20;  }
		/* 82065A14h case    7:*/		return 0x82065A18;
		  /* 82065A18h */ case    8:  		/* cmplwi CR6, R11, 16 */
		/* 82065A18h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000010);
		/* 82065A18h case    8:*/		return 0x82065A1C;
		  /* 82065A1Ch */ case    9:  		/* bc 12, CR6_GT, 12 */
		/* 82065A1Ch case    9:*/		if ( regs.CR[6].gt ) { return 0x82065A28;  }
		/* 82065A1Ch case    9:*/		return 0x82065A20;
	}
	return 0x82065A20;
} // Block from 820659F8h-82065A20h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82065A20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065A20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065A20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065A20);
		  /* 82065A20h */ case    0:  		/* cmpwi CR6, R8, 0 */
		/* 82065A20h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 82065A20h case    0:*/		return 0x82065A24;
		  /* 82065A24h */ case    1:  		/* bc 4, CR6_EQ, 44 */
		/* 82065A24h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82065A50;  }
		/* 82065A24h case    1:*/		return 0x82065A28;
	}
	return 0x82065A28;
} // Block from 82065A20h-82065A28h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82065A28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065A28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065A28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065A28);
		  /* 82065A28h */ case    0:  		/* cmplwi CR6, R27, 0 */
		/* 82065A28h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 82065A28h case    0:*/		return 0x82065A2C;
		  /* 82065A2Ch */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 82065A2Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82065A38;  }
		/* 82065A2Ch case    1:*/		return 0x82065A30;
		  /* 82065A30h */ case    2:  		/* stw R3, <#[R1 + 88]> */
		/* 82065A30h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000058) );
		/* 82065A30h case    2:*/		return 0x82065A34;
		  /* 82065A34h */ case    3:  		/* b 20 */
		/* 82065A34h case    3:*/		return 0x82065A48;
		/* 82065A34h case    3:*/		return 0x82065A38;
	}
	return 0x82065A38;
} // Block from 82065A28h-82065A38h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82065A38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065A38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065A38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065A38);
		  /* 82065A38h */ case    0:  		/* rlwinm R11, R27, 3, 0, 28 */
		/* 82065A38h case    0:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R27);
		/* 82065A38h case    0:*/		return 0x82065A3C;
		  /* 82065A3Ch */ case    1:  		/* twi 6, R21, 0 */
		/* 82065A3Ch case    1:*/		cpu::op::tw<6>(regs, 0x82065A3C, regs.R21, 0x00000000);
		/* 82065A3Ch case    1:*/		return 0x82065A40;
		  /* 82065A40h */ case    2:  		/* divwu R11, R11, R21 */
		/* 82065A40h case    2:*/		cpu::op::divwu<0>(regs,&regs.R11,regs.R11,regs.R21);
		/* 82065A40h case    2:*/		return 0x82065A44;
		  /* 82065A44h */ case    3:  		/* stw R11, <#[R1 + 88]> */
		/* 82065A44h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 82065A44h case    3:*/		return 0x82065A48;
	}
	return 0x82065A48;
} // Block from 82065A38h-82065A48h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82065A48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065A48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065A48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065A48);
		  /* 82065A48h */ case    0:  		/* stw R24, <#[R1 + 84]> */
		/* 82065A48h case    0:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R1 + 0x00000054) );
		/* 82065A48h case    0:*/		return 0x82065A4C;
		  /* 82065A4Ch */ case    1:  		/* stw R28, <#[R1 + 80]> */
		/* 82065A4Ch case    1:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000050) );
		/* 82065A4Ch case    1:*/		return 0x82065A50;
	}
	return 0x82065A50;
} // Block from 82065A48h-82065A50h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82065A50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065A50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065A50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065A50);
		  /* 82065A50h */ case    0:  		/* mr R9, R16 */
		/* 82065A50h case    0:*/		regs.R9 = regs.R16;
		/* 82065A50h case    0:*/		return 0x82065A54;
		  /* 82065A54h */ case    1:  		/* mr R8, R22 */
		/* 82065A54h case    1:*/		regs.R8 = regs.R22;
		/* 82065A54h case    1:*/		return 0x82065A58;
		  /* 82065A58h */ case    2:  		/* mr R7, R20 */
		/* 82065A58h case    2:*/		regs.R7 = regs.R20;
		/* 82065A58h case    2:*/		return 0x82065A5C;
		  /* 82065A5Ch */ case    3:  		/* mr R6, R21 */
		/* 82065A5Ch case    3:*/		regs.R6 = regs.R21;
		/* 82065A5Ch case    3:*/		return 0x82065A60;
		  /* 82065A60h */ case    4:  		/* addi R5, R1, 80 */
		/* 82065A60h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 82065A60h case    4:*/		return 0x82065A64;
		  /* 82065A64h */ case    5:  		/* addi R4, R1, 84 */
		/* 82065A64h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x54);
		/* 82065A64h case    5:*/		return 0x82065A68;
		  /* 82065A68h */ case    6:  		/* addi R3, R1, 88 */
		/* 82065A68h case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x58);
		/* 82065A68h case    6:*/		return 0x82065A6C;
		  /* 82065A6Ch */ case    7:  		/* bl -644 */
		/* 82065A6Ch case    7:*/		regs.LR = 0x82065A70; return 0x820657E8;
		/* 82065A6Ch case    7:*/		return 0x82065A70;
		  /* 82065A70h */ case    8:  		/* cmplwi CR6, R27, 0 */
		/* 82065A70h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 82065A70h case    8:*/		return 0x82065A74;
		  /* 82065A74h */ case    9:  		/* lwz R18, <#[R1 + 88]> */
		/* 82065A74h case    9:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R1 + 0x00000058) );
		/* 82065A74h case    9:*/		return 0x82065A78;
		  /* 82065A78h */ case   10:  		/* bc 4, CR6_EQ, 12 */
		/* 82065A78h case   10:*/		if ( !regs.CR[6].eq ) { return 0x82065A84;  }
		/* 82065A78h case   10:*/		return 0x82065A7C;
		  /* 82065A7Ch */ case   11:  		/* mullw R11, R18, R21 */
		/* 82065A7Ch case   11:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R18,regs.R21);
		/* 82065A7Ch case   11:*/		return 0x82065A80;
		  /* 82065A80h */ case   12:  		/* rlwinm R27, R11, 29, 3, 31 */
		/* 82065A80h case   12:*/		cpu::op::rlwinm<0,29,3,31>(regs,&regs.R27,regs.R11);
		/* 82065A80h case   12:*/		return 0x82065A84;
	}
	return 0x82065A84;
} // Block from 82065A50h-82065A84h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82065A84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065A84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065A84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065A84);
		  /* 82065A84h */ case    0:  		/* cmpwi CR6, R16, 0 */
		/* 82065A84h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R16,0x00000000);
		/* 82065A84h case    0:*/		return 0x82065A88;
		  /* 82065A88h */ case    1:  		/* bc 4, CR6_EQ, 120 */
		/* 82065A88h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82065B00;  }
		/* 82065A88h case    1:*/		return 0x82065A8C;
		  /* 82065A8Ch */ case    2:  		/* cmpwi CR6, R14, 0 */
		/* 82065A8Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R14,0x00000000);
		/* 82065A8Ch case    2:*/		return 0x82065A90;
		  /* 82065A90h */ case    3:  		/* bc 4, CR6_EQ, 112 */
		/* 82065A90h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82065B00;  }
		/* 82065A90h case    3:*/		return 0x82065A94;
		  /* 82065A94h */ case    4:  		/* cmplwi CR6, R22, 2 */
		/* 82065A94h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000002);
		/* 82065A94h case    4:*/		return 0x82065A98;
		  /* 82065A98h */ case    5:  		/* bc 12, CR6_EQ, 140 */
		/* 82065A98h case    5:*/		if ( regs.CR[6].eq ) { return 0x82065B24;  }
		/* 82065A98h case    5:*/		return 0x82065A9C;
		  /* 82065A9Ch */ case    6:  		/* cmplwi CR6, R22, 1 */
		/* 82065A9Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000001);
		/* 82065A9Ch case    6:*/		return 0x82065AA0;
		  /* 82065AA0h */ case    7:  		/* bc 4, CR6_EQ, 76 */
		/* 82065AA0h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82065AEC;  }
		/* 82065AA0h case    7:*/		return 0x82065AA4;
		  /* 82065AA4h */ case    8:  		/* cmplwi CR6, R15, 1 */
		/* 82065AA4h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R15,0x00000001);
		/* 82065AA4h case    8:*/		return 0x82065AA8;
		  /* 82065AA8h */ case    9:  		/* bc 4, CR6_EQ, 68 */
		/* 82065AA8h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82065AEC;  }
		/* 82065AA8h case    9:*/		return 0x82065AAC;
		  /* 82065AACh */ case   10:  		/* lwz R11, <#[R1 + 332]> */
		/* 82065AACh case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000014C) );
		/* 82065AACh case   10:*/		return 0x82065AB0;
		  /* 82065AB0h */ case   11:  		/* cmpwi CR6, R11, 0 */
		/* 82065AB0h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82065AB0h case   11:*/		return 0x82065AB4;
		  /* 82065AB4h */ case   12:  		/* bc 4, CR6_EQ, 56 */
		/* 82065AB4h case   12:*/		if ( !regs.CR[6].eq ) { return 0x82065AEC;  }
		/* 82065AB4h case   12:*/		return 0x82065AB8;
		  /* 82065AB8h */ case   13:  		/* cmplwi CR6, R31, 0 */
		/* 82065AB8h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82065AB8h case   13:*/		return 0x82065ABC;
		  /* 82065ABCh */ case   14:  		/* bc 4, CR6_EQ, 48 */
		/* 82065ABCh case   14:*/		if ( !regs.CR[6].eq ) { return 0x82065AEC;  }
		/* 82065ABCh case   14:*/		return 0x82065AC0;
		  /* 82065AC0h */ case   15:  		/* addi R5, R1, 92 */
		/* 82065AC0h case   15:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x5C);
		/* 82065AC0h case   15:*/		return 0x82065AC4;
		  /* 82065AC4h */ case   16:  		/* addi R4, R1, 88 */
		/* 82065AC4h case   16:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x58);
		/* 82065AC4h case   16:*/		return 0x82065AC8;
		  /* 82065AC8h */ case   17:  		/* mr R3, R20 */
		/* 82065AC8h case   17:*/		regs.R3 = regs.R20;
		/* 82065AC8h case   17:*/		return 0x82065ACC;
		  /* 82065ACCh */ case   18:  		/* bl -1028 */
		/* 82065ACCh case   18:*/		regs.LR = 0x82065AD0; return 0x820656C8;
		/* 82065ACCh case   18:*/		return 0x82065AD0;
		  /* 82065AD0h */ case   19:  		/* lwz R11, <#[R1 + 92]> */
		/* 82065AD0h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 82065AD0h case   19:*/		return 0x82065AD4;
		  /* 82065AD4h */ case   20:  		/* add R10, R11, R24 */
		/* 82065AD4h case   20:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R24);
		/* 82065AD4h case   20:*/		return 0x82065AD8;
		  /* 82065AD8h */ case   21:  		/* addi R11, R11, -1 */
		/* 82065AD8h case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82065AD8h case   21:*/		return 0x82065ADC;
		  /* 82065ADCh */ case   22:  		/* addi R10, R10, -1 */
		/* 82065ADCh case   22:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82065ADCh case   22:*/		return 0x82065AE0;
		  /* 82065AE0h */ case   23:  		/* andc R11, R10, R11 */
		/* 82065AE0h case   23:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82065AE0h case   23:*/		return 0x82065AE4;
		  /* 82065AE4h */ case   24:  		/* mullw R24, R11, R27 */
		/* 82065AE4h case   24:*/		cpu::op::mullw<0>(regs,&regs.R24,regs.R11,regs.R27);
		/* 82065AE4h case   24:*/		return 0x82065AE8;
		  /* 82065AE8h */ case   25:  		/* b 380 */
		/* 82065AE8h case   25:*/		return 0x82065C64;
		/* 82065AE8h case   25:*/		return 0x82065AEC;
	}
	return 0x82065AEC;
} // Block from 82065A84h-82065AECh (26 instructions)

//////////////////////////////////////////////////////
// Block at 82065AECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065AEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065AEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065AEC);
		  /* 82065AECh */ case    0:  		/* lwz R11, <#[R1 + 80]> */
		/* 82065AECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82065AECh case    0:*/		return 0x82065AF0;
		  /* 82065AF0h */ case    1:  		/* lwz R10, <#[R1 + 84]> */
		/* 82065AF0h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 82065AF0h case    1:*/		return 0x82065AF4;
		  /* 82065AF4h */ case    2:  		/* mullw R11, R27, R11 */
		/* 82065AF4h case    2:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R27,regs.R11);
		/* 82065AF4h case    2:*/		return 0x82065AF8;
		  /* 82065AF8h */ case    3:  		/* mullw R24, R11, R10 */
		/* 82065AF8h case    3:*/		cpu::op::mullw<0>(regs,&regs.R24,regs.R11,regs.R10);
		/* 82065AF8h case    3:*/		return 0x82065AFC;
		  /* 82065AFCh */ case    4:  		/* b 80 */
		/* 82065AFCh case    4:*/		return 0x82065B4C;
		/* 82065AFCh case    4:*/		return 0x82065B00;
	}
	return 0x82065B00;
} // Block from 82065AECh-82065B00h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82065B00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065B00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065B00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065B00);
		  /* 82065B00h */ case    0:  		/* cmplwi CR6, R22, 2 */
		/* 82065B00h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000002);
		/* 82065B00h case    0:*/		return 0x82065B04;
		  /* 82065B04h */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 82065B04h case    1:*/		if ( regs.CR[6].eq ) { return 0x82065B24;  }
		/* 82065B04h case    1:*/		return 0x82065B08;
		  /* 82065B08h */ case    2:  		/* lwz R11, <#[R1 + 84]> */
		/* 82065B08h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82065B08h case    2:*/		return 0x82065B0C;
		  /* 82065B0Ch */ case    3:  		/* lwz R10, <#[R1 + 80]> */
		/* 82065B0Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 82065B0Ch case    3:*/		return 0x82065B10;
		  /* 82065B10h */ case    4:  		/* mullw R11, R27, R11 */
		/* 82065B10h case    4:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R27,regs.R11);
		/* 82065B10h case    4:*/		return 0x82065B14;
		  /* 82065B14h */ case    5:  		/* addi R11, R11, 4095 */
		/* 82065B14h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFF);
		/* 82065B14h case    5:*/		return 0x82065B18;
		  /* 82065B18h */ case    6:  		/* rlwinm R11, R11, 0, 0, 19 */
		/* 82065B18h case    6:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R11);
		/* 82065B18h case    6:*/		return 0x82065B1C;
		  /* 82065B1Ch */ case    7:  		/* mullw R24, R11, R10 */
		/* 82065B1Ch case    7:*/		cpu::op::mullw<0>(regs,&regs.R24,regs.R11,regs.R10);
		/* 82065B1Ch case    7:*/		return 0x82065B20;
		  /* 82065B20h */ case    8:  		/* b 28 */
		/* 82065B20h case    8:*/		return 0x82065B3C;
		/* 82065B20h case    8:*/		return 0x82065B24;
	}
	return 0x82065B24;
} // Block from 82065B00h-82065B24h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82065B24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065B24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065B24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065B24);
		  /* 82065B24h */ case    0:  		/* lwz R11, <#[R1 + 80]> */
		/* 82065B24h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82065B24h case    0:*/		return 0x82065B28;
		  /* 82065B28h */ case    1:  		/* lwz R10, <#[R1 + 84]> */
		/* 82065B28h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 82065B28h case    1:*/		return 0x82065B2C;
		  /* 82065B2Ch */ case    2:  		/* mullw R11, R27, R11 */
		/* 82065B2Ch case    2:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R27,regs.R11);
		/* 82065B2Ch case    2:*/		return 0x82065B30;
		  /* 82065B30h */ case    3:  		/* mullw R11, R11, R10 */
		/* 82065B30h case    3:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82065B30h case    3:*/		return 0x82065B34;
		  /* 82065B34h */ case    4:  		/* addi R11, R11, 4095 */
		/* 82065B34h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFF);
		/* 82065B34h case    4:*/		return 0x82065B38;
		  /* 82065B38h */ case    5:  		/* rlwinm R24, R11, 0, 0, 19 */
		/* 82065B38h case    5:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R24,regs.R11);
		/* 82065B38h case    5:*/		return 0x82065B3C;
	}
	return 0x82065B3C;
} // Block from 82065B24h-82065B3Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 82065B3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065B3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065B3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065B3C);
		  /* 82065B3Ch */ case    0:  		/* cmpwi CR6, R14, 0 */
		/* 82065B3Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R14,0x00000000);
		/* 82065B3Ch case    0:*/		return 0x82065B40;
		  /* 82065B40h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 82065B40h case    1:*/		if ( regs.CR[6].eq ) { return 0x82065B4C;  }
		/* 82065B40h case    1:*/		return 0x82065B44;
		  /* 82065B44h */ case    2:  		/* lwz R11, <#[R1 + 292]> */
		/* 82065B44h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000124) );
		/* 82065B44h case    2:*/		return 0x82065B48;
		  /* 82065B48h */ case    3:  		/* mullw R24, R24, R11 */
		/* 82065B48h case    3:*/		cpu::op::mullw<0>(regs,&regs.R24,regs.R24,regs.R11);
		/* 82065B48h case    3:*/		return 0x82065B4C;
	}
	return 0x82065B4C;
} // Block from 82065B3Ch-82065B4Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82065B4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065B4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065B4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065B4C);
		  /* 82065B4Ch */ case    0:  		/* cmplwi CR6, R15, 1 */
		/* 82065B4Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R15,0x00000001);
		/* 82065B4Ch case    0:*/		return 0x82065B50;
		  /* 82065B50h */ case    1:  		/* bc 12, CR6_GT, 12 */
		/* 82065B50h case    1:*/		if ( regs.CR[6].gt ) { return 0x82065B5C;  }
		/* 82065B50h case    1:*/		return 0x82065B54;
		  /* 82065B54h */ case    2:  		/* cmplwi CR6, R15, 0 */
		/* 82065B54h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R15,0x00000000);
		/* 82065B54h case    2:*/		return 0x82065B58;
		  /* 82065B58h */ case    3:  		/* bc 4, CR6_EQ, 268 */
		/* 82065B58h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82065C64;  }
		/* 82065B58h case    3:*/		return 0x82065B5C;
	}
	return 0x82065B5C;
} // Block from 82065B4Ch-82065B5Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82065B5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065B5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065B5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065B5C);
		  /* 82065B5Ch */ case    0:  		/* cmplw CR6, R25, R26 */
		/* 82065B5Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R26);
		/* 82065B5Ch case    0:*/		return 0x82065B60;
		  /* 82065B60h */ case    1:  		/* mr R11, R25 */
		/* 82065B60h case    1:*/		regs.R11 = regs.R25;
		/* 82065B60h case    1:*/		return 0x82065B64;
		  /* 82065B64h */ case    2:  		/* bc 12, CR6_GT, 8 */
		/* 82065B64h case    2:*/		if ( regs.CR[6].gt ) { return 0x82065B6C;  }
		/* 82065B64h case    2:*/		return 0x82065B68;
		  /* 82065B68h */ case    3:  		/* mr R11, R26 */
		/* 82065B68h case    3:*/		regs.R11 = regs.R26;
		/* 82065B68h case    3:*/		return 0x82065B6C;
	}
	return 0x82065B6C;
} // Block from 82065B5Ch-82065B6Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82065B6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065B6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065B6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065B6C);
		  /* 82065B6Ch */ case    0:  		/* cmplw CR6, R23, R11 */
		/* 82065B6Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R23,regs.R11);
		/* 82065B6Ch case    0:*/		return 0x82065B70;
		  /* 82065B70h */ case    1:  		/* bc 4, CR6_GT, 12 */
		/* 82065B70h case    1:*/		if ( !regs.CR[6].gt ) { return 0x82065B7C;  }
		/* 82065B70h case    1:*/		return 0x82065B74;
		  /* 82065B74h */ case    2:  		/* mr R11, R23 */
		/* 82065B74h case    2:*/		regs.R11 = regs.R23;
		/* 82065B74h case    2:*/		return 0x82065B78;
		  /* 82065B78h */ case    3:  		/* b 20 */
		/* 82065B78h case    3:*/		return 0x82065B8C;
		/* 82065B78h case    3:*/		return 0x82065B7C;
	}
	return 0x82065B7C;
} // Block from 82065B6Ch-82065B7Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82065B7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065B7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065B7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065B7C);
		  /* 82065B7Ch */ case    0:  		/* cmplw CR6, R25, R26 */
		/* 82065B7Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R26);
		/* 82065B7Ch case    0:*/		return 0x82065B80;
		  /* 82065B80h */ case    1:  		/* mr R11, R25 */
		/* 82065B80h case    1:*/		regs.R11 = regs.R25;
		/* 82065B80h case    1:*/		return 0x82065B84;
		  /* 82065B84h */ case    2:  		/* bc 12, CR6_GT, 8 */
		/* 82065B84h case    2:*/		if ( regs.CR[6].gt ) { return 0x82065B8C;  }
		/* 82065B84h case    2:*/		return 0x82065B88;
		  /* 82065B88h */ case    3:  		/* mr R11, R26 */
		/* 82065B88h case    3:*/		regs.R11 = regs.R26;
		/* 82065B88h case    3:*/		return 0x82065B8C;
	}
	return 0x82065B8C;
} // Block from 82065B7Ch-82065B8Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82065B8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065B8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065B8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065B8C);
		  /* 82065B8Ch */ case    0:  		/* cmplwi CR6, R15, 0 */
		/* 82065B8Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R15,0x00000000);
		/* 82065B8Ch case    0:*/		return 0x82065B90;
		  /* 82065B90h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 82065B90h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82065B9C;  }
		/* 82065B90h case    1:*/		return 0x82065B94;
		  /* 82065B94h */ case    2:  		/* cntlzw R11, R11 */
		/* 82065B94h case    2:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 82065B94h case    2:*/		return 0x82065B98;
		  /* 82065B98h */ case    3:  		/* subfic R15, R11, 32 */
		/* 82065B98h case    3:*/		cpu::op::subfic<0>(regs,&regs.R15,regs.R11,0x20);
		/* 82065B98h case    3:*/		return 0x82065B9C;
	}
	return 0x82065B9C;
} // Block from 82065B8Ch-82065B9Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82065B9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065B9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065B9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065B9C);
		  /* 82065B9Ch */ case    0:  		/* li R11, 15 */
		/* 82065B9Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0xF);
		/* 82065B9Ch case    0:*/		return 0x82065BA0;
		  /* 82065BA0h */ case    1:  		/* cntlzw R11, R11 */
		/* 82065BA0h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 82065BA0h case    1:*/		return 0x82065BA4;
		  /* 82065BA4h */ case    2:  		/* subfic R27, R11, 32 */
		/* 82065BA4h case    2:*/		cpu::op::subfic<0>(regs,&regs.R27,regs.R11,0x20);
		/* 82065BA4h case    2:*/		return 0x82065BA8;
		  /* 82065BA8h */ case    3:  		/* addic. R31, R15, -1 */
		/* 82065BA8h case    3:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R15,0xFFFFFFFF);
		/* 82065BA8h case    3:*/		return 0x82065BAC;
		  /* 82065BACh */ case    4:  		/* bc 12, CR0_EQ, 132 */
		/* 82065BACh case    4:*/		if ( regs.CR[0].eq ) { return 0x82065C30;  }
		/* 82065BACh case    4:*/		return 0x82065BB0;
		  /* 82065BB0h */ case    5:  		/* lwz R11, <#[R1 + 332]> */
		/* 82065BB0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000014C) );
		/* 82065BB0h case    5:*/		return 0x82065BB4;
		  /* 82065BB4h */ case    6:  		/* cmpwi CR6, R11, 0 */
		/* 82065BB4h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82065BB4h case    6:*/		return 0x82065BB8;
		  /* 82065BB8h */ case    7:  		/* bc 12, CR6_EQ, 20 */
		/* 82065BB8h case    7:*/		if ( regs.CR[6].eq ) { return 0x82065BCC;  }
		/* 82065BB8h case    7:*/		return 0x82065BBC;
		  /* 82065BBCh */ case    8:  		/* cmplw CR6, R29, R27 */
		/* 82065BBCh case    8:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R27);
		/* 82065BBCh case    8:*/		return 0x82065BC0;
		  /* 82065BC0h */ case    9:  		/* bc 4, CR6_GT, 112 */
		/* 82065BC0h case    9:*/		if ( !regs.CR[6].gt ) { return 0x82065C30;  }
		/* 82065BC0h case    9:*/		return 0x82065BC4;
		  /* 82065BC4h */ case   10:  		/* cmplw CR6, R30, R27 */
		/* 82065BC4h case   10:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R27);
		/* 82065BC4h case   10:*/		return 0x82065BC8;
		  /* 82065BC8h */ case   11:  		/* bc 4, CR6_GT, 104 */
		/* 82065BC8h case   11:*/		if ( !regs.CR[6].gt ) { return 0x82065C30;  }
		/* 82065BC8h case   11:*/		return 0x82065BCC;
	}
	return 0x82065BCC;
} // Block from 82065B9Ch-82065BCCh (12 instructions)

//////////////////////////////////////////////////////
// Block at 82065BCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065BCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065BCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065BCC);
		  /* 82065BCCh */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 82065BCCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82065BCCh case    0:*/		return 0x82065BD0;
		  /* 82065BD0h */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 82065BD0h case    1:*/		if ( regs.CR[6].eq ) { return 0x82065BD8;  }
		/* 82065BD0h case    1:*/		return 0x82065BD4;
		  /* 82065BD4h */ case    2:  		/* addi R29, R29, -1 */
		/* 82065BD4h case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0xFFFFFFFF);
		/* 82065BD4h case    2:*/		return 0x82065BD8;
	}
	return 0x82065BD8;
} // Block from 82065BCCh-82065BD8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82065BD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065BD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065BD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065BD8);
		  /* 82065BD8h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 82065BD8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82065BD8h case    0:*/		return 0x82065BDC;
		  /* 82065BDCh */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 82065BDCh case    1:*/		if ( regs.CR[6].eq ) { return 0x82065BE4;  }
		/* 82065BDCh case    1:*/		return 0x82065BE0;
		  /* 82065BE0h */ case    2:  		/* addi R30, R30, -1 */
		/* 82065BE0h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0xFFFFFFFF);
		/* 82065BE0h case    2:*/		return 0x82065BE4;
	}
	return 0x82065BE4;
} // Block from 82065BD8h-82065BE4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82065BE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065BE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065BE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065BE4);
		  /* 82065BE4h */ case    0:  		/* cmplwi CR6, R28, 1 */
		/* 82065BE4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000001);
		/* 82065BE4h case    0:*/		return 0x82065BE8;
		  /* 82065BE8h */ case    1:  		/* bc 4, CR6_GT, 8 */
		/* 82065BE8h case    1:*/		if ( !regs.CR[6].gt ) { return 0x82065BF0;  }
		/* 82065BE8h case    1:*/		return 0x82065BEC;
		  /* 82065BECh */ case    2:  		/* rlwinm R28, R28, 31, 1, 31 */
		/* 82065BECh case    2:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R28,regs.R28);
		/* 82065BECh case    2:*/		return 0x82065BF0;
	}
	return 0x82065BF0;
} // Block from 82065BE4h-82065BF0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82065BF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065BF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065BF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065BF0);
		  /* 82065BF0h */ case    0:  		/* slw R11, R19, R29 */
		/* 82065BF0h case    0:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R19,regs.R29);
		/* 82065BF0h case    0:*/		return 0x82065BF4;
		  /* 82065BF4h */ case    1:  		/* stw R28, <#[R1 + 88]> */
		/* 82065BF4h case    1:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000058) );
		/* 82065BF4h case    1:*/		return 0x82065BF8;
		  /* 82065BF8h */ case    2:  		/* slw R10, R19, R30 */
		/* 82065BF8h case    2:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R19,regs.R30);
		/* 82065BF8h case    2:*/		return 0x82065BFC;
		  /* 82065BFCh */ case    3:  		/* stw R11, <#[R1 + 80]> */
		/* 82065BFCh case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82065BFCh case    3:*/		return 0x82065C00;
		  /* 82065C00h */ case    4:  		/* stw R10, <#[R1 + 84]> */
		/* 82065C00h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 82065C00h case    4:*/		return 0x82065C04;
		  /* 82065C04h */ case    5:  		/* mr R9, R16 */
		/* 82065C04h case    5:*/		regs.R9 = regs.R16;
		/* 82065C04h case    5:*/		return 0x82065C08;
		  /* 82065C08h */ case    6:  		/* mr R8, R22 */
		/* 82065C08h case    6:*/		regs.R8 = regs.R22;
		/* 82065C08h case    6:*/		return 0x82065C0C;
		  /* 82065C0Ch */ case    7:  		/* mr R7, R20 */
		/* 82065C0Ch case    7:*/		regs.R7 = regs.R20;
		/* 82065C0Ch case    7:*/		return 0x82065C10;
		  /* 82065C10h */ case    8:  		/* mr R6, R21 */
		/* 82065C10h case    8:*/		regs.R6 = regs.R21;
		/* 82065C10h case    8:*/		return 0x82065C14;
		  /* 82065C14h */ case    9:  		/* addi R5, R1, 88 */
		/* 82065C14h case    9:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x58);
		/* 82065C14h case    9:*/		return 0x82065C18;
		  /* 82065C18h */ case   10:  		/* addi R4, R1, 84 */
		/* 82065C18h case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x54);
		/* 82065C18h case   10:*/		return 0x82065C1C;
		  /* 82065C1Ch */ case   11:  		/* addi R3, R1, 80 */
		/* 82065C1Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82065C1Ch case   11:*/		return 0x82065C20;
		  /* 82065C20h */ case   12:  		/* bl -1080 */
		/* 82065C20h case   12:*/		regs.LR = 0x82065C24; return 0x820657E8;
		/* 82065C20h case   12:*/		return 0x82065C24;
		  /* 82065C24h */ case   13:  		/* addic. R31, R31, -1 */
		/* 82065C24h case   13:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 82065C24h case   13:*/		return 0x82065C28;
		  /* 82065C28h */ case   14:  		/* add R17, R3, R17 */
		/* 82065C28h case   14:*/		cpu::op::add<0>(regs,&regs.R17,regs.R3,regs.R17);
		/* 82065C28h case   14:*/		return 0x82065C2C;
		  /* 82065C2Ch */ case   15:  		/* bc 4, CR0_EQ, -124 */
		/* 82065C2Ch case   15:*/		if ( !regs.CR[0].eq ) { return 0x82065BB0;  }
		/* 82065C2Ch case   15:*/		return 0x82065C30;
	}
	return 0x82065C30;
} // Block from 82065BF0h-82065C30h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82065C30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065C30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065C30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065C30);
		  /* 82065C30h */ case    0:  		/* cmpwi CR6, R14, 0 */
		/* 82065C30h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R14,0x00000000);
		/* 82065C30h case    0:*/		return 0x82065C34;
		  /* 82065C34h */ case    1:  		/* bc 12, CR6_EQ, 48 */
		/* 82065C34h case    1:*/		if ( regs.CR[6].eq ) { return 0x82065C64;  }
		/* 82065C34h case    1:*/		return 0x82065C38;
		  /* 82065C38h */ case    2:  		/* lwz R11, <#[R1 + 92]> */
		/* 82065C38h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 82065C38h case    2:*/		return 0x82065C3C;
		  /* 82065C3Ch */ case    3:  		/* lwz R10, <#[R1 + 292]> */
		/* 82065C3Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000124) );
		/* 82065C3Ch case    3:*/		return 0x82065C40;
		  /* 82065C40h */ case    4:  		/* subfic R11, R11, 0 */
		/* 82065C40h case    4:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x0);
		/* 82065C40h case    4:*/		return 0x82065C44;
		  /* 82065C44h */ case    5:  		/* subfe R11, R11, R11 */
		/* 82065C44h case    5:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82065C44h case    5:*/		return 0x82065C48;
		  /* 82065C48h */ case    6:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 82065C48h case    6:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 82065C48h case    6:*/		return 0x82065C4C;
		  /* 82065C4Ch */ case    7:  		/* addi R11, R11, 1 */
		/* 82065C4Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82065C4Ch case    7:*/		return 0x82065C50;
		  /* 82065C50h */ case    8:  		/* add R10, R11, R10 */
		/* 82065C50h case    8:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 82065C50h case    8:*/		return 0x82065C54;
		  /* 82065C54h */ case    9:  		/* addi R11, R11, -1 */
		/* 82065C54h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82065C54h case    9:*/		return 0x82065C58;
		  /* 82065C58h */ case   10:  		/* addi R10, R10, -1 */
		/* 82065C58h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82065C58h case   10:*/		return 0x82065C5C;
		  /* 82065C5Ch */ case   11:  		/* andc R11, R10, R11 */
		/* 82065C5Ch case   11:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82065C5Ch case   11:*/		return 0x82065C60;
		  /* 82065C60h */ case   12:  		/* mullw R17, R11, R17 */
		/* 82065C60h case   12:*/		cpu::op::mullw<0>(regs,&regs.R17,regs.R11,regs.R17);
		/* 82065C60h case   12:*/		return 0x82065C64;
	}
	return 0x82065C64;
} // Block from 82065C30h-82065C64h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82065C64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065C64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065C64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065C64);
		  /* 82065C64h */ case    0:  		/* lwz R11, <#[R1 + 364]> */
		/* 82065C64h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000016C) );
		/* 82065C64h case    0:*/		return 0x82065C68;
		  /* 82065C68h */ case    1:  		/* mr R3, R15 */
		/* 82065C68h case    1:*/		regs.R3 = regs.R15;
		/* 82065C68h case    1:*/		return 0x82065C6C;
		  /* 82065C6Ch */ case    2:  		/* lwz R10, <#[R1 + 372]> */
		/* 82065C6Ch case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000174) );
		/* 82065C6Ch case    2:*/		return 0x82065C70;
		  /* 82065C70h */ case    3:  		/* lwz R9, <#[R1 + 380]> */
		/* 82065C70h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x0000017C) );
		/* 82065C70h case    3:*/		return 0x82065C74;
		  /* 82065C74h */ case    4:  		/* stw R18, <#[R11]> */
		/* 82065C74h case    4:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R11 + 0x00000000) );
		/* 82065C74h case    4:*/		return 0x82065C78;
		  /* 82065C78h */ case    5:  		/* stw R24, <#[R10]> */
		/* 82065C78h case    5:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R10 + 0x00000000) );
		/* 82065C78h case    5:*/		return 0x82065C7C;
		  /* 82065C7Ch */ case    6:  		/* stw R17, <#[R9]> */
		/* 82065C7Ch case    6:*/		cpu::mem::store32( regs, regs.R17, (uint32)(regs.R9 + 0x00000000) );
		/* 82065C7Ch case    6:*/		return 0x82065C80;
		  /* 82065C80h */ case    7:  		/* addi R1, R1, 256 */
		/* 82065C80h case    7:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x100);
		/* 82065C80h case    7:*/		return 0x82065C84;
		  /* 82065C84h */ case    8:  		/* b 177644 */
		/* 82065C84h case    8:*/		return 0x82091270;
		/* 82065C84h case    8:*/		return 0x82065C88;
	}
	return 0x82065C88;
} // Block from 82065C64h-82065C88h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82065C88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065C88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065C88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065C88);
		  /* 82065C88h */ case    0:  		/* mfspr R12, LR */
		/* 82065C88h case    0:*/		regs.R12 = regs.LR;
		/* 82065C88h case    0:*/		return 0x82065C8C;
		  /* 82065C8Ch */ case    1:  		/* bl 177596 */
		/* 82065C8Ch case    1:*/		regs.LR = 0x82065C90; return 0x82091248;
		/* 82065C8Ch case    1:*/		return 0x82065C90;
		  /* 82065C90h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 82065C90h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 82065C90h case    2:*/		return 0x82065C94;
		  /* 82065C94h */ case    3:  		/* lis R11, -32256 */
		/* 82065C94h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82065C94h case    3:*/		return 0x82065C98;
		  /* 82065C98h */ case    4:  		/* mr R25, R10 */
		/* 82065C98h case    4:*/		regs.R25 = regs.R10;
		/* 82065C98h case    4:*/		return 0x82065C9C;
		  /* 82065C9Ch */ case    5:  		/* addi R10, R11, 2992 */
		/* 82065C9Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xBB0);
		/* 82065C9Ch case    5:*/		return 0x82065CA0;
		  /* 82065CA0h */ case    6:  		/* mr R26, R8 */
		/* 82065CA0h case    6:*/		regs.R26 = regs.R8;
		/* 82065CA0h case    6:*/		return 0x82065CA4;
		  /* 82065CA4h */ case    7:  		/* addi R8, R1, 100 */
		/* 82065CA4h case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x64);
		/* 82065CA4h case    7:*/		return 0x82065CA8;
		  /* 82065CA8h */ case    8:  		/* mr R27, R7 */
		/* 82065CA8h case    8:*/		regs.R27 = regs.R7;
		/* 82065CA8h case    8:*/		return 0x82065CAC;
		  /* 82065CACh */ case    9:  		/* li R11, 0 */
		/* 82065CACh case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82065CACh case    9:*/		return 0x82065CB0;
		  /* 82065CB0h */ case   10:  		/* rlwinm R7, R9, 1, 0, 30 */
		/* 82065CB0h case   10:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R7,regs.R9);
		/* 82065CB0h case   10:*/		return 0x82065CB4;
		  /* 82065CB4h */ case   11:  		/* addi R10, R10, 1 */
		/* 82065CB4h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82065CB4h case   11:*/		return 0x82065CB8;
		  /* 82065CB8h */ case   12:  		/* stw R11, <#[R1 + 96]> */
		/* 82065CB8h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82065CB8h case   12:*/		return 0x82065CBC;
		  /* 82065CBCh */ case   13:  		/* mr R31, R3 */
		/* 82065CBCh case   13:*/		regs.R31 = regs.R3;
		/* 82065CBCh case   13:*/		return 0x82065CC0;
		  /* 82065CC0h */ case   14:  		/* stw R11, <#[R8]> */
		/* 82065CC0h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 82065CC0h case   14:*/		return 0x82065CC4;
		  /* 82065CC4h */ case   15:  		/* mr R30, R4 */
		/* 82065CC4h case   15:*/		regs.R30 = regs.R4;
		/* 82065CC4h case   15:*/		return 0x82065CC8;
		  /* 82065CC8h */ case   16:  		/* stw R11, <#[R8 + 4]> */
		/* 82065CC8h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00000004) );
		/* 82065CC8h case   16:*/		return 0x82065CCC;
		  /* 82065CCCh */ case   17:  		/* mr R29, R5 */
		/* 82065CCCh case   17:*/		regs.R29 = regs.R5;
		/* 82065CCCh case   17:*/		return 0x82065CD0;
		  /* 82065CD0h */ case   18:  		/* addi R5, R1, 84 */
		/* 82065CD0h case   18:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 82065CD0h case   18:*/		return 0x82065CD4;
		  /* 82065CD4h */ case   19:  		/* addi R4, R1, 80 */
		/* 82065CD4h case   19:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 82065CD4h case   19:*/		return 0x82065CD8;
		  /* 82065CD8h */ case   20:  		/* lbzx R24, <#[R7 + R10]> */
		/* 82065CD8h case   20:*/		cpu::mem::load8z( regs, &regs.R24, (uint32)(regs.R7 + regs.R10 + 0x00000000) );
		/* 82065CD8h case   20:*/		return 0x82065CDC;
		  /* 82065CDCh */ case   21:  		/* mr R3, R9 */
		/* 82065CDCh case   21:*/		regs.R3 = regs.R9;
		/* 82065CDCh case   21:*/		return 0x82065CE0;
		  /* 82065CE0h */ case   22:  		/* mr R28, R6 */
		/* 82065CE0h case   22:*/		regs.R28 = regs.R6;
		/* 82065CE0h case   22:*/		return 0x82065CE4;
		  /* 82065CE4h */ case   23:  		/* bl -1564 */
		/* 82065CE4h case   23:*/		regs.LR = 0x82065CE8; return 0x820656C8;
		/* 82065CE4h case   23:*/		return 0x82065CE8;
		  /* 82065CE8h */ case   24:  		/* addi R11, R30, -1 */
		/* 82065CE8h case   24:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xFFFFFFFF);
		/* 82065CE8h case   24:*/		return 0x82065CEC;
		  /* 82065CECh */ case   25:  		/* addi R10, R29, -1 */
		/* 82065CECh case   25:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R29,0xFFFFFFFF);
		/* 82065CECh case   25:*/		return 0x82065CF0;
		  /* 82065CF0h */ case   26:  		/* cntlzw R11, R11 */
		/* 82065CF0h case   26:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 82065CF0h case   26:*/		return 0x82065CF4;
		  /* 82065CF4h */ case   27:  		/* addi R9, R28, -1 */
		/* 82065CF4h case   27:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R28,0xFFFFFFFF);
		/* 82065CF4h case   27:*/		return 0x82065CF8;
		  /* 82065CF8h */ case   28:  		/* cntlzw R10, R10 */
		/* 82065CF8h case   28:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R10);
		/* 82065CF8h case   28:*/		return 0x82065CFC;
		  /* 82065CFCh */ case   29:  		/* subfic R11, R11, 32 */
		/* 82065CFCh case   29:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x20);
		/* 82065CFCh case   29:*/		return 0x82065D00;
		  /* 82065D00h */ case   30:  		/* cntlzw R9, R9 */
		/* 82065D00h case   30:*/		cpu::op::cntlzw<0>(regs,&regs.R9,regs.R9);
		/* 82065D00h case   30:*/		return 0x82065D04;
		  /* 82065D04h */ case   31:  		/* subfic R10, R10, 32 */
		/* 82065D04h case   31:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R10,0x20);
		/* 82065D04h case   31:*/		return 0x82065D08;
		  /* 82065D08h */ case   32:  		/* subfic R8, R9, 32 */
		/* 82065D08h case   32:*/		cpu::op::subfic<0>(regs,&regs.R8,regs.R9,0x20);
		/* 82065D08h case   32:*/		return 0x82065D0C;
		  /* 82065D0Ch */ case   33:  		/* subfc R9, R11, R10 */
		/* 82065D0Ch case   33:*/		cpu::op::subfc<0>(regs,&regs.R9,regs.R11,regs.R10);
		/* 82065D0Ch case   33:*/		return 0x82065D10;
		  /* 82065D10h */ case   34:  		/* li R9, 1 */
		/* 82065D10h case   34:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82065D10h case   34:*/		return 0x82065D14;
		  /* 82065D14h */ case   35:  		/* subfe R7, R7, R7 */
		/* 82065D14h case   35:*/		cpu::op::subfe<0>(regs,&regs.R7,regs.R7,regs.R7);
		/* 82065D14h case   35:*/		return 0x82065D18;
		  /* 82065D18h */ case   36:  		/* slw R11, R9, R11 */
		/* 82065D18h case   36:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82065D18h case   36:*/		return 0x82065D1C;
		  /* 82065D1Ch */ case   37:  		/* stw R11, <#[R1 + 88]> */
		/* 82065D1Ch case   37:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 82065D1Ch case   37:*/		return 0x82065D20;
		  /* 82065D20h */ case   38:  		/* slw R10, R9, R10 */
		/* 82065D20h case   38:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82065D20h case   38:*/		return 0x82065D24;
		  /* 82065D24h */ case   39:  		/* rlwinm R11, R7, 0, 31, 31 */
		/* 82065D24h case   39:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R11,regs.R7);
		/* 82065D24h case   39:*/		return 0x82065D28;
		  /* 82065D28h */ case   40:  		/* stw R10, <#[R1 + 92]> */
		/* 82065D28h case   40:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x0000005C) );
		/* 82065D28h case   40:*/		return 0x82065D2C;
		  /* 82065D2Ch */ case   41:  		/* cmplwi CR6, R31, 3 */
		/* 82065D2Ch case   41:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000003);
		/* 82065D2Ch case   41:*/		return 0x82065D30;
		  /* 82065D30h */ case   42:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82065D30h case   42:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82065D30h case   42:*/		return 0x82065D34;
		  /* 82065D34h */ case   43:  		/* bc 4, CR6_LT, 112 */
		/* 82065D34h case   43:*/		if ( !regs.CR[6].lt ) { return 0x82065DA4;  }
		/* 82065D34h case   43:*/		return 0x82065D38;
		  /* 82065D38h */ case   44:  		/* li R10, 16 */
		/* 82065D38h case   44:*/		cpu::op::li<0>(regs,&regs.R10,0x10);
		/* 82065D38h case   44:*/		return 0x82065D3C;
		  /* 82065D3Ch */ case   45:  		/* addi R9, R1, 96 */
		/* 82065D3Ch case   45:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x60);
		/* 82065D3Ch case   45:*/		return 0x82065D40;
		  /* 82065D40h */ case   46:  		/* sraw R10, R10, R31 */
		/* 82065D40h case   46:*/		cpu::op::sraw<0>(regs,&regs.R10,regs.R10,regs.R31);
		/* 82065D40h case   46:*/		return 0x82065D44;
		  /* 82065D44h */ case   47:  		/* stwx R10, <#[R11 + R9]> */
		/* 82065D44h case   47:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 82065D44h case   47:*/		return 0x82065D48;
		  /* 82065D48h */ case   48:  		/* lwz R11, <#[R1 + 104]> */
		/* 82065D48h case   48:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 82065D48h case   48:*/		return 0x82065D4C;
		  /* 82065D4Ch */ case   49:  		/* lwz R10, <#[R1 + 80]> */
		/* 82065D4Ch case   49:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 82065D4Ch case   49:*/		return 0x82065D50;
		  /* 82065D50h */ case   50:  		/* lwz R9, <#[R1 + 96]> */
		/* 82065D50h case   50:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000060) );
		/* 82065D50h case   50:*/		return 0x82065D54;
		  /* 82065D54h */ case   51:  		/* mullw R7, R10, R24 */
		/* 82065D54h case   51:*/		cpu::op::mullw<0>(regs,&regs.R7,regs.R10,regs.R24);
		/* 82065D54h case   51:*/		return 0x82065D58;
		  /* 82065D58h */ case   52:  		/* lwz R8, <#[R1 + 100]> */
		/* 82065D58h case   52:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000064) );
		/* 82065D58h case   52:*/		return 0x82065D5C;
		  /* 82065D5Ch */ case   53:  		/* lwz R5, <#[R1 + 84]> */
		/* 82065D5Ch case   53:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000054) );
		/* 82065D5Ch case   53:*/		return 0x82065D60;
		  /* 82065D60h */ case   54:  		/* lwz R4, <#[R1 + 276]> */
		/* 82065D60h case   54:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000114) );
		/* 82065D60h case   54:*/		return 0x82065D64;
		  /* 82065D64h */ case   55:  		/* lwz R3, <#[R1 + 284]> */
		/* 82065D64h case   55:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x0000011C) );
		/* 82065D64h case   55:*/		return 0x82065D68;
		  /* 82065D68h */ case   56:  		/* mullw R7, R7, R9 */
		/* 82065D68h case   56:*/		cpu::op::mullw<0>(regs,&regs.R7,regs.R7,regs.R9);
		/* 82065D68h case   56:*/		return 0x82065D6C;
		  /* 82065D6Ch */ case   57:  		/* twi 6, R10, 0 */
		/* 82065D6Ch case   57:*/		cpu::op::tw<6>(regs, 0x82065D6C, regs.R10, 0x00000000);
		/* 82065D6Ch case   57:*/		return 0x82065D70;
		  /* 82065D70h */ case   58:  		/* divwu R10, R9, R10 */
		/* 82065D70h case   58:*/		cpu::op::divwu<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82065D70h case   58:*/		return 0x82065D74;
		  /* 82065D74h */ case   59:  		/* rlwinm R6, R7, 29, 3, 31 */
		/* 82065D74h case   59:*/		cpu::op::rlwinm<0,29,3,31>(regs,&regs.R6,regs.R7);
		/* 82065D74h case   59:*/		return 0x82065D78;
		  /* 82065D78h */ case   60:  		/* mullw R7, R8, R27 */
		/* 82065D78h case   60:*/		cpu::op::mullw<0>(regs,&regs.R7,regs.R8,regs.R27);
		/* 82065D78h case   60:*/		return 0x82065D7C;
		  /* 82065D7Ch */ case   61:  		/* stw R10, <#[R25]> */
		/* 82065D7Ch case   61:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R25 + 0x00000000) );
		/* 82065D7Ch case   61:*/		return 0x82065D80;
		  /* 82065D80h */ case   62:  		/* divwu R8, R8, R5 */
		/* 82065D80h case   62:*/		cpu::op::divwu<0>(regs,&regs.R8,regs.R8,regs.R5);
		/* 82065D80h case   62:*/		return 0x82065D84;
		  /* 82065D84h */ case   63:  		/* add R9, R6, R7 */
		/* 82065D84h case   63:*/		cpu::op::add<0>(regs,&regs.R9,regs.R6,regs.R7);
		/* 82065D84h case   63:*/		return 0x82065D88;
		  /* 82065D88h */ case   64:  		/* mullw R10, R11, R26 */
		/* 82065D88h case   64:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R11,regs.R26);
		/* 82065D88h case   64:*/		return 0x82065D8C;
		  /* 82065D8Ch */ case   65:  		/* stw R8, <#[R4]> */
		/* 82065D8Ch case   65:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R4 + 0x00000000) );
		/* 82065D8Ch case   65:*/		return 0x82065D90;
		  /* 82065D90h */ case   66:  		/* stw R11, <#[R3]> */
		/* 82065D90h case   66:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82065D90h case   66:*/		return 0x82065D94;
		  /* 82065D94h */ case   67:  		/* twi 6, R5, 0 */
		/* 82065D94h case   67:*/		cpu::op::tw<6>(regs, 0x82065D94, regs.R5, 0x00000000);
		/* 82065D94h case   67:*/		return 0x82065D98;
		  /* 82065D98h */ case   68:  		/* add R3, R9, R10 */
		/* 82065D98h case   68:*/		cpu::op::add<0>(regs,&regs.R3,regs.R9,regs.R10);
		/* 82065D98h case   68:*/		return 0x82065D9C;
		  /* 82065D9Ch */ case   69:  		/* addi R1, R1, 192 */
		/* 82065D9Ch case   69:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 82065D9Ch case   69:*/		return 0x82065DA0;
		  /* 82065DA0h */ case   70:  		/* b 177400 */
		/* 82065DA0h case   70:*/		return 0x82091298;
		/* 82065DA0h case   70:*/		return 0x82065DA4;
	}
	return 0x82065DA4;
} // Block from 82065C88h-82065DA4h (71 instructions)

//////////////////////////////////////////////////////
// Block at 82065DA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065DA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065DA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065DA4);
		  /* 82065DA4h */ case    0:  		/* xori R11, R11, 4 */
		/* 82065DA4h case    0:*/		cpu::op::xori<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82065DA4h case    0:*/		return 0x82065DA8;
		  /* 82065DA8h */ case    1:  		/* addi R10, R1, 88 */
		/* 82065DA8h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x58);
		/* 82065DA8h case    1:*/		return 0x82065DAC;
		  /* 82065DACh */ case    2:  		/* addi R7, R31, -2 */
		/* 82065DACh case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R31,0xFFFFFFFE);
		/* 82065DACh case    2:*/		return 0x82065DB0;
		  /* 82065DB0h */ case    3:  		/* addi R6, R1, 96 */
		/* 82065DB0h case    3:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x60);
		/* 82065DB0h case    3:*/		return 0x82065DB4;
		  /* 82065DB4h */ case    4:  		/* lwzx R10, <#[R11 + R10]> */
		/* 82065DB4h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82065DB4h case    4:*/		return 0x82065DB8;
		  /* 82065DB8h */ case    5:  		/* srw R10, R10, R7 */
		/* 82065DB8h case    5:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R10,regs.R7);
		/* 82065DB8h case    5:*/		return 0x82065DBC;
		  /* 82065DBCh */ case    6:  		/* stwx R10, <#[R11 + R6]> */
		/* 82065DBCh case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R6 + 0x00000000) );
		/* 82065DBCh case    6:*/		return 0x82065DC0;
		  /* 82065DC0h */ case    7:  		/* cmplwi CR6, R10, 4 */
		/* 82065DC0h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000004);
		/* 82065DC0h case    7:*/		return 0x82065DC4;
		  /* 82065DC4h */ case    8:  		/* bc 4, CR6_LT, -124 */
		/* 82065DC4h case    8:*/		if ( !regs.CR[6].lt ) { return 0x82065D48;  }
		/* 82065DC4h case    8:*/		return 0x82065DC8;
		  /* 82065DC8h */ case    9:  		/* subf R11, R31, R8 */
		/* 82065DC8h case    9:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R31,regs.R8);
		/* 82065DC8h case    9:*/		return 0x82065DCC;
		  /* 82065DCCh */ case   10:  		/* cmplwi CR6, R11, 1 */
		/* 82065DCCh case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82065DCCh case   10:*/		return 0x82065DD0;
		  /* 82065DD0h */ case   11:  		/* bc 12, CR6_GT, 8 */
		/* 82065DD0h case   11:*/		if ( regs.CR[6].gt ) { return 0x82065DD8;  }
		/* 82065DD0h case   11:*/		return 0x82065DD4;
		  /* 82065DD4h */ case   12:  		/* mr R11, R9 */
		/* 82065DD4h case   12:*/		regs.R11 = regs.R9;
		/* 82065DD4h case   12:*/		return 0x82065DD8;
	}
	return 0x82065DD8;
} // Block from 82065DA4h-82065DD8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82065DD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065DD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065DD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065DD8);
		  /* 82065DD8h */ case    0:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82065DD8h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82065DD8h case    0:*/		return 0x82065DDC;
		  /* 82065DDCh */ case    1:  		/* b -144 */
		/* 82065DDCh case    1:*/		return 0x82065D4C;
		/* 82065DDCh case    1:*/		return 0x82065DE0;
	}
	return 0x82065DE0;
} // Block from 82065DD8h-82065DE0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82065DE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065DE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065DE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065DE0);
		  /* 82065DE0h */ case    0:  		/* mfspr R12, LR */
		/* 82065DE0h case    0:*/		regs.R12 = regs.LR;
		/* 82065DE0h case    0:*/		return 0x82065DE4;
		  /* 82065DE4h */ case    1:  		/* bl 177216 */
		/* 82065DE4h case    1:*/		regs.LR = 0x82065DE8; return 0x82091224;
		/* 82065DE4h case    1:*/		return 0x82065DE8;
		  /* 82065DE8h */ case    2:  		/* stwu R1, <#[R1 - 256]> */
		/* 82065DE8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF00) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF00);
		/* 82065DE8h case    2:*/		return 0x82065DEC;
		  /* 82065DECh */ case    3:  		/* lwz R10, <#[R3 + 32]> */
		/* 82065DECh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000020) );
		/* 82065DECh case    3:*/		return 0x82065DF0;
		  /* 82065DF0h */ case    4:  		/* lis R11, -32256 */
		/* 82065DF0h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82065DF0h case    4:*/		return 0x82065DF4;
		  /* 82065DF4h */ case    5:  		/* mr R30, R3 */
		/* 82065DF4h case    5:*/		regs.R30 = regs.R3;
		/* 82065DF4h case    5:*/		return 0x82065DF8;
		  /* 82065DF8h */ case    6:  		/* addi R11, R11, 2992 */
		/* 82065DF8h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xBB0);
		/* 82065DF8h case    6:*/		return 0x82065DFC;
		  /* 82065DFCh */ case    7:  		/* rlwinm R22, R10, 0, 26, 31 */
		/* 82065DFCh case    7:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R22,regs.R10);
		/* 82065DFCh case    7:*/		return 0x82065E00;
		  /* 82065E00h */ case    8:  		/* addi R11, R11, 1 */
		/* 82065E00h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82065E00h case    8:*/		return 0x82065E04;
		  /* 82065E04h */ case    9:  		/* rlwinm R10, R22, 1, 0, 30 */
		/* 82065E04h case    9:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R22);
		/* 82065E04h case    9:*/		return 0x82065E08;
		  /* 82065E08h */ case   10:  		/* mr R23, R4 */
		/* 82065E08h case   10:*/		regs.R23 = regs.R4;
		/* 82065E08h case   10:*/		return 0x82065E0C;
		  /* 82065E0Ch */ case   11:  		/* mr R20, R5 */
		/* 82065E0Ch case   11:*/		regs.R20 = regs.R5;
		/* 82065E0Ch case   11:*/		return 0x82065E10;
		  /* 82065E10h */ case   12:  		/* mr R19, R6 */
		/* 82065E10h case   12:*/		regs.R19 = regs.R6;
		/* 82065E10h case   12:*/		return 0x82065E14;
		  /* 82065E14h */ case   13:  		/* mr R18, R7 */
		/* 82065E14h case   13:*/		regs.R18 = regs.R7;
		/* 82065E14h case   13:*/		return 0x82065E18;
		  /* 82065E18h */ case   14:  		/* lbzx R21, <#[R10 + R11]> */
		/* 82065E18h case   14:*/		cpu::mem::load8z( regs, &regs.R21, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82065E18h case   14:*/		return 0x82065E1C;
		  /* 82065E1Ch */ case   15:  		/* mr R17, R8 */
		/* 82065E1Ch case   15:*/		regs.R17 = regs.R8;
		/* 82065E1Ch case   15:*/		return 0x82065E20;
		  /* 82065E20h */ case   16:  		/* mr R16, R9 */
		/* 82065E20h case   16:*/		regs.R16 = regs.R9;
		/* 82065E20h case   16:*/		return 0x82065E24;
		  /* 82065E24h */ case   17:  		/* bl 46268 */
		/* 82065E24h case   17:*/		regs.LR = 0x82065E28; return 0x820712E0;
		/* 82065E24h case   17:*/		return 0x82065E28;
		  /* 82065E28h */ case   18:  		/* mr R15, R3 */
		/* 82065E28h case   18:*/		regs.R15 = regs.R3;
		/* 82065E28h case   18:*/		return 0x82065E2C;
		  /* 82065E2Ch */ case   19:  		/* cmpwi CR6, R3, 4 */
		/* 82065E2Ch case   19:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000004);
		/* 82065E2Ch case   19:*/		return 0x82065E30;
		  /* 82065E30h */ case   20:  		/* addi R6, R1, 100 */
		/* 82065E30h case   20:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x64);
		/* 82065E30h case   20:*/		return 0x82065E34;
		  /* 82065E34h */ case   21:  		/* addi R5, R1, 96 */
		/* 82065E34h case   21:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x60);
		/* 82065E34h case   21:*/		return 0x82065E38;
		  /* 82065E38h */ case   22:  		/* addi R4, R1, 92 */
		/* 82065E38h case   22:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x5C);
		/* 82065E38h case   22:*/		return 0x82065E3C;
		  /* 82065E3Ch */ case   23:  		/* mr R3, R30 */
		/* 82065E3Ch case   23:*/		regs.R3 = regs.R30;
		/* 82065E3Ch case   23:*/		return 0x82065E40;
		  /* 82065E40h */ case   24:  		/* bc 4, CR6_EQ, 88 */
		/* 82065E40h case   24:*/		if ( !regs.CR[6].eq ) { return 0x82065E98;  }
		/* 82065E40h case   24:*/		return 0x82065E44;
		  /* 82065E44h */ case   25:  		/* bl -2340 */
		/* 82065E44h case   25:*/		regs.LR = 0x82065E48; return 0x82065520;
		/* 82065E44h case   25:*/		return 0x82065E48;
		  /* 82065E48h */ case   26:  		/* lwz R11, <#[R30 + 28]> */
		/* 82065E48h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 82065E48h case   26:*/		return 0x82065E4C;
		  /* 82065E4Ch */ case   27:  		/* lwz R10, <#[R30 + 48]> */
		/* 82065E4Ch case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000030) );
		/* 82065E4Ch case   27:*/		return 0x82065E50;
		  /* 82065E50h */ case   28:  		/* mr R7, R22 */
		/* 82065E50h case   28:*/		regs.R7 = regs.R22;
		/* 82065E50h case   28:*/		return 0x82065E54;
		  /* 82065E54h */ case   29:  		/* rlwinm R9, R11, 10, 23, 31 */
		/* 82065E54h case   29:*/		cpu::op::rlwinm<0,10,23,31>(regs,&regs.R9,regs.R11);
		/* 82065E54h case   29:*/		return 0x82065E58;
		  /* 82065E58h */ case   30:  		/* mr R6, R21 */
		/* 82065E58h case   30:*/		regs.R6 = regs.R21;
		/* 82065E58h case   30:*/		return 0x82065E5C;
		  /* 82065E5Ch */ case   31:  		/* mullw R31, R9, R21 */
		/* 82065E5Ch case   31:*/		cpu::op::mullw<0>(regs,&regs.R31,regs.R9,regs.R21);
		/* 82065E5Ch case   31:*/		return 0x82065E60;
		  /* 82065E60h */ case   32:  		/* addi R5, R1, 84 */
		/* 82065E60h case   32:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 82065E60h case   32:*/		return 0x82065E64;
		  /* 82065E64h */ case   33:  		/* addi R4, R1, 80 */
		/* 82065E64h case   33:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 82065E64h case   33:*/		return 0x82065E68;
		  /* 82065E68h */ case   34:  		/* addi R3, R1, 88 */
		/* 82065E68h case   34:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x58);
		/* 82065E68h case   34:*/		return 0x82065E6C;
		  /* 82065E6Ch */ case   35:  		/* rlwinm R9, R11, 1, 31, 31 */
		/* 82065E6Ch case   35:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R9,regs.R11);
		/* 82065E6Ch case   35:*/		return 0x82065E70;
		  /* 82065E70h */ case   36:  		/* rlwinm R8, R10, 23, 30, 31 */
		/* 82065E70h case   36:*/		cpu::op::rlwinm<0,23,30,31>(regs,&regs.R8,regs.R10);
		/* 82065E70h case   36:*/		return 0x82065E74;
		  /* 82065E74h */ case   37:  		/* rlwinm R31, R31, 2, 3, 29 */
		/* 82065E74h case   37:*/		cpu::op::rlwinm<0,2,3,29>(regs,&regs.R31,regs.R31);
		/* 82065E74h case   37:*/		return 0x82065E78;
		  /* 82065E78h */ case   38:  		/* lwz R25, <#[R1 + 92]> */
		/* 82065E78h case   38:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x0000005C) );
		/* 82065E78h case   38:*/		return 0x82065E7C;
		  /* 82065E7Ch */ case   39:  		/* lwz R27, <#[R1 + 96]> */
		/* 82065E7Ch case   39:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000060) );
		/* 82065E7Ch case   39:*/		return 0x82065E80;
		  /* 82065E80h */ case   40:  		/* lwz R24, <#[R1 + 100]> */
		/* 82065E80h case   40:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R1 + 0x00000064) );
		/* 82065E80h case   40:*/		return 0x82065E84;
		  /* 82065E84h */ case   41:  		/* stw R25, <#[R1 + 88]> */
		/* 82065E84h case   41:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x00000058) );
		/* 82065E84h case   41:*/		return 0x82065E88;
		  /* 82065E88h */ case   42:  		/* stw R27, <#[R1 + 80]> */
		/* 82065E88h case   42:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000050) );
		/* 82065E88h case   42:*/		return 0x82065E8C;
		  /* 82065E8Ch */ case   43:  		/* stw R24, <#[R1 + 84]> */
		/* 82065E8Ch case   43:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R1 + 0x00000054) );
		/* 82065E8Ch case   43:*/		return 0x82065E90;
		  /* 82065E90h */ case   44:  		/* bl -1704 */
		/* 82065E90h case   44:*/		regs.LR = 0x82065E94; return 0x820657E8;
		/* 82065E90h case   44:*/		return 0x82065E94;
		  /* 82065E94h */ case   45:  		/* b 696 */
		/* 82065E94h case   45:*/		return 0x8206614C;
		/* 82065E94h case   45:*/		return 0x82065E98;
	}
	return 0x82065E98;
} // Block from 82065DE0h-82065E98h (46 instructions)

//////////////////////////////////////////////////////
// Block at 82065E98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065E98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065E98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065E98);
		  /* 82065E98h */ case    0:  		/* lwz R11, <#[R30 + 40]> */
		/* 82065E98h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000028) );
		/* 82065E98h case    0:*/		return 0x82065E9C;
		  /* 82065E9Ch */ case    1:  		/* rlwinm R31, R11, 1, 31, 31 */
		/* 82065E9Ch case    1:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R31,regs.R11);
		/* 82065E9Ch case    1:*/		return 0x82065EA0;
		  /* 82065EA0h */ case    2:  		/* rlwinm R8, R31, 1, 0, 30 */
		/* 82065EA0h case    2:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R8,regs.R31);
		/* 82065EA0h case    2:*/		return 0x82065EA4;
		  /* 82065EA4h */ case    3:  		/* bl -2436 */
		/* 82065EA4h case    3:*/		regs.LR = 0x82065EA8; return 0x82065520;
		/* 82065EA4h case    3:*/		return 0x82065EA8;
	}
	return 0x82065EA8;
} // Block from 82065E98h-82065EA8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82065EA8h
// Function '?ClearF@D3D@@YAXPAVCDevice@1@KPBU_D3DRECT@@PBU__vector4@@MK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065EA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065EA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065EA8);
		  /* 82065EA8h */ case    0:  		/* lwz R28, <#[R30 + 48]> */
		/* 82065EA8h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R30 + 0x00000030) );
		/* 82065EA8h case    0:*/		return 0x82065EAC;
		  /* 82065EACh */ case    1:  		/* li R5, 1 */
		/* 82065EACh case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82065EACh case    1:*/		return 0x82065EB0;
		  /* 82065EB0h */ case    2:  		/* rlwinm R26, R28, 23, 30, 31 */
		/* 82065EB0h case    2:*/		cpu::op::rlwinm<0,23,30,31>(regs,&regs.R26,regs.R28);
		/* 82065EB0h case    2:*/		return 0x82065EB4;
		  /* 82065EB4h */ case    3:  		/* cmplwi CR6, R26, 2 */
		/* 82065EB4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000002);
		/* 82065EB4h case    3:*/		return 0x82065EB8;
		  /* 82065EB8h */ case    4:  		/* lwz R25, <#[R1 + 92]> */
		/* 82065EB8h case    4:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x0000005C) );
		/* 82065EB8h case    4:*/		return 0x82065EBC;
		  /* 82065EBCh */ case    5:  		/* lwz R27, <#[R1 + 96]> */
		/* 82065EBCh case    5:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000060) );
		/* 82065EBCh case    5:*/		return 0x82065EC0;
		  /* 82065EC0h */ case    6:  		/* subf R9, R8, R25 */
		/* 82065EC0h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R25);
		/* 82065EC0h case    6:*/		return 0x82065EC4;
		  /* 82065EC4h */ case    7:  		/* lwz R24, <#[R1 + 100]> */
		/* 82065EC4h case    7:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R1 + 0x00000064) );
		/* 82065EC4h case    7:*/		return 0x82065EC8;
		  /* 82065EC8h */ case    8:  		/* subf R7, R8, R27 */
		/* 82065EC8h case    8:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R8,regs.R27);
		/* 82065EC8h case    8:*/		return 0x82065ECC;
		  /* 82065ECCh */ case    9:  		/* addi R11, R9, -1 */
		/* 82065ECCh case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0xFFFFFFFF);
		/* 82065ECCh case    9:*/		return 0x82065ED0;
		  /* 82065ED0h */ case   10:  		/* addi R10, R7, -1 */
		/* 82065ED0h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R7,0xFFFFFFFF);
		/* 82065ED0h case   10:*/		return 0x82065ED4;
		  /* 82065ED4h */ case   11:  		/* cntlzw R11, R11 */
		/* 82065ED4h case   11:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 82065ED4h case   11:*/		return 0x82065ED8;
		  /* 82065ED8h */ case   12:  		/* cntlzw R10, R10 */
		/* 82065ED8h case   12:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R10);
		/* 82065ED8h case   12:*/		return 0x82065EDC;
		  /* 82065EDCh */ case   13:  		/* subf R11, R11, R31 */
		/* 82065EDCh case   13:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 82065EDCh case   13:*/		return 0x82065EE0;
		  /* 82065EE0h */ case   14:  		/* subf R10, R10, R31 */
		/* 82065EE0h case   14:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R10,regs.R31);
		/* 82065EE0h case   14:*/		return 0x82065EE4;
		  /* 82065EE4h */ case   15:  		/* addi R11, R11, 32 */
		/* 82065EE4h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x20);
		/* 82065EE4h case   15:*/		return 0x82065EE8;
		  /* 82065EE8h */ case   16:  		/* addi R10, R10, 32 */
		/* 82065EE8h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x20);
		/* 82065EE8h case   16:*/		return 0x82065EEC;
		  /* 82065EECh */ case   17:  		/* slw R4, R5, R11 */
		/* 82065EECh case   17:*/		cpu::op::slw<0>(regs,&regs.R4,regs.R5,regs.R11);
		/* 82065EECh case   17:*/		return 0x82065EF0;
		  /* 82065EF0h */ case   18:  		/* slw R3, R5, R10 */
		/* 82065EF0h case   18:*/		cpu::op::slw<0>(regs,&regs.R3,regs.R5,regs.R10);
		/* 82065EF0h case   18:*/		return 0x82065EF4;
		  /* 82065EF4h */ case   19:  		/* stw R4, <#[R1 + 88]> */
		/* 82065EF4h case   19:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x00000058) );
		/* 82065EF4h case   19:*/		return 0x82065EF8;
		  /* 82065EF8h */ case   20:  		/* stw R3, <#[R1 + 80]> */
		/* 82065EF8h case   20:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 82065EF8h case   20:*/		return 0x82065EFC;
		  /* 82065EFCh */ case   21:  		/* bc 4, CR6_EQ, 32 */
		/* 82065EFCh case   21:*/		if ( !regs.CR[6].eq ) { return 0x82065F1C;  }
		/* 82065EFCh case   21:*/		return 0x82065F00;
		  /* 82065F00h */ case   22:  		/* subf R11, R8, R24 */
		/* 82065F00h case   22:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R8,regs.R24);
		/* 82065F00h case   22:*/		return 0x82065F04;
		  /* 82065F04h */ case   23:  		/* addi R11, R11, -1 */
		/* 82065F04h case   23:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82065F04h case   23:*/		return 0x82065F08;
		  /* 82065F08h */ case   24:  		/* cntlzw R11, R11 */
		/* 82065F08h case   24:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 82065F08h case   24:*/		return 0x82065F0C;
		  /* 82065F0Ch */ case   25:  		/* subf R11, R11, R31 */
		/* 82065F0Ch case   25:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 82065F0Ch case   25:*/		return 0x82065F10;
		  /* 82065F10h */ case   26:  		/* addi R11, R11, 32 */
		/* 82065F10h case   26:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x20);
		/* 82065F10h case   26:*/		return 0x82065F14;
		  /* 82065F14h */ case   27:  		/* slw R29, R5, R11 */
		/* 82065F14h case   27:*/		cpu::op::slw<0>(regs,&regs.R29,regs.R5,regs.R11);
		/* 82065F14h case   27:*/		return 0x82065F18;
		  /* 82065F18h */ case   28:  		/* b 8 */
		/* 82065F18h case   28:*/		return 0x82065F20;
		/* 82065F18h case   28:*/		return 0x82065F1C;
	}
	return 0x82065F1C;
} // Block from 82065EA8h-82065F1Ch (29 instructions)

//////////////////////////////////////////////////////
// Block at 82065F1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065F1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065F1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065F1C);
		  /* 82065F1Ch */ case    0:  		/* mr R29, R5 */
		/* 82065F1Ch case    0:*/		regs.R29 = regs.R5;
		/* 82065F1Ch case    0:*/		return 0x82065F20;
	}
	return 0x82065F20;
} // Block from 82065F1Ch-82065F20h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82065F20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065F20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065F20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065F20);
		  /* 82065F20h */ case    0:  		/* stw R29, <#[R1 + 84]> */
		/* 82065F20h case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000054) );
		/* 82065F20h case    0:*/		return 0x82065F24;
		  /* 82065F24h */ case    1:  		/* cmplwi CR6, R23, 0 */
		/* 82065F24h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 82065F24h case    1:*/		return 0x82065F28;
		  /* 82065F28h */ case    2:  		/* bc 4, CR6_EQ, 192 */
		/* 82065F28h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82065FE8;  }
		/* 82065F28h case    2:*/		return 0x82065F2C;
		  /* 82065F2Ch */ case    3:  		/* cmplwi CR6, R4, 16 */
		/* 82065F2Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000010);
		/* 82065F2Ch case    3:*/		return 0x82065F30;
		  /* 82065F30h */ case    4:  		/* bc 4, CR6_GT, 12 */
		/* 82065F30h case    4:*/		if ( !regs.CR[6].gt ) { return 0x82065F3C;  }
		/* 82065F30h case    4:*/		return 0x82065F34;
		  /* 82065F34h */ case    5:  		/* cmplwi CR6, R3, 16 */
		/* 82065F34h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000010);
		/* 82065F34h case    5:*/		return 0x82065F38;
		  /* 82065F38h */ case    6:  		/* bc 12, CR6_GT, 12 */
		/* 82065F38h case    6:*/		if ( regs.CR[6].gt ) { return 0x82065F44;  }
		/* 82065F38h case    6:*/		return 0x82065F3C;
	}
	return 0x82065F3C;
} // Block from 82065F20h-82065F3Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 82065F3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065F3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065F3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065F3C);
		  /* 82065F3Ch */ case    0:  		/* rlwinm. R11, R28, 0, 20, 20 */
		/* 82065F3Ch case    0:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R11,regs.R28);
		/* 82065F3Ch case    0:*/		return 0x82065F40;
		  /* 82065F40h */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 82065F40h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82065F50;  }
		/* 82065F40h case    1:*/		return 0x82065F44;
	}
	return 0x82065F44;
} // Block from 82065F3Ch-82065F44h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82065F44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065F44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065F44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065F44);
		  /* 82065F44h */ case    0:  		/* stw R25, <#[R1 + 88]> */
		/* 82065F44h case    0:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x00000058) );
		/* 82065F44h case    0:*/		return 0x82065F48;
		  /* 82065F48h */ case    1:  		/* stw R27, <#[R1 + 80]> */
		/* 82065F48h case    1:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000050) );
		/* 82065F48h case    1:*/		return 0x82065F4C;
		  /* 82065F4Ch */ case    2:  		/* stw R24, <#[R1 + 84]> */
		/* 82065F4Ch case    2:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R1 + 0x00000054) );
		/* 82065F4Ch case    2:*/		return 0x82065F50;
	}
	return 0x82065F50;
} // Block from 82065F44h-82065F50h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82065F50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065F50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065F50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065F50);
		  /* 82065F50h */ case    0:  		/* lwz R29, <#[R30 + 28]> */
		/* 82065F50h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R30 + 0x0000001C) );
		/* 82065F50h case    0:*/		return 0x82065F54;
		  /* 82065F54h */ case    1:  		/* mr R7, R22 */
		/* 82065F54h case    1:*/		regs.R7 = regs.R22;
		/* 82065F54h case    1:*/		return 0x82065F58;
		  /* 82065F58h */ case    2:  		/* mr R8, R26 */
		/* 82065F58h case    2:*/		regs.R8 = regs.R26;
		/* 82065F58h case    2:*/		return 0x82065F5C;
		  /* 82065F5Ch */ case    3:  		/* rlwinm R22, R29, 1, 31, 31 */
		/* 82065F5Ch case    3:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R22,regs.R29);
		/* 82065F5Ch case    3:*/		return 0x82065F60;
		  /* 82065F60h */ case    4:  		/* mr R6, R21 */
		/* 82065F60h case    4:*/		regs.R6 = regs.R21;
		/* 82065F60h case    4:*/		return 0x82065F64;
		  /* 82065F64h */ case    5:  		/* addi R5, R1, 84 */
		/* 82065F64h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 82065F64h case    5:*/		return 0x82065F68;
		  /* 82065F68h */ case    6:  		/* addi R4, R1, 80 */
		/* 82065F68h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 82065F68h case    6:*/		return 0x82065F6C;
		  /* 82065F6Ch */ case    7:  		/* addi R3, R1, 88 */
		/* 82065F6Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x58);
		/* 82065F6Ch case    7:*/		return 0x82065F70;
		  /* 82065F70h */ case    8:  		/* mr R9, R22 */
		/* 82065F70h case    8:*/		regs.R9 = regs.R22;
		/* 82065F70h case    8:*/		return 0x82065F74;
		  /* 82065F74h */ case    9:  		/* bl -1932 */
		/* 82065F74h case    9:*/		regs.LR = 0x82065F78; return 0x820657E8;
		/* 82065F74h case    9:*/		return 0x82065F78;
		  /* 82065F78h */ case   10:  		/* cmplwi CR6, R22, 0 */
		/* 82065F78h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 82065F78h case   10:*/		return 0x82065F7C;
		  /* 82065F7Ch */ case   11:  		/* bc 4, CR6_EQ, 92 */
		/* 82065F7Ch case   11:*/		if ( !regs.CR[6].eq ) { return 0x82065FD8;  }
		/* 82065F7Ch case   11:*/		return 0x82065F80;
		  /* 82065F80h */ case   12:  		/* lwz R11, <#[R30 + 32]> */
		/* 82065F80h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000020) );
		/* 82065F80h case   12:*/		return 0x82065F84;
		  /* 82065F84h */ case   13:  		/* rlwinm. R10, R11, 0, 21, 21 */
		/* 82065F84h case   13:*/		cpu::op::rlwinm<1,0,21,21>(regs,&regs.R10,regs.R11);
		/* 82065F84h case   13:*/		return 0x82065F88;
		  /* 82065F88h */ case   14:  		/* bc 4, CR0_EQ, 80 */
		/* 82065F88h case   14:*/		if ( !regs.CR[0].eq ) { return 0x82065FD8;  }
		/* 82065F88h case   14:*/		return 0x82065F8C;
		  /* 82065F8Ch */ case   15:  		/* rlwinm. R10, R28, 0, 20, 20 */
		/* 82065F8Ch case   15:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R10,regs.R28);
		/* 82065F8Ch case   15:*/		return 0x82065F90;
		  /* 82065F90h */ case   16:  		/* bc 4, CR0_EQ, 72 */
		/* 82065F90h case   16:*/		if ( !regs.CR[0].eq ) { return 0x82065FD8;  }
		/* 82065F90h case   16:*/		return 0x82065F94;
		  /* 82065F94h */ case   17:  		/* cmplwi CR6, R26, 1 */
		/* 82065F94h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000001);
		/* 82065F94h case   17:*/		return 0x82065F98;
		  /* 82065F98h */ case   18:  		/* bc 4, CR6_EQ, 64 */
		/* 82065F98h case   18:*/		if ( !regs.CR[6].eq ) { return 0x82065FD8;  }
		/* 82065F98h case   18:*/		return 0x82065F9C;
		  /* 82065F9Ch */ case   19:  		/* lwz R10, <#[R30 + 44]> */
		/* 82065F9Ch case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000002C) );
		/* 82065F9Ch case   19:*/		return 0x82065FA0;
		  /* 82065FA0h */ case   20:  		/* rlwinm. R10, R10, 0, 22, 25 */
		/* 82065FA0h case   20:*/		cpu::op::rlwinm<1,0,22,25>(regs,&regs.R10,regs.R10);
		/* 82065FA0h case   20:*/		return 0x82065FA4;
		  /* 82065FA4h */ case   21:  		/* bc 4, CR0_EQ, 52 */
		/* 82065FA4h case   21:*/		if ( !regs.CR[0].eq ) { return 0x82065FD8;  }
		/* 82065FA4h case   21:*/		return 0x82065FA8;
		  /* 82065FA8h */ case   22:  		/* cmplwi CR6, R31, 0 */
		/* 82065FA8h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82065FA8h case   22:*/		return 0x82065FAC;
		  /* 82065FACh */ case   23:  		/* bc 4, CR6_EQ, 44 */
		/* 82065FACh case   23:*/		if ( !regs.CR[6].eq ) { return 0x82065FD8;  }
		/* 82065FACh case   23:*/		return 0x82065FB0;
		  /* 82065FB0h */ case   24:  		/* addi R5, R1, 100 */
		/* 82065FB0h case   24:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x64);
		/* 82065FB0h case   24:*/		return 0x82065FB4;
		  /* 82065FB4h */ case   25:  		/* addi R4, R1, 96 */
		/* 82065FB4h case   25:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 82065FB4h case   25:*/		return 0x82065FB8;
		  /* 82065FB8h */ case   26:  		/* rlwinm R3, R11, 0, 26, 31 */
		/* 82065FB8h case   26:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R3,regs.R11);
		/* 82065FB8h case   26:*/		return 0x82065FBC;
		  /* 82065FBCh */ case   27:  		/* bl -2292 */
		/* 82065FBCh case   27:*/		regs.LR = 0x82065FC0; return 0x820656C8;
		/* 82065FBCh case   27:*/		return 0x82065FC0;
		  /* 82065FC0h */ case   28:  		/* lwz R11, <#[R1 + 100]> */
		/* 82065FC0h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 82065FC0h case   28:*/		return 0x82065FC4;
		  /* 82065FC4h */ case   29:  		/* add R10, R11, R27 */
		/* 82065FC4h case   29:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R27);
		/* 82065FC4h case   29:*/		return 0x82065FC8;
		  /* 82065FC8h */ case   30:  		/* addi R11, R11, -1 */
		/* 82065FC8h case   30:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82065FC8h case   30:*/		return 0x82065FCC;
		  /* 82065FCCh */ case   31:  		/* addi R10, R10, -1 */
		/* 82065FCCh case   31:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82065FCCh case   31:*/		return 0x82065FD0;
		  /* 82065FD0h */ case   32:  		/* andc R11, R10, R11 */
		/* 82065FD0h case   32:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82065FD0h case   32:*/		return 0x82065FD4;
		  /* 82065FD4h */ case   33:  		/* stw R11, <#[R1 + 80]> */
		/* 82065FD4h case   33:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82065FD4h case   33:*/		return 0x82065FD8;
	}
	return 0x82065FD8;
} // Block from 82065F50h-82065FD8h (34 instructions)

//////////////////////////////////////////////////////
// Block at 82065FD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065FD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065FD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065FD8);
		  /* 82065FD8h */ case    0:  		/* rlwinm R11, R29, 10, 23, 31 */
		/* 82065FD8h case    0:*/		cpu::op::rlwinm<0,10,23,31>(regs,&regs.R11,regs.R29);
		/* 82065FD8h case    0:*/		return 0x82065FDC;
		  /* 82065FDCh */ case    1:  		/* mullw R11, R11, R21 */
		/* 82065FDCh case    1:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R21);
		/* 82065FDCh case    1:*/		return 0x82065FE0;
		  /* 82065FE0h */ case    2:  		/* rlwinm R31, R11, 2, 3, 29 */
		/* 82065FE0h case    2:*/		cpu::op::rlwinm<0,2,3,29>(regs,&regs.R31,regs.R11);
		/* 82065FE0h case    2:*/		return 0x82065FE4;
		  /* 82065FE4h */ case    3:  		/* b 360 */
		/* 82065FE4h case    3:*/		return 0x8206614C;
		/* 82065FE4h case    3:*/		return 0x82065FE8;
	}
	return 0x82065FE8;
} // Block from 82065FD8h-82065FE8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82065FE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82065FE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82065FE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82065FE8);
		  /* 82065FE8h */ case    0:  		/* srw R11, R9, R23 */
		/* 82065FE8h case    0:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R9,regs.R23);
		/* 82065FE8h case    0:*/		return 0x82065FEC;
		  /* 82065FECh */ case    1:  		/* mr R9, R25 */
		/* 82065FECh case    1:*/		regs.R9 = regs.R25;
		/* 82065FECh case    1:*/		return 0x82065FF0;
		  /* 82065FF0h */ case    2:  		/* mr R6, R27 */
		/* 82065FF0h case    2:*/		regs.R6 = regs.R27;
		/* 82065FF0h case    2:*/		return 0x82065FF4;
		  /* 82065FF4h */ case    3:  		/* cmplwi CR6, R11, 1 */
		/* 82065FF4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82065FF4h case    3:*/		return 0x82065FF8;
		  /* 82065FF8h */ case    4:  		/* bc 12, CR6_GT, 8 */
		/* 82065FF8h case    4:*/		if ( regs.CR[6].gt ) { return 0x82066000;  }
		/* 82065FF8h case    4:*/		return 0x82065FFC;
		  /* 82065FFCh */ case    5:  		/* mr R11, R5 */
		/* 82065FFCh case    5:*/		regs.R11 = regs.R5;
		/* 82065FFCh case    5:*/		return 0x82066000;
	}
	return 0x82066000;
} // Block from 82065FE8h-82066000h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82066000h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066000( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066000) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066000);
		  /* 82066000h */ case    0:  		/* srw R10, R7, R23 */
		/* 82066000h case    0:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R7,regs.R23);
		/* 82066000h case    0:*/		return 0x82066004;
		  /* 82066004h */ case    1:  		/* add R25, R11, R8 */
		/* 82066004h case    1:*/		cpu::op::add<0>(regs,&regs.R25,regs.R11,regs.R8);
		/* 82066004h case    1:*/		return 0x82066008;
		  /* 82066008h */ case    2:  		/* cmplwi CR6, R10, 1 */
		/* 82066008h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 82066008h case    2:*/		return 0x8206600C;
		  /* 8206600Ch */ case    3:  		/* bc 12, CR6_GT, 8 */
		/* 8206600Ch case    3:*/		if ( regs.CR[6].gt ) { return 0x82066014;  }
		/* 8206600Ch case    3:*/		return 0x82066010;
		  /* 82066010h */ case    4:  		/* mr R10, R5 */
		/* 82066010h case    4:*/		regs.R10 = regs.R5;
		/* 82066010h case    4:*/		return 0x82066014;
	}
	return 0x82066014;
} // Block from 82066000h-82066014h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82066014h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066014( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066014) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066014);
		  /* 82066014h */ case    0:  		/* add R27, R10, R8 */
		/* 82066014h case    0:*/		cpu::op::add<0>(regs,&regs.R27,regs.R10,regs.R8);
		/* 82066014h case    0:*/		return 0x82066018;
		  /* 82066018h */ case    1:  		/* cmplwi CR6, R26, 2 */
		/* 82066018h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000002);
		/* 82066018h case    1:*/		return 0x8206601C;
		  /* 8206601Ch */ case    2:  		/* bc 4, CR6_EQ, 32 */
		/* 8206601Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x8206603C;  }
		/* 8206601Ch case    2:*/		return 0x82066020;
		  /* 82066020h */ case    3:  		/* subf R11, R8, R24 */
		/* 82066020h case    3:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R8,regs.R24);
		/* 82066020h case    3:*/		return 0x82066024;
		  /* 82066024h */ case    4:  		/* srw R11, R11, R23 */
		/* 82066024h case    4:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R23);
		/* 82066024h case    4:*/		return 0x82066028;
		  /* 82066028h */ case    5:  		/* cmplwi CR6, R11, 1 */
		/* 82066028h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82066028h case    5:*/		return 0x8206602C;
		  /* 8206602Ch */ case    6:  		/* bc 12, CR6_GT, 8 */
		/* 8206602Ch case    6:*/		if ( regs.CR[6].gt ) { return 0x82066034;  }
		/* 8206602Ch case    6:*/		return 0x82066030;
		  /* 82066030h */ case    7:  		/* mr R11, R5 */
		/* 82066030h case    7:*/		regs.R11 = regs.R5;
		/* 82066030h case    7:*/		return 0x82066034;
	}
	return 0x82066034;
} // Block from 82066014h-82066034h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82066034h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066034( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066034) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066034);
		  /* 82066034h */ case    0:  		/* add R24, R11, R8 */
		/* 82066034h case    0:*/		cpu::op::add<0>(regs,&regs.R24,regs.R11,regs.R8);
		/* 82066034h case    0:*/		return 0x82066038;
		  /* 82066038h */ case    1:  		/* b 8 */
		/* 82066038h case    1:*/		return 0x82066040;
		/* 82066038h case    1:*/		return 0x8206603C;
	}
	return 0x8206603C;
} // Block from 82066034h-8206603Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206603Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206603C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206603C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206603C);
		  /* 8206603Ch */ case    0:  		/* mr R24, R5 */
		/* 8206603Ch case    0:*/		regs.R24 = regs.R5;
		/* 8206603Ch case    0:*/		return 0x82066040;
	}
	return 0x82066040;
} // Block from 8206603Ch-82066040h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82066040h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066040( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066040) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066040);
		  /* 82066040h */ case    0:  		/* rlwinm. R11, R28, 0, 20, 20 */
		/* 82066040h case    0:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R11,regs.R28);
		/* 82066040h case    0:*/		return 0x82066044;
		  /* 82066044h */ case    1:  		/* bc 12, CR0_EQ, 156 */
		/* 82066044h case    1:*/		if ( regs.CR[0].eq ) { return 0x820660E0;  }
		/* 82066044h case    1:*/		return 0x82066048;
		  /* 82066048h */ case    2:  		/* subf R10, R8, R9 */
		/* 82066048h case    2:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R8,regs.R9);
		/* 82066048h case    2:*/		return 0x8206604C;
		  /* 8206604Ch */ case    3:  		/* subf R11, R8, R6 */
		/* 8206604Ch case    3:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R8,regs.R6);
		/* 8206604Ch case    3:*/		return 0x82066050;
		  /* 82066050h */ case    4:  		/* addi R10, R10, -1 */
		/* 82066050h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82066050h case    4:*/		return 0x82066054;
		  /* 82066054h */ case    5:  		/* addi R11, R11, -1 */
		/* 82066054h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82066054h case    5:*/		return 0x82066058;
		  /* 82066058h */ case    6:  		/* cntlzw R10, R10 */
		/* 82066058h case    6:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R10);
		/* 82066058h case    6:*/		return 0x8206605C;
		  /* 8206605Ch */ case    7:  		/* cntlzw R7, R11 */
		/* 8206605Ch case    7:*/		cpu::op::cntlzw<0>(regs,&regs.R7,regs.R11);
		/* 8206605Ch case    7:*/		return 0x82066060;
		  /* 82066060h */ case    8:  		/* subf R11, R10, R31 */
		/* 82066060h case    8:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R31);
		/* 82066060h case    8:*/		return 0x82066064;
		  /* 82066064h */ case    9:  		/* subf R10, R7, R31 */
		/* 82066064h case    9:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R7,regs.R31);
		/* 82066064h case    9:*/		return 0x82066068;
		  /* 82066068h */ case   10:  		/* addi R11, R11, 32 */
		/* 82066068h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x20);
		/* 82066068h case   10:*/		return 0x8206606C;
		  /* 8206606Ch */ case   11:  		/* addi R10, R10, 32 */
		/* 8206606Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x20);
		/* 8206606Ch case   11:*/		return 0x82066070;
		  /* 82066070h */ case   12:  		/* cmpw CR6, R11, R10 */
		/* 82066070h case   12:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 82066070h case   12:*/		return 0x82066074;
		  /* 82066074h */ case   13:  		/* bc 12, CR6_LT, 8 */
		/* 82066074h case   13:*/		if ( regs.CR[6].lt ) { return 0x8206607C;  }
		/* 82066074h case   13:*/		return 0x82066078;
		  /* 82066078h */ case   14:  		/* mr R11, R10 */
		/* 82066078h case   14:*/		regs.R11 = regs.R10;
		/* 82066078h case   14:*/		return 0x8206607C;
	}
	return 0x8206607C;
} // Block from 82066040h-8206607Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8206607Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206607C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206607C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206607C);
		  /* 8206607Ch */ case    0:  		/* addi R11, R11, -4 */
		/* 8206607Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 8206607Ch case    0:*/		return 0x82066080;
		  /* 82066080h */ case    1:  		/* subfic R10, R11, 0 */
		/* 82066080h case    1:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R11,0x0);
		/* 82066080h case    1:*/		return 0x82066084;
		  /* 82066084h */ case    2:  		/* rlwinm R10, R11, 1, 31, 31 */
		/* 82066084h case    2:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R10,regs.R11);
		/* 82066084h case    2:*/		return 0x82066088;
		  /* 82066088h */ case    3:  		/* addme R10, R10 */
		/* 82066088h case    3:*/		cpu::op::addme<0>(regs,&regs.R10,regs.R10);
		/* 82066088h case    3:*/		return 0x8206608C;
		  /* 8206608Ch */ case    4:  		/* and R11, R10, R11 */
		/* 8206608Ch case    4:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8206608Ch case    4:*/		return 0x82066090;
		  /* 82066090h */ case    5:  		/* cmplw CR6, R23, R11 */
		/* 82066090h case    5:*/		cpu::op::cmplw<6>(regs,regs.R23,regs.R11);
		/* 82066090h case    5:*/		return 0x82066094;
		  /* 82066094h */ case    6:  		/* bc 12, CR6_LT, 76 */
		/* 82066094h case    6:*/		if ( regs.CR[6].lt ) { return 0x820660E0;  }
		/* 82066094h case    6:*/		return 0x82066098;
		  /* 82066098h */ case    7:  		/* subf R10, R8, R9 */
		/* 82066098h case    7:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R8,regs.R9);
		/* 82066098h case    7:*/		return 0x8206609C;
		  /* 8206609Ch */ case    8:  		/* subf R11, R8, R6 */
		/* 8206609Ch case    8:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R8,regs.R6);
		/* 8206609Ch case    8:*/		return 0x820660A0;
		  /* 820660A0h */ case    9:  		/* addi R10, R10, -1 */
		/* 820660A0h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 820660A0h case    9:*/		return 0x820660A4;
		  /* 820660A4h */ case   10:  		/* addi R11, R11, -1 */
		/* 820660A4h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820660A4h case   10:*/		return 0x820660A8;
		  /* 820660A8h */ case   11:  		/* cntlzw R10, R10 */
		/* 820660A8h case   11:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R10);
		/* 820660A8h case   11:*/		return 0x820660AC;
		  /* 820660ACh */ case   12:  		/* cntlzw R9, R11 */
		/* 820660ACh case   12:*/		cpu::op::cntlzw<0>(regs,&regs.R9,regs.R11);
		/* 820660ACh case   12:*/		return 0x820660B0;
		  /* 820660B0h */ case   13:  		/* subf R11, R10, R31 */
		/* 820660B0h case   13:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R31);
		/* 820660B0h case   13:*/		return 0x820660B4;
		  /* 820660B4h */ case   14:  		/* subf R10, R9, R31 */
		/* 820660B4h case   14:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R9,regs.R31);
		/* 820660B4h case   14:*/		return 0x820660B8;
		  /* 820660B8h */ case   15:  		/* addi R11, R11, 32 */
		/* 820660B8h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x20);
		/* 820660B8h case   15:*/		return 0x820660BC;
		  /* 820660BCh */ case   16:  		/* addi R10, R10, 32 */
		/* 820660BCh case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x20);
		/* 820660BCh case   16:*/		return 0x820660C0;
		  /* 820660C0h */ case   17:  		/* cmpw CR6, R11, R10 */
		/* 820660C0h case   17:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 820660C0h case   17:*/		return 0x820660C4;
		  /* 820660C4h */ case   18:  		/* bc 12, CR6_LT, 8 */
		/* 820660C4h case   18:*/		if ( regs.CR[6].lt ) { return 0x820660CC;  }
		/* 820660C4h case   18:*/		return 0x820660C8;
		  /* 820660C8h */ case   19:  		/* mr R11, R10 */
		/* 820660C8h case   19:*/		regs.R11 = regs.R10;
		/* 820660C8h case   19:*/		return 0x820660CC;
	}
	return 0x820660CC;
} // Block from 8206607Ch-820660CCh (20 instructions)

//////////////////////////////////////////////////////
// Block at 820660CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820660CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820660CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820660CC);
		  /* 820660CCh */ case    0:  		/* addi R11, R11, -4 */
		/* 820660CCh case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 820660CCh case    0:*/		return 0x820660D0;
		  /* 820660D0h */ case    1:  		/* subfic R10, R11, 0 */
		/* 820660D0h case    1:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R11,0x0);
		/* 820660D0h case    1:*/		return 0x820660D4;
		  /* 820660D4h */ case    2:  		/* rlwinm R10, R11, 1, 31, 31 */
		/* 820660D4h case    2:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R10,regs.R11);
		/* 820660D4h case    2:*/		return 0x820660D8;
		  /* 820660D8h */ case    3:  		/* addme R10, R10 */
		/* 820660D8h case    3:*/		cpu::op::addme<0>(regs,&regs.R10,regs.R10);
		/* 820660D8h case    3:*/		return 0x820660DC;
		  /* 820660DCh */ case    4:  		/* and R23, R10, R11 */
		/* 820660DCh case    4:*/		cpu::op::and<0>(regs,&regs.R23,regs.R10,regs.R11);
		/* 820660DCh case    4:*/		return 0x820660E0;
	}
	return 0x820660E0;
} // Block from 820660CCh-820660E0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820660E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820660E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820660E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820660E0);
		  /* 820660E0h */ case    0:  		/* srw R11, R4, R23 */
		/* 820660E0h case    0:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R4,regs.R23);
		/* 820660E0h case    0:*/		return 0x820660E4;
		  /* 820660E4h */ case    1:  		/* cmplwi CR6, R11, 1 */
		/* 820660E4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820660E4h case    1:*/		return 0x820660E8;
		  /* 820660E8h */ case    2:  		/* stw R11, <#[R1 + 88]> */
		/* 820660E8h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 820660E8h case    2:*/		return 0x820660EC;
		  /* 820660ECh */ case    3:  		/* bc 12, CR6_GT, 8 */
		/* 820660ECh case    3:*/		if ( regs.CR[6].gt ) { return 0x820660F4;  }
		/* 820660ECh case    3:*/		return 0x820660F0;
		  /* 820660F0h */ case    4:  		/* stw R5, <#[R1 + 88]> */
		/* 820660F0h case    4:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x00000058) );
		/* 820660F0h case    4:*/		return 0x820660F4;
	}
	return 0x820660F4;
} // Block from 820660E0h-820660F4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820660F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820660F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820660F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820660F4);
		  /* 820660F4h */ case    0:  		/* srw R11, R3, R23 */
		/* 820660F4h case    0:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R3,regs.R23);
		/* 820660F4h case    0:*/		return 0x820660F8;
		  /* 820660F8h */ case    1:  		/* cmplwi CR6, R11, 1 */
		/* 820660F8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820660F8h case    1:*/		return 0x820660FC;
		  /* 820660FCh */ case    2:  		/* stw R11, <#[R1 + 80]> */
		/* 820660FCh case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820660FCh case    2:*/		return 0x82066100;
		  /* 82066100h */ case    3:  		/* bc 12, CR6_GT, 8 */
		/* 82066100h case    3:*/		if ( regs.CR[6].gt ) { return 0x82066108;  }
		/* 82066100h case    3:*/		return 0x82066104;
		  /* 82066104h */ case    4:  		/* stw R5, <#[R1 + 80]> */
		/* 82066104h case    4:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x00000050) );
		/* 82066104h case    4:*/		return 0x82066108;
	}
	return 0x82066108;
} // Block from 820660F4h-82066108h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82066108h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066108( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066108) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066108);
		  /* 82066108h */ case    0:  		/* srw R11, R29, R23 */
		/* 82066108h case    0:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R29,regs.R23);
		/* 82066108h case    0:*/		return 0x8206610C;
		  /* 8206610Ch */ case    1:  		/* cmplwi CR6, R11, 1 */
		/* 8206610Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 8206610Ch case    1:*/		return 0x82066110;
		  /* 82066110h */ case    2:  		/* stw R11, <#[R1 + 84]> */
		/* 82066110h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82066110h case    2:*/		return 0x82066114;
		  /* 82066114h */ case    3:  		/* bc 12, CR6_GT, 8 */
		/* 82066114h case    3:*/		if ( regs.CR[6].gt ) { return 0x8206611C;  }
		/* 82066114h case    3:*/		return 0x82066118;
		  /* 82066118h */ case    4:  		/* stw R5, <#[R1 + 84]> */
		/* 82066118h case    4:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x00000054) );
		/* 82066118h case    4:*/		return 0x8206611C;
	}
	return 0x8206611C;
} // Block from 82066108h-8206611Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8206611Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206611C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206611C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206611C);
		  /* 8206611Ch */ case    0:  		/* lwz R11, <#[R30 + 28]> */
		/* 8206611Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 8206611Ch case    0:*/		return 0x82066120;
		  /* 82066120h */ case    1:  		/* mr R8, R26 */
		/* 82066120h case    1:*/		regs.R8 = regs.R26;
		/* 82066120h case    1:*/		return 0x82066124;
		  /* 82066124h */ case    2:  		/* mr R7, R22 */
		/* 82066124h case    2:*/		regs.R7 = regs.R22;
		/* 82066124h case    2:*/		return 0x82066128;
		  /* 82066128h */ case    3:  		/* mr R6, R21 */
		/* 82066128h case    3:*/		regs.R6 = regs.R21;
		/* 82066128h case    3:*/		return 0x8206612C;
		  /* 8206612Ch */ case    4:  		/* addi R5, R1, 84 */
		/* 8206612Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 8206612Ch case    4:*/		return 0x82066130;
		  /* 82066130h */ case    5:  		/* addi R4, R1, 80 */
		/* 82066130h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 82066130h case    5:*/		return 0x82066134;
		  /* 82066134h */ case    6:  		/* addi R3, R1, 88 */
		/* 82066134h case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x58);
		/* 82066134h case    6:*/		return 0x82066138;
		  /* 82066138h */ case    7:  		/* rlwinm R9, R11, 1, 31, 31 */
		/* 82066138h case    7:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R9,regs.R11);
		/* 82066138h case    7:*/		return 0x8206613C;
		  /* 8206613Ch */ case    8:  		/* bl -2388 */
		/* 8206613Ch case    8:*/		regs.LR = 0x82066140; return 0x820657E8;
		/* 8206613Ch case    8:*/		return 0x82066140;
		  /* 82066140h */ case    9:  		/* lwz R11, <#[R1 + 88]> */
		/* 82066140h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 82066140h case    9:*/		return 0x82066144;
		  /* 82066144h */ case   10:  		/* mullw R11, R11, R21 */
		/* 82066144h case   10:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R21);
		/* 82066144h case   10:*/		return 0x82066148;
		  /* 82066148h */ case   11:  		/* rlwinm R31, R11, 29, 3, 31 */
		/* 82066148h case   11:*/		cpu::op::rlwinm<0,29,3,31>(regs,&regs.R31,regs.R11);
		/* 82066148h case   11:*/		return 0x8206614C;
	}
	return 0x8206614C;
} // Block from 8206611Ch-8206614Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8206614Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206614C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206614C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206614C);
		  /* 8206614Ch */ case    0:  		/* lwz R11, <#[R1 + 80]> */
		/* 8206614Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8206614Ch case    0:*/		return 0x82066150;
		  /* 82066150h */ case    1:  		/* stw R25, <#[R20]> */
		/* 82066150h case    1:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R20 + 0x00000000) );
		/* 82066150h case    1:*/		return 0x82066154;
		  /* 82066154h */ case    2:  		/* stw R27, <#[R19]> */
		/* 82066154h case    2:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R19 + 0x00000000) );
		/* 82066154h case    2:*/		return 0x82066158;
		  /* 82066158h */ case    3:  		/* mullw R11, R31, R11 */
		/* 82066158h case    3:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R31,regs.R11);
		/* 82066158h case    3:*/		return 0x8206615C;
		  /* 8206615Ch */ case    4:  		/* stw R24, <#[R18]> */
		/* 8206615Ch case    4:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R18 + 0x00000000) );
		/* 8206615Ch case    4:*/		return 0x82066160;
		  /* 82066160h */ case    5:  		/* stw R31, <#[R17]> */
		/* 82066160h case    5:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R17 + 0x00000000) );
		/* 82066160h case    5:*/		return 0x82066164;
		  /* 82066164h */ case    6:  		/* stw R11, <#[R16]> */
		/* 82066164h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R16 + 0x00000000) );
		/* 82066164h case    6:*/		return 0x82066168;
		  /* 82066168h */ case    7:  		/* lwz R10, <#[R30 + 28]> */
		/* 82066168h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000001C) );
		/* 82066168h case    7:*/		return 0x8206616C;
		  /* 8206616Ch */ case    8:  		/* rlwinm. R10, R10, 0, 0, 0 */
		/* 8206616Ch case    8:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R10,regs.R10);
		/* 8206616Ch case    8:*/		return 0x82066170;
		  /* 82066170h */ case    9:  		/* bc 4, CR0_EQ, 28 */
		/* 82066170h case    9:*/		if ( !regs.CR[0].eq ) { return 0x8206618C;  }
		/* 82066170h case    9:*/		return 0x82066174;
		  /* 82066174h */ case   10:  		/* cmplwi CR6, R23, 1 */
		/* 82066174h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000001);
		/* 82066174h case   10:*/		return 0x82066178;
		  /* 82066178h */ case   11:  		/* bc 12, CR6_GT, 20 */
		/* 82066178h case   11:*/		if ( regs.CR[6].gt ) { return 0x8206618C;  }
		/* 82066178h case   11:*/		return 0x8206617C;
		  /* 8206617Ch */ case   12:  		/* cmpwi CR6, R15, 3 */
		/* 8206617Ch case   12:*/		cpu::op::cmpwi<6>(regs,regs.R15,0x00000003);
		/* 8206617Ch case   12:*/		return 0x82066180;
		  /* 82066180h */ case   13:  		/* bc 12, CR6_EQ, 40 */
		/* 82066180h case   13:*/		if ( regs.CR[6].eq ) { return 0x820661A8;  }
		/* 82066180h case   13:*/		return 0x82066184;
		  /* 82066184h */ case   14:  		/* cmpwi CR6, R15, 20 */
		/* 82066184h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R15,0x00000014);
		/* 82066184h case   14:*/		return 0x82066188;
		  /* 82066188h */ case   15:  		/* bc 12, CR6_EQ, 32 */
		/* 82066188h case   15:*/		if ( regs.CR[6].eq ) { return 0x820661A8;  }
		/* 82066188h case   15:*/		return 0x8206618C;
	}
	return 0x8206618C;
} // Block from 8206614Ch-8206618Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 8206618Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206618C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206618C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206618C);
		  /* 8206618Ch */ case    0:  		/* lwz R10, <#[R30 + 48]> */
		/* 8206618Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000030) );
		/* 8206618Ch case    0:*/		return 0x82066190;
		  /* 82066190h */ case    1:  		/* rlwinm R10, R10, 0, 21, 22 */
		/* 82066190h case    1:*/		cpu::op::rlwinm<0,0,21,22>(regs,&regs.R10,regs.R10);
		/* 82066190h case    1:*/		return 0x82066194;
		  /* 82066194h */ case    2:  		/* cmplwi CR6, R10, 1024 */
		/* 82066194h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000400);
		/* 82066194h case    2:*/		return 0x82066198;
		  /* 82066198h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 82066198h case    3:*/		if ( regs.CR[6].eq ) { return 0x820661A8;  }
		/* 82066198h case    3:*/		return 0x8206619C;
		  /* 8206619Ch */ case    4:  		/* addi R11, R11, 4095 */
		/* 8206619Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFF);
		/* 8206619Ch case    4:*/		return 0x820661A0;
		  /* 820661A0h */ case    5:  		/* rlwinm R11, R11, 0, 0, 19 */
		/* 820661A0h case    5:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R11);
		/* 820661A0h case    5:*/		return 0x820661A4;
		  /* 820661A4h */ case    6:  		/* stw R11, <#[R16]> */
		/* 820661A4h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R16 + 0x00000000) );
		/* 820661A4h case    6:*/		return 0x820661A8;
	}
	return 0x820661A8;
} // Block from 8206618Ch-820661A8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 820661A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820661A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820661A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820661A8);
		  /* 820661A8h */ case    0:  		/* addi R1, R1, 256 */
		/* 820661A8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x100);
		/* 820661A8h case    0:*/		return 0x820661AC;
		  /* 820661ACh */ case    1:  		/* b 176328 */
		/* 820661ACh case    1:*/		return 0x82091274;
		/* 820661ACh case    1:*/		return 0x820661B0;
	}
	return 0x820661B0;
} // Block from 820661A8h-820661B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820661B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820661B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820661B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820661B0);
		  /* 820661B0h */ case    0:  		/* mfspr R12, LR */
		/* 820661B0h case    0:*/		regs.R12 = regs.LR;
		/* 820661B0h case    0:*/		return 0x820661B4;
		  /* 820661B4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820661B4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820661B4h case    1:*/		return 0x820661B8;
		  /* 820661B8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820661B8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820661B8h case    2:*/		return 0x820661BC;
		  /* 820661BCh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820661BCh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820661BCh case    3:*/		return 0x820661C0;
		  /* 820661C0h */ case    4:  		/* stwu R1, <#[R1 - 128]> */
		/* 820661C0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 820661C0h case    4:*/		return 0x820661C4;
		  /* 820661C4h */ case    5:  		/* mr R30, R5 */
		/* 820661C4h case    5:*/		regs.R30 = regs.R5;
		/* 820661C4h case    5:*/		return 0x820661C8;
		  /* 820661C8h */ case    6:  		/* addi R9, R1, 88 */
		/* 820661C8h case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x58);
		/* 820661C8h case    6:*/		return 0x820661CC;
		  /* 820661CCh */ case    7:  		/* addi R8, R1, 92 */
		/* 820661CCh case    7:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x5C);
		/* 820661CCh case    7:*/		return 0x820661D0;
		  /* 820661D0h */ case    8:  		/* addi R7, R1, 96 */
		/* 820661D0h case    8:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 820661D0h case    8:*/		return 0x820661D4;
		  /* 820661D4h */ case    9:  		/* addi R6, R1, 84 */
		/* 820661D4h case    9:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x54);
		/* 820661D4h case    9:*/		return 0x820661D8;
		  /* 820661D8h */ case   10:  		/* addi R5, R1, 80 */
		/* 820661D8h case   10:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 820661D8h case   10:*/		return 0x820661DC;
		  /* 820661DCh */ case   11:  		/* mr R31, R3 */
		/* 820661DCh case   11:*/		regs.R31 = regs.R3;
		/* 820661DCh case   11:*/		return 0x820661E0;
		  /* 820661E0h */ case   12:  		/* bl -1024 */
		/* 820661E0h case   12:*/		regs.LR = 0x820661E4; return 0x82065DE0;
		/* 820661E0h case   12:*/		return 0x820661E4;
		  /* 820661E4h */ case   13:  		/* lwz R11, <#[R31 + 40]> */
		/* 820661E4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 820661E4h case   13:*/		return 0x820661E8;
		  /* 820661E8h */ case   14:  		/* lwz R10, <#[R31 + 28]> */
		/* 820661E8h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000001C) );
		/* 820661E8h case   14:*/		return 0x820661EC;
		  /* 820661ECh */ case   15:  		/* mr R3, R31 */
		/* 820661ECh case   15:*/		regs.R3 = regs.R31;
		/* 820661ECh case   15:*/		return 0x820661F0;
		  /* 820661F0h */ case   16:  		/* rlwinm R7, R11, 25, 29, 31 */
		/* 820661F0h case   16:*/		cpu::op::rlwinm<0,25,29,31>(regs,&regs.R7,regs.R11);
		/* 820661F0h case   16:*/		return 0x820661F4;
		  /* 820661F4h */ case   17:  		/* lwz R8, <#[R31 + 32]> */
		/* 820661F4h case   17:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000020) );
		/* 820661F4h case   17:*/		return 0x820661F8;
		  /* 820661F8h */ case   18:  		/* rlwinm R9, R11, 25, 26, 28 */
		/* 820661F8h case   18:*/		cpu::op::rlwinm<0,25,26,28>(regs,&regs.R9,regs.R11);
		/* 820661F8h case   18:*/		return 0x820661FC;
		  /* 820661FCh */ case   19:  		/* rlwinm R6, R11, 28, 29, 31 */
		/* 820661FCh case   19:*/		cpu::op::rlwinm<0,28,29,31>(regs,&regs.R6,regs.R11);
		/* 820661FCh case   19:*/		return 0x82066200;
		  /* 82066200h */ case   20:  		/* or R9, R9, R7 */
		/* 82066200h case   20:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 82066200h case   20:*/		return 0x82066204;
		  /* 82066204h */ case   21:  		/* rlwinm R7, R11, 31, 29, 31 */
		/* 82066204h case   21:*/		cpu::op::rlwinm<0,31,29,31>(regs,&regs.R7,regs.R11);
		/* 82066204h case   21:*/		return 0x82066208;
		  /* 82066208h */ case   22:  		/* rlwinm R9, R9, 3, 0, 28 */
		/* 82066208h case   22:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R9,regs.R9);
		/* 82066208h case   22:*/		return 0x8206620C;
		  /* 8206620Ch */ case   23:  		/* rlwinm R5, R10, 26, 30, 31 */
		/* 8206620Ch case   23:*/		cpu::op::rlwinm<0,26,30,31>(regs,&regs.R5,regs.R10);
		/* 8206620Ch case   23:*/		return 0x82066210;
		  /* 82066210h */ case   24:  		/* or R9, R9, R6 */
		/* 82066210h case   24:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R6);
		/* 82066210h case   24:*/		return 0x82066214;
		  /* 82066214h */ case   25:  		/* rlwinm R6, R10, 24, 30, 31 */
		/* 82066214h case   25:*/		cpu::op::rlwinm<0,24,30,31>(regs,&regs.R6,regs.R10);
		/* 82066214h case   25:*/		return 0x82066218;
		  /* 82066218h */ case   26:  		/* rlwinm R9, R9, 3, 0, 28 */
		/* 82066218h case   26:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R9,regs.R9);
		/* 82066218h case   26:*/		return 0x8206621C;
		  /* 8206621Ch */ case   27:  		/* or R9, R9, R7 */
		/* 8206621Ch case   27:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 8206621Ch case   27:*/		return 0x82066220;
		  /* 82066220h */ case   28:  		/* rlwinm R7, R10, 28, 30, 31 */
		/* 82066220h case   28:*/		cpu::op::rlwinm<0,28,30,31>(regs,&regs.R7,regs.R10);
		/* 82066220h case   28:*/		return 0x82066224;
		  /* 82066224h */ case   29:  		/* rlwimi R11, R9, 1, 0, 30 */
		/* 82066224h case   29:*/		cpu::op::rlwimi<0,1,0,30>(regs,&regs.R11,regs.R9);
		/* 82066224h case   29:*/		return 0x82066228;
		  /* 82066228h */ case   30:  		/* rlwinm R9, R10, 30, 30, 31 */
		/* 82066228h case   30:*/		cpu::op::rlwinm<0,30,30,31>(regs,&regs.R9,regs.R10);
		/* 82066228h case   30:*/		return 0x8206622C;
		  /* 8206622Ch */ case   31:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8206622Ch case   31:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8206622Ch case   31:*/		return 0x82066230;
		  /* 82066230h */ case   32:  		/* rlwinm R10, R10, 1, 31, 31 */
		/* 82066230h case   32:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R10,regs.R10);
		/* 82066230h case   32:*/		return 0x82066234;
		  /* 82066234h */ case   33:  		/* or R11, R11, R6 */
		/* 82066234h case   33:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R6);
		/* 82066234h case   33:*/		return 0x82066238;
		  /* 82066238h */ case   34:  		/* rlwinm R6, R8, 26, 30, 31 */
		/* 82066238h case   34:*/		cpu::op::rlwinm<0,26,30,31>(regs,&regs.R6,regs.R8);
		/* 82066238h case   34:*/		return 0x8206623C;
		  /* 8206623Ch */ case   35:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8206623Ch case   35:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8206623Ch case   35:*/		return 0x82066240;
		  /* 82066240h */ case   36:  		/* or R11, R11, R5 */
		/* 82066240h case   36:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R5);
		/* 82066240h case   36:*/		return 0x82066244;
		  /* 82066244h */ case   37:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82066244h case   37:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82066244h case   37:*/		return 0x82066248;
		  /* 82066248h */ case   38:  		/* or R11, R11, R7 */
		/* 82066248h case   38:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 82066248h case   38:*/		return 0x8206624C;
		  /* 8206624Ch */ case   39:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8206624Ch case   39:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8206624Ch case   39:*/		return 0x82066250;
		  /* 82066250h */ case   40:  		/* or R11, R11, R9 */
		/* 82066250h case   40:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 82066250h case   40:*/		return 0x82066254;
		  /* 82066254h */ case   41:  		/* rlwinm R11, R11, 1, 0, 30 */
		/* 82066254h case   41:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R11);
		/* 82066254h case   41:*/		return 0x82066258;
		  /* 82066258h */ case   42:  		/* or R11, R11, R10 */
		/* 82066258h case   42:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82066258h case   42:*/		return 0x8206625C;
		  /* 8206625Ch */ case   43:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8206625Ch case   43:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8206625Ch case   43:*/		return 0x82066260;
		  /* 82066260h */ case   44:  		/* or R11, R11, R6 */
		/* 82066260h case   44:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R6);
		/* 82066260h case   44:*/		return 0x82066264;
		  /* 82066264h */ case   45:  		/* rlwimi R8, R11, 6, 0, 25 */
		/* 82066264h case   45:*/		cpu::op::rlwimi<0,6,0,25>(regs,&regs.R8,regs.R11);
		/* 82066264h case   45:*/		return 0x82066268;
		  /* 82066268h */ case   46:  		/* stw R8, <#[R30]> */
		/* 82066268h case   46:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R30 + 0x00000000) );
		/* 82066268h case   46:*/		return 0x8206626C;
		  /* 8206626Ch */ case   47:  		/* bl 45172 */
		/* 8206626Ch case   47:*/		regs.LR = 0x82066270; return 0x820712E0;
		/* 8206626Ch case   47:*/		return 0x82066270;
		  /* 82066270h */ case   48:  		/* lwz R10, <#[R1 + 80]> */
		/* 82066270h case   48:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 82066270h case   48:*/		return 0x82066274;
		  /* 82066274h */ case   49:  		/* lwz R9, <#[R1 + 84]> */
		/* 82066274h case   49:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000054) );
		/* 82066274h case   49:*/		return 0x82066278;
		  /* 82066278h */ case   50:  		/* li R11, 0 */
		/* 82066278h case   50:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82066278h case   50:*/		return 0x8206627C;
		  /* 8206627Ch */ case   51:  		/* stw R3, <#[R30 + 4]> */
		/* 8206627Ch case   51:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000004) );
		/* 8206627Ch case   51:*/		return 0x82066280;
		  /* 82066280h */ case   52:  		/* stw R11, <#[R30 + 8]> */
		/* 82066280h case   52:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82066280h case   52:*/		return 0x82066284;
		  /* 82066284h */ case   53:  		/* stw R11, <#[R30 + 12]> */
		/* 82066284h case   53:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 82066284h case   53:*/		return 0x82066288;
		  /* 82066288h */ case   54:  		/* stw R11, <#[R30 + 20]> */
		/* 82066288h case   54:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 82066288h case   54:*/		return 0x8206628C;
		  /* 8206628Ch */ case   55:  		/* stw R10, <#[R30 + 24]> */
		/* 8206628Ch case   55:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000018) );
		/* 8206628Ch case   55:*/		return 0x82066290;
		  /* 82066290h */ case   56:  		/* stw R9, <#[R30 + 28]> */
		/* 82066290h case   56:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R30 + 0x0000001C) );
		/* 82066290h case   56:*/		return 0x82066294;
		  /* 82066294h */ case   57:  		/* stw R11, <#[R30 + 16]> */
		/* 82066294h case   57:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 82066294h case   57:*/		return 0x82066298;
		  /* 82066298h */ case   58:  		/* addi R1, R1, 128 */
		/* 82066298h case   58:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82066298h case   58:*/		return 0x8206629C;
		  /* 8206629Ch */ case   59:  		/* lwz R12, <#[R1 - 8]> */
		/* 8206629Ch case   59:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206629Ch case   59:*/		return 0x820662A0;
		  /* 820662A0h */ case   60:  		/* mtspr LR, R12 */
		/* 820662A0h case   60:*/		regs.LR = regs.R12;
		/* 820662A0h case   60:*/		return 0x820662A4;
		  /* 820662A4h */ case   61:  		/* ld R30, <#[R1 - 24]> */
		/* 820662A4h case   61:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820662A4h case   61:*/		return 0x820662A8;
		  /* 820662A8h */ case   62:  		/* ld R31, <#[R1 - 16]> */
		/* 820662A8h case   62:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820662A8h case   62:*/		return 0x820662AC;
		  /* 820662ACh */ case   63:  		/* bclr 20, CR0_LT */
		/* 820662ACh case   63:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820662ACh case   63:*/		return 0x820662B0;
	}
	return 0x820662B0;
} // Block from 820661B0h-820662B0h (64 instructions)

//////////////////////////////////////////////////////
// Block at 820662B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820662B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820662B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820662B0);
		  /* 820662B0h */ case    0:  		/* mfspr R12, LR */
		/* 820662B0h case    0:*/		regs.R12 = regs.LR;
		/* 820662B0h case    0:*/		return 0x820662B4;
		  /* 820662B4h */ case    1:  		/* bl 175980 */
		/* 820662B4h case    1:*/		regs.LR = 0x820662B8; return 0x82091220;
		/* 820662B4h case    1:*/		return 0x820662B8;
		  /* 820662B8h */ case    2:  		/* stwu R1, <#[R1 - 288]> */
		/* 820662B8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEE0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEE0);
		/* 820662B8h case    2:*/		return 0x820662BC;
		  /* 820662BCh */ case    3:  		/* lis R11, -32256 */
		/* 820662BCh case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 820662BCh case    3:*/		return 0x820662C0;
		  /* 820662C0h */ case    4:  		/* stw R10, <#[R1 + 364]> */
		/* 820662C0h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x0000016C) );
		/* 820662C0h case    4:*/		return 0x820662C4;
		  /* 820662C4h */ case    5:  		/* lwz R10, <#[R3 + 32]> */
		/* 820662C4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000020) );
		/* 820662C4h case    5:*/		return 0x820662C8;
		  /* 820662C8h */ case    6:  		/* mr R21, R7 */
		/* 820662C8h case    6:*/		regs.R21 = regs.R7;
		/* 820662C8h case    6:*/		return 0x820662CC;
		  /* 820662CCh */ case    7:  		/* addi R11, R11, 2992 */
		/* 820662CCh case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xBB0);
		/* 820662CCh case    7:*/		return 0x820662D0;
		  /* 820662D0h */ case    8:  		/* stw R9, <#[R1 + 356]> */
		/* 820662D0h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000164) );
		/* 820662D0h case    8:*/		return 0x820662D4;
		  /* 820662D4h */ case    9:  		/* lwz R9, <#[R3 + 40]> */
		/* 820662D4h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000028) );
		/* 820662D4h case    9:*/		return 0x820662D8;
		  /* 820662D8h */ case   10:  		/* rlwinm R10, R10, 1, 25, 30 */
		/* 820662D8h case   10:*/		cpu::op::rlwinm<0,1,25,30>(regs,&regs.R10,regs.R10);
		/* 820662D8h case   10:*/		return 0x820662DC;
		  /* 820662DCh */ case   11:  		/* addi R11, R11, 1 */
		/* 820662DCh case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820662DCh case   11:*/		return 0x820662E0;
		  /* 820662E0h */ case   12:  		/* stw R6, <#[R1 + 332]> */
		/* 820662E0h case   12:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x0000014C) );
		/* 820662E0h case   12:*/		return 0x820662E4;
		  /* 820662E4h */ case   13:  		/* stw R7, <#[R1 + 340]> */
		/* 820662E4h case   13:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x00000154) );
		/* 820662E4h case   13:*/		return 0x820662E8;
		  /* 820662E8h */ case   14:  		/* mr R20, R8 */
		/* 820662E8h case   14:*/		regs.R20 = regs.R8;
		/* 820662E8h case   14:*/		return 0x820662EC;
		  /* 820662ECh */ case   15:  		/* stw R8, <#[R1 + 348]> */
		/* 820662ECh case   15:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x0000015C) );
		/* 820662ECh case   15:*/		return 0x820662F0;
		  /* 820662F0h */ case   16:  		/* li R8, 0 */
		/* 820662F0h case   16:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820662F0h case   16:*/		return 0x820662F4;
		  /* 820662F4h */ case   17:  		/* lwz R7, <#[R3 + 28]> */
		/* 820662F4h case   17:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R3 + 0x0000001C) );
		/* 820662F4h case   17:*/		return 0x820662F8;
		  /* 820662F8h */ case   18:  		/* rlwinm R30, R9, 1, 31, 31 */
		/* 820662F8h case   18:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R30,regs.R9);
		/* 820662F8h case   18:*/		return 0x820662FC;
		  /* 820662FCh */ case   19:  		/* lwz R6, <#[R3 + 48]> */
		/* 820662FCh case   19:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R3 + 0x00000030) );
		/* 820662FCh case   19:*/		return 0x82066300;
		  /* 82066300h */ case   20:  		/* mr R31, R3 */
		/* 82066300h case   20:*/		regs.R31 = regs.R3;
		/* 82066300h case   20:*/		return 0x82066304;
		  /* 82066304h */ case   21:  		/* lbzx R14, <#[R10 + R11]> */
		/* 82066304h case   21:*/		cpu::mem::load8z( regs, &regs.R14, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82066304h case   21:*/		return 0x82066308;
		  /* 82066308h */ case   22:  		/* mr R27, R5 */
		/* 82066308h case   22:*/		regs.R27 = regs.R5;
		/* 82066308h case   22:*/		return 0x8206630C;
		  /* 8206630Ch */ case   23:  		/* stw R4, <#[R1 + 316]> */
		/* 8206630Ch case   23:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000013C) );
		/* 8206630Ch case   23:*/		return 0x82066310;
		  /* 82066310h */ case   24:  		/* rlwinm R28, R7, 1, 31, 31 */
		/* 82066310h case   24:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R28,regs.R7);
		/* 82066310h case   24:*/		return 0x82066314;
		  /* 82066314h */ case   25:  		/* stw R8, <#[R1 + 124]> */
		/* 82066314h case   25:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x0000007C) );
		/* 82066314h case   25:*/		return 0x82066318;
		  /* 82066318h */ case   26:  		/* rlwinm R24, R6, 23, 30, 31 */
		/* 82066318h case   26:*/		cpu::op::rlwinm<0,23,30,31>(regs,&regs.R24,regs.R6);
		/* 82066318h case   26:*/		return 0x8206631C;
		  /* 8206631Ch */ case   27:  		/* rlwinm R29, R30, 1, 0, 30 */
		/* 8206631Ch case   27:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R29,regs.R30);
		/* 8206631Ch case   27:*/		return 0x82066320;
		  /* 82066320h */ case   28:  		/* bl 44992 */
		/* 82066320h case   28:*/		regs.LR = 0x82066324; return 0x820712E0;
		/* 82066320h case   28:*/		return 0x82066324;
		  /* 82066324h */ case   29:  		/* addi R6, R1, 108 */
		/* 82066324h case   29:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x6C);
		/* 82066324h case   29:*/		return 0x82066328;
		  /* 82066328h */ case   30:  		/* addi R5, R1, 120 */
		/* 82066328h case   30:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x78);
		/* 82066328h case   30:*/		return 0x8206632C;
		  /* 8206632Ch */ case   31:  		/* addi R4, R1, 116 */
		/* 8206632Ch case   31:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x74);
		/* 8206632Ch case   31:*/		return 0x82066330;
		  /* 82066330h */ case   32:  		/* mr R3, R31 */
		/* 82066330h case   32:*/		regs.R3 = regs.R31;
		/* 82066330h case   32:*/		return 0x82066334;
		  /* 82066334h */ case   33:  		/* bl -3604 */
		/* 82066334h case   33:*/		regs.LR = 0x82066338; return 0x82065520;
		/* 82066334h case   33:*/		return 0x82066338;
		  /* 82066338h */ case   34:  		/* li R25, 1 */
		/* 82066338h case   34:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 82066338h case   34:*/		return 0x8206633C;
		  /* 8206633Ch */ case   35:  		/* cmplwi CR6, R24, 2 */
		/* 8206633Ch case   35:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000002);
		/* 8206633Ch case   35:*/		return 0x82066340;
		  /* 82066340h */ case   36:  		/* lwz R7, <#[R1 + 116]> */
		/* 82066340h case   36:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000074) );
		/* 82066340h case   36:*/		return 0x82066344;
		  /* 82066344h */ case   37:  		/* lwz R23, <#[R1 + 120]> */
		/* 82066344h case   37:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R1 + 0x00000078) );
		/* 82066344h case   37:*/		return 0x82066348;
		  /* 82066348h */ case   38:  		/* subf R9, R29, R7 */
		/* 82066348h case   38:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R29,regs.R7);
		/* 82066348h case   38:*/		return 0x8206634C;
		  /* 8206634Ch */ case   39:  		/* subf R8, R29, R23 */
		/* 8206634Ch case   39:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R29,regs.R23);
		/* 8206634Ch case   39:*/		return 0x82066350;
		  /* 82066350h */ case   40:  		/* addi R11, R9, -1 */
		/* 82066350h case   40:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0xFFFFFFFF);
		/* 82066350h case   40:*/		return 0x82066354;
		  /* 82066354h */ case   41:  		/* addi R10, R8, -1 */
		/* 82066354h case   41:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R8,0xFFFFFFFF);
		/* 82066354h case   41:*/		return 0x82066358;
		  /* 82066358h */ case   42:  		/* cntlzw R11, R11 */
		/* 82066358h case   42:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 82066358h case   42:*/		return 0x8206635C;
		  /* 8206635Ch */ case   43:  		/* cntlzw R6, R10 */
		/* 8206635Ch case   43:*/		cpu::op::cntlzw<0>(regs,&regs.R6,regs.R10);
		/* 8206635Ch case   43:*/		return 0x82066360;
		  /* 82066360h */ case   44:  		/* subf R10, R11, R30 */
		/* 82066360h case   44:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R30);
		/* 82066360h case   44:*/		return 0x82066364;
		  /* 82066364h */ case   45:  		/* subf R11, R6, R30 */
		/* 82066364h case   45:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R6,regs.R30);
		/* 82066364h case   45:*/		return 0x82066368;
		  /* 82066368h */ case   46:  		/* addi R10, R10, 32 */
		/* 82066368h case   46:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x20);
		/* 82066368h case   46:*/		return 0x8206636C;
		  /* 8206636Ch */ case   47:  		/* addi R11, R11, 32 */
		/* 8206636Ch case   47:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x20);
		/* 8206636Ch case   47:*/		return 0x82066370;
		  /* 82066370h */ case   48:  		/* slw R26, R25, R10 */
		/* 82066370h case   48:*/		cpu::op::slw<0>(regs,&regs.R26,regs.R25,regs.R10);
		/* 82066370h case   48:*/		return 0x82066374;
		  /* 82066374h */ case   49:  		/* slw R17, R25, R11 */
		/* 82066374h case   49:*/		cpu::op::slw<0>(regs,&regs.R17,regs.R25,regs.R11);
		/* 82066374h case   49:*/		return 0x82066378;
		  /* 82066378h */ case   50:  		/* bc 4, CR6_EQ, 36 */
		/* 82066378h case   50:*/		if ( !regs.CR[6].eq ) { return 0x8206639C;  }
		/* 82066378h case   50:*/		return 0x8206637C;
		  /* 8206637Ch */ case   51:  		/* lwz R11, <#[R1 + 108]> */
		/* 8206637Ch case   51:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000006C) );
		/* 8206637Ch case   51:*/		return 0x82066380;
		  /* 82066380h */ case   52:  		/* subf R11, R29, R11 */
		/* 82066380h case   52:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R29,regs.R11);
		/* 82066380h case   52:*/		return 0x82066384;
		  /* 82066384h */ case   53:  		/* addi R11, R11, -1 */
		/* 82066384h case   53:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82066384h case   53:*/		return 0x82066388;
		  /* 82066388h */ case   54:  		/* cntlzw R11, R11 */
		/* 82066388h case   54:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 82066388h case   54:*/		return 0x8206638C;
		  /* 8206638Ch */ case   55:  		/* subf R11, R11, R30 */
		/* 8206638Ch case   55:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 8206638Ch case   55:*/		return 0x82066390;
		  /* 82066390h */ case   56:  		/* addi R11, R11, 32 */
		/* 82066390h case   56:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x20);
		/* 82066390h case   56:*/		return 0x82066394;
		  /* 82066394h */ case   57:  		/* slw R15, R25, R11 */
		/* 82066394h case   57:*/		cpu::op::slw<0>(regs,&regs.R15,regs.R25,regs.R11);
		/* 82066394h case   57:*/		return 0x82066398;
		  /* 82066398h */ case   58:  		/* b 8 */
		/* 82066398h case   58:*/		return 0x820663A0;
		/* 82066398h case   58:*/		return 0x8206639C;
	}
	return 0x8206639C;
} // Block from 820662B0h-8206639Ch (59 instructions)

//////////////////////////////////////////////////////
// Block at 8206639Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206639C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206639C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206639C);
		  /* 8206639Ch */ case    0:  		/* mr R15, R25 */
		/* 8206639Ch case    0:*/		regs.R15 = regs.R25;
		/* 8206639Ch case    0:*/		return 0x820663A0;
	}
	return 0x820663A0;
} // Block from 8206639Ch-820663A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820663A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820663A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820663A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820663A0);
		  /* 820663A0h */ case    0:  		/* cmplwi CR6, R26, 16 */
		/* 820663A0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000010);
		/* 820663A0h case    0:*/		return 0x820663A4;
		  /* 820663A4h */ case    1:  		/* bc 4, CR6_GT, 12 */
		/* 820663A4h case    1:*/		if ( !regs.CR[6].gt ) { return 0x820663B0;  }
		/* 820663A4h case    1:*/		return 0x820663A8;
		  /* 820663A8h */ case    2:  		/* cmplwi CR6, R17, 16 */
		/* 820663A8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R17,0x00000010);
		/* 820663A8h case    2:*/		return 0x820663AC;
		  /* 820663ACh */ case    3:  		/* bc 12, CR6_GT, 20 */
		/* 820663ACh case    3:*/		if ( regs.CR[6].gt ) { return 0x820663C0;  }
		/* 820663ACh case    3:*/		return 0x820663B0;
	}
	return 0x820663B0;
} // Block from 820663A0h-820663B0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820663B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820663B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820663B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820663B0);
		  /* 820663B0h */ case    0:  		/* lwz R11, <#[R31 + 48]> */
		/* 820663B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 820663B0h case    0:*/		return 0x820663B4;
		  /* 820663B4h */ case    1:  		/* mr R30, R25 */
		/* 820663B4h case    1:*/		regs.R30 = regs.R25;
		/* 820663B4h case    1:*/		return 0x820663B8;
		  /* 820663B8h */ case    2:  		/* rlwinm. R11, R11, 0, 20, 20 */
		/* 820663B8h case    2:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R11,regs.R11);
		/* 820663B8h case    2:*/		return 0x820663BC;
		  /* 820663BCh */ case    3:  		/* bc 4, CR0_EQ, 8 */
		/* 820663BCh case    3:*/		if ( !regs.CR[0].eq ) { return 0x820663C4;  }
		/* 820663BCh case    3:*/		return 0x820663C0;
	}
	return 0x820663C0;
} // Block from 820663B0h-820663C0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820663C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820663C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820663C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820663C0);
		  /* 820663C0h */ case    0:  		/* li R30, 0 */
		/* 820663C0h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820663C0h case    0:*/		return 0x820663C4;
	}
	return 0x820663C4;
} // Block from 820663C0h-820663C4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820663C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820663C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820663C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820663C4);
		  /* 820663C4h */ case    0:  		/* cmplwi CR6, R27, 0 */
		/* 820663C4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820663C4h case    0:*/		return 0x820663C8;
		  /* 820663C8h */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 820663C8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820663DC;  }
		/* 820663C8h case    1:*/		return 0x820663CC;
		  /* 820663CCh */ case    2:  		/* cmpwi CR6, R30, 0 */
		/* 820663CCh case    2:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 820663CCh case    2:*/		return 0x820663D0;
		  /* 820663D0h */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 820663D0h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820663DC;  }
		/* 820663D0h case    3:*/		return 0x820663D4;
		  /* 820663D4h */ case    4:  		/* lwz R11, <#[R31 + 48]> */
		/* 820663D4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 820663D4h case    4:*/		return 0x820663D8;
		  /* 820663D8h */ case    5:  		/* b 8 */
		/* 820663D8h case    5:*/		return 0x820663E0;
		/* 820663D8h case    5:*/		return 0x820663DC;
	}
	return 0x820663DC;
} // Block from 820663C4h-820663DCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 820663DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820663DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820663DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820663DC);
		  /* 820663DCh */ case    0:  		/* lwz R11, <#[R31 + 32]> */
		/* 820663DCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 820663DCh case    0:*/		return 0x820663E0;
	}
	return 0x820663E0;
} // Block from 820663DCh-820663E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820663E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820663E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820663E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820663E0);
		  /* 820663E0h */ case    0:  		/* rlwinm R11, R11, 0, 0, 19 */
		/* 820663E0h case    0:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R11);
		/* 820663E0h case    0:*/		return 0x820663E4;
		  /* 820663E4h */ case    1:  		/* cmplwi CR6, R27, 0 */
		/* 820663E4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 820663E4h case    1:*/		return 0x820663E8;
		  /* 820663E8h */ case    2:  		/* stw R11, <#[R1 + 104]> */
		/* 820663E8h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 820663E8h case    2:*/		return 0x820663EC;
		  /* 820663ECh */ case    3:  		/* bc 4, CR6_EQ, 224 */
		/* 820663ECh case    3:*/		if ( !regs.CR[6].eq ) { return 0x820664CC;  }
		/* 820663ECh case    3:*/		return 0x820663F0;
		  /* 820663F0h */ case    4:  		/* cmpwi CR6, R30, 0 */
		/* 820663F0h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 820663F0h case    4:*/		return 0x820663F4;
		  /* 820663F4h */ case    5:  		/* bc 4, CR6_EQ, 216 */
		/* 820663F4h case    5:*/		if ( !regs.CR[6].eq ) { return 0x820664CC;  }
		/* 820663F4h case    5:*/		return 0x820663F8;
		  /* 820663F8h */ case    6:  		/* lwz R11, <#[R1 + 108]> */
		/* 820663F8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000006C) );
		/* 820663F8h case    6:*/		return 0x820663FC;
		  /* 820663FCh */ case    7:  		/* mr R9, R28 */
		/* 820663FCh case    7:*/		regs.R9 = regs.R28;
		/* 820663FCh case    7:*/		return 0x82066400;
		  /* 82066400h */ case    8:  		/* stw R7, <#[R1 + 112]> */
		/* 82066400h case    8:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x00000070) );
		/* 82066400h case    8:*/		return 0x82066404;
		  /* 82066404h */ case    9:  		/* mr R6, R14 */
		/* 82066404h case    9:*/		regs.R6 = regs.R14;
		/* 82066404h case    9:*/		return 0x82066408;
		  /* 82066408h */ case   10:  		/* stw R23, <#[R1 + 100]> */
		/* 82066408h case   10:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R1 + 0x00000064) );
		/* 82066408h case   10:*/		return 0x8206640C;
		  /* 8206640Ch */ case   11:  		/* addi R5, R1, 96 */
		/* 8206640Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x60);
		/* 8206640Ch case   11:*/		return 0x82066410;
		  /* 82066410h */ case   12:  		/* lwz R29, <#[R31 + 48]> */
		/* 82066410h case   12:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x00000030) );
		/* 82066410h case   12:*/		return 0x82066414;
		  /* 82066414h */ case   13:  		/* addi R4, R1, 100 */
		/* 82066414h case   13:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x64);
		/* 82066414h case   13:*/		return 0x82066418;
		  /* 82066418h */ case   14:  		/* lwz R30, <#[R31 + 32]> */
		/* 82066418h case   14:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000020) );
		/* 82066418h case   14:*/		return 0x8206641C;
		  /* 8206641Ch */ case   15:  		/* addi R3, R1, 112 */
		/* 8206641Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x70);
		/* 8206641Ch case   15:*/		return 0x82066420;
		  /* 82066420h */ case   16:  		/* stw R11, <#[R1 + 96]> */
		/* 82066420h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82066420h case   16:*/		return 0x82066424;
		  /* 82066424h */ case   17:  		/* rlwinm R27, R29, 23, 30, 31 */
		/* 82066424h case   17:*/		cpu::op::rlwinm<0,23,30,31>(regs,&regs.R27,regs.R29);
		/* 82066424h case   17:*/		return 0x82066428;
		  /* 82066428h */ case   18:  		/* rlwinm R28, R30, 0, 26, 31 */
		/* 82066428h case   18:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R28,regs.R30);
		/* 82066428h case   18:*/		return 0x8206642C;
		  /* 8206642Ch */ case   19:  		/* mr R8, R27 */
		/* 8206642Ch case   19:*/		regs.R8 = regs.R27;
		/* 8206642Ch case   19:*/		return 0x82066430;
		  /* 82066430h */ case   20:  		/* mr R7, R28 */
		/* 82066430h case   20:*/		regs.R7 = regs.R28;
		/* 82066430h case   20:*/		return 0x82066434;
		  /* 82066434h */ case   21:  		/* bl -3148 */
		/* 82066434h case   21:*/		regs.LR = 0x82066438; return 0x820657E8;
		/* 82066434h case   21:*/		return 0x82066438;
		  /* 82066438h */ case   22:  		/* lwz R26, <#[R31 + 28]> */
		/* 82066438h case   22:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R31 + 0x0000001C) );
		/* 82066438h case   22:*/		return 0x8206643C;
		  /* 8206643Ch */ case   23:  		/* rlwinm. R11, R26, 0, 0, 0 */
		/* 8206643Ch case   23:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R11,regs.R26);
		/* 8206643Ch case   23:*/		return 0x82066440;
		  /* 82066440h */ case   24:  		/* bc 4, CR0_EQ, 92 */
		/* 82066440h case   24:*/		if ( !regs.CR[0].eq ) { return 0x8206649C;  }
		/* 82066440h case   24:*/		return 0x82066444;
		  /* 82066444h */ case   25:  		/* rlwinm. R11, R30, 0, 21, 21 */
		/* 82066444h case   25:*/		cpu::op::rlwinm<1,0,21,21>(regs,&regs.R11,regs.R30);
		/* 82066444h case   25:*/		return 0x82066448;
		  /* 82066448h */ case   26:  		/* bc 4, CR0_EQ, 84 */
		/* 82066448h case   26:*/		if ( !regs.CR[0].eq ) { return 0x8206649C;  }
		/* 82066448h case   26:*/		return 0x8206644C;
		  /* 8206644Ch */ case   27:  		/* rlwinm. R11, R29, 0, 20, 20 */
		/* 8206644Ch case   27:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R11,regs.R29);
		/* 8206644Ch case   27:*/		return 0x82066450;
		  /* 82066450h */ case   28:  		/* bc 4, CR0_EQ, 76 */
		/* 82066450h case   28:*/		if ( !regs.CR[0].eq ) { return 0x8206649C;  }
		/* 82066450h case   28:*/		return 0x82066454;
		  /* 82066454h */ case   29:  		/* cmplwi CR6, R27, 1 */
		/* 82066454h case   29:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000001);
		/* 82066454h case   29:*/		return 0x82066458;
		  /* 82066458h */ case   30:  		/* bc 4, CR6_EQ, 68 */
		/* 82066458h case   30:*/		if ( !regs.CR[6].eq ) { return 0x8206649C;  }
		/* 82066458h case   30:*/		return 0x8206645C;
		  /* 8206645Ch */ case   31:  		/* lwz R11, <#[R31 + 44]> */
		/* 8206645Ch case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 8206645Ch case   31:*/		return 0x82066460;
		  /* 82066460h */ case   32:  		/* rlwinm. R11, R11, 0, 22, 25 */
		/* 82066460h case   32:*/		cpu::op::rlwinm<1,0,22,25>(regs,&regs.R11,regs.R11);
		/* 82066460h case   32:*/		return 0x82066464;
		  /* 82066464h */ case   33:  		/* bc 4, CR0_EQ, 56 */
		/* 82066464h case   33:*/		if ( !regs.CR[0].eq ) { return 0x8206649C;  }
		/* 82066464h case   33:*/		return 0x82066468;
		  /* 82066468h */ case   34:  		/* lwz R11, <#[R31 + 40]> */
		/* 82066468h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 82066468h case   34:*/		return 0x8206646C;
		  /* 8206646Ch */ case   35:  		/* rlwinm. R11, R11, 0, 0, 0 */
		/* 8206646Ch case   35:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R11,regs.R11);
		/* 8206646Ch case   35:*/		return 0x82066470;
		  /* 82066470h */ case   36:  		/* bc 4, CR0_EQ, 44 */
		/* 82066470h case   36:*/		if ( !regs.CR[0].eq ) { return 0x8206649C;  }
		/* 82066470h case   36:*/		return 0x82066474;
		  /* 82066474h */ case   37:  		/* addi R5, R1, 100 */
		/* 82066474h case   37:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x64);
		/* 82066474h case   37:*/		return 0x82066478;
		  /* 82066478h */ case   38:  		/* addi R4, R1, 128 */
		/* 82066478h case   38:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x80);
		/* 82066478h case   38:*/		return 0x8206647C;
		  /* 8206647Ch */ case   39:  		/* mr R3, R28 */
		/* 8206647Ch case   39:*/		regs.R3 = regs.R28;
		/* 8206647Ch case   39:*/		return 0x82066480;
		  /* 82066480h */ case   40:  		/* bl -3512 */
		/* 82066480h case   40:*/		regs.LR = 0x82066484; return 0x820656C8;
		/* 82066480h case   40:*/		return 0x82066484;
		  /* 82066484h */ case   41:  		/* lwz R11, <#[R1 + 100]> */
		/* 82066484h case   41:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 82066484h case   41:*/		return 0x82066488;
		  /* 82066488h */ case   42:  		/* add R10, R11, R23 */
		/* 82066488h case   42:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R23);
		/* 82066488h case   42:*/		return 0x8206648C;
		  /* 8206648Ch */ case   43:  		/* addi R11, R11, -1 */
		/* 8206648Ch case   43:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8206648Ch case   43:*/		return 0x82066490;
		  /* 82066490h */ case   44:  		/* addi R10, R10, -1 */
		/* 82066490h case   44:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82066490h case   44:*/		return 0x82066494;
		  /* 82066494h */ case   45:  		/* andc R17, R10, R11 */
		/* 82066494h case   45:*/		cpu::op::andc<0>(regs,&regs.R17,regs.R10,regs.R11);
		/* 82066494h case   45:*/		return 0x82066498;
		  /* 82066498h */ case   46:  		/* b 8 */
		/* 82066498h case   46:*/		return 0x820664A0;
		/* 82066498h case   46:*/		return 0x8206649C;
	}
	return 0x8206649C;
} // Block from 820663E0h-8206649Ch (47 instructions)

//////////////////////////////////////////////////////
// Block at 8206649Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206649C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206649C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206649C);
		  /* 8206649Ch */ case    0:  		/* lwz R17, <#[R1 + 100]> */
		/* 8206649Ch case    0:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R1 + 0x00000064) );
		/* 8206649Ch case    0:*/		return 0x820664A0;
	}
	return 0x820664A0;
} // Block from 8206649Ch-820664A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820664A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820664A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820664A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820664A0);
		  /* 820664A0h */ case    0:  		/* lwz R15, <#[R1 + 96]> */
		/* 820664A0h case    0:*/		cpu::mem::load32z( regs, &regs.R15, (uint32)(regs.R1 + 0x00000060) );
		/* 820664A0h case    0:*/		return 0x820664A4;
		  /* 820664A4h */ case    1:  		/* cmplwi CR6, R24, 0 */
		/* 820664A4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 820664A4h case    1:*/		return 0x820664A8;
		  /* 820664A8h */ case    2:  		/* bc 4, CR6_EQ, 20 */
		/* 820664A8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820664BC;  }
		/* 820664A8h case    2:*/		return 0x820664AC;
		  /* 820664ACh */ case    3:  		/* lwz R11, <#[R1 + 112]> */
		/* 820664ACh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 820664ACh case    3:*/		return 0x820664B0;
		  /* 820664B0h */ case    4:  		/* mullw R11, R11, R14 */
		/* 820664B0h case    4:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R14);
		/* 820664B0h case    4:*/		return 0x820664B4;
		  /* 820664B4h */ case    5:  		/* rlwinm R30, R11, 29, 3, 31 */
		/* 820664B4h case    5:*/		cpu::op::rlwinm<0,29,3,31>(regs,&regs.R30,regs.R11);
		/* 820664B4h case    5:*/		return 0x820664B8;
		  /* 820664B8h */ case    6:  		/* b 584 */
		/* 820664B8h case    6:*/		return 0x82066700;
		/* 820664B8h case    6:*/		return 0x820664BC;
	}
	return 0x820664BC;
} // Block from 820664A0h-820664BCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 820664BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820664BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820664BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820664BC);
		  /* 820664BCh */ case    0:  		/* rlwinm R11, R26, 10, 23, 31 */
		/* 820664BCh case    0:*/		cpu::op::rlwinm<0,10,23,31>(regs,&regs.R11,regs.R26);
		/* 820664BCh case    0:*/		return 0x820664C0;
		  /* 820664C0h */ case    1:  		/* mullw R11, R11, R14 */
		/* 820664C0h case    1:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R14);
		/* 820664C0h case    1:*/		return 0x820664C4;
		  /* 820664C4h */ case    2:  		/* rlwinm R30, R11, 2, 3, 29 */
		/* 820664C4h case    2:*/		cpu::op::rlwinm<0,2,3,29>(regs,&regs.R30,regs.R11);
		/* 820664C4h case    2:*/		return 0x820664C8;
		  /* 820664C8h */ case    3:  		/* b 568 */
		/* 820664C8h case    3:*/		return 0x82066700;
		/* 820664C8h case    3:*/		return 0x820664CC;
	}
	return 0x820664CC;
} // Block from 820664BCh-820664CCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820664CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820664CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820664CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820664CC);
		  /* 820664CCh */ case    0:  		/* srw R10, R9, R27 */
		/* 820664CCh case    0:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R9,regs.R27);
		/* 820664CCh case    0:*/		return 0x820664D0;
		  /* 820664D0h */ case    1:  		/* cmplwi CR6, R10, 1 */
		/* 820664D0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 820664D0h case    1:*/		return 0x820664D4;
		  /* 820664D4h */ case    2:  		/* bc 12, CR6_GT, 8 */
		/* 820664D4h case    2:*/		if ( regs.CR[6].gt ) { return 0x820664DC;  }
		/* 820664D4h case    2:*/		return 0x820664D8;
		  /* 820664D8h */ case    3:  		/* mr R10, R25 */
		/* 820664D8h case    3:*/		regs.R10 = regs.R25;
		/* 820664D8h case    3:*/		return 0x820664DC;
	}
	return 0x820664DC;
} // Block from 820664CCh-820664DCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820664DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820664DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820664DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820664DC);
		  /* 820664DCh */ case    0:  		/* srw R11, R8, R27 */
		/* 820664DCh case    0:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R8,regs.R27);
		/* 820664DCh case    0:*/		return 0x820664E0;
		  /* 820664E0h */ case    1:  		/* add R10, R10, R29 */
		/* 820664E0h case    1:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R29);
		/* 820664E0h case    1:*/		return 0x820664E4;
		  /* 820664E4h */ case    2:  		/* cmplwi CR6, R11, 1 */
		/* 820664E4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 820664E4h case    2:*/		return 0x820664E8;
		  /* 820664E8h */ case    3:  		/* stw R10, <#[R1 + 116]> */
		/* 820664E8h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000074) );
		/* 820664E8h case    3:*/		return 0x820664EC;
		  /* 820664ECh */ case    4:  		/* bc 12, CR6_GT, 8 */
		/* 820664ECh case    4:*/		if ( regs.CR[6].gt ) { return 0x820664F4;  }
		/* 820664ECh case    4:*/		return 0x820664F0;
		  /* 820664F0h */ case    5:  		/* mr R11, R25 */
		/* 820664F0h case    5:*/		regs.R11 = regs.R25;
		/* 820664F0h case    5:*/		return 0x820664F4;
	}
	return 0x820664F4;
} // Block from 820664DCh-820664F4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820664F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820664F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820664F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820664F4);
		  /* 820664F4h */ case    0:  		/* add R11, R11, R29 */
		/* 820664F4h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 820664F4h case    0:*/		return 0x820664F8;
		  /* 820664F8h */ case    1:  		/* cmplwi CR6, R24, 2 */
		/* 820664F8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000002);
		/* 820664F8h case    1:*/		return 0x820664FC;
		  /* 820664FCh */ case    2:  		/* stw R11, <#[R1 + 120]> */
		/* 820664FCh case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000078) );
		/* 820664FCh case    2:*/		return 0x82066500;
		  /* 82066500h */ case    3:  		/* bc 4, CR6_EQ, 40 */
		/* 82066500h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82066528;  }
		/* 82066500h case    3:*/		return 0x82066504;
		  /* 82066504h */ case    4:  		/* lwz R11, <#[R1 + 108]> */
		/* 82066504h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000006C) );
		/* 82066504h case    4:*/		return 0x82066508;
		  /* 82066508h */ case    5:  		/* subf R11, R29, R11 */
		/* 82066508h case    5:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R29,regs.R11);
		/* 82066508h case    5:*/		return 0x8206650C;
		  /* 8206650Ch */ case    6:  		/* srw R11, R11, R27 */
		/* 8206650Ch case    6:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R27);
		/* 8206650Ch case    6:*/		return 0x82066510;
		  /* 82066510h */ case    7:  		/* cmplwi CR6, R11, 1 */
		/* 82066510h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82066510h case    7:*/		return 0x82066514;
		  /* 82066514h */ case    8:  		/* bc 12, CR6_GT, 8 */
		/* 82066514h case    8:*/		if ( regs.CR[6].gt ) { return 0x8206651C;  }
		/* 82066514h case    8:*/		return 0x82066518;
	}
	return 0x82066518;
} // Block from 820664F4h-82066518h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82066518h
// Function 'D3DDevice_ClearF'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066518( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066518) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066518);
		  /* 82066518h */ case    0:  		/* mr R11, R25 */
		/* 82066518h case    0:*/		regs.R11 = regs.R25;
		/* 82066518h case    0:*/		return 0x8206651C;
	}
	return 0x8206651C;
} // Block from 82066518h-8206651Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206651Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206651C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206651C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206651C);
		  /* 8206651Ch */ case    0:  		/* add R11, R11, R29 */
		/* 8206651Ch case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 8206651Ch case    0:*/		return 0x82066520;
		  /* 82066520h */ case    1:  		/* stw R11, <#[R1 + 108]> */
		/* 82066520h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000006C) );
		/* 82066520h case    1:*/		return 0x82066524;
		  /* 82066524h */ case    2:  		/* b 8 */
		/* 82066524h case    2:*/		return 0x8206652C;
		/* 82066524h case    2:*/		return 0x82066528;
	}
	return 0x82066528;
} // Block from 8206651Ch-82066528h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82066528h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066528( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066528) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066528);
		  /* 82066528h */ case    0:  		/* stw R25, <#[R1 + 108]> */
		/* 82066528h case    0:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x0000006C) );
		/* 82066528h case    0:*/		return 0x8206652C;
	}
	return 0x8206652C;
} // Block from 82066528h-8206652Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206652Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206652C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206652C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206652C);
		  /* 8206652Ch */ case    0:  		/* mr R3, R31 */
		/* 8206652Ch case    0:*/		regs.R3 = regs.R31;
		/* 8206652Ch case    0:*/		return 0x82066530;
		  /* 82066530h */ case    1:  		/* bl 44464 */
		/* 82066530h case    1:*/		regs.LR = 0x82066534; return 0x820712E0;
		/* 82066530h case    1:*/		return 0x82066534;
		  /* 82066534h */ case    2:  		/* cmpwi CR6, R3, 18 */
		/* 82066534h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000012);
		/* 82066534h case    2:*/		return 0x82066538;
		  /* 82066538h */ case    3:  		/* bc 12, CR6_EQ, 20 */
		/* 82066538h case    3:*/		if ( regs.CR[6].eq ) { return 0x8206654C;  }
		/* 82066538h case    3:*/		return 0x8206653C;
		  /* 8206653Ch */ case    4:  		/* cmpwi CR6, R3, 19 */
		/* 8206653Ch case    4:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000013);
		/* 8206653Ch case    4:*/		return 0x82066540;
		  /* 82066540h */ case    5:  		/* bc 12, CR6_EQ, 12 */
		/* 82066540h case    5:*/		if ( regs.CR[6].eq ) { return 0x8206654C;  }
		/* 82066540h case    5:*/		return 0x82066544;
		  /* 82066544h */ case    6:  		/* mr R16, R25 */
		/* 82066544h case    6:*/		regs.R16 = regs.R25;
		/* 82066544h case    6:*/		return 0x82066548;
		  /* 82066548h */ case    7:  		/* b 36 */
		/* 82066548h case    7:*/		return 0x8206656C;
		/* 82066548h case    7:*/		return 0x8206654C;
	}
	return 0x8206654C;
} // Block from 8206652Ch-8206654Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8206654Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206654C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206654C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206654C);
		  /* 8206654Ch */ case    0:  		/* lwz R11, <#[R31 + 32]> */
		/* 8206654Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 8206654Ch case    0:*/		return 0x82066550;
		  /* 82066550h */ case    1:  		/* lwz R10, <#[R31 + 36]> */
		/* 82066550h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000024) );
		/* 82066550h case    1:*/		return 0x82066554;
		  /* 82066554h */ case    2:  		/* rlwinm R11, R11, 23, 30, 30 */
		/* 82066554h case    2:*/		cpu::op::rlwinm<0,23,30,30>(regs,&regs.R11,regs.R11);
		/* 82066554h case    2:*/		return 0x82066558;
		  /* 82066558h */ case    3:  		/* rlwinm R10, R10, 6, 26, 31 */
		/* 82066558h case    3:*/		cpu::op::rlwinm<0,6,26,31>(regs,&regs.R10,regs.R10);
		/* 82066558h case    3:*/		return 0x8206655C;
		  /* 8206655Ch */ case    4:  		/* slw R11, R25, R11 */
		/* 8206655Ch case    4:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R25,regs.R11);
		/* 8206655Ch case    4:*/		return 0x82066560;
		  /* 82066560h */ case    5:  		/* add R10, R10, R11 */
		/* 82066560h case    5:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 82066560h case    5:*/		return 0x82066564;
		  /* 82066564h */ case    6:  		/* addi R11, R11, -1 */
		/* 82066564h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82066564h case    6:*/		return 0x82066568;
		  /* 82066568h */ case    7:  		/* andc R16, R10, R11 */
		/* 82066568h case    7:*/		cpu::op::andc<0>(regs,&regs.R16,regs.R10,regs.R11);
		/* 82066568h case    7:*/		return 0x8206656C;
	}
	return 0x8206656C;
} // Block from 8206654Ch-8206656Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8206656Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206656C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206656C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206656C);
		  /* 8206656Ch */ case    0:  		/* cntlzw R11, R26 */
		/* 8206656Ch case    0:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R26);
		/* 8206656Ch case    0:*/		return 0x82066570;
		  /* 82066570h */ case    1:  		/* cntlzw R10, R17 */
		/* 82066570h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R17);
		/* 82066570h case    1:*/		return 0x82066574;
		  /* 82066574h */ case    2:  		/* cntlzw R9, R15 */
		/* 82066574h case    2:*/		cpu::op::cntlzw<0>(regs,&regs.R9,regs.R15);
		/* 82066574h case    2:*/		return 0x82066578;
		  /* 82066578h */ case    3:  		/* subfic R22, R11, 31 */
		/* 82066578h case    3:*/		cpu::op::subfic<0>(regs,&regs.R22,regs.R11,0x1F);
		/* 82066578h case    3:*/		return 0x8206657C;
		  /* 8206657Ch */ case    4:  		/* subfic R23, R10, 31 */
		/* 8206657Ch case    4:*/		cpu::op::subfic<0>(regs,&regs.R23,regs.R10,0x1F);
		/* 8206657Ch case    4:*/		return 0x82066580;
		  /* 82066580h */ case    5:  		/* subfic R24, R9, 31 */
		/* 82066580h case    5:*/		cpu::op::subfic<0>(regs,&regs.R24,regs.R9,0x1F);
		/* 82066580h case    5:*/		return 0x82066584;
		  /* 82066584h */ case    6:  		/* cmpwi CR6, R30, 0 */
		/* 82066584h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 82066584h case    6:*/		return 0x82066588;
		  /* 82066588h */ case    7:  		/* bc 12, CR6_EQ, 24 */
		/* 82066588h case    7:*/		if ( regs.CR[6].eq ) { return 0x820665A0;  }
		/* 82066588h case    7:*/		return 0x8206658C;
		  /* 8206658Ch */ case    8:  		/* mr R18, R27 */
		/* 8206658Ch case    8:*/		regs.R18 = regs.R27;
		/* 8206658Ch case    8:*/		return 0x82066590;
		  /* 82066590h */ case    9:  		/* addi R22, R22, 1 */
		/* 82066590h case    9:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R22,0x1);
		/* 82066590h case    9:*/		return 0x82066594;
		  /* 82066594h */ case   10:  		/* addi R23, R23, 1 */
		/* 82066594h case   10:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0x1);
		/* 82066594h case   10:*/		return 0x82066598;
		  /* 82066598h */ case   11:  		/* addi R24, R24, 1 */
		/* 82066598h case   11:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x1);
		/* 82066598h case   11:*/		return 0x8206659C;
		  /* 8206659Ch */ case   12:  		/* b 8 */
		/* 8206659Ch case   12:*/		return 0x820665A4;
		/* 8206659Ch case   12:*/		return 0x820665A0;
	}
	return 0x820665A0;
} // Block from 8206656Ch-820665A0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820665A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820665A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820665A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820665A0);
		  /* 820665A0h */ case    0:  		/* addi R18, R27, -1 */
		/* 820665A0h case    0:*/		cpu::op::addi<0>(regs,&regs.R18,regs.R27,0xFFFFFFFF);
		/* 820665A0h case    0:*/		return 0x820665A4;
	}
	return 0x820665A4;
} // Block from 820665A0h-820665A4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820665A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820665A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820665A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820665A4);
		  /* 820665A4h */ case    0:  		/* cmpwi CR6, R18, 0 */
		/* 820665A4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R18,0x00000000);
		/* 820665A4h case    0:*/		return 0x820665A8;
		  /* 820665A8h */ case    1:  		/* bc 12, CR6_LT, 340 */
		/* 820665A8h case    1:*/		if ( regs.CR[6].lt ) { return 0x820666FC;  }
		/* 820665A8h case    1:*/		return 0x820665AC;
		  /* 820665ACh */ case    2:  		/* lwz R11, <#[R31 + 28]> */
		/* 820665ACh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 820665ACh case    2:*/		return 0x820665B0;
		  /* 820665B0h */ case    3:  		/* lwz R10, <#[R31 + 32]> */
		/* 820665B0h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000020) );
		/* 820665B0h case    3:*/		return 0x820665B4;
		  /* 820665B4h */ case    4:  		/* lwz R20, <#[R31 + 48]> */
		/* 820665B4h case    4:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R31 + 0x00000030) );
		/* 820665B4h case    4:*/		return 0x820665B8;
		  /* 820665B8h */ case    5:  		/* rlwinm R19, R11, 1, 31, 31 */
		/* 820665B8h case    5:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R19,regs.R11);
		/* 820665B8h case    5:*/		return 0x820665BC;
		  /* 820665BCh */ case    6:  		/* rlwinm R21, R10, 0, 26, 31 */
		/* 820665BCh case    6:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R21,regs.R10);
		/* 820665BCh case    6:*/		return 0x820665C0;
		  /* 820665C0h */ case    7:  		/* cmplwi CR6, R22, 0 */
		/* 820665C0h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 820665C0h case    7:*/		return 0x820665C4;
		  /* 820665C4h */ case    8:  		/* bc 12, CR6_EQ, 8 */
		/* 820665C4h case    8:*/		if ( regs.CR[6].eq ) { return 0x820665CC;  }
		/* 820665C4h case    8:*/		return 0x820665C8;
		  /* 820665C8h */ case    9:  		/* addi R22, R22, -1 */
		/* 820665C8h case    9:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R22,0xFFFFFFFF);
		/* 820665C8h case    9:*/		return 0x820665CC;
	}
	return 0x820665CC;
} // Block from 820665A4h-820665CCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 820665CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820665CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820665CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820665CC);
		  /* 820665CCh */ case    0:  		/* cmplwi CR6, R23, 0 */
		/* 820665CCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 820665CCh case    0:*/		return 0x820665D0;
		  /* 820665D0h */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 820665D0h case    1:*/		if ( regs.CR[6].eq ) { return 0x820665D8;  }
		/* 820665D0h case    1:*/		return 0x820665D4;
		  /* 820665D4h */ case    2:  		/* addi R23, R23, -1 */
		/* 820665D4h case    2:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0xFFFFFFFF);
		/* 820665D4h case    2:*/		return 0x820665D8;
	}
	return 0x820665D8;
} // Block from 820665CCh-820665D8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820665D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820665D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820665D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820665D8);
		  /* 820665D8h */ case    0:  		/* cmplwi CR6, R24, 0 */
		/* 820665D8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 820665D8h case    0:*/		return 0x820665DC;
		  /* 820665DCh */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 820665DCh case    1:*/		if ( regs.CR[6].eq ) { return 0x820665E4;  }
		/* 820665DCh case    1:*/		return 0x820665E0;
		  /* 820665E0h */ case    2:  		/* addi R24, R24, -1 */
		/* 820665E0h case    2:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0xFFFFFFFF);
		/* 820665E0h case    2:*/		return 0x820665E4;
	}
	return 0x820665E4;
} // Block from 820665D8h-820665E4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820665E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820665E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820665E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820665E4);
		  /* 820665E4h */ case    0:  		/* slw R29, R25, R22 */
		/* 820665E4h case    0:*/		cpu::op::slw<0>(regs,&regs.R29,regs.R25,regs.R22);
		/* 820665E4h case    0:*/		return 0x820665E8;
		  /* 820665E8h */ case    1:  		/* slw R28, R25, R23 */
		/* 820665E8h case    1:*/		cpu::op::slw<0>(regs,&regs.R28,regs.R25,regs.R23);
		/* 820665E8h case    1:*/		return 0x820665EC;
		  /* 820665ECh */ case    2:  		/* stw R29, <#[R1 + 112]> */
		/* 820665ECh case    2:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000070) );
		/* 820665ECh case    2:*/		return 0x820665F0;
		  /* 820665F0h */ case    3:  		/* slw R27, R25, R24 */
		/* 820665F0h case    3:*/		cpu::op::slw<0>(regs,&regs.R27,regs.R25,regs.R24);
		/* 820665F0h case    3:*/		return 0x820665F4;
		  /* 820665F4h */ case    4:  		/* stw R28, <#[R1 + 100]> */
		/* 820665F4h case    4:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000064) );
		/* 820665F4h case    4:*/		return 0x820665F8;
		  /* 820665F8h */ case    5:  		/* stw R27, <#[R1 + 96]> */
		/* 820665F8h case    5:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000060) );
		/* 820665F8h case    5:*/		return 0x820665FC;
		  /* 820665FCh */ case    6:  		/* rlwinm R26, R20, 23, 30, 31 */
		/* 820665FCh case    6:*/		cpu::op::rlwinm<0,23,30,31>(regs,&regs.R26,regs.R20);
		/* 820665FCh case    6:*/		return 0x82066600;
		  /* 82066600h */ case    7:  		/* mr R9, R19 */
		/* 82066600h case    7:*/		regs.R9 = regs.R19;
		/* 82066600h case    7:*/		return 0x82066604;
		  /* 82066604h */ case    8:  		/* mr R8, R26 */
		/* 82066604h case    8:*/		regs.R8 = regs.R26;
		/* 82066604h case    8:*/		return 0x82066608;
		  /* 82066608h */ case    9:  		/* mr R7, R21 */
		/* 82066608h case    9:*/		regs.R7 = regs.R21;
		/* 82066608h case    9:*/		return 0x8206660C;
		  /* 8206660Ch */ case   10:  		/* mr R6, R14 */
		/* 8206660Ch case   10:*/		regs.R6 = regs.R14;
		/* 8206660Ch case   10:*/		return 0x82066610;
		  /* 82066610h */ case   11:  		/* addi R5, R1, 96 */
		/* 82066610h case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x60);
		/* 82066610h case   11:*/		return 0x82066614;
		  /* 82066614h */ case   12:  		/* addi R4, R1, 100 */
		/* 82066614h case   12:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x64);
		/* 82066614h case   12:*/		return 0x82066618;
		  /* 82066618h */ case   13:  		/* addi R3, R1, 112 */
		/* 82066618h case   13:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x70);
		/* 82066618h case   13:*/		return 0x8206661C;
		  /* 8206661Ch */ case   14:  		/* bl -3636 */
		/* 8206661Ch case   14:*/		regs.LR = 0x82066620; return 0x820657E8;
		/* 8206661Ch case   14:*/		return 0x82066620;
		  /* 82066620h */ case   15:  		/* lwz R11, <#[R1 + 112]> */
		/* 82066620h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 82066620h case   15:*/		return 0x82066624;
		  /* 82066624h */ case   16:  		/* cmplwi CR6, R29, 16 */
		/* 82066624h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000010);
		/* 82066624h case   16:*/		return 0x82066628;
		  /* 82066628h */ case   17:  		/* mullw R11, R11, R14 */
		/* 82066628h case   17:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R14);
		/* 82066628h case   17:*/		return 0x8206662C;
		  /* 8206662Ch */ case   18:  		/* rlwinm R30, R11, 29, 3, 31 */
		/* 8206662Ch case   18:*/		cpu::op::rlwinm<0,29,3,31>(regs,&regs.R30,regs.R11);
		/* 8206662Ch case   18:*/		return 0x82066630;
		  /* 82066630h */ case   19:  		/* bc 4, CR6_GT, 12 */
		/* 82066630h case   19:*/		if ( !regs.CR[6].gt ) { return 0x8206663C;  }
		/* 82066630h case   19:*/		return 0x82066634;
		  /* 82066634h */ case   20:  		/* cmplwi CR6, R28, 16 */
		/* 82066634h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000010);
		/* 82066634h case   20:*/		return 0x82066638;
		  /* 82066638h */ case   21:  		/* bc 12, CR6_GT, 12 */
		/* 82066638h case   21:*/		if ( regs.CR[6].gt ) { return 0x82066644;  }
		/* 82066638h case   21:*/		return 0x8206663C;
	}
	return 0x8206663C;
} // Block from 820665E4h-8206663Ch (22 instructions)

//////////////////////////////////////////////////////
// Block at 8206663Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206663C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206663C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206663C);
		  /* 8206663Ch */ case    0:  		/* rlwinm. R11, R20, 0, 20, 20 */
		/* 8206663Ch case    0:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R11,regs.R20);
		/* 8206663Ch case    0:*/		return 0x82066640;
		  /* 82066640h */ case    1:  		/* bc 4, CR0_EQ, 100 */
		/* 82066640h case    1:*/		if ( !regs.CR[0].eq ) { return 0x820666A4;  }
		/* 82066640h case    1:*/		return 0x82066644;
	}
	return 0x82066644;
} // Block from 8206663Ch-82066644h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82066644h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066644( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066644) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066644);
		  /* 82066644h */ case    0:  		/* lwz R17, <#[R1 + 100]> */
		/* 82066644h case    0:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R1 + 0x00000064) );
		/* 82066644h case    0:*/		return 0x82066648;
	}
	return 0x82066648;
} // Block from 82066644h-82066648h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82066648h
// Function '?BuildGprAllocationSetup@D3D@@YAKPAVCDevice@1@PAK1@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066648( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066648) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066648);
		  /* 82066648h */ case    0:  		/* cmpwi CR6, R18, 0 */
		/* 82066648h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R18,0x00000000);
		/* 82066648h case    0:*/		return 0x8206664C;
		  /* 8206664Ch */ case    1:  		/* lwz R15, <#[R1 + 96]> */
		/* 8206664Ch case    1:*/		cpu::mem::load32z( regs, &regs.R15, (uint32)(regs.R1 + 0x00000060) );
		/* 8206664Ch case    1:*/		return 0x82066650;
		  /* 82066650h */ case    2:  		/* bc 4, CR6_GT, 64 */
		/* 82066650h case    2:*/		if ( !regs.CR[6].gt ) { return 0x82066690;  }
		/* 82066650h case    2:*/		return 0x82066654;
		  /* 82066654h */ case    3:  		/* cmplwi CR6, R26, 2 */
		/* 82066654h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000002);
		/* 82066654h case    3:*/		return 0x82066658;
		  /* 82066658h */ case    4:  		/* bc 12, CR6_EQ, 24 */
		/* 82066658h case    4:*/		if ( regs.CR[6].eq ) { return 0x82066670;  }
		/* 82066658h case    4:*/		return 0x8206665C;
		  /* 8206665Ch */ case    5:  		/* mullw R11, R30, R17 */
		/* 8206665Ch case    5:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R30,regs.R17);
		/* 8206665Ch case    5:*/		return 0x82066660;
		  /* 82066660h */ case    6:  		/* addi R11, R11, 4095 */
		/* 82066660h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFF);
		/* 82066660h case    6:*/		return 0x82066664;
		  /* 82066664h */ case    7:  		/* rlwinm R11, R11, 0, 0, 19 */
		/* 82066664h case    7:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R11);
		/* 82066664h case    7:*/		return 0x82066668;
		  /* 82066668h */ case    8:  		/* mullw R11, R11, R15 */
		/* 82066668h case    8:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R15);
		/* 82066668h case    8:*/		return 0x8206666C;
		  /* 8206666Ch */ case    9:  		/* b 20 */
		/* 8206666Ch case    9:*/		return 0x82066680;
		/* 8206666Ch case    9:*/		return 0x82066670;
	}
	return 0x82066670;
} // Block from 82066648h-82066670h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82066670h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066670( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066670) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066670);
		  /* 82066670h */ case    0:  		/* mullw R11, R30, R15 */
		/* 82066670h case    0:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R30,regs.R15);
		/* 82066670h case    0:*/		return 0x82066674;
		  /* 82066674h */ case    1:  		/* mullw R11, R11, R17 */
		/* 82066674h case    1:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R17);
		/* 82066674h case    1:*/		return 0x82066678;
		  /* 82066678h */ case    2:  		/* addi R11, R11, 4095 */
		/* 82066678h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFF);
		/* 82066678h case    2:*/		return 0x8206667C;
		  /* 8206667Ch */ case    3:  		/* rlwinm R11, R11, 0, 0, 19 */
		/* 8206667Ch case    3:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R11);
		/* 8206667Ch case    3:*/		return 0x82066680;
	}
	return 0x82066680;
} // Block from 82066670h-82066680h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82066680h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066680( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066680) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066680);
		  /* 82066680h */ case    0:  		/* lwz R10, <#[R1 + 104]> */
		/* 82066680h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000068) );
		/* 82066680h case    0:*/		return 0x82066684;
		  /* 82066684h */ case    1:  		/* mullw R11, R11, R16 */
		/* 82066684h case    1:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R16);
		/* 82066684h case    1:*/		return 0x82066688;
		  /* 82066688h */ case    2:  		/* add R11, R11, R10 */
		/* 82066688h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82066688h case    2:*/		return 0x8206668C;
		  /* 8206668Ch */ case    3:  		/* stw R11, <#[R1 + 104]> */
		/* 8206668Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 8206668Ch case    3:*/		return 0x82066690;
	}
	return 0x82066690;
} // Block from 82066680h-82066690h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82066690h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066690( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066690) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066690);
		  /* 82066690h */ case    0:  		/* addic. R18, R18, -1 */
		/* 82066690h case    0:*/		cpu::op::addic<1>(regs,&regs.R18,regs.R18,0xFFFFFFFF);
		/* 82066690h case    0:*/		return 0x82066694;
		  /* 82066694h */ case    1:  		/* bc 4, CR0_LT, -212 */
		/* 82066694h case    1:*/		if ( !regs.CR[0].lt ) { return 0x820665C0;  }
		/* 82066694h case    1:*/		return 0x82066698;
		  /* 82066698h */ case    2:  		/* lwz R21, <#[R1 + 340]> */
		/* 82066698h case    2:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R1 + 0x00000154) );
		/* 82066698h case    2:*/		return 0x8206669C;
		  /* 8206669Ch */ case    3:  		/* lwz R20, <#[R1 + 348]> */
		/* 8206669Ch case    3:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R1 + 0x0000015C) );
		/* 8206669Ch case    3:*/		return 0x820666A0;
		  /* 820666A0h */ case    4:  		/* b 96 */
		/* 820666A0h case    4:*/		return 0x82066700;
		/* 820666A0h case    4:*/		return 0x820666A4;
	}
	return 0x820666A4;
} // Block from 82066690h-820666A4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820666A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820666A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820666A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820666A4);
		  /* 820666A4h */ case    0:  		/* addi R8, R1, 124 */
		/* 820666A4h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x7C);
		/* 820666A4h case    0:*/		return 0x820666A8;
		  /* 820666A8h */ case    1:  		/* lwz R17, <#[R1 + 100]> */
		/* 820666A8h case    1:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R1 + 0x00000064) );
		/* 820666A8h case    1:*/		return 0x820666AC;
		  /* 820666ACh */ case    2:  		/* addi R11, R1, 128 */
		/* 820666ACh case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x80);
		/* 820666ACh case    2:*/		return 0x820666B0;
		  /* 820666B0h */ case    3:  		/* stw R8, <#[R1 + 84]> */
		/* 820666B0h case    3:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000054) );
		/* 820666B0h case    3:*/		return 0x820666B4;
		  /* 820666B4h */ case    4:  		/* addi R10, R1, 112 */
		/* 820666B4h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x70);
		/* 820666B4h case    4:*/		return 0x820666B8;
		  /* 820666B8h */ case    5:  		/* mr R9, R21 */
		/* 820666B8h case    5:*/		regs.R9 = regs.R21;
		/* 820666B8h case    5:*/		return 0x820666BC;
		  /* 820666BCh */ case    6:  		/* stw R11, <#[R1 + 92]> */
		/* 820666BCh case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 820666BCh case    6:*/		return 0x820666C0;
		  /* 820666C0h */ case    7:  		/* mullw R8, R30, R17 */
		/* 820666C0h case    7:*/		cpu::op::mullw<0>(regs,&regs.R8,regs.R30,regs.R17);
		/* 820666C0h case    7:*/		return 0x820666C4;
		  /* 820666C4h */ case    8:  		/* mr R7, R30 */
		/* 820666C4h case    8:*/		regs.R7 = regs.R30;
		/* 820666C4h case    8:*/		return 0x820666C8;
		  /* 820666C8h */ case    9:  		/* mr R6, R27 */
		/* 820666C8h case    9:*/		regs.R6 = regs.R27;
		/* 820666C8h case    9:*/		return 0x820666CC;
		  /* 820666CCh */ case   10:  		/* mr R5, R28 */
		/* 820666CCh case   10:*/		regs.R5 = regs.R28;
		/* 820666CCh case   10:*/		return 0x820666D0;
		  /* 820666D0h */ case   11:  		/* mr R4, R29 */
		/* 820666D0h case   11:*/		regs.R4 = regs.R29;
		/* 820666D0h case   11:*/		return 0x820666D4;
		  /* 820666D4h */ case   12:  		/* mr R3, R18 */
		/* 820666D4h case   12:*/		regs.R3 = regs.R18;
		/* 820666D4h case   12:*/		return 0x820666D8;
		  /* 820666D8h */ case   13:  		/* bl -2640 */
		/* 820666D8h case   13:*/		regs.LR = 0x820666DC; return 0x82065C88;
		/* 820666D8h case   13:*/		return 0x820666DC;
		  /* 820666DCh */ case   14:  		/* lwz R11, <#[R1 + 104]> */
		/* 820666DCh case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 820666DCh case   14:*/		return 0x820666E0;
		  /* 820666E0h */ case   15:  		/* lwz R15, <#[R1 + 96]> */
		/* 820666E0h case   15:*/		cpu::mem::load32z( regs, &regs.R15, (uint32)(regs.R1 + 0x00000060) );
		/* 820666E0h case   15:*/		return 0x820666E4;
		  /* 820666E4h */ case   16:  		/* add R11, R11, R3 */
		/* 820666E4h case   16:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 820666E4h case   16:*/		return 0x820666E8;
		  /* 820666E8h */ case   17:  		/* lwz R21, <#[R1 + 340]> */
		/* 820666E8h case   17:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R1 + 0x00000154) );
		/* 820666E8h case   17:*/		return 0x820666EC;
		  /* 820666ECh */ case   18:  		/* lwz R20, <#[R1 + 348]> */
		/* 820666ECh case   18:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R1 + 0x0000015C) );
		/* 820666ECh case   18:*/		return 0x820666F0;
		  /* 820666F0h */ case   19:  		/* stw R3, <#[R1 + 124]> */
		/* 820666F0h case   19:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x0000007C) );
		/* 820666F0h case   19:*/		return 0x820666F4;
		  /* 820666F4h */ case   20:  		/* stw R11, <#[R1 + 104]> */
		/* 820666F4h case   20:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 820666F4h case   20:*/		return 0x820666F8;
		  /* 820666F8h */ case   21:  		/* b 8 */
		/* 820666F8h case   21:*/		return 0x82066700;
		/* 820666F8h case   21:*/		return 0x820666FC;
	}
	return 0x820666FC;
} // Block from 820666A4h-820666FCh (22 instructions)

//////////////////////////////////////////////////////
// Block at 820666FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820666FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820666FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820666FC);
		  /* 820666FCh */ case    0:  		/* lwz R30, <#[R1 + 128]> */
		/* 820666FCh case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000080) );
		/* 820666FCh case    0:*/		return 0x82066700;
	}
	return 0x82066700;
} // Block from 820666FCh-82066700h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82066700h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066700( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066700) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066700);
		  /* 82066700h */ case    0:  		/* mullw R11, R30, R17 */
		/* 82066700h case    0:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R30,regs.R17);
		/* 82066700h case    0:*/		return 0x82066704;
		  /* 82066704h */ case    1:  		/* lwz R9, <#[R1 + 316]> */
		/* 82066704h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x0000013C) );
		/* 82066704h case    1:*/		return 0x82066708;
		  /* 82066708h */ case    2:  		/* lwz R8, <#[R1 + 388]> */
		/* 82066708h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000184) );
		/* 82066708h case    2:*/		return 0x8206670C;
		  /* 8206670Ch */ case    3:  		/* lwz R7, <#[R1 + 104]> */
		/* 8206670Ch case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000068) );
		/* 8206670Ch case    3:*/		return 0x82066710;
		  /* 82066710h */ case    4:  		/* lwz R6, <#[R1 + 332]> */
		/* 82066710h case    4:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x0000014C) );
		/* 82066710h case    4:*/		return 0x82066714;
		  /* 82066714h */ case    5:  		/* addi R10, R11, 4095 */
		/* 82066714h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xFFF);
		/* 82066714h case    5:*/		return 0x82066718;
		  /* 82066718h */ case    6:  		/* rlwinm R10, R10, 0, 0, 19 */
		/* 82066718h case    6:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R10,regs.R10);
		/* 82066718h case    6:*/		return 0x8206671C;
		  /* 8206671Ch */ case    7:  		/* mullw R9, R10, R9 */
		/* 8206671Ch case    7:*/		cpu::op::mullw<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 8206671Ch case    7:*/		return 0x82066720;
		  /* 82066720h */ case    8:  		/* add R9, R9, R7 */
		/* 82066720h case    8:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 82066720h case    8:*/		return 0x82066724;
		  /* 82066724h */ case    9:  		/* stw R9, <#[R8]> */
		/* 82066724h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R8 + 0x00000000) );
		/* 82066724h case    9:*/		return 0x82066728;
		  /* 82066728h */ case   10:  		/* stw R30, <#[R6]> */
		/* 82066728h case   10:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R6 + 0x00000000) );
		/* 82066728h case   10:*/		return 0x8206672C;
		  /* 8206672Ch */ case   11:  		/* lwz R9, <#[R31 + 48]> */
		/* 8206672Ch case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000030) );
		/* 8206672Ch case   11:*/		return 0x82066730;
		  /* 82066730h */ case   12:  		/* rlwinm R9, R9, 0, 21, 22 */
		/* 82066730h case   12:*/		cpu::op::rlwinm<0,0,21,22>(regs,&regs.R9,regs.R9);
		/* 82066730h case   12:*/		return 0x82066734;
		  /* 82066734h */ case   13:  		/* cmplwi CR6, R9, 1024 */
		/* 82066734h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000400);
		/* 82066734h case   13:*/		return 0x82066738;
		  /* 82066738h */ case   14:  		/* bc 12, CR6_EQ, 16 */
		/* 82066738h case   14:*/		if ( regs.CR[6].eq ) { return 0x82066748;  }
		/* 82066738h case   14:*/		return 0x8206673C;
		  /* 8206673Ch */ case   15:  		/* mullw R11, R10, R15 */
		/* 8206673Ch case   15:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R10,regs.R15);
		/* 8206673Ch case   15:*/		return 0x82066740;
		  /* 82066740h */ case   16:  		/* stw R10, <#[R21]> */
		/* 82066740h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R21 + 0x00000000) );
		/* 82066740h case   16:*/		return 0x82066744;
		  /* 82066744h */ case   17:  		/* b 20 */
		/* 82066744h case   17:*/		return 0x82066758;
		/* 82066744h case   17:*/		return 0x82066748;
	}
	return 0x82066748;
} // Block from 82066700h-82066748h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82066748h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066748( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066748) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066748);
		  /* 82066748h */ case    0:  		/* mullw R10, R11, R15 */
		/* 82066748h case    0:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R11,regs.R15);
		/* 82066748h case    0:*/		return 0x8206674C;
		  /* 8206674Ch */ case    1:  		/* stw R11, <#[R21]> */
		/* 8206674Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 8206674Ch case    1:*/		return 0x82066750;
		  /* 82066750h */ case    2:  		/* addi R11, R10, 4095 */
		/* 82066750h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0xFFF);
		/* 82066750h case    2:*/		return 0x82066754;
		  /* 82066754h */ case    3:  		/* rlwinm R11, R11, 0, 0, 19 */
		/* 82066754h case    3:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R11,regs.R11);
		/* 82066754h case    3:*/		return 0x82066758;
	}
	return 0x82066758;
} // Block from 82066748h-82066758h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82066758h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066758( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066758) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066758);
		  /* 82066758h */ case    0:  		/* stw R11, <#[R20]> */
		/* 82066758h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R20 + 0x00000000) );
		/* 82066758h case    0:*/		return 0x8206675C;
		  /* 8206675Ch */ case    1:  		/* lwz R11, <#[R1 + 116]> */
		/* 8206675Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000074) );
		/* 8206675Ch case    1:*/		return 0x82066760;
		  /* 82066760h */ case    2:  		/* lwz R10, <#[R1 + 364]> */
		/* 82066760h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000016C) );
		/* 82066760h case    2:*/		return 0x82066764;
		  /* 82066764h */ case    3:  		/* lwz R9, <#[R1 + 372]> */
		/* 82066764h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000174) );
		/* 82066764h case    3:*/		return 0x82066768;
		  /* 82066768h */ case    4:  		/* lwz R8, <#[R1 + 120]> */
		/* 82066768h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000078) );
		/* 82066768h case    4:*/		return 0x8206676C;
		  /* 8206676Ch */ case    5:  		/* lwz R7, <#[R1 + 380]> */
		/* 8206676Ch case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x0000017C) );
		/* 8206676Ch case    5:*/		return 0x82066770;
		  /* 82066770h */ case    6:  		/* lwz R6, <#[R1 + 108]> */
		/* 82066770h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x0000006C) );
		/* 82066770h case    6:*/		return 0x82066774;
		  /* 82066774h */ case    7:  		/* lwz R5, <#[R1 + 124]> */
		/* 82066774h case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x0000007C) );
		/* 82066774h case    7:*/		return 0x82066778;
		  /* 82066778h */ case    8:  		/* lwz R4, <#[R1 + 356]> */
		/* 82066778h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000164) );
		/* 82066778h case    8:*/		return 0x8206677C;
		  /* 8206677Ch */ case    9:  		/* stw R11, <#[R10]> */
		/* 8206677Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8206677Ch case    9:*/		return 0x82066780;
		  /* 82066780h */ case   10:  		/* stw R8, <#[R9]> */
		/* 82066780h case   10:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 82066780h case   10:*/		return 0x82066784;
		  /* 82066784h */ case   11:  		/* stw R6, <#[R7]> */
		/* 82066784h case   11:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R7 + 0x00000000) );
		/* 82066784h case   11:*/		return 0x82066788;
		  /* 82066788h */ case   12:  		/* stw R5, <#[R4]> */
		/* 82066788h case   12:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R4 + 0x00000000) );
		/* 82066788h case   12:*/		return 0x8206678C;
		  /* 8206678Ch */ case   13:  		/* addi R1, R1, 288 */
		/* 8206678Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x120);
		/* 8206678Ch case   13:*/		return 0x82066790;
		  /* 82066790h */ case   14:  		/* b 174816 */
		/* 82066790h case   14:*/		return 0x82091270;
		/* 82066790h case   14:*/		return 0x82066794;
		  /* 82066794h */ case   15:  		/* nop */
		/* 82066794h case   15:*/		cpu::op::nop();
		/* 82066794h case   15:*/		return 0x82066798;
	}
	return 0x82066798;
} // Block from 82066758h-82066798h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82066798h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066798( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066798) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066798);
		  /* 82066798h */ case    0:  		/* mfspr R12, LR */
		/* 82066798h case    0:*/		regs.R12 = regs.LR;
		/* 82066798h case    0:*/		return 0x8206679C;
		  /* 8206679Ch */ case    1:  		/* bl 174744 */
		/* 8206679Ch case    1:*/		regs.LR = 0x820667A0; return 0x82091234;
		/* 8206679Ch case    1:*/		return 0x820667A0;
		  /* 820667A0h */ case    2:  		/* stwu R1, <#[R1 - 256]> */
		/* 820667A0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF00) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF00);
		/* 820667A0h case    2:*/		return 0x820667A4;
		  /* 820667A4h */ case    3:  		/* lwz R20, <#[R1 + 340]> */
		/* 820667A4h case    3:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R1 + 0x00000154) );
		/* 820667A4h case    3:*/		return 0x820667A8;
		  /* 820667A8h */ case    4:  		/* mr R19, R3 */
		/* 820667A8h case    4:*/		regs.R19 = regs.R3;
		/* 820667A8h case    4:*/		return 0x820667AC;
		  /* 820667ACh */ case    5:  		/* mr R29, R4 */
		/* 820667ACh case    5:*/		regs.R29 = regs.R4;
		/* 820667ACh case    5:*/		return 0x820667B0;
		  /* 820667B0h */ case    6:  		/* rlwinm R11, R20, 1, 0, 30 */
		/* 820667B0h case    6:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R20);
		/* 820667B0h case    6:*/		return 0x820667B4;
		  /* 820667B4h */ case    7:  		/* mr R28, R5 */
		/* 820667B4h case    7:*/		regs.R28 = regs.R5;
		/* 820667B4h case    7:*/		return 0x820667B8;
		  /* 820667B8h */ case    8:  		/* mr R27, R6 */
		/* 820667B8h case    8:*/		regs.R27 = regs.R6;
		/* 820667B8h case    8:*/		return 0x820667BC;
		  /* 820667BCh */ case    9:  		/* mr R22, R7 */
		/* 820667BCh case    9:*/		regs.R22 = regs.R7;
		/* 820667BCh case    9:*/		return 0x820667C0;
		  /* 820667C0h */ case   10:  		/* mr R24, R8 */
		/* 820667C0h case   10:*/		regs.R24 = regs.R8;
		/* 820667C0h case   10:*/		return 0x820667C4;
		  /* 820667C4h */ case   11:  		/* mr R31, R9 */
		/* 820667C4h case   11:*/		regs.R31 = regs.R9;
		/* 820667C4h case   11:*/		return 0x820667C8;
		  /* 820667C8h */ case   12:  		/* mr R26, R10 */
		/* 820667C8h case   12:*/		regs.R26 = regs.R10;
		/* 820667C8h case   12:*/		return 0x820667CC;
		  /* 820667CCh */ case   13:  		/* cmpwi CR6, R3, 3 */
		/* 820667CCh case   13:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000003);
		/* 820667CCh case   13:*/		return 0x820667D0;
		  /* 820667D0h */ case   14:  		/* addi R25, R11, 1 */
		/* 820667D0h case   14:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R11,0x1);
		/* 820667D0h case   14:*/		return 0x820667D4;
		  /* 820667D4h */ case   15:  		/* bc 12, CR6_EQ, 116 */
		/* 820667D4h case   15:*/		if ( regs.CR[6].eq ) { return 0x82066848;  }
		/* 820667D4h case   15:*/		return 0x820667D8;
		  /* 820667D8h */ case   16:  		/* cmpwi CR6, R3, 17 */
		/* 820667D8h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000011);
		/* 820667D8h case   16:*/		return 0x820667DC;
		  /* 820667DCh */ case   17:  		/* bc 12, CR6_EQ, 48 */
		/* 820667DCh case   17:*/		if ( regs.CR[6].eq ) { return 0x8206680C;  }
		/* 820667DCh case   17:*/		return 0x820667E0;
		  /* 820667E0h */ case   18:  		/* cmpwi CR6, R3, 18 */
		/* 820667E0h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000012);
		/* 820667E0h case   18:*/		return 0x820667E4;
		  /* 820667E4h */ case   19:  		/* bc 12, CR6_EQ, 32 */
		/* 820667E4h case   19:*/		if ( regs.CR[6].eq ) { return 0x82066804;  }
		/* 820667E4h case   19:*/		return 0x820667E8;
		  /* 820667E8h */ case   20:  		/* cmpwi CR6, R3, 19 */
		/* 820667E8h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000013);
		/* 820667E8h case   20:*/		return 0x820667EC;
		  /* 820667ECh */ case   21:  		/* bc 12, CR6_EQ, 92 */
		/* 820667ECh case   21:*/		if ( regs.CR[6].eq ) { return 0x82066848;  }
		/* 820667ECh case   21:*/		return 0x820667F0;
		  /* 820667F0h */ case   22:  		/* cmpwi CR6, R3, 20 */
		/* 820667F0h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000014);
		/* 820667F0h case   22:*/		return 0x820667F4;
		  /* 820667F4h */ case   23:  		/* bc 4, CR6_EQ, 92 */
		/* 820667F4h case   23:*/		if ( !regs.CR[6].eq ) { return 0x82066850;  }
		/* 820667F4h case   23:*/		return 0x820667F8;
		  /* 820667F8h */ case   24:  		/* li R30, 0 */
		/* 820667F8h case   24:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 820667F8h case   24:*/		return 0x820667FC;
		  /* 820667FCh */ case   25:  		/* li R26, 0 */
		/* 820667FCh case   25:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 820667FCh case   25:*/		return 0x82066800;
		  /* 82066800h */ case   26:  		/* b 92 */
		/* 82066800h case   26:*/		return 0x8206685C;
		/* 82066800h case   26:*/		return 0x82066804;
	}
	return 0x82066804;
} // Block from 82066798h-82066804h (27 instructions)

//////////////////////////////////////////////////////
// Block at 82066804h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066804( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066804) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066804);
		  /* 82066804h */ case    0:  		/* li R30, 3 */
		/* 82066804h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x3);
		/* 82066804h case    0:*/		return 0x82066808;
		  /* 82066808h */ case    1:  		/* b 84 */
		/* 82066808h case    1:*/		return 0x8206685C;
		/* 82066808h case    1:*/		return 0x8206680C;
	}
	return 0x8206680C;
} // Block from 82066804h-8206680Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206680Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206680C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206680C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206680C);
		  /* 8206680Ch */ case    0:  		/* li R30, 2 */
		/* 8206680Ch case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x2);
		/* 8206680Ch case    0:*/		return 0x82066810;
		  /* 82066810h */ case    1:  		/* mr R5, R27 */
		/* 82066810h case    1:*/		regs.R5 = regs.R27;
		/* 82066810h case    1:*/		return 0x82066814;
		  /* 82066814h */ case    2:  		/* cmplwi CR6, R22, 0 */
		/* 82066814h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 82066814h case    2:*/		return 0x82066818;
		  /* 82066818h */ case    3:  		/* bc 4, CR6_EQ, 24 */
		/* 82066818h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82066830;  }
		/* 82066818h case    3:*/		return 0x8206681C;
		  /* 8206681Ch */ case    4:  		/* mr R6, R20 */
		/* 8206681Ch case    4:*/		regs.R6 = regs.R20;
		/* 8206681Ch case    4:*/		return 0x82066820;
	}
	return 0x82066820;
} // Block from 8206680Ch-82066820h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82066820h
// Function '?CleanupGprAllocationSetup@D3D@@YAXPAVCDevice@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066820( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066820) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066820);
		  /* 82066820h */ case    0:  		/* mr R4, R28 */
		/* 82066820h case    0:*/		regs.R4 = regs.R28;
		/* 82066820h case    0:*/		return 0x82066824;
		  /* 82066824h */ case    1:  		/* mr R3, R29 */
		/* 82066824h case    1:*/		regs.R3 = regs.R29;
		/* 82066824h case    1:*/		return 0x82066828;
		  /* 82066828h */ case    2:  		/* bl -4296 */
		/* 82066828h case    2:*/		regs.LR = 0x8206682C; return 0x82065760;
		/* 82066828h case    2:*/		return 0x8206682C;
		  /* 8206682Ch */ case    3:  		/* mr R22, R3 */
		/* 8206682Ch case    3:*/		regs.R22 = regs.R3;
		/* 8206682Ch case    3:*/		return 0x82066830;
	}
	return 0x82066830;
} // Block from 82066820h-82066830h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82066830h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066830( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066830) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066830);
		  /* 82066830h */ case    0:  		/* cmpwi CR6, R26, 2 */
		/* 82066830h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R26,0x00000002);
		/* 82066830h case    0:*/		return 0x82066834;
		  /* 82066834h */ case    1:  		/* bc 4, CR6_EQ, 48 */
		/* 82066834h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82066864;  }
		/* 82066834h case    1:*/		return 0x82066838;
		  /* 82066838h */ case    2:  		/* subfic R11, R22, 1 */
		/* 82066838h case    2:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R22,0x1);
		/* 82066838h case    2:*/		return 0x8206683C;
		  /* 8206683Ch */ case    3:  		/* subfe R11, R11, R11 */
		/* 8206683Ch case    3:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8206683Ch case    3:*/		return 0x82066840;
		  /* 82066840h */ case    4:  		/* rlwinm R23, R11, 0, 31, 31 */
		/* 82066840h case    4:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R23,regs.R11);
		/* 82066840h case    4:*/		return 0x82066844;
		  /* 82066844h */ case    5:  		/* b 36 */
		/* 82066844h case    5:*/		return 0x82066868;
		/* 82066844h case    5:*/		return 0x82066848;
	}
	return 0x82066848;
} // Block from 82066830h-82066848h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82066848h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066848( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066848) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066848);
		  /* 82066848h */ case    0:  		/* li R30, 1 */
		/* 82066848h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 82066848h case    0:*/		return 0x8206684C;
		  /* 8206684Ch */ case    1:  		/* b 8 */
		/* 8206684Ch case    1:*/		return 0x82066854;
		/* 8206684Ch case    1:*/		return 0x82066850;
	}
	return 0x82066850;
} // Block from 82066848h-82066850h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82066850h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066850( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066850) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066850);
		  /* 82066850h */ case    0:  		/* lwz R30, <#[R1 + 136]> */
		/* 82066850h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000088) );
		/* 82066850h case    0:*/		return 0x82066854;
	}
	return 0x82066854;
} // Block from 82066850h-82066854h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82066854h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066854( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066854) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066854);
		  /* 82066854h */ case    0:  		/* cmpwi CR6, R19, 17 */
		/* 82066854h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R19,0x00000011);
		/* 82066854h case    0:*/		return 0x82066858;
		  /* 82066858h */ case    1:  		/* bc 12, CR6_EQ, -72 */
		/* 82066858h case    1:*/		if ( regs.CR[6].eq ) { return 0x82066810;  }
		/* 82066858h case    1:*/		return 0x8206685C;
	}
	return 0x8206685C;
} // Block from 82066854h-8206685Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206685Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206685C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206685C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206685C);
		  /* 8206685Ch */ case    0:  		/* li R5, 1 */
		/* 8206685Ch case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8206685Ch case    0:*/		return 0x82066860;
		  /* 82066860h */ case    1:  		/* b -76 */
		/* 82066860h case    1:*/		return 0x82066814;
		/* 82066860h case    1:*/		return 0x82066864;
	}
	return 0x82066864;
} // Block from 8206685Ch-82066864h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82066864h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066864( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066864) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066864);
		  /* 82066864h */ case    0:  		/* mr R23, R26 */
		/* 82066864h case    0:*/		regs.R23 = regs.R26;
		/* 82066864h case    0:*/		return 0x82066868;
	}
	return 0x82066868;
} // Block from 82066864h-82066868h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82066868h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066868( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066868) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066868);
		  /* 82066868h */ case    0:  		/* lwz R11, <#[R1 + 356]> */
		/* 82066868h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000164) );
		/* 82066868h case    0:*/		return 0x8206686C;
		  /* 8206686Ch */ case    1:  		/* addi R10, R1, 136 */
		/* 8206686Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x88);
		/* 8206686Ch case    1:*/		return 0x82066870;
		  /* 82066870h */ case    2:  		/* lwz R21, <#[R1 + 348]> */
		/* 82066870h case    2:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R1 + 0x0000015C) );
		/* 82066870h case    2:*/		return 0x82066874;
		  /* 82066874h */ case    3:  		/* addi R9, R1, 132 */
		/* 82066874h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x84);
		/* 82066874h case    3:*/		return 0x82066878;
		  /* 82066878h */ case    4:  		/* addi R6, R1, 128 */
		/* 82066878h case    4:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x80);
		/* 82066878h case    4:*/		return 0x8206687C;
		  /* 8206687Ch */ case    5:  		/* stw R10, <#[R1 + 124]> */
		/* 8206687Ch case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x0000007C) );
		/* 8206687Ch case    5:*/		return 0x82066880;
		  /* 82066880h */ case    6:  		/* rlwinm R26, R31, 0, 26, 31 */
		/* 82066880h case    6:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R26,regs.R31);
		/* 82066880h case    6:*/		return 0x82066884;
		  /* 82066884h */ case    7:  		/* stw R9, <#[R1 + 116]> */
		/* 82066884h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000074) );
		/* 82066884h case    7:*/		return 0x82066888;
		  /* 82066888h */ case    8:  		/* stw R6, <#[R1 + 108]> */
		/* 82066888h case    8:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x0000006C) );
		/* 82066888h case    8:*/		return 0x8206688C;
		  /* 8206688Ch */ case    9:  		/* mr R10, R23 */
		/* 8206688Ch case    9:*/		regs.R10 = regs.R23;
		/* 8206688Ch case    9:*/		return 0x82066890;
		  /* 82066890h */ case   10:  		/* rlwinm R9, R31, 24, 31, 31 */
		/* 82066890h case   10:*/		cpu::op::rlwinm<0,24,31,31>(regs,&regs.R9,regs.R31);
		/* 82066890h case   10:*/		return 0x82066894;
		  /* 82066894h */ case   11:  		/* stw R20, <#[R1 + 84]> */
		/* 82066894h case   11:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R1 + 0x00000054) );
		/* 82066894h case   11:*/		return 0x82066898;
		  /* 82066898h */ case   12:  		/* mr R8, R30 */
		/* 82066898h case   12:*/		regs.R8 = regs.R30;
		/* 82066898h case   12:*/		return 0x8206689C;
		  /* 8206689Ch */ case   13:  		/* stw R11, <#[R1 + 100]> */
		/* 8206689Ch case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 8206689Ch case   13:*/		return 0x820668A0;
		  /* 820668A0h */ case   14:  		/* mr R7, R26 */
		/* 820668A0h case   14:*/		regs.R7 = regs.R26;
		/* 820668A0h case   14:*/		return 0x820668A4;
		  /* 820668A4h */ case   15:  		/* stw R21, <#[R1 + 92]> */
		/* 820668A4h case   15:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R1 + 0x0000005C) );
		/* 820668A4h case   15:*/		return 0x820668A8;
		  /* 820668A8h */ case   16:  		/* mr R6, R22 */
		/* 820668A8h case   16:*/		regs.R6 = regs.R22;
		/* 820668A8h case   16:*/		return 0x820668AC;
		  /* 820668ACh */ case   17:  		/* mr R5, R27 */
		/* 820668ACh case   17:*/		regs.R5 = regs.R27;
		/* 820668ACh case   17:*/		return 0x820668B0;
		  /* 820668B0h */ case   18:  		/* mr R4, R28 */
		/* 820668B0h case   18:*/		regs.R4 = regs.R28;
		/* 820668B0h case   18:*/		return 0x820668B4;
		  /* 820668B4h */ case   19:  		/* mr R3, R29 */
		/* 820668B4h case   19:*/		regs.R3 = regs.R29;
		/* 820668B4h case   19:*/		return 0x820668B8;
		  /* 820668B8h */ case   20:  		/* bl -4016 */
		/* 820668B8h case   20:*/		regs.LR = 0x820668BC; return 0x82065908;
		/* 820668B8h case   20:*/		return 0x820668BC;
		  /* 820668BCh */ case   21:  		/* lis R10, 16 */
		/* 820668BCh case   21:*/		cpu::op::lis<0>(regs,&regs.R10,0x10);
		/* 820668BCh case   21:*/		return 0x820668C0;
		  /* 820668C0h */ case   22:  		/* rlwinm. R11, R24, 0, 29, 29 */
		/* 820668C0h case   22:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R24);
		/* 820668C0h case   22:*/		return 0x820668C4;
		  /* 820668C4h */ case   23:  		/* ori R10, R10, 3 */
		/* 820668C4h case   23:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x3);
		/* 820668C4h case   23:*/		return 0x820668C8;
		  /* 820668C8h */ case   24:  		/* bc 12, CR0_EQ, 12 */
		/* 820668C8h case   24:*/		if ( regs.CR[0].eq ) { return 0x820668D4;  }
		/* 820668C8h case   24:*/		return 0x820668CC;
		  /* 820668CCh */ case   25:  		/* lis R10, 48 */
		/* 820668CCh case   25:*/		cpu::op::lis<0>(regs,&regs.R10,0x30);
		/* 820668CCh case   25:*/		return 0x820668D0;
		  /* 820668D0h */ case   26:  		/* ori R10, R10, 3 */
		/* 820668D0h case   26:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x3);
		/* 820668D0h case   26:*/		return 0x820668D4;
	}
	return 0x820668D4;
} // Block from 82066868h-820668D4h (27 instructions)

//////////////////////////////////////////////////////
// Block at 820668D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820668D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820668D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820668D4);
		  /* 820668D4h */ case    0:  		/* rlwinm. R11, R24, 0, 22, 22 */
		/* 820668D4h case    0:*/		cpu::op::rlwinm<1,0,22,22>(regs,&regs.R11,regs.R24);
		/* 820668D4h case    0:*/		return 0x820668D8;
		  /* 820668D8h */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 820668D8h case    1:*/		if ( regs.CR[0].eq ) { return 0x820668E0;  }
		/* 820668D8h case    1:*/		return 0x820668DC;
		  /* 820668DCh */ case    2:  		/* oris R10, R10, 64 */
		/* 820668DCh case    2:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x40);
		/* 820668DCh case    2:*/		return 0x820668E0;
	}
	return 0x820668E0;
} // Block from 820668D4h-820668E0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820668E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820668E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820668E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820668E0);
		  /* 820668E0h */ case    0:  		/* lwz R11, <#[R1 + 364]> */
		/* 820668E0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000016C) );
		/* 820668E0h case    0:*/		return 0x820668E4;
		  /* 820668E4h */ case    1:  		/* lis R9, -1 */
		/* 820668E4h case    1:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFFFFFF);
		/* 820668E4h case    1:*/		return 0x820668E8;
		  /* 820668E8h */ case    2:  		/* li R8, 1 */
		/* 820668E8h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820668E8h case    2:*/		return 0x820668EC;
		  /* 820668ECh */ case    3:  		/* li R7, 0 */
		/* 820668ECh case    3:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820668ECh case    3:*/		return 0x820668F0;
		  /* 820668F0h */ case    4:  		/* cmplwi CR6, R30, 1 */
		/* 820668F0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000001);
		/* 820668F0h case    4:*/		return 0x820668F4;
		  /* 820668F4h */ case    5:  		/* stw R10, <#[R11]> */
		/* 820668F4h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 820668F4h case    5:*/		return 0x820668F8;
		  /* 820668F8h */ case    6:  		/* lwz R10, <#[R11 + 48]> */
		/* 820668F8h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 820668F8h case    6:*/		return 0x820668FC;
		  /* 820668FCh */ case    7:  		/* stw R8, <#[R11 + 4]> */
		/* 820668FCh case    7:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 820668FCh case    7:*/		return 0x82066900;
		  /* 82066900h */ case    8:  		/* rlwimi R10, R30, 9, 21, 22 */
		/* 82066900h case    8:*/		cpu::op::rlwimi<0,9,21,22>(regs,&regs.R10,regs.R30);
		/* 82066900h case    8:*/		return 0x82066904;
		  /* 82066904h */ case    9:  		/* stw R9, <#[R11 + 20]> */
		/* 82066904h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000014) );
		/* 82066904h case    9:*/		return 0x82066908;
		  /* 82066908h */ case   10:  		/* stw R9, <#[R11 + 24]> */
		/* 82066908h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000018) );
		/* 82066908h case   10:*/		return 0x8206690C;
		  /* 8206690Ch */ case   11:  		/* stw R7, <#[R11 + 8]> */
		/* 8206690Ch case   11:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000008) );
		/* 8206690Ch case   11:*/		return 0x82066910;
		  /* 82066910h */ case   12:  		/* stw R10, <#[R11 + 48]> */
		/* 82066910h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 82066910h case   12:*/		return 0x82066914;
		  /* 82066914h */ case   13:  		/* bc 12, CR6_LT, 148 */
		/* 82066914h case   13:*/		if ( regs.CR[6].lt ) { return 0x820669A8;  }
		/* 82066914h case   13:*/		return 0x82066918;
		  /* 82066918h */ case   14:  		/* bc 12, CR6_EQ, 88 */
		/* 82066918h case   14:*/		if ( regs.CR[6].eq ) { return 0x82066970;  }
		/* 82066918h case   14:*/		return 0x8206691C;
		  /* 8206691Ch */ case   15:  		/* cmplwi CR6, R30, 3 */
		/* 8206691Ch case   15:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000003);
		/* 8206691Ch case   15:*/		return 0x82066920;
		  /* 82066920h */ case   16:  		/* bc 12, CR6_LT, 32 */
		/* 82066920h case   16:*/		if ( regs.CR[6].lt ) { return 0x82066940;  }
		/* 82066920h case   16:*/		return 0x82066924;
		  /* 82066924h */ case   17:  		/* bc 4, CR6_EQ, 148 */
		/* 82066924h case   17:*/		if ( !regs.CR[6].eq ) { return 0x820669B8;  }
		/* 82066924h case   17:*/		return 0x82066928;
		  /* 82066928h */ case   18:  		/* subf R9, R25, R28 */
		/* 82066928h case   18:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R25,regs.R28);
		/* 82066928h case   18:*/		return 0x8206692C;
		  /* 8206692Ch */ case   19:  		/* subf R8, R25, R29 */
		/* 8206692Ch case   19:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R25,regs.R29);
		/* 8206692Ch case   19:*/		return 0x82066930;
		  /* 82066930h */ case   20:  		/* addi R7, R27, -1 */
		/* 82066930h case   20:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R27,0xFFFFFFFF);
		/* 82066930h case   20:*/		return 0x82066934;
		  /* 82066934h */ case   21:  		/* rlwimi R8, R9, 13, 6, 18 */
		/* 82066934h case   21:*/		cpu::op::rlwimi<0,13,6,18>(regs,&regs.R8,regs.R9);
		/* 82066934h case   21:*/		return 0x82066938;
	}
	return 0x82066938;
} // Block from 820668E0h-82066938h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82066938h
// Function '?InitializeGprAllocation@D3D@@YAHPAVCDevice@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066938( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066938) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066938);
		  /* 82066938h */ case    0:  		/* rlwimi R8, R7, 26, 0, 5 */
		/* 82066938h case    0:*/		cpu::op::rlwimi<0,26,0,5>(regs,&regs.R8,regs.R7);
		/* 82066938h case    0:*/		return 0x8206693C;
		  /* 8206693Ch */ case    1:  		/* b 120 */
		/* 8206693Ch case    1:*/		return 0x820669B4;
		/* 8206693Ch case    1:*/		return 0x82066940;
	}
	return 0x82066940;
} // Block from 82066938h-82066940h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82066940h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066940( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066940) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066940);
		  /* 82066940h */ case    0:  		/* lwz R9, <#[R11 + 36]> */
		/* 82066940h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000024) );
		/* 82066940h case    0:*/		return 0x82066944;
		  /* 82066944h */ case    1:  		/* subf R8, R25, R29 */
		/* 82066944h case    1:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R25,regs.R29);
		/* 82066944h case    1:*/		return 0x82066948;
		  /* 82066948h */ case    2:  		/* subf R7, R25, R28 */
		/* 82066948h case    2:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R25,regs.R28);
		/* 82066948h case    2:*/		return 0x8206694C;
		  /* 8206694Ch */ case    3:  		/* rlwimi R8, R9, 0, 0, 20 */
		/* 8206694Ch case    3:*/		cpu::op::rlwimi<0,0,0,20>(regs,&regs.R8,regs.R9);
		/* 8206694Ch case    3:*/		return 0x82066950;
		  /* 82066950h */ case    4:  		/* subf R6, R25, R27 */
		/* 82066950h case    4:*/		cpu::op::subf<0>(regs,&regs.R6,regs.R25,regs.R27);
		/* 82066950h case    4:*/		return 0x82066954;
		  /* 82066954h */ case    5:  		/* rlwinm R9, R7, 11, 10, 20 */
		/* 82066954h case    5:*/		cpu::op::rlwinm<0,11,10,20>(regs,&regs.R9,regs.R7);
		/* 82066954h case    5:*/		return 0x82066958;
		  /* 82066958h */ case    6:  		/* stw R8, <#[R11 + 36]> */
		/* 82066958h case    6:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000024) );
		/* 82066958h case    6:*/		return 0x8206695C;
		  /* 8206695Ch */ case    7:  		/* rlwinm R7, R6, 22, 0, 9 */
		/* 8206695Ch case    7:*/		cpu::op::rlwinm<0,22,0,9>(regs,&regs.R7,regs.R6);
		/* 8206695Ch case    7:*/		return 0x82066960;
		  /* 82066960h */ case    8:  		/* rlwinm R8, R8, 0, 0, 31 */
		/* 82066960h case    8:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R8,regs.R8);
		/* 82066960h case    8:*/		return 0x82066964;
		  /* 82066964h */ case    9:  		/* or R9, R9, R7 */
		/* 82066964h case    9:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 82066964h case    9:*/		return 0x82066968;
		  /* 82066968h */ case   10:  		/* rlwinm R8, R8, 0, 21, 31 */
		/* 82066968h case   10:*/		cpu::op::rlwinm<0,0,21,31>(regs,&regs.R8,regs.R8);
		/* 82066968h case   10:*/		return 0x8206696C;
		  /* 8206696Ch */ case   11:  		/* b 48 */
		/* 8206696Ch case   11:*/		return 0x8206699C;
		/* 8206696Ch case   11:*/		return 0x82066970;
	}
	return 0x82066970;
} // Block from 82066940h-82066970h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82066970h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066970( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066970) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066970);
		  /* 82066970h */ case    0:  		/* lwz R9, <#[R11 + 36]> */
		/* 82066970h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000024) );
		/* 82066970h case    0:*/		return 0x82066974;
		  /* 82066974h */ case    1:  		/* subf R8, R25, R29 */
		/* 82066974h case    1:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R25,regs.R29);
		/* 82066974h case    1:*/		return 0x82066978;
		  /* 82066978h */ case    2:  		/* subf R7, R25, R28 */
		/* 82066978h case    2:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R25,regs.R28);
		/* 82066978h case    2:*/		return 0x8206697C;
		  /* 8206697Ch */ case    3:  		/* rlwimi R8, R9, 0, 0, 18 */
		/* 8206697Ch case    3:*/		cpu::op::rlwimi<0,0,0,18>(regs,&regs.R8,regs.R9);
		/* 8206697Ch case    3:*/		return 0x82066980;
		  /* 82066980h */ case    4:  		/* addi R9, R27, -1 */
		/* 82066980h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R27,0xFFFFFFFF);
		/* 82066980h case    4:*/		return 0x82066984;
		  /* 82066984h */ case    5:  		/* stw R8, <#[R11 + 36]> */
		/* 82066984h case    5:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000024) );
		/* 82066984h case    5:*/		return 0x82066988;
		  /* 82066988h */ case    6:  		/* rlwinm R8, R7, 13, 6, 18 */
		/* 82066988h case    6:*/		cpu::op::rlwinm<0,13,6,18>(regs,&regs.R8,regs.R7);
		/* 82066988h case    6:*/		return 0x8206698C;
		  /* 8206698Ch */ case    7:  		/* rlwinm R9, R9, 26, 0, 5 */
		/* 8206698Ch case    7:*/		cpu::op::rlwinm<0,26,0,5>(regs,&regs.R9,regs.R9);
		/* 8206698Ch case    7:*/		return 0x82066990;
		  /* 82066990h */ case    8:  		/* or R9, R8, R9 */
		/* 82066990h case    8:*/		cpu::op::or<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 82066990h case    8:*/		return 0x82066994;
		  /* 82066994h */ case    9:  		/* lwz R8, <#[R11 + 36]> */
		/* 82066994h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000024) );
		/* 82066994h case    9:*/		return 0x82066998;
		  /* 82066998h */ case   10:  		/* rlwinm R8, R8, 0, 19, 31 */
		/* 82066998h case   10:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R8,regs.R8);
		/* 82066998h case   10:*/		return 0x8206699C;
	}
	return 0x8206699C;
} // Block from 82066970h-8206699Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8206699Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206699C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206699C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206699C);
		  /* 8206699Ch */ case    0:  		/* or R9, R9, R8 */
		/* 8206699Ch case    0:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 8206699Ch case    0:*/		return 0x820669A0;
		  /* 820669A0h */ case    1:  		/* stw R9, <#[R11 + 36]> */
		/* 820669A0h case    1:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000024) );
		/* 820669A0h case    1:*/		return 0x820669A4;
		  /* 820669A4h */ case    2:  		/* b 20 */
		/* 820669A4h case    2:*/		return 0x820669B8;
		/* 820669A4h case    2:*/		return 0x820669A8;
	}
	return 0x820669A8;
} // Block from 8206699Ch-820669A8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820669A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820669A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820669A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820669A8);
		  /* 820669A8h */ case    0:  		/* lwz R9, <#[R11 + 36]> */
		/* 820669A8h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000024) );
		/* 820669A8h case    0:*/		return 0x820669AC;
		  /* 820669ACh */ case    1:  		/* subf R8, R25, R29 */
		/* 820669ACh case    1:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R25,regs.R29);
		/* 820669ACh case    1:*/		return 0x820669B0;
		  /* 820669B0h */ case    2:  		/* rlwimi R8, R9, 0, 0, 7 */
		/* 820669B0h case    2:*/		cpu::op::rlwimi<0,0,0,7>(regs,&regs.R8,regs.R9);
		/* 820669B0h case    2:*/		return 0x820669B4;
	}
	return 0x820669B4;
} // Block from 820669A8h-820669B4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820669B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820669B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820669B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820669B4);
		  /* 820669B4h */ case    0:  		/* stw R8, <#[R11 + 36]> */
		/* 820669B4h case    0:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000024) );
		/* 820669B4h case    0:*/		return 0x820669B8;
	}
	return 0x820669B8;
} // Block from 820669B4h-820669B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820669B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820669B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820669B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820669B8);
		  /* 820669B8h */ case    0:  		/* srawi R9, R31, 15 */
		/* 820669B8h case    0:*/		cpu::op::srawi<0,15>(regs,&regs.R9,regs.R31);
		/* 820669B8h case    0:*/		return 0x820669BC;
		  /* 820669BCh */ case    1:  		/* lwz R8, <#[R1 + 128]> */
		/* 820669BCh case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000080) );
		/* 820669BCh case    1:*/		return 0x820669C0;
		  /* 820669C0h */ case    2:  		/* srawi R7, R31, 13 */
		/* 820669C0h case    2:*/		cpu::op::srawi<0,13>(regs,&regs.R7,regs.R31);
		/* 820669C0h case    2:*/		return 0x820669C4;
		  /* 820669C4h */ case    3:  		/* lwz R6, <#[R11 + 28]> */
		/* 820669C4h case    3:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x0000001C) );
		/* 820669C4h case    3:*/		return 0x820669C8;
		  /* 820669C8h */ case    4:  		/* srawi R5, R31, 11 */
		/* 820669C8h case    4:*/		cpu::op::srawi<0,11>(regs,&regs.R5,regs.R31);
		/* 820669C8h case    4:*/		return 0x820669CC;
		  /* 820669CCh */ case    5:  		/* lwz R4, <#[R11 + 32]> */
		/* 820669CCh case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000020) );
		/* 820669CCh case    5:*/		return 0x820669D0;
		  /* 820669D0h */ case    6:  		/* srawi R3, R31, 9 */
		/* 820669D0h case    6:*/		cpu::op::srawi<0,9>(regs,&regs.R3,regs.R31);
		/* 820669D0h case    6:*/		return 0x820669D4;
		  /* 820669D4h */ case    7:  		/* lwz R30, <#[R11 + 40]> */
		/* 820669D4h case    7:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000028) );
		/* 820669D4h case    7:*/		return 0x820669D8;
		  /* 820669D8h */ case    8:  		/* rlwimi R7, R9, 2, 28, 29 */
		/* 820669D8h case    8:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R7,regs.R9);
		/* 820669D8h case    8:*/		return 0x820669DC;
		  /* 820669DCh */ case    9:  		/* lwz R28, <#[R11 + 44]> */
		/* 820669DCh case    9:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x0000002C) );
		/* 820669DCh case    9:*/		return 0x820669E0;
		  /* 820669E0h */ case   10:  		/* srawi R29, R31, 8 */
		/* 820669E0h case   10:*/		cpu::op::srawi<0,8>(regs,&regs.R29,regs.R31);
		/* 820669E0h case   10:*/		return 0x820669E4;
		  /* 820669E4h */ case   11:  		/* lwz R9, <#[R1 + 372]> */
		/* 820669E4h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000174) );
		/* 820669E4h case   11:*/		return 0x820669E8;
		  /* 820669E8h */ case   12:  		/* addi R27, R19, -19 */
		/* 820669E8h case   12:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R19,0xFFFFFFED);
		/* 820669E8h case   12:*/		return 0x820669EC;
		  /* 820669ECh */ case   13:  		/* lwz R25, <#[R1 + 132]> */
		/* 820669ECh case   13:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x00000084) );
		/* 820669ECh case   13:*/		return 0x820669F0;
		  /* 820669F0h */ case   14:  		/* rlwimi R8, R29, 14, 0, 17 */
		/* 820669F0h case   14:*/		cpu::op::rlwimi<0,14,0,17>(regs,&regs.R8,regs.R29);
		/* 820669F0h case   14:*/		return 0x820669F4;
		  /* 820669F4h */ case   15:  		/* lwz R24, <#[R1 + 380]> */
		/* 820669F4h case   15:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R1 + 0x0000017C) );
		/* 820669F4h case   15:*/		return 0x820669F8;
		  /* 820669F8h */ case   16:  		/* rlwinm R7, R7, 0, 28, 31 */
		/* 820669F8h case   16:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R7,regs.R7);
		/* 820669F8h case   16:*/		return 0x820669FC;
		  /* 820669FCh */ case   17:  		/* lwz R29, <#[R1 + 136]> */
		/* 820669FCh case   17:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000088) );
		/* 820669FCh case   17:*/		return 0x82066A00;
		  /* 82066A00h */ case   18:  		/* cntlzw R27, R27 */
		/* 82066A00h case   18:*/		cpu::op::cntlzw<0>(regs,&regs.R27,regs.R27);
		/* 82066A00h case   18:*/		return 0x82066A04;
		  /* 82066A04h */ case   19:  		/* rlwimi R5, R7, 2, 0, 29 */
		/* 82066A04h case   19:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R5,regs.R7);
		/* 82066A04h case   19:*/		return 0x82066A08;
		  /* 82066A08h */ case   20:  		/* rlwimi R6, R8, 17, 0, 9 */
		/* 82066A08h case   20:*/		cpu::op::rlwimi<0,17,0,9>(regs,&regs.R6,regs.R8);
		/* 82066A08h case   20:*/		return 0x82066A0C;
		  /* 82066A0Ch */ case   21:  		/* srawi R19, R31, 6 */
		/* 82066A0Ch case   21:*/		cpu::op::srawi<0,6>(regs,&regs.R19,regs.R31);
		/* 82066A0Ch case   21:*/		return 0x82066A10;
		  /* 82066A10h */ case   22:  		/* rlwinm R8, R27, 27, 31, 31 */
		/* 82066A10h case   22:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R8,regs.R27);
		/* 82066A10h case   22:*/		return 0x82066A14;
		  /* 82066A14h */ case   23:  		/* rlwimi R3, R5, 2, 0, 29 */
		/* 82066A14h case   23:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R3,regs.R5);
		/* 82066A14h case   23:*/		return 0x82066A18;
		  /* 82066A18h */ case   24:  		/* mr R7, R6 */
		/* 82066A18h case   24:*/		regs.R7 = regs.R6;
		/* 82066A18h case   24:*/		return 0x82066A1C;
		  /* 82066A1Ch */ case   25:  		/* rlwimi R19, R8, 4, 27, 27 */
		/* 82066A1Ch case   25:*/		cpu::op::rlwimi<0,4,27,27>(regs,&regs.R19,regs.R8);
		/* 82066A1Ch case   25:*/		return 0x82066A20;
		  /* 82066A20h */ case   26:  		/* rlwinm R8, R4, 0, 0, 25 */
		/* 82066A20h case   26:*/		cpu::op::rlwinm<0,0,0,25>(regs,&regs.R8,regs.R4);
		/* 82066A20h case   26:*/		return 0x82066A24;
		  /* 82066A24h */ case   27:  		/* rlwinm R5, R20, 18, 0, 13 */
		/* 82066A24h case   27:*/		cpu::op::rlwinm<0,18,0,13>(regs,&regs.R5,regs.R20);
		/* 82066A24h case   27:*/		return 0x82066A28;
		  /* 82066A28h */ case   28:  		/* rlwinm R6, R21, 0, 26, 31 */
		/* 82066A28h case   28:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R6,regs.R21);
		/* 82066A28h case   28:*/		return 0x82066A2C;
		  /* 82066A2Ch */ case   29:  		/* rlwinm R7, R7, 0, 0, 21 */
		/* 82066A2Ch case   29:*/		cpu::op::rlwinm<0,0,0,21>(regs,&regs.R7,regs.R7);
		/* 82066A2Ch case   29:*/		return 0x82066A30;
		  /* 82066A30h */ case   30:  		/* rlwinm R4, R3, 2, 0, 29 */
		/* 82066A30h case   30:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R3);
		/* 82066A30h case   30:*/		return 0x82066A34;
		  /* 82066A34h */ case   31:  		/* or R6, R6, R5 */
		/* 82066A34h case   31:*/		cpu::op::or<0>(regs,&regs.R6,regs.R6,regs.R5);
		/* 82066A34h case   31:*/		return 0x82066A38;
		  /* 82066A38h */ case   32:  		/* or R7, R4, R7 */
		/* 82066A38h case   32:*/		cpu::op::or<0>(regs,&regs.R7,regs.R4,regs.R7);
		/* 82066A38h case   32:*/		return 0x82066A3C;
		  /* 82066A3Ch */ case   33:  		/* srawi R5, R31, 17 */
		/* 82066A3Ch case   33:*/		cpu::op::srawi<0,17>(regs,&regs.R5,regs.R31);
		/* 82066A3Ch case   33:*/		return 0x82066A40;
		  /* 82066A40h */ case   34:  		/* or R8, R8, R26 */
		/* 82066A40h case   34:*/		cpu::op::or<0>(regs,&regs.R8,regs.R8,regs.R26);
		/* 82066A40h case   34:*/		return 0x82066A44;
		  /* 82066A44h */ case   35:  		/* rlwimi R5, R6, 13, 0, 18 */
		/* 82066A44h case   35:*/		cpu::op::rlwimi<0,13,0,18>(regs,&regs.R5,regs.R6);
		/* 82066A44h case   35:*/		return 0x82066A48;
		  /* 82066A48h */ case   36:  		/* ori R7, R7, 2 */
		/* 82066A48h case   36:*/		cpu::op::ori<0>(regs,&regs.R7,regs.R7,0x2);
		/* 82066A48h case   36:*/		return 0x82066A4C;
		  /* 82066A4Ch */ case   37:  		/* addi R4, R22, -1 */
		/* 82066A4Ch case   37:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R22,0xFFFFFFFF);
		/* 82066A4Ch case   37:*/		return 0x82066A50;
		  /* 82066A50h */ case   38:  		/* rlwimi R8, R19, 6, 24, 25 */
		/* 82066A50h case   38:*/		cpu::op::rlwimi<0,6,24,25>(regs,&regs.R8,regs.R19);
		/* 82066A50h case   38:*/		return 0x82066A54;
		  /* 82066A54h */ case   39:  		/* stw R7, <#[R11 + 28]> */
		/* 82066A54h case   39:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x0000001C) );
		/* 82066A54h case   39:*/		return 0x82066A58;
		  /* 82066A58h */ case   40:  		/* rlwinm R6, R30, 0, 1, 12 */
		/* 82066A58h case   40:*/		cpu::op::rlwinm<0,0,1,12>(regs,&regs.R6,regs.R30);
		/* 82066A58h case   40:*/		return 0x82066A5C;
		  /* 82066A5Ch */ case   41:  		/* rlwimi R28, R4, 6, 22, 25 */
		/* 82066A5Ch case   41:*/		cpu::op::rlwimi<0,6,22,25>(regs,&regs.R28,regs.R4);
		/* 82066A5Ch case   41:*/		return 0x82066A60;
		  /* 82066A60h */ case   42:  		/* rlwimi R8, R19, 6, 21, 21 */
		/* 82066A60h case   42:*/		cpu::op::rlwimi<0,6,21,21>(regs,&regs.R8,regs.R19);
		/* 82066A60h case   42:*/		return 0x82066A64;
		  /* 82066A64h */ case   43:  		/* rlwimi R10, R23, 11, 20, 20 */
		/* 82066A64h case   43:*/		cpu::op::rlwimi<0,11,20,20>(regs,&regs.R10,regs.R23);
		/* 82066A64h case   43:*/		return 0x82066A68;
		  /* 82066A68h */ case   44:  		/* stw R28, <#[R11 + 44]> */
		/* 82066A68h case   44:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x0000002C) );
		/* 82066A68h case   44:*/		return 0x82066A6C;
		  /* 82066A6Ch */ case   45:  		/* or R7, R5, R6 */
		/* 82066A6Ch case   45:*/		cpu::op::or<0>(regs,&regs.R7,regs.R5,regs.R6);
		/* 82066A6Ch case   45:*/		return 0x82066A70;
		  /* 82066A70h */ case   46:  		/* stw R8, <#[R11 + 32]> */
		/* 82066A70h case   46:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000020) );
		/* 82066A70h case   46:*/		return 0x82066A74;
		  /* 82066A74h */ case   47:  		/* stw R10, <#[R11 + 48]> */
		/* 82066A74h case   47:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 82066A74h case   47:*/		return 0x82066A78;
		  /* 82066A78h */ case   48:  		/* stw R7, <#[R11 + 40]> */
		/* 82066A78h case   48:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000028) );
		/* 82066A78h case   48:*/		return 0x82066A7C;
		  /* 82066A7Ch */ case   49:  		/* stw R25, <#[R9]> */
		/* 82066A7Ch case   49:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R9 + 0x00000000) );
		/* 82066A7Ch case   49:*/		return 0x82066A80;
		  /* 82066A80h */ case   50:  		/* stw R29, <#[R24]> */
		/* 82066A80h case   50:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R24 + 0x00000000) );
		/* 82066A80h case   50:*/		return 0x82066A84;
		  /* 82066A84h */ case   51:  		/* addi R1, R1, 256 */
		/* 82066A84h case   51:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x100);
		/* 82066A84h case   51:*/		return 0x82066A88;
		  /* 82066A88h */ case   52:  		/* b 174076 */
		/* 82066A88h case   52:*/		return 0x82091284;
		/* 82066A88h case   52:*/		return 0x82066A8C;
		  /* 82066A8Ch */ case   53:  		/* nop */
		/* 82066A8Ch case   53:*/		cpu::op::nop();
		/* 82066A8Ch case   53:*/		return 0x82066A90;
	}
	return 0x82066A90;
} // Block from 820669B8h-82066A90h (54 instructions)

//////////////////////////////////////////////////////
// Block at 82066A90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066A90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066A90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066A90);
		  /* 82066A90h */ case    0:  		/* mfspr R12, LR */
		/* 82066A90h case    0:*/		regs.R12 = regs.LR;
		/* 82066A90h case    0:*/		return 0x82066A94;
		  /* 82066A94h */ case    1:  		/* bl 173988 */
		/* 82066A94h case    1:*/		regs.LR = 0x82066A98; return 0x82091238;
		/* 82066A94h case    1:*/		return 0x82066A98;
		  /* 82066A98h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 82066A98h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 82066A98h case    2:*/		return 0x82066A9C;
		  /* 82066A9Ch */ case    3:  		/* rlwinm R25, R5, 0, 26, 31 */
		/* 82066A9Ch case    3:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R25,regs.R5);
		/* 82066A9Ch case    3:*/		return 0x82066AA0;
		  /* 82066AA0h */ case    4:  		/* mr R30, R3 */
		/* 82066AA0h case    4:*/		regs.R30 = regs.R3;
		/* 82066AA0h case    4:*/		return 0x82066AA4;
		  /* 82066AA4h */ case    5:  		/* mr R27, R4 */
		/* 82066AA4h case    5:*/		regs.R27 = regs.R4;
		/* 82066AA4h case    5:*/		return 0x82066AA8;
		  /* 82066AA8h */ case    6:  		/* mr R28, R5 */
		/* 82066AA8h case    6:*/		regs.R28 = regs.R5;
		/* 82066AA8h case    6:*/		return 0x82066AAC;
		  /* 82066AACh */ case    7:  		/* mr R29, R6 */
		/* 82066AACh case    7:*/		regs.R29 = regs.R6;
		/* 82066AACh case    7:*/		return 0x82066AB0;
		  /* 82066AB0h */ case    8:  		/* mr R23, R7 */
		/* 82066AB0h case    8:*/		regs.R23 = regs.R7;
		/* 82066AB0h case    8:*/		return 0x82066AB4;
		  /* 82066AB4h */ case    9:  		/* mr R31, R8 */
		/* 82066AB4h case    9:*/		regs.R31 = regs.R8;
		/* 82066AB4h case    9:*/		return 0x82066AB8;
		  /* 82066AB8h */ case   10:  		/* mr R21, R9 */
		/* 82066AB8h case   10:*/		regs.R21 = regs.R9;
		/* 82066AB8h case   10:*/		return 0x82066ABC;
		  /* 82066ABCh */ case   11:  		/* mr R20, R10 */
		/* 82066ABCh case   11:*/		regs.R20 = regs.R10;
		/* 82066ABCh case   11:*/		return 0x82066AC0;
		  /* 82066AC0h */ case   12:  		/* li R22, 1 */
		/* 82066AC0h case   12:*/		cpu::op::li<0>(regs,&regs.R22,0x1);
		/* 82066AC0h case   12:*/		return 0x82066AC4;
		  /* 82066AC4h */ case   13:  		/* cmplwi CR6, R25, 22 */
		/* 82066AC4h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000016);
		/* 82066AC4h case   13:*/		return 0x82066AC8;
	}
	return 0x82066AC8;
} // Block from 82066A90h-82066AC8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82066AC8h
// Function 'D3DDevice_SetVertexShaderConstantFN'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066AC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066AC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066AC8);
		  /* 82066AC8h */ case    0:  		/* bc 12, CR6_EQ, 16 */
		/* 82066AC8h case    0:*/		if ( regs.CR[6].eq ) { return 0x82066AD8;  }
		/* 82066AC8h case    0:*/		return 0x82066ACC;
		  /* 82066ACCh */ case    1:  		/* cmplwi CR6, R25, 23 */
		/* 82066ACCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000017);
		/* 82066ACCh case    1:*/		return 0x82066AD0;
		  /* 82066AD0h */ case    2:  		/* li R26, 0 */
		/* 82066AD0h case    2:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82066AD0h case    2:*/		return 0x82066AD4;
		  /* 82066AD4h */ case    3:  		/* bc 4, CR6_EQ, 8 */
		/* 82066AD4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82066ADC;  }
		/* 82066AD4h case    3:*/		return 0x82066AD8;
	}
	return 0x82066AD8;
} // Block from 82066AC8h-82066AD8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82066AD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066AD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066AD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066AD8);
		  /* 82066AD8h */ case    0:  		/* mr R26, R22 */
		/* 82066AD8h case    0:*/		regs.R26 = regs.R22;
		/* 82066AD8h case    0:*/		return 0x82066ADC;
	}
	return 0x82066ADC;
} // Block from 82066AD8h-82066ADCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82066ADCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066ADC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066ADC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066ADC);
		  /* 82066ADCh */ case    0:  		/* cmplwi CR6, R25, 54 */
		/* 82066ADCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000036);
		/* 82066ADCh case    0:*/		return 0x82066AE0;
		  /* 82066AE0h */ case    1:  		/* bc 4, CR6_EQ, 8 */
		/* 82066AE0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82066AE8;  }
		/* 82066AE0h case    1:*/		return 0x82066AE4;
		  /* 82066AE4h */ case    2:  		/* li R25, 7 */
		/* 82066AE4h case    2:*/		cpu::op::li<0>(regs,&regs.R25,0x7);
		/* 82066AE4h case    2:*/		return 0x82066AE8;
	}
	return 0x82066AE8;
} // Block from 82066ADCh-82066AE8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82066AE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066AE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066AE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066AE8);
		  /* 82066AE8h */ case    0:  		/* li R11, 4 */
		/* 82066AE8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x4);
		/* 82066AE8h case    0:*/		return 0x82066AEC;
		  /* 82066AECh */ case    1:  		/* stw R22, <#[R31 + 4]> */
		/* 82066AECh case    1:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R31 + 0x00000004) );
		/* 82066AECh case    1:*/		return 0x82066AF0;
		  /* 82066AF0h */ case    2:  		/* lis R10, -1 */
		/* 82066AF0h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 82066AF0h case    2:*/		return 0x82066AF4;
		  /* 82066AF4h */ case    3:  		/* mr R6, R29 */
		/* 82066AF4h case    3:*/		regs.R6 = regs.R29;
		/* 82066AF4h case    3:*/		return 0x82066AF8;
		  /* 82066AF8h */ case    4:  		/* stw R11, <#[R31]> */
		/* 82066AF8h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82066AF8h case    4:*/		return 0x82066AFC;
		  /* 82066AFCh */ case    5:  		/* mr R5, R28 */
		/* 82066AFCh case    5:*/		regs.R5 = regs.R28;
		/* 82066AFCh case    5:*/		return 0x82066B00;
		  /* 82066B00h */ case    6:  		/* stw R10, <#[R31 + 20]> */
		/* 82066B00h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000014) );
		/* 82066B00h case    6:*/		return 0x82066B04;
		  /* 82066B04h */ case    7:  		/* mr R4, R27 */
		/* 82066B04h case    7:*/		regs.R4 = regs.R27;
		/* 82066B04h case    7:*/		return 0x82066B08;
		  /* 82066B08h */ case    8:  		/* mr R3, R30 */
		/* 82066B08h case    8:*/		regs.R3 = regs.R30;
		/* 82066B08h case    8:*/		return 0x82066B0C;
		  /* 82066B0Ch */ case    9:  		/* li R24, -1 */
		/* 82066B0Ch case    9:*/		cpu::op::li<0>(regs,&regs.R24,0xFFFFFFFF);
		/* 82066B0Ch case    9:*/		return 0x82066B10;
		  /* 82066B10h */ case   10:  		/* bl -5304 */
		/* 82066B10h case   10:*/		regs.LR = 0x82066B14; return 0x82065658;
		/* 82066B10h case   10:*/		return 0x82066B14;
		  /* 82066B14h */ case   11:  		/* cmpwi CR6, R26, 0 */
		/* 82066B14h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R26,0x00000000);
		/* 82066B14h case   11:*/		return 0x82066B18;
		  /* 82066B18h */ case   12:  		/* bc 12, CR6_EQ, 64 */
		/* 82066B18h case   12:*/		if ( regs.CR[6].eq ) { return 0x82066B58;  }
		/* 82066B18h case   12:*/		return 0x82066B1C;
		  /* 82066B1Ch */ case   13:  		/* mr R11, R30 */
		/* 82066B1Ch case   13:*/		regs.R11 = regs.R30;
		/* 82066B1Ch case   13:*/		return 0x82066B20;
		  /* 82066B20h */ case   14:  		/* mr R10, R27 */
		/* 82066B20h case   14:*/		regs.R10 = regs.R27;
		/* 82066B20h case   14:*/		return 0x82066B24;
		  /* 82066B24h */ case   15:  		/* cmpwi CR6, R29, 1 */
		/* 82066B24h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000001);
		/* 82066B24h case   15:*/		return 0x82066B28;
		  /* 82066B28h */ case   16:  		/* bc 12, CR6_LT, 8 */
		/* 82066B28h case   16:*/		if ( regs.CR[6].lt ) { return 0x82066B30;  }
		/* 82066B28h case   16:*/		return 0x82066B2C;
		  /* 82066B2Ch */ case   17:  		/* rlwinm R10, R27, 1, 0, 30 */
		/* 82066B2Ch case   17:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R27);
		/* 82066B2Ch case   17:*/		return 0x82066B30;
	}
	return 0x82066B30;
} // Block from 82066AE8h-82066B30h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82066B30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066B30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066B30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066B30);
		  /* 82066B30h */ case    0:  		/* cmpwi CR6, R29, 2 */
		/* 82066B30h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000002);
		/* 82066B30h case    0:*/		return 0x82066B34;
		  /* 82066B34h */ case    1:  		/* bc 4, CR6_EQ, 8 */
		/* 82066B34h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82066B3C;  }
		/* 82066B34h case    1:*/		return 0x82066B38;
		  /* 82066B38h */ case    2:  		/* rlwinm R11, R30, 1, 0, 30 */
		/* 82066B38h case    2:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R30);
		/* 82066B38h case    2:*/		return 0x82066B3C;
	}
	return 0x82066B3C;
} // Block from 82066B30h-82066B3Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82066B3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066B3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066B3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066B3C);
		  /* 82066B3Ch */ case    0:  		/* addi R11, R11, 31 */
		/* 82066B3Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1F);
		/* 82066B3Ch case    0:*/		return 0x82066B40;
		  /* 82066B40h */ case    1:  		/* addi R10, R10, 15 */
		/* 82066B40h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xF);
		/* 82066B40h case    1:*/		return 0x82066B44;
		  /* 82066B44h */ case    2:  		/* rlwinm R11, R11, 27, 5, 31 */
		/* 82066B44h case    2:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R11);
		/* 82066B44h case    2:*/		return 0x82066B48;
		  /* 82066B48h */ case    3:  		/* rlwinm R10, R10, 28, 4, 31 */
		/* 82066B48h case    3:*/		cpu::op::rlwinm<0,28,4,31>(regs,&regs.R10,regs.R10);
		/* 82066B48h case    3:*/		return 0x82066B4C;
		  /* 82066B4Ch */ case    4:  		/* mullw R11, R11, R10 */
		/* 82066B4Ch case    4:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82066B4Ch case    4:*/		return 0x82066B50;
		  /* 82066B50h */ case    5:  		/* rlwinm R7, R11, 0, 9, 31 */
		/* 82066B50h case    5:*/		cpu::op::rlwinm<0,0,9,31>(regs,&regs.R7,regs.R11);
		/* 82066B50h case    5:*/		return 0x82066B54;
		  /* 82066B54h */ case    6:  		/* b 8 */
		/* 82066B54h case    6:*/		return 0x82066B5C;
		/* 82066B54h case    6:*/		return 0x82066B58;
	}
	return 0x82066B58;
} // Block from 82066B3Ch-82066B58h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82066B58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066B58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066B58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066B58);
		  /* 82066B58h */ case    0:  		/* li R7, 0 */
		/* 82066B58h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82066B58h case    0:*/		return 0x82066B5C;
	}
	return 0x82066B5C;
} // Block from 82066B58h-82066B5Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82066B5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066B5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066B5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066B5C);
		  /* 82066B5Ch */ case    0:  		/* cmplwi CR6, R23, 0 */
		/* 82066B5Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 82066B5Ch case    0:*/		return 0x82066B60;
		  /* 82066B60h */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 82066B60h case    1:*/		if ( regs.CR[6].eq ) { return 0x82066B74;  }
		/* 82066B60h case    1:*/		return 0x82066B64;
		  /* 82066B64h */ case    2:  		/* lwz R9, <#[R23]> */
		/* 82066B64h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x00000000) );
		/* 82066B64h case    2:*/		return 0x82066B68;
		  /* 82066B68h */ case    3:  		/* lwz R24, <#[R23 + 4]> */
		/* 82066B68h case    3:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R23 + 0x00000004) );
		/* 82066B68h case    3:*/		return 0x82066B6C;
		  /* 82066B6Ch */ case    4:  		/* lwz R8, <#[R23 + 8]> */
		/* 82066B6Ch case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R23 + 0x00000008) );
		/* 82066B6Ch case    4:*/		return 0x82066B70;
		  /* 82066B70h */ case    5:  		/* b 40 */
		/* 82066B70h case    5:*/		return 0x82066B98;
		/* 82066B70h case    5:*/		return 0x82066B74;
	}
	return 0x82066B74;
} // Block from 82066B5Ch-82066B74h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82066B74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066B74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066B74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066B74);
		  /* 82066B74h */ case    0:  		/* li R9, 0 */
		/* 82066B74h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82066B74h case    0:*/		return 0x82066B78;
		  /* 82066B78h */ case    1:  		/* li R8, 0 */
		/* 82066B78h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82066B78h case    1:*/		return 0x82066B7C;
		  /* 82066B7Ch */ case    2:  		/* cmpwi CR6, R26, 0 */
		/* 82066B7Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R26,0x00000000);
		/* 82066B7Ch case    2:*/		return 0x82066B80;
		  /* 82066B80h */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 82066B80h case    3:*/		if ( regs.CR[6].eq ) { return 0x82066B98;  }
		/* 82066B80h case    3:*/		return 0x82066B84;
		  /* 82066B84h */ case    4:  		/* lis R11, -32216 */
		/* 82066B84h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 82066B84h case    4:*/		return 0x82066B88;
		  /* 82066B88h */ case    5:  		/* lwz R11, <#[R11 + 28680]> */
		/* 82066B88h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00007008) );
		/* 82066B88h case    5:*/		return 0x82066B8C;
		  /* 82066B8Ch */ case    6:  		/* subfic R11, R11, 0 */
		/* 82066B8Ch case    6:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x0);
		/* 82066B8Ch case    6:*/		return 0x82066B90;
		  /* 82066B90h */ case    7:  		/* subfe R11, R11, R11 */
		/* 82066B90h case    7:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82066B90h case    7:*/		return 0x82066B94;
		  /* 82066B94h */ case    8:  		/* and R24, R11, R24 */
		/* 82066B94h case    8:*/		cpu::op::and<0>(regs,&regs.R24,regs.R11,regs.R24);
		/* 82066B94h case    8:*/		return 0x82066B98;
	}
	return 0x82066B98;
} // Block from 82066B74h-82066B98h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82066B98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066B98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066B98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066B98);
		  /* 82066B98h */ case    0:  		/* cmpwi CR6, R29, 0 */
		/* 82066B98h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 82066B98h case    0:*/		return 0x82066B9C;
		  /* 82066B9Ch */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 82066B9Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x82066BA8;  }
		/* 82066B9Ch case    1:*/		return 0x82066BA0;
	}
	return 0x82066BA0;
} // Block from 82066B98h-82066BA0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82066BA0h
// Function 'D3DDevice_SetPixelShaderConstantFN'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066BA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066BA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066BA0);
		  /* 82066BA0h */ case    0:  		/* cmpwi CR6, R29, 1 */
		/* 82066BA0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000001);
		/* 82066BA0h case    0:*/		return 0x82066BA4;
		  /* 82066BA4h */ case    1:  		/* bc 4, CR6_EQ, 32 */
		/* 82066BA4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82066BC4;  }
		/* 82066BA4h case    1:*/		return 0x82066BA8;
	}
	return 0x82066BA8;
} // Block from 82066BA0h-82066BA8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82066BA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066BA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066BA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066BA8);
		  /* 82066BA8h */ case    0:  		/* li R10, 80 */
		/* 82066BA8h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x50);
		/* 82066BA8h case    0:*/		return 0x82066BAC;
		  /* 82066BACh */ case    1:  		/* addi R11, R30, 79 */
		/* 82066BACh case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x4F);
		/* 82066BACh case    1:*/		return 0x82066BB0;
		  /* 82066BB0h */ case    2:  		/* divwu R11, R11, R10 */
		/* 82066BB0h case    2:*/		cpu::op::divwu<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82066BB0h case    2:*/		return 0x82066BB4;
		  /* 82066BB4h */ case    3:  		/* mulli R10, R11, 80 */
		/* 82066BB4h case    3:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R11,0x50);
		/* 82066BB4h case    3:*/		return 0x82066BB8;
		  /* 82066BB8h */ case    4:  		/* addi R11, R30, 31 */
		/* 82066BB8h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x1F);
		/* 82066BB8h case    4:*/		return 0x82066BBC;
		  /* 82066BBCh */ case    5:  		/* rlwinm R11, R11, 0, 0, 26 */
		/* 82066BBCh case    5:*/		cpu::op::rlwinm<0,0,0,26>(regs,&regs.R11,regs.R11);
		/* 82066BBCh case    5:*/		return 0x82066BC0;
		  /* 82066BC0h */ case    6:  		/* b 28 */
		/* 82066BC0h case    6:*/		return 0x82066BDC;
		/* 82066BC0h case    6:*/		return 0x82066BC4;
	}
	return 0x82066BC4;
} // Block from 82066BA8h-82066BC4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82066BC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066BC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066BC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066BC4);
		  /* 82066BC4h */ case    0:  		/* li R10, 40 */
		/* 82066BC4h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x28);
		/* 82066BC4h case    0:*/		return 0x82066BC8;
		  /* 82066BC8h */ case    1:  		/* addi R11, R30, 39 */
		/* 82066BC8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x27);
		/* 82066BC8h case    1:*/		return 0x82066BCC;
		  /* 82066BCCh */ case    2:  		/* divwu R11, R11, R10 */
		/* 82066BCCh case    2:*/		cpu::op::divwu<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82066BCCh case    2:*/		return 0x82066BD0;
		  /* 82066BD0h */ case    3:  		/* mulli R10, R11, 40 */
		/* 82066BD0h case    3:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R11,0x28);
		/* 82066BD0h case    3:*/		return 0x82066BD4;
		  /* 82066BD4h */ case    4:  		/* addi R11, R30, 15 */
		/* 82066BD4h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xF);
		/* 82066BD4h case    4:*/		return 0x82066BD8;
		  /* 82066BD8h */ case    5:  		/* rlwinm R11, R11, 0, 0, 27 */
		/* 82066BD8h case    5:*/		cpu::op::rlwinm<0,0,0,27>(regs,&regs.R11,regs.R11);
		/* 82066BD8h case    5:*/		return 0x82066BDC;
	}
	return 0x82066BDC;
} // Block from 82066BC4h-82066BDCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 82066BDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066BDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066BDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066BDC);
		  /* 82066BDCh */ case    0:  		/* lwz R6, <#[R31 + 36]> */
		/* 82066BDCh case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000024) );
		/* 82066BDCh case    0:*/		return 0x82066BE0;
		  /* 82066BE0h */ case    1:  		/* addi R5, R30, -1 */
		/* 82066BE0h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R30,0xFFFFFFFF);
		/* 82066BE0h case    1:*/		return 0x82066BE4;
		  /* 82066BE4h */ case    2:  		/* rlwimi R29, R11, 2, 0, 29 */
		/* 82066BE4h case    2:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R29,regs.R11);
		/* 82066BE4h case    2:*/		return 0x82066BE8;
		  /* 82066BE8h */ case    3:  		/* stw R28, <#[R31 + 40]> */
		/* 82066BE8h case    3:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x00000028) );
		/* 82066BE8h case    3:*/		return 0x82066BEC;
		  /* 82066BECh */ case    4:  		/* rlwinm R11, R5, 18, 0, 13 */
		/* 82066BECh case    4:*/		cpu::op::rlwinm<0,18,0,13>(regs,&regs.R11,regs.R5);
		/* 82066BECh case    4:*/		return 0x82066BF0;
		  /* 82066BF0h */ case    5:  		/* rlwinm R6, R6, 0, 29, 31 */
		/* 82066BF0h case    5:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R6,regs.R6);
		/* 82066BF0h case    5:*/		return 0x82066BF4;
		  /* 82066BF4h */ case    6:  		/* lis R5, -32256 */
		/* 82066BF4h case    6:*/		cpu::op::lis<0>(regs,&regs.R5,0xFFFF8200);
		/* 82066BF4h case    6:*/		return 0x82066BF8;
		  /* 82066BF8h */ case    7:  		/* or R11, R11, R6 */
		/* 82066BF8h case    7:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R6);
		/* 82066BF8h case    7:*/		return 0x82066BFC;
		  /* 82066BFCh */ case    8:  		/* addi R6, R27, -1 */
		/* 82066BFCh case    8:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R27,0xFFFFFFFF);
		/* 82066BFCh case    8:*/		return 0x82066C00;
		  /* 82066C00h */ case    9:  		/* rlwinm R4, R29, 16, 0, 15 */
		/* 82066C00h case    9:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R4,regs.R29);
		/* 82066C00h case    9:*/		return 0x82066C04;
		  /* 82066C04h */ case   10:  		/* rlwinm R10, R10, 0, 18, 31 */
		/* 82066C04h case   10:*/		cpu::op::rlwinm<0,0,18,31>(regs,&regs.R10,regs.R10);
		/* 82066C04h case   10:*/		return 0x82066C08;
		  /* 82066C08h */ case   11:  		/* addi R5, R5, 2992 */
		/* 82066C08h case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0xBB0);
		/* 82066C08h case   11:*/		return 0x82066C0C;
		  /* 82066C0Ch */ case   12:  		/* rlwinm R30, R25, 1, 0, 30 */
		/* 82066C0Ch case   12:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R30,regs.R25);
		/* 82066C0Ch case   12:*/		return 0x82066C10;
		  /* 82066C10h */ case   13:  		/* rlwimi R11, R6, 3, 14, 28 */
		/* 82066C10h case   13:*/		cpu::op::rlwimi<0,3,14,28>(regs,&regs.R11,regs.R6);
		/* 82066C10h case   13:*/		return 0x82066C14;
		  /* 82066C14h */ case   14:  		/* or R10, R4, R10 */
		/* 82066C14h case   14:*/		cpu::op::or<0>(regs,&regs.R10,regs.R4,regs.R10);
		/* 82066C14h case   14:*/		return 0x82066C18;
		  /* 82066C18h */ case   15:  		/* stw R11, <#[R31 + 36]> */
		/* 82066C18h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 82066C18h case   15:*/		return 0x82066C1C;
		  /* 82066C1Ch */ case   16:  		/* cmpwi CR6, R26, 0 */
		/* 82066C1Ch case   16:*/		cpu::op::cmpwi<6>(regs,regs.R26,0x00000000);
		/* 82066C1Ch case   16:*/		return 0x82066C20;
		  /* 82066C20h */ case   17:  		/* stw R10, <#[R31 + 24]> */
		/* 82066C20h case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 82066C20h case   17:*/		return 0x82066C24;
		  /* 82066C24h */ case   18:  		/* lhzx R11, <#[R30 + R5]> */
		/* 82066C24h case   18:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R30 + regs.R5 + 0x00000000) );
		/* 82066C24h case   18:*/		return 0x82066C28;
		  /* 82066C28h */ case   19:  		/* rlwinm R11, R11, 24, 28, 31 */
		/* 82066C28h case   19:*/		cpu::op::rlwinm<0,24,28,31>(regs,&regs.R11,regs.R11);
		/* 82066C28h case   19:*/		return 0x82066C2C;
		  /* 82066C2Ch */ case   20:  		/* bc 12, CR6_EQ, 104 */
		/* 82066C2Ch case   20:*/		if ( regs.CR[6].eq ) { return 0x82066C94;  }
		/* 82066C2Ch case   20:*/		return 0x82066C30;
		  /* 82066C30h */ case   21:  		/* rlwinm R11, R11, 16, 15, 15 */
		/* 82066C30h case   21:*/		cpu::op::rlwinm<0,16,15,15>(regs,&regs.R11,regs.R11);
		/* 82066C30h case   21:*/		return 0x82066C34;
		  /* 82066C34h */ case   22:  		/* rlwinm R10, R9, 0, 20, 31 */
		/* 82066C34h case   22:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R10,regs.R9);
		/* 82066C34h case   22:*/		return 0x82066C38;
		  /* 82066C38h */ case   23:  		/* cmpwi CR6, R24, -1 */
		/* 82066C38h case   23:*/		cpu::op::cmpwi<6>(regs,regs.R24,0xFFFFFFFF);
		/* 82066C38h case   23:*/		return 0x82066C3C;
		  /* 82066C3Ch */ case   24:  		/* or R11, R11, R10 */
		/* 82066C3Ch case   24:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82066C3Ch case   24:*/		return 0x82066C40;
		  /* 82066C40h */ case   25:  		/* stw R11, <#[R31 + 28]> */
		/* 82066C40h case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 82066C40h case   25:*/		return 0x82066C44;
		  /* 82066C44h */ case   26:  		/* bc 12, CR6_EQ, 68 */
		/* 82066C44h case   26:*/		if ( regs.CR[6].eq ) { return 0x82066C88;  }
		/* 82066C44h case   26:*/		return 0x82066C48;
		  /* 82066C48h */ case   27:  		/* cmplwi CR6, R23, 0 */
		/* 82066C48h case   27:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 82066C48h case   27:*/		return 0x82066C4C;
		  /* 82066C4Ch */ case   28:  		/* bc 12, CR6_EQ, 24 */
		/* 82066C4Ch case   28:*/		if ( regs.CR[6].eq ) { return 0x82066C64;  }
		/* 82066C4Ch case   28:*/		return 0x82066C50;
		  /* 82066C50h */ case   29:  		/* lwz R11, <#[R23 + 12]> */
		/* 82066C50h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x0000000C) );
		/* 82066C50h case   29:*/		return 0x82066C54;
		  /* 82066C54h */ case   30:  		/* cmpwi CR6, R11, 0 */
		/* 82066C54h case   30:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82066C54h case   30:*/		return 0x82066C58;
		  /* 82066C58h */ case   31:  		/* bc 12, CR6_EQ, 12 */
		/* 82066C58h case   31:*/		if ( regs.CR[6].eq ) { return 0x82066C64;  }
		/* 82066C58h case   31:*/		return 0x82066C5C;
		  /* 82066C5Ch */ case   32:  		/* addi R11, R11, -1 */
		/* 82066C5Ch case   32:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82066C5Ch case   32:*/		return 0x82066C60;
		  /* 82066C60h */ case   33:  		/* b 16 */
		/* 82066C60h case   33:*/		return 0x82066C70;
		/* 82066C60h case   33:*/		return 0x82066C64;
	}
	return 0x82066C64;
} // Block from 82066BDCh-82066C64h (34 instructions)

//////////////////////////////////////////////////////
// Block at 82066C64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066C64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066C64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066C64);
		  /* 82066C64h */ case    0:  		/* addi R11, R25, -22 */
		/* 82066C64h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R25,0xFFFFFFEA);
		/* 82066C64h case    0:*/		return 0x82066C68;
		  /* 82066C68h */ case    1:  		/* addic R10, R11, -1 */
		/* 82066C68h case    1:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R11,0xFFFFFFFF);
		/* 82066C68h case    1:*/		return 0x82066C6C;
		  /* 82066C6Ch */ case    2:  		/* subfe R11, R10, R11 */
		/* 82066C6Ch case    2:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82066C6Ch case    2:*/		return 0x82066C70;
	}
	return 0x82066C70;
} // Block from 82066C64h-82066C70h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82066C70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066C70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066C70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066C70);
		  /* 82066C70h */ case    0:  		/* rlwinm R11, R11, 0, 31, 31 */
		/* 82066C70h case    0:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82066C70h case    0:*/		return 0x82066C74;
		  /* 82066C74h */ case    1:  		/* rlwinm R10, R24, 13, 0, 18 */
		/* 82066C74h case    1:*/		cpu::op::rlwinm<0,13,0,18>(regs,&regs.R10,regs.R24);
		/* 82066C74h case    1:*/		return 0x82066C78;
	}
	return 0x82066C78;
} // Block from 82066C70h-82066C78h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82066C78h
// Function 'D3DDevice_SetVertexShaderConstantB'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066C78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066C78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066C78);
		  /* 82066C78h */ case    0:  		/* or R11, R11, R10 */
		/* 82066C78h case    0:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82066C78h case    0:*/		return 0x82066C7C;
		  /* 82066C7Ch */ case    1:  		/* rlwimi R22, R11, 4, 0, 27 */
		/* 82066C7Ch case    1:*/		cpu::op::rlwimi<0,4,0,27>(regs,&regs.R22,regs.R11);
		/* 82066C7Ch case    1:*/		return 0x82066C80;
		  /* 82066C80h */ case    2:  		/* stw R22, <#[R31 + 32]> */
		/* 82066C80h case    2:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R31 + 0x00000020) );
		/* 82066C80h case    2:*/		return 0x82066C84;
		  /* 82066C84h */ case    3:  		/* b 100 */
		/* 82066C84h case    3:*/		return 0x82066CE8;
		/* 82066C84h case    3:*/		return 0x82066C88;
	}
	return 0x82066C88;
} // Block from 82066C78h-82066C88h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82066C88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066C88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066C88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066C88);
		  /* 82066C88h */ case    0:  		/* li R11, 0 */
		/* 82066C88h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82066C88h case    0:*/		return 0x82066C8C;
		  /* 82066C8Ch */ case    1:  		/* stw R11, <#[R31 + 32]> */
		/* 82066C8Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 82066C8Ch case    1:*/		return 0x82066C90;
		  /* 82066C90h */ case    2:  		/* b 88 */
		/* 82066C90h case    2:*/		return 0x82066CE8;
		/* 82066C90h case    2:*/		return 0x82066C94;
	}
	return 0x82066C94;
} // Block from 82066C88h-82066C94h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82066C94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066C94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066C94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066C94);
		  /* 82066C94h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 82066C94h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82066C94h case    0:*/		return 0x82066C98;
		  /* 82066C98h */ case    1:  		/* bc 4, CR6_EQ, 60 */
		/* 82066C98h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82066CD4;  }
		/* 82066C98h case    1:*/		return 0x82066C9C;
		  /* 82066C9Ch */ case    2:  		/* rlwinm. R10, R28, 0, 14, 14 */
		/* 82066C9Ch case    2:*/		cpu::op::rlwinm<1,0,14,14>(regs,&regs.R10,regs.R28);
		/* 82066C9Ch case    2:*/		return 0x82066CA0;
		  /* 82066CA0h */ case    3:  		/* bc 4, CR0_EQ, 52 */
		/* 82066CA0h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82066CD4;  }
		/* 82066CA0h case    3:*/		return 0x82066CA4;
		  /* 82066CA4h */ case    4:  		/* rlwinm R10, R28, 0, 21, 22 */
		/* 82066CA4h case    4:*/		cpu::op::rlwinm<0,0,21,22>(regs,&regs.R10,regs.R28);
		/* 82066CA4h case    4:*/		return 0x82066CA8;
		  /* 82066CA8h */ case    5:  		/* cmpwi CR6, R10, 1536 */
		/* 82066CA8h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000600);
		/* 82066CA8h case    5:*/		return 0x82066CAC;
		  /* 82066CACh */ case    6:  		/* bc 4, CR6_EQ, 40 */
		/* 82066CACh case    6:*/		if ( !regs.CR[6].eq ) { return 0x82066CD4;  }
		/* 82066CACh case    6:*/		return 0x82066CB0;
		  /* 82066CB0h */ case    7:  		/* rlwinm R10, R28, 0, 19, 20 */
		/* 82066CB0h case    7:*/		cpu::op::rlwinm<0,0,19,20>(regs,&regs.R10,regs.R28);
		/* 82066CB0h case    7:*/		return 0x82066CB4;
		  /* 82066CB4h */ case    8:  		/* cmpwi CR6, R10, 6144 */
		/* 82066CB4h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00001800);
		/* 82066CB4h case    8:*/		return 0x82066CB8;
		  /* 82066CB8h */ case    9:  		/* bc 4, CR6_EQ, 28 */
		/* 82066CB8h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82066CD4;  }
		/* 82066CB8h case    9:*/		return 0x82066CBC;
		  /* 82066CBCh */ case   10:  		/* rlwinm R10, R28, 0, 17, 18 */
		/* 82066CBCh case   10:*/		cpu::op::rlwinm<0,0,17,18>(regs,&regs.R10,regs.R28);
		/* 82066CBCh case   10:*/		return 0x82066CC0;
		  /* 82066CC0h */ case   11:  		/* cmpwi CR6, R10, 24576 */
		/* 82066CC0h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00006000);
		/* 82066CC0h case   11:*/		return 0x82066CC4;
		  /* 82066CC4h */ case   12:  		/* bc 4, CR6_EQ, 16 */
		/* 82066CC4h case   12:*/		if ( !regs.CR[6].eq ) { return 0x82066CD4;  }
		/* 82066CC4h case   12:*/		return 0x82066CC8;
		  /* 82066CC8h */ case   13:  		/* rlwinm. R10, R28, 0, 15, 16 */
		/* 82066CC8h case   13:*/		cpu::op::rlwinm<1,0,15,16>(regs,&regs.R10,regs.R28);
		/* 82066CC8h case   13:*/		return 0x82066CCC;
		  /* 82066CCCh */ case   14:  		/* bc 4, CR0_EQ, 8 */
		/* 82066CCCh case   14:*/		if ( !regs.CR[0].eq ) { return 0x82066CD4;  }
		/* 82066CCCh case   14:*/		return 0x82066CD0;
		  /* 82066CD0h */ case   15:  		/* mr R11, R22 */
		/* 82066CD0h case   15:*/		regs.R11 = regs.R22;
		/* 82066CD0h case   15:*/		return 0x82066CD4;
	}
	return 0x82066CD4;
} // Block from 82066C94h-82066CD4h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82066CD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066CD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066CD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066CD4);
		  /* 82066CD4h */ case    0:  		/* rlwimi R11, R8, 4, 22, 27 */
		/* 82066CD4h case    0:*/		cpu::op::rlwimi<0,4,22,27>(regs,&regs.R11,regs.R8);
		/* 82066CD4h case    0:*/		return 0x82066CD8;
	}
	return 0x82066CD8;
} // Block from 82066CD4h-82066CD8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82066CD8h
// Function 'D3DDevice_SetPixelShaderConstantB'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066CD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066CD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066CD8);
		  /* 82066CD8h */ case    0:  		/* rlwinm R10, R9, 0, 20, 31 */
		/* 82066CD8h case    0:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R10,regs.R9);
		/* 82066CD8h case    0:*/		return 0x82066CDC;
		  /* 82066CDCh */ case    1:  		/* rlwinm R11, R11, 16, 6, 15 */
		/* 82066CDCh case    1:*/		cpu::op::rlwinm<0,16,6,15>(regs,&regs.R11,regs.R11);
		/* 82066CDCh case    1:*/		return 0x82066CE0;
		  /* 82066CE0h */ case    2:  		/* or R11, R11, R10 */
		/* 82066CE0h case    2:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82066CE0h case    2:*/		return 0x82066CE4;
		  /* 82066CE4h */ case    3:  		/* stw R11, <#[R31 + 28]> */
		/* 82066CE4h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 82066CE4h case    3:*/		return 0x82066CE8;
	}
	return 0x82066CE8;
} // Block from 82066CD8h-82066CE8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82066CE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066CE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066CE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066CE8);
		  /* 82066CE8h */ case    0:  		/* mulli R11, R3, 5120 */
		/* 82066CE8h case    0:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R3,0x1400);
		/* 82066CE8h case    0:*/		return 0x82066CEC;
		  /* 82066CECh */ case    1:  		/* stw R11, <#[R31 + 44]> */
		/* 82066CECh case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 82066CECh case    1:*/		return 0x82066CF0;
		  /* 82066CF0h */ case    2:  		/* stw R3, <#[R21]> */
		/* 82066CF0h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R21 + 0x00000000) );
		/* 82066CF0h case    2:*/		return 0x82066CF4;
		  /* 82066CF4h */ case    3:  		/* stw R7, <#[R20]> */
		/* 82066CF4h case    3:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R20 + 0x00000000) );
		/* 82066CF4h case    3:*/		return 0x82066CF8;
		  /* 82066CF8h */ case    4:  		/* addi R1, R1, 192 */
		/* 82066CF8h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 82066CF8h case    4:*/		return 0x82066CFC;
		  /* 82066CFCh */ case    5:  		/* b 173452 */
		/* 82066CFCh case    5:*/		return 0x82091288;
		/* 82066CFCh case    5:*/		return 0x82066D00;
		  /* 82066D00h */ case    6:  		/* lwz R11, <#[R3 + 44]> */
		/* 82066D00h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000002C) );
		/* 82066D00h case    6:*/		return 0x82066D04;
		  /* 82066D04h */ case    7:  		/* rlwinm R11, R11, 26, 28, 31 */
		/* 82066D04h case    7:*/		cpu::op::rlwinm<0,26,28,31>(regs,&regs.R11,regs.R11);
		/* 82066D04h case    7:*/		return 0x82066D08;
		  /* 82066D08h */ case    8:  		/* addi R3, R11, 1 */
		/* 82066D08h case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x1);
		/* 82066D08h case    8:*/		return 0x82066D0C;
		  /* 82066D0Ch */ case    9:  		/* bclr 20, CR0_LT */
		/* 82066D0Ch case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82066D0Ch case    9:*/		return 0x82066D10;
	}
	return 0x82066D10;
} // Block from 82066CE8h-82066D10h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82066D10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066D10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066D10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066D10);
		  /* 82066D10h */ case    0:  		/* b -2912 */
		/* 82066D10h case    0:*/		return 0x820661B0;
		/* 82066D10h case    0:*/		return 0x82066D14;
		  /* 82066D14h */ case    1:  		/* nop */
		/* 82066D14h case    1:*/		cpu::op::nop();
		/* 82066D14h case    1:*/		return 0x82066D18;
	}
	return 0x82066D18;
} // Block from 82066D10h-82066D18h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82066D18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066D18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066D18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066D18);
		  /* 82066D18h */ case    0:  		/* mfspr R12, LR */
		/* 82066D18h case    0:*/		regs.R12 = regs.LR;
		/* 82066D18h case    0:*/		return 0x82066D1C;
		  /* 82066D1Ch */ case    1:  		/* bl 173348 */
		/* 82066D1Ch case    1:*/		regs.LR = 0x82066D20; return 0x82091240;
		/* 82066D1Ch case    1:*/		return 0x82066D20;
		  /* 82066D20h */ case    2:  		/* stwu R1, <#[R1 - 224]> */
		/* 82066D20h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF20) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF20);
		/* 82066D20h case    2:*/		return 0x82066D24;
		  /* 82066D24h */ case    3:  		/* mr R28, R3 */
		/* 82066D24h case    3:*/		regs.R28 = regs.R3;
		/* 82066D24h case    3:*/		return 0x82066D28;
		  /* 82066D28h */ case    4:  		/* mr R27, R4 */
		/* 82066D28h case    4:*/		regs.R27 = regs.R4;
		/* 82066D28h case    4:*/		return 0x82066D2C;
		  /* 82066D2Ch */ case    5:  		/* li R30, 0 */
		/* 82066D2Ch case    5:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82066D2Ch case    5:*/		return 0x82066D30;
		  /* 82066D30h */ case    6:  		/* lis R4, 25728 */
		/* 82066D30h case    6:*/		cpu::op::lis<0>(regs,&regs.R4,0x6480);
		/* 82066D30h case    6:*/		return 0x82066D34;
		  /* 82066D34h */ case    7:  		/* li R3, 52 */
		/* 82066D34h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x34);
		/* 82066D34h case    7:*/		return 0x82066D38;
	}
	return 0x82066D38;
} // Block from 82066D18h-82066D38h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82066D38h
// Function 'D3DDevice_SetVertexShaderConstantI'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066D38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066D38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066D38);
		  /* 82066D38h */ case    0:  		/* mr R26, R5 */
		/* 82066D38h case    0:*/		regs.R26 = regs.R5;
		/* 82066D38h case    0:*/		return 0x82066D3C;
		  /* 82066D3Ch */ case    1:  		/* mr R25, R6 */
		/* 82066D3Ch case    1:*/		regs.R25 = regs.R6;
		/* 82066D3Ch case    1:*/		return 0x82066D40;
		  /* 82066D40h */ case    2:  		/* mr R29, R7 */
		/* 82066D40h case    2:*/		regs.R29 = regs.R7;
		/* 82066D40h case    2:*/		return 0x82066D44;
		  /* 82066D44h */ case    3:  		/* mr R24, R8 */
		/* 82066D44h case    3:*/		regs.R24 = regs.R8;
		/* 82066D44h case    3:*/		return 0x82066D48;
		  /* 82066D48h */ case    4:  		/* mr R23, R10 */
		/* 82066D48h case    4:*/		regs.R23 = regs.R10;
		/* 82066D48h case    4:*/		return 0x82066D4C;
		  /* 82066D4Ch */ case    5:  		/* mr R22, R30 */
		/* 82066D4Ch case    5:*/		regs.R22 = regs.R30;
		/* 82066D4Ch case    5:*/		return 0x82066D50;
		  /* 82066D50h */ case    6:  		/* bl 136368 */
		/* 82066D50h case    6:*/		regs.LR = 0x82066D54; return 0x82088200;
		/* 82066D50h case    6:*/		return 0x82066D54;
		  /* 82066D54h */ case    7:  		/* or. R31, R3, R3 */
		/* 82066D54h case    7:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 82066D54h case    7:*/		return 0x82066D58;
		  /* 82066D58h */ case    8:  		/* bc 4, CR0_EQ, 12 */
		/* 82066D58h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82066D64;  }
		/* 82066D58h case    8:*/		return 0x82066D5C;
		  /* 82066D5Ch */ case    9:  		/* li R3, 0 */
		/* 82066D5Ch case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82066D5Ch case    9:*/		return 0x82066D60;
		  /* 82066D60h */ case   10:  		/* b 208 */
		/* 82066D60h case   10:*/		return 0x82066E30;
		/* 82066D60h case   10:*/		return 0x82066D64;
	}
	return 0x82066D64;
} // Block from 82066D38h-82066D64h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82066D64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066D64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066D64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066D64);
		  /* 82066D64h */ case    0:  		/* addi R8, R1, 128 */
		/* 82066D64h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x80);
		/* 82066D64h case    0:*/		return 0x82066D68;
		  /* 82066D68h */ case    1:  		/* stw R31, <#[R1 + 108]> */
		/* 82066D68h case    1:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x0000006C) );
		/* 82066D68h case    1:*/		return 0x82066D6C;
		  /* 82066D6Ch */ case    2:  		/* addi R11, R1, 132 */
		/* 82066D6Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x84);
		/* 82066D6Ch case    2:*/		return 0x82066D70;
		  /* 82066D70h */ case    3:  		/* stw R30, <#[R1 + 100]> */
		/* 82066D70h case    3:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000064) );
		/* 82066D70h case    3:*/		return 0x82066D74;
		  /* 82066D74h */ case    4:  		/* stw R8, <#[R1 + 116]> */
		/* 82066D74h case    4:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000074) );
		/* 82066D74h case    4:*/		return 0x82066D78;
		  /* 82066D78h */ case    5:  		/* li R10, 2 */
		/* 82066D78h case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x2);
		/* 82066D78h case    5:*/		return 0x82066D7C;
		  /* 82066D7Ch */ case    6:  		/* mr R9, R24 */
		/* 82066D7Ch case    6:*/		regs.R9 = regs.R24;
		/* 82066D7Ch case    6:*/		return 0x82066D80;
		  /* 82066D80h */ case    7:  		/* stw R11, <#[R1 + 124]> */
		/* 82066D80h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000007C) );
		/* 82066D80h case    7:*/		return 0x82066D84;
		  /* 82066D84h */ case    8:  		/* mr R8, R29 */
		/* 82066D84h case    8:*/		regs.R8 = regs.R29;
		/* 82066D84h case    8:*/		return 0x82066D88;
		  /* 82066D88h */ case    9:  		/* stw R30, <#[R1 + 92]> */
		/* 82066D88h case    9:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x0000005C) );
		/* 82066D88h case    9:*/		return 0x82066D8C;
		  /* 82066D8Ch */ case   10:  		/* mr R7, R25 */
		/* 82066D8Ch case   10:*/		regs.R7 = regs.R25;
		/* 82066D8Ch case   10:*/		return 0x82066D90;
	}
	return 0x82066D90;
} // Block from 82066D64h-82066D90h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82066D90h
// Function 'D3DDevice_SetPixelShaderConstantI'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066D90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066D90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066D90);
		  /* 82066D90h */ case    0:  		/* stw R30, <#[R1 + 84]> */
		/* 82066D90h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000054) );
		/* 82066D90h case    0:*/		return 0x82066D94;
		  /* 82066D94h */ case    1:  		/* mr R6, R26 */
		/* 82066D94h case    1:*/		regs.R6 = regs.R26;
		/* 82066D94h case    1:*/		return 0x82066D98;
		  /* 82066D98h */ case    2:  		/* mr R5, R27 */
		/* 82066D98h case    2:*/		regs.R5 = regs.R27;
		/* 82066D98h case    2:*/		return 0x82066D9C;
		  /* 82066D9Ch */ case    3:  		/* mr R4, R28 */
		/* 82066D9Ch case    3:*/		regs.R4 = regs.R28;
		/* 82066D9Ch case    3:*/		return 0x82066DA0;
		  /* 82066DA0h */ case    4:  		/* mr R3, R23 */
		/* 82066DA0h case    4:*/		regs.R3 = regs.R23;
		/* 82066DA0h case    4:*/		return 0x82066DA4;
		  /* 82066DA4h */ case    5:  		/* bl -1548 */
		/* 82066DA4h case    5:*/		regs.LR = 0x82066DA8; return 0x82066798;
		/* 82066DA4h case    5:*/		return 0x82066DA8;
		  /* 82066DA8h */ case    6:  		/* nor R11, R29, R29 */
		/* 82066DA8h case    6:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R29,regs.R29);
		/* 82066DA8h case    6:*/		return 0x82066DAC;
		  /* 82066DACh */ case    7:  		/* lwz R3, <#[R1 + 128]> */
		/* 82066DACh case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000080) );
		/* 82066DACh case    7:*/		return 0x82066DB0;
		  /* 82066DB0h */ case    8:  		/* rlwinm R11, R11, 30, 31, 31 */
		/* 82066DB0h case    8:*/		cpu::op::rlwinm<0,30,31,31>(regs,&regs.R11,regs.R11);
		/* 82066DB0h case    8:*/		return 0x82066DB4;
		  /* 82066DB4h */ case    9:  		/* ori R11, R11, 2 */
		/* 82066DB4h case    9:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82066DB4h case    9:*/		return 0x82066DB8;
		  /* 82066DB8h */ case   10:  		/* rlwinm R11, R11, 28, 0, 3 */
		/* 82066DB8h case   10:*/		cpu::op::rlwinm<0,28,0,3>(regs,&regs.R11,regs.R11);
		/* 82066DB8h case   10:*/		return 0x82066DBC;
		  /* 82066DBCh */ case   11:  		/* oris R30, R11, 35968 */
		/* 82066DBCh case   11:*/		cpu::op::oris<0>(regs,&regs.R30,regs.R11,0x8C80);
		/* 82066DBCh case   11:*/		return 0x82066DC0;
		  /* 82066DC0h */ case   12:  		/* mr R4, R30 */
		/* 82066DC0h case   12:*/		regs.R4 = regs.R30;
		/* 82066DC0h case   12:*/		return 0x82066DC4;
		  /* 82066DC4h */ case   13:  		/* bl 136252 */
		/* 82066DC4h case   13:*/		regs.LR = 0x82066DC8; return 0x82088200;
		/* 82066DC4h case   13:*/		return 0x82066DC8;
		  /* 82066DC8h */ case   14:  		/* or. R29, R3, R3 */
		/* 82066DC8h case   14:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 82066DC8h case   14:*/		return 0x82066DCC;
		  /* 82066DCCh */ case   15:  		/* bc 4, CR0_EQ, 20 */
		/* 82066DCCh case   15:*/		if ( !regs.CR[0].eq ) { return 0x82066DE0;  }
		/* 82066DCCh case   15:*/		return 0x82066DD0;
		  /* 82066DD0h */ case   16:  		/* lis R4, 9344 */
		/* 82066DD0h case   16:*/		cpu::op::lis<0>(regs,&regs.R4,0x2480);
		/* 82066DD0h case   16:*/		return 0x82066DD4;
		  /* 82066DD4h */ case   17:  		/* mr R3, R31 */
		/* 82066DD4h case   17:*/		regs.R3 = regs.R31;
		/* 82066DD4h case   17:*/		return 0x82066DD8;
		  /* 82066DD8h */ case   18:  		/* bl 136544 */
		/* 82066DD8h case   18:*/		regs.LR = 0x82066DDC; return 0x82088338;
		/* 82066DD8h case   18:*/		return 0x82066DDC;
		  /* 82066DDCh */ case   19:  		/* b -128 */
		/* 82066DDCh case   19:*/		return 0x82066D5C;
		/* 82066DDCh case   19:*/		return 0x82066DE0;
	}
	return 0x82066DE0;
} // Block from 82066D90h-82066DE0h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82066DE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066DE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066DE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066DE0);
		  /* 82066DE0h */ case    0:  		/* lwz R3, <#[R1 + 132]> */
		/* 82066DE0h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000084) );
		/* 82066DE0h case    0:*/		return 0x82066DE4;
		  /* 82066DE4h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 82066DE4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82066DE4h case    1:*/		return 0x82066DE8;
	}
	return 0x82066DE8;
} // Block from 82066DE0h-82066DE8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82066DE8h
// Function 'XGGetMicrocodeShaderParts'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066DE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066DE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066DE8);
		  /* 82066DE8h */ case    0:  		/* bc 12, CR6_EQ, 44 */
		/* 82066DE8h case    0:*/		if ( regs.CR[6].eq ) { return 0x82066E14;  }
		/* 82066DE8h case    0:*/		return 0x82066DEC;
		  /* 82066DECh */ case    1:  		/* mr R4, R30 */
		/* 82066DECh case    1:*/		regs.R4 = regs.R30;
		/* 82066DECh case    1:*/		return 0x82066DF0;
		  /* 82066DF0h */ case    2:  		/* bl 136208 */
		/* 82066DF0h case    2:*/		regs.LR = 0x82066DF4; return 0x82088200;
		/* 82066DF0h case    2:*/		return 0x82066DF4;
		  /* 82066DF4h */ case    3:  		/* or. R22, R3, R3 */
		/* 82066DF4h case    3:*/		cpu::op::or<1>(regs,&regs.R22,regs.R3,regs.R3);
		/* 82066DF4h case    3:*/		return 0x82066DF8;
		  /* 82066DF8h */ case    4:  		/* bc 4, CR0_EQ, 28 */
		/* 82066DF8h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82066E14;  }
		/* 82066DF8h case    4:*/		return 0x82066DFC;
		  /* 82066DFCh */ case    5:  		/* lis R4, 9344 */
		/* 82066DFCh case    5:*/		cpu::op::lis<0>(regs,&regs.R4,0x2480);
		/* 82066DFCh case    5:*/		return 0x82066E00;
		  /* 82066E00h */ case    6:  		/* mr R3, R31 */
		/* 82066E00h case    6:*/		regs.R3 = regs.R31;
		/* 82066E00h case    6:*/		return 0x82066E04;
		  /* 82066E04h */ case    7:  		/* bl 136500 */
		/* 82066E04h case    7:*/		regs.LR = 0x82066E08; return 0x82088338;
		/* 82066E04h case    7:*/		return 0x82066E08;
		  /* 82066E08h */ case    8:  		/* lis R4, -20096 */
		/* 82066E08h case    8:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFFB180);
		/* 82066E08h case    8:*/		return 0x82066E0C;
		  /* 82066E0Ch */ case    9:  		/* mr R3, R29 */
		/* 82066E0Ch case    9:*/		regs.R3 = regs.R29;
		/* 82066E0Ch case    9:*/		return 0x82066E10;
		  /* 82066E10h */ case   10:  		/* b -56 */
		/* 82066E10h case   10:*/		return 0x82066DD8;
		/* 82066E10h case   10:*/		return 0x82066E14;
	}
	return 0x82066E14;
} // Block from 82066DE8h-82066E14h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82066E14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066E14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066E14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066E14);
		  /* 82066E14h */ case    0:  		/* lwz R11, <#[R31 + 32]> */
		/* 82066E14h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 82066E14h case    0:*/		return 0x82066E18;
		  /* 82066E18h */ case    1:  		/* mr R3, R31 */
		/* 82066E18h case    1:*/		regs.R3 = regs.R31;
		/* 82066E18h case    1:*/		return 0x82066E1C;
		  /* 82066E1Ch */ case    2:  		/* lwz R10, <#[R31 + 48]> */
		/* 82066E1Ch case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000030) );
		/* 82066E1Ch case    2:*/		return 0x82066E20;
		  /* 82066E20h */ case    3:  		/* rlwimi R11, R29, 0, 0, 19 */
		/* 82066E20h case    3:*/		cpu::op::rlwimi<0,0,0,19>(regs,&regs.R11,regs.R29);
		/* 82066E20h case    3:*/		return 0x82066E24;
		  /* 82066E24h */ case    4:  		/* rlwimi R22, R10, 0, 20, 31 */
		/* 82066E24h case    4:*/		cpu::op::rlwimi<0,0,20,31>(regs,&regs.R22,regs.R10);
		/* 82066E24h case    4:*/		return 0x82066E28;
		  /* 82066E28h */ case    5:  		/* stw R11, <#[R31 + 32]> */
		/* 82066E28h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 82066E28h case    5:*/		return 0x82066E2C;
		  /* 82066E2Ch */ case    6:  		/* stw R22, <#[R31 + 48]> */
		/* 82066E2Ch case    6:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R31 + 0x00000030) );
		/* 82066E2Ch case    6:*/		return 0x82066E30;
	}
	return 0x82066E30;
} // Block from 82066E14h-82066E30h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82066E30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066E30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066E30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066E30);
		  /* 82066E30h */ case    0:  		/* addi R1, R1, 224 */
		/* 82066E30h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xE0);
		/* 82066E30h case    0:*/		return 0x82066E34;
		  /* 82066E34h */ case    1:  		/* b 173148 */
		/* 82066E34h case    1:*/		return 0x82091290;
		/* 82066E34h case    1:*/		return 0x82066E38;
	}
	return 0x82066E38;
} // Block from 82066E30h-82066E38h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82066E38h
// Function 'XGRegisterPixelShader'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066E38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066E38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066E38);
		  /* 82066E38h */ case    0:  		/* mfspr R12, LR */
		/* 82066E38h case    0:*/		regs.R12 = regs.LR;
		/* 82066E38h case    0:*/		return 0x82066E3C;
		  /* 82066E3Ch */ case    1:  		/* bl 173076 */
		/* 82066E3Ch case    1:*/		regs.LR = 0x82066E40; return 0x82091250;
		/* 82066E3Ch case    1:*/		return 0x82066E40;
		  /* 82066E40h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82066E40h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82066E40h case    2:*/		return 0x82066E44;
		  /* 82066E44h */ case    3:  		/* mr R29, R3 */
		/* 82066E44h case    3:*/		regs.R29 = regs.R3;
		/* 82066E44h case    3:*/		return 0x82066E48;
		  /* 82066E48h */ case    4:  		/* mr R28, R4 */
		/* 82066E48h case    4:*/		regs.R28 = regs.R4;
		/* 82066E48h case    4:*/		return 0x82066E4C;
		  /* 82066E4Ch */ case    5:  		/* lis R4, 25728 */
		/* 82066E4Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R4,0x6480);
		/* 82066E4Ch case    5:*/		return 0x82066E50;
		  /* 82066E50h */ case    6:  		/* li R3, 48 */
		/* 82066E50h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x30);
		/* 82066E50h case    6:*/		return 0x82066E54;
		  /* 82066E54h */ case    7:  		/* mr R27, R5 */
		/* 82066E54h case    7:*/		regs.R27 = regs.R5;
		/* 82066E54h case    7:*/		return 0x82066E58;
		  /* 82066E58h */ case    8:  		/* mr R26, R6 */
		/* 82066E58h case    8:*/		regs.R26 = regs.R6;
		/* 82066E58h case    8:*/		return 0x82066E5C;
		  /* 82066E5Ch */ case    9:  		/* mr R30, R7 */
		/* 82066E5Ch case    9:*/		regs.R30 = regs.R7;
		/* 82066E5Ch case    9:*/		return 0x82066E60;
		  /* 82066E60h */ case   10:  		/* bl 136096 */
		/* 82066E60h case   10:*/		regs.LR = 0x82066E64; return 0x82088200;
		/* 82066E60h case   10:*/		return 0x82066E64;
		  /* 82066E64h */ case   11:  		/* or. R31, R3, R3 */
		/* 82066E64h case   11:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 82066E64h case   11:*/		return 0x82066E68;
		  /* 82066E68h */ case   12:  		/* bc 4, CR0_EQ, 12 */
		/* 82066E68h case   12:*/		if ( !regs.CR[0].eq ) { return 0x82066E74;  }
		/* 82066E68h case   12:*/		return 0x82066E6C;
		  /* 82066E6Ch */ case   13:  		/* li R3, 0 */
		/* 82066E6Ch case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82066E6Ch case   13:*/		return 0x82066E70;
	}
	return 0x82066E70;
} // Block from 82066E38h-82066E70h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82066E70h
// Function 'D3DDevice_SetPixelShader'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066E70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066E70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066E70);
		  /* 82066E70h */ case    0:  		/* b 248 */
		/* 82066E70h case    0:*/		return 0x82066F68;
		/* 82066E70h case    0:*/		return 0x82066E74;
	}
	return 0x82066E74;
} // Block from 82066E70h-82066E74h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82066E74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066E74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066E74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066E74);
		  /* 82066E74h */ case    0:  		/* addi R10, R1, 84 */
		/* 82066E74h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x54);
		/* 82066E74h case    0:*/		return 0x82066E78;
		  /* 82066E78h */ case    1:  		/* addi R9, R1, 80 */
		/* 82066E78h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x50);
		/* 82066E78h case    1:*/		return 0x82066E7C;
		  /* 82066E7Ch */ case    2:  		/* mr R8, R31 */
		/* 82066E7Ch case    2:*/		regs.R8 = regs.R31;
		/* 82066E7Ch case    2:*/		return 0x82066E80;
		  /* 82066E80h */ case    3:  		/* mr R7, R30 */
		/* 82066E80h case    3:*/		regs.R7 = regs.R30;
		/* 82066E80h case    3:*/		return 0x82066E84;
		  /* 82066E84h */ case    4:  		/* mr R6, R26 */
		/* 82066E84h case    4:*/		regs.R6 = regs.R26;
		/* 82066E84h case    4:*/		return 0x82066E88;
		  /* 82066E88h */ case    5:  		/* mr R5, R27 */
		/* 82066E88h case    5:*/		regs.R5 = regs.R27;
		/* 82066E88h case    5:*/		return 0x82066E8C;
		  /* 82066E8Ch */ case    6:  		/* mr R4, R28 */
		/* 82066E8Ch case    6:*/		regs.R4 = regs.R28;
		/* 82066E8Ch case    6:*/		return 0x82066E90;
		  /* 82066E90h */ case    7:  		/* mr R3, R29 */
		/* 82066E90h case    7:*/		regs.R3 = regs.R29;
		/* 82066E90h case    7:*/		return 0x82066E94;
		  /* 82066E94h */ case    8:  		/* bl -1028 */
		/* 82066E94h case    8:*/		regs.LR = 0x82066E98; return 0x82066A90;
		/* 82066E94h case    8:*/		return 0x82066E98;
		  /* 82066E98h */ case    9:  		/* lwz R11, <#[R31]> */
		/* 82066E98h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82066E98h case    9:*/		return 0x82066E9C;
		  /* 82066E9Ch */ case   10:  		/* cmplwi CR6, R30, 0 */
		/* 82066E9Ch case   10:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82066E9Ch case   10:*/		return 0x82066EA0;
		  /* 82066EA0h */ case   11:  		/* oris R11, R11, 16 */
		/* 82066EA0h case   11:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x10);
		/* 82066EA0h case   11:*/		return 0x82066EA4;
		  /* 82066EA4h */ case   12:  		/* stw R11, <#[R31]> */
		/* 82066EA4h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82066EA4h case   12:*/		return 0x82066EA8;
		  /* 82066EA8h */ case   13:  		/* bc 4, CR6_EQ, 188 */
		/* 82066EA8h case   13:*/		if ( !regs.CR[6].eq ) { return 0x82066F64;  }
		/* 82066EA8h case   13:*/		return 0x82066EAC;
		  /* 82066EACh */ case   14:  		/* lwz R11, <#[R31 + 40]> */
		/* 82066EACh case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000028) );
		/* 82066EACh case   14:*/		return 0x82066EB0;
		  /* 82066EB0h */ case   15:  		/* rlwinm R11, R11, 0, 26, 31 */
		/* 82066EB0h case   15:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R11,regs.R11);
		/* 82066EB0h case   15:*/		return 0x82066EB4;
		  /* 82066EB4h */ case   16:  		/* cmplwi CR6, R11, 22 */
		/* 82066EB4h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000016);
		/* 82066EB4h case   16:*/		return 0x82066EB8;
		  /* 82066EB8h */ case   17:  		/* bc 12, CR6_EQ, 16 */
		/* 82066EB8h case   17:*/		if ( regs.CR[6].eq ) { return 0x82066EC8;  }
		/* 82066EB8h case   17:*/		return 0x82066EBC;
		  /* 82066EBCh */ case   18:  		/* cmplwi CR6, R11, 23 */
		/* 82066EBCh case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000017);
		/* 82066EBCh case   18:*/		return 0x82066EC0;
		  /* 82066EC0h */ case   19:  		/* li R29, 0 */
		/* 82066EC0h case   19:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82066EC0h case   19:*/		return 0x82066EC4;
		  /* 82066EC4h */ case   20:  		/* bc 4, CR6_EQ, 8 */
		/* 82066EC4h case   20:*/		if ( !regs.CR[6].eq ) { return 0x82066ECC;  }
		/* 82066EC4h case   20:*/		return 0x82066EC8;
	}
	return 0x82066EC8;
} // Block from 82066E74h-82066EC8h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82066EC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066EC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066EC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066EC8);
		  /* 82066EC8h */ case    0:  		/* li R29, 1 */
		/* 82066EC8h case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 82066EC8h case    0:*/		return 0x82066ECC;
	}
	return 0x82066ECC;
} // Block from 82066EC8h-82066ECCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82066ECCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066ECC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066ECC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066ECC);
		  /* 82066ECCh */ case    0:  		/* lwz R30, <#[R1 + 80]> */
		/* 82066ECCh case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000050) );
		/* 82066ECCh case    0:*/		return 0x82066ED0;
		  /* 82066ED0h */ case    1:  		/* addi R4, R1, 80 */
		/* 82066ED0h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 82066ED0h case    1:*/		return 0x82066ED4;
		  /* 82066ED4h */ case    2:  		/* mr R3, R30 */
		/* 82066ED4h case    2:*/		regs.R3 = regs.R30;
		/* 82066ED4h case    2:*/		return 0x82066ED8;
		  /* 82066ED8h */ case    3:  		/* bl 66984 */
		/* 82066ED8h case    3:*/		regs.LR = 0x82066EDC; return 0x82077480;
		/* 82066ED8h case    3:*/		return 0x82066EDC;
		  /* 82066EDCh */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 82066EDCh case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82066EDCh case    4:*/		return 0x82066EE0;
		  /* 82066EE0h */ case    5:  		/* bc 4, CR0_EQ, 20 */
		/* 82066EE0h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82066EF4;  }
		/* 82066EE0h case    5:*/		return 0x82066EE4;
		  /* 82066EE4h */ case    6:  		/* lis R4, 9344 */
		/* 82066EE4h case    6:*/		cpu::op::lis<0>(regs,&regs.R4,0x2480);
		/* 82066EE4h case    6:*/		return 0x82066EE8;
		  /* 82066EE8h */ case    7:  		/* mr R3, R31 */
		/* 82066EE8h case    7:*/		regs.R3 = regs.R31;
		/* 82066EE8h case    7:*/		return 0x82066EEC;
		  /* 82066EECh */ case    8:  		/* bl 136268 */
		/* 82066EECh case    8:*/		regs.LR = 0x82066EF0; return 0x82088338;
		/* 82066EECh case    8:*/		return 0x82066EF0;
		  /* 82066EF0h */ case    9:  		/* b -132 */
		/* 82066EF0h case    9:*/		return 0x82066E6C;
		/* 82066EF0h case    9:*/		return 0x82066EF4;
	}
	return 0x82066EF4;
} // Block from 82066ECCh-82066EF4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82066EF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066EF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066EF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066EF4);
		  /* 82066EF4h */ case    0:  		/* lwz R3, <#[R1 + 80]> */
		/* 82066EF4h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 82066EF4h case    0:*/		return 0x82066EF8;
		  /* 82066EF8h */ case    1:  		/* add R11, R3, R30 */
		/* 82066EF8h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R30);
		/* 82066EF8h case    1:*/		return 0x82066EFC;
		  /* 82066EFCh */ case    2:  		/* cmplwi CR6, R11, 2048 */
		/* 82066EFCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000800);
		/* 82066EFCh case    2:*/		return 0x82066F00;
		  /* 82066F00h */ case    3:  		/* bc 4, CR6_GT, 16 */
		/* 82066F00h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82066F10;  }
		/* 82066F00h case    3:*/		return 0x82066F04;
		  /* 82066F04h */ case    4:  		/* mr R4, R30 */
		/* 82066F04h case    4:*/		regs.R4 = regs.R30;
		/* 82066F04h case    4:*/		return 0x82066F08;
		  /* 82066F08h */ case    5:  		/* bl 66856 */
		/* 82066F08h case    5:*/		regs.LR = 0x82066F0C; return 0x82077430;
		/* 82066F08h case    5:*/		return 0x82066F0C;
		  /* 82066F0Ch */ case    6:  		/* b -40 */
		/* 82066F0Ch case    6:*/		return 0x82066EE4;
		/* 82066F0Ch case    6:*/		return 0x82066F10;
	}
	return 0x82066F10;
} // Block from 82066EF4h-82066F10h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82066F10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066F10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066F10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066F10);
		  /* 82066F10h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 82066F10h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82066F10h case    0:*/		return 0x82066F14;
		  /* 82066F14h */ case    1:  		/* cmpwi CR6, R29, 0 */
		/* 82066F14h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 82066F14h case    1:*/		return 0x82066F18;
		  /* 82066F18h */ case    2:  		/* oris R11, R11, 32768 */
		/* 82066F18h case    2:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8000);
		/* 82066F18h case    2:*/		return 0x82066F1C;
		  /* 82066F1Ch */ case    3:  		/* stw R11, <#[R31]> */
		/* 82066F1Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82066F1Ch case    3:*/		return 0x82066F20;
		  /* 82066F20h */ case    4:  		/* bc 12, CR6_EQ, 56 */
		/* 82066F20h case    4:*/		if ( regs.CR[6].eq ) { return 0x82066F58;  }
		/* 82066F20h case    4:*/		return 0x82066F24;
		  /* 82066F24h */ case    5:  		/* lwz R10, <#[R31 + 28]> */
		/* 82066F24h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000001C) );
		/* 82066F24h case    5:*/		return 0x82066F28;
		  /* 82066F28h */ case    6:  		/* lis R11, -32216 */
		/* 82066F28h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 82066F28h case    6:*/		return 0x82066F2C;
		  /* 82066F2Ch */ case    7:  		/* rlwimi R3, R10, 0, 0, 19 */
		/* 82066F2Ch case    7:*/		cpu::op::rlwimi<0,0,0,19>(regs,&regs.R3,regs.R10);
		/* 82066F2Ch case    7:*/		return 0x82066F30;
		  /* 82066F30h */ case    8:  		/* stw R3, <#[R31 + 28]> */
		/* 82066F30h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000001C) );
		/* 82066F30h case    8:*/		return 0x82066F34;
		  /* 82066F34h */ case    9:  		/* lwz R10, <#[R11 + 28680]> */
		/* 82066F34h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00007008) );
		/* 82066F34h case    9:*/		return 0x82066F38;
		  /* 82066F38h */ case   10:  		/* cmpwi CR6, R10, 0 */
		/* 82066F38h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 82066F38h case   10:*/		return 0x82066F3C;
		  /* 82066F3Ch */ case   11:  		/* bc 4, CR6_EQ, 40 */
		/* 82066F3Ch case   11:*/		if ( !regs.CR[6].eq ) { return 0x82066F64;  }
		/* 82066F3Ch case   11:*/		return 0x82066F40;
		  /* 82066F40h */ case   12:  		/* li R10, 1 */
		/* 82066F40h case   12:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82066F40h case   12:*/		return 0x82066F44;
		  /* 82066F44h */ case   13:  		/* stw R10, <#[R11 + 28680]> */
		/* 82066F44h case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00007008) );
		/* 82066F44h case   13:*/		return 0x82066F48;
		  /* 82066F48h */ case   14:  		/* lwz R11, <#[R31 + 32]> */
		/* 82066F48h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 82066F48h case   14:*/		return 0x82066F4C;
		  /* 82066F4Ch */ case   15:  		/* rlwinm R11, R11, 0, 15, 31 */
		/* 82066F4Ch case   15:*/		cpu::op::rlwinm<0,0,15,31>(regs,&regs.R11,regs.R11);
		/* 82066F4Ch case   15:*/		return 0x82066F50;
		  /* 82066F50h */ case   16:  		/* stw R11, <#[R31 + 32]> */
		/* 82066F50h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 82066F50h case   16:*/		return 0x82066F54;
		  /* 82066F54h */ case   17:  		/* b 16 */
		/* 82066F54h case   17:*/		return 0x82066F64;
		/* 82066F54h case   17:*/		return 0x82066F58;
	}
	return 0x82066F58;
} // Block from 82066F10h-82066F58h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82066F58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066F58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066F58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066F58);
		  /* 82066F58h */ case    0:  		/* lwz R11, <#[R31 + 28]> */
		/* 82066F58h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 82066F58h case    0:*/		return 0x82066F5C;
		  /* 82066F5Ch */ case    1:  		/* rlwimi R3, R11, 0, 0, 19 */
		/* 82066F5Ch case    1:*/		cpu::op::rlwimi<0,0,0,19>(regs,&regs.R3,regs.R11);
		/* 82066F5Ch case    1:*/		return 0x82066F60;
		  /* 82066F60h */ case    2:  		/* stw R3, <#[R31 + 28]> */
		/* 82066F60h case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000001C) );
		/* 82066F60h case    2:*/		return 0x82066F64;
	}
	return 0x82066F64;
} // Block from 82066F58h-82066F64h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82066F64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066F64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066F64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066F64);
		  /* 82066F64h */ case    0:  		/* mr R3, R31 */
		/* 82066F64h case    0:*/		regs.R3 = regs.R31;
		/* 82066F64h case    0:*/		return 0x82066F68;
	}
	return 0x82066F68;
} // Block from 82066F64h-82066F68h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82066F68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066F68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066F68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066F68);
		  /* 82066F68h */ case    0:  		/* addi R1, R1, 144 */
		/* 82066F68h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82066F68h case    0:*/		return 0x82066F6C;
		  /* 82066F6Ch */ case    1:  		/* b 172852 */
		/* 82066F6Ch case    1:*/		return 0x820912A0;
		/* 82066F6Ch case    1:*/		return 0x82066F70;
	}
	return 0x82066F70;
} // Block from 82066F68h-82066F70h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82066F70h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82066F70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82066F70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82066F70);
		  /* 82066F70h */ case    0:  		/* mfspr R12, LR */
		/* 82066F70h case    0:*/		regs.R12 = regs.LR;
		/* 82066F70h case    0:*/		return 0x82066F74;
		  /* 82066F74h */ case    1:  		/* bl 172740 */
		/* 82066F74h case    1:*/		regs.LR = 0x82066F78; return 0x82091238;
		/* 82066F74h case    1:*/		return 0x82066F78;
		  /* 82066F78h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 82066F78h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 82066F78h case    2:*/		return 0x82066F7C;
		  /* 82066F7Ch */ case    3:  		/* addi R11, R4, 3230 */
		/* 82066F7Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0xC9E);
		/* 82066F7Ch case    3:*/		return 0x82066F80;
		  /* 82066F80h */ case    4:  		/* mr R31, R3 */
		/* 82066F80h case    4:*/		regs.R31 = regs.R3;
		/* 82066F80h case    4:*/		return 0x82066F84;
		  /* 82066F84h */ case    5:  		/* rlwinm R29, R11, 2, 0, 29 */
		/* 82066F84h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R29,regs.R11);
		/* 82066F84h case    5:*/		return 0x82066F88;
		  /* 82066F88h */ case    6:  		/* addi R11, R4, 48 */
		/* 82066F88h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x30);
		/* 82066F88h case    6:*/		return 0x82066F8C;
		  /* 82066F8Ch */ case    7:  		/* cmplwi CR6, R5, 0 */
		/* 82066F8Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 82066F8Ch case    7:*/		return 0x82066F90;
		  /* 82066F90h */ case    8:  		/* mulli R11, R11, 24 */
		/* 82066F90h case    8:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x18);
		/* 82066F90h case    8:*/		return 0x82066F94;
		  /* 82066F94h */ case    9:  		/* lwzx R28, <#[R29 + R3]> */
		/* 82066F94h case    9:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R29 + regs.R3 + 0x00000000) );
		/* 82066F94h case    9:*/		return 0x82066F98;
		  /* 82066F98h */ case   10:  		/* bc 12, CR6_EQ, 224 */
		/* 82066F98h case   10:*/		if ( regs.CR[6].eq ) { return 0x82067078;  }
		/* 82066F98h case   10:*/		return 0x82066F9C;
		  /* 82066F9Ch */ case   11:  		/* lwz R27, <#[R5 + 48]> */
		/* 82066F9Ch case   11:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R5 + 0x00000030) );
		/* 82066F9Ch case   11:*/		return 0x82066FA0;
		  /* 82066FA0h */ case   12:  		/* add R11, R11, R3 */
		/* 82066FA0h case   12:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 82066FA0h case   12:*/		return 0x82066FA4;
		  /* 82066FA4h */ case   13:  		/* lwz R7, <#[R5 + 32]> */
		/* 82066FA4h case   13:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R5 + 0x00000020) );
		/* 82066FA4h case   13:*/		return 0x82066FA8;
		  /* 82066FA8h */ case   14:  		/* rlwinm R9, R27, 12, 20, 31 */
		/* 82066FA8h case   14:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R9,regs.R27);
		/* 82066FA8h case   14:*/		return 0x82066FAC;
		  /* 82066FACh */ case   15:  		/* lwz R26, <#[R5 + 44]> */
		/* 82066FACh case   15:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R5 + 0x0000002C) );
		/* 82066FACh case   15:*/		return 0x82066FB0;
		  /* 82066FB0h */ case   16:  		/* rlwinm R10, R7, 12, 20, 31 */
		/* 82066FB0h case   16:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R10,regs.R7);
		/* 82066FB0h case   16:*/		return 0x82066FB4;
		  /* 82066FB4h */ case   17:  		/* lwz R25, <#[R5 + 28]> */
		/* 82066FB4h case   17:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R5 + 0x0000001C) );
		/* 82066FB4h case   17:*/		return 0x82066FB8;
		  /* 82066FB8h */ case   18:  		/* addi R9, R9, 512 */
		/* 82066FB8h case   18:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x200);
		/* 82066FB8h case   18:*/		return 0x82066FBC;
		  /* 82066FBCh */ case   19:  		/* lwz R24, <#[R5 + 36]> */
		/* 82066FBCh case   19:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R5 + 0x00000024) );
		/* 82066FBCh case   19:*/		return 0x82066FC0;
		  /* 82066FC0h */ case   20:  		/* addi R10, R10, 512 */
		/* 82066FC0h case   20:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x200);
		/* 82066FC0h case   20:*/		return 0x82066FC4;
		  /* 82066FC4h */ case   21:  		/* lwz R22, <#[R11]> */
		/* 82066FC4h case   21:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R11 + 0x00000000) );
		/* 82066FC4h case   21:*/		return 0x82066FC8;
		  /* 82066FC8h */ case   22:  		/* rlwinm R30, R7, 0, 3, 31 */
		/* 82066FC8h case   22:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R30,regs.R7);
		/* 82066FC8h case   22:*/		return 0x82066FCC;
		  /* 82066FCCh */ case   23:  		/* lwz R21, <#[R11 + 12]> */
		/* 82066FCCh case   23:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R11 + 0x0000000C) );
		/* 82066FCCh case   23:*/		return 0x82066FD0;
		  /* 82066FD0h */ case   24:  		/* rlwinm R8, R9, 0, 19, 19 */
		/* 82066FD0h case   24:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R8,regs.R9);
		/* 82066FD0h case   24:*/		return 0x82066FD4;
		  /* 82066FD4h */ case   25:  		/* lwz R20, <#[R11 + 20]> */
		/* 82066FD4h case   25:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R11 + 0x00000014) );
		/* 82066FD4h case   25:*/		return 0x82066FD8;
		  /* 82066FD8h */ case   26:  		/* rlwinm R3, R10, 0, 19, 19 */
		/* 82066FD8h case   26:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R3,regs.R10);
		/* 82066FD8h case   26:*/		return 0x82066FDC;
		  /* 82066FDCh */ case   27:  		/* lwz R23, <#[R5 + 40]> */
		/* 82066FDCh case   27:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R5 + 0x00000028) );
		/* 82066FDCh case   27:*/		return 0x82066FE0;
		  /* 82066FE0h */ case   28:  		/* add R9, R31, R4 */
		/* 82066FE0h case   28:*/		cpu::op::add<0>(regs,&regs.R9,regs.R31,regs.R4);
		/* 82066FE0h case   28:*/		return 0x82066FE4;
		  /* 82066FE4h */ case   29:  		/* lwz R4, <#[R11 + 16]> */
		/* 82066FE4h case   29:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000010) );
		/* 82066FE4h case   29:*/		return 0x82066FE8;
		  /* 82066FE8h */ case   30:  		/* rlwinm R7, R27, 0, 3, 22 */
		/* 82066FE8h case   30:*/		cpu::op::rlwinm<0,0,3,22>(regs,&regs.R7,regs.R27);
		/* 82066FE8h case   30:*/		return 0x82066FEC;
		  /* 82066FECh */ case   31:  		/* lwz R27, <#[R11 + 4]> */
		/* 82066FECh case   31:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x00000004) );
		/* 82066FECh case   31:*/		return 0x82066FF0;
		  /* 82066FF0h */ case   32:  		/* mr R10, R26 */
		/* 82066FF0h case   32:*/		regs.R10 = regs.R26;
		/* 82066FF0h case   32:*/		return 0x82066FF4;
		  /* 82066FF4h */ case   33:  		/* stw R24, <#[R11 + 8]> */
		/* 82066FF4h case   33:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R11 + 0x00000008) );
		/* 82066FF4h case   33:*/		return 0x82066FF8;
		  /* 82066FF8h */ case   34:  		/* add R7, R8, R7 */
		/* 82066FF8h case   34:*/		cpu::op::add<0>(regs,&regs.R7,regs.R8,regs.R7);
		/* 82066FF8h case   34:*/		return 0x82066FFC;
		  /* 82066FFCh */ case   35:  		/* add R3, R3, R30 */
		/* 82066FFCh case   35:*/		cpu::op::add<0>(regs,&regs.R3,regs.R3,regs.R30);
		/* 82066FFCh case   35:*/		return 0x82067000;
		  /* 82067000h */ case   36:  		/* rlwimi R10, R4, 0, 30, 21 */
		/* 82067000h case   36:*/		cpu::op::rlwimi<0,0,30,21>(regs,&regs.R10,regs.R4);
		/* 82067000h case   36:*/		return 0x82067004;
		  /* 82067004h */ case   37:  		/* lbz R8, <#[R9 + 12356]> */
		/* 82067004h case   37:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R9 + 0x00003044) );
		/* 82067004h case   37:*/		return 0x82067008;
		  /* 82067008h */ case   38:  		/* rlwimi R25, R22, 0, 10, 21 */
		/* 82067008h case   38:*/		cpu::op::rlwimi<0,0,10,21>(regs,&regs.R25,regs.R22);
		/* 82067008h case   38:*/		return 0x8206700C;
		  /* 8206700Ch */ case   39:  		/* rlwimi R3, R27, 0, 20, 20 */
		/* 8206700Ch case   39:*/		cpu::op::rlwimi<0,0,20,20>(regs,&regs.R3,regs.R27);
		/* 8206700Ch case   39:*/		return 0x82067010;
		  /* 82067010h */ case   40:  		/* stw R10, <#[R11 + 16]> */
		/* 82067010h case   40:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 82067010h case   40:*/		return 0x82067014;
		  /* 82067014h */ case   41:  		/* rlwimi R23, R21, 0, 1, 12 */
		/* 82067014h case   41:*/		cpu::op::rlwimi<0,0,1,12>(regs,&regs.R23,regs.R21);
		/* 82067014h case   41:*/		return 0x82067018;
		  /* 82067018h */ case   42:  		/* stw R25, <#[R11]> */
		/* 82067018h case   42:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R11 + 0x00000000) );
		/* 82067018h case   42:*/		return 0x8206701C;
		  /* 8206701Ch */ case   43:  		/* rlwimi R7, R20, 0, 23, 31 */
		/* 8206701Ch case   43:*/		cpu::op::rlwimi<0,0,23,31>(regs,&regs.R7,regs.R20);
		/* 8206701Ch case   43:*/		return 0x82067020;
		  /* 82067020h */ case   44:  		/* stw R3, <#[R11 + 4]> */
		/* 82067020h case   44:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000004) );
		/* 82067020h case   44:*/		return 0x82067024;
		  /* 82067024h */ case   45:  		/* rlwinm R4, R26, 30, 28, 31 */
		/* 82067024h case   45:*/		cpu::op::rlwinm<0,30,28,31>(regs,&regs.R4,regs.R26);
		/* 82067024h case   45:*/		return 0x82067028;
		  /* 82067028h */ case   46:  		/* stw R23, <#[R11 + 12]> */
		/* 82067028h case   46:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x0000000C) );
		/* 82067028h case   46:*/		return 0x8206702C;
		  /* 8206702Ch */ case   47:  		/* stw R7, <#[R11 + 20]> */
		/* 8206702Ch case   47:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000014) );
		/* 8206702Ch case   47:*/		return 0x82067030;
	}
	return 0x82067030;
} // Block from 82066F70h-82067030h (48 instructions)

//////////////////////////////////////////////////////
// Block at 82067030h
// Function 'XGRegisterVertexShader'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067030( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067030) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067030);
		  /* 82067030h */ case    0:  		/* cmplw CR6, R4, R8 */
		/* 82067030h case    0:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R8);
		/* 82067030h case    0:*/		return 0x82067034;
		  /* 82067034h */ case    1:  		/* bc 4, CR6_GT, 12 */
		/* 82067034h case    1:*/		if ( !regs.CR[6].gt ) { return 0x82067040;  }
		/* 82067034h case    1:*/		return 0x82067038;
		  /* 82067038h */ case    2:  		/* rlwinm R8, R26, 0, 0, 31 */
		/* 82067038h case    2:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R8,regs.R26);
		/* 82067038h case    2:*/		return 0x8206703C;
		  /* 8206703Ch */ case    3:  		/* rlwinm R8, R8, 30, 28, 31 */
		/* 8206703Ch case    3:*/		cpu::op::rlwinm<0,30,28,31>(regs,&regs.R8,regs.R8);
		/* 8206703Ch case    3:*/		return 0x82067040;
	}
	return 0x82067040;
} // Block from 82067030h-82067040h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82067040h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067040( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067040) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067040);
		  /* 82067040h */ case    0:  		/* lwz R7, <#[R5 + 44]> */
		/* 82067040h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R5 + 0x0000002C) );
		/* 82067040h case    0:*/		return 0x82067044;
		  /* 82067044h */ case    1:  		/* rlwimi R10, R8, 2, 26, 29 */
		/* 82067044h case    1:*/		cpu::op::rlwimi<0,2,26,29>(regs,&regs.R10,regs.R8);
		/* 82067044h case    1:*/		return 0x82067048;
		  /* 82067048h */ case    2:  		/* lbz R9, <#[R9 + 12382]> */
		/* 82067048h case    2:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R9 + 0x0000305E) );
		/* 82067048h case    2:*/		return 0x8206704C;
		  /* 8206704Ch */ case    3:  		/* rlwinm R8, R7, 26, 28, 31 */
		/* 8206704Ch case    3:*/		cpu::op::rlwinm<0,26,28,31>(regs,&regs.R8,regs.R7);
		/* 8206704Ch case    3:*/		return 0x82067050;
		  /* 82067050h */ case    4:  		/* stw R10, <#[R11 + 16]> */
		/* 82067050h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 82067050h case    4:*/		return 0x82067054;
		  /* 82067054h */ case    5:  		/* cmplw CR6, R8, R9 */
		/* 82067054h case    5:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 82067054h case    5:*/		return 0x82067058;
		  /* 82067058h */ case    6:  		/* bc 4, CR6_LT, 8 */
		/* 82067058h case    6:*/		if ( !regs.CR[6].lt ) { return 0x82067060;  }
		/* 82067058h case    6:*/		return 0x8206705C;
		  /* 8206705Ch */ case    7:  		/* mr R9, R8 */
		/* 8206705Ch case    7:*/		regs.R9 = regs.R8;
		/* 8206705Ch case    7:*/		return 0x82067060;
	}
	return 0x82067060;
} // Block from 82067040h-82067060h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82067060h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067060( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067060) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067060);
		  /* 82067060h */ case    0:  		/* ld R8, <#[R31 + 24]> */
		/* 82067060h case    0:*/		cpu::mem::load64( regs, &regs.R8, (uint32)(regs.R31 + 0x00000018) );
		/* 82067060h case    0:*/		return 0x82067064;
		  /* 82067064h */ case    1:  		/* rlwimi R10, R9, 6, 22, 25 */
		/* 82067064h case    1:*/		cpu::op::rlwimi<0,6,22,25>(regs,&regs.R10,regs.R9);
		/* 82067064h case    1:*/		return 0x82067068;
		  /* 82067068h */ case    2:  		/* or R9, R8, R6 */
		/* 82067068h case    2:*/		cpu::op::or<0>(regs,&regs.R9,regs.R8,regs.R6);
		/* 82067068h case    2:*/		return 0x8206706C;
		  /* 8206706Ch */ case    3:  		/* stw R10, <#[R11 + 16]> */
		/* 8206706Ch case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 8206706Ch case    3:*/		return 0x82067070;
		  /* 82067070h */ case    4:  		/* std R9, <#[R31 + 24]> */
		/* 82067070h case    4:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R31 + 0x00000018) );
		/* 82067070h case    4:*/		return 0x82067074;
		  /* 82067074h */ case    5:  		/* b 16 */
		/* 82067074h case    5:*/		return 0x82067084;
		/* 82067074h case    5:*/		return 0x82067078;
	}
	return 0x82067078;
} // Block from 82067060h-82067078h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82067078h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067078);
		  /* 82067078h */ case    0:  		/* lwzx R10, <#[R11 + R31]> */
		/* 82067078h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82067078h case    0:*/		return 0x8206707C;
		  /* 8206707Ch */ case    1:  		/* rlwinm R10, R10, 0, 0, 29 */
		/* 8206707Ch case    1:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R10,regs.R10);
		/* 8206707Ch case    1:*/		return 0x82067080;
		  /* 82067080h */ case    2:  		/* stwx R10, <#[R11 + R31]> */
		/* 82067080h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82067080h case    2:*/		return 0x82067084;
	}
	return 0x82067084;
} // Block from 82067078h-82067084h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82067084h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067084( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067084) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067084);
		  /* 82067084h */ case    0:  		/* stwx R5, <#[R29 + R31]> */
		/* 82067084h case    0:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R29 + regs.R31 + 0x00000000) );
		/* 82067084h case    0:*/		return 0x82067088;
		  /* 82067088h */ case    1:  		/* cmplwi CR6, R28, 0 */
		/* 82067088h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 82067088h case    1:*/		return 0x8206708C;
		  /* 8206708Ch */ case    2:  		/* bc 12, CR6_EQ, 104 */
		/* 8206708Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x820670F4;  }
		/* 8206708Ch case    2:*/		return 0x82067090;
		  /* 82067090h */ case    3:  		/* lwz R11, <#[R31 + 11036]> */
		/* 82067090h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B1C) );
		/* 82067090h case    3:*/		return 0x82067094;
		  /* 82067094h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82067094h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82067094h case    4:*/		return 0x82067098;
		  /* 82067098h */ case    5:  		/* bc 12, CR6_EQ, 12 */
		/* 82067098h case    5:*/		if ( regs.CR[6].eq ) { return 0x820670A4;  }
		/* 82067098h case    5:*/		return 0x8206709C;
		  /* 8206709Ch */ case    6:  		/* stw R11, <#[R28 + 8]> */
		/* 8206709Ch case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 8206709Ch case    6:*/		return 0x820670A0;
		  /* 820670A0h */ case    7:  		/* b 84 */
		/* 820670A0h case    7:*/		return 0x820670F4;
		/* 820670A0h case    7:*/		return 0x820670A4;
	}
	return 0x820670A4;
} // Block from 82067084h-820670A4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820670A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820670A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820670A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820670A4);
		  /* 820670A4h */ case    0:  		/* lwz R11, <#[R31 + 11040]> */
		/* 820670A4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B20) );
		/* 820670A4h case    0:*/		return 0x820670A8;
		  /* 820670A8h */ case    1:  		/* lwz R10, <#[R28]> */
		/* 820670A8h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000000) );
		/* 820670A8h case    1:*/		return 0x820670AC;
		  /* 820670ACh */ case    2:  		/* and. R11, R11, R10 */
		/* 820670ACh case    2:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820670ACh case    2:*/		return 0x820670B0;
		  /* 820670B0h */ case    3:  		/* bc 12, CR0_EQ, 68 */
		/* 820670B0h case    3:*/		if ( regs.CR[0].eq ) { return 0x820670F4;  }
		/* 820670B0h case    3:*/		return 0x820670B4;
		  /* 820670B4h */ case    4:  		/* lwz R11, <#[R31 + 13932]> */
		/* 820670B4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000366C) );
		/* 820670B4h case    4:*/		return 0x820670B8;
		  /* 820670B8h */ case    5:  		/* lwz R3, <#[R31 + 13928]> */
		/* 820670B8h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00003668) );
		/* 820670B8h case    5:*/		return 0x820670BC;
		  /* 820670BCh */ case    6:  		/* cmplw CR6, R3, R11 */
		/* 820670BCh case    6:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 820670BCh case    6:*/		return 0x820670C0;
		  /* 820670C0h */ case    7:  		/* bc 12, CR6_LT, 12 */
		/* 820670C0h case    7:*/		if ( regs.CR[6].lt ) { return 0x820670CC;  }
		/* 820670C0h case    7:*/		return 0x820670C4;
		  /* 820670C4h */ case    8:  		/* mr R3, R31 */
		/* 820670C4h case    8:*/		regs.R3 = regs.R31;
		/* 820670C4h case    8:*/		return 0x820670C8;
		  /* 820670C8h */ case    9:  		/* bl 55464 */
		/* 820670C8h case    9:*/		regs.LR = 0x820670CC; return 0x82074970;
		/* 820670C8h case    9:*/		return 0x820670CC;
	}
	return 0x820670CC;
} // Block from 820670A4h-820670CCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 820670CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820670CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820670CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820670CC);
		  /* 820670CCh */ case    0:  		/* lwz R11, <#[R1 + 80]> */
		/* 820670CCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820670CCh case    0:*/		return 0x820670D0;
		  /* 820670D0h */ case    1:  		/* li R10, -1 */
		/* 820670D0h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 820670D0h case    1:*/		return 0x820670D4;
		  /* 820670D4h */ case    2:  		/* addi R9, R3, 8 */
		/* 820670D4h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R3,0x8);
		/* 820670D4h case    2:*/		return 0x820670D8;
		  /* 820670D8h */ case    3:  		/* rlwimi R11, R28, 30, 2, 31 */
		/* 820670D8h case    3:*/		cpu::op::rlwimi<0,30,2,31>(regs,&regs.R11,regs.R28);
		/* 820670D8h case    3:*/		return 0x820670DC;
		  /* 820670DCh */ case    4:  		/* stw R10, <#[R1 + 84]> */
		/* 820670DCh case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 820670DCh case    4:*/		return 0x820670E0;
		  /* 820670E0h */ case    5:  		/* rlwinm R11, R11, 0, 2, 0 */
		/* 820670E0h case    5:*/		cpu::op::rlwinm<0,0,2,0>(regs,&regs.R11,regs.R11);
		/* 820670E0h case    5:*/		return 0x820670E4;
		  /* 820670E4h */ case    6:  		/* stw R11, <#[R1 + 80]> */
		/* 820670E4h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820670E4h case    6:*/		return 0x820670E8;
		  /* 820670E8h */ case    7:  		/* ld R11, <#[R1 + 80]> */
		/* 820670E8h case    7:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820670E8h case    7:*/		return 0x820670EC;
		  /* 820670ECh */ case    8:  		/* std R11, <#[R3]> */
		/* 820670ECh case    8:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820670ECh case    8:*/		return 0x820670F0;
		  /* 820670F0h */ case    9:  		/* stw R9, <#[R31 + 13928]> */
		/* 820670F0h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00003668) );
		/* 820670F0h case    9:*/		return 0x820670F4;
	}
	return 0x820670F4;
} // Block from 820670CCh-820670F4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820670F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820670F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820670F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820670F4);
		  /* 820670F4h */ case    0:  		/* addi R1, R1, 192 */
		/* 820670F4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 820670F4h case    0:*/		return 0x820670F8;
		  /* 820670F8h */ case    1:  		/* b 172432 */
		/* 820670F8h case    1:*/		return 0x82091288;
		/* 820670F8h case    1:*/		return 0x820670FC;
		  /* 820670FCh */ case    2:  		/* nop */
		/* 820670FCh case    2:*/		cpu::op::nop();
		/* 820670FCh case    2:*/		return 0x82067100;
	}
	return 0x82067100;
} // Block from 820670F4h-82067100h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82067100h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067100( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067100) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067100);
		  /* 82067100h */ case    0:  		/* mfspr R12, LR */
		/* 82067100h case    0:*/		regs.R12 = regs.LR;
		/* 82067100h case    0:*/		return 0x82067104;
		  /* 82067104h */ case    1:  		/* bl 172372 */
		/* 82067104h case    1:*/		regs.LR = 0x82067108; return 0x82091258;
		/* 82067104h case    1:*/		return 0x82067108;
		  /* 82067108h */ case    2:  		/* lis R10, 42 */
		/* 82067108h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0x2A);
		/* 82067108h case    2:*/		return 0x8206710C;
		  /* 8206710Ch */ case    3:  		/* lis R9, 24 */
		/* 8206710Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R9,0x18);
		/* 8206710Ch case    3:*/		return 0x82067110;
		  /* 82067110h */ case    4:  		/* lis R5, 44 */
		/* 82067110h case    4:*/		cpu::op::lis<0>(regs,&regs.R5,0x2C);
		/* 82067110h case    4:*/		return 0x82067114;
		  /* 82067114h */ case    5:  		/* li R11, 0 */
		/* 82067114h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82067114h case    5:*/		return 0x82067118;
		  /* 82067118h */ case    6:  		/* andi. R7, R3, 16398 */
		/* 82067118h case    6:*/		cpu::op::andi<1>(regs,&regs.R7,regs.R3,0x400E);
		/* 82067118h case    6:*/		return 0x8206711C;
		  /* 8206711Ch */ case    7:  		/* ori R6, R10, 9145 */
		/* 8206711Ch case    7:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R10,0x23B9);
		/* 8206711Ch case    7:*/		return 0x82067120;
		  /* 82067120h */ case    8:  		/* ori R31, R9, 10374 */
		/* 82067120h case    8:*/		cpu::op::ori<0>(regs,&regs.R31,regs.R9,0x2886);
		/* 82067120h case    8:*/		return 0x82067124;
		  /* 82067124h */ case    9:  		/* ori R30, R5, 33700 */
		/* 82067124h case    9:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R5,0x83A4);
		/* 82067124h case    9:*/		return 0x82067128;
	}
	return 0x82067128;
} // Block from 82067100h-82067128h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82067128h
// Function 'D3DDevice_SetVertexShader'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067128( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067128) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067128);
		  /* 82067128h */ case    0:  		/* mr R8, R11 */
		/* 82067128h case    0:*/		regs.R8 = regs.R11;
		/* 82067128h case    0:*/		return 0x8206712C;
		  /* 8206712Ch */ case    1:  		/* li R5, 1 */
		/* 8206712Ch case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8206712Ch case    1:*/		return 0x82067130;
		  /* 82067130h */ case    2:  		/* mr R9, R11 */
		/* 82067130h case    2:*/		regs.R9 = regs.R11;
		/* 82067130h case    2:*/		return 0x82067134;
		  /* 82067134h */ case    3:  		/* addi R10, R4, 52 */
		/* 82067134h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x34);
		/* 82067134h case    3:*/		return 0x82067138;
		  /* 82067138h */ case    4:  		/* cmplwi CR6, R7, 2 */
		/* 82067138h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000002);
		/* 82067138h case    4:*/		return 0x8206713C;
		  /* 8206713Ch */ case    5:  		/* bc 12, CR6_EQ, 840 */
		/* 8206713Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x82067484;  }
		/* 8206713Ch case    5:*/		return 0x82067140;
		  /* 82067140h */ case    6:  		/* cmplwi CR6, R7, 6 */
		/* 82067140h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000006);
		/* 82067140h case    6:*/		return 0x82067144;
		  /* 82067144h */ case    7:  		/* bc 12, CR6_EQ, 696 */
		/* 82067144h case    7:*/		if ( regs.CR[6].eq ) { return 0x820673FC;  }
		/* 82067144h case    7:*/		return 0x82067148;
		  /* 82067148h */ case    8:  		/* cmplwi CR6, R7, 8 */
		/* 82067148h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000008);
		/* 82067148h case    8:*/		return 0x8206714C;
		  /* 8206714Ch */ case    9:  		/* bc 12, CR6_EQ, 564 */
		/* 8206714Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x82067380;  }
		/* 8206714Ch case    9:*/		return 0x82067150;
		  /* 82067150h */ case   10:  		/* cmplwi CR6, R7, 10 */
		/* 82067150h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x0000000A);
		/* 82067150h case   10:*/		return 0x82067154;
		  /* 82067154h */ case   11:  		/* bc 12, CR6_EQ, 408 */
		/* 82067154h case   11:*/		if ( regs.CR[6].eq ) { return 0x820672EC;  }
		/* 82067154h case   11:*/		return 0x82067158;
		  /* 82067158h */ case   12:  		/* cmplwi CR6, R7, 12 */
		/* 82067158h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x0000000C);
		/* 82067158h case   12:*/		return 0x8206715C;
		  /* 8206715Ch */ case   13:  		/* bc 12, CR6_EQ, 204 */
		/* 8206715Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x82067228;  }
		/* 8206715Ch case   13:*/		return 0x82067160;
		  /* 82067160h */ case   14:  		/* cmplwi CR6, R7, 14 */
		/* 82067160h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x0000000E);
		/* 82067160h case   14:*/		return 0x82067164;
		  /* 82067164h */ case   15:  		/* bc 12, CR6_EQ, 32 */
		/* 82067164h case   15:*/		if ( regs.CR[6].eq ) { return 0x82067184;  }
		/* 82067164h case   15:*/		return 0x82067168;
		  /* 82067168h */ case   16:  		/* cmplwi CR6, R7, 16386 */
		/* 82067168h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00004002);
		/* 82067168h case   16:*/		return 0x8206716C;
		  /* 8206716Ch */ case   17:  		/* bc 4, CR6_EQ, 828 */
		/* 8206716Ch case   17:*/		if ( !regs.CR[6].eq ) { return 0x820674A8;  }
		/* 8206716Ch case   17:*/		return 0x82067170;
		  /* 82067170h */ case   18:  		/* lis R9, 26 */
		/* 82067170h case   18:*/		cpu::op::lis<0>(regs,&regs.R9,0x1A);
		/* 82067170h case   18:*/		return 0x82067174;
		  /* 82067174h */ case   19:  		/* ori R7, R9, 9126 */
		/* 82067174h case   19:*/		cpu::op::ori<0>(regs,&regs.R7,regs.R9,0x23A6);
		/* 82067174h case   19:*/		return 0x82067178;
		  /* 82067178h */ case   20:  		/* li R9, 16 */
		/* 82067178h case   20:*/		cpu::op::li<0>(regs,&regs.R9,0x10);
		/* 82067178h case   20:*/		return 0x8206717C;
		  /* 8206717Ch */ case   21:  		/* stw R7, <#[R10 + 4]> */
		/* 8206717Ch case   21:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x00000004) );
		/* 8206717Ch case   21:*/		return 0x82067180;
		  /* 82067180h */ case   22:  		/* b 780 */
		/* 82067180h case   22:*/		return 0x8206748C;
		/* 82067180h case   22:*/		return 0x82067184;
	}
	return 0x82067184;
} // Block from 82067128h-82067184h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82067184h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067184( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067184) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067184);
		  /* 82067184h */ case    0:  		/* sth R11, <#[R10]> */
		/* 82067184h case    0:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82067184h case    0:*/		return 0x82067188;
		  /* 82067188h */ case    1:  		/* lis R9, 26 */
		/* 82067188h case    1:*/		cpu::op::lis<0>(regs,&regs.R9,0x1A);
		/* 82067188h case    1:*/		return 0x8206718C;
		  /* 8206718Ch */ case    2:  		/* sth R11, <#[R10 + 2]> */
		/* 8206718Ch case    2:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R10 + 0x00000002) );
		/* 8206718Ch case    2:*/		return 0x82067190;
		  /* 82067190h */ case    3:  		/* li R8, 12 */
		/* 82067190h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0xC);
		/* 82067190h case    3:*/		return 0x82067194;
		  /* 82067194h */ case    4:  		/* stw R6, <#[R10 + 4]> */
		/* 82067194h case    4:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 82067194h case    4:*/		return 0x82067198;
		  /* 82067198h */ case    5:  		/* ori R9, R9, 9126 */
		/* 82067198h case    5:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x23A6);
		/* 82067198h case    5:*/		return 0x8206719C;
		  /* 8206719Ch */ case    6:  		/* stb R11, <#[R10 + 8]> */
		/* 8206719Ch case    6:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 8206719Ch case    6:*/		return 0x820671A0;
		  /* 820671A0h */ case    7:  		/* rlwinm. R7, R3, 0, 19, 19 */
		/* 820671A0h case    7:*/		cpu::op::rlwinm<1,0,19,19>(regs,&regs.R7,regs.R3);
		/* 820671A0h case    7:*/		return 0x820671A4;
		  /* 820671A4h */ case    8:  		/* stb R11, <#[R10 + 9]> */
		/* 820671A4h case    8:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x00000009) );
		/* 820671A4h case    8:*/		return 0x820671A8;
		  /* 820671A8h */ case    9:  		/* li R7, 2 */
		/* 820671A8h case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 820671A8h case    9:*/		return 0x820671AC;
		  /* 820671ACh */ case   10:  		/* stb R11, <#[R10 + 10]> */
		/* 820671ACh case   10:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x0000000A) );
		/* 820671ACh case   10:*/		return 0x820671B0;
		  /* 820671B0h */ case   11:  		/* sthu R11, <#[R10 + 12]> */
		/* 820671B0h case   11:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		regs.R10 = (uint32)(regs.R10 + 0x0000000C);
		/* 820671B0h case   11:*/		return 0x820671B4;
		  /* 820671B4h */ case   12:  		/* sth R8, <#[R10 + 2]> */
		/* 820671B4h case   12:*/		cpu::mem::store16( regs, regs.R8, (uint32)(regs.R10 + 0x00000002) );
		/* 820671B4h case   12:*/		return 0x820671B8;
		  /* 820671B8h */ case   13:  		/* stw R9, <#[R10 + 4]> */
		/* 820671B8h case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 820671B8h case   13:*/		return 0x820671BC;
		  /* 820671BCh */ case   14:  		/* stb R11, <#[R10 + 8]> */
		/* 820671BCh case   14:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 820671BCh case   14:*/		return 0x820671C0;
		  /* 820671C0h */ case   15:  		/* stb R5, <#[R10 + 9]> */
		/* 820671C0h case   15:*/		cpu::mem::store8( regs, regs.R5, (uint32)(regs.R10 + 0x00000009) );
		/* 820671C0h case   15:*/		return 0x820671C4;
		  /* 820671C4h */ case   16:  		/* stb R11, <#[R10 + 10]> */
		/* 820671C4h case   16:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x0000000A) );
		/* 820671C4h case   16:*/		return 0x820671C8;
		  /* 820671C8h */ case   17:  		/* addi R10, R10, 12 */
		/* 820671C8h case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xC);
		/* 820671C8h case   17:*/		return 0x820671CC;
		  /* 820671CCh */ case   18:  		/* stb R7, <#[R10 + 9]> */
		/* 820671CCh case   18:*/		cpu::mem::store8( regs, regs.R7, (uint32)(regs.R10 + 0x00000009) );
		/* 820671CCh case   18:*/		return 0x820671D0;
		  /* 820671D0h */ case   19:  		/* bc 12, CR0_EQ, 36 */
		/* 820671D0h case   19:*/		if ( regs.CR[0].eq ) { return 0x820671F4;  }
		/* 820671D0h case   19:*/		return 0x820671D4;
		  /* 820671D4h */ case   20:  		/* lis R9, 26 */
		/* 820671D4h case   20:*/		cpu::op::lis<0>(regs,&regs.R9,0x1A);
		/* 820671D4h case   20:*/		return 0x820671D8;
		  /* 820671D8h */ case   21:  		/* li R8, 28 */
		/* 820671D8h case   21:*/		cpu::op::li<0>(regs,&regs.R8,0x1C);
		/* 820671D8h case   21:*/		return 0x820671DC;
		  /* 820671DCh */ case   22:  		/* ori R9, R9, 8838 */
		/* 820671DCh case   22:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x2286);
		/* 820671DCh case   22:*/		return 0x820671E0;
		  /* 820671E0h */ case   23:  		/* sth R8, <#[R10 + 2]> */
		/* 820671E0h case   23:*/		cpu::mem::store16( regs, regs.R8, (uint32)(regs.R10 + 0x00000002) );
		/* 820671E0h case   23:*/		return 0x820671E4;
		  /* 820671E4h */ case   24:  		/* li R8, 3 */
		/* 820671E4h case   24:*/		cpu::op::li<0>(regs,&regs.R8,0x3);
		/* 820671E4h case   24:*/		return 0x820671E8;
		  /* 820671E8h */ case   25:  		/* stw R9, <#[R10 + 4]> */
		/* 820671E8h case   25:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 820671E8h case   25:*/		return 0x820671EC;
		  /* 820671ECh */ case   26:  		/* li R9, 32 */
		/* 820671ECh case   26:*/		cpu::op::li<0>(regs,&regs.R9,0x20);
		/* 820671ECh case   26:*/		return 0x820671F0;
		  /* 820671F0h */ case   27:  		/* b 680 */
		/* 820671F0h case   27:*/		return 0x82067498;
		/* 820671F0h case   27:*/		return 0x820671F4;
	}
	return 0x820671F4;
} // Block from 82067184h-820671F4h (28 instructions)

//////////////////////////////////////////////////////
// Block at 820671F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820671F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820671F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820671F4);
		  /* 820671F4h */ case    0:  		/* rlwinm. R9, R3, 0, 16, 16 */
		/* 820671F4h case    0:*/		cpu::op::rlwinm<1,0,16,16>(regs,&regs.R9,regs.R3);
		/* 820671F4h case    0:*/		return 0x820671F8;
		  /* 820671F8h */ case    1:  		/* sth R11, <#[R10]> */
		/* 820671F8h case    1:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820671F8h case    1:*/		return 0x820671FC;
		  /* 820671FCh */ case    2:  		/* li R9, 28 */
		/* 820671FCh case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x1C);
		/* 820671FCh case    2:*/		return 0x82067200;
		  /* 82067200h */ case    3:  		/* stb R11, <#[R10 + 8]> */
		/* 82067200h case    3:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 82067200h case    3:*/		return 0x82067204;
		  /* 82067204h */ case    4:  		/* li R8, 3 */
		/* 82067204h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x3);
		/* 82067204h case    4:*/		return 0x82067208;
		  /* 82067208h */ case    5:  		/* stb R11, <#[R10 + 10]> */
		/* 82067208h case    5:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x0000000A) );
		/* 82067208h case    5:*/		return 0x8206720C;
		  /* 8206720Ch */ case    6:  		/* sth R9, <#[R10 + 2]> */
		/* 8206720Ch case    6:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R10 + 0x00000002) );
		/* 8206720Ch case    6:*/		return 0x82067210;
		  /* 82067210h */ case    7:  		/* li R9, 32 */
		/* 82067210h case    7:*/		cpu::op::li<0>(regs,&regs.R9,0x20);
		/* 82067210h case    7:*/		return 0x82067214;
		  /* 82067214h */ case    8:  		/* bc 12, CR0_EQ, 12 */
		/* 82067214h case    8:*/		if ( regs.CR[0].eq ) { return 0x82067220;  }
		/* 82067214h case    8:*/		return 0x82067218;
		  /* 82067218h */ case    9:  		/* stw R31, <#[R10 + 4]> */
		/* 82067218h case    9:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R10 + 0x00000004) );
		/* 82067218h case    9:*/		return 0x8206721C;
		  /* 8206721Ch */ case   10:  		/* b 648 */
		/* 8206721Ch case   10:*/		return 0x820674A4;
		/* 8206721Ch case   10:*/		return 0x82067220;
	}
	return 0x82067220;
} // Block from 820671F4h-82067220h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82067220h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067220( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067220) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067220);
		  /* 82067220h */ case    0:  		/* stw R30, <#[R10 + 4]> */
		/* 82067220h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R10 + 0x00000004) );
		/* 82067220h case    0:*/		return 0x82067224;
		  /* 82067224h */ case    1:  		/* b 640 */
		/* 82067224h case    1:*/		return 0x820674A4;
		/* 82067224h case    1:*/		return 0x82067228;
	}
	return 0x82067228;
} // Block from 82067220h-82067228h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82067228h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067228( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067228) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067228);
		  /* 82067228h */ case    0:  		/* sth R11, <#[R10]> */
		/* 82067228h case    0:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82067228h case    0:*/		return 0x8206722C;
		  /* 8206722Ch */ case    1:  		/* rlwinm. R9, R3, 0, 19, 19 */
		/* 8206722Ch case    1:*/		cpu::op::rlwinm<1,0,19,19>(regs,&regs.R9,regs.R3);
		/* 8206722Ch case    1:*/		return 0x82067230;
		  /* 82067230h */ case    2:  		/* sth R11, <#[R10 + 2]> */
		/* 82067230h case    2:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R10 + 0x00000002) );
		/* 82067230h case    2:*/		return 0x82067234;
		  /* 82067234h */ case    3:  		/* stw R6, <#[R10 + 4]> */
		/* 82067234h case    3:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 82067234h case    3:*/		return 0x82067238;
		  /* 82067238h */ case    4:  		/* stb R11, <#[R10 + 8]> */
		/* 82067238h case    4:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 82067238h case    4:*/		return 0x8206723C;
		  /* 8206723Ch */ case    5:  		/* stb R11, <#[R10 + 9]> */
		/* 8206723Ch case    5:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x00000009) );
		/* 8206723Ch case    5:*/		return 0x82067240;
		  /* 82067240h */ case    6:  		/* stb R11, <#[R10 + 10]> */
		/* 82067240h case    6:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x0000000A) );
		/* 82067240h case    6:*/		return 0x82067244;
		  /* 82067244h */ case    7:  		/* addi R10, R10, 12 */
		/* 82067244h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xC);
		/* 82067244h case    7:*/		return 0x82067248;
		  /* 82067248h */ case    8:  		/* sth R11, <#[R10]> */
		/* 82067248h case    8:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82067248h case    8:*/		return 0x8206724C;
		  /* 8206724Ch */ case    9:  		/* stb R11, <#[R10 + 8]> */
		/* 8206724Ch case    9:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 8206724Ch case    9:*/		return 0x82067250;
		  /* 82067250h */ case   10:  		/* stb R5, <#[R10 + 9]> */
		/* 82067250h case   10:*/		cpu::mem::store8( regs, regs.R5, (uint32)(regs.R10 + 0x00000009) );
		/* 82067250h case   10:*/		return 0x82067254;
		  /* 82067254h */ case   11:  		/* stb R11, <#[R10 + 10]> */
		/* 82067254h case   11:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x0000000A) );
		/* 82067254h case   11:*/		return 0x82067258;
		  /* 82067258h */ case   12:  		/* bc 12, CR0_EQ, 60 */
		/* 82067258h case   12:*/		if ( regs.CR[0].eq ) { return 0x82067294;  }
		/* 82067258h case   12:*/		return 0x8206725C;
		  /* 8206725Ch */ case   13:  		/* li R9, 12 */
		/* 8206725Ch case   13:*/		cpu::op::li<0>(regs,&regs.R9,0xC);
		/* 8206725Ch case   13:*/		return 0x82067260;
		  /* 82067260h */ case   14:  		/* stw R6, <#[R10 + 4]> */
		/* 82067260h case   14:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 82067260h case   14:*/		return 0x82067264;
		  /* 82067264h */ case   15:  		/* li R7, 24 */
		/* 82067264h case   15:*/		cpu::op::li<0>(regs,&regs.R7,0x18);
		/* 82067264h case   15:*/		return 0x82067268;
		  /* 82067268h */ case   16:  		/* sth R9, <#[R10 + 2]> */
		/* 82067268h case   16:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R10 + 0x00000002) );
		/* 82067268h case   16:*/		return 0x8206726C;
		  /* 8206726Ch */ case   17:  		/* li R9, 28 */
		/* 8206726Ch case   17:*/		cpu::op::li<0>(regs,&regs.R9,0x1C);
		/* 8206726Ch case   17:*/		return 0x82067270;
		  /* 82067270h */ case   18:  		/* sthu R11, <#[R10 + 12]> */
		/* 82067270h case   18:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		regs.R10 = (uint32)(regs.R10 + 0x0000000C);
		/* 82067270h case   18:*/		return 0x82067274;
		  /* 82067274h */ case   19:  		/* lis R8, 26 */
		/* 82067274h case   19:*/		cpu::op::lis<0>(regs,&regs.R8,0x1A);
		/* 82067274h case   19:*/		return 0x82067278;
		  /* 82067278h */ case   20:  		/* li R28, 2 */
		/* 82067278h case   20:*/		cpu::op::li<0>(regs,&regs.R28,0x2);
		/* 82067278h case   20:*/		return 0x8206727C;
		  /* 8206727Ch */ case   21:  		/* ori R29, R8, 8838 */
		/* 8206727Ch case   21:*/		cpu::op::ori<0>(regs,&regs.R29,regs.R8,0x2286);
		/* 8206727Ch case   21:*/		return 0x82067280;
		  /* 82067280h */ case   22:  		/* li R8, 3 */
		/* 82067280h case   22:*/		cpu::op::li<0>(regs,&regs.R8,0x3);
		/* 82067280h case   22:*/		return 0x82067284;
		  /* 82067284h */ case   23:  		/* sth R7, <#[R10 + 2]> */
		/* 82067284h case   23:*/		cpu::mem::store16( regs, regs.R7, (uint32)(regs.R10 + 0x00000002) );
		/* 82067284h case   23:*/		return 0x82067288;
		  /* 82067288h */ case   24:  		/* stw R29, <#[R10 + 4]> */
		/* 82067288h case   24:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R10 + 0x00000004) );
		/* 82067288h case   24:*/		return 0x8206728C;
		  /* 8206728Ch */ case   25:  		/* stb R28, <#[R10 + 9]> */
		/* 8206728Ch case   25:*/		cpu::mem::store8( regs, regs.R28, (uint32)(regs.R10 + 0x00000009) );
		/* 8206728Ch case   25:*/		return 0x82067290;
		  /* 82067290h */ case   26:  		/* b 524 */
		/* 82067290h case   26:*/		return 0x8206749C;
		/* 82067290h case   26:*/		return 0x82067294;
	}
	return 0x82067294;
} // Block from 82067228h-82067294h (27 instructions)

//////////////////////////////////////////////////////
// Block at 82067294h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067294( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067294) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067294);
		  /* 82067294h */ case    0:  		/* rlwinm. R9, R3, 0, 16, 16 */
		/* 82067294h case    0:*/		cpu::op::rlwinm<1,0,16,16>(regs,&regs.R9,regs.R3);
		/* 82067294h case    0:*/		return 0x82067298;
		  /* 82067298h */ case    1:  		/* bc 12, CR0_EQ, 52 */
		/* 82067298h case    1:*/		if ( regs.CR[0].eq ) { return 0x820672CC;  }
		/* 82067298h case    1:*/		return 0x8206729C;
		  /* 8206729Ch */ case    2:  		/* li R9, 12 */
		/* 8206729Ch case    2:*/		cpu::op::li<0>(regs,&regs.R9,0xC);
		/* 8206729Ch case    2:*/		return 0x820672A0;
		  /* 820672A0h */ case    3:  		/* stw R6, <#[R10 + 4]> */
		/* 820672A0h case    3:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 820672A0h case    3:*/		return 0x820672A4;
		  /* 820672A4h */ case    4:  		/* li R7, 24 */
		/* 820672A4h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x18);
		/* 820672A4h case    4:*/		return 0x820672A8;
		  /* 820672A8h */ case    5:  		/* sth R9, <#[R10 + 2]> */
		/* 820672A8h case    5:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R10 + 0x00000002) );
		/* 820672A8h case    5:*/		return 0x820672AC;
		  /* 820672ACh */ case    6:  		/* li R9, 28 */
		/* 820672ACh case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x1C);
		/* 820672ACh case    6:*/		return 0x820672B0;
		  /* 820672B0h */ case    7:  		/* sthu R11, <#[R10 + 12]> */
		/* 820672B0h case    7:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		regs.R10 = (uint32)(regs.R10 + 0x0000000C);
		/* 820672B0h case    7:*/		return 0x820672B4;
		  /* 820672B4h */ case    8:  		/* li R29, 2 */
		/* 820672B4h case    8:*/		cpu::op::li<0>(regs,&regs.R29,0x2);
		/* 820672B4h case    8:*/		return 0x820672B8;
		  /* 820672B8h */ case    9:  		/* li R8, 3 */
		/* 820672B8h case    9:*/		cpu::op::li<0>(regs,&regs.R8,0x3);
		/* 820672B8h case    9:*/		return 0x820672BC;
		  /* 820672BCh */ case   10:  		/* sth R7, <#[R10 + 2]> */
		/* 820672BCh case   10:*/		cpu::mem::store16( regs, regs.R7, (uint32)(regs.R10 + 0x00000002) );
		/* 820672BCh case   10:*/		return 0x820672C0;
		  /* 820672C0h */ case   11:  		/* stw R31, <#[R10 + 4]> */
		/* 820672C0h case   11:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R10 + 0x00000004) );
		/* 820672C0h case   11:*/		return 0x820672C4;
		  /* 820672C4h */ case   12:  		/* stb R29, <#[R10 + 9]> */
		/* 820672C4h case   12:*/		cpu::mem::store8( regs, regs.R29, (uint32)(regs.R10 + 0x00000009) );
		/* 820672C4h case   12:*/		return 0x820672C8;
		  /* 820672C8h */ case   13:  		/* b 468 */
		/* 820672C8h case   13:*/		return 0x8206749C;
		/* 820672C8h case   13:*/		return 0x820672CC;
	}
	return 0x820672CC;
} // Block from 82067294h-820672CCh (14 instructions)

//////////////////////////////////////////////////////
// Block at 820672CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820672CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820672CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820672CC);
		  /* 820672CCh */ case    0:  		/* lis R9, 26 */
		/* 820672CCh case    0:*/		cpu::op::lis<0>(regs,&regs.R9,0x1A);
		/* 820672CCh case    0:*/		return 0x820672D0;
		  /* 820672D0h */ case    1:  		/* li R8, 12 */
		/* 820672D0h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0xC);
		/* 820672D0h case    1:*/		return 0x820672D4;
		  /* 820672D4h */ case    2:  		/* ori R9, R9, 9126 */
		/* 820672D4h case    2:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x23A6);
		/* 820672D4h case    2:*/		return 0x820672D8;
		  /* 820672D8h */ case    3:  		/* sth R8, <#[R10 + 2]> */
		/* 820672D8h case    3:*/		cpu::mem::store16( regs, regs.R8, (uint32)(regs.R10 + 0x00000002) );
		/* 820672D8h case    3:*/		return 0x820672DC;
		  /* 820672DCh */ case    4:  		/* li R8, 2 */
		/* 820672DCh case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x2);
		/* 820672DCh case    4:*/		return 0x820672E0;
		  /* 820672E0h */ case    5:  		/* stw R9, <#[R10 + 4]> */
		/* 820672E0h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 820672E0h case    5:*/		return 0x820672E4;
		  /* 820672E4h */ case    6:  		/* li R9, 28 */
		/* 820672E4h case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x1C);
		/* 820672E4h case    6:*/		return 0x820672E8;
		  /* 820672E8h */ case    7:  		/* b 444 */
		/* 820672E8h case    7:*/		return 0x820674A4;
		/* 820672E8h case    7:*/		return 0x820672EC;
	}
	return 0x820672EC;
} // Block from 820672CCh-820672ECh (8 instructions)

//////////////////////////////////////////////////////
// Block at 820672ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820672EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820672EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820672EC);
		  /* 820672ECh */ case    0:  		/* sth R11, <#[R10]> */
		/* 820672ECh case    0:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820672ECh case    0:*/		return 0x820672F0;
		  /* 820672F0h */ case    1:  		/* rlwinm. R9, R3, 0, 19, 19 */
		/* 820672F0h case    1:*/		cpu::op::rlwinm<1,0,19,19>(regs,&regs.R9,regs.R3);
		/* 820672F0h case    1:*/		return 0x820672F4;
		  /* 820672F4h */ case    2:  		/* sth R11, <#[R10 + 2]> */
		/* 820672F4h case    2:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R10 + 0x00000002) );
		/* 820672F4h case    2:*/		return 0x820672F8;
	}
	return 0x820672F8;
} // Block from 820672ECh-820672F8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820672F8h
// Function 'D3DDevice_SetShaderGPRAllocation'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820672F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820672F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820672F8);
		  /* 820672F8h */ case    0:  		/* stw R6, <#[R10 + 4]> */
		/* 820672F8h case    0:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 820672F8h case    0:*/		return 0x820672FC;
		  /* 820672FCh */ case    1:  		/* stb R11, <#[R10 + 8]> */
		/* 820672FCh case    1:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 820672FCh case    1:*/		return 0x82067300;
		  /* 82067300h */ case    2:  		/* stb R11, <#[R10 + 9]> */
		/* 82067300h case    2:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x00000009) );
		/* 82067300h case    2:*/		return 0x82067304;
		  /* 82067304h */ case    3:  		/* stb R11, <#[R10 + 10]> */
		/* 82067304h case    3:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x0000000A) );
		/* 82067304h case    3:*/		return 0x82067308;
		  /* 82067308h */ case    4:  		/* addi R10, R10, 12 */
		/* 82067308h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xC);
		/* 82067308h case    4:*/		return 0x8206730C;
		  /* 8206730Ch */ case    5:  		/* sth R11, <#[R10]> */
		/* 8206730Ch case    5:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8206730Ch case    5:*/		return 0x82067310;
		  /* 82067310h */ case    6:  		/* stb R11, <#[R10 + 8]> */
		/* 82067310h case    6:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 82067310h case    6:*/		return 0x82067314;
		  /* 82067314h */ case    7:  		/* stb R5, <#[R10 + 9]> */
		/* 82067314h case    7:*/		cpu::mem::store8( regs, regs.R5, (uint32)(regs.R10 + 0x00000009) );
		/* 82067314h case    7:*/		return 0x82067318;
		  /* 82067318h */ case    8:  		/* stb R11, <#[R10 + 10]> */
		/* 82067318h case    8:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x0000000A) );
		/* 82067318h case    8:*/		return 0x8206731C;
		  /* 8206731Ch */ case    9:  		/* bc 12, CR0_EQ, 36 */
		/* 8206731Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x82067340;  }
		/* 8206731Ch case    9:*/		return 0x82067320;
		  /* 82067320h */ case   10:  		/* lis R9, 44 */
		/* 82067320h case   10:*/		cpu::op::lis<0>(regs,&regs.R9,0x2C);
		/* 82067320h case   10:*/		return 0x82067324;
		  /* 82067324h */ case   11:  		/* li R8, 12 */
		/* 82067324h case   11:*/		cpu::op::li<0>(regs,&regs.R8,0xC);
		/* 82067324h case   11:*/		return 0x82067328;
		  /* 82067328h */ case   12:  		/* ori R9, R9, 9125 */
		/* 82067328h case   12:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x23A5);
		/* 82067328h case   12:*/		return 0x8206732C;
		  /* 8206732Ch */ case   13:  		/* sth R8, <#[R10 + 2]> */
		/* 8206732Ch case   13:*/		cpu::mem::store16( regs, regs.R8, (uint32)(regs.R10 + 0x00000002) );
		/* 8206732Ch case   13:*/		return 0x82067330;
		  /* 82067330h */ case   14:  		/* li R7, 20 */
		/* 82067330h case   14:*/		cpu::op::li<0>(regs,&regs.R7,0x14);
		/* 82067330h case   14:*/		return 0x82067334;
		  /* 82067334h */ case   15:  		/* stw R9, <#[R10 + 4]> */
		/* 82067334h case   15:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 82067334h case   15:*/		return 0x82067338;
		  /* 82067338h */ case   16:  		/* li R9, 24 */
		/* 82067338h case   16:*/		cpu::op::li<0>(regs,&regs.R9,0x18);
		/* 82067338h case   16:*/		return 0x8206733C;
		  /* 8206733Ch */ case   17:  		/* b -204 */
		/* 8206733Ch case   17:*/		return 0x82067270;
		/* 8206733Ch case   17:*/		return 0x82067340;
	}
	return 0x82067340;
} // Block from 820672F8h-82067340h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82067340h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067340( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067340) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067340);
		  /* 82067340h */ case    0:  		/* rlwinm. R9, R3, 0, 16, 16 */
		/* 82067340h case    0:*/		cpu::op::rlwinm<1,0,16,16>(regs,&regs.R9,regs.R3);
		/* 82067340h case    0:*/		return 0x82067344;
		  /* 82067344h */ case    1:  		/* bc 12, CR0_EQ, 36 */
		/* 82067344h case    1:*/		if ( regs.CR[0].eq ) { return 0x82067368;  }
		/* 82067344h case    1:*/		return 0x82067348;
		  /* 82067348h */ case    2:  		/* lis R9, 44 */
		/* 82067348h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0x2C);
		/* 82067348h case    2:*/		return 0x8206734C;
		  /* 8206734Ch */ case    3:  		/* li R8, 12 */
		/* 8206734Ch case    3:*/		cpu::op::li<0>(regs,&regs.R8,0xC);
		/* 8206734Ch case    3:*/		return 0x82067350;
		  /* 82067350h */ case    4:  		/* ori R9, R9, 9125 */
		/* 82067350h case    4:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x23A5);
		/* 82067350h case    4:*/		return 0x82067354;
		  /* 82067354h */ case    5:  		/* sth R8, <#[R10 + 2]> */
		/* 82067354h case    5:*/		cpu::mem::store16( regs, regs.R8, (uint32)(regs.R10 + 0x00000002) );
		/* 82067354h case    5:*/		return 0x82067358;
		  /* 82067358h */ case    6:  		/* li R7, 20 */
		/* 82067358h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x14);
		/* 82067358h case    6:*/		return 0x8206735C;
		  /* 8206735Ch */ case    7:  		/* stw R9, <#[R10 + 4]> */
		/* 8206735Ch case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 8206735Ch case    7:*/		return 0x82067360;
		  /* 82067360h */ case    8:  		/* li R9, 24 */
		/* 82067360h case    8:*/		cpu::op::li<0>(regs,&regs.R9,0x18);
		/* 82067360h case    8:*/		return 0x82067364;
		  /* 82067364h */ case    9:  		/* b -180 */
		/* 82067364h case    9:*/		return 0x820672B0;
		/* 82067364h case    9:*/		return 0x82067368;
	}
	return 0x82067368;
} // Block from 82067340h-82067368h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82067368h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067368( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067368) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067368);
		  /* 82067368h */ case    0:  		/* li R9, 12 */
		/* 82067368h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0xC);
		/* 82067368h case    0:*/		return 0x8206736C;
		  /* 8206736Ch */ case    1:  		/* stw R6, <#[R10 + 4]> */
		/* 8206736Ch case    1:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 8206736Ch case    1:*/		return 0x82067370;
		  /* 82067370h */ case    2:  		/* li R8, 2 */
		/* 82067370h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x2);
		/* 82067370h case    2:*/		return 0x82067374;
		  /* 82067374h */ case    3:  		/* sth R9, <#[R10 + 2]> */
		/* 82067374h case    3:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R10 + 0x00000002) );
		/* 82067374h case    3:*/		return 0x82067378;
		  /* 82067378h */ case    4:  		/* li R9, 24 */
		/* 82067378h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x18);
		/* 82067378h case    4:*/		return 0x8206737C;
		  /* 8206737Ch */ case    5:  		/* b 296 */
		/* 8206737Ch case    5:*/		return 0x820674A4;
		/* 8206737Ch case    5:*/		return 0x82067380;
	}
	return 0x82067380;
} // Block from 82067368h-82067380h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82067380h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067380( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067380) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067380);
		  /* 82067380h */ case    0:  		/* sth R11, <#[R10]> */
		/* 82067380h case    0:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82067380h case    0:*/		return 0x82067384;
		  /* 82067384h */ case    1:  		/* rlwinm. R9, R3, 0, 19, 19 */
		/* 82067384h case    1:*/		cpu::op::rlwinm<1,0,19,19>(regs,&regs.R9,regs.R3);
		/* 82067384h case    1:*/		return 0x82067388;
		  /* 82067388h */ case    2:  		/* sth R11, <#[R10 + 2]> */
		/* 82067388h case    2:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R10 + 0x00000002) );
		/* 82067388h case    2:*/		return 0x8206738C;
		  /* 8206738Ch */ case    3:  		/* stw R6, <#[R10 + 4]> */
		/* 8206738Ch case    3:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 8206738Ch case    3:*/		return 0x82067390;
		  /* 82067390h */ case    4:  		/* stb R11, <#[R10 + 8]> */
		/* 82067390h case    4:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 82067390h case    4:*/		return 0x82067394;
		  /* 82067394h */ case    5:  		/* stb R11, <#[R10 + 9]> */
		/* 82067394h case    5:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x00000009) );
		/* 82067394h case    5:*/		return 0x82067398;
		  /* 82067398h */ case    6:  		/* stb R11, <#[R10 + 10]> */
		/* 82067398h case    6:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x0000000A) );
		/* 82067398h case    6:*/		return 0x8206739C;
		  /* 8206739Ch */ case    7:  		/* addi R10, R10, 12 */
		/* 8206739Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xC);
		/* 8206739Ch case    7:*/		return 0x820673A0;
		  /* 820673A0h */ case    8:  		/* sth R11, <#[R10]> */
		/* 820673A0h case    8:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820673A0h case    8:*/		return 0x820673A4;
		  /* 820673A4h */ case    9:  		/* stb R11, <#[R10 + 8]> */
		/* 820673A4h case    9:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 820673A4h case    9:*/		return 0x820673A8;
		  /* 820673A8h */ case   10:  		/* stb R5, <#[R10 + 9]> */
		/* 820673A8h case   10:*/		cpu::mem::store8( regs, regs.R5, (uint32)(regs.R10 + 0x00000009) );
		/* 820673A8h case   10:*/		return 0x820673AC;
		  /* 820673ACh */ case   11:  		/* stb R11, <#[R10 + 10]> */
		/* 820673ACh case   11:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x0000000A) );
		/* 820673ACh case   11:*/		return 0x820673B0;
		  /* 820673B0h */ case   12:  		/* bc 12, CR0_EQ, 28 */
		/* 820673B0h case   12:*/		if ( regs.CR[0].eq ) { return 0x820673CC;  }
		/* 820673B0h case   12:*/		return 0x820673B4;
		  /* 820673B4h */ case   13:  		/* stw R30, <#[R10 + 4]> */
		/* 820673B4h case   13:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R10 + 0x00000004) );
		/* 820673B4h case   13:*/		return 0x820673B8;
		  /* 820673B8h */ case   14:  		/* li R9, 12 */
		/* 820673B8h case   14:*/		cpu::op::li<0>(regs,&regs.R9,0xC);
		/* 820673B8h case   14:*/		return 0x820673BC;
		  /* 820673BCh */ case   15:  		/* li R7, 16 */
		/* 820673BCh case   15:*/		cpu::op::li<0>(regs,&regs.R7,0x10);
		/* 820673BCh case   15:*/		return 0x820673C0;
		  /* 820673C0h */ case   16:  		/* sth R9, <#[R10 + 2]> */
		/* 820673C0h case   16:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R10 + 0x00000002) );
		/* 820673C0h case   16:*/		return 0x820673C4;
		  /* 820673C4h */ case   17:  		/* li R9, 20 */
		/* 820673C4h case   17:*/		cpu::op::li<0>(regs,&regs.R9,0x14);
		/* 820673C4h case   17:*/		return 0x820673C8;
		  /* 820673C8h */ case   18:  		/* b -344 */
		/* 820673C8h case   18:*/		return 0x82067270;
		/* 820673C8h case   18:*/		return 0x820673CC;
	}
	return 0x820673CC;
} // Block from 82067380h-820673CCh (19 instructions)

//////////////////////////////////////////////////////
// Block at 820673CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820673CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820673CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820673CC);
		  /* 820673CCh */ case    0:  		/* rlwinm. R9, R3, 0, 16, 16 */
		/* 820673CCh case    0:*/		cpu::op::rlwinm<1,0,16,16>(regs,&regs.R9,regs.R3);
		/* 820673CCh case    0:*/		return 0x820673D0;
		  /* 820673D0h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 820673D0h case    1:*/		if ( regs.CR[0].eq ) { return 0x820673DC;  }
		/* 820673D0h case    1:*/		return 0x820673D4;
		  /* 820673D4h */ case    2:  		/* stw R31, <#[R10 + 4]> */
		/* 820673D4h case    2:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R10 + 0x00000004) );
		/* 820673D4h case    2:*/		return 0x820673D8;
		  /* 820673D8h */ case    3:  		/* b -32 */
		/* 820673D8h case    3:*/		return 0x820673B8;
		/* 820673D8h case    3:*/		return 0x820673DC;
	}
	return 0x820673DC;
} // Block from 820673CCh-820673DCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820673DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820673DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820673DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820673DC);
		  /* 820673DCh */ case    0:  		/* lis R9, 44 */
		/* 820673DCh case    0:*/		cpu::op::lis<0>(regs,&regs.R9,0x2C);
		/* 820673DCh case    0:*/		return 0x820673E0;
	}
	return 0x820673E0;
} // Block from 820673DCh-820673E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820673E0h
// Function 'CopyNativeToUCodeShader'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820673E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820673E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820673E0);
		  /* 820673E0h */ case    0:  		/* li R8, 12 */
		/* 820673E0h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0xC);
		/* 820673E0h case    0:*/		return 0x820673E4;
		  /* 820673E4h */ case    1:  		/* ori R9, R9, 9125 */
		/* 820673E4h case    1:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x23A5);
		/* 820673E4h case    1:*/		return 0x820673E8;
	}
	return 0x820673E8;
} // Block from 820673E0h-820673E8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820673E8h
// Function 'UCodeToNativeConstantTable'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820673E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820673E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820673E8);
		  /* 820673E8h */ case    0:  		/* sth R8, <#[R10 + 2]> */
		/* 820673E8h case    0:*/		cpu::mem::store16( regs, regs.R8, (uint32)(regs.R10 + 0x00000002) );
		/* 820673E8h case    0:*/		return 0x820673EC;
		  /* 820673ECh */ case    1:  		/* li R8, 2 */
		/* 820673ECh case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x2);
		/* 820673ECh case    1:*/		return 0x820673F0;
		  /* 820673F0h */ case    2:  		/* stw R9, <#[R10 + 4]> */
		/* 820673F0h case    2:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 820673F0h case    2:*/		return 0x820673F4;
		  /* 820673F4h */ case    3:  		/* li R9, 20 */
		/* 820673F4h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x14);
		/* 820673F4h case    3:*/		return 0x820673F8;
	}
	return 0x820673F8;
} // Block from 820673E8h-820673F8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820673F8h
// Function '?SortInterpolators@InterpolatorTable@D3D@@QAAH_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820673F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820673F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820673F8);
		  /* 820673F8h */ case    0:  		/* b 172 */
		/* 820673F8h case    0:*/		return 0x820674A4;
		/* 820673F8h case    0:*/		return 0x820673FC;
	}
	return 0x820673FC;
} // Block from 820673F8h-820673FCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820673FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820673FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820673FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820673FC);
		  /* 820673FCh */ case    0:  		/* sth R11, <#[R10]> */
		/* 820673FCh case    0:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820673FCh case    0:*/		return 0x82067400;
		  /* 82067400h */ case    1:  		/* rlwinm. R9, R3, 0, 19, 19 */
		/* 82067400h case    1:*/		cpu::op::rlwinm<1,0,19,19>(regs,&regs.R9,regs.R3);
		/* 82067400h case    1:*/		return 0x82067404;
		  /* 82067404h */ case    2:  		/* sth R11, <#[R10 + 2]> */
		/* 82067404h case    2:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R10 + 0x00000002) );
		/* 82067404h case    2:*/		return 0x82067408;
		  /* 82067408h */ case    3:  		/* stw R6, <#[R10 + 4]> */
		/* 82067408h case    3:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 82067408h case    3:*/		return 0x8206740C;
		  /* 8206740Ch */ case    4:  		/* stb R11, <#[R10 + 8]> */
		/* 8206740Ch case    4:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 8206740Ch case    4:*/		return 0x82067410;
		  /* 82067410h */ case    5:  		/* stb R11, <#[R10 + 9]> */
		/* 82067410h case    5:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x00000009) );
		/* 82067410h case    5:*/		return 0x82067414;
		  /* 82067414h */ case    6:  		/* stb R11, <#[R10 + 10]> */
		/* 82067414h case    6:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x0000000A) );
		/* 82067414h case    6:*/		return 0x82067418;
		  /* 82067418h */ case    7:  		/* addi R10, R10, 12 */
		/* 82067418h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xC);
		/* 82067418h case    7:*/		return 0x8206741C;
		  /* 8206741Ch */ case    8:  		/* bc 12, CR0_EQ, 40 */
		/* 8206741Ch case    8:*/		if ( regs.CR[0].eq ) { return 0x82067444;  }
		/* 8206741Ch case    8:*/		return 0x82067420;
		  /* 82067420h */ case    9:  		/* lis R9, 26 */
		/* 82067420h case    9:*/		cpu::op::lis<0>(regs,&regs.R9,0x1A);
		/* 82067420h case    9:*/		return 0x82067424;
		  /* 82067424h */ case   10:  		/* li R8, 2 */
		/* 82067424h case   10:*/		cpu::op::li<0>(regs,&regs.R8,0x2);
		/* 82067424h case   10:*/		return 0x82067428;
		  /* 82067428h */ case   11:  		/* ori R9, R9, 8838 */
		/* 82067428h case   11:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x2286);
		/* 82067428h case   11:*/		return 0x8206742C;
		  /* 8206742Ch */ case   12:  		/* li R7, 12 */
		/* 8206742Ch case   12:*/		cpu::op::li<0>(regs,&regs.R7,0xC);
		/* 8206742Ch case   12:*/		return 0x82067430;
		  /* 82067430h */ case   13:  		/* stb R8, <#[R10 + 9]> */
		/* 82067430h case   13:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R10 + 0x00000009) );
		/* 82067430h case   13:*/		return 0x82067434;
		  /* 82067434h */ case   14:  		/* stw R9, <#[R10 + 4]> */
		/* 82067434h case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 82067434h case   14:*/		return 0x82067438;
		  /* 82067438h */ case   15:  		/* li R9, 16 */
		/* 82067438h case   15:*/		cpu::op::li<0>(regs,&regs.R9,0x10);
		/* 82067438h case   15:*/		return 0x8206743C;
		  /* 8206743Ch */ case   16:  		/* sth R7, <#[R10 + 2]> */
		/* 8206743Ch case   16:*/		cpu::mem::store16( regs, regs.R7, (uint32)(regs.R10 + 0x00000002) );
		/* 8206743Ch case   16:*/		return 0x82067440;
		  /* 82067440h */ case   17:  		/* b 88 */
		/* 82067440h case   17:*/		return 0x82067498;
		/* 82067440h case   17:*/		return 0x82067444;
	}
	return 0x82067444;
} // Block from 820673FCh-82067444h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82067444h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067444( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067444) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067444);
		  /* 82067444h */ case    0:  		/* rlwinm. R9, R3, 0, 16, 16 */
		/* 82067444h case    0:*/		cpu::op::rlwinm<1,0,16,16>(regs,&regs.R9,regs.R3);
		/* 82067444h case    0:*/		return 0x82067448;
		  /* 82067448h */ case    1:  		/* sth R11, <#[R10]> */
		/* 82067448h case    1:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82067448h case    1:*/		return 0x8206744C;
		  /* 8206744Ch */ case    2:  		/* li R9, 12 */
		/* 8206744Ch case    2:*/		cpu::op::li<0>(regs,&regs.R9,0xC);
		/* 8206744Ch case    2:*/		return 0x82067450;
		  /* 82067450h */ case    3:  		/* stb R11, <#[R10 + 8]> */
		/* 82067450h case    3:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 82067450h case    3:*/		return 0x82067454;
		  /* 82067454h */ case    4:  		/* stb R11, <#[R10 + 10]> */
		/* 82067454h case    4:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x0000000A) );
		/* 82067454h case    4:*/		return 0x82067458;
		  /* 82067458h */ case    5:  		/* sth R9, <#[R10 + 2]> */
		/* 82067458h case    5:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R10 + 0x00000002) );
		/* 82067458h case    5:*/		return 0x8206745C;
		  /* 8206745Ch */ case    6:  		/* li R9, 16 */
		/* 8206745Ch case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x10);
		/* 8206745Ch case    6:*/		return 0x82067460;
		  /* 82067460h */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 82067460h case    7:*/		if ( regs.CR[0].eq ) { return 0x82067474;  }
		/* 82067460h case    7:*/		return 0x82067464;
		  /* 82067464h */ case    8:  		/* li R8, 2 */
		/* 82067464h case    8:*/		cpu::op::li<0>(regs,&regs.R8,0x2);
		/* 82067464h case    8:*/		return 0x82067468;
		  /* 82067468h */ case    9:  		/* stw R31, <#[R10 + 4]> */
		/* 82067468h case    9:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R10 + 0x00000004) );
		/* 82067468h case    9:*/		return 0x8206746C;
		  /* 8206746Ch */ case   10:  		/* stb R8, <#[R10 + 9]> */
		/* 8206746Ch case   10:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R10 + 0x00000009) );
		/* 8206746Ch case   10:*/		return 0x82067470;
		  /* 82067470h */ case   11:  		/* b 52 */
		/* 82067470h case   11:*/		return 0x820674A4;
		/* 82067470h case   11:*/		return 0x82067474;
	}
	return 0x82067474;
} // Block from 82067444h-82067474h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82067474h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067474( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067474) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067474);
		  /* 82067474h */ case    0:  		/* stw R30, <#[R10 + 4]> */
		/* 82067474h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R10 + 0x00000004) );
		/* 82067474h case    0:*/		return 0x82067478;
		  /* 82067478h */ case    1:  		/* li R8, 2 */
		/* 82067478h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x2);
		/* 82067478h case    1:*/		return 0x8206747C;
		  /* 8206747Ch */ case    2:  		/* stb R5, <#[R10 + 9]> */
		/* 8206747Ch case    2:*/		cpu::mem::store8( regs, regs.R5, (uint32)(regs.R10 + 0x00000009) );
		/* 8206747Ch case    2:*/		return 0x82067480;
		  /* 82067480h */ case    3:  		/* b 36 */
		/* 82067480h case    3:*/		return 0x820674A4;
		/* 82067480h case    3:*/		return 0x82067484;
	}
	return 0x82067484;
} // Block from 82067474h-82067484h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82067484h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067484( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067484) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067484);
		  /* 82067484h */ case    0:  		/* li R9, 12 */
		/* 82067484h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0xC);
		/* 82067484h case    0:*/		return 0x82067488;
		  /* 82067488h */ case    1:  		/* stw R6, <#[R10 + 4]> */
		/* 82067488h case    1:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 82067488h case    1:*/		return 0x8206748C;
	}
	return 0x8206748C;
} // Block from 82067484h-8206748Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206748Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206748C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206748C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206748C);
		  /* 8206748Ch */ case    0:  		/* sth R11, <#[R10 + 2]> */
		/* 8206748Ch case    0:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R10 + 0x00000002) );
		/* 8206748Ch case    0:*/		return 0x82067490;
		  /* 82067490h */ case    1:  		/* mr R8, R5 */
		/* 82067490h case    1:*/		regs.R8 = regs.R5;
		/* 82067490h case    1:*/		return 0x82067494;
		  /* 82067494h */ case    2:  		/* stb R11, <#[R10 + 9]> */
		/* 82067494h case    2:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x00000009) );
		/* 82067494h case    2:*/		return 0x82067498;
	}
	return 0x82067498;
} // Block from 8206748Ch-82067498h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82067498h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067498( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067498) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067498);
		  /* 82067498h */ case    0:  		/* sth R11, <#[R10]> */
		/* 82067498h case    0:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82067498h case    0:*/		return 0x8206749C;
	}
	return 0x8206749C;
} // Block from 82067498h-8206749Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206749Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206749C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206749C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206749C);
		  /* 8206749Ch */ case    0:  		/* stb R11, <#[R10 + 8]> */
		/* 8206749Ch case    0:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 8206749Ch case    0:*/		return 0x820674A0;
		  /* 820674A0h */ case    1:  		/* stb R11, <#[R10 + 10]> */
		/* 820674A0h case    1:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x0000000A) );
		/* 820674A0h case    1:*/		return 0x820674A4;
	}
	return 0x820674A4;
} // Block from 8206749Ch-820674A4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820674A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820674A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820674A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820674A4);
		  /* 820674A4h */ case    0:  		/* addi R10, R10, 12 */
		/* 820674A4h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xC);
		/* 820674A4h case    0:*/		return 0x820674A8;
	}
	return 0x820674A8;
} // Block from 820674A4h-820674A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820674A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820674A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820674A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820674A8);
		  /* 820674A8h */ case    0:  		/* rlwinm. R7, R3, 0, 27, 27 */
		/* 820674A8h case    0:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R7,regs.R3);
		/* 820674A8h case    0:*/		return 0x820674AC;
		  /* 820674ACh */ case    1:  		/* bc 12, CR0_EQ, 52 */
		/* 820674ACh case    1:*/		if ( regs.CR[0].eq ) { return 0x820674E0;  }
		/* 820674ACh case    1:*/		return 0x820674B0;
		  /* 820674B0h */ case    2:  		/* rlwinm R7, R9, 0, 16, 31 */
		/* 820674B0h case    2:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R7,regs.R9);
		/* 820674B0h case    2:*/		return 0x820674B4;
		  /* 820674B4h */ case    3:  		/* sth R9, <#[R10 + 2]> */
		/* 820674B4h case    3:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R10 + 0x00000002) );
		/* 820674B4h case    3:*/		return 0x820674B8;
		  /* 820674B8h */ case    4:  		/* li R9, 3 */
		/* 820674B8h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x3);
		/* 820674B8h case    4:*/		return 0x820674BC;
		  /* 820674BCh */ case    5:  		/* sth R11, <#[R10]> */
		/* 820674BCh case    5:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820674BCh case    5:*/		return 0x820674C0;
		  /* 820674C0h */ case    6:  		/* addi R7, R7, 12 */
		/* 820674C0h case    6:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0xC);
		/* 820674C0h case    6:*/		return 0x820674C4;
		  /* 820674C4h */ case    7:  		/* stw R6, <#[R10 + 4]> */
		/* 820674C4h case    7:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 820674C4h case    7:*/		return 0x820674C8;
		  /* 820674C8h */ case    8:  		/* stb R9, <#[R10 + 9]> */
		/* 820674C8h case    8:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R10 + 0x00000009) );
		/* 820674C8h case    8:*/		return 0x820674CC;
		  /* 820674CCh */ case    9:  		/* addi R8, R8, 1 */
		/* 820674CCh case    9:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 820674CCh case    9:*/		return 0x820674D0;
		  /* 820674D0h */ case   10:  		/* stb R11, <#[R10 + 8]> */
		/* 820674D0h case   10:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 820674D0h case   10:*/		return 0x820674D4;
		  /* 820674D4h */ case   11:  		/* rlwinm R9, R7, 0, 16, 31 */
		/* 820674D4h case   11:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R9,regs.R7);
		/* 820674D4h case   11:*/		return 0x820674D8;
		  /* 820674D8h */ case   12:  		/* stb R11, <#[R10 + 10]> */
		/* 820674D8h case   12:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x0000000A) );
		/* 820674D8h case   12:*/		return 0x820674DC;
		  /* 820674DCh */ case   13:  		/* addi R10, R10, 12 */
		/* 820674DCh case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xC);
		/* 820674DCh case   13:*/		return 0x820674E0;
	}
	return 0x820674E0;
} // Block from 820674A8h-820674E0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 820674E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820674E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820674E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820674E0);
		  /* 820674E0h */ case    0:  		/* rlwinm. R7, R3, 0, 26, 26 */
		/* 820674E0h case    0:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R7,regs.R3);
		/* 820674E0h case    0:*/		return 0x820674E4;
		  /* 820674E4h */ case    1:  		/* bc 12, CR0_EQ, 52 */
		/* 820674E4h case    1:*/		if ( regs.CR[0].eq ) { return 0x82067518;  }
		/* 820674E4h case    1:*/		return 0x820674E8;
	}
	return 0x820674E8;
} // Block from 820674E0h-820674E8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820674E8h
// Function '?SortInterpolatorRecordsCompareFn@InterpolatorTable@D3D@@CAHPBX0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820674E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820674E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820674E8);
		  /* 820674E8h */ case    0:  		/* rlwinm R7, R9, 0, 16, 31 */
		/* 820674E8h case    0:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R7,regs.R9);
		/* 820674E8h case    0:*/		return 0x820674EC;
		  /* 820674ECh */ case    1:  		/* sth R9, <#[R10 + 2]> */
		/* 820674ECh case    1:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R10 + 0x00000002) );
		/* 820674ECh case    1:*/		return 0x820674F0;
		  /* 820674F0h */ case    2:  		/* li R9, 4 */
		/* 820674F0h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 820674F0h case    2:*/		return 0x820674F4;
		  /* 820674F4h */ case    3:  		/* sth R11, <#[R10]> */
		/* 820674F4h case    3:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820674F4h case    3:*/		return 0x820674F8;
	}
	return 0x820674F8;
} // Block from 820674E8h-820674F8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820674F8h
// Function '?Write@StreamWriter@CMicrocodeBuilder@D3D@@QAAXPAXK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820674F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820674F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820674F8);
		  /* 820674F8h */ case    0:  		/* addi R7, R7, 4 */
		/* 820674F8h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 820674F8h case    0:*/		return 0x820674FC;
		  /* 820674FCh */ case    1:  		/* stw R30, <#[R10 + 4]> */
		/* 820674FCh case    1:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R10 + 0x00000004) );
		/* 820674FCh case    1:*/		return 0x82067500;
		  /* 82067500h */ case    2:  		/* stb R9, <#[R10 + 9]> */
		/* 82067500h case    2:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R10 + 0x00000009) );
		/* 82067500h case    2:*/		return 0x82067504;
		  /* 82067504h */ case    3:  		/* addi R8, R8, 1 */
		/* 82067504h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82067504h case    3:*/		return 0x82067508;
		  /* 82067508h */ case    4:  		/* stb R11, <#[R10 + 8]> */
		/* 82067508h case    4:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 82067508h case    4:*/		return 0x8206750C;
		  /* 8206750Ch */ case    5:  		/* rlwinm R9, R7, 0, 16, 31 */
		/* 8206750Ch case    5:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R9,regs.R7);
		/* 8206750Ch case    5:*/		return 0x82067510;
		  /* 82067510h */ case    6:  		/* stb R11, <#[R10 + 10]> */
		/* 82067510h case    6:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x0000000A) );
		/* 82067510h case    6:*/		return 0x82067514;
		  /* 82067514h */ case    7:  		/* addi R10, R10, 12 */
		/* 82067514h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xC);
		/* 82067514h case    7:*/		return 0x82067518;
	}
	return 0x82067518;
} // Block from 820674F8h-82067518h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82067518h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067518( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067518) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067518);
		  /* 82067518h */ case    0:  		/* rlwinm. R7, R3, 0, 25, 25 */
		/* 82067518h case    0:*/		cpu::op::rlwinm<1,0,25,25>(regs,&regs.R7,regs.R3);
		/* 82067518h case    0:*/		return 0x8206751C;
		  /* 8206751Ch */ case    1:  		/* li R6, 10 */
		/* 8206751Ch case    1:*/		cpu::op::li<0>(regs,&regs.R6,0xA);
		/* 8206751Ch case    1:*/		return 0x82067520;
		  /* 82067520h */ case    2:  		/* bc 12, CR0_EQ, 48 */
		/* 82067520h case    2:*/		if ( regs.CR[0].eq ) { return 0x82067550;  }
		/* 82067520h case    2:*/		return 0x82067524;
		  /* 82067524h */ case    3:  		/* rlwinm R7, R9, 0, 16, 31 */
		/* 82067524h case    3:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R7,regs.R9);
		/* 82067524h case    3:*/		return 0x82067528;
		  /* 82067528h */ case    4:  		/* sth R9, <#[R10 + 2]> */
		/* 82067528h case    4:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R10 + 0x00000002) );
		/* 82067528h case    4:*/		return 0x8206752C;
		  /* 8206752Ch */ case    5:  		/* sth R11, <#[R10]> */
		/* 8206752Ch case    5:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 8206752Ch case    5:*/		return 0x82067530;
		  /* 82067530h */ case    6:  		/* addi R8, R8, 1 */
		/* 82067530h case    6:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82067530h case    6:*/		return 0x82067534;
		  /* 82067534h */ case    7:  		/* addi R9, R7, 4 */
		/* 82067534h case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R7,0x4);
		/* 82067534h case    7:*/		return 0x82067538;
		  /* 82067538h */ case    8:  		/* stw R31, <#[R10 + 4]> */
		/* 82067538h case    8:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R10 + 0x00000004) );
		/* 82067538h case    8:*/		return 0x8206753C;
		  /* 8206753Ch */ case    9:  		/* stb R11, <#[R10 + 8]> */
		/* 8206753Ch case    9:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 8206753Ch case    9:*/		return 0x82067540;
		  /* 82067540h */ case   10:  		/* stb R6, <#[R10 + 9]> */
		/* 82067540h case   10:*/		cpu::mem::store8( regs, regs.R6, (uint32)(regs.R10 + 0x00000009) );
		/* 82067540h case   10:*/		return 0x82067544;
		  /* 82067544h */ case   11:  		/* rlwinm R9, R9, 0, 16, 31 */
		/* 82067544h case   11:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R9,regs.R9);
		/* 82067544h case   11:*/		return 0x82067548;
		  /* 82067548h */ case   12:  		/* stb R11, <#[R10 + 10]> */
		/* 82067548h case   12:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x0000000A) );
		/* 82067548h case   12:*/		return 0x8206754C;
		  /* 8206754Ch */ case   13:  		/* addi R10, R10, 12 */
		/* 8206754Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xC);
		/* 8206754Ch case   13:*/		return 0x82067550;
	}
	return 0x82067550;
} // Block from 82067518h-82067550h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82067550h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067550( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067550) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067550);
		  /* 82067550h */ case    0:  		/* rlwinm. R7, R3, 0, 24, 24 */
		/* 82067550h case    0:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R7,regs.R3);
		/* 82067550h case    0:*/		return 0x82067554;
		  /* 82067554h */ case    1:  		/* bc 12, CR0_EQ, 48 */
		/* 82067554h case    1:*/		if ( regs.CR[0].eq ) { return 0x82067584;  }
		/* 82067554h case    1:*/		return 0x82067558;
		  /* 82067558h */ case    2:  		/* rlwinm R7, R9, 0, 16, 31 */
		/* 82067558h case    2:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R7,regs.R9);
		/* 82067558h case    2:*/		return 0x8206755C;
		  /* 8206755Ch */ case    3:  		/* sth R9, <#[R10 + 2]> */
		/* 8206755Ch case    3:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R10 + 0x00000002) );
		/* 8206755Ch case    3:*/		return 0x82067560;
		  /* 82067560h */ case    4:  		/* sth R11, <#[R10]> */
		/* 82067560h case    4:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82067560h case    4:*/		return 0x82067564;
		  /* 82067564h */ case    5:  		/* addi R8, R8, 1 */
		/* 82067564h case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82067564h case    5:*/		return 0x82067568;
		  /* 82067568h */ case    6:  		/* addi R9, R7, 4 */
		/* 82067568h case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R7,0x4);
		/* 82067568h case    6:*/		return 0x8206756C;
		  /* 8206756Ch */ case    7:  		/* stw R31, <#[R10 + 4]> */
		/* 8206756Ch case    7:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R10 + 0x00000004) );
		/* 8206756Ch case    7:*/		return 0x82067570;
		  /* 82067570h */ case    8:  		/* stb R11, <#[R10 + 8]> */
		/* 82067570h case    8:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 82067570h case    8:*/		return 0x82067574;
		  /* 82067574h */ case    9:  		/* stb R6, <#[R10 + 9]> */
		/* 82067574h case    9:*/		cpu::mem::store8( regs, regs.R6, (uint32)(regs.R10 + 0x00000009) );
		/* 82067574h case    9:*/		return 0x82067578;
		  /* 82067578h */ case   10:  		/* rlwinm R9, R9, 0, 16, 31 */
		/* 82067578h case   10:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R9,regs.R9);
		/* 82067578h case   10:*/		return 0x8206757C;
		  /* 8206757Ch */ case   11:  		/* stb R5, <#[R10 + 10]> */
		/* 8206757Ch case   11:*/		cpu::mem::store8( regs, regs.R5, (uint32)(regs.R10 + 0x0000000A) );
		/* 8206757Ch case   11:*/		return 0x82067580;
	}
	return 0x82067580;
} // Block from 82067550h-82067580h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82067580h
// Function '??0Sink@CMicrocodeBuilder@D3D@@QAA@PAXK0K@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067580( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067580) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067580);
		  /* 82067580h */ case    0:  		/* addi R10, R10, 12 */
		/* 82067580h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xC);
		/* 82067580h case    0:*/		return 0x82067584;
	}
	return 0x82067584;
} // Block from 82067580h-82067584h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82067584h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067584( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067584) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067584);
		  /* 82067584h */ case    0:  		/* rlwinm. R5, R3, 24, 28, 31 */
		/* 82067584h case    0:*/		cpu::op::rlwinm<1,24,28,31>(regs,&regs.R5,regs.R3);
		/* 82067584h case    0:*/		return 0x82067588;
		  /* 82067588h */ case    1:  		/* rlwinm R7, R3, 16, 16, 31 */
		/* 82067588h case    1:*/		cpu::op::rlwinm<0,16,16,31>(regs,&regs.R7,regs.R3);
		/* 82067588h case    1:*/		return 0x8206758C;
		  /* 8206758Ch */ case    2:  		/* mr R6, R11 */
		/* 8206758Ch case    2:*/		regs.R6 = regs.R11;
		/* 8206758Ch case    2:*/		return 0x82067590;
		  /* 82067590h */ case    3:  		/* bc 12, CR0_EQ, 104 */
		/* 82067590h case    3:*/		if ( regs.CR[0].eq ) { return 0x820675F8;  }
		/* 82067590h case    3:*/		return 0x82067594;
		  /* 82067594h */ case    4:  		/* mtspr CTR, R5 */
		/* 82067594h case    4:*/		regs.CTR = regs.R5;
		/* 82067594h case    4:*/		return 0x82067598;
		  /* 82067598h */ case    5:  		/* add R8, R5, R8 */
		/* 82067598h case    5:*/		cpu::op::add<0>(regs,&regs.R8,regs.R5,regs.R8);
		/* 82067598h case    5:*/		return 0x8206759C;
		  /* 8206759Ch */ case    6:  		/* lis R5, -32256 */
		/* 8206759Ch case    6:*/		cpu::op::lis<0>(regs,&regs.R5,0xFFFF8200);
		/* 8206759Ch case    6:*/		return 0x820675A0;
		  /* 820675A0h */ case    7:  		/* addi R5, R5, 3256 */
		/* 820675A0h case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0xCB8);
		/* 820675A0h case    7:*/		return 0x820675A4;
		  /* 820675A4h */ case    8:  		/* rlwinm R31, R7, 0, 30, 31 */
		/* 820675A4h case    8:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R31,regs.R7);
		/* 820675A4h case    8:*/		return 0x820675A8;
		  /* 820675A8h */ case    9:  		/* addi R30, R5, -4 */
		/* 820675A8h case    9:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R5,0xFFFFFFFC);
		/* 820675A8h case    9:*/		return 0x820675AC;
		  /* 820675ACh */ case   10:  		/* rlwinm R3, R9, 0, 16, 31 */
		/* 820675ACh case   10:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R3,regs.R9);
		/* 820675ACh case   10:*/		return 0x820675B0;
		  /* 820675B0h */ case   11:  		/* rlwinm R29, R6, 0, 24, 31 */
		/* 820675B0h case   11:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R29,regs.R6);
		/* 820675B0h case   11:*/		return 0x820675B4;
		  /* 820675B4h */ case   12:  		/* li R28, 5 */
		/* 820675B4h case   12:*/		cpu::op::li<0>(regs,&regs.R28,0x5);
		/* 820675B4h case   12:*/		return 0x820675B8;
		  /* 820675B8h */ case   13:  		/* rlwinm R7, R7, 30, 2, 31 */
		/* 820675B8h case   13:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R7,regs.R7);
		/* 820675B8h case   13:*/		return 0x820675BC;
		  /* 820675BCh */ case   14:  		/* lbzx R31, <#[R31 + R30]> */
		/* 820675BCh case   14:*/		cpu::mem::load8z( regs, &regs.R31, (uint32)(regs.R31 + regs.R30 + 0x00000000) );
		/* 820675BCh case   14:*/		return 0x820675C0;
		  /* 820675C0h */ case   15:  		/* addi R6, R6, 1 */
		/* 820675C0h case   15:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 820675C0h case   15:*/		return 0x820675C4;
		  /* 820675C4h */ case   16:  		/* sth R9, <#[R10 + 2]> */
		/* 820675C4h case   16:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R10 + 0x00000002) );
		/* 820675C4h case   16:*/		return 0x820675C8;
		  /* 820675C8h */ case   17:  		/* rlwinm R9, R31, 0, 0, 29 */
		/* 820675C8h case   17:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R9,regs.R31);
		/* 820675C8h case   17:*/		return 0x820675CC;
		  /* 820675CCh */ case   18:  		/* sth R11, <#[R10]> */
		/* 820675CCh case   18:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 820675CCh case   18:*/		return 0x820675D0;
		  /* 820675D0h */ case   19:  		/* add R31, R9, R5 */
		/* 820675D0h case   19:*/		cpu::op::add<0>(regs,&regs.R31,regs.R9,regs.R5);
		/* 820675D0h case   19:*/		return 0x820675D4;
		  /* 820675D4h */ case   20:  		/* add R9, R3, R9 */
		/* 820675D4h case   20:*/		cpu::op::add<0>(regs,&regs.R9,regs.R3,regs.R9);
		/* 820675D4h case   20:*/		return 0x820675D8;
		  /* 820675D8h */ case   21:  		/* rlwinm R9, R9, 0, 16, 31 */
		/* 820675D8h case   21:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R9,regs.R9);
		/* 820675D8h case   21:*/		return 0x820675DC;
		  /* 820675DCh */ case   22:  		/* lwz R3, <#[R31 - 4]> */
		/* 820675DCh case   22:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0xFFFFFFFC) );
		/* 820675DCh case   22:*/		return 0x820675E0;
		  /* 820675E0h */ case   23:  		/* stw R3, <#[R10 + 4]> */
		/* 820675E0h case   23:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R10 + 0x00000004) );
		/* 820675E0h case   23:*/		return 0x820675E4;
		  /* 820675E4h */ case   24:  		/* stb R11, <#[R10 + 8]> */
		/* 820675E4h case   24:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 820675E4h case   24:*/		return 0x820675E8;
		  /* 820675E8h */ case   25:  		/* stb R28, <#[R10 + 9]> */
		/* 820675E8h case   25:*/		cpu::mem::store8( regs, regs.R28, (uint32)(regs.R10 + 0x00000009) );
		/* 820675E8h case   25:*/		return 0x820675EC;
		  /* 820675ECh */ case   26:  		/* stb R29, <#[R10 + 10]> */
		/* 820675ECh case   26:*/		cpu::mem::store8( regs, regs.R29, (uint32)(regs.R10 + 0x0000000A) );
		/* 820675ECh case   26:*/		return 0x820675F0;
		  /* 820675F0h */ case   27:  		/* addi R10, R10, 12 */
		/* 820675F0h case   27:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xC);
		/* 820675F0h case   27:*/		return 0x820675F4;
		  /* 820675F4h */ case   28:  		/* bc 16, CR0_LT, -80 */
		/* 820675F4h case   28:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x820675A4;  }
		/* 820675F4h case   28:*/		return 0x820675F8;
	}
	return 0x820675F8;
} // Block from 82067584h-820675F8h (29 instructions)

//////////////////////////////////////////////////////
// Block at 820675F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820675F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820675F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820675F8);
		  /* 820675F8h */ case    0:  		/* li R7, 255 */
		/* 820675F8h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0xFF);
		/* 820675F8h case    0:*/		return 0x820675FC;
		  /* 820675FCh */ case    1:  		/* sth R11, <#[R1 - 62]> */
		/* 820675FCh case    1:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R1 + 0xFFFFFFC2) );
		/* 820675FCh case    1:*/		return 0x82067600;
	}
	return 0x82067600;
} // Block from 820675F8h-82067600h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82067600h
// Function '?Write@DefinitionTable@CMicrocodeBuilder@D3D@@QAAJPAVSink@23@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067600( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067600) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067600);
		  /* 82067600h */ case    0:  		/* li R9, -1 */
		/* 82067600h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0xFFFFFFFF);
		/* 82067600h case    0:*/		return 0x82067604;
		  /* 82067604h */ case    1:  		/* stb R11, <#[R1 - 56]> */
		/* 82067604h case    1:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0xFFFFFFC8) );
		/* 82067604h case    1:*/		return 0x82067608;
		  /* 82067608h */ case    2:  		/* sth R7, <#[R1 - 64]> */
		/* 82067608h case    2:*/		cpu::mem::store16( regs, regs.R7, (uint32)(regs.R1 + 0xFFFFFFC0) );
		/* 82067608h case    2:*/		return 0x8206760C;
		  /* 8206760Ch */ case    3:  		/* lwz R7, <#[R1 - 64]> */
		/* 8206760Ch case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0xFFFFFFC0) );
		/* 8206760Ch case    3:*/		return 0x82067610;
		  /* 82067610h */ case    4:  		/* stb R11, <#[R1 - 55]> */
		/* 82067610h case    4:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0xFFFFFFC9) );
		/* 82067610h case    4:*/		return 0x82067614;
		  /* 82067614h */ case    5:  		/* stb R11, <#[R1 - 54]> */
		/* 82067614h case    5:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0xFFFFFFCA) );
		/* 82067614h case    5:*/		return 0x82067618;
		  /* 82067618h */ case    6:  		/* lwz R6, <#[R1 - 56]> */
		/* 82067618h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0xFFFFFFC8) );
		/* 82067618h case    6:*/		return 0x8206761C;
		  /* 8206761Ch */ case    7:  		/* stw R9, <#[R10 + 4]> */
		/* 8206761Ch case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 8206761Ch case    7:*/		return 0x82067620;
		  /* 82067620h */ case    8:  		/* stw R6, <#[R10 + 8]> */
		/* 82067620h case    8:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + 0x00000008) );
		/* 82067620h case    8:*/		return 0x82067624;
		  /* 82067624h */ case    9:  		/* stw R7, <#[R10]> */
		/* 82067624h case    9:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 82067624h case    9:*/		return 0x82067628;
		  /* 82067628h */ case   10:  		/* stw R8, <#[R4 + 24]> */
		/* 82067628h case   10:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R4 + 0x00000018) );
		/* 82067628h case   10:*/		return 0x8206762C;
		  /* 8206762Ch */ case   11:  		/* stw R11, <#[R4 + 28]> */
		/* 8206762Ch case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x0000001C) );
		/* 8206762Ch case   11:*/		return 0x82067630;
		  /* 82067630h */ case   12:  		/* stw R11, <#[R4 + 48]> */
		/* 82067630h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000030) );
		/* 82067630h case   12:*/		return 0x82067634;
		  /* 82067634h */ case   13:  		/* b 171124 */
		/* 82067634h case   13:*/		return 0x820912A8;
		/* 82067634h case   13:*/		return 0x82067638;
		  /* 82067638h */ case   14:  		/* lbz R11, <#[R3]> */
		/* 82067638h case   14:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82067638h case   14:*/		return 0x8206763C;
		  /* 8206763Ch */ case   15:  		/* lbz R10, <#[R4]> */
		/* 8206763Ch case   15:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 8206763Ch case   15:*/		return 0x82067640;
		  /* 82067640h */ case   16:  		/* subf R3, R10, R11 */
		/* 82067640h case   16:*/		cpu::op::subf<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 82067640h case   16:*/		return 0x82067644;
		  /* 82067644h */ case   17:  		/* bclr 20, CR0_LT */
		/* 82067644h case   17:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82067644h case   17:*/		return 0x82067648;
	}
	return 0x82067648;
} // Block from 82067600h-82067648h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82067648h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067648( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067648) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067648);
		  /* 82067648h */ case    0:  		/* mfspr R12, LR */
		/* 82067648h case    0:*/		regs.R12 = regs.LR;
		/* 82067648h case    0:*/		return 0x8206764C;
		  /* 8206764Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8206764Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206764Ch case    1:*/		return 0x82067650;
		  /* 82067650h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82067650h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82067650h case    2:*/		return 0x82067654;
		  /* 82067654h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82067654h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82067654h case    3:*/		return 0x82067658;
		  /* 82067658h */ case    4:  		/* mr R31, R3 */
		/* 82067658h case    4:*/		regs.R31 = regs.R3;
		/* 82067658h case    4:*/		return 0x8206765C;
		  /* 8206765Ch */ case    5:  		/* li R11, 0 */
		/* 8206765Ch case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8206765Ch case    5:*/		return 0x82067660;
		  /* 82067660h */ case    6:  		/* mr R3, R4 */
		/* 82067660h case    6:*/		regs.R3 = regs.R4;
		/* 82067660h case    6:*/		return 0x82067664;
		  /* 82067664h */ case    7:  		/* cmplwi CR6, R4, 0 */
		/* 82067664h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82067664h case    7:*/		return 0x82067668;
		  /* 82067668h */ case    8:  		/* stw R4, <#[R31]> */
		/* 82067668h case    8:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R31 + 0x00000000) );
		/* 82067668h case    8:*/		return 0x8206766C;
		  /* 8206766Ch */ case    9:  		/* stw R5, <#[R31 + 8]> */
		/* 8206766Ch case    9:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R31 + 0x00000008) );
		/* 8206766Ch case    9:*/		return 0x82067670;
		  /* 82067670h */ case   10:  		/* stw R11, <#[R31 + 4]> */
		/* 82067670h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82067670h case   10:*/		return 0x82067674;
		  /* 82067674h */ case   11:  		/* stw R11, <#[R31 + 12]> */
		/* 82067674h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82067674h case   11:*/		return 0x82067678;
		  /* 82067678h */ case   12:  		/* stw R11, <#[R31 + 16]> */
		/* 82067678h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82067678h case   12:*/		return 0x8206767C;
		  /* 8206767Ch */ case   13:  		/* bc 12, CR6_EQ, 12 */
		/* 8206767Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x82067688;  }
		/* 8206767Ch case   13:*/		return 0x82067680;
		  /* 82067680h */ case   14:  		/* li R4, 0 */
		/* 82067680h case   14:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82067680h case   14:*/		return 0x82067684;
		  /* 82067684h */ case   15:  		/* bl 171196 */
		/* 82067684h case   15:*/		regs.LR = 0x82067688; return 0x82091340;
		/* 82067684h case   15:*/		return 0x82067688;
	}
	return 0x82067688;
} // Block from 82067648h-82067688h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82067688h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067688( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067688) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067688);
		  /* 82067688h */ case    0:  		/* mr R3, R31 */
		/* 82067688h case    0:*/		regs.R3 = regs.R31;
		/* 82067688h case    0:*/		return 0x8206768C;
		  /* 8206768Ch */ case    1:  		/* addi R1, R1, 96 */
		/* 8206768Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8206768Ch case    1:*/		return 0x82067690;
		  /* 82067690h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 82067690h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82067690h case    2:*/		return 0x82067694;
		  /* 82067694h */ case    3:  		/* mtspr LR, R12 */
		/* 82067694h case    3:*/		regs.LR = regs.R12;
		/* 82067694h case    3:*/		return 0x82067698;
		  /* 82067698h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 82067698h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82067698h case    4:*/		return 0x8206769C;
		  /* 8206769Ch */ case    5:  		/* bclr 20, CR0_LT */
		/* 8206769Ch case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206769Ch case    5:*/		return 0x820676A0;
	}
	return 0x820676A0;
} // Block from 82067688h-820676A0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820676A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820676A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820676A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820676A0);
		  /* 820676A0h */ case    0:  		/* mfspr R12, LR */
		/* 820676A0h case    0:*/		regs.R12 = regs.LR;
		/* 820676A0h case    0:*/		return 0x820676A4;
		  /* 820676A4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820676A4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820676A4h case    1:*/		return 0x820676A8;
		  /* 820676A8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820676A8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820676A8h case    2:*/		return 0x820676AC;
		  /* 820676ACh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820676ACh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820676ACh case    3:*/		return 0x820676B0;
		  /* 820676B0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820676B0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820676B0h case    4:*/		return 0x820676B4;
		  /* 820676B4h */ case    5:  		/* lwz R11, <#[R3 + 4]> */
		/* 820676B4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 820676B4h case    5:*/		return 0x820676B8;
		  /* 820676B8h */ case    6:  		/* mr R31, R3 */
		/* 820676B8h case    6:*/		regs.R31 = regs.R3;
		/* 820676B8h case    6:*/		return 0x820676BC;
		  /* 820676BCh */ case    7:  		/* lwz R10, <#[R3 + 8]> */
		/* 820676BCh case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 820676BCh case    7:*/		return 0x820676C0;
		  /* 820676C0h */ case    8:  		/* add R30, R11, R5 */
		/* 820676C0h case    8:*/		cpu::op::add<0>(regs,&regs.R30,regs.R11,regs.R5);
		/* 820676C0h case    8:*/		return 0x820676C4;
		  /* 820676C4h */ case    9:  		/* cmplw CR6, R30, R10 */
		/* 820676C4h case    9:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R10);
		/* 820676C4h case    9:*/		return 0x820676C8;
		  /* 820676C8h */ case   10:  		/* bc 12, CR6_GT, 28 */
		/* 820676C8h case   10:*/		if ( regs.CR[6].gt ) { return 0x820676E4;  }
		/* 820676C8h case   10:*/		return 0x820676CC;
		  /* 820676CCh */ case   11:  		/* cmplwi CR6, R4, 0 */
		/* 820676CCh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 820676CCh case   11:*/		return 0x820676D0;
		  /* 820676D0h */ case   12:  		/* bc 12, CR6_EQ, 40 */
		/* 820676D0h case   12:*/		if ( regs.CR[6].eq ) { return 0x820676F8;  }
		/* 820676D0h case   12:*/		return 0x820676D4;
		  /* 820676D4h */ case   13:  		/* lwz R10, <#[R3]> */
		/* 820676D4h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 820676D4h case   13:*/		return 0x820676D8;
		  /* 820676D8h */ case   14:  		/* add R3, R11, R10 */
		/* 820676D8h case   14:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 820676D8h case   14:*/		return 0x820676DC;
		  /* 820676DCh */ case   15:  		/* bl 172756 */
		/* 820676DCh case   15:*/		regs.LR = 0x820676E0; return 0x820919B0;
		/* 820676DCh case   15:*/		return 0x820676E0;
		  /* 820676E0h */ case   16:  		/* b 24 */
		/* 820676E0h case   16:*/		return 0x820676F8;
		/* 820676E0h case   16:*/		return 0x820676E4;
	}
	return 0x820676E4;
} // Block from 820676A0h-820676E4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820676E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820676E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820676E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820676E4);
		  /* 820676E4h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 820676E4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820676E4h case    0:*/		return 0x820676E8;
		  /* 820676E8h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 820676E8h case    1:*/		if ( regs.CR[6].eq ) { return 0x820676F8;  }
		/* 820676E8h case    1:*/		return 0x820676EC;
		  /* 820676ECh */ case    2:  		/* lis R11, -32768 */
		/* 820676ECh case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8000);
		/* 820676ECh case    2:*/		return 0x820676F0;
		  /* 820676F0h */ case    3:  		/* ori R11, R11, 16389 */
		/* 820676F0h case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4005);
		/* 820676F0h case    3:*/		return 0x820676F4;
		  /* 820676F4h */ case    4:  		/* stw R11, <#[R31 + 16]> */
		/* 820676F4h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 820676F4h case    4:*/		return 0x820676F8;
	}
	return 0x820676F8;
} // Block from 820676E4h-820676F8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820676F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820676F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820676F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820676F8);
		  /* 820676F8h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 820676F8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 820676F8h case    0:*/		return 0x820676FC;
		  /* 820676FCh */ case    1:  		/* stw R30, <#[R31 + 4]> */
		/* 820676FCh case    1:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000004) );
		/* 820676FCh case    1:*/		return 0x82067700;
		  /* 82067700h */ case    2:  		/* cmplw CR6, R30, R11 */
		/* 82067700h case    2:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 82067700h case    2:*/		return 0x82067704;
		  /* 82067704h */ case    3:  		/* bc 4, CR6_GT, 8 */
		/* 82067704h case    3:*/		if ( !regs.CR[6].gt ) { return 0x8206770C;  }
		/* 82067704h case    3:*/		return 0x82067708;
		  /* 82067708h */ case    4:  		/* stw R30, <#[R31 + 12]> */
		/* 82067708h case    4:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000000C) );
		/* 82067708h case    4:*/		return 0x8206770C;
	}
	return 0x8206770C;
} // Block from 820676F8h-8206770Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8206770Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206770C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206770C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206770C);
		  /* 8206770Ch */ case    0:  		/* addi R1, R1, 112 */
		/* 8206770Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8206770Ch case    0:*/		return 0x82067710;
		  /* 82067710h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82067710h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82067710h case    1:*/		return 0x82067714;
		  /* 82067714h */ case    2:  		/* mtspr LR, R12 */
		/* 82067714h case    2:*/		regs.LR = regs.R12;
		/* 82067714h case    2:*/		return 0x82067718;
		  /* 82067718h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 82067718h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82067718h case    3:*/		return 0x8206771C;
		  /* 8206771Ch */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 8206771Ch case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206771Ch case    4:*/		return 0x82067720;
		  /* 82067720h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82067720h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82067720h case    5:*/		return 0x82067724;
	}
	return 0x82067724;
} // Block from 8206770Ch-82067724h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82067724h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067724( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067724) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067724);
		  /* 82067724h */ case    0:  		/* nop */
		/* 82067724h case    0:*/		cpu::op::nop();
		/* 82067724h case    0:*/		return 0x82067728;
		  /* 82067728h */ case    1:  		/* lwz R11, <#[R3]> */
		/* 82067728h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82067728h case    1:*/		return 0x8206772C;
		  /* 8206772Ch */ case    2:  		/* rlwinm R9, R11, 28, 4, 31 */
		/* 8206772Ch case    2:*/		cpu::op::rlwinm<0,28,4,31>(regs,&regs.R9,regs.R11);
		/* 8206772Ch case    2:*/		return 0x82067730;
		  /* 82067730h */ case    3:  		/* rlwinm. R10, R11, 17, 31, 31 */
		/* 82067730h case    3:*/		cpu::op::rlwinm<1,17,31,31>(regs,&regs.R10,regs.R11);
		/* 82067730h case    3:*/		return 0x82067734;
		  /* 82067734h */ case    4:  		/* or R9, R9, R11 */
		/* 82067734h case    4:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 82067734h case    4:*/		return 0x82067738;
		  /* 82067738h */ case    5:  		/* rlwinm R9, R9, 16, 28, 31 */
		/* 82067738h case    5:*/		cpu::op::rlwinm<0,16,28,31>(regs,&regs.R9,regs.R9);
		/* 82067738h case    5:*/		return 0x8206773C;
		  /* 8206773Ch */ case    6:  		/* bc 12, CR0_EQ, 16 */
		/* 8206773Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x8206774C;  }
		/* 8206773Ch case    6:*/		return 0x82067740;
		  /* 82067740h */ case    7:  		/* rlwinm. R8, R11, 0, 17, 17 */
		/* 82067740h case    7:*/		cpu::op::rlwinm<1,0,17,17>(regs,&regs.R8,regs.R11);
		/* 82067740h case    7:*/		return 0x82067744;
		  /* 82067744h */ case    8:  		/* bc 12, CR0_EQ, 8 */
		/* 82067744h case    8:*/		if ( regs.CR[0].eq ) { return 0x8206774C;  }
		/* 82067744h case    8:*/		return 0x82067748;
		  /* 82067748h */ case    9:  		/* li R9, 15 */
		/* 82067748h case    9:*/		cpu::op::li<0>(regs,&regs.R9,0xF);
		/* 82067748h case    9:*/		return 0x8206774C;
	}
	return 0x8206774C;
} // Block from 82067724h-8206774Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8206774Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206774C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206774C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206774C);
		  /* 8206774Ch */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 8206774Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8206774Ch case    0:*/		return 0x82067750;
		  /* 82067750h */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 82067750h case    1:*/		if ( regs.CR[6].eq ) { return 0x82067764;  }
		/* 82067750h case    1:*/		return 0x82067754;
		  /* 82067754h */ case    2:  		/* rlwinm R11, R11, 0, 26, 31 */
		/* 82067754h case    2:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R11,regs.R11);
		/* 82067754h case    2:*/		return 0x82067758;
		  /* 82067758h */ case    3:  		/* cmplwi CR6, R11, 16 */
		/* 82067758h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000010);
		/* 82067758h case    3:*/		return 0x8206775C;
		  /* 8206775Ch */ case    4:  		/* li R11, 1 */
		/* 8206775Ch case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8206775Ch case    4:*/		return 0x82067760;
		  /* 82067760h */ case    5:  		/* bc 12, CR6_LT, 8 */
		/* 82067760h case    5:*/		if ( regs.CR[6].lt ) { return 0x82067768;  }
		/* 82067760h case    5:*/		return 0x82067764;
	}
	return 0x82067764;
} // Block from 8206774Ch-82067764h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82067764h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067764( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067764) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067764);
		  /* 82067764h */ case    0:  		/* li R11, 0 */
		/* 82067764h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82067764h case    0:*/		return 0x82067768;
	}
	return 0x82067768;
} // Block from 82067764h-82067768h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82067768h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067768( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067768) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067768);
		  /* 82067768h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82067768h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82067768h case    0:*/		return 0x8206776C;
		  /* 8206776Ch */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 8206776Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8206777C;  }
		/* 8206776Ch case    1:*/		return 0x82067770;
		  /* 82067770h */ case    2:  		/* cmplwi CR6, R9, 0 */
		/* 82067770h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82067770h case    2:*/		return 0x82067774;
		  /* 82067774h */ case    3:  		/* li R11, 1 */
		/* 82067774h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82067774h case    3:*/		return 0x82067778;
		  /* 82067778h */ case    4:  		/* bc 4, CR6_EQ, 8 */
		/* 82067778h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82067780;  }
		/* 82067778h case    4:*/		return 0x8206777C;
	}
	return 0x8206777C;
} // Block from 82067768h-8206777Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8206777Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206777C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206777C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206777C);
		  /* 8206777Ch */ case    0:  		/* li R11, 0 */
		/* 8206777Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8206777Ch case    0:*/		return 0x82067780;
	}
	return 0x82067780;
} // Block from 8206777Ch-82067780h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82067780h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067780( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067780) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067780);
		  /* 82067780h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82067780h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82067780h case    0:*/		return 0x82067784;
		  /* 82067784h */ case    1:  		/* mr R3, R11 */
		/* 82067784h case    1:*/		regs.R3 = regs.R11;
		/* 82067784h case    1:*/		return 0x82067788;
		  /* 82067788h */ case    2:  		/* bclr 12, CR0_EQ */
		/* 82067788h case    2:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 82067788h case    2:*/		return 0x8206778C;
	}
	return 0x8206778C;
} // Block from 82067780h-8206778Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206778Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206778C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206778C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206778C);
		  /* 8206778Ch */ case    0:  		/* cmplwi CR6, R4, 0 */
		/* 8206778Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8206778Ch case    0:*/		return 0x82067790;
		  /* 82067790h */ case    1:  		/* bclr 12, CR6_EQ */
		/* 82067790h case    1:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 82067790h case    1:*/		return 0x82067794;
	}
	return 0x82067794;
} // Block from 8206778Ch-82067794h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82067794h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067794( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067794) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067794);
		  /* 82067794h */ case    0:  		/* rlwinm R11, R9, 0, 24, 31 */
		/* 82067794h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R9);
		/* 82067794h case    0:*/		return 0x82067798;
		  /* 82067798h */ case    1:  		/* stw R11, <#[R4]> */
		/* 82067798h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 82067798h case    1:*/		return 0x8206779C;
		  /* 8206779Ch */ case    2:  		/* bclr 20, CR0_LT */
		/* 8206779Ch case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206779Ch case    2:*/		return 0x820677A0;
	}
	return 0x820677A0;
} // Block from 82067794h-820677A0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820677A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820677A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820677A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820677A0);
		  /* 820677A0h */ case    0:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 820677A0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 820677A0h case    0:*/		return 0x820677A4;
		  /* 820677A4h */ case    1:  		/* bclr 4, CR0_EQ */
		/* 820677A4h case    1:*/		if ( !regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 820677A4h case    1:*/		return 0x820677A8;
	}
	return 0x820677A8;
} // Block from 820677A0h-820677A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820677A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820677A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820677A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820677A8);
		  /* 820677A8h */ case    0:  		/* rlwinm. R11, R4, 0, 24, 31 */
		/* 820677A8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R4);
		/* 820677A8h case    0:*/		return 0x820677AC;
		  /* 820677ACh */ case    1:  		/* lwz R11, <#[R7]> */
		/* 820677ACh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 820677ACh case    1:*/		return 0x820677B0;
		  /* 820677B0h */ case    2:  		/* bc 12, CR0_EQ, 40 */
		/* 820677B0h case    2:*/		if ( regs.CR[0].eq ) { return 0x820677D8;  }
		/* 820677B0h case    2:*/		return 0x820677B4;
		  /* 820677B4h */ case    3:  		/* rlwinm R10, R11, 22, 24, 29 */
		/* 820677B4h case    3:*/		cpu::op::rlwinm<0,22,24,29>(regs,&regs.R10,regs.R11);
		/* 820677B4h case    3:*/		return 0x820677B8;
		  /* 820677B8h */ case    4:  		/* lwzx R10, <#[R10 + R8]> */
		/* 820677B8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 820677B8h case    4:*/		return 0x820677BC;
		  /* 820677BCh */ case    5:  		/* rlwimi R11, R10, 12, 14, 19 */
		/* 820677BCh case    5:*/		cpu::op::rlwimi<0,12,14,19>(regs,&regs.R11,regs.R10);
		/* 820677BCh case    5:*/		return 0x820677C0;
		  /* 820677C0h */ case    6:  		/* rlwinm R10, R11, 29, 24, 29 */
		/* 820677C0h case    6:*/		cpu::op::rlwinm<0,29,24,29>(regs,&regs.R10,regs.R11);
		/* 820677C0h case    6:*/		return 0x820677C4;
		  /* 820677C4h */ case    7:  		/* stw R11, <#[R7]> */
		/* 820677C4h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 820677C4h case    7:*/		return 0x820677C8;
		  /* 820677C8h */ case    8:  		/* lwzx R10, <#[R10 + R8]> */
		/* 820677C8h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 820677C8h case    8:*/		return 0x820677CC;
		  /* 820677CCh */ case    9:  		/* rlwimi R11, R10, 5, 21, 26 */
		/* 820677CCh case    9:*/		cpu::op::rlwimi<0,5,21,26>(regs,&regs.R11,regs.R10);
		/* 820677CCh case    9:*/		return 0x820677D0;
		  /* 820677D0h */ case   10:  		/* stw R11, <#[R7]> */
		/* 820677D0h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 820677D0h case   10:*/		return 0x820677D4;
		  /* 820677D4h */ case   11:  		/* bclr 20, CR0_LT */
		/* 820677D4h case   11:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820677D4h case   11:*/		return 0x820677D8;
	}
	return 0x820677D8;
} // Block from 820677A8h-820677D8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820677D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820677D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820677D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820677D8);
		  /* 820677D8h */ case    0:  		/* rlwinm. R10, R11, 0, 16, 16 */
		/* 820677D8h case    0:*/		cpu::op::rlwinm<1,0,16,16>(regs,&regs.R10,regs.R11);
		/* 820677D8h case    0:*/		return 0x820677DC;
		  /* 820677DCh */ case    1:  		/* bc 4, CR0_EQ, 36 */
		/* 820677DCh case    1:*/		if ( !regs.CR[0].eq ) { return 0x82067800;  }
		/* 820677DCh case    1:*/		return 0x820677E0;
		  /* 820677E0h */ case    2:  		/* rlwinm R10, R11, 26, 24, 29 */
		/* 820677E0h case    2:*/		cpu::op::rlwinm<0,26,24,29>(regs,&regs.R10,regs.R11);
		/* 820677E0h case    2:*/		return 0x820677E4;
		  /* 820677E4h */ case    3:  		/* lwzx R10, <#[R10 + R8]> */
		/* 820677E4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 820677E4h case    3:*/		return 0x820677E8;
		  /* 820677E8h */ case    4:  		/* rlwimi R11, R10, 8, 18, 23 */
		/* 820677E8h case    4:*/		cpu::op::rlwimi<0,8,18,23>(regs,&regs.R11,regs.R10);
		/* 820677E8h case    4:*/		return 0x820677EC;
		  /* 820677ECh */ case    5:  		/* rlwinm R10, R11, 2, 24, 29 */
		/* 820677ECh case    5:*/		cpu::op::rlwinm<0,2,24,29>(regs,&regs.R10,regs.R11);
		/* 820677ECh case    5:*/		return 0x820677F0;
		  /* 820677F0h */ case    6:  		/* stw R11, <#[R7]> */
		/* 820677F0h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 820677F0h case    6:*/		return 0x820677F4;
		  /* 820677F4h */ case    7:  		/* lwzx R10, <#[R10 + R8]> */
		/* 820677F4h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 820677F4h case    7:*/		return 0x820677F8;
		  /* 820677F8h */ case    8:  		/* rlwimi R10, R11, 0, 0, 25 */
		/* 820677F8h case    8:*/		cpu::op::rlwimi<0,0,0,25>(regs,&regs.R10,regs.R11);
		/* 820677F8h case    8:*/		return 0x820677FC;
		  /* 820677FCh */ case    9:  		/* stw R10, <#[R7]> */
		/* 820677FCh case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R7 + 0x00000000) );
		/* 820677FCh case    9:*/		return 0x82067800;
	}
	return 0x82067800;
} // Block from 820677D8h-82067800h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82067800h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067800( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067800) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067800);
		  /* 82067800h */ case    0:  		/* lwz R10, <#[R7 + 8]> */
		/* 82067800h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + 0x00000008) );
		/* 82067800h case    0:*/		return 0x82067804;
		  /* 82067804h */ case    1:  		/* lis R11, -32217 */
		/* 82067804h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82067804h case    1:*/		return 0x82067808;
		  /* 82067808h */ case    2:  		/* lwz R9, <#[R7]> */
		/* 82067808h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R7 + 0x00000000) );
		/* 82067808h case    2:*/		return 0x8206780C;
		  /* 8206780Ch */ case    3:  		/* addi R11, R11, 1568 */
		/* 8206780Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x620);
		/* 8206780Ch case    3:*/		return 0x82067810;
		  /* 82067810h */ case    4:  		/* rlwinm R6, R10, 8, 27, 31 */
		/* 82067810h case    4:*/		cpu::op::rlwinm<0,8,27,31>(regs,&regs.R6,regs.R10);
		/* 82067810h case    4:*/		return 0x82067814;
		  /* 82067814h */ case    5:  		/* addi R5, R11, 32 */
		/* 82067814h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x20);
		/* 82067814h case    5:*/		return 0x82067818;
		  /* 82067818h */ case    6:  		/* rlwinm R4, R9, 6, 26, 31 */
		/* 82067818h case    6:*/		cpu::op::rlwinm<0,6,26,31>(regs,&regs.R4,regs.R9);
		/* 82067818h case    6:*/		return 0x8206781C;
		  /* 8206781Ch */ case    7:  		/* lbzx R11, <#[R6 + R11]> */
		/* 8206781Ch case    7:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R6 + regs.R11 + 0x00000000) );
		/* 8206781Ch case    7:*/		return 0x82067820;
		  /* 82067820h */ case    8:  		/* lbzx R6, <#[R4 + R5]> */
		/* 82067820h case    8:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R4 + regs.R5 + 0x00000000) );
		/* 82067820h case    8:*/		return 0x82067824;
		  /* 82067824h */ case    9:  		/* cmplwi CR6, R11, 1 */
		/* 82067824h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82067824h case    9:*/		return 0x82067828;
		  /* 82067828h */ case   10:  		/* bc 12, CR6_LT, 36 */
		/* 82067828h case   10:*/		if ( regs.CR[6].lt ) { return 0x8206784C;  }
		/* 82067828h case   10:*/		return 0x8206782C;
		  /* 8206782Ch */ case   11:  		/* rlwinm. R10, R10, 0, 0, 0 */
		/* 8206782Ch case   11:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R10,regs.R10);
		/* 8206782Ch case   11:*/		return 0x82067830;
		  /* 82067830h */ case   12:  		/* bc 12, CR0_EQ, 28 */
		/* 82067830h case   12:*/		if ( regs.CR[0].eq ) { return 0x8206784C;  }
		/* 82067830h case   12:*/		return 0x82067834;
		  /* 82067834h */ case   13:  		/* lbz R10, <#[R7 + 9]> */
		/* 82067834h case   13:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R7 + 0x00000009) );
		/* 82067834h case   13:*/		return 0x82067838;
		  /* 82067838h */ case   14:  		/* rlwinm R5, R10, 2, 24, 29 */
		/* 82067838h case   14:*/		cpu::op::rlwinm<0,2,24,29>(regs,&regs.R5,regs.R10);
		/* 82067838h case   14:*/		return 0x8206783C;
		  /* 8206783Ch */ case   15:  		/* rlwinm R10, R10, 0, 0, 25 */
		/* 8206783Ch case   15:*/		cpu::op::rlwinm<0,0,0,25>(regs,&regs.R10,regs.R10);
		/* 8206783Ch case   15:*/		return 0x82067840;
		  /* 82067840h */ case   16:  		/* lwzx R5, <#[R5 + R8]> */
		/* 82067840h case   16:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + regs.R8 + 0x00000000) );
		/* 82067840h case   16:*/		return 0x82067844;
		  /* 82067844h */ case   17:  		/* or R10, R5, R10 */
		/* 82067844h case   17:*/		cpu::op::or<0>(regs,&regs.R10,regs.R5,regs.R10);
		/* 82067844h case   17:*/		return 0x82067848;
		  /* 82067848h */ case   18:  		/* stb R10, <#[R7 + 9]> */
		/* 82067848h case   18:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R7 + 0x00000009) );
		/* 82067848h case   18:*/		return 0x8206784C;
	}
	return 0x8206784C;
} // Block from 82067800h-8206784Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 8206784Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206784C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206784C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206784C);
		  /* 8206784Ch */ case    0:  		/* cmplwi CR6, R11, 2 */
		/* 8206784Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 8206784Ch case    0:*/		return 0x82067850;
		  /* 82067850h */ case    1:  		/* bc 12, CR6_LT, 40 */
		/* 82067850h case    1:*/		if ( regs.CR[6].lt ) { return 0x82067878;  }
		/* 82067850h case    1:*/		return 0x82067854;
		  /* 82067854h */ case    2:  		/* lwz R10, <#[R7 + 8]> */
		/* 82067854h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + 0x00000008) );
		/* 82067854h case    2:*/		return 0x82067858;
		  /* 82067858h */ case    3:  		/* rlwinm. R10, R10, 0, 1, 1 */
		/* 82067858h case    3:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R10);
		/* 82067858h case    3:*/		return 0x8206785C;
		  /* 8206785Ch */ case    4:  		/* bc 12, CR0_EQ, 28 */
		/* 8206785Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x82067878;  }
		/* 8206785Ch case    4:*/		return 0x82067860;
		  /* 82067860h */ case    5:  		/* lbz R10, <#[R7 + 10]> */
		/* 82067860h case    5:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R7 + 0x0000000A) );
		/* 82067860h case    5:*/		return 0x82067864;
		  /* 82067864h */ case    6:  		/* rlwinm R5, R10, 2, 24, 29 */
		/* 82067864h case    6:*/		cpu::op::rlwinm<0,2,24,29>(regs,&regs.R5,regs.R10);
		/* 82067864h case    6:*/		return 0x82067868;
		  /* 82067868h */ case    7:  		/* rlwinm R10, R10, 0, 0, 25 */
		/* 82067868h case    7:*/		cpu::op::rlwinm<0,0,0,25>(regs,&regs.R10,regs.R10);
		/* 82067868h case    7:*/		return 0x8206786C;
		  /* 8206786Ch */ case    8:  		/* lwzx R5, <#[R5 + R8]> */
		/* 8206786Ch case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + regs.R8 + 0x00000000) );
		/* 8206786Ch case    8:*/		return 0x82067870;
		  /* 82067870h */ case    9:  		/* or R10, R5, R10 */
		/* 82067870h case    9:*/		cpu::op::or<0>(regs,&regs.R10,regs.R5,regs.R10);
		/* 82067870h case    9:*/		return 0x82067874;
		  /* 82067874h */ case   10:  		/* stb R10, <#[R7 + 10]> */
		/* 82067874h case   10:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R7 + 0x0000000A) );
		/* 82067874h case   10:*/		return 0x82067878;
	}
	return 0x82067878;
} // Block from 8206784Ch-82067878h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82067878h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067878( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067878) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067878);
		  /* 82067878h */ case    0:  		/* cmplwi CR6, R11, 3 */
		/* 82067878h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 82067878h case    0:*/		return 0x8206787C;
		  /* 8206787Ch */ case    1:  		/* bc 4, CR6_LT, 12 */
		/* 8206787Ch case    1:*/		if ( !regs.CR[6].lt ) { return 0x82067888;  }
		/* 8206787Ch case    1:*/		return 0x82067880;
		  /* 82067880h */ case    2:  		/* cmplwi CR6, R6, 1 */
		/* 82067880h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000001);
		/* 82067880h case    2:*/		return 0x82067884;
		  /* 82067884h */ case    3:  		/* bc 4, CR6_EQ, 36 */
		/* 82067884h case    3:*/		if ( !regs.CR[6].eq ) { return 0x820678A8;  }
		/* 82067884h case    3:*/		return 0x82067888;
	}
	return 0x82067888;
} // Block from 82067878h-82067888h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82067888h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067888( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067888) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067888);
		  /* 82067888h */ case    0:  		/* lwz R11, <#[R7 + 8]> */
		/* 82067888h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000008) );
		/* 82067888h case    0:*/		return 0x8206788C;
		  /* 8206788Ch */ case    1:  		/* rlwinm. R10, R11, 0, 2, 2 */
		/* 8206788Ch case    1:*/		cpu::op::rlwinm<1,0,2,2>(regs,&regs.R10,regs.R11);
		/* 8206788Ch case    1:*/		return 0x82067890;
		  /* 82067890h */ case    2:  		/* bc 12, CR0_EQ, 24 */
		/* 82067890h case    2:*/		if ( regs.CR[0].eq ) { return 0x820678A8;  }
		/* 82067890h case    2:*/		return 0x82067894;
		  /* 82067894h */ case    3:  		/* rlwinm R10, R11, 2, 24, 29 */
		/* 82067894h case    3:*/		cpu::op::rlwinm<0,2,24,29>(regs,&regs.R10,regs.R11);
		/* 82067894h case    3:*/		return 0x82067898;
		  /* 82067898h */ case    4:  		/* rlwinm R11, R11, 0, 24, 25 */
		/* 82067898h case    4:*/		cpu::op::rlwinm<0,0,24,25>(regs,&regs.R11,regs.R11);
		/* 82067898h case    4:*/		return 0x8206789C;
		  /* 8206789Ch */ case    5:  		/* lwzx R10, <#[R10 + R8]> */
		/* 8206789Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 8206789Ch case    5:*/		return 0x820678A0;
		  /* 820678A0h */ case    6:  		/* or R11, R10, R11 */
		/* 820678A0h case    6:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820678A0h case    6:*/		return 0x820678A4;
		  /* 820678A4h */ case    7:  		/* stb R11, <#[R7 + 11]> */
		/* 820678A4h case    7:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R7 + 0x0000000B) );
		/* 820678A4h case    7:*/		return 0x820678A8;
	}
	return 0x820678A8;
} // Block from 82067888h-820678A8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820678A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820678A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820678A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820678A8);
		  /* 820678A8h */ case    0:  		/* cmplwi CR6, R6, 2 */
		/* 820678A8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000002);
		/* 820678A8h case    0:*/		return 0x820678AC;
		  /* 820678ACh */ case    1:  		/* bclr 4, CR6_EQ */
		/* 820678ACh case    1:*/		if ( !regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 820678ACh case    1:*/		return 0x820678B0;
	}
	return 0x820678B0;
} // Block from 820678A8h-820678B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820678B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820678B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820678B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820678B0);
		  /* 820678B0h */ case    0:  		/* lwz R11, <#[R7 + 8]> */
		/* 820678B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000008) );
		/* 820678B0h case    0:*/		return 0x820678B4;
		  /* 820678B4h */ case    1:  		/* mr R10, R9 */
		/* 820678B4h case    1:*/		regs.R10 = regs.R9;
		/* 820678B4h case    1:*/		return 0x820678B8;
		  /* 820678B8h */ case    2:  		/* lwz R6, <#[R7 + 4]> */
		/* 820678B8h case    2:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R7 + 0x00000004) );
		/* 820678B8h case    2:*/		return 0x820678BC;
		  /* 820678BCh */ case    3:  		/* rlwimi R10, R11, 30, 4, 4 */
		/* 820678BCh case    3:*/		cpu::op::rlwimi<0,30,4,4>(regs,&regs.R10,regs.R11);
		/* 820678BCh case    3:*/		return 0x820678C0;
		  /* 820678C0h */ case    4:  		/* mr R5, R6 */
		/* 820678C0h case    4:*/		regs.R5 = regs.R6;
		/* 820678C0h case    4:*/		return 0x820678C4;
		  /* 820678C4h */ case    5:  		/* rlwimi R5, R10, 6, 30, 31 */
		/* 820678C4h case    5:*/		cpu::op::rlwimi<0,6,30,31>(regs,&regs.R5,regs.R10);
		/* 820678C4h case    5:*/		return 0x820678C8;
		  /* 820678C8h */ case    6:  		/* rlwinm R10, R5, 0, 26, 31 */
		/* 820678C8h case    6:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R10,regs.R5);
		/* 820678C8h case    6:*/		return 0x820678CC;
		  /* 820678CCh */ case    7:  		/* rlwinm R5, R10, 2, 24, 29 */
		/* 820678CCh case    7:*/		cpu::op::rlwinm<0,2,24,29>(regs,&regs.R5,regs.R10);
		/* 820678CCh case    7:*/		return 0x820678D0;
		  /* 820678D0h */ case    8:  		/* rlwinm R10, R10, 0, 0, 25 */
		/* 820678D0h case    8:*/		cpu::op::rlwinm<0,0,0,25>(regs,&regs.R10,regs.R10);
		/* 820678D0h case    8:*/		return 0x820678D4;
		  /* 820678D4h */ case    9:  		/* lwzx R8, <#[R5 + R8]> */
		/* 820678D4h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R5 + regs.R8 + 0x00000000) );
		/* 820678D4h case    9:*/		return 0x820678D8;
		  /* 820678D8h */ case   10:  		/* or R10, R8, R10 */
		/* 820678D8h case   10:*/		cpu::op::or<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 820678D8h case   10:*/		return 0x820678DC;
		  /* 820678DCh */ case   11:  		/* rlwimi R6, R10, 0, 26, 29 */
		/* 820678DCh case   11:*/		cpu::op::rlwimi<0,0,26,29>(regs,&regs.R6,regs.R10);
		/* 820678DCh case   11:*/		return 0x820678E0;
		  /* 820678E0h */ case   12:  		/* rlwimi R11, R10, 28, 2, 2 */
		/* 820678E0h case   12:*/		cpu::op::rlwimi<0,28,2,2>(regs,&regs.R11,regs.R10);
		/* 820678E0h case   12:*/		return 0x820678E4;
		  /* 820678E4h */ case   13:  		/* rlwimi R9, R10, 26, 5, 5 */
		/* 820678E4h case   13:*/		cpu::op::rlwimi<0,26,5,5>(regs,&regs.R9,regs.R10);
		/* 820678E4h case   13:*/		return 0x820678E8;
		  /* 820678E8h */ case   14:  		/* stb R6, <#[R7 + 7]> */
		/* 820678E8h case   14:*/		cpu::mem::store8( regs, regs.R6, (uint32)(regs.R7 + 0x00000007) );
		/* 820678E8h case   14:*/		return 0x820678EC;
		  /* 820678ECh */ case   15:  		/* stw R11, <#[R7 + 8]> */
		/* 820678ECh case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R7 + 0x00000008) );
		/* 820678ECh case   15:*/		return 0x820678F0;
		  /* 820678F0h */ case   16:  		/* stw R9, <#[R7]> */
		/* 820678F0h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R7 + 0x00000000) );
		/* 820678F0h case   16:*/		return 0x820678F4;
		  /* 820678F4h */ case   17:  		/* bclr 20, CR0_LT */
		/* 820678F4h case   17:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820678F4h case   17:*/		return 0x820678F8;
	}
	return 0x820678F8;
} // Block from 820678B0h-820678F8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 820678F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820678F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820678F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820678F8);
		  /* 820678F8h */ case    0:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 820678F8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 820678F8h case    0:*/		return 0x820678FC;
		  /* 820678FCh */ case    1:  		/* bclr 4, CR0_EQ */
		/* 820678FCh case    1:*/		if ( !regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 820678FCh case    1:*/		return 0x82067900;
	}
	return 0x82067900;
} // Block from 820678F8h-82067900h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82067900h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067900( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067900) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067900);
		  /* 82067900h */ case    0:  		/* rlwinm. R11, R4, 0, 24, 31 */
		/* 82067900h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R4);
		/* 82067900h case    0:*/		return 0x82067904;
		  /* 82067904h */ case    1:  		/* bclr 4, CR0_EQ */
		/* 82067904h case    1:*/		if ( !regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 82067904h case    1:*/		return 0x82067908;
	}
	return 0x82067908;
} // Block from 82067900h-82067908h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82067908h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067908( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067908) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067908);
		  /* 82067908h */ case    0:  		/* lwz R11, <#[R7]> */
		/* 82067908h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 82067908h case    0:*/		return 0x8206790C;
		  /* 8206790Ch */ case    1:  		/* rlwinm. R10, R11, 0, 16, 16 */
		/* 8206790Ch case    1:*/		cpu::op::rlwinm<1,0,16,16>(regs,&regs.R10,regs.R11);
		/* 8206790Ch case    1:*/		return 0x82067910;
		  /* 82067910h */ case    2:  		/* bclr 12, CR0_EQ */
		/* 82067910h case    2:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 82067910h case    2:*/		return 0x82067914;
	}
	return 0x82067914;
} // Block from 82067908h-82067914h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82067914h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067914( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067914) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067914);
		  /* 82067914h */ case    0:  		/* rlwinm R10, R11, 2, 24, 29 */
		/* 82067914h case    0:*/		cpu::op::rlwinm<0,2,24,29>(regs,&regs.R10,regs.R11);
		/* 82067914h case    0:*/		return 0x82067918;
		  /* 82067918h */ case    1:  		/* lwzx R10, <#[R10 + R8]> */
		/* 82067918h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 82067918h case    1:*/		return 0x8206791C;
		  /* 8206791Ch */ case    2:  		/* rlwimi R10, R11, 0, 0, 25 */
		/* 8206791Ch case    2:*/		cpu::op::rlwimi<0,0,0,25>(regs,&regs.R10,regs.R11);
		/* 8206791Ch case    2:*/		return 0x82067920;
		  /* 82067920h */ case    3:  		/* stw R10, <#[R7]> */
		/* 82067920h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R7 + 0x00000000) );
		/* 82067920h case    3:*/		return 0x82067924;
		  /* 82067924h */ case    4:  		/* bclr 20, CR0_LT */
		/* 82067924h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82067924h case    4:*/		return 0x82067928;
	}
	return 0x82067928;
} // Block from 82067914h-82067928h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82067928h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067928( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067928) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067928);
		  /* 82067928h */ case    0:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82067928h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82067928h case    0:*/		return 0x8206792C;
		  /* 8206792Ch */ case    1:  		/* bclr 4, CR0_EQ */
		/* 8206792Ch case    1:*/		if ( !regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 8206792Ch case    1:*/		return 0x82067930;
	}
	return 0x82067930;
} // Block from 82067928h-82067930h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82067930h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067930( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067930) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067930);
		  /* 82067930h */ case    0:  		/* lwz R11, <#[R8]> */
		/* 82067930h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 82067930h case    0:*/		return 0x82067934;
		  /* 82067934h */ case    1:  		/* rlwinm. R10, R4, 0, 24, 31 */
		/* 82067934h case    1:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R4);
		/* 82067934h case    1:*/		return 0x82067938;
		  /* 82067938h */ case    2:  		/* bc 12, CR0_EQ, 32 */
		/* 82067938h case    2:*/		if ( regs.CR[0].eq ) { return 0x82067958;  }
		/* 82067938h case    2:*/		return 0x8206793C;
		  /* 8206793Ch */ case    3:  		/* lwz R9, <#[R7]> */
		/* 8206793Ch case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R7 + 0x00000000) );
		/* 8206793Ch case    3:*/		return 0x82067940;
		  /* 82067940h */ case    4:  		/* rlwinm R10, R9, 20, 26, 31 */
		/* 82067940h case    4:*/		cpu::op::rlwinm<0,20,26,31>(regs,&regs.R10,regs.R9);
		/* 82067940h case    4:*/		return 0x82067944;
		  /* 82067944h */ case    5:  		/* cmplw CR6, R11, R10 */
		/* 82067944h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82067944h case    5:*/		return 0x82067948;
		  /* 82067948h */ case    6:  		/* bc 12, CR6_GT, 8 */
		/* 82067948h case    6:*/		if ( regs.CR[6].gt ) { return 0x82067950;  }
		/* 82067948h case    6:*/		return 0x8206794C;
		  /* 8206794Ch */ case    7:  		/* mr R11, R10 */
		/* 8206794Ch case    7:*/		regs.R11 = regs.R10;
		/* 8206794Ch case    7:*/		return 0x82067950;
	}
	return 0x82067950;
} // Block from 82067930h-82067950h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82067950h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067950( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067950) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067950);
		  /* 82067950h */ case    0:  		/* rlwinm R10, R9, 27, 26, 31 */
		/* 82067950h case    0:*/		cpu::op::rlwinm<0,27,26,31>(regs,&regs.R10,regs.R9);
		/* 82067950h case    0:*/		return 0x82067954;
		  /* 82067954h */ case    1:  		/* b 208 */
		/* 82067954h case    1:*/		return 0x82067A24;
		/* 82067954h case    1:*/		return 0x82067958;
	}
	return 0x82067958;
} // Block from 82067950h-82067958h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82067958h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067958( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067958) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067958);
		  /* 82067958h */ case    0:  		/* lwz R6, <#[R7]> */
		/* 82067958h case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R7 + 0x00000000) );
		/* 82067958h case    0:*/		return 0x8206795C;
		  /* 8206795Ch */ case    1:  		/* rlwinm. R10, R6, 0, 16, 16 */
		/* 8206795Ch case    1:*/		cpu::op::rlwinm<1,0,16,16>(regs,&regs.R10,regs.R6);
		/* 8206795Ch case    1:*/		return 0x82067960;
		  /* 82067960h */ case    2:  		/* bc 4, CR0_EQ, 36 */
		/* 82067960h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82067984;  }
		/* 82067960h case    2:*/		return 0x82067964;
		  /* 82067964h */ case    3:  		/* rlwinm R10, R6, 24, 26, 31 */
		/* 82067964h case    3:*/		cpu::op::rlwinm<0,24,26,31>(regs,&regs.R10,regs.R6);
		/* 82067964h case    3:*/		return 0x82067968;
		  /* 82067968h */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 82067968h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82067968h case    4:*/		return 0x8206796C;
		  /* 8206796Ch */ case    5:  		/* bc 12, CR6_GT, 8 */
		/* 8206796Ch case    5:*/		if ( regs.CR[6].gt ) { return 0x82067974;  }
		/* 8206796Ch case    5:*/		return 0x82067970;
		  /* 82067970h */ case    6:  		/* mr R11, R10 */
		/* 82067970h case    6:*/		regs.R11 = regs.R10;
		/* 82067970h case    6:*/		return 0x82067974;
	}
	return 0x82067974;
} // Block from 82067958h-82067974h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82067974h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067974( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067974) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067974);
		  /* 82067974h */ case    0:  		/* rlwinm R10, R6, 0, 26, 31 */
		/* 82067974h case    0:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R10,regs.R6);
		/* 82067974h case    0:*/		return 0x82067978;
		  /* 82067978h */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 82067978h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82067978h case    1:*/		return 0x8206797C;
		  /* 8206797Ch */ case    2:  		/* bc 12, CR6_GT, 8 */
		/* 8206797Ch case    2:*/		if ( regs.CR[6].gt ) { return 0x82067984;  }
		/* 8206797Ch case    2:*/		return 0x82067980;
		  /* 82067980h */ case    3:  		/* mr R11, R10 */
		/* 82067980h case    3:*/		regs.R11 = regs.R10;
		/* 82067980h case    3:*/		return 0x82067984;
	}
	return 0x82067984;
} // Block from 82067974h-82067984h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82067984h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067984( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067984) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067984);
		  /* 82067984h */ case    0:  		/* lwz R10, <#[R7 + 8]> */
		/* 82067984h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + 0x00000008) );
		/* 82067984h case    0:*/		return 0x82067988;
		  /* 82067988h */ case    1:  		/* lis R9, -32217 */
		/* 82067988h case    1:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8227);
		/* 82067988h case    1:*/		return 0x8206798C;
		  /* 8206798Ch */ case    2:  		/* rlwinm R4, R6, 6, 26, 31 */
		/* 8206798Ch case    2:*/		cpu::op::rlwinm<0,6,26,31>(regs,&regs.R4,regs.R6);
		/* 8206798Ch case    2:*/		return 0x82067990;
		  /* 82067990h */ case    3:  		/* addi R9, R9, 1568 */
		/* 82067990h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x620);
		/* 82067990h case    3:*/		return 0x82067994;
		  /* 82067994h */ case    4:  		/* rlwinm R5, R10, 8, 27, 31 */
		/* 82067994h case    4:*/		cpu::op::rlwinm<0,8,27,31>(regs,&regs.R5,regs.R10);
		/* 82067994h case    4:*/		return 0x82067998;
		  /* 82067998h */ case    5:  		/* addi R3, R9, 32 */
		/* 82067998h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R9,0x20);
		/* 82067998h case    5:*/		return 0x8206799C;
		  /* 8206799Ch */ case    6:  		/* lbzx R5, <#[R5 + R9]> */
		/* 8206799Ch case    6:*/		cpu::mem::load8z( regs, &regs.R5, (uint32)(regs.R5 + regs.R9 + 0x00000000) );
		/* 8206799Ch case    6:*/		return 0x820679A0;
		  /* 820679A0h */ case    7:  		/* lbzx R4, <#[R4 + R3]> */
		/* 820679A0h case    7:*/		cpu::mem::load8z( regs, &regs.R4, (uint32)(regs.R4 + regs.R3 + 0x00000000) );
		/* 820679A0h case    7:*/		return 0x820679A4;
		  /* 820679A4h */ case    8:  		/* cmplwi CR6, R5, 1 */
		/* 820679A4h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000001);
		/* 820679A4h case    8:*/		return 0x820679A8;
		  /* 820679A8h */ case    9:  		/* bc 12, CR6_LT, 28 */
		/* 820679A8h case    9:*/		if ( regs.CR[6].lt ) { return 0x820679C4;  }
		/* 820679A8h case    9:*/		return 0x820679AC;
		  /* 820679ACh */ case   10:  		/* rlwinm. R9, R10, 0, 0, 0 */
		/* 820679ACh case   10:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R9,regs.R10);
		/* 820679ACh case   10:*/		return 0x820679B0;
		  /* 820679B0h */ case   11:  		/* bc 12, CR0_EQ, 20 */
		/* 820679B0h case   11:*/		if ( regs.CR[0].eq ) { return 0x820679C4;  }
		/* 820679B0h case   11:*/		return 0x820679B4;
		  /* 820679B4h */ case   12:  		/* rlwinm R9, R10, 16, 26, 31 */
		/* 820679B4h case   12:*/		cpu::op::rlwinm<0,16,26,31>(regs,&regs.R9,regs.R10);
		/* 820679B4h case   12:*/		return 0x820679B8;
		  /* 820679B8h */ case   13:  		/* cmplw CR6, R11, R9 */
		/* 820679B8h case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820679B8h case   13:*/		return 0x820679BC;
		  /* 820679BCh */ case   14:  		/* bc 12, CR6_GT, 8 */
		/* 820679BCh case   14:*/		if ( regs.CR[6].gt ) { return 0x820679C4;  }
		/* 820679BCh case   14:*/		return 0x820679C0;
		  /* 820679C0h */ case   15:  		/* mr R11, R9 */
		/* 820679C0h case   15:*/		regs.R11 = regs.R9;
		/* 820679C0h case   15:*/		return 0x820679C4;
	}
	return 0x820679C4;
} // Block from 82067984h-820679C4h (16 instructions)

//////////////////////////////////////////////////////
// Block at 820679C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820679C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820679C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820679C4);
		  /* 820679C4h */ case    0:  		/* cmplwi CR6, R5, 2 */
		/* 820679C4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000002);
		/* 820679C4h case    0:*/		return 0x820679C8;
		  /* 820679C8h */ case    1:  		/* bc 12, CR6_LT, 28 */
		/* 820679C8h case    1:*/		if ( regs.CR[6].lt ) { return 0x820679E4;  }
		/* 820679C8h case    1:*/		return 0x820679CC;
		  /* 820679CCh */ case    2:  		/* rlwinm. R9, R10, 0, 1, 1 */
		/* 820679CCh case    2:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R9,regs.R10);
		/* 820679CCh case    2:*/		return 0x820679D0;
		  /* 820679D0h */ case    3:  		/* bc 12, CR0_EQ, 20 */
		/* 820679D0h case    3:*/		if ( regs.CR[0].eq ) { return 0x820679E4;  }
		/* 820679D0h case    3:*/		return 0x820679D4;
		  /* 820679D4h */ case    4:  		/* rlwinm R9, R10, 24, 26, 31 */
		/* 820679D4h case    4:*/		cpu::op::rlwinm<0,24,26,31>(regs,&regs.R9,regs.R10);
		/* 820679D4h case    4:*/		return 0x820679D8;
		  /* 820679D8h */ case    5:  		/* cmplw CR6, R11, R9 */
		/* 820679D8h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 820679D8h case    5:*/		return 0x820679DC;
		  /* 820679DCh */ case    6:  		/* bc 12, CR6_GT, 8 */
		/* 820679DCh case    6:*/		if ( regs.CR[6].gt ) { return 0x820679E4;  }
		/* 820679DCh case    6:*/		return 0x820679E0;
		  /* 820679E0h */ case    7:  		/* mr R11, R9 */
		/* 820679E0h case    7:*/		regs.R11 = regs.R9;
		/* 820679E0h case    7:*/		return 0x820679E4;
	}
	return 0x820679E4;
} // Block from 820679C4h-820679E4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 820679E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820679E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820679E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820679E4);
		  /* 820679E4h */ case    0:  		/* cmplwi CR6, R5, 3 */
		/* 820679E4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000003);
		/* 820679E4h case    0:*/		return 0x820679E8;
		  /* 820679E8h */ case    1:  		/* bc 4, CR6_LT, 12 */
		/* 820679E8h case    1:*/		if ( !regs.CR[6].lt ) { return 0x820679F4;  }
		/* 820679E8h case    1:*/		return 0x820679EC;
		  /* 820679ECh */ case    2:  		/* cmplwi CR6, R4, 1 */
		/* 820679ECh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000001);
		/* 820679ECh case    2:*/		return 0x820679F0;
		  /* 820679F0h */ case    3:  		/* bc 4, CR6_EQ, 28 */
		/* 820679F0h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82067A0C;  }
		/* 820679F0h case    3:*/		return 0x820679F4;
	}
	return 0x820679F4;
} // Block from 820679E4h-820679F4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820679F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820679F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820679F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820679F4);
		  /* 820679F4h */ case    0:  		/* rlwinm. R9, R10, 0, 2, 2 */
		/* 820679F4h case    0:*/		cpu::op::rlwinm<1,0,2,2>(regs,&regs.R9,regs.R10);
		/* 820679F4h case    0:*/		return 0x820679F8;
		  /* 820679F8h */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 820679F8h case    1:*/		if ( regs.CR[0].eq ) { return 0x82067A0C;  }
		/* 820679F8h case    1:*/		return 0x820679FC;
		  /* 820679FCh */ case    2:  		/* rlwinm R9, R10, 0, 26, 31 */
		/* 820679FCh case    2:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R9,regs.R10);
		/* 820679FCh case    2:*/		return 0x82067A00;
		  /* 82067A00h */ case    3:  		/* cmplw CR6, R11, R9 */
		/* 82067A00h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82067A00h case    3:*/		return 0x82067A04;
		  /* 82067A04h */ case    4:  		/* bc 12, CR6_GT, 8 */
		/* 82067A04h case    4:*/		if ( regs.CR[6].gt ) { return 0x82067A0C;  }
		/* 82067A04h case    4:*/		return 0x82067A08;
		  /* 82067A08h */ case    5:  		/* mr R11, R9 */
		/* 82067A08h case    5:*/		regs.R11 = regs.R9;
		/* 82067A08h case    5:*/		return 0x82067A0C;
	}
	return 0x82067A0C;
} // Block from 820679F4h-82067A0Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 82067A0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067A0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067A0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067A0C);
		  /* 82067A0Ch */ case    0:  		/* cmplwi CR6, R4, 2 */
		/* 82067A0Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000002);
		/* 82067A0Ch case    0:*/		return 0x82067A10;
		  /* 82067A10h */ case    1:  		/* bc 4, CR6_EQ, 32 */
		/* 82067A10h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82067A30;  }
		/* 82067A10h case    1:*/		return 0x82067A14;
		  /* 82067A14h */ case    2:  		/* lwz R9, <#[R7 + 4]> */
		/* 82067A14h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R7 + 0x00000004) );
		/* 82067A14h case    2:*/		return 0x82067A18;
		  /* 82067A18h */ case    3:  		/* rlwimi R6, R10, 30, 4, 4 */
		/* 82067A18h case    3:*/		cpu::op::rlwimi<0,30,4,4>(regs,&regs.R6,regs.R10);
		/* 82067A18h case    3:*/		return 0x82067A1C;
		  /* 82067A1Ch */ case    4:  		/* rlwimi R9, R6, 6, 30, 31 */
		/* 82067A1Ch case    4:*/		cpu::op::rlwimi<0,6,30,31>(regs,&regs.R9,regs.R6);
		/* 82067A1Ch case    4:*/		return 0x82067A20;
		  /* 82067A20h */ case    5:  		/* rlwinm R10, R9, 0, 26, 31 */
		/* 82067A20h case    5:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R10,regs.R9);
		/* 82067A20h case    5:*/		return 0x82067A24;
	}
	return 0x82067A24;
} // Block from 82067A0Ch-82067A24h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82067A24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067A24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067A24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067A24);
		  /* 82067A24h */ case    0:  		/* cmplw CR6, R11, R10 */
		/* 82067A24h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82067A24h case    0:*/		return 0x82067A28;
		  /* 82067A28h */ case    1:  		/* bc 12, CR6_GT, 8 */
		/* 82067A28h case    1:*/		if ( regs.CR[6].gt ) { return 0x82067A30;  }
		/* 82067A28h case    1:*/		return 0x82067A2C;
		  /* 82067A2Ch */ case    2:  		/* mr R11, R10 */
		/* 82067A2Ch case    2:*/		regs.R11 = regs.R10;
		/* 82067A2Ch case    2:*/		return 0x82067A30;
	}
	return 0x82067A30;
} // Block from 82067A24h-82067A30h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82067A30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067A30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067A30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067A30);
		  /* 82067A30h */ case    0:  		/* stw R11, <#[R8]> */
		/* 82067A30h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 82067A30h case    0:*/		return 0x82067A34;
		  /* 82067A34h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82067A34h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82067A34h case    1:*/		return 0x82067A38;
	}
	return 0x82067A38;
} // Block from 82067A30h-82067A38h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82067A38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067A38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067A38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067A38);
		  /* 82067A38h */ case    0:  		/* lwz R9, <#[R3]> */
		/* 82067A38h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 82067A38h case    0:*/		return 0x82067A3C;
		  /* 82067A3Ch */ case    1:  		/* li R3, 1 */
		/* 82067A3Ch case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82067A3Ch case    1:*/		return 0x82067A40;
		  /* 82067A40h */ case    2:  		/* li R6, 0 */
		/* 82067A40h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82067A40h case    2:*/		return 0x82067A44;
		  /* 82067A44h */ case    3:  		/* rlwinm R11, R9, 0, 20, 31 */
		/* 82067A44h case    3:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R11,regs.R9);
		/* 82067A44h case    3:*/		return 0x82067A48;
		  /* 82067A48h */ case    4:  		/* rlwinm. R7, R9, 20, 29, 31 */
		/* 82067A48h case    4:*/		cpu::op::rlwinm<1,20,29,31>(regs,&regs.R7,regs.R9);
		/* 82067A48h case    4:*/		return 0x82067A4C;
		  /* 82067A4Ch */ case    5:  		/* mulli R11, R11, 12 */
		/* 82067A4Ch case    5:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 82067A4Ch case    5:*/		return 0x82067A50;
		  /* 82067A50h */ case    6:  		/* add R10, R11, R4 */
		/* 82067A50h case    6:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R4);
		/* 82067A50h case    6:*/		return 0x82067A54;
		  /* 82067A54h */ case    7:  		/* rlwinm R4, R9, 16, 20, 31 */
		/* 82067A54h case    7:*/		cpu::op::rlwinm<0,16,20,31>(regs,&regs.R4,regs.R9);
		/* 82067A54h case    7:*/		return 0x82067A58;
		  /* 82067A58h */ case    8:  		/* bclr 12, CR0_EQ */
		/* 82067A58h case    8:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 82067A58h case    8:*/		return 0x82067A5C;
	}
	return 0x82067A5C;
} // Block from 82067A38h-82067A5Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 82067A5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067A5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067A5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067A5C);
		  /* 82067A5Ch */ case    0:  		/* li R5, 0 */
		/* 82067A5Ch case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82067A5Ch case    0:*/		return 0x82067A60;
		  /* 82067A60h */ case    1:  		/* slw R11, R3, R5 */
		/* 82067A60h case    1:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R3,regs.R5);
		/* 82067A60h case    1:*/		return 0x82067A64;
		  /* 82067A64h */ case    2:  		/* and. R11, R11, R4 */
		/* 82067A64h case    2:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R4);
		/* 82067A64h case    2:*/		return 0x82067A68;
		  /* 82067A68h */ case    3:  		/* bc 4, CR0_EQ, 88 */
		/* 82067A68h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82067AC0;  }
		/* 82067A68h case    3:*/		return 0x82067A6C;
		  /* 82067A6Ch */ case    4:  		/* lbz R11, <#[R10 + 8]> */
		/* 82067A6Ch case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 82067A6Ch case    4:*/		return 0x82067A70;
		  /* 82067A70h */ case    5:  		/* lwz R9, <#[R10]> */
		/* 82067A70h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82067A70h case    5:*/		return 0x82067A74;
		  /* 82067A74h */ case    6:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 82067A74h case    6:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 82067A74h case    6:*/		return 0x82067A78;
	}
	return 0x82067A78;
} // Block from 82067A5Ch-82067A78h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82067A78h
// Function '?Clear@Microcode@CMicrocodeBuilder@D3D@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067A78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067A78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067A78);
		  /* 82067A78h */ case    0:  		/* rlwinm R9, R9, 6, 26, 31 */
		/* 82067A78h case    0:*/		cpu::op::rlwinm<0,6,26,31>(regs,&regs.R9,regs.R9);
		/* 82067A78h case    0:*/		return 0x82067A7C;
		  /* 82067A7Ch */ case    1:  		/* cmplwi CR6, R11, 20 */
		/* 82067A7Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000014);
		/* 82067A7Ch case    1:*/		return 0x82067A80;
		  /* 82067A80h */ case    2:  		/* bc 12, CR6_LT, 16 */
		/* 82067A80h case    2:*/		if ( regs.CR[6].lt ) { return 0x82067A90;  }
		/* 82067A80h case    2:*/		return 0x82067A84;
		  /* 82067A84h */ case    3:  		/* cmplwi CR6, R11, 23 */
		/* 82067A84h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000017);
		/* 82067A84h case    3:*/		return 0x82067A88;
		  /* 82067A88h */ case    4:  		/* mr R11, R3 */
		/* 82067A88h case    4:*/		regs.R11 = regs.R3;
		/* 82067A88h case    4:*/		return 0x82067A8C;
		  /* 82067A8Ch */ case    5:  		/* bc 4, CR6_GT, 8 */
		/* 82067A8Ch case    5:*/		if ( !regs.CR[6].gt ) { return 0x82067A94;  }
		/* 82067A8Ch case    5:*/		return 0x82067A90;
	}
	return 0x82067A90;
} // Block from 82067A78h-82067A90h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82067A90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067A90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067A90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067A90);
		  /* 82067A90h */ case    0:  		/* li R11, 0 */
		/* 82067A90h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82067A90h case    0:*/		return 0x82067A94;
	}
	return 0x82067A94;
} // Block from 82067A90h-82067A94h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82067A94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067A94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067A94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067A94);
		  /* 82067A94h */ case    0:  		/* rlwinm R8, R11, 0, 24, 31 */
		/* 82067A94h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R8,regs.R11);
		/* 82067A94h case    0:*/		return 0x82067A98;
		  /* 82067A98h */ case    1:  		/* cmplwi CR6, R9, 27 */
		/* 82067A98h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x0000001B);
		/* 82067A98h case    1:*/		return 0x82067A9C;
		  /* 82067A9Ch */ case    2:  		/* bc 12, CR6_LT, 16 */
		/* 82067A9Ch case    2:*/		if ( regs.CR[6].lt ) { return 0x82067AAC;  }
		/* 82067A9Ch case    2:*/		return 0x82067AA0;
		  /* 82067AA0h */ case    3:  		/* cmplwi CR6, R9, 34 */
		/* 82067AA0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000022);
		/* 82067AA0h case    3:*/		return 0x82067AA4;
		  /* 82067AA4h */ case    4:  		/* mr R11, R3 */
		/* 82067AA4h case    4:*/		regs.R11 = regs.R3;
		/* 82067AA4h case    4:*/		return 0x82067AA8;
		  /* 82067AA8h */ case    5:  		/* bc 4, CR6_GT, 8 */
		/* 82067AA8h case    5:*/		if ( !regs.CR[6].gt ) { return 0x82067AB0;  }
		/* 82067AA8h case    5:*/		return 0x82067AAC;
	}
	return 0x82067AAC;
} // Block from 82067A94h-82067AACh (6 instructions)

//////////////////////////////////////////////////////
// Block at 82067AACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067AAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067AAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067AAC);
		  /* 82067AACh */ case    0:  		/* li R11, 0 */
		/* 82067AACh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82067AACh case    0:*/		return 0x82067AB0;
	}
	return 0x82067AB0;
} // Block from 82067AACh-82067AB0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82067AB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067AB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067AB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067AB0);
		  /* 82067AB0h */ case    0:  		/* rlwinm. R9, R8, 0, 24, 31 */
		/* 82067AB0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R9,regs.R8);
		/* 82067AB0h case    0:*/		return 0x82067AB4;
		  /* 82067AB4h */ case    1:  		/* bc 4, CR0_EQ, 36 */
		/* 82067AB4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82067AD8;  }
		/* 82067AB4h case    1:*/		return 0x82067AB8;
		  /* 82067AB8h */ case    2:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82067AB8h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82067AB8h case    2:*/		return 0x82067ABC;
		  /* 82067ABCh */ case    3:  		/* bc 4, CR0_EQ, 28 */
		/* 82067ABCh case    3:*/		if ( !regs.CR[0].eq ) { return 0x82067AD8;  }
		/* 82067ABCh case    3:*/		return 0x82067AC0;
	}
	return 0x82067AC0;
} // Block from 82067AB0h-82067AC0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82067AC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067AC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067AC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067AC0);
		  /* 82067AC0h */ case    0:  		/* addi R6, R6, 1 */
		/* 82067AC0h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 82067AC0h case    0:*/		return 0x82067AC4;
		  /* 82067AC4h */ case    1:  		/* addi R5, R5, 2 */
		/* 82067AC4h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x2);
		/* 82067AC4h case    1:*/		return 0x82067AC8;
		  /* 82067AC8h */ case    2:  		/* addi R10, R10, 12 */
		/* 82067AC8h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xC);
		/* 82067AC8h case    2:*/		return 0x82067ACC;
		  /* 82067ACCh */ case    3:  		/* cmplw CR6, R6, R7 */
		/* 82067ACCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R7);
		/* 82067ACCh case    3:*/		return 0x82067AD0;
		  /* 82067AD0h */ case    4:  		/* bc 12, CR6_LT, -112 */
		/* 82067AD0h case    4:*/		if ( regs.CR[6].lt ) { return 0x82067A60;  }
		/* 82067AD0h case    4:*/		return 0x82067AD4;
		  /* 82067AD4h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82067AD4h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82067AD4h case    5:*/		return 0x82067AD8;
	}
	return 0x82067AD8;
} // Block from 82067AC0h-82067AD8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82067AD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067AD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067AD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067AD8);
		  /* 82067AD8h */ case    0:  		/* li R3, 0 */
		/* 82067AD8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82067AD8h case    0:*/		return 0x82067ADC;
		  /* 82067ADCh */ case    1:  		/* bclr 20, CR0_LT */
		/* 82067ADCh case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82067ADCh case    1:*/		return 0x82067AE0;
	}
	return 0x82067AE0;
} // Block from 82067AD8h-82067AE0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82067AE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067AE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067AE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067AE0);
		  /* 82067AE0h */ case    0:  		/* mfspr R12, LR */
		/* 82067AE0h case    0:*/		regs.R12 = regs.LR;
		/* 82067AE0h case    0:*/		return 0x82067AE4;
		  /* 82067AE4h */ case    1:  		/* bl 169848 */
		/* 82067AE4h case    1:*/		regs.LR = 0x82067AE8; return 0x8209125C;
		/* 82067AE4h case    1:*/		return 0x82067AE8;
		  /* 82067AE8h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82067AE8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82067AE8h case    2:*/		return 0x82067AEC;
		  /* 82067AECh */ case    3:  		/* mr R29, R7 */
		/* 82067AECh case    3:*/		regs.R29 = regs.R7;
		/* 82067AECh case    3:*/		return 0x82067AF0;
		  /* 82067AF0h */ case    4:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82067AF0h case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82067AF0h case    4:*/		return 0x82067AF4;
		  /* 82067AF4h */ case    5:  		/* bc 12, CR0_EQ, 176 */
		/* 82067AF4h case    5:*/		if ( regs.CR[0].eq ) { return 0x82067BA4;  }
		/* 82067AF4h case    5:*/		return 0x82067AF8;
		  /* 82067AF8h */ case    6:  		/* lwz R31, <#[R7 + 4]> */
		/* 82067AF8h case    6:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R7 + 0x00000004) );
		/* 82067AF8h case    6:*/		return 0x82067AFC;
		  /* 82067AFCh */ case    7:  		/* li R11, 1 */
		/* 82067AFCh case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82067AFCh case    7:*/		return 0x82067B00;
		  /* 82067B00h */ case    8:  		/* rlwinm R30, R31, 20, 28, 31 */
		/* 82067B00h case    8:*/		cpu::op::rlwinm<0,20,28,31>(regs,&regs.R30,regs.R31);
		/* 82067B00h case    8:*/		return 0x82067B04;
		  /* 82067B04h */ case    9:  		/* slw R11, R11, R30 */
		/* 82067B04h case    9:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 82067B04h case    9:*/		return 0x82067B08;
		  /* 82067B08h */ case   10:  		/* andi. R11, R11, 24702 */
		/* 82067B08h case   10:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x607E);
		/* 82067B08h case   10:*/		return 0x82067B0C;
		  /* 82067B0Ch */ case   11:  		/* cmplwi CR0, R11, 0 */
		/* 82067B0Ch case   11:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82067B0Ch case   11:*/		return 0x82067B10;
		  /* 82067B10h */ case   12:  		/* bc 12, CR0_EQ, 148 */
		/* 82067B10h case   12:*/		if ( regs.CR[0].eq ) { return 0x82067BA4;  }
		/* 82067B10h case   12:*/		return 0x82067B14;
		  /* 82067B14h */ case   13:  		/* mr R4, R8 */
		/* 82067B14h case   13:*/		regs.R4 = regs.R8;
		/* 82067B14h case   13:*/		return 0x82067B18;
		  /* 82067B18h */ case   14:  		/* mr R3, R7 */
		/* 82067B18h case   14:*/		regs.R3 = regs.R7;
		/* 82067B18h case   14:*/		return 0x82067B1C;
		  /* 82067B1Ch */ case   15:  		/* bl -228 */
		/* 82067B1Ch case   15:*/		regs.LR = 0x82067B20; return 0x82067A38;
		/* 82067B1Ch case   15:*/		return 0x82067B20;
		  /* 82067B20h */ case   16:  		/* rlwinm R11, R3, 0, 24, 31 */
		/* 82067B20h case   16:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82067B20h case   16:*/		return 0x82067B24;
		  /* 82067B24h */ case   17:  		/* cmplwi CR6, R30, 6 */
		/* 82067B24h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000006);
		/* 82067B24h case   17:*/		return 0x82067B28;
		  /* 82067B28h */ case   18:  		/* addic R10, R11, -1 */
		/* 82067B28h case   18:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R11,0xFFFFFFFF);
		/* 82067B28h case   18:*/		return 0x82067B2C;
		  /* 82067B2Ch */ case   19:  		/* subfe R11, R10, R11 */
		/* 82067B2Ch case   19:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82067B2Ch case   19:*/		return 0x82067B30;
		  /* 82067B30h */ case   20:  		/* bc 12, CR6_GT, 56 */
		/* 82067B30h case   20:*/		if ( regs.CR[6].gt ) { return 0x82067B68;  }
		/* 82067B30h case   20:*/		return 0x82067B34;
		  /* 82067B34h */ case   21:  		/* cmplwi CR6, R30, 5 */
		/* 82067B34h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000005);
		/* 82067B34h case   21:*/		return 0x82067B38;
	}
	return 0x82067B38;
} // Block from 82067AE0h-82067B38h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82067B38h
// Function '?Initialize@Microcode@CMicrocodeBuilder@D3D@@QAAXPAV23@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067B38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067B38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067B38);
		  /* 82067B38h */ case    0:  		/* bc 4, CR6_LT, 40 */
		/* 82067B38h case    0:*/		if ( !regs.CR[6].lt ) { return 0x82067B60;  }
		/* 82067B38h case    0:*/		return 0x82067B3C;
		  /* 82067B3Ch */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 82067B3Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82067B3Ch case    1:*/		return 0x82067B40;
		  /* 82067B40h */ case    2:  		/* bc 12, CR6_EQ, 100 */
		/* 82067B40h case    2:*/		if ( regs.CR[6].eq ) { return 0x82067BA4;  }
		/* 82067B40h case    2:*/		return 0x82067B44;
		  /* 82067B44h */ case    3:  		/* cmplwi CR6, R30, 2 */
		/* 82067B44h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000002);
		/* 82067B44h case    3:*/		return 0x82067B48;
		  /* 82067B48h */ case    4:  		/* bc 4, CR6_GT, 24 */
		/* 82067B48h case    4:*/		if ( !regs.CR[6].gt ) { return 0x82067B60;  }
		/* 82067B48h case    4:*/		return 0x82067B4C;
		  /* 82067B4Ch */ case    5:  		/* cmplwi CR6, R30, 3 */
		/* 82067B4Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000003);
		/* 82067B4Ch case    5:*/		return 0x82067B50;
		  /* 82067B50h */ case    6:  		/* bc 12, CR6_EQ, 60 */
		/* 82067B50h case    6:*/		if ( regs.CR[6].eq ) { return 0x82067B8C;  }
		/* 82067B50h case    6:*/		return 0x82067B54;
		  /* 82067B54h */ case    7:  		/* cmplwi CR6, R30, 4 */
		/* 82067B54h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000004);
		/* 82067B54h case    7:*/		return 0x82067B58;
		  /* 82067B58h */ case    8:  		/* bc 12, CR6_EQ, 32 */
		/* 82067B58h case    8:*/		if ( regs.CR[6].eq ) { return 0x82067B78;  }
		/* 82067B58h case    8:*/		return 0x82067B5C;
		  /* 82067B5Ch */ case    9:  		/* b 72 */
		/* 82067B5Ch case    9:*/		return 0x82067BA4;
		/* 82067B5Ch case    9:*/		return 0x82067B60;
	}
	return 0x82067B60;
} // Block from 82067B38h-82067B60h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82067B60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067B60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067B60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067B60);
		  /* 82067B60h */ case    0:  		/* rlwimi R31, R11, 9, 22, 22 */
		/* 82067B60h case    0:*/		cpu::op::rlwimi<0,9,22,22>(regs,&regs.R31,regs.R11);
		/* 82067B60h case    0:*/		return 0x82067B64;
		  /* 82067B64h */ case    1:  		/* b 60 */
		/* 82067B64h case    1:*/		return 0x82067BA0;
		/* 82067B64h case    1:*/		return 0x82067B68;
	}
	return 0x82067B68;
} // Block from 82067B60h-82067B68h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82067B68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067B68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067B68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067B68);
		  /* 82067B68h */ case    0:  		/* cmplwi CR6, R30, 13 */
		/* 82067B68h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x0000000D);
		/* 82067B68h case    0:*/		return 0x82067B6C;
		  /* 82067B6Ch */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 82067B6Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x82067B8C;  }
		/* 82067B6Ch case    1:*/		return 0x82067B70;
		  /* 82067B70h */ case    2:  		/* cmplwi CR6, R30, 14 */
		/* 82067B70h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x0000000E);
		/* 82067B70h case    2:*/		return 0x82067B74;
		  /* 82067B74h */ case    3:  		/* bc 4, CR6_EQ, 48 */
		/* 82067B74h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82067BA4;  }
		/* 82067B74h case    3:*/		return 0x82067B78;
	}
	return 0x82067B78;
} // Block from 82067B68h-82067B78h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82067B78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067B78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067B78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067B78);
		  /* 82067B78h */ case    0:  		/* subfic R11, R11, 0 */
		/* 82067B78h case    0:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x0);
		/* 82067B78h case    0:*/		return 0x82067B7C;
		  /* 82067B7Ch */ case    1:  		/* subfe R11, R11, R11 */
		/* 82067B7Ch case    1:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82067B7Ch case    1:*/		return 0x82067B80;
		  /* 82067B80h */ case    2:  		/* andi. R11, R11, 10 */
		/* 82067B80h case    2:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0xA);
		/* 82067B80h case    2:*/		return 0x82067B84;
		  /* 82067B84h */ case    3:  		/* addi R11, R11, 4 */
		/* 82067B84h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82067B84h case    3:*/		return 0x82067B88;
		  /* 82067B88h */ case    4:  		/* b 20 */
		/* 82067B88h case    4:*/		return 0x82067B9C;
		/* 82067B88h case    4:*/		return 0x82067B8C;
	}
	return 0x82067B8C;
} // Block from 82067B78h-82067B8Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82067B8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067B8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067B8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067B8C);
		  /* 82067B8Ch */ case    0:  		/* subfic R11, R11, 0 */
		/* 82067B8Ch case    0:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x0);
		/* 82067B8Ch case    0:*/		return 0x82067B90;
		  /* 82067B90h */ case    1:  		/* subfe R11, R11, R11 */
		/* 82067B90h case    1:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82067B90h case    1:*/		return 0x82067B94;
		  /* 82067B94h */ case    2:  		/* andi. R11, R11, 10 */
		/* 82067B94h case    2:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0xA);
		/* 82067B94h case    2:*/		return 0x82067B98;
		  /* 82067B98h */ case    3:  		/* addi R11, R11, 3 */
		/* 82067B98h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x3);
		/* 82067B98h case    3:*/		return 0x82067B9C;
	}
	return 0x82067B9C;
} // Block from 82067B8Ch-82067B9Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82067B9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067B9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067B9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067B9C);
		  /* 82067B9Ch */ case    0:  		/* rlwimi R31, R11, 12, 16, 19 */
		/* 82067B9Ch case    0:*/		cpu::op::rlwimi<0,12,16,19>(regs,&regs.R31,regs.R11);
		/* 82067B9Ch case    0:*/		return 0x82067BA0;
	}
	return 0x82067BA0;
} // Block from 82067B9Ch-82067BA0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82067BA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067BA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067BA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067BA0);
		  /* 82067BA0h */ case    0:  		/* stw R31, <#[R29 + 4]> */
		/* 82067BA0h case    0:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R29 + 0x00000004) );
		/* 82067BA0h case    0:*/		return 0x82067BA4;
	}
	return 0x82067BA4;
} // Block from 82067BA0h-82067BA4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82067BA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067BA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067BA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067BA4);
		  /* 82067BA4h */ case    0:  		/* addi R1, R1, 112 */
		/* 82067BA4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82067BA4h case    0:*/		return 0x82067BA8;
		  /* 82067BA8h */ case    1:  		/* b 169732 */
		/* 82067BA8h case    1:*/		return 0x820912AC;
		/* 82067BA8h case    1:*/		return 0x82067BAC;
		  /* 82067BACh */ case    2:  		/* nop */
		/* 82067BACh case    2:*/		cpu::op::nop();
		/* 82067BACh case    2:*/		return 0x82067BB0;
	}
	return 0x82067BB0;
} // Block from 82067BA4h-82067BB0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82067BB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067BB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067BB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067BB0);
		  /* 82067BB0h */ case    0:  		/* mfspr R12, LR */
		/* 82067BB0h case    0:*/		regs.R12 = regs.LR;
		/* 82067BB0h case    0:*/		return 0x82067BB4;
		  /* 82067BB4h */ case    1:  		/* bl 169640 */
		/* 82067BB4h case    1:*/		regs.LR = 0x82067BB8; return 0x8209125C;
		/* 82067BB4h case    1:*/		return 0x82067BB8;
		  /* 82067BB8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82067BB8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82067BB8h case    2:*/		return 0x82067BBC;
		  /* 82067BBCh */ case    3:  		/* mr R29, R6 */
		/* 82067BBCh case    3:*/		regs.R29 = regs.R6;
		/* 82067BBCh case    3:*/		return 0x82067BC0;
		  /* 82067BC0h */ case    4:  		/* mr R30, R7 */
		/* 82067BC0h case    4:*/		regs.R30 = regs.R7;
		/* 82067BC0h case    4:*/		return 0x82067BC4;
		  /* 82067BC4h */ case    5:  		/* mr R31, R8 */
		/* 82067BC4h case    5:*/		regs.R31 = regs.R8;
		/* 82067BC4h case    5:*/		return 0x82067BC8;
		  /* 82067BC8h */ case    6:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82067BC8h case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82067BC8h case    6:*/		return 0x82067BCC;
		  /* 82067BCCh */ case    7:  		/* bc 4, CR0_EQ, 176 */
		/* 82067BCCh case    7:*/		if ( !regs.CR[0].eq ) { return 0x82067C7C;  }
		/* 82067BCCh case    7:*/		return 0x82067BD0;
		  /* 82067BD0h */ case    8:  		/* rlwinm. R11, R4, 0, 24, 31 */
		/* 82067BD0h case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R4);
		/* 82067BD0h case    8:*/		return 0x82067BD4;
		  /* 82067BD4h */ case    9:  		/* bc 4, CR0_EQ, 168 */
		/* 82067BD4h case    9:*/		if ( !regs.CR[0].eq ) { return 0x82067C7C;  }
		/* 82067BD4h case    9:*/		return 0x82067BD8;
		  /* 82067BD8h */ case   10:  		/* addi R4, R1, 80 */
		/* 82067BD8h case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 82067BD8h case   10:*/		return 0x82067BDC;
		  /* 82067BDCh */ case   11:  		/* mr R3, R7 */
		/* 82067BDCh case   11:*/		regs.R3 = regs.R7;
		/* 82067BDCh case   11:*/		return 0x82067BE0;
		  /* 82067BE0h */ case   12:  		/* bl -1208 */
		/* 82067BE0h case   12:*/		regs.LR = 0x82067BE4; return 0x82067728;
		/* 82067BE0h case   12:*/		return 0x82067BE4;
		  /* 82067BE4h */ case   13:  		/* cmpwi CR0, R3, 0 */
		/* 82067BE4h case   13:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82067BE4h case   13:*/		return 0x82067BE8;
		  /* 82067BE8h */ case   14:  		/* bc 12, CR0_EQ, 148 */
		/* 82067BE8h case   14:*/		if ( regs.CR[0].eq ) { return 0x82067C7C;  }
		/* 82067BE8h case   14:*/		return 0x82067BEC;
		  /* 82067BECh */ case   15:  		/* li R11, 4 */
		/* 82067BECh case   15:*/		cpu::op::li<0>(regs,&regs.R11,0x4);
		/* 82067BECh case   15:*/		return 0x82067BF0;
		  /* 82067BF0h */ case   16:  		/* lwz R10, <#[R30]> */
		/* 82067BF0h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82067BF0h case   16:*/		return 0x82067BF4;
		  /* 82067BF4h */ case   17:  		/* lwz R6, <#[R1 + 80]> */
		/* 82067BF4h case   17:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 82067BF4h case   17:*/		return 0x82067BF8;
		  /* 82067BF8h */ case   18:  		/* li R5, 0 */
		/* 82067BF8h case   18:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82067BF8h case   18:*/		return 0x82067BFC;
		  /* 82067BFCh */ case   19:  		/* rlwinm R4, R10, 0, 26, 31 */
		/* 82067BFCh case   19:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R4,regs.R10);
		/* 82067BFCh case   19:*/		return 0x82067C00;
		  /* 82067C00h */ case   20:  		/* mtspr CTR, R11 */
		/* 82067C00h case   20:*/		regs.CTR = regs.R11;
		/* 82067C00h case   20:*/		return 0x82067C04;
		  /* 82067C04h */ case   21:  		/* li R11, 1 */
		/* 82067C04h case   21:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82067C04h case   21:*/		return 0x82067C08;
		  /* 82067C08h */ case   22:  		/* slw R11, R11, R5 */
		/* 82067C08h case   22:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R5);
		/* 82067C08h case   22:*/		return 0x82067C0C;
		  /* 82067C0Ch */ case   23:  		/* and. R11, R11, R6 */
		/* 82067C0Ch case   23:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R6);
		/* 82067C0Ch case   23:*/		return 0x82067C10;
		  /* 82067C10h */ case   24:  		/* bc 12, CR0_EQ, 100 */
		/* 82067C10h case   24:*/		if ( regs.CR[0].eq ) { return 0x82067C74;  }
		/* 82067C10h case   24:*/		return 0x82067C14;
		  /* 82067C14h */ case   25:  		/* addi R11, R4, 4 */
		/* 82067C14h case   25:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x4);
		/* 82067C14h case   25:*/		return 0x82067C18;
		  /* 82067C18h */ case   26:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82067C18h case   26:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82067C18h case   26:*/		return 0x82067C1C;
		  /* 82067C1Ch */ case   27:  		/* add R11, R11, R5 */
		/* 82067C1Ch case   27:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R5);
		/* 82067C1Ch case   27:*/		return 0x82067C20;
		  /* 82067C20h */ case   28:  		/* lbzx R11, <#[R11 + R31]> */
		/* 82067C20h case   28:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82067C20h case   28:*/		return 0x82067C24;
		  /* 82067C24h */ case   29:  		/* cmplwi CR6, R11, 255 */
		/* 82067C24h case   29:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x000000FF);
		/* 82067C24h case   29:*/		return 0x82067C28;
		  /* 82067C28h */ case   30:  		/* bc 12, CR6_EQ, 76 */
		/* 82067C28h case   30:*/		if ( regs.CR[6].eq ) { return 0x82067C74;  }
		/* 82067C28h case   30:*/		return 0x82067C2C;
		  /* 82067C2Ch */ case   31:  		/* rlwinm R10, R11, 2, 0, 29 */
		/* 82067C2Ch case   31:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R11);
		/* 82067C2Ch case   31:*/		return 0x82067C30;
		  /* 82067C30h */ case   32:  		/* lwz R9, <#[R31]> */
		/* 82067C30h case   32:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82067C30h case   32:*/		return 0x82067C34;
		  /* 82067C34h */ case   33:  		/* addi R11, R11, 40 */
		/* 82067C34h case   33:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x28);
		/* 82067C34h case   33:*/		return 0x82067C38;
		  /* 82067C38h */ case   34:  		/* lwz R3, <#[R31 + 8]> */
		/* 82067C38h case   34:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 82067C38h case   34:*/		return 0x82067C3C;
		  /* 82067C3Ch */ case   35:  		/* rlwinm R30, R29, 0, 20, 31 */
		/* 82067C3Ch case   35:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R30,regs.R29);
		/* 82067C3Ch case   35:*/		return 0x82067C40;
		  /* 82067C40h */ case   36:  		/* rlwinm R11, R11, 1, 0, 30 */
		/* 82067C40h case   36:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R11);
		/* 82067C40h case   36:*/		return 0x82067C44;
		  /* 82067C44h */ case   37:  		/* lhzx R8, <#[R10 + R9]> */
		/* 82067C44h case   37:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82067C44h case   37:*/		return 0x82067C48;
		  /* 82067C48h */ case   38:  		/* rlwinm R8, R8, 0, 20, 31 */
		/* 82067C48h case   38:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R8,regs.R8);
		/* 82067C48h case   38:*/		return 0x82067C4C;
		  /* 82067C4Ch */ case   39:  		/* lhzx R7, <#[R11 + R31]> */
		/* 82067C4Ch case   39:*/		cpu::mem::load16z( regs, &regs.R7, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82067C4Ch case   39:*/		return 0x82067C50;
		  /* 82067C50h */ case   40:  		/* add R8, R8, R7 */
		/* 82067C50h case   40:*/		cpu::op::add<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 82067C50h case   40:*/		return 0x82067C54;
		  /* 82067C54h */ case   41:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 82067C54h case   41:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 82067C54h case   41:*/		return 0x82067C58;
		  /* 82067C58h */ case   42:  		/* stwx R30, <#[R8 + R3]> */
		/* 82067C58h case   42:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R8 + regs.R3 + 0x00000000) );
		/* 82067C58h case   42:*/		return 0x82067C5C;
		  /* 82067C5Ch */ case   43:  		/* lhzx R8, <#[R11 + R31]> */
		/* 82067C5Ch case   43:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82067C5Ch case   43:*/		return 0x82067C60;
		  /* 82067C60h */ case   44:  		/* addi R8, R8, 1 */
		/* 82067C60h case   44:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82067C60h case   44:*/		return 0x82067C64;
		  /* 82067C64h */ case   45:  		/* sthx R8, <#[R11 + R31]> */
		/* 82067C64h case   45:*/		cpu::mem::store16( regs, regs.R8, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82067C64h case   45:*/		return 0x82067C68;
		  /* 82067C68h */ case   46:  		/* lwzx R11, <#[R10 + R9]> */
		/* 82067C68h case   46:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82067C68h case   46:*/		return 0x82067C6C;
		  /* 82067C6Ch */ case   47:  		/* rlwinm R11, R11, 20, 28, 31 */
		/* 82067C6Ch case   47:*/		cpu::op::rlwinm<0,20,28,31>(regs,&regs.R11,regs.R11);
		/* 82067C6Ch case   47:*/		return 0x82067C70;
		  /* 82067C70h */ case   48:  		/* andc R6, R6, R11 */
		/* 82067C70h case   48:*/		cpu::op::andc<0>(regs,&regs.R6,regs.R6,regs.R11);
		/* 82067C70h case   48:*/		return 0x82067C74;
	}
	return 0x82067C74;
} // Block from 82067BB0h-82067C74h (49 instructions)

//////////////////////////////////////////////////////
// Block at 82067C74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067C74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067C74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067C74);
		  /* 82067C74h */ case    0:  		/* addi R5, R5, 1 */
		/* 82067C74h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 82067C74h case    0:*/		return 0x82067C78;
		  /* 82067C78h */ case    1:  		/* bc 16, CR0_LT, -116 */
		/* 82067C78h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82067C04;  }
		/* 82067C78h case    1:*/		return 0x82067C7C;
	}
	return 0x82067C7C;
} // Block from 82067C74h-82067C7Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82067C7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067C7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067C7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067C7C);
		  /* 82067C7Ch */ case    0:  		/* addi R1, R1, 128 */
		/* 82067C7Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82067C7Ch case    0:*/		return 0x82067C80;
		  /* 82067C80h */ case    1:  		/* b 169516 */
		/* 82067C80h case    1:*/		return 0x820912AC;
		/* 82067C80h case    1:*/		return 0x82067C84;
		  /* 82067C84h */ case    2:  		/* nop */
		/* 82067C84h case    2:*/		cpu::op::nop();
		/* 82067C84h case    2:*/		return 0x82067C88;
	}
	return 0x82067C88;
} // Block from 82067C7Ch-82067C88h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82067C88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067C88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067C88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067C88);
		  /* 82067C88h */ case    0:  		/* mfspr R12, LR */
		/* 82067C88h case    0:*/		regs.R12 = regs.LR;
		/* 82067C88h case    0:*/		return 0x82067C8C;
		  /* 82067C8Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82067C8Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82067C8Ch case    1:*/		return 0x82067C90;
		  /* 82067C90h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82067C90h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82067C90h case    2:*/		return 0x82067C94;
		  /* 82067C94h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82067C94h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82067C94h case    3:*/		return 0x82067C98;
		  /* 82067C98h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82067C98h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82067C98h case    4:*/		return 0x82067C9C;
		  /* 82067C9Ch */ case    5:  		/* mr R30, R7 */
		/* 82067C9Ch case    5:*/		regs.R30 = regs.R7;
		/* 82067C9Ch case    5:*/		return 0x82067CA0;
		  /* 82067CA0h */ case    6:  		/* mr R31, R8 */
		/* 82067CA0h case    6:*/		regs.R31 = regs.R8;
		/* 82067CA0h case    6:*/		return 0x82067CA4;
		  /* 82067CA4h */ case    7:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82067CA4h case    7:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82067CA4h case    7:*/		return 0x82067CA8;
		  /* 82067CA8h */ case    8:  		/* bc 4, CR0_EQ, 144 */
		/* 82067CA8h case    8:*/		if ( !regs.CR[0].eq ) { return 0x82067D38;  }
		/* 82067CA8h case    8:*/		return 0x82067CAC;
		  /* 82067CACh */ case    9:  		/* rlwinm. R11, R4, 0, 24, 31 */
		/* 82067CACh case    9:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R4);
		/* 82067CACh case    9:*/		return 0x82067CB0;
		  /* 82067CB0h */ case   10:  		/* bc 4, CR0_EQ, 136 */
		/* 82067CB0h case   10:*/		if ( !regs.CR[0].eq ) { return 0x82067D38;  }
		/* 82067CB0h case   10:*/		return 0x82067CB4;
		  /* 82067CB4h */ case   11:  		/* addi R4, R1, 80 */
		/* 82067CB4h case   11:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 82067CB4h case   11:*/		return 0x82067CB8;
		  /* 82067CB8h */ case   12:  		/* mr R3, R7 */
		/* 82067CB8h case   12:*/		regs.R3 = regs.R7;
		/* 82067CB8h case   12:*/		return 0x82067CBC;
		  /* 82067CBCh */ case   13:  		/* bl -1428 */
		/* 82067CBCh case   13:*/		regs.LR = 0x82067CC0; return 0x82067728;
		/* 82067CBCh case   13:*/		return 0x82067CC0;
		  /* 82067CC0h */ case   14:  		/* cmpwi CR0, R3, 0 */
		/* 82067CC0h case   14:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82067CC0h case   14:*/		return 0x82067CC4;
		  /* 82067CC4h */ case   15:  		/* bc 12, CR0_EQ, 116 */
		/* 82067CC4h case   15:*/		if ( regs.CR[0].eq ) { return 0x82067D38;  }
		/* 82067CC4h case   15:*/		return 0x82067CC8;
		  /* 82067CC8h */ case   16:  		/* li R11, 4 */
		/* 82067CC8h case   16:*/		cpu::op::li<0>(regs,&regs.R11,0x4);
		/* 82067CC8h case   16:*/		return 0x82067CCC;
		  /* 82067CCCh */ case   17:  		/* lwz R10, <#[R30]> */
		/* 82067CCCh case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82067CCCh case   17:*/		return 0x82067CD0;
		  /* 82067CD0h */ case   18:  		/* lwz R7, <#[R1 + 80]> */
		/* 82067CD0h case   18:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000050) );
		/* 82067CD0h case   18:*/		return 0x82067CD4;
		  /* 82067CD4h */ case   19:  		/* li R6, 0 */
		/* 82067CD4h case   19:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82067CD4h case   19:*/		return 0x82067CD8;
		  /* 82067CD8h */ case   20:  		/* rlwinm R5, R10, 0, 26, 31 */
		/* 82067CD8h case   20:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R5,regs.R10);
		/* 82067CD8h case   20:*/		return 0x82067CDC;
		  /* 82067CDCh */ case   21:  		/* mtspr CTR, R11 */
		/* 82067CDCh case   21:*/		regs.CTR = regs.R11;
		/* 82067CDCh case   21:*/		return 0x82067CE0;
		  /* 82067CE0h */ case   22:  		/* li R11, 1 */
		/* 82067CE0h case   22:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82067CE0h case   22:*/		return 0x82067CE4;
		  /* 82067CE4h */ case   23:  		/* slw R11, R11, R6 */
		/* 82067CE4h case   23:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R6);
		/* 82067CE4h case   23:*/		return 0x82067CE8;
		  /* 82067CE8h */ case   24:  		/* and. R11, R11, R7 */
		/* 82067CE8h case   24:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R7);
		/* 82067CE8h case   24:*/		return 0x82067CEC;
		  /* 82067CECh */ case   25:  		/* bc 12, CR0_EQ, 68 */
		/* 82067CECh case   25:*/		if ( regs.CR[0].eq ) { return 0x82067D30;  }
		/* 82067CECh case   25:*/		return 0x82067CF0;
		  /* 82067CF0h */ case   26:  		/* addi R11, R5, 2 */
		/* 82067CF0h case   26:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R5,0x2);
		/* 82067CF0h case   26:*/		return 0x82067CF4;
		  /* 82067CF4h */ case   27:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82067CF4h case   27:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82067CF4h case   27:*/		return 0x82067CF8;
		  /* 82067CF8h */ case   28:  		/* add R11, R11, R6 */
		/* 82067CF8h case   28:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R6);
		/* 82067CF8h case   28:*/		return 0x82067CFC;
		  /* 82067CFCh */ case   29:  		/* lbzx R11, <#[R11 + R31]> */
		/* 82067CFCh case   29:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82067CFCh case   29:*/		return 0x82067D00;
		  /* 82067D00h */ case   30:  		/* cmplwi CR6, R11, 255 */
		/* 82067D00h case   30:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x000000FF);
		/* 82067D00h case   30:*/		return 0x82067D04;
		  /* 82067D04h */ case   31:  		/* bc 12, CR6_EQ, 44 */
		/* 82067D04h case   31:*/		if ( regs.CR[6].eq ) { return 0x82067D30;  }
		/* 82067D04h case   31:*/		return 0x82067D08;
		  /* 82067D08h */ case   32:  		/* addi R10, R11, 36 */
		/* 82067D08h case   32:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x24);
		/* 82067D08h case   32:*/		return 0x82067D0C;
		  /* 82067D0Ch */ case   33:  		/* lwz R8, <#[R31]> */
		/* 82067D0Ch case   33:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 82067D0Ch case   33:*/		return 0x82067D10;
		  /* 82067D10h */ case   34:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 82067D10h case   34:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 82067D10h case   34:*/		return 0x82067D14;
		  /* 82067D14h */ case   35:  		/* rlwinm R11, R10, 1, 0, 30 */
		/* 82067D14h case   35:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R10);
		/* 82067D14h case   35:*/		return 0x82067D18;
		  /* 82067D18h */ case   36:  		/* lhzx R10, <#[R11 + R31]> */
		/* 82067D18h case   36:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82067D18h case   36:*/		return 0x82067D1C;
		  /* 82067D1Ch */ case   37:  		/* addi R10, R10, 1 */
		/* 82067D1Ch case   37:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82067D1Ch case   37:*/		return 0x82067D20;
		  /* 82067D20h */ case   38:  		/* sthx R10, <#[R11 + R31]> */
		/* 82067D20h case   38:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 82067D20h case   38:*/		return 0x82067D24;
		  /* 82067D24h */ case   39:  		/* lwzx R11, <#[R9 + R8]> */
		/* 82067D24h case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R8 + 0x00000000) );
		/* 82067D24h case   39:*/		return 0x82067D28;
		  /* 82067D28h */ case   40:  		/* rlwinm R11, R11, 20, 28, 31 */
		/* 82067D28h case   40:*/		cpu::op::rlwinm<0,20,28,31>(regs,&regs.R11,regs.R11);
		/* 82067D28h case   40:*/		return 0x82067D2C;
		  /* 82067D2Ch */ case   41:  		/* andc R7, R7, R11 */
		/* 82067D2Ch case   41:*/		cpu::op::andc<0>(regs,&regs.R7,regs.R7,regs.R11);
		/* 82067D2Ch case   41:*/		return 0x82067D30;
	}
	return 0x82067D30;
} // Block from 82067C88h-82067D30h (42 instructions)

//////////////////////////////////////////////////////
// Block at 82067D30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067D30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067D30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067D30);
		  /* 82067D30h */ case    0:  		/* addi R6, R6, 1 */
		/* 82067D30h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 82067D30h case    0:*/		return 0x82067D34;
		  /* 82067D34h */ case    1:  		/* bc 16, CR0_LT, -84 */
		/* 82067D34h case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82067CE0;  }
		/* 82067D34h case    1:*/		return 0x82067D38;
	}
	return 0x82067D38;
} // Block from 82067D30h-82067D38h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82067D38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067D38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067D38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067D38);
		  /* 82067D38h */ case    0:  		/* addi R1, R1, 112 */
		/* 82067D38h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82067D38h case    0:*/		return 0x82067D3C;
		  /* 82067D3Ch */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82067D3Ch case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82067D3Ch case    1:*/		return 0x82067D40;
		  /* 82067D40h */ case    2:  		/* mtspr LR, R12 */
		/* 82067D40h case    2:*/		regs.LR = regs.R12;
		/* 82067D40h case    2:*/		return 0x82067D44;
		  /* 82067D44h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 82067D44h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82067D44h case    3:*/		return 0x82067D48;
		  /* 82067D48h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 82067D48h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82067D48h case    4:*/		return 0x82067D4C;
		  /* 82067D4Ch */ case    5:  		/* bclr 20, CR0_LT */
		/* 82067D4Ch case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82067D4Ch case    5:*/		return 0x82067D50;
	}
	return 0x82067D50;
} // Block from 82067D38h-82067D50h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82067D50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067D50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067D50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067D50);
		  /* 82067D50h */ case    0:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82067D50h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82067D50h case    0:*/		return 0x82067D54;
		  /* 82067D54h */ case    1:  		/* bclr 4, CR0_EQ */
		/* 82067D54h case    1:*/		if ( !regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 82067D54h case    1:*/		return 0x82067D58;
	}
	return 0x82067D58;
} // Block from 82067D50h-82067D58h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82067D58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067D58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067D58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067D58);
		  /* 82067D58h */ case    0:  		/* rlwinm. R11, R4, 0, 24, 31 */
		/* 82067D58h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R4);
		/* 82067D58h case    0:*/		return 0x82067D5C;
		  /* 82067D5Ch */ case    1:  		/* bclr 4, CR0_EQ */
		/* 82067D5Ch case    1:*/		if ( !regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 82067D5Ch case    1:*/		return 0x82067D60;
	}
	return 0x82067D60;
} // Block from 82067D58h-82067D60h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82067D60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067D60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067D60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067D60);
		  /* 82067D60h */ case    0:  		/* lwz R11, <#[R7]> */
		/* 82067D60h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 82067D60h case    0:*/		return 0x82067D64;
		  /* 82067D64h */ case    1:  		/* rlwinm. R10, R11, 0, 16, 16 */
		/* 82067D64h case    1:*/		cpu::op::rlwinm<1,0,16,16>(regs,&regs.R10,regs.R11);
		/* 82067D64h case    1:*/		return 0x82067D68;
		  /* 82067D68h */ case    2:  		/* bc 12, CR0_EQ, 60 */
		/* 82067D68h case    2:*/		if ( regs.CR[0].eq ) { return 0x82067DA4;  }
		/* 82067D68h case    2:*/		return 0x82067D6C;
		  /* 82067D6Ch */ case    3:  		/* rlwinm R11, R11, 0, 26, 31 */
		/* 82067D6Ch case    3:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R11,regs.R11);
		/* 82067D6Ch case    3:*/		return 0x82067D70;
		  /* 82067D70h */ case    4:  		/* cmplwi CR6, R11, 3 */
		/* 82067D70h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 82067D70h case    4:*/		return 0x82067D74;
		  /* 82067D74h */ case    5:  		/* bc 12, CR6_GT, 28 */
		/* 82067D74h case    5:*/		if ( regs.CR[6].gt ) { return 0x82067D90;  }
		/* 82067D74h case    5:*/		return 0x82067D78;
		  /* 82067D78h */ case    6:  		/* li R10, 1 */
		/* 82067D78h case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82067D78h case    6:*/		return 0x82067D7C;
		  /* 82067D7Ch */ case    7:  		/* lwz R9, <#[R8]> */
		/* 82067D7Ch case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000000) );
		/* 82067D7Ch case    7:*/		return 0x82067D80;
		  /* 82067D80h */ case    8:  		/* slw R11, R10, R11 */
		/* 82067D80h case    8:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82067D80h case    8:*/		return 0x82067D84;
		  /* 82067D84h */ case    9:  		/* or R11, R11, R9 */
		/* 82067D84h case    9:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 82067D84h case    9:*/		return 0x82067D88;
		  /* 82067D88h */ case   10:  		/* rlwimi R11, R9, 0, 0, 27 */
		/* 82067D88h case   10:*/		cpu::op::rlwimi<0,0,0,27>(regs,&regs.R11,regs.R9);
		/* 82067D88h case   10:*/		return 0x82067D8C;
		  /* 82067D8Ch */ case   11:  		/* b 20 */
		/* 82067D8Ch case   11:*/		return 0x82067DA0;
		/* 82067D8Ch case   11:*/		return 0x82067D90;
	}
	return 0x82067D90;
} // Block from 82067D60h-82067D90h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82067D90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067D90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067D90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067D90);
		  /* 82067D90h */ case    0:  		/* cmplwi CR6, R11, 61 */
		/* 82067D90h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000003D);
		/* 82067D90h case    0:*/		return 0x82067D94;
		  /* 82067D94h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 82067D94h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82067DA4;  }
		/* 82067D94h case    1:*/		return 0x82067D98;
		  /* 82067D98h */ case    2:  		/* lwz R11, <#[R8]> */
		/* 82067D98h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 82067D98h case    2:*/		return 0x82067D9C;
		  /* 82067D9Ch */ case    3:  		/* ori R11, R11, 16 */
		/* 82067D9Ch case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x10);
		/* 82067D9Ch case    3:*/		return 0x82067DA0;
	}
	return 0x82067DA0;
} // Block from 82067D90h-82067DA0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82067DA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067DA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067DA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067DA0);
		  /* 82067DA0h */ case    0:  		/* stw R11, <#[R8]> */
		/* 82067DA0h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 82067DA0h case    0:*/		return 0x82067DA4;
	}
	return 0x82067DA4;
} // Block from 82067DA0h-82067DA4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82067DA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067DA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067DA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067DA4);
		  /* 82067DA4h */ case    0:  		/* lbz R11, <#[R7 + 8]> */
		/* 82067DA4h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000008) );
		/* 82067DA4h case    0:*/		return 0x82067DA8;
		  /* 82067DA8h */ case    1:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 82067DA8h case    1:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 82067DA8h case    1:*/		return 0x82067DAC;
		  /* 82067DACh */ case    2:  		/* cmplwi CR6, R11, 24 */
		/* 82067DACh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000018);
		/* 82067DACh case    2:*/		return 0x82067DB0;
		  /* 82067DB0h */ case    3:  		/* bc 12, CR6_LT, 12 */
		/* 82067DB0h case    3:*/		if ( regs.CR[6].lt ) { return 0x82067DBC;  }
		/* 82067DB0h case    3:*/		return 0x82067DB4;
		  /* 82067DB4h */ case    4:  		/* cmplwi CR6, R11, 27 */
		/* 82067DB4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001B);
		/* 82067DB4h case    4:*/		return 0x82067DB8;
	}
	return 0x82067DB8;
} // Block from 82067DA4h-82067DB8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82067DB8h
// Function '?Finish@Microcode@CMicrocodeBuilder@D3D@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067DB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067DB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067DB8);
		  /* 82067DB8h */ case    0:  		/* bc 4, CR6_GT, 28 */
		/* 82067DB8h case    0:*/		if ( !regs.CR[6].gt ) { return 0x82067DD4;  }
		/* 82067DB8h case    0:*/		return 0x82067DBC;
	}
	return 0x82067DBC;
} // Block from 82067DB8h-82067DBCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82067DBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067DBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067DBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067DBC);
		  /* 82067DBCh */ case    0:  		/* lwz R11, <#[R7]> */
		/* 82067DBCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 82067DBCh case    0:*/		return 0x82067DC0;
		  /* 82067DC0h */ case    1:  		/* rlwinm R11, R11, 6, 26, 31 */
		/* 82067DC0h case    1:*/		cpu::op::rlwinm<0,6,26,31>(regs,&regs.R11,regs.R11);
		/* 82067DC0h case    1:*/		return 0x82067DC4;
		  /* 82067DC4h */ case    2:  		/* cmplwi CR6, R11, 35 */
		/* 82067DC4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000023);
		/* 82067DC4h case    2:*/		return 0x82067DC8;
		  /* 82067DC8h */ case    3:  		/* bclr 12, CR6_LT */
		/* 82067DC8h case    3:*/		if ( regs.CR[6].lt ) { return (uint32)regs.LR; }
		/* 82067DC8h case    3:*/		return 0x82067DCC;
	}
	return 0x82067DCC;
} // Block from 82067DBCh-82067DCCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 82067DCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067DCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067DCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067DCC);
		  /* 82067DCCh */ case    0:  		/* cmplwi CR6, R11, 39 */
		/* 82067DCCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000027);
		/* 82067DCCh case    0:*/		return 0x82067DD0;
		  /* 82067DD0h */ case    1:  		/* bclr 12, CR6_GT */
		/* 82067DD0h case    1:*/		if ( regs.CR[6].gt ) { return (uint32)regs.LR; }
		/* 82067DD0h case    1:*/		return 0x82067DD4;
	}
	return 0x82067DD4;
} // Block from 82067DCCh-82067DD4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82067DD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067DD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067DD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067DD4);
		  /* 82067DD4h */ case    0:  		/* lwz R11, <#[R8]> */
		/* 82067DD4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 82067DD4h case    0:*/		return 0x82067DD8;
		  /* 82067DD8h */ case    1:  		/* ori R11, R11, 32 */
		/* 82067DD8h case    1:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x20);
		/* 82067DD8h case    1:*/		return 0x82067DDC;
		  /* 82067DDCh */ case    2:  		/* stw R11, <#[R8]> */
		/* 82067DDCh case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 82067DDCh case    2:*/		return 0x82067DE0;
		  /* 82067DE0h */ case    3:  		/* bclr 20, CR0_LT */
		/* 82067DE0h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82067DE0h case    3:*/		return 0x82067DE4;
	}
	return 0x82067DE4;
} // Block from 82067DD4h-82067DE4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82067DE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067DE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067DE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067DE4);
		  /* 82067DE4h */ case    0:  		/* nop */
		/* 82067DE4h case    0:*/		cpu::op::nop();
		/* 82067DE4h case    0:*/		return 0x82067DE8;
	}
	return 0x82067DE8;
} // Block from 82067DE4h-82067DE8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82067DE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067DE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067DE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067DE8);
		  /* 82067DE8h */ case    0:  		/* mfspr R12, LR */
		/* 82067DE8h case    0:*/		regs.R12 = regs.LR;
		/* 82067DE8h case    0:*/		return 0x82067DEC;
		  /* 82067DECh */ case    1:  		/* bl 169036 */
		/* 82067DECh case    1:*/		regs.LR = 0x82067DF0; return 0x82091238;
		/* 82067DECh case    1:*/		return 0x82067DF0;
		  /* 82067DF0h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 82067DF0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 82067DF0h case    2:*/		return 0x82067DF4;
		  /* 82067DF4h */ case    3:  		/* lwz R11, <#[R4]> */
		/* 82067DF4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 82067DF4h case    3:*/		return 0x82067DF8;
		  /* 82067DF8h */ case    4:  		/* mr R29, R4 */
		/* 82067DF8h case    4:*/		regs.R29 = regs.R4;
		/* 82067DF8h case    4:*/		return 0x82067DFC;
		  /* 82067DFCh */ case    5:  		/* mr R22, R5 */
		/* 82067DFCh case    5:*/		regs.R22 = regs.R5;
		/* 82067DFCh case    5:*/		return 0x82067E00;
		  /* 82067E00h */ case    6:  		/* mr R21, R6 */
		/* 82067E00h case    6:*/		regs.R21 = regs.R6;
		/* 82067E00h case    6:*/		return 0x82067E04;
		  /* 82067E04h */ case    7:  		/* mr R23, R8 */
		/* 82067E04h case    7:*/		regs.R23 = regs.R8;
		/* 82067E04h case    7:*/		return 0x82067E08;
		  /* 82067E08h */ case    8:  		/* mr R20, R9 */
		/* 82067E08h case    8:*/		regs.R20 = regs.R9;
		/* 82067E08h case    8:*/		return 0x82067E0C;
		  /* 82067E0Ch */ case    9:  		/* rlwinm. R26, R11, 20, 29, 31 */
		/* 82067E0Ch case    9:*/		cpu::op::rlwinm<1,20,29,31>(regs,&regs.R26,regs.R11);
		/* 82067E0Ch case    9:*/		return 0x82067E10;
		  /* 82067E10h */ case   10:  		/* bc 12, CR0_EQ, 172 */
		/* 82067E10h case   10:*/		if ( regs.CR[0].eq ) { return 0x82067EBC;  }
		/* 82067E10h case   10:*/		return 0x82067E14;
		  /* 82067E14h */ case   11:  		/* lwz R10, <#[R4 + 4]> */
		/* 82067E14h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000004) );
		/* 82067E14h case   11:*/		return 0x82067E18;
		  /* 82067E18h */ case   12:  		/* rlwinm R9, R11, 0, 20, 31 */
		/* 82067E18h case   12:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R9,regs.R11);
		/* 82067E18h case   12:*/		return 0x82067E1C;
		  /* 82067E1Ch */ case   13:  		/* rlwinm R8, R11, 4, 28, 31 */
		/* 82067E1Ch case   13:*/		cpu::op::rlwinm<0,4,28,31>(regs,&regs.R8,regs.R11);
		/* 82067E1Ch case   13:*/		return 0x82067E20;
		  /* 82067E20h */ case   14:  		/* rlwinm R6, R10, 4, 26, 27 */
		/* 82067E20h case   14:*/		cpu::op::rlwinm<0,4,26,27>(regs,&regs.R6,regs.R10);
		/* 82067E20h case   14:*/		return 0x82067E24;
		  /* 82067E24h */ case   15:  		/* mulli R10, R9, 12 */
		/* 82067E24h case   15:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R9,0xC);
		/* 82067E24h case   15:*/		return 0x82067E28;
		  /* 82067E28h */ case   16:  		/* add R31, R10, R7 */
		/* 82067E28h case   16:*/		cpu::op::add<0>(regs,&regs.R31,regs.R10,regs.R7);
		/* 82067E28h case   16:*/		return 0x82067E2C;
		  /* 82067E2Ch */ case   17:  		/* rlwinm R25, R11, 16, 20, 31 */
		/* 82067E2Ch case   17:*/		cpu::op::rlwinm<0,16,20,31>(regs,&regs.R25,regs.R11);
		/* 82067E2Ch case   17:*/		return 0x82067E30;
		  /* 82067E30h */ case   18:  		/* or R24, R6, R8 */
		/* 82067E30h case   18:*/		cpu::op::or<0>(regs,&regs.R24,regs.R6,regs.R8);
		/* 82067E30h case   18:*/		return 0x82067E34;
		  /* 82067E34h */ case   19:  		/* li R30, 0 */
		/* 82067E34h case   19:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82067E34h case   19:*/		return 0x82067E38;
		  /* 82067E38h */ case   20:  		/* cmplwi CR6, R26, 0 */
		/* 82067E38h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 82067E38h case   20:*/		return 0x82067E3C;
		  /* 82067E3Ch */ case   21:  		/* bc 12, CR6_EQ, 128 */
		/* 82067E3Ch case   21:*/		if ( regs.CR[6].eq ) { return 0x82067EBC;  }
		/* 82067E3Ch case   21:*/		return 0x82067E40;
		  /* 82067E40h */ case   22:  		/* li R28, 0 */
		/* 82067E40h case   22:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 82067E40h case   22:*/		return 0x82067E44;
		  /* 82067E44h */ case   23:  		/* li R27, 1 */
		/* 82067E44h case   23:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 82067E44h case   23:*/		return 0x82067E48;
		  /* 82067E48h */ case   24:  		/* lwz R11, <#[R23]> */
		/* 82067E48h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 82067E48h case   24:*/		return 0x82067E4C;
		  /* 82067E4Ch */ case   25:  		/* cmplw CR6, R31, R11 */
		/* 82067E4Ch case   25:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82067E4Ch case   25:*/		return 0x82067E50;
		  /* 82067E50h */ case   26:  		/* bc 12, CR6_GT, 104 */
		/* 82067E50h case   26:*/		if ( regs.CR[6].gt ) { return 0x82067EB8;  }
		/* 82067E50h case   26:*/		return 0x82067E54;
		  /* 82067E54h */ case   27:  		/* bc 4, CR6_EQ, 76 */
		/* 82067E54h case   27:*/		if ( !regs.CR[6].eq ) { return 0x82067EA0;  }
		/* 82067E54h case   27:*/		return 0x82067E58;
		  /* 82067E58h */ case   28:  		/* slw R11, R27, R30 */
		/* 82067E58h case   28:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R27,regs.R30);
		/* 82067E58h case   28:*/		return 0x82067E5C;
		  /* 82067E5Ch */ case   29:  		/* lwz R10, <#[R29]> */
		/* 82067E5Ch case   29:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 82067E5Ch case   29:*/		return 0x82067E60;
		  /* 82067E60h */ case   30:  		/* and R11, R11, R24 */
		/* 82067E60h case   30:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R24);
		/* 82067E60h case   30:*/		return 0x82067E64;
		  /* 82067E64h */ case   31:  		/* mtspr CTR, R22 */
		/* 82067E64h case   31:*/		regs.CTR = regs.R22;
		/* 82067E64h case   31:*/		return 0x82067E68;
		  /* 82067E68h */ case   32:  		/* slw R9, R27, R28 */
		/* 82067E68h case   32:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R27,regs.R28);
		/* 82067E68h case   32:*/		return 0x82067E6C;
		  /* 82067E6Ch */ case   33:  		/* addic R8, R11, -1 */
		/* 82067E6Ch case   33:*/		cpu::op::addic<0>(regs,&regs.R8,regs.R11,0xFFFFFFFF);
		/* 82067E6Ch case   33:*/		return 0x82067E70;
		  /* 82067E70h */ case   34:  		/* and R9, R9, R25 */
		/* 82067E70h case   34:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R25);
		/* 82067E70h case   34:*/		return 0x82067E74;
		  /* 82067E74h */ case   35:  		/* subfe R5, R8, R11 */
		/* 82067E74h case   35:*/		cpu::op::subfe<0>(regs,&regs.R5,regs.R8,regs.R11);
		/* 82067E74h case   35:*/		return 0x82067E78;
		  /* 82067E78h */ case   36:  		/* addic R4, R9, -1 */
		/* 82067E78h case   36:*/		cpu::op::addic<0>(regs,&regs.R4,regs.R9,0xFFFFFFFF);
		/* 82067E78h case   36:*/		return 0x82067E7C;
		  /* 82067E7Ch */ case   37:  		/* rlwinm R11, R10, 0, 20, 31 */
		/* 82067E7Ch case   37:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R11,regs.R10);
		/* 82067E7Ch case   37:*/		return 0x82067E80;
		  /* 82067E80h */ case   38:  		/* mr R8, R21 */
		/* 82067E80h case   38:*/		regs.R8 = regs.R21;
		/* 82067E80h case   38:*/		return 0x82067E84;
		  /* 82067E84h */ case   39:  		/* mr R7, R31 */
		/* 82067E84h case   39:*/		regs.R7 = regs.R31;
		/* 82067E84h case   39:*/		return 0x82067E88;
		  /* 82067E88h */ case   40:  		/* add R6, R11, R30 */
		/* 82067E88h case   40:*/		cpu::op::add<0>(regs,&regs.R6,regs.R11,regs.R30);
		/* 82067E88h case   40:*/		return 0x82067E8C;
		  /* 82067E8Ch */ case   41:  		/* subfe R4, R4, R9 */
		/* 82067E8Ch case   41:*/		cpu::op::subfe<0>(regs,&regs.R4,regs.R4,regs.R9);
		/* 82067E8Ch case   41:*/		return 0x82067E90;
		  /* 82067E90h */ case   42:  		/* li R3, 0 */
		/* 82067E90h case   42:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82067E90h case   42:*/		return 0x82067E94;
		  /* 82067E94h */ case   43:  		/* bcctrl 20, CR0_LT */
		/* 82067E94h case   43:*/		if ( 1 ) { regs.LR = 0x82067E98; return (uint32)regs.CTR; }
		/* 82067E94h case   43:*/		return 0x82067E98;
		  /* 82067E98h */ case   44:  		/* addi R11, R31, 12 */
		/* 82067E98h case   44:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xC);
		/* 82067E98h case   44:*/		return 0x82067E9C;
		  /* 82067E9Ch */ case   45:  		/* stw R11, <#[R23]> */
		/* 82067E9Ch case   45:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 82067E9Ch case   45:*/		return 0x82067EA0;
	}
	return 0x82067EA0;
} // Block from 82067DE8h-82067EA0h (46 instructions)

//////////////////////////////////////////////////////
// Block at 82067EA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067EA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067EA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067EA0);
		  /* 82067EA0h */ case    0:  		/* addi R30, R30, 1 */
		/* 82067EA0h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82067EA0h case    0:*/		return 0x82067EA4;
		  /* 82067EA4h */ case    1:  		/* addi R28, R28, 2 */
		/* 82067EA4h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x2);
		/* 82067EA4h case    1:*/		return 0x82067EA8;
		  /* 82067EA8h */ case    2:  		/* addi R31, R31, 12 */
		/* 82067EA8h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0xC);
		/* 82067EA8h case    2:*/		return 0x82067EAC;
		  /* 82067EACh */ case    3:  		/* cmplw CR6, R30, R26 */
		/* 82067EACh case    3:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R26);
		/* 82067EACh case    3:*/		return 0x82067EB0;
		  /* 82067EB0h */ case    4:  		/* bc 12, CR6_LT, -104 */
		/* 82067EB0h case    4:*/		if ( regs.CR[6].lt ) { return 0x82067E48;  }
		/* 82067EB0h case    4:*/		return 0x82067EB4;
		  /* 82067EB4h */ case    5:  		/* b 8 */
		/* 82067EB4h case    5:*/		return 0x82067EBC;
		/* 82067EB4h case    5:*/		return 0x82067EB8;
	}
	return 0x82067EB8;
} // Block from 82067EA0h-82067EB8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82067EB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067EB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067EB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067EB8);
		  /* 82067EB8h */ case    0:  		/* stw R27, <#[R20]> */
		/* 82067EB8h case    0:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R20 + 0x00000000) );
		/* 82067EB8h case    0:*/		return 0x82067EBC;
	}
	return 0x82067EBC;
} // Block from 82067EB8h-82067EBCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82067EBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067EBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067EBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067EBC);
		  /* 82067EBCh */ case    0:  		/* addi R1, R1, 192 */
		/* 82067EBCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 82067EBCh case    0:*/		return 0x82067EC0;
		  /* 82067EC0h */ case    1:  		/* b 168904 */
		/* 82067EC0h case    1:*/		return 0x82091288;
		/* 82067EC0h case    1:*/		return 0x82067EC4;
		  /* 82067EC4h */ case    2:  		/* nop */
		/* 82067EC4h case    2:*/		cpu::op::nop();
		/* 82067EC4h case    2:*/		return 0x82067EC8;
	}
	return 0x82067EC8;
} // Block from 82067EBCh-82067EC8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82067EC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067EC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067EC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067EC8);
		  /* 82067EC8h */ case    0:  		/* mfspr R12, LR */
		/* 82067EC8h case    0:*/		regs.R12 = regs.LR;
		/* 82067EC8h case    0:*/		return 0x82067ECC;
		  /* 82067ECCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82067ECCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82067ECCh case    1:*/		return 0x82067ED0;
		  /* 82067ED0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82067ED0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82067ED0h case    2:*/		return 0x82067ED4;
		  /* 82067ED4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82067ED4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82067ED4h case    3:*/		return 0x82067ED8;
		  /* 82067ED8h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82067ED8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82067ED8h case    4:*/		return 0x82067EDC;
		  /* 82067EDCh */ case    5:  		/* mr R31, R3 */
		/* 82067EDCh case    5:*/		regs.R31 = regs.R3;
		/* 82067EDCh case    5:*/		return 0x82067EE0;
		  /* 82067EE0h */ case    6:  		/* lwz R3, <#[R3 + 19896]> */
		/* 82067EE0h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00004DB8) );
		/* 82067EE0h case    6:*/		return 0x82067EE4;
		  /* 82067EE4h */ case    7:  		/* mr R30, R4 */
		/* 82067EE4h case    7:*/		regs.R30 = regs.R4;
		/* 82067EE4h case    7:*/		return 0x82067EE8;
		  /* 82067EE8h */ case    8:  		/* cmplwi CR6, R3, 0 */
		/* 82067EE8h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82067EE8h case    8:*/		return 0x82067EEC;
		  /* 82067EECh */ case    9:  		/* bc 12, CR6_EQ, 28 */
		/* 82067EECh case    9:*/		if ( regs.CR[6].eq ) { return 0x82067F08;  }
		/* 82067EECh case    9:*/		return 0x82067EF0;
		  /* 82067EF0h */ case   10:  		/* lwz R11, <#[R3]> */
		/* 82067EF0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82067EF0h case   10:*/		return 0x82067EF4;
		  /* 82067EF4h */ case   11:  		/* lwz R11, <#[R11 + 4]> */
		/* 82067EF4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82067EF4h case   11:*/		return 0x82067EF8;
		  /* 82067EF8h */ case   12:  		/* mtspr CTR, R11 */
		/* 82067EF8h case   12:*/		regs.CTR = regs.R11;
		/* 82067EF8h case   12:*/		return 0x82067EFC;
		  /* 82067EFCh */ case   13:  		/* bcctrl 20, CR0_LT */
		/* 82067EFCh case   13:*/		if ( 1 ) { regs.LR = 0x82067F00; return (uint32)regs.CTR; }
		/* 82067EFCh case   13:*/		return 0x82067F00;
		  /* 82067F00h */ case   14:  		/* li R11, 0 */
		/* 82067F00h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82067F00h case   14:*/		return 0x82067F04;
		  /* 82067F04h */ case   15:  		/* stw R11, <#[R31 + 19896]> */
		/* 82067F04h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00004DB8) );
		/* 82067F04h case   15:*/		return 0x82067F08;
	}
	return 0x82067F08;
} // Block from 82067EC8h-82067F08h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82067F08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067F08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067F08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067F08);
		  /* 82067F08h */ case    0:  		/* stw R30, <#[R31 + 19896]> */
		/* 82067F08h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00004DB8) );
		/* 82067F08h case    0:*/		return 0x82067F0C;
		  /* 82067F0Ch */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 82067F0Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82067F0Ch case    1:*/		return 0x82067F10;
		  /* 82067F10h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 82067F10h case    2:*/		if ( regs.CR[6].eq ) { return 0x82067F28;  }
		/* 82067F10h case    2:*/		return 0x82067F14;
		  /* 82067F14h */ case    3:  		/* lwz R11, <#[R30]> */
		/* 82067F14h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82067F14h case    3:*/		return 0x82067F18;
		  /* 82067F18h */ case    4:  		/* mr R3, R30 */
		/* 82067F18h case    4:*/		regs.R3 = regs.R30;
		/* 82067F18h case    4:*/		return 0x82067F1C;
		  /* 82067F1Ch */ case    5:  		/* lwz R11, <#[R11]> */
		/* 82067F1Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82067F1Ch case    5:*/		return 0x82067F20;
		  /* 82067F20h */ case    6:  		/* mtspr CTR, R11 */
		/* 82067F20h case    6:*/		regs.CTR = regs.R11;
		/* 82067F20h case    6:*/		return 0x82067F24;
		  /* 82067F24h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 82067F24h case    7:*/		if ( 1 ) { regs.LR = 0x82067F28; return (uint32)regs.CTR; }
		/* 82067F24h case    7:*/		return 0x82067F28;
	}
	return 0x82067F28;
} // Block from 82067F08h-82067F28h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82067F28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067F28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067F28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067F28);
		  /* 82067F28h */ case    0:  		/* addi R1, R1, 112 */
		/* 82067F28h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82067F28h case    0:*/		return 0x82067F2C;
		  /* 82067F2Ch */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82067F2Ch case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82067F2Ch case    1:*/		return 0x82067F30;
		  /* 82067F30h */ case    2:  		/* mtspr LR, R12 */
		/* 82067F30h case    2:*/		regs.LR = regs.R12;
		/* 82067F30h case    2:*/		return 0x82067F34;
		  /* 82067F34h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 82067F34h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82067F34h case    3:*/		return 0x82067F38;
		  /* 82067F38h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 82067F38h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82067F38h case    4:*/		return 0x82067F3C;
		  /* 82067F3Ch */ case    5:  		/* bclr 20, CR0_LT */
		/* 82067F3Ch case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82067F3Ch case    5:*/		return 0x82067F40;
	}
	return 0x82067F40;
} // Block from 82067F28h-82067F40h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82067F40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067F40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067F40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067F40);
		  /* 82067F40h */ case    0:  		/* lwz R11, <#[R3 + 19892]> */
		/* 82067F40h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00004DB4) );
		/* 82067F40h case    0:*/		return 0x82067F44;
		  /* 82067F44h */ case    1:  		/* andi. R10, R4, 249 */
		/* 82067F44h case    1:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R4,0xF9);
		/* 82067F44h case    1:*/		return 0x82067F48;
		  /* 82067F48h */ case    2:  		/* rlwinm R11, R11, 0, 29, 23 */
		/* 82067F48h case    2:*/		cpu::op::rlwinm<0,0,29,23>(regs,&regs.R11,regs.R11);
		/* 82067F48h case    2:*/		return 0x82067F4C;
		  /* 82067F4Ch */ case    3:  		/* rlwinm R9, R4, 0, 31, 31 */
		/* 82067F4Ch case    3:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R9,regs.R4);
		/* 82067F4Ch case    3:*/		return 0x82067F50;
		  /* 82067F50h */ case    4:  		/* or R11, R10, R11 */
		/* 82067F50h case    4:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82067F50h case    4:*/		return 0x82067F54;
		  /* 82067F54h */ case    5:  		/* stw R9, <#[R3]> */
		/* 82067F54h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 82067F54h case    5:*/		return 0x82067F58;
		  /* 82067F58h */ case    6:  		/* stw R11, <#[R3 + 19892]> */
		/* 82067F58h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00004DB4) );
		/* 82067F58h case    6:*/		return 0x82067F5C;
		  /* 82067F5Ch */ case    7:  		/* bclr 20, CR0_LT */
		/* 82067F5Ch case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82067F5Ch case    7:*/		return 0x82067F60;
	}
	return 0x82067F60;
} // Block from 82067F40h-82067F60h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82067F60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067F60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067F60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067F60);
		  /* 82067F60h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82067F60h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82067F60h case    0:*/		return 0x82067F64;
		  /* 82067F64h */ case    1:  		/* mulli R11, R11, 9936 */
		/* 82067F64h case    1:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x26D0);
		/* 82067F64h case    1:*/		return 0x82067F68;
		  /* 82067F68h */ case    2:  		/* add R11, R11, R3 */
		/* 82067F68h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 82067F68h case    2:*/		return 0x82067F6C;
		  /* 82067F6Ch */ case    3:  		/* addi R10, R11, 16 */
		/* 82067F6Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x10);
		/* 82067F6Ch case    3:*/		return 0x82067F70;
		  /* 82067F70h */ case    4:  		/* stw R4, <#[R11 + 104]> */
		/* 82067F70h case    4:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R11 + 0x00000068) );
		/* 82067F70h case    4:*/		return 0x82067F74;
		  /* 82067F74h */ case    5:  		/* stw R5, <#[R11 + 108]> */
		/* 82067F74h case    5:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R11 + 0x0000006C) );
		/* 82067F74h case    5:*/		return 0x82067F78;
		  /* 82067F78h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82067F78h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82067F78h case    6:*/		return 0x82067F7C;
	}
	return 0x82067F7C;
} // Block from 82067F60h-82067F7Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 82067F7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067F7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067F7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067F7C);
		  /* 82067F7Ch */ case    0:  		/* nop */
		/* 82067F7Ch case    0:*/		cpu::op::nop();
		/* 82067F7Ch case    0:*/		return 0x82067F80;
		  /* 82067F80h */ case    1:  		/* b -184 */
		/* 82067F80h case    1:*/		return 0x82067EC8;
		/* 82067F80h case    1:*/		return 0x82067F84;
		  /* 82067F84h */ case    2:  		/* nop */
		/* 82067F84h case    2:*/		cpu::op::nop();
		/* 82067F84h case    2:*/		return 0x82067F88;
	}
	return 0x82067F88;
} // Block from 82067F7Ch-82067F88h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82067F88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067F88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067F88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067F88);
		  /* 82067F88h */ case    0:  		/* mfspr R12, LR */
		/* 82067F88h case    0:*/		regs.R12 = regs.LR;
		/* 82067F88h case    0:*/		return 0x82067F8C;
		  /* 82067F8Ch */ case    1:  		/* bl 168628 */
		/* 82067F8Ch case    1:*/		regs.LR = 0x82067F90; return 0x82091240;
		/* 82067F8Ch case    1:*/		return 0x82067F90;
		  /* 82067F90h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 82067F90h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 82067F90h case    2:*/		return 0x82067F94;
		  /* 82067F94h */ case    3:  		/* lwz R11, <#[R4]> */
		/* 82067F94h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 82067F94h case    3:*/		return 0x82067F98;
		  /* 82067F98h */ case    4:  		/* mr R24, R3 */
		/* 82067F98h case    4:*/		regs.R24 = regs.R3;
		/* 82067F98h case    4:*/		return 0x82067F9C;
		  /* 82067F9Ch */ case    5:  		/* mr R22, R9 */
		/* 82067F9Ch case    5:*/		regs.R22 = regs.R9;
		/* 82067F9Ch case    5:*/		return 0x82067FA0;
		  /* 82067FA0h */ case    6:  		/* mr R23, R10 */
		/* 82067FA0h case    6:*/		regs.R23 = regs.R10;
		/* 82067FA0h case    6:*/		return 0x82067FA4;
		  /* 82067FA4h */ case    7:  		/* li R3, 0 */
		/* 82067FA4h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82067FA4h case    7:*/		return 0x82067FA8;
		  /* 82067FA8h */ case    8:  		/* cmplw CR6, R11, R6 */
		/* 82067FA8h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R6);
		/* 82067FA8h case    8:*/		return 0x82067FAC;
		  /* 82067FACh */ case    9:  		/* bc 4, CR6_EQ, 32 */
		/* 82067FACh case    9:*/		if ( !regs.CR[6].eq ) { return 0x82067FCC;  }
		/* 82067FACh case    9:*/		return 0x82067FB0;
		  /* 82067FB0h */ case   10:  		/* lwz R11, <#[R24 + 4]> */
		/* 82067FB0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000004) );
		/* 82067FB0h case   10:*/		return 0x82067FB4;
		  /* 82067FB4h */ case   11:  		/* rlwinm. R11, R11, 0, 20, 20 */
		/* 82067FB4h case   11:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R11,regs.R11);
		/* 82067FB4h case   11:*/		return 0x82067FB8;
		  /* 82067FB8h */ case   12:  		/* bc 4, CR0_EQ, 20 */
		/* 82067FB8h case   12:*/		if ( !regs.CR[0].eq ) { return 0x82067FCC;  }
		/* 82067FB8h case   12:*/		return 0x82067FBC;
		  /* 82067FBCh */ case   13:  		/* lwz R11, <#[R24]> */
		/* 82067FBCh case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 82067FBCh case   13:*/		return 0x82067FC0;
		  /* 82067FC0h */ case   14:  		/* rlwinm R11, R11, 0, 20, 31 */
		/* 82067FC0h case   14:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R11,regs.R11);
		/* 82067FC0h case   14:*/		return 0x82067FC4;
		  /* 82067FC4h */ case   15:  		/* mulli R11, R11, 12 */
		/* 82067FC4h case   15:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 82067FC4h case   15:*/		return 0x82067FC8;
		  /* 82067FC8h */ case   16:  		/* stw R11, <#[R4]> */
		/* 82067FC8h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 82067FC8h case   16:*/		return 0x82067FCC;
	}
	return 0x82067FCC;
} // Block from 82067F88h-82067FCCh (17 instructions)

//////////////////////////////////////////////////////
// Block at 82067FCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067FCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067FCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067FCC);
		  /* 82067FCCh */ case    0:  		/* rlwinm. R11, R22, 0, 29, 30 */
		/* 82067FCCh case    0:*/		cpu::op::rlwinm<1,0,29,30>(regs,&regs.R11,regs.R22);
		/* 82067FCCh case    0:*/		return 0x82067FD0;
		  /* 82067FD0h */ case    1:  		/* bc 12, CR0_EQ, 320 */
		/* 82067FD0h case    1:*/		if ( regs.CR[0].eq ) { return 0x82068110;  }
		/* 82067FD0h case    1:*/		return 0x82067FD4;
		  /* 82067FD4h */ case    2:  		/* lwz R31, <#[R24 + 4]> */
		/* 82067FD4h case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R24 + 0x00000004) );
		/* 82067FD4h case    2:*/		return 0x82067FD8;
		  /* 82067FD8h */ case    3:  		/* rlwinm. R11, R31, 0, 20, 20 */
		/* 82067FD8h case    3:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R11,regs.R31);
		/* 82067FD8h case    3:*/		return 0x82067FDC;
		  /* 82067FDCh */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 82067FDCh case    4:*/		if ( regs.CR[0].eq ) { return 0x82067FEC;  }
		/* 82067FDCh case    4:*/		return 0x82067FE0;
		  /* 82067FE0h */ case    5:  		/* li R9, 0 */
		/* 82067FE0h case    5:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82067FE0h case    5:*/		return 0x82067FE4;
		  /* 82067FE4h */ case    6:  		/* mr R6, R8 */
		/* 82067FE4h case    6:*/		regs.R6 = regs.R8;
		/* 82067FE4h case    6:*/		return 0x82067FE8;
		  /* 82067FE8h */ case    7:  		/* b 12 */
		/* 82067FE8h case    7:*/		return 0x82067FF4;
		/* 82067FE8h case    7:*/		return 0x82067FEC;
	}
	return 0x82067FEC;
} // Block from 82067FCCh-82067FECh (8 instructions)

//////////////////////////////////////////////////////
// Block at 82067FECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067FEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067FEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067FEC);
		  /* 82067FECh */ case    0:  		/* lwz R9, <#[R4]> */
		/* 82067FECh case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x00000000) );
		/* 82067FECh case    0:*/		return 0x82067FF0;
		  /* 82067FF0h */ case    1:  		/* mr R7, R5 */
		/* 82067FF0h case    1:*/		regs.R7 = regs.R5;
		/* 82067FF0h case    1:*/		return 0x82067FF4;
	}
	return 0x82067FF4;
} // Block from 82067FECh-82067FF4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82067FF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82067FF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82067FF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82067FF4);
		  /* 82067FF4h */ case    0:  		/* lwz R11, <#[R24]> */
		/* 82067FF4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 82067FF4h case    0:*/		return 0x82067FF8;
		  /* 82067FF8h */ case    1:  		/* rlwinm. R25, R11, 20, 29, 31 */
		/* 82067FF8h case    1:*/		cpu::op::rlwinm<1,20,29,31>(regs,&regs.R25,regs.R11);
		/* 82067FF8h case    1:*/		return 0x82067FFC;
		  /* 82067FFCh */ case    2:  		/* bc 12, CR0_EQ, 276 */
		/* 82067FFCh case    2:*/		if ( regs.CR[0].eq ) { return 0x82068110;  }
		/* 82067FFCh case    2:*/		return 0x82068000;
		  /* 82068000h */ case    3:  		/* rlwinm R10, R11, 0, 20, 31 */
		/* 82068000h case    3:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R10,regs.R11);
		/* 82068000h case    3:*/		return 0x82068004;
		  /* 82068004h */ case    4:  		/* mulli R10, R10, 12 */
		/* 82068004h case    4:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0xC);
		/* 82068004h case    4:*/		return 0x82068008;
		  /* 82068008h */ case    5:  		/* cmplw CR6, R10, R9 */
		/* 82068008h case    5:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 82068008h case    5:*/		return 0x8206800C;
		  /* 8206800Ch */ case    6:  		/* bc 12, CR6_LT, 252 */
		/* 8206800Ch case    6:*/		if ( regs.CR[6].lt ) { return 0x82068108;  }
		/* 8206800Ch case    6:*/		return 0x82068010;
		  /* 82068010h */ case    7:  		/* mulli R9, R25, 12 */
		/* 82068010h case    7:*/		cpu::op::mulli<0>(regs,&regs.R9,regs.R25,0xC);
		/* 82068010h case    7:*/		return 0x82068014;
		  /* 82068014h */ case    8:  		/* add R9, R9, R10 */
		/* 82068014h case    8:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 82068014h case    8:*/		return 0x82068018;
		  /* 82068018h */ case    9:  		/* cmplw CR6, R9, R6 */
		/* 82068018h case    9:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R6);
		/* 82068018h case    9:*/		return 0x8206801C;
		  /* 8206801Ch */ case   10:  		/* bc 12, CR6_GT, 236 */
		/* 8206801Ch case   10:*/		if ( regs.CR[6].gt ) { return 0x82068108;  }
		/* 8206801Ch case   10:*/		return 0x82068020;
		  /* 82068020h */ case   11:  		/* rlwinm R9, R31, 4, 26, 27 */
		/* 82068020h case   11:*/		cpu::op::rlwinm<0,4,26,27>(regs,&regs.R9,regs.R31);
		/* 82068020h case   11:*/		return 0x82068024;
		  /* 82068024h */ case   12:  		/* rlwinm R8, R11, 4, 28, 31 */
		/* 82068024h case   12:*/		cpu::op::rlwinm<0,4,28,31>(regs,&regs.R8,regs.R11);
		/* 82068024h case   12:*/		return 0x82068028;
		  /* 82068028h */ case   13:  		/* add R29, R10, R7 */
		/* 82068028h case   13:*/		cpu::op::add<0>(regs,&regs.R29,regs.R10,regs.R7);
		/* 82068028h case   13:*/		return 0x8206802C;
		  /* 8206802Ch */ case   14:  		/* rlwinm R28, R11, 16, 20, 31 */
		/* 8206802Ch case   14:*/		cpu::op::rlwinm<0,16,20,31>(regs,&regs.R28,regs.R11);
		/* 8206802Ch case   14:*/		return 0x82068030;
		  /* 82068030h */ case   15:  		/* or R26, R9, R8 */
		/* 82068030h case   15:*/		cpu::op::or<0>(regs,&regs.R26,regs.R9,regs.R8);
		/* 82068030h case   15:*/		return 0x82068034;
		  /* 82068034h */ case   16:  		/* li R31, 0 */
		/* 82068034h case   16:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82068034h case   16:*/		return 0x82068038;
		  /* 82068038h */ case   17:  		/* cmplwi CR6, R25, 0 */
		/* 82068038h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 82068038h case   17:*/		return 0x8206803C;
		  /* 8206803Ch */ case   18:  		/* bc 12, CR6_EQ, 212 */
		/* 8206803Ch case   18:*/		if ( regs.CR[6].eq ) { return 0x82068110;  }
		/* 8206803Ch case   18:*/		return 0x82068040;
		  /* 82068040h */ case   19:  		/* li R30, 0 */
		/* 82068040h case   19:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82068040h case   19:*/		return 0x82068044;
		  /* 82068044h */ case   20:  		/* li R27, 1 */
		/* 82068044h case   20:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 82068044h case   20:*/		return 0x82068048;
		  /* 82068048h */ case   21:  		/* li R11, 2 */
		/* 82068048h case   21:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 82068048h case   21:*/		return 0x8206804C;
		  /* 8206804Ch */ case   22:  		/* slw R10, R27, R31 */
		/* 8206804Ch case   22:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R27,regs.R31);
		/* 8206804Ch case   22:*/		return 0x82068050;
		  /* 82068050h */ case   23:  		/* slw R11, R11, R30 */
		/* 82068050h case   23:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 82068050h case   23:*/		return 0x82068054;
		  /* 82068054h */ case   24:  		/* and R11, R11, R28 */
		/* 82068054h case   24:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R28);
		/* 82068054h case   24:*/		return 0x82068058;
		  /* 82068058h */ case   25:  		/* and R10, R10, R26 */
		/* 82068058h case   25:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R26);
		/* 82068058h case   25:*/		return 0x8206805C;
		  /* 8206805Ch */ case   26:  		/* addic R9, R11, -1 */
		/* 8206805Ch case   26:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R11,0xFFFFFFFF);
		/* 8206805Ch case   26:*/		return 0x82068060;
		  /* 82068060h */ case   27:  		/* slw R8, R27, R30 */
		/* 82068060h case   27:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R27,regs.R30);
		/* 82068060h case   27:*/		return 0x82068064;
		  /* 82068064h */ case   28:  		/* subfe R11, R9, R11 */
		/* 82068064h case   28:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82068064h case   28:*/		return 0x82068068;
		  /* 82068068h */ case   29:  		/* addic R9, R10, -1 */
		/* 82068068h case   29:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R10,0xFFFFFFFF);
		/* 82068068h case   29:*/		return 0x8206806C;
		  /* 8206806Ch */ case   30:  		/* and R8, R8, R28 */
		/* 8206806Ch case   30:*/		cpu::op::and<0>(regs,&regs.R8,regs.R8,regs.R28);
		/* 8206806Ch case   30:*/		return 0x82068070;
		  /* 82068070h */ case   31:  		/* subfe R10, R9, R10 */
		/* 82068070h case   31:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82068070h case   31:*/		return 0x82068074;
		  /* 82068074h */ case   32:  		/* subfic R9, R8, 0 */
		/* 82068074h case   32:*/		cpu::op::subfic<0>(regs,&regs.R9,regs.R8,0x0);
		/* 82068074h case   32:*/		return 0x82068078;
		  /* 82068078h */ case   33:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82068078h case   33:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82068078h case   33:*/		return 0x8206807C;
		  /* 8206807Ch */ case   34:  		/* subfe R9, R9, R9 */
		/* 8206807Ch case   34:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 8206807Ch case   34:*/		return 0x82068080;
		  /* 82068080h */ case   35:  		/* rlwinm R11, R9, 0, 0, 30 */
		/* 82068080h case   35:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R9);
		/* 82068080h case   35:*/		return 0x82068084;
		  /* 82068084h */ case   36:  		/* addi R11, R11, 4 */
		/* 82068084h case   36:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82068084h case   36:*/		return 0x82068088;
		  /* 82068088h */ case   37:  		/* bc 12, CR0_EQ, 8 */
		/* 82068088h case   37:*/		if ( regs.CR[0].eq ) { return 0x82068090;  }
		/* 82068088h case   37:*/		return 0x8206808C;
		  /* 8206808Ch */ case   38:  		/* ori R11, R11, 32 */
		/* 8206808Ch case   38:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x20);
		/* 8206808Ch case   38:*/		return 0x82068090;
	}
	return 0x82068090;
} // Block from 82067FF4h-82068090h (39 instructions)

//////////////////////////////////////////////////////
// Block at 82068090h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068090( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068090) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068090);
		  /* 82068090h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 82068090h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 82068090h case    0:*/		return 0x82068094;
		  /* 82068094h */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 82068094h case    1:*/		if ( regs.CR[0].eq ) { return 0x8206809C;  }
		/* 82068094h case    1:*/		return 0x82068098;
		  /* 82068098h */ case    2:  		/* ori R11, R11, 16 */
		/* 82068098h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x10);
		/* 82068098h case    2:*/		return 0x8206809C;
	}
	return 0x8206809C;
} // Block from 82068090h-8206809Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206809Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206809C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206809C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206809C);
		  /* 8206809Ch */ case    0:  		/* lwz R10, <#[R24 + 4]> */
		/* 8206809Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x00000004) );
		/* 8206809Ch case    0:*/		return 0x820680A0;
		  /* 820680A0h */ case    1:  		/* rlwinm. R9, R10, 0, 20, 20 */
		/* 820680A0h case    1:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R9,regs.R10);
		/* 820680A0h case    1:*/		return 0x820680A4;
		  /* 820680A4h */ case    2:  		/* bc 12, CR0_EQ, 8 */
		/* 820680A4h case    2:*/		if ( regs.CR[0].eq ) { return 0x820680AC;  }
		/* 820680A4h case    2:*/		return 0x820680A8;
		  /* 820680A8h */ case    3:  		/* ori R11, R11, 64 */
		/* 820680A8h case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x40);
		/* 820680A8h case    3:*/		return 0x820680AC;
	}
	return 0x820680AC;
} // Block from 8206809Ch-820680ACh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820680ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820680AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820680AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820680AC);
		  /* 820680ACh */ case    0:  		/* rlwinm R10, R10, 0, 16, 19 */
		/* 820680ACh case    0:*/		cpu::op::rlwinm<0,0,16,19>(regs,&regs.R10,regs.R10);
		/* 820680ACh case    0:*/		return 0x820680B0;
		  /* 820680B0h */ case    1:  		/* cmplwi CR6, R10, 20480 */
		/* 820680B0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00005000);
		/* 820680B0h case    1:*/		return 0x820680B4;
		  /* 820680B4h */ case    2:  		/* bc 4, CR6_EQ, 8 */
		/* 820680B4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x820680BC;  }
		/* 820680B4h case    2:*/		return 0x820680B8;
		  /* 820680B8h */ case    3:  		/* ori R11, R11, 128 */
		/* 820680B8h case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x80);
		/* 820680B8h case    3:*/		return 0x820680BC;
	}
	return 0x820680BC;
} // Block from 820680ACh-820680BCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820680BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820680BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820680BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820680BC);
		  /* 820680BCh */ case    0:  		/* and R10, R11, R22 */
		/* 820680BCh case    0:*/		cpu::op::and<0>(regs,&regs.R10,regs.R11,regs.R22);
		/* 820680BCh case    0:*/		return 0x820680C0;
		  /* 820680C0h */ case    1:  		/* rlwinm. R10, R10, 0, 29, 30 */
		/* 820680C0h case    1:*/		cpu::op::rlwinm<1,0,29,30>(regs,&regs.R10,regs.R10);
		/* 820680C0h case    1:*/		return 0x820680C4;
		  /* 820680C4h */ case    2:  		/* bc 12, CR0_EQ, 44 */
		/* 820680C4h case    2:*/		if ( regs.CR[0].eq ) { return 0x820680F0;  }
		/* 820680C4h case    2:*/		return 0x820680C8;
		  /* 820680C8h */ case    3:  		/* lwz R10, <#[R24]> */
		/* 820680C8h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x00000000) );
		/* 820680C8h case    3:*/		return 0x820680CC;
		  /* 820680CCh */ case    4:  		/* mr R5, R29 */
		/* 820680CCh case    4:*/		regs.R5 = regs.R29;
		/* 820680CCh case    4:*/		return 0x820680D0;
		  /* 820680D0h */ case    5:  		/* mr R3, R11 */
		/* 820680D0h case    5:*/		regs.R3 = regs.R11;
		/* 820680D0h case    5:*/		return 0x820680D4;
		  /* 820680D4h */ case    6:  		/* lwz R6, <#[R1 + 260]> */
		/* 820680D4h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000104) );
		/* 820680D4h case    6:*/		return 0x820680D8;
		  /* 820680D8h */ case    7:  		/* rlwinm R10, R10, 0, 20, 31 */
		/* 820680D8h case    7:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R10,regs.R10);
		/* 820680D8h case    7:*/		return 0x820680DC;
		  /* 820680DCh */ case    8:  		/* mtspr CTR, R23 */
		/* 820680DCh case    8:*/		regs.CTR = regs.R23;
		/* 820680DCh case    8:*/		return 0x820680E0;
		  /* 820680E0h */ case    9:  		/* add R4, R10, R31 */
		/* 820680E0h case    9:*/		cpu::op::add<0>(regs,&regs.R4,regs.R10,regs.R31);
		/* 820680E0h case    9:*/		return 0x820680E4;
		  /* 820680E4h */ case   10:  		/* bcctrl 20, CR0_LT */
		/* 820680E4h case   10:*/		if ( 1 ) { regs.LR = 0x820680E8; return (uint32)regs.CTR; }
		/* 820680E4h case   10:*/		return 0x820680E8;
		  /* 820680E8h */ case   11:  		/* cmpwi CR0, R3, 0 */
		/* 820680E8h case   11:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 820680E8h case   11:*/		return 0x820680EC;
		  /* 820680ECh */ case   12:  		/* bc 12, CR0_LT, 36 */
		/* 820680ECh case   12:*/		if ( regs.CR[0].lt ) { return 0x82068110;  }
		/* 820680ECh case   12:*/		return 0x820680F0;
	}
	return 0x820680F0;
} // Block from 820680BCh-820680F0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 820680F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820680F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820680F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820680F0);
		  /* 820680F0h */ case    0:  		/* addi R31, R31, 1 */
		/* 820680F0h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 820680F0h case    0:*/		return 0x820680F4;
		  /* 820680F4h */ case    1:  		/* addi R30, R30, 2 */
		/* 820680F4h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x2);
		/* 820680F4h case    1:*/		return 0x820680F8;
		  /* 820680F8h */ case    2:  		/* addi R29, R29, 12 */
		/* 820680F8h case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0xC);
		/* 820680F8h case    2:*/		return 0x820680FC;
		  /* 820680FCh */ case    3:  		/* cmplw CR6, R31, R25 */
		/* 820680FCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R25);
		/* 820680FCh case    3:*/		return 0x82068100;
		  /* 82068100h */ case    4:  		/* bc 12, CR6_LT, -184 */
		/* 82068100h case    4:*/		if ( regs.CR[6].lt ) { return 0x82068048;  }
		/* 82068100h case    4:*/		return 0x82068104;
		  /* 82068104h */ case    5:  		/* b 12 */
		/* 82068104h case    5:*/		return 0x82068110;
		/* 82068104h case    5:*/		return 0x82068108;
	}
	return 0x82068108;
} // Block from 820680F0h-82068108h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82068108h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068108( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068108) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068108);
		  /* 82068108h */ case    0:  		/* lis R3, -32768 */
		/* 82068108h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 82068108h case    0:*/		return 0x8206810C;
		  /* 8206810Ch */ case    1:  		/* ori R3, R3, 16389 */
		/* 8206810Ch case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 8206810Ch case    1:*/		return 0x82068110;
	}
	return 0x82068110;
} // Block from 82068108h-82068110h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82068110h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068110( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068110) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068110);
		  /* 82068110h */ case    0:  		/* addi R1, R1, 176 */
		/* 82068110h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 82068110h case    0:*/		return 0x82068114;
		  /* 82068114h */ case    1:  		/* b 168316 */
		/* 82068114h case    1:*/		return 0x82091290;
		/* 82068114h case    1:*/		return 0x82068118;
	}
	return 0x82068118;
} // Block from 82068110h-82068118h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82068118h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068118( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068118) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068118);
		  /* 82068118h */ case    0:  		/* mfspr R12, LR */
		/* 82068118h case    0:*/		regs.R12 = regs.LR;
		/* 82068118h case    0:*/		return 0x8206811C;
		  /* 8206811Ch */ case    1:  		/* bl 168196 */
		/* 8206811Ch case    1:*/		regs.LR = 0x82068120; return 0x82091220;
		/* 8206811Ch case    1:*/		return 0x82068120;
		  /* 82068120h */ case    2:  		/* stwu R1, <#[R1 - 320]> */
		/* 82068120h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEC0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEC0);
		/* 82068120h case    2:*/		return 0x82068124;
		  /* 82068124h */ case    3:  		/* addi R11, R1, 128 */
		/* 82068124h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x80);
		/* 82068124h case    3:*/		return 0x82068128;
		  /* 82068128h */ case    4:  		/* stw R4, <#[R1 + 96]> */
		/* 82068128h case    4:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x00000060) );
		/* 82068128h case    4:*/		return 0x8206812C;
		  /* 8206812Ch */ case    5:  		/* mr R18, R3 */
		/* 8206812Ch case    5:*/		regs.R18 = regs.R3;
		/* 8206812Ch case    5:*/		return 0x82068130;
		  /* 82068130h */ case    6:  		/* mr R24, R4 */
		/* 82068130h case    6:*/		regs.R24 = regs.R4;
		/* 82068130h case    6:*/		return 0x82068134;
		  /* 82068134h */ case    7:  		/* mr R17, R5 */
		/* 82068134h case    7:*/		regs.R17 = regs.R5;
		/* 82068134h case    7:*/		return 0x82068138;
		  /* 82068138h */ case    8:  		/* mr R16, R6 */
		/* 82068138h case    8:*/		regs.R16 = regs.R6;
		/* 82068138h case    8:*/		return 0x8206813C;
		  /* 8206813Ch */ case    9:  		/* mr R23, R7 */
		/* 8206813Ch case    9:*/		regs.R23 = regs.R7;
		/* 8206813Ch case    9:*/		return 0x82068140;
		  /* 82068140h */ case   10:  		/* mr R14, R8 */
		/* 82068140h case   10:*/		regs.R14 = regs.R8;
		/* 82068140h case   10:*/		return 0x82068144;
		  /* 82068144h */ case   11:  		/* mr R22, R9 */
		/* 82068144h case   11:*/		regs.R22 = regs.R9;
		/* 82068144h case   11:*/		return 0x82068148;
		  /* 82068148h */ case   12:  		/* mr R20, R10 */
		/* 82068148h case   12:*/		regs.R20 = regs.R10;
		/* 82068148h case   12:*/		return 0x8206814C;
		  /* 8206814Ch */ case   13:  		/* li R3, 0 */
		/* 8206814Ch case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8206814Ch case   13:*/		return 0x82068150;
		  /* 82068150h */ case   14:  		/* li R31, 0 */
		/* 82068150h case   14:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82068150h case   14:*/		return 0x82068154;
		  /* 82068154h */ case   15:  		/* li R29, 0 */
		/* 82068154h case   15:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82068154h case   15:*/		return 0x82068158;
		  /* 82068158h */ case   16:  		/* li R26, 0 */
		/* 82068158h case   16:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82068158h case   16:*/		return 0x8206815C;
		  /* 8206815Ch */ case   17:  		/* li R19, -1 */
		/* 8206815Ch case   17:*/		cpu::op::li<0>(regs,&regs.R19,0xFFFFFFFF);
		/* 8206815Ch case   17:*/		return 0x82068160;
		  /* 82068160h */ case   18:  		/* li R15, -1 */
		/* 82068160h case   18:*/		cpu::op::li<0>(regs,&regs.R15,0xFFFFFFFF);
		/* 82068160h case   18:*/		return 0x82068164;
		  /* 82068164h */ case   19:  		/* addi R21, R1, 144 */
		/* 82068164h case   19:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R1,0x90);
		/* 82068164h case   19:*/		return 0x82068168;
		  /* 82068168h */ case   20:  		/* addi R25, R11, -4 */
		/* 82068168h case   20:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R11,0xFFFFFFFC);
		/* 82068168h case   20:*/		return 0x8206816C;
		  /* 8206816Ch */ case   21:  		/* li R27, 1 */
		/* 8206816Ch case   21:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 8206816Ch case   21:*/		return 0x82068170;
		  /* 82068170h */ case   22:  		/* li R11, 12 */
		/* 82068170h case   22:*/		cpu::op::li<0>(regs,&regs.R11,0xC);
		/* 82068170h case   22:*/		return 0x82068174;
		  /* 82068174h */ case   23:  		/* li R9, 6 */
		/* 82068174h case   23:*/		cpu::op::li<0>(regs,&regs.R9,0x6);
		/* 82068174h case   23:*/		return 0x82068178;
		  /* 82068178h */ case   24:  		/* divwu R11, R31, R11 */
		/* 82068178h case   24:*/		cpu::op::divwu<0>(regs,&regs.R11,regs.R31,regs.R11);
		/* 82068178h case   24:*/		return 0x8206817C;
		  /* 8206817Ch */ case   25:  		/* cmplwi CR6, R29, 0 */
		/* 8206817Ch case   25:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 8206817Ch case   25:*/		return 0x82068180;
		  /* 82068180h */ case   26:  		/* mulli R11, R11, 12 */
		/* 82068180h case   26:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 82068180h case   26:*/		return 0x82068184;
		  /* 82068184h */ case   27:  		/* subf R10, R11, R31 */
		/* 82068184h case   27:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R31);
		/* 82068184h case   27:*/		return 0x82068188;
		  /* 82068188h */ case   28:  		/* divwu R10, R10, R9 */
		/* 82068188h case   28:*/		cpu::op::divwu<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82068188h case   28:*/		return 0x8206818C;
		  /* 8206818Ch */ case   29:  		/* bc 12, CR6_EQ, 20 */
		/* 8206818Ch case   29:*/		if ( regs.CR[6].eq ) { return 0x820681A0;  }
		/* 8206818Ch case   29:*/		return 0x82068190;
		  /* 82068190h */ case   30:  		/* cmplw CR6, R31, R16 */
		/* 82068190h case   30:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R16);
		/* 82068190h case   30:*/		return 0x82068194;
		  /* 82068194h */ case   31:  		/* bc 4, CR6_LT, 724 */
		/* 82068194h case   31:*/		if ( !regs.CR[6].lt ) { return 0x82068468;  }
		/* 82068194h case   31:*/		return 0x82068198;
		  /* 82068198h */ case   32:  		/* add R28, R11, R17 */
		/* 82068198h case   32:*/		cpu::op::add<0>(regs,&regs.R28,regs.R11,regs.R17);
		/* 82068198h case   32:*/		return 0x8206819C;
		  /* 8206819Ch */ case   33:  		/* b 20 */
		/* 8206819Ch case   33:*/		return 0x820681B0;
		/* 8206819Ch case   33:*/		return 0x820681A0;
	}
	return 0x820681A0;
} // Block from 82068118h-820681A0h (34 instructions)

//////////////////////////////////////////////////////
// Block at 820681A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820681A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820681A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820681A0);
		  /* 820681A0h */ case    0:  		/* lwz R8, <#[R1 + 96]> */
		/* 820681A0h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000060) );
		/* 820681A0h case    0:*/		return 0x820681A4;
		  /* 820681A4h */ case    1:  		/* cmplw CR6, R31, R8 */
		/* 820681A4h case    1:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R8);
		/* 820681A4h case    1:*/		return 0x820681A8;
		  /* 820681A8h */ case    2:  		/* bc 4, CR6_LT, 704 */
		/* 820681A8h case    2:*/		if ( !regs.CR[6].lt ) { return 0x82068468;  }
		/* 820681A8h case    2:*/		return 0x820681AC;
		  /* 820681ACh */ case    3:  		/* add R28, R11, R18 */
		/* 820681ACh case    3:*/		cpu::op::add<0>(regs,&regs.R28,regs.R11,regs.R18);
		/* 820681ACh case    3:*/		return 0x820681B0;
	}
	return 0x820681B0;
} // Block from 820681A0h-820681B0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820681B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820681B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820681B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820681B0);
		  /* 820681B0h */ case    0:  		/* lwz R8, <#[R28]> */
		/* 820681B0h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R28 + 0x00000000) );
		/* 820681B0h case    0:*/		return 0x820681B4;
		  /* 820681B4h */ case    1:  		/* rlwinm R10, R10, 3, 0, 28 */
		/* 820681B4h case    1:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R10);
		/* 820681B4h case    1:*/		return 0x820681B8;
		  /* 820681B8h */ case    2:  		/* stw R8, <#[R1 + 112]> */
		/* 820681B8h case    2:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000070) );
		/* 820681B8h case    2:*/		return 0x820681BC;
		  /* 820681BCh */ case    3:  		/* addi R11, R1, 112 */
		/* 820681BCh case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 820681BCh case    3:*/		return 0x820681C0;
		  /* 820681C0h */ case    4:  		/* rlwinm. R7, R22, 0, 31, 31 */
		/* 820681C0h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R7,regs.R22);
		/* 820681C0h case    4:*/		return 0x820681C4;
		  /* 820681C4h */ case    5:  		/* add R30, R10, R11 */
		/* 820681C4h case    5:*/		cpu::op::add<0>(regs,&regs.R30,regs.R10,regs.R11);
		/* 820681C4h case    5:*/		return 0x820681C8;
		  /* 820681C8h */ case    6:  		/* lhz R11, <#[R28 + 6]> */
		/* 820681C8h case    6:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000006) );
		/* 820681C8h case    6:*/		return 0x820681CC;
		  /* 820681CCh */ case    7:  		/* stw R11, <#[R1 + 116]> */
		/* 820681CCh case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000074) );
		/* 820681CCh case    7:*/		return 0x820681D0;
		  /* 820681D0h */ case    8:  		/* lhz R11, <#[R28 + 4]> */
		/* 820681D0h case    8:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 820681D0h case    8:*/		return 0x820681D4;
		  /* 820681D4h */ case    9:  		/* lwz R10, <#[R28 + 8]> */
		/* 820681D4h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000008) );
		/* 820681D4h case    9:*/		return 0x820681D8;
		  /* 820681D8h */ case   10:  		/* rlwinm R10, R10, 16, 0, 15 */
		/* 820681D8h case   10:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R10,regs.R10);
		/* 820681D8h case   10:*/		return 0x820681DC;
		  /* 820681DCh */ case   11:  		/* or R11, R10, R11 */
		/* 820681DCh case   11:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820681DCh case   11:*/		return 0x820681E0;
		  /* 820681E0h */ case   12:  		/* stw R11, <#[R1 + 120]> */
		/* 820681E0h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000078) );
		/* 820681E0h case   12:*/		return 0x820681E4;
		  /* 820681E4h */ case   13:  		/* lhz R11, <#[R28 + 8]> */
		/* 820681E4h case   13:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 820681E4h case   13:*/		return 0x820681E8;
		  /* 820681E8h */ case   14:  		/* stw R11, <#[R1 + 124]> */
		/* 820681E8h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000007C) );
		/* 820681E8h case   14:*/		return 0x820681EC;
		  /* 820681ECh */ case   15:  		/* bc 12, CR0_EQ, 36 */
		/* 820681ECh case   15:*/		if ( regs.CR[0].eq ) { return 0x82068210;  }
		/* 820681ECh case   15:*/		return 0x820681F0;
		  /* 820681F0h */ case   16:  		/* mr R5, R30 */
		/* 820681F0h case   16:*/		regs.R5 = regs.R30;
		/* 820681F0h case   16:*/		return 0x820681F4;
		  /* 820681F4h */ case   17:  		/* lwz R6, <#[R1 + 404]> */
		/* 820681F4h case   17:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000194) );
		/* 820681F4h case   17:*/		return 0x820681F8;
		  /* 820681F8h */ case   18:  		/* divwu R4, R31, R9 */
		/* 820681F8h case   18:*/		cpu::op::divwu<0>(regs,&regs.R4,regs.R31,regs.R9);
		/* 820681F8h case   18:*/		return 0x820681FC;
		  /* 820681FCh */ case   19:  		/* mtspr CTR, R20 */
		/* 820681FCh case   19:*/		regs.CTR = regs.R20;
		/* 820681FCh case   19:*/		return 0x82068200;
		  /* 82068200h */ case   20:  		/* li R3, 1 */
		/* 82068200h case   20:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82068200h case   20:*/		return 0x82068204;
		  /* 82068204h */ case   21:  		/* bcctrl 20, CR0_LT */
		/* 82068204h case   21:*/		if ( 1 ) { regs.LR = 0x82068208; return (uint32)regs.CTR; }
		/* 82068204h case   21:*/		return 0x82068208;
		  /* 82068208h */ case   22:  		/* cmpwi CR0, R3, 0 */
		/* 82068208h case   22:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82068208h case   22:*/		return 0x8206820C;
		  /* 8206820Ch */ case   23:  		/* bc 12, CR0_LT, 612 */
		/* 8206820Ch case   23:*/		if ( regs.CR[0].lt ) { return 0x82068470;  }
		/* 8206820Ch case   23:*/		return 0x82068210;
	}
	return 0x82068210;
} // Block from 820681B0h-82068210h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82068210h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068210( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068210) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068210);
		  /* 82068210h */ case    0:  		/* lwz R11, <#[R30 + 4]> */
		/* 82068210h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 82068210h case    0:*/		return 0x82068214;
		  /* 82068214h */ case    1:  		/* li R8, 0 */
		/* 82068214h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82068214h case    1:*/		return 0x82068218;
		  /* 82068218h */ case    2:  		/* rlwinm R10, R11, 20, 28, 31 */
		/* 82068218h case    2:*/		cpu::op::rlwinm<0,20,28,31>(regs,&regs.R10,regs.R11);
		/* 82068218h case    2:*/		return 0x8206821C;
		  /* 8206821Ch */ case    3:  		/* cmplwi CR6, R10, 15 */
		/* 8206821Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000000F);
		/* 8206821Ch case    3:*/		return 0x82068220;
		  /* 82068220h */ case    4:  		/* bc 12, CR6_GT, 464 */
		/* 82068220h case    4:*/		if ( regs.CR[6].gt ) { return 0x820683F0;  }
		/* 82068220h case    4:*/		return 0x82068224;
		  /* 82068224h */ case    5:  		/* lis R12, -32256 */
		/* 82068224h case    5:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8200);
		/* 82068224h case    5:*/		return 0x82068228;
		  /* 82068228h */ case    6:  		/* addi R12, R12, 3544 */
		/* 82068228h case    6:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xDD8);
		/* 82068228h case    6:*/		return 0x8206822C;
		  /* 8206822Ch */ case    7:  		/* lbzx R0, <#[R12 + R10]> */
		/* 8206822Ch case    7:*/		cpu::mem::load8z( regs, &regs.R0, (uint32)(regs.R12 + regs.R10 + 0x00000000) );
		/* 8206822Ch case    7:*/		return 0x82068230;
		  /* 82068230h */ case    8:  		/* rlwinm R0, R0, 2, 0, 29 */
		/* 82068230h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R0,regs.R0);
		/* 82068230h case    8:*/		return 0x82068234;
		  /* 82068234h */ case    9:  		/* lis R12, -32249 */
		/* 82068234h case    9:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8207);
		/* 82068234h case    9:*/		return 0x82068238;
		  /* 82068238h */ case   10:  		/* ori R0, R0, 0 */
		/* 82068238h case   10:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 82068238h case   10:*/		return 0x8206823C;
		  /* 8206823Ch */ case   11:  		/* addi R12, R12, -32180 */
		/* 8206823Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFF824C);
		/* 8206823Ch case   11:*/		return 0x82068240;
		  /* 82068240h */ case   12:  		/* add R12, R12, R0 */
		/* 82068240h case   12:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 82068240h case   12:*/		return 0x82068244;
		  /* 82068244h */ case   13:  		/* mtspr CTR, R12 */
		/* 82068244h case   13:*/		regs.CTR = regs.R12;
		/* 82068244h case   13:*/		return 0x82068248;
		  /* 82068248h */ case   14:  		/* bcctr 20, CR0_LT */
		/* 82068248h case   14:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 82068248h case   14:*/		return 0x8206824C;
		  /* 8206824Ch */ case   15:  		/* mr R8, R27 */
		/* 8206824Ch case   15:*/		regs.R8 = regs.R27;
		/* 8206824Ch case   15:*/		return 0x82068250;
		  /* 82068250h */ case   16:  		/* b 412 */
		/* 82068250h case   16:*/		return 0x820683EC;
		/* 82068250h case   16:*/		return 0x82068254;
		  /* 82068254h */ case   17:  		/* rlwinm R10, R11, 27, 27, 29 */
		/* 82068254h case   17:*/		cpu::op::rlwinm<0,27,27,29>(regs,&regs.R10,regs.R11);
		/* 82068254h case   17:*/		return 0x82068258;
		  /* 82068258h */ case   18:  		/* rlwinm R9, R11, 30, 27, 31 */
		/* 82068258h case   18:*/		cpu::op::rlwinm<0,30,27,31>(regs,&regs.R9,regs.R11);
		/* 82068258h case   18:*/		return 0x8206825C;
		  /* 8206825Ch */ case   19:  		/* rlwinm R11, R11, 22, 31, 31 */
		/* 8206825Ch case   19:*/		cpu::op::rlwinm<0,22,31,31>(regs,&regs.R11,regs.R11);
		/* 8206825Ch case   19:*/		return 0x82068260;
		  /* 82068260h */ case   20:  		/* slw R9, R27, R9 */
		/* 82068260h case   20:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R27,regs.R9);
		/* 82068260h case   20:*/		return 0x82068264;
		  /* 82068264h */ case   21:  		/* lwzx R10, <#[R10 + R23]> */
		/* 82068264h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R23 + 0x00000000) );
		/* 82068264h case   21:*/		return 0x82068268;
		  /* 82068268h */ case   22:  		/* and R10, R9, R10 */
		/* 82068268h case   22:*/		cpu::op::and<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82068268h case   22:*/		return 0x8206826C;
		  /* 8206826Ch */ case   23:  		/* addic R9, R10, -1 */
		/* 8206826Ch case   23:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R10,0xFFFFFFFF);
		/* 8206826Ch case   23:*/		return 0x82068270;
		  /* 82068270h */ case   24:  		/* subfe R10, R9, R10 */
		/* 82068270h case   24:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82068270h case   24:*/		return 0x82068274;
		  /* 82068274h */ case   25:  		/* cmplw CR6, R10, R11 */
		/* 82068274h case   25:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82068274h case   25:*/		return 0x82068278;
		  /* 82068278h */ case   26:  		/* bc 4, CR6_EQ, 372 */
		/* 82068278h case   26:*/		if ( !regs.CR[6].eq ) { return 0x820683EC;  }
		/* 82068278h case   26:*/		return 0x8206827C;
		  /* 8206827Ch */ case   27:  		/* b -48 */
		/* 8206827Ch case   27:*/		return 0x8206824C;
		/* 8206827Ch case   27:*/		return 0x82068280;
		  /* 82068280h */ case   28:  		/* lwz R10, <#[R30]> */
		/* 82068280h case   28:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82068280h case   28:*/		return 0x82068284;
		  /* 82068284h */ case   29:  		/* rlwinm R9, R10, 18, 25, 29 */
		/* 82068284h case   29:*/		cpu::op::rlwinm<0,18,25,29>(regs,&regs.R9,regs.R10);
		/* 82068284h case   29:*/		return 0x82068288;
		  /* 82068288h */ case   30:  		/* lwzx R9, <#[R9 + R14]> */
		/* 82068288h case   30:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R14 + 0x00000000) );
		/* 82068288h case   30:*/		return 0x8206828C;
		  /* 8206828Ch */ case   31:  		/* rlwinm. R9, R9, 0, 24, 31 */
		/* 8206828Ch case   31:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R9,regs.R9);
		/* 8206828Ch case   31:*/		return 0x82068290;
		  /* 82068290h */ case   32:  		/* bc 12, CR0_EQ, 192 */
		/* 82068290h case   32:*/		if ( regs.CR[0].eq ) { return 0x82068350;  }
		/* 82068290h case   32:*/		return 0x82068294;
		  /* 82068294h */ case   33:  		/* addi R15, R15, 1 */
		/* 82068294h case   33:*/		cpu::op::addi<0>(regs,&regs.R15,regs.R15,0x1);
		/* 82068294h case   33:*/		return 0x82068298;
		  /* 82068298h */ case   34:  		/* addi R25, R25, 4 */
		/* 82068298h case   34:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x4);
		/* 82068298h case   34:*/		return 0x8206829C;
		  /* 8206829Ch */ case   35:  		/* cmpwi CR6, R15, 4 */
		/* 8206829Ch case   35:*/		cpu::op::cmpwi<6>(regs,regs.R15,0x00000004);
		/* 8206829Ch case   35:*/		return 0x820682A0;
		  /* 820682A0h */ case   36:  		/* bc 12, CR6_LT, 12 */
		/* 820682A0h case   36:*/		if ( regs.CR[6].lt ) { return 0x820682AC;  }
		/* 820682A0h case   36:*/		return 0x820682A4;
		  /* 820682A4h */ case   37:  		/* mr R26, R27 */
		/* 820682A4h case   37:*/		regs.R26 = regs.R27;
		/* 820682A4h case   37:*/		return 0x820682A8;
		  /* 820682A8h */ case   38:  		/* b 328 */
		/* 820682A8h case   38:*/		return 0x820683F0;
		/* 820682A8h case   38:*/		return 0x820682AC;
	}
	return 0x820682AC;
} // Block from 82068210h-820682ACh (39 instructions)

//////////////////////////////////////////////////////
// Block at 820682ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820682AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820682AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820682AC);
		  /* 820682ACh */ case    0:  		/* stw R8, <#[R25]> */
		/* 820682ACh case    0:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R25 + 0x00000000) );
		/* 820682ACh case    0:*/		return 0x820682B0;
		  /* 820682B0h */ case    1:  		/* b 316 */
		/* 820682B0h case    1:*/		return 0x820683EC;
		/* 820682B0h case    1:*/		return 0x820682B4;
		  /* 820682B4h */ case    2:  		/* cmpwi CR6, R15, 0 */
		/* 820682B4h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R15,0x00000000);
		/* 820682B4h case    2:*/		return 0x820682B8;
		  /* 820682B8h */ case    3:  		/* bc 12, CR6_LT, -20 */
		/* 820682B8h case    3:*/		if ( regs.CR[6].lt ) { return 0x820682A4;  }
		/* 820682B8h case    3:*/		return 0x820682BC;
		  /* 820682BCh */ case    4:  		/* lwz R9, <#[R30]> */
		/* 820682BCh case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 820682BCh case    4:*/		return 0x820682C0;
		  /* 820682C0h */ case    5:  		/* lwz R10, <#[R25]> */
		/* 820682C0h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000000) );
		/* 820682C0h case    5:*/		return 0x820682C4;
		  /* 820682C4h */ case    6:  		/* rlwinm R7, R9, 18, 25, 29 */
		/* 820682C4h case    6:*/		cpu::op::rlwinm<0,18,25,29>(regs,&regs.R7,regs.R9);
		/* 820682C4h case    6:*/		return 0x820682C8;
		  /* 820682C8h */ case    7:  		/* addi R10, R10, 1 */
		/* 820682C8h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 820682C8h case    7:*/		return 0x820682CC;
		  /* 820682CCh */ case    8:  		/* stw R10, <#[R25]> */
		/* 820682CCh case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R25 + 0x00000000) );
		/* 820682CCh case    8:*/		return 0x820682D0;
		  /* 820682D0h */ case    9:  		/* lwzx R7, <#[R7 + R14]> */
		/* 820682D0h case    9:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + regs.R14 + 0x00000000) );
		/* 820682D0h case    9:*/		return 0x820682D4;
		  /* 820682D4h */ case   10:  		/* rlwinm R7, R7, 0, 24, 31 */
		/* 820682D4h case   10:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R7,regs.R7);
		/* 820682D4h case   10:*/		return 0x820682D8;
		  /* 820682D8h */ case   11:  		/* cmplw CR6, R10, R7 */
		/* 820682D8h case   11:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R7);
		/* 820682D8h case   11:*/		return 0x820682DC;
		  /* 820682DCh */ case   12:  		/* bc 4, CR6_LT, 12 */
		/* 820682DCh case   12:*/		if ( !regs.CR[6].lt ) { return 0x820682E8;  }
		/* 820682DCh case   12:*/		return 0x820682E0;
		  /* 820682E0h */ case   13:  		/* rlwinm R10, R9, 0, 19, 31 */
		/* 820682E0h case   13:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R10,regs.R9);
		/* 820682E0h case   13:*/		return 0x820682E4;
		  /* 820682E4h */ case   14:  		/* b 112 */
		/* 820682E4h case   14:*/		return 0x82068354;
		/* 820682E4h case   14:*/		return 0x820682E8;
	}
	return 0x820682E8;
} // Block from 820682ACh-820682E8h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820682E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820682E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820682E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820682E8);
		  /* 820682E8h */ case    0:  		/* addi R15, R15, -1 */
		/* 820682E8h case    0:*/		cpu::op::addi<0>(regs,&regs.R15,regs.R15,0xFFFFFFFF);
		/* 820682E8h case    0:*/		return 0x820682EC;
		  /* 820682ECh */ case    1:  		/* addi R25, R25, -4 */
		/* 820682ECh case    1:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0xFFFFFFFC);
		/* 820682ECh case    1:*/		return 0x820682F0;
		  /* 820682F0h */ case    2:  		/* b 252 */
		/* 820682F0h case    2:*/		return 0x820683EC;
		/* 820682F0h case    2:*/		return 0x820682F4;
		  /* 820682F4h */ case    3:  		/* lwz R10, <#[R30]> */
		/* 820682F4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 820682F4h case    3:*/		return 0x820682F8;
		  /* 820682F8h */ case    4:  		/* rlwinm. R9, R10, 0, 18, 18 */
		/* 820682F8h case    4:*/		cpu::op::rlwinm<1,0,18,18>(regs,&regs.R9,regs.R10);
		/* 820682F8h case    4:*/		return 0x820682FC;
		  /* 820682FCh */ case    5:  		/* bc 4, CR0_EQ, 52 */
		/* 820682FCh case    5:*/		if ( !regs.CR[0].eq ) { return 0x82068330;  }
		/* 820682FCh case    5:*/		return 0x82068300;
		  /* 82068300h */ case    6:  		/* rlwinm. R9, R10, 0, 17, 17 */
		/* 82068300h case    6:*/		cpu::op::rlwinm<1,0,17,17>(regs,&regs.R9,regs.R10);
		/* 82068300h case    6:*/		return 0x82068304;
		  /* 82068304h */ case    7:  		/* bc 4, CR0_EQ, 44 */
		/* 82068304h case    7:*/		if ( !regs.CR[0].eq ) { return 0x82068330;  }
		/* 82068304h case    7:*/		return 0x82068308;
		  /* 82068308h */ case    8:  		/* rlwinm R9, R11, 27, 27, 29 */
		/* 82068308h case    8:*/		cpu::op::rlwinm<0,27,27,29>(regs,&regs.R9,regs.R11);
		/* 82068308h case    8:*/		return 0x8206830C;
		  /* 8206830Ch */ case    9:  		/* rlwinm R7, R11, 30, 27, 31 */
		/* 8206830Ch case    9:*/		cpu::op::rlwinm<0,30,27,31>(regs,&regs.R7,regs.R11);
		/* 8206830Ch case    9:*/		return 0x82068310;
		  /* 82068310h */ case   10:  		/* rlwinm R6, R11, 22, 31, 31 */
		/* 82068310h case   10:*/		cpu::op::rlwinm<0,22,31,31>(regs,&regs.R6,regs.R11);
		/* 82068310h case   10:*/		return 0x82068314;
		  /* 82068314h */ case   11:  		/* slw R7, R27, R7 */
		/* 82068314h case   11:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R27,regs.R7);
		/* 82068314h case   11:*/		return 0x82068318;
		  /* 82068318h */ case   12:  		/* lwzx R9, <#[R9 + R23]> */
		/* 82068318h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R23 + 0x00000000) );
		/* 82068318h case   12:*/		return 0x8206831C;
		  /* 8206831Ch */ case   13:  		/* and R9, R7, R9 */
		/* 8206831Ch case   13:*/		cpu::op::and<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 8206831Ch case   13:*/		return 0x82068320;
		  /* 82068320h */ case   14:  		/* addic R7, R9, -1 */
		/* 82068320h case   14:*/		cpu::op::addic<0>(regs,&regs.R7,regs.R9,0xFFFFFFFF);
		/* 82068320h case   14:*/		return 0x82068324;
		  /* 82068324h */ case   15:  		/* subfe R9, R7, R9 */
		/* 82068324h case   15:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 82068324h case   15:*/		return 0x82068328;
		  /* 82068328h */ case   16:  		/* cmplw CR6, R9, R6 */
		/* 82068328h case   16:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R6);
		/* 82068328h case   16:*/		return 0x8206832C;
		  /* 8206832Ch */ case   17:  		/* bc 4, CR6_EQ, 192 */
		/* 8206832Ch case   17:*/		if ( !regs.CR[6].eq ) { return 0x820683EC;  }
		/* 8206832Ch case   17:*/		return 0x82068330;
	}
	return 0x82068330;
} // Block from 820682E8h-82068330h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82068330h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068330( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068330) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068330);
		  /* 82068330h */ case    0:  		/* addi R19, R19, 1 */
		/* 82068330h case    0:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R19,0x1);
		/* 82068330h case    0:*/		return 0x82068334;
		  /* 82068334h */ case    1:  		/* addi R21, R21, 4 */
		/* 82068334h case    1:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R21,0x4);
		/* 82068334h case    1:*/		return 0x82068338;
		  /* 82068338h */ case    2:  		/* cmpwi CR6, R19, 4 */
		/* 82068338h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R19,0x00000004);
		/* 82068338h case    2:*/		return 0x8206833C;
		  /* 8206833Ch */ case    3:  		/* bc 4, CR6_LT, -152 */
		/* 8206833Ch case    3:*/		if ( !regs.CR[6].lt ) { return 0x820682A4;  }
		/* 8206833Ch case    3:*/		return 0x82068340;
		  /* 82068340h */ case    4:  		/* rlwinm R9, R29, 16, 0, 15 */
		/* 82068340h case    4:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R9,regs.R29);
		/* 82068340h case    4:*/		return 0x82068344;
		  /* 82068344h */ case    5:  		/* addi R7, R31, 6 */
		/* 82068344h case    5:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R31,0x6);
		/* 82068344h case    5:*/		return 0x82068348;
		  /* 82068348h */ case    6:  		/* or R9, R9, R7 */
		/* 82068348h case    6:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 82068348h case    6:*/		return 0x8206834C;
		  /* 8206834Ch */ case    7:  		/* stw R9, <#[R21 - 4]> */
		/* 8206834Ch case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R21 + 0xFFFFFFFC) );
		/* 8206834Ch case    7:*/		return 0x82068350;
	}
	return 0x82068350;
} // Block from 82068330h-82068350h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82068350h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068350( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068350) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068350);
		  /* 82068350h */ case    0:  		/* rlwinm R10, R10, 0, 19, 31 */
		/* 82068350h case    0:*/		cpu::op::rlwinm<0,0,19,31>(regs,&regs.R10,regs.R10);
		/* 82068350h case    0:*/		return 0x82068354;
	}
	return 0x82068354;
} // Block from 82068350h-82068354h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82068354h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068354( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068354) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068354);
		  /* 82068354h */ case    0:  		/* rlwinm R29, R11, 21, 31, 31 */
		/* 82068354h case    0:*/		cpu::op::rlwinm<0,21,31,31>(regs,&regs.R29,regs.R11);
		/* 82068354h case    0:*/		return 0x82068358;
		  /* 82068358h */ case    1:  		/* mulli R31, R10, 6 */
		/* 82068358h case    1:*/		cpu::op::mulli<0>(regs,&regs.R31,regs.R10,0x6);
		/* 82068358h case    1:*/		return 0x8206835C;
		  /* 8206835Ch */ case    2:  		/* b 148 */
		/* 8206835Ch case    2:*/		return 0x820683F0;
		/* 8206835Ch case    2:*/		return 0x82068360;
		  /* 82068360h */ case    3:  		/* cmpwi CR6, R19, 0 */
		/* 82068360h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R19,0x00000000);
		/* 82068360h case    3:*/		return 0x82068364;
		  /* 82068364h */ case    4:  		/* bc 12, CR6_LT, -192 */
		/* 82068364h case    4:*/		if ( regs.CR[6].lt ) { return 0x820682A4;  }
		/* 82068364h case    4:*/		return 0x82068368;
		  /* 82068368h */ case    5:  		/* lwzu R11, <#[R21 - 4]> */
		/* 82068368h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0xFFFFFFFC) );
		regs.R21 = (uint32)(regs.R21 + 0xFFFFFFFC);
		/* 82068368h case    5:*/		return 0x8206836C;
		  /* 8206836Ch */ case    6:  		/* addi R19, R19, -1 */
		/* 8206836Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R19,0xFFFFFFFF);
		/* 8206836Ch case    6:*/		return 0x82068370;
		  /* 82068370h */ case    7:  		/* rlwinm R31, R11, 0, 16, 31 */
		/* 82068370h case    7:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R31,regs.R11);
		/* 82068370h case    7:*/		return 0x82068374;
		  /* 82068374h */ case    8:  		/* rlwinm R29, R11, 16, 16, 31 */
		/* 82068374h case    8:*/		cpu::op::rlwinm<0,16,16,31>(regs,&regs.R29,regs.R11);
		/* 82068374h case    8:*/		return 0x82068378;
		  /* 82068378h */ case    9:  		/* b 120 */
		/* 82068378h case    9:*/		return 0x820683F0;
		/* 82068378h case    9:*/		return 0x8206837C;
		  /* 8206837Ch */ case   10:  		/* lwz R10, <#[R30]> */
		/* 8206837Ch case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 8206837Ch case   10:*/		return 0x82068380;
		  /* 82068380h */ case   11:  		/* rlwinm. R9, R10, 0, 18, 18 */
		/* 82068380h case   11:*/		cpu::op::rlwinm<1,0,18,18>(regs,&regs.R9,regs.R10);
		/* 82068380h case   11:*/		return 0x82068384;
		  /* 82068384h */ case   12:  		/* bc 4, CR0_EQ, -52 */
		/* 82068384h case   12:*/		if ( !regs.CR[0].eq ) { return 0x82068350;  }
		/* 82068384h case   12:*/		return 0x82068388;
		  /* 82068388h */ case   13:  		/* rlwinm. R9, R10, 0, 17, 17 */
		/* 82068388h case   13:*/		cpu::op::rlwinm<1,0,17,17>(regs,&regs.R9,regs.R10);
		/* 82068388h case   13:*/		return 0x8206838C;
		  /* 8206838Ch */ case   14:  		/* bc 4, CR0_EQ, 96 */
		/* 8206838Ch case   14:*/		if ( !regs.CR[0].eq ) { return 0x820683EC;  }
		/* 8206838Ch case   14:*/		return 0x82068390;
		  /* 82068390h */ case   15:  		/* rlwinm R9, R11, 27, 27, 29 */
		/* 82068390h case   15:*/		cpu::op::rlwinm<0,27,27,29>(regs,&regs.R9,regs.R11);
		/* 82068390h case   15:*/		return 0x82068394;
		  /* 82068394h */ case   16:  		/* rlwinm R7, R11, 30, 27, 31 */
		/* 82068394h case   16:*/		cpu::op::rlwinm<0,30,27,31>(regs,&regs.R7,regs.R11);
		/* 82068394h case   16:*/		return 0x82068398;
		  /* 82068398h */ case   17:  		/* rlwinm R6, R11, 22, 31, 31 */
		/* 82068398h case   17:*/		cpu::op::rlwinm<0,22,31,31>(regs,&regs.R6,regs.R11);
		/* 82068398h case   17:*/		return 0x8206839C;
		  /* 8206839Ch */ case   18:  		/* slw R7, R27, R7 */
		/* 8206839Ch case   18:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R27,regs.R7);
		/* 8206839Ch case   18:*/		return 0x820683A0;
		  /* 820683A0h */ case   19:  		/* lwzx R9, <#[R9 + R23]> */
		/* 820683A0h case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R23 + 0x00000000) );
		/* 820683A0h case   19:*/		return 0x820683A4;
		  /* 820683A4h */ case   20:  		/* and R9, R7, R9 */
		/* 820683A4h case   20:*/		cpu::op::and<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820683A4h case   20:*/		return 0x820683A8;
		  /* 820683A8h */ case   21:  		/* addic R7, R9, -1 */
		/* 820683A8h case   21:*/		cpu::op::addic<0>(regs,&regs.R7,regs.R9,0xFFFFFFFF);
		/* 820683A8h case   21:*/		return 0x820683AC;
		  /* 820683ACh */ case   22:  		/* subfe R9, R7, R9 */
		/* 820683ACh case   22:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 820683ACh case   22:*/		return 0x820683B0;
		  /* 820683B0h */ case   23:  		/* cmplw CR6, R9, R6 */
		/* 820683B0h case   23:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R6);
		/* 820683B0h case   23:*/		return 0x820683B4;
		  /* 820683B4h */ case   24:  		/* bc 4, CR6_EQ, 56 */
		/* 820683B4h case   24:*/		if ( !regs.CR[6].eq ) { return 0x820683EC;  }
		/* 820683B4h case   24:*/		return 0x820683B8;
		  /* 820683B8h */ case   25:  		/* b -104 */
		/* 820683B8h case   25:*/		return 0x82068350;
		/* 820683B8h case   25:*/		return 0x820683BC;
		  /* 820683BCh */ case   26:  		/* rlwinm R10, R11, 27, 27, 29 */
		/* 820683BCh case   26:*/		cpu::op::rlwinm<0,27,27,29>(regs,&regs.R10,regs.R11);
		/* 820683BCh case   26:*/		return 0x820683C0;
		  /* 820683C0h */ case   27:  		/* rlwinm R9, R11, 30, 27, 31 */
		/* 820683C0h case   27:*/		cpu::op::rlwinm<0,30,27,31>(regs,&regs.R9,regs.R11);
		/* 820683C0h case   27:*/		return 0x820683C4;
		  /* 820683C4h */ case   28:  		/* rlwinm R11, R11, 22, 31, 31 */
		/* 820683C4h case   28:*/		cpu::op::rlwinm<0,22,31,31>(regs,&regs.R11,regs.R11);
		/* 820683C4h case   28:*/		return 0x820683C8;
		  /* 820683C8h */ case   29:  		/* slw R9, R27, R9 */
		/* 820683C8h case   29:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R27,regs.R9);
		/* 820683C8h case   29:*/		return 0x820683CC;
		  /* 820683CCh */ case   30:  		/* lwzx R10, <#[R10 + R23]> */
		/* 820683CCh case   30:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R23 + 0x00000000) );
		/* 820683CCh case   30:*/		return 0x820683D0;
		  /* 820683D0h */ case   31:  		/* and R10, R9, R10 */
		/* 820683D0h case   31:*/		cpu::op::and<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 820683D0h case   31:*/		return 0x820683D4;
		  /* 820683D4h */ case   32:  		/* addic R9, R10, -1 */
		/* 820683D4h case   32:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R10,0xFFFFFFFF);
		/* 820683D4h case   32:*/		return 0x820683D8;
		  /* 820683D8h */ case   33:  		/* subfe R10, R9, R10 */
		/* 820683D8h case   33:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 820683D8h case   33:*/		return 0x820683DC;
		  /* 820683DCh */ case   34:  		/* cmplw CR6, R10, R11 */
		/* 820683DCh case   34:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 820683DCh case   34:*/		return 0x820683E0;
		  /* 820683E0h */ case   35:  		/* bc 4, CR6_EQ, 12 */
		/* 820683E0h case   35:*/		if ( !regs.CR[6].eq ) { return 0x820683EC;  }
		/* 820683E0h case   35:*/		return 0x820683E4;
		  /* 820683E4h */ case   36:  		/* mr R8, R27 */
		/* 820683E4h case   36:*/		regs.R8 = regs.R27;
		/* 820683E4h case   36:*/		return 0x820683E8;
		  /* 820683E8h */ case   37:  		/* mr R26, R27 */
		/* 820683E8h case   37:*/		regs.R26 = regs.R27;
		/* 820683E8h case   37:*/		return 0x820683EC;
	}
	return 0x820683EC;
} // Block from 82068354h-820683ECh (38 instructions)

//////////////////////////////////////////////////////
// Block at 820683ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820683EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820683EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820683EC);
		  /* 820683ECh */ case    0:  		/* addi R31, R31, 6 */
		/* 820683ECh case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x6);
		/* 820683ECh case    0:*/		return 0x820683F0;
	}
	return 0x820683F0;
} // Block from 820683ECh-820683F0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820683F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820683F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820683F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820683F0);
		  /* 820683F0h */ case    0:  		/* rlwinm. R11, R8, 0, 24, 31 */
		/* 820683F0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R8);
		/* 820683F0h case    0:*/		return 0x820683F4;
		  /* 820683F4h */ case    1:  		/* bc 12, CR0_EQ, 56 */
		/* 820683F4h case    1:*/		if ( regs.CR[0].eq ) { return 0x8206842C;  }
		/* 820683F4h case    1:*/		return 0x820683F8;
		  /* 820683F8h */ case    2:  		/* lwz R11, <#[R1 + 404]> */
		/* 820683F8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000194) );
		/* 820683F8h case    2:*/		return 0x820683FC;
		  /* 820683FCh */ case    3:  		/* mr R10, R20 */
		/* 820683FCh case    3:*/		regs.R10 = regs.R20;
		/* 820683FCh case    3:*/		return 0x82068400;
		  /* 82068400h */ case    4:  		/* mr R9, R22 */
		/* 82068400h case    4:*/		regs.R9 = regs.R22;
		/* 82068400h case    4:*/		return 0x82068404;
		  /* 82068404h */ case    5:  		/* mr R8, R16 */
		/* 82068404h case    5:*/		regs.R8 = regs.R16;
		/* 82068404h case    5:*/		return 0x82068408;
		  /* 82068408h */ case    6:  		/* mr R7, R17 */
		/* 82068408h case    6:*/		regs.R7 = regs.R17;
		/* 82068408h case    6:*/		return 0x8206840C;
		  /* 8206840Ch */ case    7:  		/* mr R6, R24 */
		/* 8206840Ch case    7:*/		regs.R6 = regs.R24;
		/* 8206840Ch case    7:*/		return 0x82068410;
		  /* 82068410h */ case    8:  		/* mr R5, R18 */
		/* 82068410h case    8:*/		regs.R5 = regs.R18;
		/* 82068410h case    8:*/		return 0x82068414;
		  /* 82068414h */ case    9:  		/* stw R11, <#[R1 + 84]> */
		/* 82068414h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82068414h case    9:*/		return 0x82068418;
		  /* 82068418h */ case   10:  		/* addi R4, R1, 96 */
		/* 82068418h case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 82068418h case   10:*/		return 0x8206841C;
		  /* 8206841Ch */ case   11:  		/* mr R3, R30 */
		/* 8206841Ch case   11:*/		regs.R3 = regs.R30;
		/* 8206841Ch case   11:*/		return 0x82068420;
		  /* 82068420h */ case   12:  		/* bl -1176 */
		/* 82068420h case   12:*/		regs.LR = 0x82068424; return 0x82067F88;
		/* 82068420h case   12:*/		return 0x82068424;
		  /* 82068424h */ case   13:  		/* cmpwi CR0, R3, 0 */
		/* 82068424h case   13:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82068424h case   13:*/		return 0x82068428;
		  /* 82068428h */ case   14:  		/* bc 12, CR0_LT, 72 */
		/* 82068428h case   14:*/		if ( regs.CR[0].lt ) { return 0x82068470;  }
		/* 82068428h case   14:*/		return 0x8206842C;
	}
	return 0x8206842C;
} // Block from 820683F0h-8206842Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8206842Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206842C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206842C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206842C);
		  /* 8206842Ch */ case    0:  		/* lwz R11, <#[R1 + 112]> */
		/* 8206842Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 8206842Ch case    0:*/		return 0x82068430;
		  /* 82068430h */ case    1:  		/* rlwinm. R10, R26, 0, 24, 31 */
		/* 82068430h case    1:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R26);
		/* 82068430h case    1:*/		return 0x82068434;
		  /* 82068434h */ case    2:  		/* stw R11, <#[R28]> */
		/* 82068434h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 82068434h case    2:*/		return 0x82068438;
		  /* 82068438h */ case    3:  		/* lwz R10, <#[R1 + 120]> */
		/* 82068438h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000078) );
		/* 82068438h case    3:*/		return 0x8206843C;
		  /* 8206843Ch */ case    4:  		/* lwz R11, <#[R1 + 116]> */
		/* 8206843Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000074) );
		/* 8206843Ch case    4:*/		return 0x82068440;
		  /* 82068440h */ case    5:  		/* rlwimi R11, R10, 16, 0, 15 */
		/* 82068440h case    5:*/		cpu::op::rlwimi<0,16,0,15>(regs,&regs.R11,regs.R10);
		/* 82068440h case    5:*/		return 0x82068444;
		  /* 82068444h */ case    6:  		/* stw R11, <#[R28 + 4]> */
		/* 82068444h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 82068444h case    6:*/		return 0x82068448;
		  /* 82068448h */ case    7:  		/* lwz R10, <#[R1 + 120]> */
		/* 82068448h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000078) );
		/* 82068448h case    7:*/		return 0x8206844C;
		  /* 8206844Ch */ case    8:  		/* rlwinm R10, R10, 16, 16, 31 */
		/* 8206844Ch case    8:*/		cpu::op::rlwinm<0,16,16,31>(regs,&regs.R10,regs.R10);
		/* 8206844Ch case    8:*/		return 0x82068450;
		  /* 82068450h */ case    9:  		/* lwz R11, <#[R1 + 124]> */
		/* 82068450h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000007C) );
		/* 82068450h case    9:*/		return 0x82068454;
		  /* 82068454h */ case   10:  		/* rlwinm R11, R11, 16, 0, 15 */
		/* 82068454h case   10:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R11,regs.R11);
		/* 82068454h case   10:*/		return 0x82068458;
		  /* 82068458h */ case   11:  		/* or R11, R11, R10 */
		/* 82068458h case   11:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82068458h case   11:*/		return 0x8206845C;
		  /* 8206845Ch */ case   12:  		/* stw R11, <#[R28 + 8]> */
		/* 8206845Ch case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 8206845Ch case   12:*/		return 0x82068460;
	}
	return 0x82068460;
} // Block from 8206842Ch-82068460h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82068460h
// Function '?Write@Microcode@CMicrocodeBuilder@D3D@@QAAJPAVSink@23@H@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068460( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068460) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068460);
		  /* 82068460h */ case    0:  		/* bc 12, CR0_EQ, -752 */
		/* 82068460h case    0:*/		if ( regs.CR[0].eq ) { return 0x82068170;  }
		/* 82068460h case    0:*/		return 0x82068464;
		  /* 82068464h */ case    1:  		/* b 12 */
		/* 82068464h case    1:*/		return 0x82068470;
		/* 82068464h case    1:*/		return 0x82068468;
	}
	return 0x82068468;
} // Block from 82068460h-82068468h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82068468h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068468( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068468) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068468);
		  /* 82068468h */ case    0:  		/* lis R3, -32768 */
		/* 82068468h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 82068468h case    0:*/		return 0x8206846C;
		  /* 8206846Ch */ case    1:  		/* ori R3, R3, 16389 */
		/* 8206846Ch case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 8206846Ch case    1:*/		return 0x82068470;
	}
	return 0x82068470;
} // Block from 82068468h-82068470h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82068470h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068470( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068470) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068470);
		  /* 82068470h */ case    0:  		/* addi R1, R1, 320 */
		/* 82068470h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x140);
		/* 82068470h case    0:*/		return 0x82068474;
		  /* 82068474h */ case    1:  		/* b 167420 */
		/* 82068474h case    1:*/		return 0x82091270;
		/* 82068474h case    1:*/		return 0x82068478;
	}
	return 0x82068478;
} // Block from 82068470h-82068478h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82068478h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068478( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068478) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068478);
		  /* 82068478h */ case    0:  		/* mfspr R12, LR */
		/* 82068478h case    0:*/		regs.R12 = regs.LR;
		/* 82068478h case    0:*/		return 0x8206847C;
		  /* 8206847Ch */ case    1:  		/* bl 167356 */
		/* 8206847Ch case    1:*/		regs.LR = 0x82068480; return 0x82091238;
		/* 8206847Ch case    1:*/		return 0x82068480;
		  /* 82068480h */ case    2:  		/* stwu R1, <#[R1 - 240]> */
		/* 82068480h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF10) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF10);
		/* 82068480h case    2:*/		return 0x82068484;
		  /* 82068484h */ case    3:  		/* mr R27, R3 */
		/* 82068484h case    3:*/		regs.R27 = regs.R3;
		/* 82068484h case    3:*/		return 0x82068488;
		  /* 82068488h */ case    4:  		/* mr R29, R4 */
		/* 82068488h case    4:*/		regs.R29 = regs.R4;
		/* 82068488h case    4:*/		return 0x8206848C;
		  /* 8206848Ch */ case    5:  		/* mr R23, R5 */
		/* 8206848Ch case    5:*/		regs.R23 = regs.R5;
		/* 8206848Ch case    5:*/		return 0x82068490;
		  /* 82068490h */ case    6:  		/* mr R22, R6 */
		/* 82068490h case    6:*/		regs.R22 = regs.R6;
		/* 82068490h case    6:*/		return 0x82068494;
		  /* 82068494h */ case    7:  		/* mr R30, R9 */
		/* 82068494h case    7:*/		regs.R30 = regs.R9;
		/* 82068494h case    7:*/		return 0x82068498;
		  /* 82068498h */ case    8:  		/* mr R28, R10 */
		/* 82068498h case    8:*/		regs.R28 = regs.R10;
		/* 82068498h case    8:*/		return 0x8206849C;
		  /* 8206849Ch */ case    9:  		/* rlwinm. R11, R9, 0, 28, 28 */
		/* 8206849Ch case    9:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R9);
		/* 8206849Ch case    9:*/		return 0x820684A0;
		  /* 820684A0h */ case   10:  		/* li R3, 0 */
		/* 820684A0h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820684A0h case   10:*/		return 0x820684A4;
		  /* 820684A4h */ case   11:  		/* bc 12, CR0_EQ, 24 */
		/* 820684A4h case   11:*/		if ( regs.CR[0].eq ) { return 0x820684BC;  }
		/* 820684A4h case   11:*/		return 0x820684A8;
		  /* 820684A8h */ case   12:  		/* lwz R11, <#[R1 + 324]> */
		/* 820684A8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000144) );
		/* 820684A8h case   12:*/		return 0x820684AC;
		  /* 820684ACh */ case   13:  		/* mr R3, R27 */
		/* 820684ACh case   13:*/		regs.R3 = regs.R27;
		/* 820684ACh case   13:*/		return 0x820684B0;
		  /* 820684B0h */ case   14:  		/* stw R11, <#[R1 + 84]> */
		/* 820684B0h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 820684B0h case   14:*/		return 0x820684B4;
		  /* 820684B4h */ case   15:  		/* bl -924 */
		/* 820684B4h case   15:*/		regs.LR = 0x820684B8; return 0x82068118;
		/* 820684B4h case   15:*/		return 0x820684B8;
		  /* 820684B8h */ case   16:  		/* b 300 */
		/* 820684B8h case   16:*/		return 0x820685E4;
		/* 820684B8h case   16:*/		return 0x820684BC;
	}
	return 0x820684BC;
} // Block from 82068478h-820684BCh (17 instructions)

//////////////////////////////////////////////////////
// Block at 820684BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820684BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820684BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820684BC);
		  /* 820684BCh */ case    0:  		/* stw R29, <#[R1 + 96]> */
		/* 820684BCh case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000060) );
		/* 820684BCh case    0:*/		return 0x820684C0;
		  /* 820684C0h */ case    1:  		/* mr R25, R27 */
		/* 820684C0h case    1:*/		regs.R25 = regs.R27;
		/* 820684C0h case    1:*/		return 0x820684C4;
		  /* 820684C4h */ case    2:  		/* li R21, 0 */
		/* 820684C4h case    2:*/		cpu::op::li<0>(regs,&regs.R21,0x0);
		/* 820684C4h case    2:*/		return 0x820684C8;
		  /* 820684C8h */ case    3:  		/* cmplwi CR6, R29, 0 */
		/* 820684C8h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820684C8h case    3:*/		return 0x820684CC;
		  /* 820684CCh */ case    4:  		/* bc 12, CR6_EQ, 280 */
		/* 820684CCh case    4:*/		if ( regs.CR[6].eq ) { return 0x820685E4;  }
		/* 820684CCh case    4:*/		return 0x820684D0;
		  /* 820684D0h */ case    5:  		/* lwz R24, <#[R1 + 324]> */
		/* 820684D0h case    5:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R1 + 0x00000144) );
		/* 820684D0h case    5:*/		return 0x820684D4;
		  /* 820684D4h */ case    6:  		/* rlwinm R20, R30, 0, 31, 31 */
		/* 820684D4h case    6:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R20,regs.R30);
		/* 820684D4h case    6:*/		return 0x820684D8;
		  /* 820684D8h */ case    7:  		/* lwz R11, <#[R25 + 4]> */
		/* 820684D8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 820684D8h case    7:*/		return 0x820684DC;
		  /* 820684DCh */ case    8:  		/* li R26, 0 */
		/* 820684DCh case    8:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 820684DCh case    8:*/		return 0x820684E0;
		  /* 820684E0h */ case    9:  		/* lwz R10, <#[R25 + 8]> */
		/* 820684E0h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000008) );
		/* 820684E0h case    9:*/		return 0x820684E4;
		  /* 820684E4h */ case   10:  		/* addi R31, R1, 112 */
		/* 820684E4h case   10:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0x70);
		/* 820684E4h case   10:*/		return 0x820684E8;
		  /* 820684E8h */ case   11:  		/* lwz R9, <#[R25]> */
		/* 820684E8h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + 0x00000000) );
		/* 820684E8h case   11:*/		return 0x820684EC;
		  /* 820684ECh */ case   12:  		/* rlwinm R8, R11, 16, 16, 31 */
		/* 820684ECh case   12:*/		cpu::op::rlwinm<0,16,16,31>(regs,&regs.R8,regs.R11);
		/* 820684ECh case   12:*/		return 0x820684F0;
		  /* 820684F0h */ case   13:  		/* rlwinm R7, R10, 16, 0, 15 */
		/* 820684F0h case   13:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R7,regs.R10);
		/* 820684F0h case   13:*/		return 0x820684F4;
		  /* 820684F4h */ case   14:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 820684F4h case   14:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 820684F4h case   14:*/		return 0x820684F8;
		  /* 820684F8h */ case   15:  		/* or R8, R7, R8 */
		/* 820684F8h case   15:*/		cpu::op::or<0>(regs,&regs.R8,regs.R7,regs.R8);
		/* 820684F8h case   15:*/		return 0x820684FC;
		  /* 820684FCh */ case   16:  		/* rlwinm R10, R10, 16, 16, 31 */
		/* 820684FCh case   16:*/		cpu::op::rlwinm<0,16,16,31>(regs,&regs.R10,regs.R10);
		/* 820684FCh case   16:*/		return 0x82068500;
		  /* 82068500h */ case   17:  		/* stw R11, <#[R1 + 116]> */
		/* 82068500h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000074) );
		/* 82068500h case   17:*/		return 0x82068504;
		  /* 82068504h */ case   18:  		/* stw R9, <#[R1 + 112]> */
		/* 82068504h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000070) );
		/* 82068504h case   18:*/		return 0x82068508;
		  /* 82068508h */ case   19:  		/* stw R8, <#[R1 + 120]> */
		/* 82068508h case   19:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000078) );
		/* 82068508h case   19:*/		return 0x8206850C;
		  /* 8206850Ch */ case   20:  		/* stw R10, <#[R1 + 124]> */
		/* 8206850Ch case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x0000007C) );
		/* 8206850Ch case   20:*/		return 0x82068510;
		  /* 82068510h */ case   21:  		/* cmplwi CR6, R20, 0 */
		/* 82068510h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000000);
		/* 82068510h case   21:*/		return 0x82068514;
		  /* 82068514h */ case   22:  		/* bc 12, CR6_EQ, 44 */
		/* 82068514h case   22:*/		if ( regs.CR[6].eq ) { return 0x82068540;  }
		/* 82068514h case   22:*/		return 0x82068518;
		  /* 82068518h */ case   23:  		/* li R11, 6 */
		/* 82068518h case   23:*/		cpu::op::li<0>(regs,&regs.R11,0x6);
		/* 82068518h case   23:*/		return 0x8206851C;
		  /* 8206851Ch */ case   24:  		/* mtspr CTR, R28 */
		/* 8206851Ch case   24:*/		regs.CTR = regs.R28;
		/* 8206851Ch case   24:*/		return 0x82068520;
		  /* 82068520h */ case   25:  		/* mr R6, R24 */
		/* 82068520h case   25:*/		regs.R6 = regs.R24;
		/* 82068520h case   25:*/		return 0x82068524;
		  /* 82068524h */ case   26:  		/* divwu R11, R21, R11 */
		/* 82068524h case   26:*/		cpu::op::divwu<0>(regs,&regs.R11,regs.R21,regs.R11);
		/* 82068524h case   26:*/		return 0x82068528;
		  /* 82068528h */ case   27:  		/* mr R5, R31 */
		/* 82068528h case   27:*/		regs.R5 = regs.R31;
		/* 82068528h case   27:*/		return 0x8206852C;
		  /* 8206852Ch */ case   28:  		/* add R4, R11, R26 */
		/* 8206852Ch case   28:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R26);
		/* 8206852Ch case   28:*/		return 0x82068530;
		  /* 82068530h */ case   29:  		/* li R3, 1 */
		/* 82068530h case   29:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82068530h case   29:*/		return 0x82068534;
		  /* 82068534h */ case   30:  		/* bcctrl 20, CR0_LT */
		/* 82068534h case   30:*/		if ( 1 ) { regs.LR = 0x82068538; return (uint32)regs.CTR; }
		/* 82068534h case   30:*/		return 0x82068538;
		  /* 82068538h */ case   31:  		/* cmpwi CR0, R3, 0 */
		/* 82068538h case   31:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82068538h case   31:*/		return 0x8206853C;
		  /* 8206853Ch */ case   32:  		/* bc 12, CR0_LT, 168 */
		/* 8206853Ch case   32:*/		if ( regs.CR[0].lt ) { return 0x820685E4;  }
		/* 8206853Ch case   32:*/		return 0x82068540;
	}
	return 0x82068540;
} // Block from 820684BCh-82068540h (33 instructions)

//////////////////////////////////////////////////////
// Block at 82068540h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068540( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068540) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068540);
		  /* 82068540h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 82068540h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82068540h case    0:*/		return 0x82068544;
		  /* 82068544h */ case    1:  		/* li R10, 1 */
		/* 82068544h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82068544h case    1:*/		return 0x82068548;
		  /* 82068548h */ case    2:  		/* rlwinm R11, R11, 20, 28, 31 */
		/* 82068548h case    2:*/		cpu::op::rlwinm<0,20,28,31>(regs,&regs.R11,regs.R11);
		/* 82068548h case    2:*/		return 0x8206854C;
		  /* 8206854Ch */ case    3:  		/* slw R11, R10, R11 */
		/* 8206854Ch case    3:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8206854Ch case    3:*/		return 0x82068550;
		  /* 82068550h */ case    4:  		/* andi. R11, R11, 24702 */
		/* 82068550h case    4:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x607E);
		/* 82068550h case    4:*/		return 0x82068554;
		  /* 82068554h */ case    5:  		/* cmplwi CR0, R11, 0 */
		/* 82068554h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82068554h case    5:*/		return 0x82068558;
		  /* 82068558h */ case    6:  		/* bc 12, CR0_EQ, 52 */
		/* 82068558h case    6:*/		if ( regs.CR[0].eq ) { return 0x8206858C;  }
		/* 82068558h case    6:*/		return 0x8206855C;
		  /* 8206855Ch */ case    7:  		/* mr R10, R28 */
		/* 8206855Ch case    7:*/		regs.R10 = regs.R28;
		/* 8206855Ch case    7:*/		return 0x82068560;
		  /* 82068560h */ case    8:  		/* stw R24, <#[R1 + 84]> */
		/* 82068560h case    8:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R1 + 0x00000054) );
		/* 82068560h case    8:*/		return 0x82068564;
		  /* 82068564h */ case    9:  		/* mr R9, R30 */
		/* 82068564h case    9:*/		regs.R9 = regs.R30;
		/* 82068564h case    9:*/		return 0x82068568;
		  /* 82068568h */ case   10:  		/* mr R8, R22 */
		/* 82068568h case   10:*/		regs.R8 = regs.R22;
		/* 82068568h case   10:*/		return 0x8206856C;
		  /* 8206856Ch */ case   11:  		/* mr R7, R23 */
		/* 8206856Ch case   11:*/		regs.R7 = regs.R23;
		/* 8206856Ch case   11:*/		return 0x82068570;
		  /* 82068570h */ case   12:  		/* mr R6, R29 */
		/* 82068570h case   12:*/		regs.R6 = regs.R29;
		/* 82068570h case   12:*/		return 0x82068574;
		  /* 82068574h */ case   13:  		/* mr R5, R27 */
		/* 82068574h case   13:*/		regs.R5 = regs.R27;
		/* 82068574h case   13:*/		return 0x82068578;
		  /* 82068578h */ case   14:  		/* addi R4, R1, 96 */
		/* 82068578h case   14:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 82068578h case   14:*/		return 0x8206857C;
		  /* 8206857Ch */ case   15:  		/* mr R3, R31 */
		/* 8206857Ch case   15:*/		regs.R3 = regs.R31;
		/* 8206857Ch case   15:*/		return 0x82068580;
		  /* 82068580h */ case   16:  		/* bl -1528 */
		/* 82068580h case   16:*/		regs.LR = 0x82068584; return 0x82067F88;
		/* 82068580h case   16:*/		return 0x82068584;
		  /* 82068584h */ case   17:  		/* cmpwi CR0, R3, 0 */
		/* 82068584h case   17:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82068584h case   17:*/		return 0x82068588;
		  /* 82068588h */ case   18:  		/* bc 12, CR0_LT, 92 */
		/* 82068588h case   18:*/		if ( regs.CR[0].lt ) { return 0x820685E4;  }
		/* 82068588h case   18:*/		return 0x8206858C;
	}
	return 0x8206858C;
} // Block from 82068540h-8206858Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 8206858Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206858C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206858C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206858C);
		  /* 8206858Ch */ case    0:  		/* addi R26, R26, 1 */
		/* 8206858Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 8206858Ch case    0:*/		return 0x82068590;
		  /* 82068590h */ case    1:  		/* addi R31, R31, 8 */
		/* 82068590h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x8);
		/* 82068590h case    1:*/		return 0x82068594;
		  /* 82068594h */ case    2:  		/* cmplwi CR6, R26, 2 */
		/* 82068594h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000002);
		/* 82068594h case    2:*/		return 0x82068598;
		  /* 82068598h */ case    3:  		/* bc 12, CR6_LT, -136 */
		/* 82068598h case    3:*/		if ( regs.CR[6].lt ) { return 0x82068510;  }
		/* 82068598h case    3:*/		return 0x8206859C;
		  /* 8206859Ch */ case    4:  		/* rlwinm. R11, R30, 0, 26, 26 */
		/* 8206859Ch case    4:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R30);
		/* 8206859Ch case    4:*/		return 0x820685A0;
		  /* 820685A0h */ case    5:  		/* bc 4, CR0_EQ, 48 */
		/* 820685A0h case    5:*/		if ( !regs.CR[0].eq ) { return 0x820685D0;  }
		/* 820685A0h case    5:*/		return 0x820685A4;
		  /* 820685A4h */ case    6:  		/* lwz R11, <#[R1 + 120]> */
		/* 820685A4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000078) );
		/* 820685A4h case    6:*/		return 0x820685A8;
		  /* 820685A8h */ case    7:  		/* lwz R10, <#[R1 + 116]> */
		/* 820685A8h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000074) );
		/* 820685A8h case    7:*/		return 0x820685AC;
		  /* 820685ACh */ case    8:  		/* lwz R9, <#[R1 + 124]> */
		/* 820685ACh case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x0000007C) );
		/* 820685ACh case    8:*/		return 0x820685B0;
		  /* 820685B0h */ case    9:  		/* rlwinm R8, R11, 16, 16, 31 */
		/* 820685B0h case    9:*/		cpu::op::rlwinm<0,16,16,31>(regs,&regs.R8,regs.R11);
		/* 820685B0h case    9:*/		return 0x820685B4;
		  /* 820685B4h */ case   10:  		/* rlwimi R10, R11, 16, 0, 15 */
		/* 820685B4h case   10:*/		cpu::op::rlwimi<0,16,0,15>(regs,&regs.R10,regs.R11);
		/* 820685B4h case   10:*/		return 0x820685B8;
		  /* 820685B8h */ case   11:  		/* lwz R7, <#[R1 + 112]> */
		/* 820685B8h case   11:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000070) );
		/* 820685B8h case   11:*/		return 0x820685BC;
		  /* 820685BCh */ case   12:  		/* rlwinm R11, R9, 16, 0, 15 */
		/* 820685BCh case   12:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R11,regs.R9);
		/* 820685BCh case   12:*/		return 0x820685C0;
		  /* 820685C0h */ case   13:  		/* stw R10, <#[R25 + 4]> */
		/* 820685C0h case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R25 + 0x00000004) );
		/* 820685C0h case   13:*/		return 0x820685C4;
		  /* 820685C4h */ case   14:  		/* or R11, R11, R8 */
		/* 820685C4h case   14:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 820685C4h case   14:*/		return 0x820685C8;
		  /* 820685C8h */ case   15:  		/* stw R7, <#[R25]> */
		/* 820685C8h case   15:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R25 + 0x00000000) );
		/* 820685C8h case   15:*/		return 0x820685CC;
		  /* 820685CCh */ case   16:  		/* stw R11, <#[R25 + 8]> */
		/* 820685CCh case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 820685CCh case   16:*/		return 0x820685D0;
	}
	return 0x820685D0;
} // Block from 8206858Ch-820685D0h (17 instructions)

//////////////////////////////////////////////////////
// Block at 820685D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820685D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820685D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820685D0);
		  /* 820685D0h */ case    0:  		/* lwz R11, <#[R1 + 96]> */
		/* 820685D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 820685D0h case    0:*/		return 0x820685D4;
		  /* 820685D4h */ case    1:  		/* addi R21, R21, 12 */
		/* 820685D4h case    1:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R21,0xC);
		/* 820685D4h case    1:*/		return 0x820685D8;
		  /* 820685D8h */ case    2:  		/* addi R25, R25, 12 */
		/* 820685D8h case    2:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0xC);
		/* 820685D8h case    2:*/		return 0x820685DC;
		  /* 820685DCh */ case    3:  		/* cmplw CR6, R21, R11 */
		/* 820685DCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R11);
		/* 820685DCh case    3:*/		return 0x820685E0;
		  /* 820685E0h */ case    4:  		/* bc 12, CR6_LT, -264 */
		/* 820685E0h case    4:*/		if ( regs.CR[6].lt ) { return 0x820684D8;  }
		/* 820685E0h case    4:*/		return 0x820685E4;
	}
	return 0x820685E4;
} // Block from 820685D0h-820685E4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 820685E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820685E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820685E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820685E4);
		  /* 820685E4h */ case    0:  		/* addi R1, R1, 240 */
		/* 820685E4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xF0);
		/* 820685E4h case    0:*/		return 0x820685E8;
		  /* 820685E8h */ case    1:  		/* b 167072 */
		/* 820685E8h case    1:*/		return 0x82091288;
		/* 820685E8h case    1:*/		return 0x820685EC;
		  /* 820685ECh */ case    2:  		/* nop */
		/* 820685ECh case    2:*/		cpu::op::nop();
		/* 820685ECh case    2:*/		return 0x820685F0;
	}
	return 0x820685F0;
} // Block from 820685E4h-820685F0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820685F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820685F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820685F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820685F0);
		  /* 820685F0h */ case    0:  		/* mfspr R12, LR */
		/* 820685F0h case    0:*/		regs.R12 = regs.LR;
		/* 820685F0h case    0:*/		return 0x820685F4;
		  /* 820685F4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820685F4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820685F4h case    1:*/		return 0x820685F8;
		  /* 820685F8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820685F8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820685F8h case    2:*/		return 0x820685FC;
		  /* 820685FCh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820685FCh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820685FCh case    3:*/		return 0x82068600;
		  /* 82068600h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82068600h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82068600h case    4:*/		return 0x82068604;
		  /* 82068604h */ case    5:  		/* lwz R11, <#[R3]> */
		/* 82068604h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82068604h case    5:*/		return 0x82068608;
		  /* 82068608h */ case    6:  		/* mr R30, R3 */
		/* 82068608h case    6:*/		regs.R30 = regs.R3;
		/* 82068608h case    6:*/		return 0x8206860C;
		  /* 8206860Ch */ case    7:  		/* mr R31, R4 */
		/* 8206860Ch case    7:*/		regs.R31 = regs.R4;
		/* 8206860Ch case    7:*/		return 0x82068610;
		  /* 82068610h */ case    8:  		/* cmplw CR6, R11, R4 */
		/* 82068610h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R4);
		/* 82068610h case    8:*/		return 0x82068614;
		  /* 82068614h */ case    9:  		/* bc 12, CR6_GT, 68 */
		/* 82068614h case    9:*/		if ( regs.CR[6].gt ) { return 0x82068658;  }
		/* 82068614h case    9:*/		return 0x82068618;
		  /* 82068618h */ case   10:  		/* lwz R10, <#[R3 + 4]> */
		/* 82068618h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 82068618h case   10:*/		return 0x8206861C;
		  /* 8206861Ch */ case   11:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8206861Ch case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8206861Ch case   11:*/		return 0x82068620;
		  /* 82068620h */ case   12:  		/* add R9, R10, R11 */
		/* 82068620h case   12:*/		cpu::op::add<0>(regs,&regs.R9,regs.R10,regs.R11);
		/* 82068620h case   12:*/		return 0x82068624;
		  /* 82068624h */ case   13:  		/* cmplw CR6, R4, R9 */
		/* 82068624h case   13:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R9);
		/* 82068624h case   13:*/		return 0x82068628;
		  /* 82068628h */ case   14:  		/* bc 4, CR6_LT, 48 */
		/* 82068628h case   14:*/		if ( !regs.CR[6].lt ) { return 0x82068658;  }
		/* 82068628h case   14:*/		return 0x8206862C;
		  /* 8206862Ch */ case   15:  		/* subf R10, R4, R10 */
		/* 8206862Ch case   15:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R4,regs.R10);
		/* 8206862Ch case   15:*/		return 0x82068630;
		  /* 82068630h */ case   16:  		/* addi R4, R4, 4 */
		/* 82068630h case   16:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x4);
		/* 82068630h case   16:*/		return 0x82068634;
		  /* 82068634h */ case   17:  		/* add R11, R10, R11 */
		/* 82068634h case   17:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82068634h case   17:*/		return 0x82068638;
		  /* 82068638h */ case   18:  		/* mr R3, R31 */
		/* 82068638h case   18:*/		regs.R3 = regs.R31;
		/* 82068638h case   18:*/		return 0x8206863C;
		  /* 8206863Ch */ case   19:  		/* addi R11, R11, -4 */
		/* 8206863Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 8206863Ch case   19:*/		return 0x82068640;
		  /* 82068640h */ case   20:  		/* srawi R11, R11, 2 */
		/* 82068640h case   20:*/		cpu::op::srawi<0,2>(regs,&regs.R11,regs.R11);
		/* 82068640h case   20:*/		return 0x82068644;
		  /* 82068644h */ case   21:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 82068644h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 82068644h case   21:*/		return 0x82068648;
		  /* 82068648h */ case   22:  		/* bl 170200 */
		/* 82068648h case   22:*/		regs.LR = 0x8206864C; return 0x82091F20;
		/* 82068648h case   22:*/		return 0x8206864C;
		  /* 8206864Ch */ case   23:  		/* lwz R11, <#[R30 + 4]> */
		/* 8206864Ch case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 8206864Ch case   23:*/		return 0x82068650;
		  /* 82068650h */ case   24:  		/* addi R11, R11, -1 */
		/* 82068650h case   24:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82068650h case   24:*/		return 0x82068654;
		  /* 82068654h */ case   25:  		/* stw R11, <#[R30 + 4]> */
		/* 82068654h case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 82068654h case   25:*/		return 0x82068658;
	}
	return 0x82068658;
} // Block from 820685F0h-82068658h (26 instructions)

//////////////////////////////////////////////////////
// Block at 82068658h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068658( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068658) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068658);
		  /* 82068658h */ case    0:  		/* mr R3, R31 */
		/* 82068658h case    0:*/		regs.R3 = regs.R31;
		/* 82068658h case    0:*/		return 0x8206865C;
		  /* 8206865Ch */ case    1:  		/* addi R1, R1, 112 */
		/* 8206865Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8206865Ch case    1:*/		return 0x82068660;
		  /* 82068660h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 82068660h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82068660h case    2:*/		return 0x82068664;
		  /* 82068664h */ case    3:  		/* mtspr LR, R12 */
		/* 82068664h case    3:*/		regs.LR = regs.R12;
		/* 82068664h case    3:*/		return 0x82068668;
		  /* 82068668h */ case    4:  		/* ld R30, <#[R1 - 24]> */
		/* 82068668h case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82068668h case    4:*/		return 0x8206866C;
		  /* 8206866Ch */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 8206866Ch case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206866Ch case    5:*/		return 0x82068670;
		  /* 82068670h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82068670h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82068670h case    6:*/		return 0x82068674;
	}
	return 0x82068674;
} // Block from 82068658h-82068674h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82068674h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068674( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068674) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068674);
		  /* 82068674h */ case    0:  		/* nop */
		/* 82068674h case    0:*/		cpu::op::nop();
		/* 82068674h case    0:*/		return 0x82068678;
		  /* 82068678h */ case    1:  		/* li R11, 0 */
		/* 82068678h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82068678h case    1:*/		return 0x8206867C;
		  /* 8206867Ch */ case    2:  		/* mr R10, R3 */
		/* 8206867Ch case    2:*/		regs.R10 = regs.R3;
		/* 8206867Ch case    2:*/		return 0x82068680;
		  /* 82068680h */ case    3:  		/* lwz R9, <#[R10]> */
		/* 82068680h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82068680h case    3:*/		return 0x82068684;
		  /* 82068684h */ case    4:  		/* cmplwi CR6, R9, 0 */
		/* 82068684h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82068684h case    4:*/		return 0x82068688;
		  /* 82068688h */ case    5:  		/* bc 4, CR6_EQ, 20 */
		/* 82068688h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8206869C;  }
		/* 82068688h case    5:*/		return 0x8206868C;
		  /* 8206868Ch */ case    6:  		/* addi R11, R11, 1 */
		/* 8206868Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8206868Ch case    6:*/		return 0x82068690;
		  /* 82068690h */ case    7:  		/* addi R10, R10, 4 */
		/* 82068690h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82068690h case    7:*/		return 0x82068694;
		  /* 82068694h */ case    8:  		/* cmplwi CR6, R11, 7 */
		/* 82068694h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000007);
		/* 82068694h case    8:*/		return 0x82068698;
		  /* 82068698h */ case    9:  		/* bc 12, CR6_LT, -24 */
		/* 82068698h case    9:*/		if ( regs.CR[6].lt ) { return 0x82068680;  }
		/* 82068698h case    9:*/		return 0x8206869C;
	}
	return 0x8206869C;
} // Block from 82068674h-8206869Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8206869Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206869C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206869C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206869C);
		  /* 8206869Ch */ case    0:  		/* rlwinm R11, R11, 5, 0, 26 */
		/* 8206869Ch case    0:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R11);
		/* 8206869Ch case    0:*/		return 0x820686A0;
		  /* 820686A0h */ case    1:  		/* b 36 */
		/* 820686A0h case    1:*/		return 0x820686C4;
		/* 820686A0h case    1:*/		return 0x820686A4;
		  /* 820686A4h */ case    2:  		/* rlwinm R10, R11, 29, 3, 29 */
		/* 820686A4h case    2:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R10,regs.R11);
		/* 820686A4h case    2:*/		return 0x820686A8;
		  /* 820686A8h */ case    3:  		/* rlwinm R9, R11, 0, 27, 31 */
		/* 820686A8h case    3:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R11);
		/* 820686A8h case    3:*/		return 0x820686AC;
		  /* 820686ACh */ case    4:  		/* li R8, 1 */
		/* 820686ACh case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820686ACh case    4:*/		return 0x820686B0;
		  /* 820686B0h */ case    5:  		/* slw R9, R8, R9 */
		/* 820686B0h case    5:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 820686B0h case    5:*/		return 0x820686B4;
		  /* 820686B4h */ case    6:  		/* lwzx R10, <#[R10 + R3]> */
		/* 820686B4h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 820686B4h case    6:*/		return 0x820686B8;
		  /* 820686B8h */ case    7:  		/* and. R10, R9, R10 */
		/* 820686B8h case    7:*/		cpu::op::and<1>(regs,&regs.R10,regs.R9,regs.R10);
		/* 820686B8h case    7:*/		return 0x820686BC;
		  /* 820686BCh */ case    8:  		/* bc 4, CR0_EQ, 16 */
		/* 820686BCh case    8:*/		if ( !regs.CR[0].eq ) { return 0x820686CC;  }
		/* 820686BCh case    8:*/		return 0x820686C0;
		  /* 820686C0h */ case    9:  		/* addi R11, R11, 1 */
		/* 820686C0h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 820686C0h case    9:*/		return 0x820686C4;
	}
	return 0x820686C4;
} // Block from 8206869Ch-820686C4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820686C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820686C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820686C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820686C4);
		  /* 820686C4h */ case    0:  		/* cmplwi CR6, R11, 256 */
		/* 820686C4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000100);
		/* 820686C4h case    0:*/		return 0x820686C8;
		  /* 820686C8h */ case    1:  		/* bc 12, CR6_LT, -36 */
		/* 820686C8h case    1:*/		if ( regs.CR[6].lt ) { return 0x820686A4;  }
		/* 820686C8h case    1:*/		return 0x820686CC;
	}
	return 0x820686CC;
} // Block from 820686C4h-820686CCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 820686CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820686CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820686CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820686CC);
		  /* 820686CCh */ case    0:  		/* mr R3, R11 */
		/* 820686CCh case    0:*/		regs.R3 = regs.R11;
		/* 820686CCh case    0:*/		return 0x820686D0;
		  /* 820686D0h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820686D0h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820686D0h case    1:*/		return 0x820686D4;
	}
	return 0x820686D4;
} // Block from 820686CCh-820686D4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820686D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820686D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820686D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820686D4);
		  /* 820686D4h */ case    0:  		/* nop */
		/* 820686D4h case    0:*/		cpu::op::nop();
		/* 820686D4h case    0:*/		return 0x820686D8;
	}
	return 0x820686D8;
} // Block from 820686D4h-820686D8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820686D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820686D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820686D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820686D8);
		  /* 820686D8h */ case    0:  		/* mfspr R12, LR */
		/* 820686D8h case    0:*/		regs.R12 = regs.LR;
		/* 820686D8h case    0:*/		return 0x820686DC;
		  /* 820686DCh */ case    1:  		/* bl 166736 */
		/* 820686DCh case    1:*/		regs.LR = 0x820686E0; return 0x8209122C;
		/* 820686DCh case    1:*/		return 0x820686E0;
		  /* 820686E0h */ case    2:  		/* stwu R1, <#[R1 - 208]> */
		/* 820686E0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 820686E0h case    2:*/		return 0x820686E4;
		  /* 820686E4h */ case    3:  		/* addi R11, R4, -4 */
		/* 820686E4h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0xFFFFFFFC);
		/* 820686E4h case    3:*/		return 0x820686E8;
		  /* 820686E8h */ case    4:  		/* lis R10, -16384 */
		/* 820686E8h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFC000);
		/* 820686E8h case    4:*/		return 0x820686EC;
		  /* 820686ECh */ case    5:  		/* li R9, 768 */
		/* 820686ECh case    5:*/		cpu::op::li<0>(regs,&regs.R9,0x300);
		/* 820686ECh case    5:*/		return 0x820686F0;
		  /* 820686F0h */ case    6:  		/* ori R10, R10, 15104 */
		/* 820686F0h case    6:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x3B00);
		/* 820686F0h case    6:*/		return 0x820686F4;
		  /* 820686F4h */ case    7:  		/* lis R8, -16359 */
		/* 820686F4h case    7:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFFC019);
		/* 820686F4h case    7:*/		return 0x820686F8;
		  /* 820686F8h */ case    8:  		/* stwu R10, <#[R11 + 4]> */
		/* 820686F8h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820686F8h case    8:*/		return 0x820686FC;
		  /* 820686FCh */ case    9:  		/* li R10, 0 */
		/* 820686FCh case    9:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820686FCh case    9:*/		return 0x82068700;
		  /* 82068700h */ case   10:  		/* ori R8, R8, 11008 */
		/* 82068700h case   10:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x2B00);
		/* 82068700h case   10:*/		return 0x82068704;
		  /* 82068704h */ case   11:  		/* li R7, 24 */
		/* 82068704h case   11:*/		cpu::op::li<0>(regs,&regs.R7,0x18);
		/* 82068704h case   11:*/		return 0x82068708;
		  /* 82068708h */ case   12:  		/* lis R6, -32256 */
		/* 82068708h case   12:*/		cpu::op::lis<0>(regs,&regs.R6,0xFFFF8200);
		/* 82068708h case   12:*/		return 0x8206870C;
		  /* 8206870Ch */ case   13:  		/* mr R31, R4 */
		/* 8206870Ch case   13:*/		regs.R31 = regs.R4;
		/* 8206870Ch case   13:*/		return 0x82068710;
		  /* 82068710h */ case   14:  		/* stwu R9, <#[R11 + 4]> */
		/* 82068710h case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82068710h case   14:*/		return 0x82068714;
		  /* 82068714h */ case   15:  		/* addi R29, R6, 3120 */
		/* 82068714h case   15:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R6,0xC30);
		/* 82068714h case   15:*/		return 0x82068718;
		  /* 82068718h */ case   16:  		/* li R5, 96 */
		/* 82068718h case   16:*/		cpu::op::li<0>(regs,&regs.R5,0x60);
		/* 82068718h case   16:*/		return 0x8206871C;
		  /* 8206871Ch */ case   17:  		/* mr R4, R29 */
		/* 8206871Ch case   17:*/		regs.R4 = regs.R29;
		/* 8206871Ch case   17:*/		return 0x82068720;
		  /* 82068720h */ case   18:  		/* stwu R8, <#[R11 + 4]> */
		/* 82068720h case   18:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82068720h case   18:*/		return 0x82068724;
		  /* 82068724h */ case   19:  		/* stwu R10, <#[R11 + 4]> */
		/* 82068724h case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82068724h case   19:*/		return 0x82068728;
		  /* 82068728h */ case   20:  		/* mr R30, R11 */
		/* 82068728h case   20:*/		regs.R30 = regs.R11;
		/* 82068728h case   20:*/		return 0x8206872C;
		  /* 8206872Ch */ case   21:  		/* stwu R7, <#[R30 + 4]> */
		/* 8206872Ch case   21:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 8206872Ch case   21:*/		return 0x82068730;
		  /* 82068730h */ case   22:  		/* addi R3, R30, 4 */
		/* 82068730h case   22:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R30,0x4);
		/* 82068730h case   22:*/		return 0x82068734;
		  /* 82068734h */ case   23:  		/* bl 168572 */
		/* 82068734h case   23:*/		regs.LR = 0x82068738; return 0x820919B0;
		/* 82068734h case   23:*/		return 0x82068738;
		  /* 82068738h */ case   24:  		/* addi R11, R30, 96 */
		/* 82068738h case   24:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x60);
		/* 82068738h case   24:*/		return 0x8206873C;
		  /* 8206873Ch */ case   25:  		/* lis R10, -16374 */
		/* 8206873Ch case   25:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFC00A);
		/* 8206873Ch case   25:*/		return 0x82068740;
		  /* 82068740h */ case   26:  		/* li R9, 1 */
		/* 82068740h case   26:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82068740h case   26:*/		return 0x82068744;
		  /* 82068744h */ case   27:  		/* ori R10, R10, 11008 */
		/* 82068744h case   27:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x2B00);
		/* 82068744h case   27:*/		return 0x82068748;
		  /* 82068748h */ case   28:  		/* li R8, 9 */
		/* 82068748h case   28:*/		cpu::op::li<0>(regs,&regs.R8,0x9);
		/* 82068748h case   28:*/		return 0x8206874C;
		  /* 8206874Ch */ case   29:  		/* stwu R10, <#[R11 + 4]> */
		/* 8206874Ch case   29:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206874Ch case   29:*/		return 0x82068750;
		  /* 82068750h */ case   30:  		/* addi R4, R29, 96 */
		/* 82068750h case   30:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R29,0x60);
		/* 82068750h case   30:*/		return 0x82068754;
		  /* 82068754h */ case   31:  		/* li R5, 36 */
		/* 82068754h case   31:*/		cpu::op::li<0>(regs,&regs.R5,0x24);
		/* 82068754h case   31:*/		return 0x82068758;
		  /* 82068758h */ case   32:  		/* stwu R9, <#[R11 + 4]> */
		/* 82068758h case   32:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82068758h case   32:*/		return 0x8206875C;
		  /* 8206875Ch */ case   33:  		/* mr R30, R11 */
		/* 8206875Ch case   33:*/		regs.R30 = regs.R11;
		/* 8206875Ch case   33:*/		return 0x82068760;
		  /* 82068760h */ case   34:  		/* stwu R8, <#[R30 + 4]> */
		/* 82068760h case   34:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 82068760h case   34:*/		return 0x82068764;
		  /* 82068764h */ case   35:  		/* addi R3, R30, 4 */
		/* 82068764h case   35:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R30,0x4);
		/* 82068764h case   35:*/		return 0x82068768;
		  /* 82068768h */ case   36:  		/* bl 168520 */
		/* 82068768h case   36:*/		regs.LR = 0x8206876C; return 0x820919B0;
		/* 82068768h case   36:*/		return 0x8206876C;
		  /* 8206876Ch */ case   37:  		/* addi R11, R30, 36 */
		/* 8206876Ch case   37:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x24);
		/* 8206876Ch case   37:*/		return 0x82068770;
		  /* 82068770h */ case   38:  		/* lis R10, 1 */
		/* 82068770h case   38:*/		cpu::op::lis<0>(regs,&regs.R10,0x1);
		/* 82068770h case   38:*/		return 0x82068774;
		  /* 82068774h */ case   39:  		/* lis R9, 4096 */
		/* 82068774h case   39:*/		cpu::op::lis<0>(regs,&regs.R9,0x1000);
		/* 82068774h case   39:*/		return 0x82068778;
		  /* 82068778h */ case   40:  		/* ori R10, R10, 8576 */
		/* 82068778h case   40:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x2180);
		/* 82068778h case   40:*/		return 0x8206877C;
		  /* 8206877Ch */ case   41:  		/* ori R9, R9, 14 */
		/* 8206877Ch case   41:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0xE);
		/* 8206877Ch case   41:*/		return 0x82068780;
		  /* 82068780h */ case   42:  		/* stwu R10, <#[R11 + 4]> */
		/* 82068780h case   42:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82068780h case   42:*/		return 0x82068784;
		  /* 82068784h */ case   43:  		/* li R10, 0 */
		/* 82068784h case   43:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82068784h case   43:*/		return 0x82068788;
		  /* 82068788h */ case   44:  		/* lis R8, 2 */
		/* 82068788h case   44:*/		cpu::op::lis<0>(regs,&regs.R8,0x2);
		/* 82068788h case   44:*/		return 0x8206878C;
		  /* 8206878Ch */ case   45:  		/* lis R7, 0 */
		/* 8206878Ch case   45:*/		cpu::op::lis<0>(regs,&regs.R7,0x0);
		/* 8206878Ch case   45:*/		return 0x82068790;
		  /* 82068790h */ case   46:  		/* ori R8, R8, 8448 */
		/* 82068790h case   46:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x2100);
		/* 82068790h case   46:*/		return 0x82068794;
		  /* 82068794h */ case   47:  		/* ori R7, R7, 65535 */
		/* 82068794h case   47:*/		cpu::op::ori<0>(regs,&regs.R7,regs.R7,0xFFFF);
		/* 82068794h case   47:*/		return 0x82068798;
		  /* 82068798h */ case   48:  		/* stwu R9, <#[R11 + 4]> */
		/* 82068798h case   48:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82068798h case   48:*/		return 0x8206879C;
		  /* 8206879Ch */ case   49:  		/* li R6, 0 */
		/* 8206879Ch case   49:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8206879Ch case   49:*/		return 0x820687A0;
		  /* 820687A0h */ case   50:  		/* li R9, 0 */
		/* 820687A0h case   50:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 820687A0h case   50:*/		return 0x820687A4;
		  /* 820687A4h */ case   51:  		/* li R5, 8851 */
		/* 820687A4h case   51:*/		cpu::op::li<0>(regs,&regs.R5,0x2293);
		/* 820687A4h case   51:*/		return 0x820687A8;
		  /* 820687A8h */ case   52:  		/* li R4, 0 */
		/* 820687A8h case   52:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820687A8h case   52:*/		return 0x820687AC;
		  /* 820687ACh */ case   53:  		/* lis R3, 2 */
		/* 820687ACh case   53:*/		cpu::op::lis<0>(regs,&regs.R3,0x2);
		/* 820687ACh case   53:*/		return 0x820687B0;
		  /* 820687B0h */ case   54:  		/* stwu R10, <#[R11 + 4]> */
		/* 820687B0h case   54:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820687B0h case   54:*/		return 0x820687B4;
		  /* 820687B4h */ case   55:  		/* lis R30, 0 */
		/* 820687B4h case   55:*/		cpu::op::lis<0>(regs,&regs.R30,0x0);
		/* 820687B4h case   55:*/		return 0x820687B8;
		  /* 820687B8h */ case   56:  		/* ori R3, R3, 8708 */
		/* 820687B8h case   56:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x2204);
		/* 820687B8h case   56:*/		return 0x820687BC;
		  /* 820687BCh */ case   57:  		/* lis R10, 1 */
		/* 820687BCh case   57:*/		cpu::op::lis<0>(regs,&regs.R10,0x1);
		/* 820687BCh case   57:*/		return 0x820687C0;
		  /* 820687C0h */ case   58:  		/* lis R22, 8 */
		/* 820687C0h case   58:*/		cpu::op::lis<0>(regs,&regs.R22,0x8);
		/* 820687C0h case   58:*/		return 0x820687C4;
		  /* 820687C4h */ case   59:  		/* lis R29, 1 */
		/* 820687C4h case   59:*/		cpu::op::lis<0>(regs,&regs.R29,0x1);
		/* 820687C4h case   59:*/		return 0x820687C8;
		  /* 820687C8h */ case   60:  		/* stwu R8, <#[R11 + 4]> */
		/* 820687C8h case   60:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820687C8h case   60:*/		return 0x820687CC;
		  /* 820687CCh */ case   61:  		/* li R28, 768 */
		/* 820687CCh case   61:*/		cpu::op::li<0>(regs,&regs.R28,0x300);
		/* 820687CCh case   61:*/		return 0x820687D0;
		  /* 820687D0h */ case   62:  		/* li R27, 8978 */
		/* 820687D0h case   62:*/		cpu::op::li<0>(regs,&regs.R27,0x2312);
		/* 820687D0h case   62:*/		return 0x820687D4;
		  /* 820687D4h */ case   63:  		/* ori R30, R30, 65535 */
		/* 820687D4h case   63:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R30,0xFFFF);
		/* 820687D4h case   63:*/		return 0x820687D8;
		  /* 820687D8h */ case   64:  		/* li R26, 8205 */
		/* 820687D8h case   64:*/		cpu::op::li<0>(regs,&regs.R26,0x200D);
		/* 820687D8h case   64:*/		return 0x820687DC;
		  /* 820687DCh */ case   65:  		/* li R8, 0 */
		/* 820687DCh case   65:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 820687DCh case   65:*/		return 0x820687E0;
		  /* 820687E0h */ case   66:  		/* stwu R7, <#[R11 + 4]> */
		/* 820687E0h case   66:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820687E0h case   66:*/		return 0x820687E4;
		  /* 820687E4h */ case   67:  		/* li R25, 8704 */
		/* 820687E4h case   67:*/		cpu::op::li<0>(regs,&regs.R25,0x2200);
		/* 820687E4h case   67:*/		return 0x820687E8;
		  /* 820687E8h */ case   68:  		/* li R24, 0 */
		/* 820687E8h case   68:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 820687E8h case   68:*/		return 0x820687EC;
		  /* 820687ECh */ case   69:  		/* li R7, 0 */
		/* 820687ECh case   69:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 820687ECh case   69:*/		return 0x820687F0;
		  /* 820687F0h */ case   70:  		/* li R23, 8832 */
		/* 820687F0h case   70:*/		cpu::op::li<0>(regs,&regs.R23,0x2280);
		/* 820687F0h case   70:*/		return 0x820687F4;
		  /* 820687F4h */ case   71:  		/* li R21, 8962 */
		/* 820687F4h case   71:*/		cpu::op::li<0>(regs,&regs.R21,0x2302);
		/* 820687F4h case   71:*/		return 0x820687F8;
		  /* 820687F8h */ case   72:  		/* stwu R6, <#[R11 + 4]> */
		/* 820687F8h case   72:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820687F8h case   72:*/		return 0x820687FC;
		  /* 820687FCh */ case   73:  		/* li R6, 8712 */
		/* 820687FCh case   73:*/		cpu::op::li<0>(regs,&regs.R6,0x2208);
		/* 820687FCh case   73:*/		return 0x82068800;
		  /* 82068800h */ case   74:  		/* ori R22, R22, 8 */
		/* 82068800h case   74:*/		cpu::op::ori<0>(regs,&regs.R22,regs.R22,0x8);
		/* 82068800h case   74:*/		return 0x82068804;
		  /* 82068804h */ case   75:  		/* stwu R9, <#[R11 + 4]> */
		/* 82068804h case   75:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82068804h case   75:*/		return 0x82068808;
		  /* 82068808h */ case   76:  		/* li R9, 8707 */
		/* 82068808h case   76:*/		cpu::op::li<0>(regs,&regs.R9,0x2203);
		/* 82068808h case   76:*/		return 0x8206880C;
		  /* 8206880Ch */ case   77:  		/* stwu R5, <#[R11 + 4]> */
		/* 8206880Ch case   77:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206880Ch case   77:*/		return 0x82068810;
		  /* 82068810h */ case   78:  		/* li R5, 4 */
		/* 82068810h case   78:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 82068810h case   78:*/		return 0x82068814;
		  /* 82068814h */ case   79:  		/* stwu R4, <#[R11 + 4]> */
		/* 82068814h case   79:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82068814h case   79:*/		return 0x82068818;
		  /* 82068818h */ case   80:  		/* li R4, 8452 */
		/* 82068818h case   80:*/		cpu::op::li<0>(regs,&regs.R4,0x2104);
		/* 82068818h case   80:*/		return 0x8206881C;
		  /* 8206881Ch */ case   81:  		/* stwu R3, <#[R11 + 4]> */
		/* 8206881Ch case   81:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206881Ch case   81:*/		return 0x82068820;
		  /* 82068820h */ case   82:  		/* li R3, 0 */
		/* 82068820h case   82:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82068820h case   82:*/		return 0x82068824;
		  /* 82068824h */ case   83:  		/* stwu R10, <#[R11 + 4]> */
		/* 82068824h case   83:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82068824h case   83:*/		return 0x82068828;
		  /* 82068828h */ case   84:  		/* stwu R29, <#[R11 + 4]> */
		/* 82068828h case   84:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82068828h case   84:*/		return 0x8206882C;
		  /* 8206882Ch */ case   85:  		/* li R10, 4 */
		/* 8206882Ch case   85:*/		cpu::op::li<0>(regs,&regs.R10,0x4);
		/* 8206882Ch case   85:*/		return 0x82068830;
		  /* 82068830h */ case   86:  		/* lis R20, 2 */
		/* 82068830h case   86:*/		cpu::op::lis<0>(regs,&regs.R20,0x2);
		/* 82068830h case   86:*/		return 0x82068834;
		  /* 82068834h */ case   87:  		/* li R19, 0 */
		/* 82068834h case   87:*/		cpu::op::li<0>(regs,&regs.R19,0x0);
		/* 82068834h case   87:*/		return 0x82068838;
		  /* 82068838h */ case   88:  		/* ori R20, R20, 8320 */
		/* 82068838h case   88:*/		cpu::op::ori<0>(regs,&regs.R20,regs.R20,0x2080);
		/* 82068838h case   88:*/		return 0x8206883C;
		  /* 8206883Ch */ case   89:  		/* li R18, 0 */
		/* 8206883Ch case   89:*/		cpu::op::li<0>(regs,&regs.R18,0x0);
		/* 8206883Ch case   89:*/		return 0x82068840;
		  /* 82068840h */ case   90:  		/* stwu R28, <#[R11 + 4]> */
		/* 82068840h case   90:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82068840h case   90:*/		return 0x82068844;
		  /* 82068844h */ case   91:  		/* lis R17, 16 */
		/* 82068844h case   91:*/		cpu::op::lis<0>(regs,&regs.R17,0x10);
		/* 82068844h case   91:*/		return 0x82068848;
		  /* 82068848h */ case   92:  		/* ori R29, R17, 16 */
		/* 82068848h case   92:*/		cpu::op::ori<0>(regs,&regs.R29,regs.R17,0x10);
		/* 82068848h case   92:*/		return 0x8206884C;
		  /* 8206884Ch */ case   93:  		/* stwu R27, <#[R11 + 4]> */
		/* 8206884Ch case   93:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206884Ch case   93:*/		return 0x82068850;
		  /* 82068850h */ case   94:  		/* stwu R30, <#[R11 + 4]> */
		/* 82068850h case   94:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82068850h case   94:*/		return 0x82068854;
		  /* 82068854h */ case   95:  		/* stwu R26, <#[R11 + 4]> */
		/* 82068854h case   95:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82068854h case   95:*/		return 0x82068858;
		  /* 82068858h */ case   96:  		/* stwu R8, <#[R11 + 4]> */
		/* 82068858h case   96:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82068858h case   96:*/		return 0x8206885C;
		  /* 8206885Ch */ case   97:  		/* stwu R25, <#[R11 + 4]> */
		/* 8206885Ch case   97:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206885Ch case   97:*/		return 0x82068860;
		  /* 82068860h */ case   98:  		/* stwu R24, <#[R11 + 4]> */
		/* 82068860h case   98:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82068860h case   98:*/		return 0x82068864;
		  /* 82068864h */ case   99:  		/* stwu R9, <#[R11 + 4]> */
		/* 82068864h case   99:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82068864h case   99:*/		return 0x82068868;
		  /* 82068868h */ case  100:  		/* stwu R7, <#[R11 + 4]> */
		/* 82068868h case  100:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82068868h case  100:*/		return 0x8206886C;
		  /* 8206886Ch */ case  101:  		/* stwu R6, <#[R11 + 4]> */
		/* 8206886Ch case  101:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206886Ch case  101:*/		return 0x82068870;
		  /* 82068870h */ case  102:  		/* stwu R5, <#[R11 + 4]> */
		/* 82068870h case  102:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82068870h case  102:*/		return 0x82068874;
		  /* 82068874h */ case  103:  		/* stwu R4, <#[R11 + 4]> */
		/* 82068874h case  103:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82068874h case  103:*/		return 0x82068878;
		  /* 82068878h */ case  104:  		/* stwu R3, <#[R11 + 4]> */
		/* 82068878h case  104:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82068878h case  104:*/		return 0x8206887C;
		  /* 8206887Ch */ case  105:  		/* stwu R23, <#[R11 + 4]> */
		/* 8206887Ch case  105:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206887Ch case  105:*/		return 0x82068880;
		  /* 82068880h */ case  106:  		/* stwu R22, <#[R11 + 4]> */
		/* 82068880h case  106:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82068880h case  106:*/		return 0x82068884;
		  /* 82068884h */ case  107:  		/* stwu R21, <#[R11 + 4]> */
		/* 82068884h case  107:*/		cpu::mem::store32( regs, regs.R21, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82068884h case  107:*/		return 0x82068888;
		  /* 82068888h */ case  108:  		/* stwu R10, <#[R11 + 4]> */
		/* 82068888h case  108:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82068888h case  108:*/		return 0x8206888C;
		  /* 8206888Ch */ case  109:  		/* stwu R20, <#[R11 + 4]> */
		/* 8206888Ch case  109:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206888Ch case  109:*/		return 0x82068890;
		  /* 82068890h */ case  110:  		/* stwu R19, <#[R11 + 4]> */
		/* 82068890h case  110:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82068890h case  110:*/		return 0x82068894;
		  /* 82068894h */ case  111:  		/* stwu R18, <#[R11 + 4]> */
		/* 82068894h case  111:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82068894h case  111:*/		return 0x82068898;
		  /* 82068898h */ case  112:  		/* stwu R29, <#[R11 + 4]> */
		/* 82068898h case  112:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82068898h case  112:*/		return 0x8206889C;
		  /* 8206889Ch */ case  113:  		/* subf R11, R31, R11 */
		/* 8206889Ch case  113:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R31,regs.R11);
		/* 8206889Ch case  113:*/		return 0x820688A0;
		  /* 820688A0h */ case  114:  		/* addi R11, R11, 4 */
		/* 820688A0h case  114:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 820688A0h case  114:*/		return 0x820688A4;
		  /* 820688A4h */ case  115:  		/* srawi R3, R11, 2 */
		/* 820688A4h case  115:*/		cpu::op::srawi<0,2>(regs,&regs.R3,regs.R11);
		/* 820688A4h case  115:*/		return 0x820688A8;
		  /* 820688A8h */ case  116:  		/* addi R1, R1, 208 */
		/* 820688A8h case  116:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 820688A8h case  116:*/		return 0x820688AC;
		  /* 820688ACh */ case  117:  		/* b 166352 */
		/* 820688ACh case  117:*/		return 0x8209127C;
		/* 820688ACh case  117:*/		return 0x820688B0;
		  /* 820688B0h */ case  118:  		/* li R12, 1 */
		/* 820688B0h case  118:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 820688B0h case  118:*/		return 0x820688B4;
		  /* 820688B4h */ case  119:  		/* ld R11, <#[R3 + 16]> */
		/* 820688B4h case  119:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 820688B4h case  119:*/		return 0x820688B8;
		  /* 820688B8h */ case  120:  		/* li R10, 1 */
		/* 820688B8h case  120:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820688B8h case  120:*/		return 0x820688BC;
		  /* 820688BCh */ case  121:  		/* rldicr R12, R12, 41, 63 */
		/* 820688BCh case  121:*/		cpu::op::rldicr<0,41,63>(regs,&regs.R12,regs.R12);
		/* 820688BCh case  121:*/		return 0x820688C0;
		  /* 820688C0h */ case  122:  		/* or R9, R11, R12 */
		/* 820688C0h case  122:*/		cpu::op::or<0>(regs,&regs.R9,regs.R11,regs.R12);
		/* 820688C0h case  122:*/		return 0x820688C4;
		  /* 820688C4h */ case  123:  		/* li R12, 1 */
		/* 820688C4h case  123:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 820688C4h case  123:*/		return 0x820688C8;
		  /* 820688C8h */ case  124:  		/* rldicr R11, R10, 35, 63 */
		/* 820688C8h case  124:*/		cpu::op::rldicr<0,35,63>(regs,&regs.R11,regs.R10);
		/* 820688C8h case  124:*/		return 0x820688CC;
		  /* 820688CCh */ case  125:  		/* std R9, <#[R3 + 16]> */
		/* 820688CCh case  125:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R3 + 0x00000010) );
		/* 820688CCh case  125:*/		return 0x820688D0;
		  /* 820688D0h */ case  126:  		/* rldicr R12, R12, 40, 63 */
		/* 820688D0h case  126:*/		cpu::op::rldicr<0,40,63>(regs,&regs.R12,regs.R12);
		/* 820688D0h case  126:*/		return 0x820688D4;
		  /* 820688D4h */ case  127:  		/* mr R10, R9 */
		/* 820688D4h case  127:*/		regs.R10 = regs.R9;
		/* 820688D4h case  127:*/		return 0x820688D8;
		  /* 820688D8h */ case  128:  		/* or R10, R10, R12 */
		/* 820688D8h case  128:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R12);
		/* 820688D8h case  128:*/		return 0x820688DC;
		  /* 820688DCh */ case  129:  		/* li R12, 1 */
		/* 820688DCh case  129:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 820688DCh case  129:*/		return 0x820688E0;
		  /* 820688E0h */ case  130:  		/* std R10, <#[R3 + 16]> */
		/* 820688E0h case  130:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 820688E0h case  130:*/		return 0x820688E4;
		  /* 820688E4h */ case  131:  		/* rldicr R12, R12, 39, 63 */
		/* 820688E4h case  131:*/		cpu::op::rldicr<0,39,63>(regs,&regs.R12,regs.R12);
		/* 820688E4h case  131:*/		return 0x820688E8;
		  /* 820688E8h */ case  132:  		/* or R10, R10, R12 */
		/* 820688E8h case  132:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R12);
		/* 820688E8h case  132:*/		return 0x820688EC;
		  /* 820688ECh */ case  133:  		/* li R12, 1 */
		/* 820688ECh case  133:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 820688ECh case  133:*/		return 0x820688F0;
		  /* 820688F0h */ case  134:  		/* std R10, <#[R3 + 16]> */
		/* 820688F0h case  134:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 820688F0h case  134:*/		return 0x820688F4;
		  /* 820688F4h */ case  135:  		/* ld R10, <#[R3 + 24]> */
		/* 820688F4h case  135:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R3 + 0x00000018) );
		/* 820688F4h case  135:*/		return 0x820688F8;
		  /* 820688F8h */ case  136:  		/* or R10, R10, R11 */
		/* 820688F8h case  136:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 820688F8h case  136:*/		return 0x820688FC;
		  /* 820688FCh */ case  137:  		/* std R10, <#[R3 + 24]> */
		/* 820688FCh case  137:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R3 + 0x00000018) );
		/* 820688FCh case  137:*/		return 0x82068900;
		  /* 82068900h */ case  138:  		/* rldicr R12, R12, 44, 63 */
		/* 82068900h case  138:*/		cpu::op::rldicr<0,44,63>(regs,&regs.R12,regs.R12);
		/* 82068900h case  138:*/		return 0x82068904;
		  /* 82068904h */ case  139:  		/* ld R10, <#[R3 + 16]> */
		/* 82068904h case  139:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 82068904h case  139:*/		return 0x82068908;
		  /* 82068908h */ case  140:  		/* ori R10, R10, 128 */
		/* 82068908h case  140:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x80);
		/* 82068908h case  140:*/		return 0x8206890C;
		  /* 8206890Ch */ case  141:  		/* std R10, <#[R3 + 16]> */
		/* 8206890Ch case  141:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 8206890Ch case  141:*/		return 0x82068910;
		  /* 82068910h */ case  142:  		/* ori R10, R10, 64 */
		/* 82068910h case  142:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x40);
		/* 82068910h case  142:*/		return 0x82068914;
		  /* 82068914h */ case  143:  		/* std R10, <#[R3 + 16]> */
		/* 82068914h case  143:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 82068914h case  143:*/		return 0x82068918;
		  /* 82068918h */ case  144:  		/* ori R10, R10, 32 */
		/* 82068918h case  144:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x20);
		/* 82068918h case  144:*/		return 0x8206891C;
		  /* 8206891Ch */ case  145:  		/* std R10, <#[R3 + 16]> */
		/* 8206891Ch case  145:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 8206891Ch case  145:*/		return 0x82068920;
		  /* 82068920h */ case  146:  		/* ld R10, <#[R3 + 32]> */
		/* 82068920h case  146:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R3 + 0x00000020) );
		/* 82068920h case  146:*/		return 0x82068924;
		  /* 82068924h */ case  147:  		/* oris R10, R10, 8 */
		/* 82068924h case  147:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x8);
		/* 82068924h case  147:*/		return 0x82068928;
		  /* 82068928h */ case  148:  		/* std R10, <#[R3 + 32]> */
		/* 82068928h case  148:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R3 + 0x00000020) );
		/* 82068928h case  148:*/		return 0x8206892C;
		  /* 8206892Ch */ case  149:  		/* ld R10, <#[R3 + 16]> */
		/* 8206892Ch case  149:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 8206892Ch case  149:*/		return 0x82068930;
		  /* 82068930h */ case  150:  		/* or R10, R10, R12 */
		/* 82068930h case  150:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R12);
		/* 82068930h case  150:*/		return 0x82068934;
		  /* 82068934h */ case  151:  		/* std R10, <#[R3 + 16]> */
		/* 82068934h case  151:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 82068934h case  151:*/		return 0x82068938;
		  /* 82068938h */ case  152:  		/* oris R10, R10, 8 */
		/* 82068938h case  152:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x8);
		/* 82068938h case  152:*/		return 0x8206893C;
		  /* 8206893Ch */ case  153:  		/* li R12, 1 */
		/* 8206893Ch case  153:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 8206893Ch case  153:*/		return 0x82068940;
		  /* 82068940h */ case  154:  		/* std R10, <#[R3 + 16]> */
		/* 82068940h case  154:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 82068940h case  154:*/		return 0x82068944;
		  /* 82068944h */ case  155:  		/* oris R10, R10, 16 */
		/* 82068944h case  155:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x10);
		/* 82068944h case  155:*/		return 0x82068948;
		  /* 82068948h */ case  156:  		/* rldicr R12, R12, 37, 63 */
		/* 82068948h case  156:*/		cpu::op::rldicr<0,37,63>(regs,&regs.R12,regs.R12);
		/* 82068948h case  156:*/		return 0x8206894C;
		  /* 8206894Ch */ case  157:  		/* std R10, <#[R3 + 16]> */
		/* 8206894Ch case  157:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 8206894Ch case  157:*/		return 0x82068950;
		  /* 82068950h */ case  158:  		/* ori R10, R10, 2048 */
		/* 82068950h case  158:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x800);
		/* 82068950h case  158:*/		return 0x82068954;
		  /* 82068954h */ case  159:  		/* std R10, <#[R3 + 16]> */
		/* 82068954h case  159:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 82068954h case  159:*/		return 0x82068958;
		  /* 82068958h */ case  160:  		/* ori R10, R10, 256 */
		/* 82068958h case  160:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x100);
		/* 82068958h case  160:*/		return 0x8206895C;
		  /* 8206895Ch */ case  161:  		/* std R10, <#[R3 + 16]> */
		/* 8206895Ch case  161:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 8206895Ch case  161:*/		return 0x82068960;
		  /* 82068960h */ case  162:  		/* ori R10, R10, 8 */
		/* 82068960h case  162:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x8);
		/* 82068960h case  162:*/		return 0x82068964;
		  /* 82068964h */ case  163:  		/* std R10, <#[R3 + 16]> */
		/* 82068964h case  163:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 82068964h case  163:*/		return 0x82068968;
		  /* 82068968h */ case  164:  		/* or R10, R10, R12 */
		/* 82068968h case  164:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R12);
		/* 82068968h case  164:*/		return 0x8206896C;
		  /* 8206896Ch */ case  165:  		/* li R12, 1 */
		/* 8206896Ch case  165:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 8206896Ch case  165:*/		return 0x82068970;
		  /* 82068970h */ case  166:  		/* std R10, <#[R3 + 16]> */
		/* 82068970h case  166:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 82068970h case  166:*/		return 0x82068974;
		  /* 82068974h */ case  167:  		/* rldicr R12, R12, 54, 63 */
		/* 82068974h case  167:*/		cpu::op::rldicr<0,54,63>(regs,&regs.R12,regs.R12);
		/* 82068974h case  167:*/		return 0x82068978;
		  /* 82068978h */ case  168:  		/* ld R10, <#[R3 + 24]> */
		/* 82068978h case  168:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R3 + 0x00000018) );
		/* 82068978h case  168:*/		return 0x8206897C;
		  /* 8206897Ch */ case  169:  		/* or R10, R10, R12 */
		/* 8206897Ch case  169:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R12);
		/* 8206897Ch case  169:*/		return 0x82068980;
		  /* 82068980h */ case  170:  		/* std R10, <#[R3 + 24]> */
		/* 82068980h case  170:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R3 + 0x00000018) );
		/* 82068980h case  170:*/		return 0x82068984;
		  /* 82068984h */ case  171:  		/* ld R10, <#[R3 + 32]> */
		/* 82068984h case  171:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R3 + 0x00000020) );
		/* 82068984h case  171:*/		return 0x82068988;
		  /* 82068988h */ case  172:  		/* or R11, R10, R11 */
		/* 82068988h case  172:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82068988h case  172:*/		return 0x8206898C;
		  /* 8206898Ch */ case  173:  		/* std R11, <#[R3 + 32]> */
		/* 8206898Ch case  173:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 8206898Ch case  173:*/		return 0x82068990;
		  /* 82068990h */ case  174:  		/* ld R11, <#[R3 + 24]> */
		/* 82068990h case  174:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82068990h case  174:*/		return 0x82068994;
		  /* 82068994h */ case  175:  		/* oris R11, R11, 32768 */
		/* 82068994h case  175:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8000);
		/* 82068994h case  175:*/		return 0x82068998;
		  /* 82068998h */ case  176:  		/* std R11, <#[R3 + 24]> */
		/* 82068998h case  176:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82068998h case  176:*/		return 0x8206899C;
		  /* 8206899Ch */ case  177:  		/* lwz R11, <#[R3 + 10436]> */
		/* 8206899Ch case  177:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000028C4) );
		/* 8206899Ch case  177:*/		return 0x820689A0;
		  /* 820689A0h */ case  178:  		/* lwz R10, <#[R3 + 10440]> */
		/* 820689A0h case  178:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x000028C8) );
		/* 820689A0h case  178:*/		return 0x820689A4;
		  /* 820689A4h */ case  179:  		/* rlwinm R9, R10, 1, 0, 30 */
		/* 820689A4h case  179:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R9,regs.R10);
		/* 820689A4h case  179:*/		return 0x820689A8;
		  /* 820689A8h */ case  180:  		/* rlwinm R10, R10, 17, 0, 14 */
		/* 820689A8h case  180:*/		cpu::op::rlwinm<0,17,0,14>(regs,&regs.R10,regs.R10);
		/* 820689A8h case  180:*/		return 0x820689AC;
		  /* 820689ACh */ case  181:  		/* rlwinm R8, R11, 1, 0, 30 */
		/* 820689ACh case  181:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R8,regs.R11);
		/* 820689ACh case  181:*/		return 0x820689B0;
		  /* 820689B0h */ case  182:  		/* srawi R7, R9, 17 */
		/* 820689B0h case  182:*/		cpu::op::srawi<0,17>(regs,&regs.R7,regs.R9);
		/* 820689B0h case  182:*/		return 0x820689B4;
		  /* 820689B4h */ case  183:  		/* rlwinm R11, R11, 17, 0, 14 */
		/* 820689B4h case  183:*/		cpu::op::rlwinm<0,17,0,14>(regs,&regs.R11,regs.R11);
		/* 820689B4h case  183:*/		return 0x820689B8;
		  /* 820689B8h */ case  184:  		/* srawi R6, R10, 17 */
		/* 820689B8h case  184:*/		cpu::op::srawi<0,17>(regs,&regs.R6,regs.R10);
		/* 820689B8h case  184:*/		return 0x820689BC;
		  /* 820689BCh */ case  185:  		/* srawi R5, R8, 17 */
		/* 820689BCh case  185:*/		cpu::op::srawi<0,17>(regs,&regs.R5,regs.R8);
		/* 820689BCh case  185:*/		return 0x820689C0;
		  /* 820689C0h */ case  186:  		/* srawi R4, R11, 17 */
		/* 820689C0h case  186:*/		cpu::op::srawi<0,17>(regs,&regs.R4,regs.R11);
		/* 820689C0h case  186:*/		return 0x820689C4;
		  /* 820689C4h */ case  187:  		/* b -27164 */
		/* 820689C4h case  187:*/		return 0x82061FA8;
		/* 820689C4h case  187:*/		return 0x820689C8;
		  /* 820689C8h */ case  188:  		/* addi R11, R5, -4 */
		/* 820689C8h case  188:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R5,0xFFFFFFFC);
		/* 820689C8h case  188:*/		return 0x820689CC;
		  /* 820689CCh */ case  189:  		/* li R10, 1480 */
		/* 820689CCh case  189:*/		cpu::op::li<0>(regs,&regs.R10,0x5C8);
		/* 820689CCh case  189:*/		return 0x820689D0;
		  /* 820689D0h */ case  190:  		/* lis R9, 7 */
		/* 820689D0h case  190:*/		cpu::op::lis<0>(regs,&regs.R9,0x7);
		/* 820689D0h case  190:*/		return 0x820689D4;
		  /* 820689D4h */ case  191:  		/* lis R8, 2 */
		/* 820689D4h case  191:*/		cpu::op::lis<0>(regs,&regs.R8,0x2);
		/* 820689D4h case  191:*/		return 0x820689D8;
		  /* 820689D8h */ case  192:  		/* ori R7, R9, 36096 */
		/* 820689D8h case  192:*/		cpu::op::ori<0>(regs,&regs.R7,regs.R9,0x8D00);
		/* 820689D8h case  192:*/		return 0x820689DC;
		  /* 820689DCh */ case  193:  		/* stwu R10, <#[R11 + 4]> */
		/* 820689DCh case  193:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820689DCh case  193:*/		return 0x820689E0;
		  /* 820689E0h */ case  194:  		/* neg R10, R4 */
		/* 820689E0h case  194:*/		cpu::op::neg<0>(regs,&regs.R10,regs.R4);
		/* 820689E0h case  194:*/		return 0x820689E4;
		  /* 820689E4h */ case  195:  		/* li R9, 8 */
		/* 820689E4h case  195:*/		cpu::op::li<0>(regs,&regs.R9,0x8);
		/* 820689E4h case  195:*/		return 0x820689E8;
		  /* 820689E8h */ case  196:  		/* rlwimi R10, R4, 8, 17, 23 */
		/* 820689E8h case  196:*/		cpu::op::rlwimi<0,8,17,23>(regs,&regs.R10,regs.R4);
		/* 820689E8h case  196:*/		return 0x820689EC;
		  /* 820689ECh */ case  197:  		/* rlwinm R10, R10, 4, 13, 27 */
		/* 820689ECh case  197:*/		cpu::op::rlwinm<0,4,13,27>(regs,&regs.R10,regs.R10);
		/* 820689ECh case  197:*/		return 0x820689F0;
		  /* 820689F0h */ case  198:  		/* stwu R8, <#[R11 + 4]> */
		/* 820689F0h case  198:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 820689F0h case  198:*/		return 0x820689F4;
		  /* 820689F4h */ case  199:  		/* rlwinm R10, R10, 0, 21, 19 */
		/* 820689F4h case  199:*/		cpu::op::rlwinm<0,0,21,19>(regs,&regs.R10,regs.R10);
		/* 820689F4h case  199:*/		return 0x820689F8;
		  /* 820689F8h */ case  200:  		/* mtspr CTR, R9 */
		/* 820689F8h case  200:*/		regs.CTR = regs.R9;
		/* 820689F8h case  200:*/		return 0x820689FC;
		  /* 820689FCh */ case  201:  		/* ori R8, R10, 1 */
		/* 820689FCh case  201:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R10,0x1);
		/* 820689FCh case  201:*/		return 0x82068A00;
		  /* 82068A00h */ case  202:  		/* stwu R7, <#[R11 + 4]> */
		/* 82068A00h case  202:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82068A00h case  202:*/		return 0x82068A04;
		  /* 82068A04h */ case  203:  		/* stwu R8, <#[R11 + 4]> */
		/* 82068A04h case  203:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82068A04h case  203:*/		return 0x82068A08;
		  /* 82068A08h */ case  204:  		/* bc 16, CR0_LT, -4 */
		/* 82068A08h case  204:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82068A04;  }
		/* 82068A08h case  204:*/		return 0x82068A0C;
		  /* 82068A0Ch */ case  205:  		/* li R9, 3328 */
		/* 82068A0Ch case  205:*/		cpu::op::li<0>(regs,&regs.R9,0xD00);
		/* 82068A0Ch case  205:*/		return 0x82068A10;
		  /* 82068A10h */ case  206:  		/* stwu R9, <#[R11 + 4]> */
		/* 82068A10h case  206:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82068A10h case  206:*/		return 0x82068A14;
		  /* 82068A14h */ case  207:  		/* stwu R10, <#[R11 + 4]> */
		/* 82068A14h case  207:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82068A14h case  207:*/		return 0x82068A18;
		  /* 82068A18h */ case  208:  		/* subf R11, R5, R11 */
		/* 82068A18h case  208:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R5,regs.R11);
		/* 82068A18h case  208:*/		return 0x82068A1C;
		  /* 82068A1Ch */ case  209:  		/* addi R11, R11, 4 */
		/* 82068A1Ch case  209:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82068A1Ch case  209:*/		return 0x82068A20;
		  /* 82068A20h */ case  210:  		/* srawi R3, R11, 2 */
		/* 82068A20h case  210:*/		cpu::op::srawi<0,2>(regs,&regs.R3,regs.R11);
		/* 82068A20h case  210:*/		return 0x82068A24;
		  /* 82068A24h */ case  211:  		/* bclr 20, CR0_LT */
		/* 82068A24h case  211:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82068A24h case  211:*/		return 0x82068A28;
	}
	return 0x82068A28;
} // Block from 820686D8h-82068A28h (212 instructions)

//////////////////////////////////////////////////////
// Block at 82068A28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068A28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068A28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068A28);
		  /* 82068A28h */ case    0:  		/* lwz R3, <#[R3 + 14184]> */
		/* 82068A28h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00003768) );
		/* 82068A28h case    0:*/		return 0x82068A2C;
		  /* 82068A2Ch */ case    1:  		/* lis R4, -20096 */
		/* 82068A2Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFFB180);
		/* 82068A2Ch case    1:*/		return 0x82068A30;
		  /* 82068A30h */ case    2:  		/* b 129288 */
		/* 82068A30h case    2:*/		return 0x82088338;
		/* 82068A30h case    2:*/		return 0x82068A34;
		  /* 82068A34h */ case    3:  		/* nop */
		/* 82068A34h case    3:*/		cpu::op::nop();
		/* 82068A34h case    3:*/		return 0x82068A38;
	}
	return 0x82068A38;
} // Block from 82068A28h-82068A38h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82068A38h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068A38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068A38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068A38);
		  /* 82068A38h */ case    0:  		/* addi R10, R4, 120 */
		/* 82068A38h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x78);
		/* 82068A38h case    0:*/		return 0x82068A3C;
		  /* 82068A3Ch */ case    1:  		/* mr R11, R5 */
		/* 82068A3Ch case    1:*/		regs.R11 = regs.R5;
		/* 82068A3Ch case    1:*/		return 0x82068A40;
		  /* 82068A40h */ case    2:  		/* rlwinm R10, R10, 4, 0, 27 */
		/* 82068A40h case    2:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R10,regs.R10);
		/* 82068A40h case    2:*/		return 0x82068A44;
		  /* 82068A44h */ case    3:  		/* mr R9, R6 */
		/* 82068A44h case    3:*/		regs.R9 = regs.R6;
		/* 82068A44h case    3:*/		return 0x82068A48;
		  /* 82068A48h */ case    4:  		/* add R10, R10, R3 */
		/* 82068A48h case    4:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R3);
		/* 82068A48h case    4:*/		return 0x82068A4C;
		  /* 82068A4Ch */ case    5:  		/* dcbt R0, R5 */
		/* 82068A4Ch case    5:*/		cpu::op::dcbt<0>(regs,&regs.R0,regs.R5);
		/* 82068A4Ch case    5:*/		return 0x82068A50;
		  /* 82068A50h */ case    6:  		/* li R8, 128 */
		/* 82068A50h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x80);
		/* 82068A50h case    6:*/		return 0x82068A54;
		  /* 82068A54h */ case    7:  		/* dcbt R8, R5 */
		/* 82068A54h case    7:*/		cpu::op::dcbt<0>(regs,&regs.R8,regs.R5);
		/* 82068A54h case    7:*/		return 0x82068A58;
		  /* 82068A58h */ case    8:  		/* li R5, 16 */
		/* 82068A58h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 82068A58h case    8:*/		return 0x82068A5C;
		  /* 82068A5Ch */ case    9:  		/* cmplwi CR6, R6, 3 */
		/* 82068A5Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000003);
		/* 82068A5Ch case    9:*/		return 0x82068A60;
		  /* 82068A60h */ case   10:  		/* bc 4, CR6_GT, 120 */
		/* 82068A60h case   10:*/		if ( !regs.CR[6].gt ) { return 0x82068AD8;  }
		/* 82068A60h case   10:*/		return 0x82068A64;
		  /* 82068A64h */ case   11:  		/* addi R8, R6, -4 */
		/* 82068A64h case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R6,0xFFFFFFFC);
		/* 82068A64h case   11:*/		return 0x82068A68;
		  /* 82068A68h */ case   12:  		/* li R6, 32 */
		/* 82068A68h case   12:*/		cpu::op::li<0>(regs,&regs.R6,0x20);
		/* 82068A68h case   12:*/		return 0x82068A6C;
		  /* 82068A6Ch */ case   13:  		/* rlwinm R8, R8, 30, 2, 31 */
		/* 82068A6Ch case   13:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R8,regs.R8);
		/* 82068A6Ch case   13:*/		return 0x82068A70;
		  /* 82068A70h */ case   14:  		/* addi R8, R8, 1 */
		/* 82068A70h case   14:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82068A70h case   14:*/		return 0x82068A74;
		  /* 82068A74h */ case   15:  		/* mtspr CTR, R8 */
		/* 82068A74h case   15:*/		regs.CTR = regs.R8;
		/* 82068A74h case   15:*/		return 0x82068A78;
		  /* 82068A78h */ case   16:  		/* li R8, 48 */
		/* 82068A78h case   16:*/		cpu::op::li<0>(regs,&regs.R8,0x30);
		/* 82068A78h case   16:*/		return 0x82068A7C;
		  /* 82068A7Ch */ case   17:  		/* li R4, 256 */
		/* 82068A7Ch case   17:*/		cpu::op::li<0>(regs,&regs.R4,0x100);
		/* 82068A7Ch case   17:*/		return 0x82068A80;
		  /* 82068A80h */ case   18:  		/* dcbt R4, R11 */
		/* 82068A80h case   18:*/		cpu::op::dcbt<0>(regs,&regs.R4,regs.R11);
		/* 82068A80h case   18:*/		return 0x82068A84;
		  /* 82068A84h */ case   19:  		/* lvrx VR62, <#[R5 + R11]> */
		/* 82068A84h case   19:*/		cpu::mem::lvrx( regs, &regs.VR62, (uint32)(regs.R5 + regs.R11 + 0x00000000) );
		/* 82068A84h case   19:*/		return 0x82068A88;
		  /* 82068A88h */ case   20:  		/* li R4, 64 */
		/* 82068A88h case   20:*/		cpu::op::li<0>(regs,&regs.R4,0x40);
		/* 82068A88h case   20:*/		return 0x82068A8C;
		  /* 82068A8Ch */ case   21:  		/* lvlx VR63, <#[R11]> */
		/* 82068A8Ch case   21:*/		cpu::mem::lvlx( regs, &regs.VR63, (uint32)(regs.R11 + 0x00000000) );
		/* 82068A8Ch case   21:*/		return 0x82068A90;
		  /* 82068A90h */ case   22:  		/* addi R9, R9, -4 */
		/* 82068A90h case   22:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFC);
		/* 82068A90h case   22:*/		return 0x82068A94;
		  /* 82068A94h */ case   23:  		/* vor VR63, VR63, VR62 */
		/* 82068A94h case   23:*/		cpu::op::vor<0>(regs,&regs.VR63,regs.VR63,regs.VR62);
		/* 82068A94h case   23:*/		return 0x82068A98;
		  /* 82068A98h */ case   24:  		/* lvlx VR61, <#[R5 + R11]> */
		/* 82068A98h case   24:*/		cpu::mem::lvlx( regs, &regs.VR61, (uint32)(regs.R5 + regs.R11 + 0x00000000) );
		/* 82068A98h case   24:*/		return 0x82068A9C;
		  /* 82068A9Ch */ case   25:  		/* lvrx VR62, <#[R6 + R11]> */
		/* 82068A9Ch case   25:*/		cpu::mem::lvrx( regs, &regs.VR62, (uint32)(regs.R6 + regs.R11 + 0x00000000) );
		/* 82068A9Ch case   25:*/		return 0x82068AA0;
		  /* 82068AA0h */ case   26:  		/* vor VR62, VR61, VR62 */
		/* 82068AA0h case   26:*/		cpu::op::vor<0>(regs,&regs.VR62,regs.VR61,regs.VR62);
		/* 82068AA0h case   26:*/		return 0x82068AA4;
		  /* 82068AA4h */ case   27:  		/* lvlx VR60, <#[R6 + R11]> */
		/* 82068AA4h case   27:*/		cpu::mem::lvlx( regs, &regs.VR60, (uint32)(regs.R6 + regs.R11 + 0x00000000) );
		/* 82068AA4h case   27:*/		return 0x82068AA8;
		  /* 82068AA8h */ case   28:  		/* lvrx VR61, <#[R8 + R11]> */
		/* 82068AA8h case   28:*/		cpu::mem::lvrx( regs, &regs.VR61, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 82068AA8h case   28:*/		return 0x82068AAC;
		  /* 82068AACh */ case   29:  		/* vor VR61, VR60, VR61 */
		/* 82068AACh case   29:*/		cpu::op::vor<0>(regs,&regs.VR61,regs.VR60,regs.VR61);
		/* 82068AACh case   29:*/		return 0x82068AB0;
		  /* 82068AB0h */ case   30:  		/* lvlx VR59, <#[R8 + R11]> */
		/* 82068AB0h case   30:*/		cpu::mem::lvlx( regs, &regs.VR59, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 82068AB0h case   30:*/		return 0x82068AB4;
		  /* 82068AB4h */ case   31:  		/* lvrx VR60, <#[R4 + R11]> */
		/* 82068AB4h case   31:*/		cpu::mem::lvrx( regs, &regs.VR60, (uint32)(regs.R4 + regs.R11 + 0x00000000) );
		/* 82068AB4h case   31:*/		return 0x82068AB8;
		  /* 82068AB8h */ case   32:  		/* addi R11, R11, 64 */
		/* 82068AB8h case   32:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x40);
		/* 82068AB8h case   32:*/		return 0x82068ABC;
		  /* 82068ABCh */ case   33:  		/* vor VR60, VR59, VR60 */
		/* 82068ABCh case   33:*/		cpu::op::vor<0>(regs,&regs.VR60,regs.VR59,regs.VR60);
		/* 82068ABCh case   33:*/		return 0x82068AC0;
		  /* 82068AC0h */ case   34:  		/* stvx VR63, <#[R10]> */
		/* 82068AC0h case   34:*/		cpu::mem::stvx( regs, regs.VR63, (uint32)(regs.R10 + 0x00000000) );
		/* 82068AC0h case   34:*/		return 0x82068AC4;
		  /* 82068AC4h */ case   35:  		/* stvx VR62, <#[R10 + R5]> */
		/* 82068AC4h case   35:*/		cpu::mem::stvx( regs, regs.VR62, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 82068AC4h case   35:*/		return 0x82068AC8;
		  /* 82068AC8h */ case   36:  		/* stvx VR61, <#[R10 + R6]> */
		/* 82068AC8h case   36:*/		cpu::mem::stvx( regs, regs.VR61, (uint32)(regs.R10 + regs.R6 + 0x00000000) );
		/* 82068AC8h case   36:*/		return 0x82068ACC;
		  /* 82068ACCh */ case   37:  		/* stvx VR60, <#[R10 + R8]> */
		/* 82068ACCh case   37:*/		cpu::mem::stvx( regs, regs.VR60, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 82068ACCh case   37:*/		return 0x82068AD0;
		  /* 82068AD0h */ case   38:  		/* addi R10, R10, 64 */
		/* 82068AD0h case   38:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x40);
		/* 82068AD0h case   38:*/		return 0x82068AD4;
		  /* 82068AD4h */ case   39:  		/* bc 16, CR0_LT, -88 */
		/* 82068AD4h case   39:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82068A7C;  }
		/* 82068AD4h case   39:*/		return 0x82068AD8;
	}
	return 0x82068AD8;
} // Block from 82068A38h-82068AD8h (40 instructions)

//////////////////////////////////////////////////////
// Block at 82068AD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068AD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068AD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068AD8);
		  /* 82068AD8h */ case    0:  		/* cmplwi CR6, R9, 0 */
		/* 82068AD8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82068AD8h case    0:*/		return 0x82068ADC;
		  /* 82068ADCh */ case    1:  		/* bc 12, CR6_EQ, 36 */
		/* 82068ADCh case    1:*/		if ( regs.CR[6].eq ) { return 0x82068B00;  }
		/* 82068ADCh case    1:*/		return 0x82068AE0;
		  /* 82068AE0h */ case    2:  		/* mtspr CTR, R9 */
		/* 82068AE0h case    2:*/		regs.CTR = regs.R9;
		/* 82068AE0h case    2:*/		return 0x82068AE4;
		  /* 82068AE4h */ case    3:  		/* lvlx VR63, <#[R11]> */
		/* 82068AE4h case    3:*/		cpu::mem::lvlx( regs, &regs.VR63, (uint32)(regs.R11 + 0x00000000) );
		/* 82068AE4h case    3:*/		return 0x82068AE8;
		  /* 82068AE8h */ case    4:  		/* lvrx VR62, <#[R5 + R11]> */
		/* 82068AE8h case    4:*/		cpu::mem::lvrx( regs, &regs.VR62, (uint32)(regs.R5 + regs.R11 + 0x00000000) );
		/* 82068AE8h case    4:*/		return 0x82068AEC;
		  /* 82068AECh */ case    5:  		/* addi R11, R11, 16 */
		/* 82068AECh case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x10);
		/* 82068AECh case    5:*/		return 0x82068AF0;
		  /* 82068AF0h */ case    6:  		/* vor VR63, VR63, VR62 */
		/* 82068AF0h case    6:*/		cpu::op::vor<0>(regs,&regs.VR63,regs.VR63,regs.VR62);
		/* 82068AF0h case    6:*/		return 0x82068AF4;
		  /* 82068AF4h */ case    7:  		/* stvx VR63, <#[R10]> */
		/* 82068AF4h case    7:*/		cpu::mem::stvx( regs, regs.VR63, (uint32)(regs.R10 + 0x00000000) );
		/* 82068AF4h case    7:*/		return 0x82068AF8;
		  /* 82068AF8h */ case    8:  		/* addi R10, R10, 16 */
		/* 82068AF8h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x10);
		/* 82068AF8h case    8:*/		return 0x82068AFC;
		  /* 82068AFCh */ case    9:  		/* bc 16, CR0_LT, -24 */
		/* 82068AFCh case    9:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82068AE4;  }
		/* 82068AFCh case    9:*/		return 0x82068B00;
	}
	return 0x82068B00;
} // Block from 82068AD8h-82068B00h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82068B00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068B00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068B00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068B00);
		  /* 82068B00h */ case    0:  		/* ld R11, <#[R3]> */
		/* 82068B00h case    0:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82068B00h case    0:*/		return 0x82068B04;
		  /* 82068B04h */ case    1:  		/* or R11, R11, R7 */
		/* 82068B04h case    1:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 82068B04h case    1:*/		return 0x82068B08;
		  /* 82068B08h */ case    2:  		/* std R11, <#[R3]> */
		/* 82068B08h case    2:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82068B08h case    2:*/		return 0x82068B0C;
		  /* 82068B0Ch */ case    3:  		/* bclr 20, CR0_LT */
		/* 82068B0Ch case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82068B0Ch case    3:*/		return 0x82068B10;
	}
	return 0x82068B10;
} // Block from 82068B00h-82068B10h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82068B10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068B10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068B10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068B10);
		  /* 82068B10h */ case    0:  		/* addi R10, R4, 376 */
		/* 82068B10h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x178);
		/* 82068B10h case    0:*/		return 0x82068B14;
		  /* 82068B14h */ case    1:  		/* mr R11, R5 */
		/* 82068B14h case    1:*/		regs.R11 = regs.R5;
		/* 82068B14h case    1:*/		return 0x82068B18;
		  /* 82068B18h */ case    2:  		/* rlwinm R10, R10, 4, 0, 27 */
		/* 82068B18h case    2:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R10,regs.R10);
		/* 82068B18h case    2:*/		return 0x82068B1C;
		  /* 82068B1Ch */ case    3:  		/* mr R9, R6 */
		/* 82068B1Ch case    3:*/		regs.R9 = regs.R6;
		/* 82068B1Ch case    3:*/		return 0x82068B20;
		  /* 82068B20h */ case    4:  		/* add R10, R10, R3 */
		/* 82068B20h case    4:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R3);
		/* 82068B20h case    4:*/		return 0x82068B24;
		  /* 82068B24h */ case    5:  		/* dcbt R0, R5 */
		/* 82068B24h case    5:*/		cpu::op::dcbt<0>(regs,&regs.R0,regs.R5);
		/* 82068B24h case    5:*/		return 0x82068B28;
		  /* 82068B28h */ case    6:  		/* li R8, 128 */
		/* 82068B28h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x80);
		/* 82068B28h case    6:*/		return 0x82068B2C;
		  /* 82068B2Ch */ case    7:  		/* dcbt R8, R5 */
		/* 82068B2Ch case    7:*/		cpu::op::dcbt<0>(regs,&regs.R8,regs.R5);
		/* 82068B2Ch case    7:*/		return 0x82068B30;
		  /* 82068B30h */ case    8:  		/* li R5, 16 */
		/* 82068B30h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x10);
		/* 82068B30h case    8:*/		return 0x82068B34;
		  /* 82068B34h */ case    9:  		/* cmplwi CR6, R6, 3 */
		/* 82068B34h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000003);
		/* 82068B34h case    9:*/		return 0x82068B38;
		  /* 82068B38h */ case   10:  		/* bc 4, CR6_GT, 120 */
		/* 82068B38h case   10:*/		if ( !regs.CR[6].gt ) { return 0x82068BB0;  }
		/* 82068B38h case   10:*/		return 0x82068B3C;
		  /* 82068B3Ch */ case   11:  		/* addi R8, R6, -4 */
		/* 82068B3Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R6,0xFFFFFFFC);
		/* 82068B3Ch case   11:*/		return 0x82068B40;
		  /* 82068B40h */ case   12:  		/* li R6, 32 */
		/* 82068B40h case   12:*/		cpu::op::li<0>(regs,&regs.R6,0x20);
		/* 82068B40h case   12:*/		return 0x82068B44;
		  /* 82068B44h */ case   13:  		/* rlwinm R8, R8, 30, 2, 31 */
		/* 82068B44h case   13:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R8,regs.R8);
		/* 82068B44h case   13:*/		return 0x82068B48;
		  /* 82068B48h */ case   14:  		/* addi R8, R8, 1 */
		/* 82068B48h case   14:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82068B48h case   14:*/		return 0x82068B4C;
		  /* 82068B4Ch */ case   15:  		/* mtspr CTR, R8 */
		/* 82068B4Ch case   15:*/		regs.CTR = regs.R8;
		/* 82068B4Ch case   15:*/		return 0x82068B50;
		  /* 82068B50h */ case   16:  		/* li R8, 48 */
		/* 82068B50h case   16:*/		cpu::op::li<0>(regs,&regs.R8,0x30);
		/* 82068B50h case   16:*/		return 0x82068B54;
		  /* 82068B54h */ case   17:  		/* li R4, 256 */
		/* 82068B54h case   17:*/		cpu::op::li<0>(regs,&regs.R4,0x100);
		/* 82068B54h case   17:*/		return 0x82068B58;
		  /* 82068B58h */ case   18:  		/* dcbt R4, R11 */
		/* 82068B58h case   18:*/		cpu::op::dcbt<0>(regs,&regs.R4,regs.R11);
		/* 82068B58h case   18:*/		return 0x82068B5C;
		  /* 82068B5Ch */ case   19:  		/* lvrx VR62, <#[R5 + R11]> */
		/* 82068B5Ch case   19:*/		cpu::mem::lvrx( regs, &regs.VR62, (uint32)(regs.R5 + regs.R11 + 0x00000000) );
		/* 82068B5Ch case   19:*/		return 0x82068B60;
		  /* 82068B60h */ case   20:  		/* li R4, 64 */
		/* 82068B60h case   20:*/		cpu::op::li<0>(regs,&regs.R4,0x40);
		/* 82068B60h case   20:*/		return 0x82068B64;
		  /* 82068B64h */ case   21:  		/* lvlx VR63, <#[R11]> */
		/* 82068B64h case   21:*/		cpu::mem::lvlx( regs, &regs.VR63, (uint32)(regs.R11 + 0x00000000) );
		/* 82068B64h case   21:*/		return 0x82068B68;
		  /* 82068B68h */ case   22:  		/* addi R9, R9, -4 */
		/* 82068B68h case   22:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFC);
		/* 82068B68h case   22:*/		return 0x82068B6C;
		  /* 82068B6Ch */ case   23:  		/* vor VR63, VR63, VR62 */
		/* 82068B6Ch case   23:*/		cpu::op::vor<0>(regs,&regs.VR63,regs.VR63,regs.VR62);
		/* 82068B6Ch case   23:*/		return 0x82068B70;
		  /* 82068B70h */ case   24:  		/* lvlx VR61, <#[R5 + R11]> */
		/* 82068B70h case   24:*/		cpu::mem::lvlx( regs, &regs.VR61, (uint32)(regs.R5 + regs.R11 + 0x00000000) );
		/* 82068B70h case   24:*/		return 0x82068B74;
		  /* 82068B74h */ case   25:  		/* lvrx VR62, <#[R6 + R11]> */
		/* 82068B74h case   25:*/		cpu::mem::lvrx( regs, &regs.VR62, (uint32)(regs.R6 + regs.R11 + 0x00000000) );
		/* 82068B74h case   25:*/		return 0x82068B78;
		  /* 82068B78h */ case   26:  		/* vor VR62, VR61, VR62 */
		/* 82068B78h case   26:*/		cpu::op::vor<0>(regs,&regs.VR62,regs.VR61,regs.VR62);
		/* 82068B78h case   26:*/		return 0x82068B7C;
		  /* 82068B7Ch */ case   27:  		/* lvlx VR60, <#[R6 + R11]> */
		/* 82068B7Ch case   27:*/		cpu::mem::lvlx( regs, &regs.VR60, (uint32)(regs.R6 + regs.R11 + 0x00000000) );
		/* 82068B7Ch case   27:*/		return 0x82068B80;
		  /* 82068B80h */ case   28:  		/* lvrx VR61, <#[R8 + R11]> */
		/* 82068B80h case   28:*/		cpu::mem::lvrx( regs, &regs.VR61, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 82068B80h case   28:*/		return 0x82068B84;
		  /* 82068B84h */ case   29:  		/* vor VR61, VR60, VR61 */
		/* 82068B84h case   29:*/		cpu::op::vor<0>(regs,&regs.VR61,regs.VR60,regs.VR61);
		/* 82068B84h case   29:*/		return 0x82068B88;
		  /* 82068B88h */ case   30:  		/* lvlx VR59, <#[R8 + R11]> */
		/* 82068B88h case   30:*/		cpu::mem::lvlx( regs, &regs.VR59, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 82068B88h case   30:*/		return 0x82068B8C;
		  /* 82068B8Ch */ case   31:  		/* lvrx VR60, <#[R4 + R11]> */
		/* 82068B8Ch case   31:*/		cpu::mem::lvrx( regs, &regs.VR60, (uint32)(regs.R4 + regs.R11 + 0x00000000) );
		/* 82068B8Ch case   31:*/		return 0x82068B90;
		  /* 82068B90h */ case   32:  		/* addi R11, R11, 64 */
		/* 82068B90h case   32:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x40);
		/* 82068B90h case   32:*/		return 0x82068B94;
		  /* 82068B94h */ case   33:  		/* vor VR60, VR59, VR60 */
		/* 82068B94h case   33:*/		cpu::op::vor<0>(regs,&regs.VR60,regs.VR59,regs.VR60);
		/* 82068B94h case   33:*/		return 0x82068B98;
		  /* 82068B98h */ case   34:  		/* stvx VR63, <#[R10]> */
		/* 82068B98h case   34:*/		cpu::mem::stvx( regs, regs.VR63, (uint32)(regs.R10 + 0x00000000) );
		/* 82068B98h case   34:*/		return 0x82068B9C;
		  /* 82068B9Ch */ case   35:  		/* stvx VR62, <#[R10 + R5]> */
		/* 82068B9Ch case   35:*/		cpu::mem::stvx( regs, regs.VR62, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 82068B9Ch case   35:*/		return 0x82068BA0;
		  /* 82068BA0h */ case   36:  		/* stvx VR61, <#[R10 + R6]> */
		/* 82068BA0h case   36:*/		cpu::mem::stvx( regs, regs.VR61, (uint32)(regs.R10 + regs.R6 + 0x00000000) );
		/* 82068BA0h case   36:*/		return 0x82068BA4;
		  /* 82068BA4h */ case   37:  		/* stvx VR60, <#[R10 + R8]> */
		/* 82068BA4h case   37:*/		cpu::mem::stvx( regs, regs.VR60, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 82068BA4h case   37:*/		return 0x82068BA8;
		  /* 82068BA8h */ case   38:  		/* addi R10, R10, 64 */
		/* 82068BA8h case   38:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x40);
		/* 82068BA8h case   38:*/		return 0x82068BAC;
		  /* 82068BACh */ case   39:  		/* bc 16, CR0_LT, -88 */
		/* 82068BACh case   39:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82068B54;  }
		/* 82068BACh case   39:*/		return 0x82068BB0;
	}
	return 0x82068BB0;
} // Block from 82068B10h-82068BB0h (40 instructions)

//////////////////////////////////////////////////////
// Block at 82068BB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068BB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068BB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068BB0);
		  /* 82068BB0h */ case    0:  		/* cmplwi CR6, R9, 0 */
		/* 82068BB0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82068BB0h case    0:*/		return 0x82068BB4;
		  /* 82068BB4h */ case    1:  		/* bc 12, CR6_EQ, 36 */
		/* 82068BB4h case    1:*/		if ( regs.CR[6].eq ) { return 0x82068BD8;  }
		/* 82068BB4h case    1:*/		return 0x82068BB8;
		  /* 82068BB8h */ case    2:  		/* mtspr CTR, R9 */
		/* 82068BB8h case    2:*/		regs.CTR = regs.R9;
		/* 82068BB8h case    2:*/		return 0x82068BBC;
		  /* 82068BBCh */ case    3:  		/* lvlx VR63, <#[R11]> */
		/* 82068BBCh case    3:*/		cpu::mem::lvlx( regs, &regs.VR63, (uint32)(regs.R11 + 0x00000000) );
		/* 82068BBCh case    3:*/		return 0x82068BC0;
		  /* 82068BC0h */ case    4:  		/* lvrx VR62, <#[R5 + R11]> */
		/* 82068BC0h case    4:*/		cpu::mem::lvrx( regs, &regs.VR62, (uint32)(regs.R5 + regs.R11 + 0x00000000) );
		/* 82068BC0h case    4:*/		return 0x82068BC4;
		  /* 82068BC4h */ case    5:  		/* addi R11, R11, 16 */
		/* 82068BC4h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x10);
		/* 82068BC4h case    5:*/		return 0x82068BC8;
		  /* 82068BC8h */ case    6:  		/* vor VR63, VR63, VR62 */
		/* 82068BC8h case    6:*/		cpu::op::vor<0>(regs,&regs.VR63,regs.VR63,regs.VR62);
		/* 82068BC8h case    6:*/		return 0x82068BCC;
		  /* 82068BCCh */ case    7:  		/* stvx VR63, <#[R10]> */
		/* 82068BCCh case    7:*/		cpu::mem::stvx( regs, regs.VR63, (uint32)(regs.R10 + 0x00000000) );
		/* 82068BCCh case    7:*/		return 0x82068BD0;
		  /* 82068BD0h */ case    8:  		/* addi R10, R10, 16 */
		/* 82068BD0h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x10);
		/* 82068BD0h case    8:*/		return 0x82068BD4;
		  /* 82068BD4h */ case    9:  		/* bc 16, CR0_LT, -24 */
		/* 82068BD4h case    9:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82068BBC;  }
		/* 82068BD4h case    9:*/		return 0x82068BD8;
	}
	return 0x82068BD8;
} // Block from 82068BB0h-82068BD8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82068BD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068BD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068BD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068BD8);
		  /* 82068BD8h */ case    0:  		/* ld R11, <#[R3 + 8]> */
		/* 82068BD8h case    0:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82068BD8h case    0:*/		return 0x82068BDC;
		  /* 82068BDCh */ case    1:  		/* or R11, R7, R11 */
		/* 82068BDCh case    1:*/		cpu::op::or<0>(regs,&regs.R11,regs.R7,regs.R11);
		/* 82068BDCh case    1:*/		return 0x82068BE0;
		  /* 82068BE0h */ case    2:  		/* std R11, <#[R3 + 8]> */
		/* 82068BE0h case    2:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82068BE0h case    2:*/		return 0x82068BE4;
		  /* 82068BE4h */ case    3:  		/* bclr 20, CR0_LT */
		/* 82068BE4h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82068BE4h case    3:*/		return 0x82068BE8;
	}
	return 0x82068BE8;
} // Block from 82068BD8h-82068BE8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82068BE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068BE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068BE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068BE8);
		  /* 82068BE8h */ case    0:  		/* addi R10, R5, -4 */
		/* 82068BE8h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R5,0xFFFFFFFC);
		/* 82068BE8h case    0:*/		return 0x82068BEC;
		  /* 82068BECh */ case    1:  		/* rlwinm R11, R4, 27, 5, 31 */
		/* 82068BECh case    1:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R4);
		/* 82068BECh case    1:*/		return 0x82068BF0;
		  /* 82068BF0h */ case    2:  		/* lwzu R9, <#[R10 + 4]> */
		/* 82068BF0h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 82068BF0h case    2:*/		return 0x82068BF4;
		  /* 82068BF4h */ case    3:  		/* rlwinm R8, R4, 0, 27, 31 */
		/* 82068BF4h case    3:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R8,regs.R4);
		/* 82068BF4h case    3:*/		return 0x82068BF8;
		  /* 82068BF8h */ case    4:  		/* addi R11, R11, 2528 */
		/* 82068BF8h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x9E0);
		/* 82068BF8h case    4:*/		return 0x82068BFC;
		  /* 82068BFCh */ case    5:  		/* li R7, 1 */
		/* 82068BFCh case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 82068BFCh case    5:*/		return 0x82068C00;
		  /* 82068C00h */ case    6:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82068C00h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82068C00h case    6:*/		return 0x82068C04;
		  /* 82068C04h */ case    7:  		/* rlwinm R9, R9, 0, 31, 31 */
		/* 82068C04h case    7:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R9,regs.R9);
		/* 82068C04h case    7:*/		return 0x82068C08;
		  /* 82068C08h */ case    8:  		/* slw R7, R7, R8 */
		/* 82068C08h case    8:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R7,regs.R8);
		/* 82068C08h case    8:*/		return 0x82068C0C;
		  /* 82068C0Ch */ case    9:  		/* lwzx R5, <#[R11 + R3]> */
		/* 82068C0Ch case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 82068C0Ch case    9:*/		return 0x82068C10;
		  /* 82068C10h */ case   10:  		/* slw R9, R9, R8 */
		/* 82068C10h case   10:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 82068C10h case   10:*/		return 0x82068C14;
		  /* 82068C14h */ case   11:  		/* andc R8, R5, R7 */
		/* 82068C14h case   11:*/		cpu::op::andc<0>(regs,&regs.R8,regs.R5,regs.R7);
		/* 82068C14h case   11:*/		return 0x82068C18;
		  /* 82068C18h */ case   12:  		/* addic. R6, R6, -1 */
		/* 82068C18h case   12:*/		cpu::op::addic<1>(regs,&regs.R6,regs.R6,0xFFFFFFFF);
		/* 82068C18h case   12:*/		return 0x82068C1C;
		  /* 82068C1Ch */ case   13:  		/* or R9, R8, R9 */
		/* 82068C1Ch case   13:*/		cpu::op::or<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 82068C1Ch case   13:*/		return 0x82068C20;
		  /* 82068C20h */ case   14:  		/* addi R4, R4, 1 */
		/* 82068C20h case   14:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 82068C20h case   14:*/		return 0x82068C24;
		  /* 82068C24h */ case   15:  		/* stwx R9, <#[R11 + R3]> */
		/* 82068C24h case   15:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 82068C24h case   15:*/		return 0x82068C28;
		  /* 82068C28h */ case   16:  		/* bc 4, CR0_EQ, -60 */
		/* 82068C28h case   16:*/		if ( !regs.CR[0].eq ) { return 0x82068BEC;  }
		/* 82068C28h case   16:*/		return 0x82068C2C;
		  /* 82068C2Ch */ case   17:  		/* li R12, 1 */
		/* 82068C2Ch case   17:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 82068C2Ch case   17:*/		return 0x82068C30;
		  /* 82068C30h */ case   18:  		/* ld R11, <#[R3 + 32]> */
		/* 82068C30h case   18:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 82068C30h case   18:*/		return 0x82068C34;
		  /* 82068C34h */ case   19:  		/* rldicr R12, R12, 56, 63 */
		/* 82068C34h case   19:*/		cpu::op::rldicr<0,56,63>(regs,&regs.R12,regs.R12);
		/* 82068C34h case   19:*/		return 0x82068C38;
		  /* 82068C38h */ case   20:  		/* or R11, R11, R12 */
		/* 82068C38h case   20:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 82068C38h case   20:*/		return 0x82068C3C;
		  /* 82068C3Ch */ case   21:  		/* std R11, <#[R3 + 32]> */
		/* 82068C3Ch case   21:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 82068C3Ch case   21:*/		return 0x82068C40;
		  /* 82068C40h */ case   22:  		/* bclr 20, CR0_LT */
		/* 82068C40h case   22:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82068C40h case   22:*/		return 0x82068C44;
	}
	return 0x82068C44;
} // Block from 82068BE8h-82068C44h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82068C44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068C44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068C44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068C44);
		  /* 82068C44h */ case    0:  		/* nop */
		/* 82068C44h case    0:*/		cpu::op::nop();
		/* 82068C44h case    0:*/		return 0x82068C48;
		  /* 82068C48h */ case    1:  		/* addi R10, R5, -4 */
		/* 82068C48h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R5,0xFFFFFFFC);
		/* 82068C48h case    1:*/		return 0x82068C4C;
		  /* 82068C4Ch */ case    2:  		/* rlwinm R11, R4, 27, 5, 31 */
		/* 82068C4Ch case    2:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R4);
		/* 82068C4Ch case    2:*/		return 0x82068C50;
		  /* 82068C50h */ case    3:  		/* lwzu R9, <#[R10 + 4]> */
		/* 82068C50h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 82068C50h case    3:*/		return 0x82068C54;
		  /* 82068C54h */ case    4:  		/* rlwinm R8, R4, 0, 27, 31 */
		/* 82068C54h case    4:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R8,regs.R4);
		/* 82068C54h case    4:*/		return 0x82068C58;
		  /* 82068C58h */ case    5:  		/* addi R11, R11, 2532 */
		/* 82068C58h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x9E4);
		/* 82068C58h case    5:*/		return 0x82068C5C;
		  /* 82068C5Ch */ case    6:  		/* li R7, 1 */
		/* 82068C5Ch case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 82068C5Ch case    6:*/		return 0x82068C60;
		  /* 82068C60h */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82068C60h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82068C60h case    7:*/		return 0x82068C64;
		  /* 82068C64h */ case    8:  		/* rlwinm R9, R9, 0, 31, 31 */
		/* 82068C64h case    8:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R9,regs.R9);
		/* 82068C64h case    8:*/		return 0x82068C68;
		  /* 82068C68h */ case    9:  		/* slw R7, R7, R8 */
		/* 82068C68h case    9:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R7,regs.R8);
		/* 82068C68h case    9:*/		return 0x82068C6C;
		  /* 82068C6Ch */ case   10:  		/* lwzx R5, <#[R11 + R3]> */
		/* 82068C6Ch case   10:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 82068C6Ch case   10:*/		return 0x82068C70;
		  /* 82068C70h */ case   11:  		/* slw R9, R9, R8 */
		/* 82068C70h case   11:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 82068C70h case   11:*/		return 0x82068C74;
		  /* 82068C74h */ case   12:  		/* andc R8, R5, R7 */
		/* 82068C74h case   12:*/		cpu::op::andc<0>(regs,&regs.R8,regs.R5,regs.R7);
		/* 82068C74h case   12:*/		return 0x82068C78;
		  /* 82068C78h */ case   13:  		/* addic. R6, R6, -1 */
		/* 82068C78h case   13:*/		cpu::op::addic<1>(regs,&regs.R6,regs.R6,0xFFFFFFFF);
		/* 82068C78h case   13:*/		return 0x82068C7C;
		  /* 82068C7Ch */ case   14:  		/* or R9, R8, R9 */
		/* 82068C7Ch case   14:*/		cpu::op::or<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 82068C7Ch case   14:*/		return 0x82068C80;
		  /* 82068C80h */ case   15:  		/* addi R4, R4, 1 */
		/* 82068C80h case   15:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 82068C80h case   15:*/		return 0x82068C84;
		  /* 82068C84h */ case   16:  		/* stwx R9, <#[R11 + R3]> */
		/* 82068C84h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 82068C84h case   16:*/		return 0x82068C88;
		  /* 82068C88h */ case   17:  		/* bc 4, CR0_EQ, -60 */
		/* 82068C88h case   17:*/		if ( !regs.CR[0].eq ) { return 0x82068C4C;  }
		/* 82068C88h case   17:*/		return 0x82068C8C;
		  /* 82068C8Ch */ case   18:  		/* li R12, 1 */
		/* 82068C8Ch case   18:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 82068C8Ch case   18:*/		return 0x82068C90;
		  /* 82068C90h */ case   19:  		/* ld R11, <#[R3 + 32]> */
		/* 82068C90h case   19:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 82068C90h case   19:*/		return 0x82068C94;
		  /* 82068C94h */ case   20:  		/* rldicr R12, R12, 56, 63 */
		/* 82068C94h case   20:*/		cpu::op::rldicr<0,56,63>(regs,&regs.R12,regs.R12);
		/* 82068C94h case   20:*/		return 0x82068C98;
		  /* 82068C98h */ case   21:  		/* or R11, R11, R12 */
		/* 82068C98h case   21:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 82068C98h case   21:*/		return 0x82068C9C;
		  /* 82068C9Ch */ case   22:  		/* std R11, <#[R3 + 32]> */
		/* 82068C9Ch case   22:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 82068C9Ch case   22:*/		return 0x82068CA0;
		  /* 82068CA0h */ case   23:  		/* bclr 20, CR0_LT */
		/* 82068CA0h case   23:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82068CA0h case   23:*/		return 0x82068CA4;
	}
	return 0x82068CA4;
} // Block from 82068C44h-82068CA4h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82068CA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068CA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068CA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068CA4);
		  /* 82068CA4h */ case    0:  		/* nop */
		/* 82068CA4h case    0:*/		cpu::op::nop();
		/* 82068CA4h case    0:*/		return 0x82068CA8;
		  /* 82068CA8h */ case    1:  		/* addi R10, R4, 2535 */
		/* 82068CA8h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x9E7);
		/* 82068CA8h case    1:*/		return 0x82068CAC;
		  /* 82068CACh */ case    2:  		/* addi R11, R5, 4 */
		/* 82068CACh case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R5,0x4);
		/* 82068CACh case    2:*/		return 0x82068CB0;
		  /* 82068CB0h */ case    3:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82068CB0h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82068CB0h case    3:*/		return 0x82068CB4;
		  /* 82068CB4h */ case    4:  		/* add R10, R10, R3 */
		/* 82068CB4h case    4:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R3);
		/* 82068CB4h case    4:*/		return 0x82068CB8;
		  /* 82068CB8h */ case    5:  		/* lbz R9, <#[R11 + 7]> */
		/* 82068CB8h case    5:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000007) );
		/* 82068CB8h case    5:*/		return 0x82068CBC;
		  /* 82068CBCh */ case    6:  		/* addic. R6, R6, -1 */
		/* 82068CBCh case    6:*/		cpu::op::addic<1>(regs,&regs.R6,regs.R6,0xFFFFFFFF);
		/* 82068CBCh case    6:*/		return 0x82068CC0;
		  /* 82068CC0h */ case    7:  		/* lbz R8, <#[R11 + 3]> */
		/* 82068CC0h case    7:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000003) );
		/* 82068CC0h case    7:*/		return 0x82068CC4;
		  /* 82068CC4h */ case    8:  		/* rlwinm R9, R9, 8, 0, 31 */
		/* 82068CC4h case    8:*/		cpu::op::rlwinm<0,8,0,31>(regs,&regs.R9,regs.R9);
		/* 82068CC4h case    8:*/		return 0x82068CC8;
		  /* 82068CC8h */ case    9:  		/* lbz R7, <#[R11 - 1]> */
		/* 82068CC8h case    9:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R11 + 0xFFFFFFFF) );
		/* 82068CC8h case    9:*/		return 0x82068CCC;
		  /* 82068CCCh */ case   10:  		/* addi R11, R11, 16 */
		/* 82068CCCh case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x10);
		/* 82068CCCh case   10:*/		return 0x82068CD0;
		  /* 82068CD0h */ case   11:  		/* or R9, R9, R8 */
		/* 82068CD0h case   11:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 82068CD0h case   11:*/		return 0x82068CD4;
		  /* 82068CD4h */ case   12:  		/* rlwinm R9, R9, 8, 0, 23 */
		/* 82068CD4h case   12:*/		cpu::op::rlwinm<0,8,0,23>(regs,&regs.R9,regs.R9);
		/* 82068CD4h case   12:*/		return 0x82068CD8;
		  /* 82068CD8h */ case   13:  		/* or R9, R9, R7 */
		/* 82068CD8h case   13:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 82068CD8h case   13:*/		return 0x82068CDC;
		  /* 82068CDCh */ case   14:  		/* stwu R9, <#[R10 + 4]> */
		/* 82068CDCh case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 82068CDCh case   14:*/		return 0x82068CE0;
		  /* 82068CE0h */ case   15:  		/* bc 4, CR0_EQ, -40 */
		/* 82068CE0h case   15:*/		if ( !regs.CR[0].eq ) { return 0x82068CB8;  }
		/* 82068CE0h case   15:*/		return 0x82068CE4;
		  /* 82068CE4h */ case   16:  		/* li R12, 1 */
		/* 82068CE4h case   16:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 82068CE4h case   16:*/		return 0x82068CE8;
		  /* 82068CE8h */ case   17:  		/* ld R11, <#[R3 + 32]> */
		/* 82068CE8h case   17:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 82068CE8h case   17:*/		return 0x82068CEC;
		  /* 82068CECh */ case   18:  		/* rldicr R12, R12, 56, 63 */
		/* 82068CECh case   18:*/		cpu::op::rldicr<0,56,63>(regs,&regs.R12,regs.R12);
		/* 82068CECh case   18:*/		return 0x82068CF0;
		  /* 82068CF0h */ case   19:  		/* or R11, R11, R12 */
		/* 82068CF0h case   19:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 82068CF0h case   19:*/		return 0x82068CF4;
		  /* 82068CF4h */ case   20:  		/* std R11, <#[R3 + 32]> */
		/* 82068CF4h case   20:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 82068CF4h case   20:*/		return 0x82068CF8;
		  /* 82068CF8h */ case   21:  		/* bclr 20, CR0_LT */
		/* 82068CF8h case   21:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82068CF8h case   21:*/		return 0x82068CFC;
	}
	return 0x82068CFC;
} // Block from 82068CA4h-82068CFCh (22 instructions)

//////////////////////////////////////////////////////
// Block at 82068CFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068CFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068CFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068CFC);
		  /* 82068CFCh */ case    0:  		/* nop */
		/* 82068CFCh case    0:*/		cpu::op::nop();
		/* 82068CFCh case    0:*/		return 0x82068D00;
		  /* 82068D00h */ case    1:  		/* addi R10, R4, 2551 */
		/* 82068D00h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x9F7);
		/* 82068D00h case    1:*/		return 0x82068D04;
		  /* 82068D04h */ case    2:  		/* addi R11, R5, 4 */
		/* 82068D04h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R5,0x4);
		/* 82068D04h case    2:*/		return 0x82068D08;
		  /* 82068D08h */ case    3:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82068D08h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82068D08h case    3:*/		return 0x82068D0C;
		  /* 82068D0Ch */ case    4:  		/* add R10, R10, R3 */
		/* 82068D0Ch case    4:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R3);
		/* 82068D0Ch case    4:*/		return 0x82068D10;
		  /* 82068D10h */ case    5:  		/* lbz R9, <#[R11 + 7]> */
		/* 82068D10h case    5:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000007) );
		/* 82068D10h case    5:*/		return 0x82068D14;
		  /* 82068D14h */ case    6:  		/* addic. R6, R6, -1 */
		/* 82068D14h case    6:*/		cpu::op::addic<1>(regs,&regs.R6,regs.R6,0xFFFFFFFF);
		/* 82068D14h case    6:*/		return 0x82068D18;
		  /* 82068D18h */ case    7:  		/* lbz R8, <#[R11 + 3]> */
		/* 82068D18h case    7:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000003) );
		/* 82068D18h case    7:*/		return 0x82068D1C;
		  /* 82068D1Ch */ case    8:  		/* rlwinm R9, R9, 8, 0, 31 */
		/* 82068D1Ch case    8:*/		cpu::op::rlwinm<0,8,0,31>(regs,&regs.R9,regs.R9);
		/* 82068D1Ch case    8:*/		return 0x82068D20;
		  /* 82068D20h */ case    9:  		/* lbz R7, <#[R11 - 1]> */
		/* 82068D20h case    9:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R11 + 0xFFFFFFFF) );
		/* 82068D20h case    9:*/		return 0x82068D24;
		  /* 82068D24h */ case   10:  		/* addi R11, R11, 16 */
		/* 82068D24h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x10);
		/* 82068D24h case   10:*/		return 0x82068D28;
		  /* 82068D28h */ case   11:  		/* or R9, R9, R8 */
		/* 82068D28h case   11:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 82068D28h case   11:*/		return 0x82068D2C;
		  /* 82068D2Ch */ case   12:  		/* rlwinm R9, R9, 8, 0, 23 */
		/* 82068D2Ch case   12:*/		cpu::op::rlwinm<0,8,0,23>(regs,&regs.R9,regs.R9);
		/* 82068D2Ch case   12:*/		return 0x82068D30;
		  /* 82068D30h */ case   13:  		/* or R9, R9, R7 */
		/* 82068D30h case   13:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 82068D30h case   13:*/		return 0x82068D34;
		  /* 82068D34h */ case   14:  		/* stwu R9, <#[R10 + 4]> */
		/* 82068D34h case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 82068D34h case   14:*/		return 0x82068D38;
		  /* 82068D38h */ case   15:  		/* bc 4, CR0_EQ, -40 */
		/* 82068D38h case   15:*/		if ( !regs.CR[0].eq ) { return 0x82068D10;  }
		/* 82068D38h case   15:*/		return 0x82068D3C;
		  /* 82068D3Ch */ case   16:  		/* li R12, 1 */
		/* 82068D3Ch case   16:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 82068D3Ch case   16:*/		return 0x82068D40;
		  /* 82068D40h */ case   17:  		/* ld R11, <#[R3 + 32]> */
		/* 82068D40h case   17:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 82068D40h case   17:*/		return 0x82068D44;
		  /* 82068D44h */ case   18:  		/* rldicr R12, R12, 56, 63 */
		/* 82068D44h case   18:*/		cpu::op::rldicr<0,56,63>(regs,&regs.R12,regs.R12);
		/* 82068D44h case   18:*/		return 0x82068D48;
		  /* 82068D48h */ case   19:  		/* or R11, R11, R12 */
		/* 82068D48h case   19:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 82068D48h case   19:*/		return 0x82068D4C;
		  /* 82068D4Ch */ case   20:  		/* std R11, <#[R3 + 32]> */
		/* 82068D4Ch case   20:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 82068D4Ch case   20:*/		return 0x82068D50;
		  /* 82068D50h */ case   21:  		/* bclr 20, CR0_LT */
		/* 82068D50h case   21:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82068D50h case   21:*/		return 0x82068D54;
	}
	return 0x82068D54;
} // Block from 82068CFCh-82068D54h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82068D54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068D54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068D54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068D54);
		  /* 82068D54h */ case    0:  		/* nop */
		/* 82068D54h case    0:*/		cpu::op::nop();
		/* 82068D54h case    0:*/		return 0x82068D58;
		  /* 82068D58h */ case    1:  		/* li R11, 0 */
		/* 82068D58h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82068D58h case    1:*/		return 0x82068D5C;
		  /* 82068D5Ch */ case    2:  		/* stw R11, <#[R4]> */
		/* 82068D5Ch case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 82068D5Ch case    2:*/		return 0x82068D60;
		  /* 82068D60h */ case    3:  		/* stw R11, <#[R4 + 4]> */
		/* 82068D60h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 82068D60h case    3:*/		return 0x82068D64;
		  /* 82068D64h */ case    4:  		/* stw R11, <#[R4 + 8]> */
		/* 82068D64h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 82068D64h case    4:*/		return 0x82068D68;
		  /* 82068D68h */ case    5:  		/* stw R11, <#[R4 + 12]> */
		/* 82068D68h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 82068D68h case    5:*/		return 0x82068D6C;
		  /* 82068D6Ch */ case    6:  		/* lwz R10, <#[R3]> */
		/* 82068D6Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82068D6Ch case    6:*/		return 0x82068D70;
		  /* 82068D70h */ case    7:  		/* lwz R11, <#[R3 + 4]> */
		/* 82068D70h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82068D70h case    7:*/		return 0x82068D74;
		  /* 82068D74h */ case    8:  		/* add R9, R11, R3 */
		/* 82068D74h case    8:*/		cpu::op::add<0>(regs,&regs.R9,regs.R11,regs.R3);
		/* 82068D74h case    8:*/		return 0x82068D78;
		  /* 82068D78h */ case    9:  		/* stw R3, <#[R4]> */
		/* 82068D78h case    9:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R4 + 0x00000000) );
		/* 82068D78h case    9:*/		return 0x82068D7C;
		  /* 82068D7Ch */ case   10:  		/* rlwinm R10, R10, 0, 31, 31 */
		/* 82068D7Ch case   10:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R10);
		/* 82068D7Ch case   10:*/		return 0x82068D80;
		  /* 82068D80h */ case   11:  		/* stw R9, <#[R4 + 8]> */
		/* 82068D80h case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R4 + 0x00000008) );
		/* 82068D80h case   11:*/		return 0x82068D84;
		  /* 82068D84h */ case   12:  		/* subfic R10, R10, 0 */
		/* 82068D84h case   12:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R10,0x0);
		/* 82068D84h case   12:*/		return 0x82068D88;
		  /* 82068D88h */ case   13:  		/* subfe R10, R10, R10 */
		/* 82068D88h case   13:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 82068D88h case   13:*/		return 0x82068D8C;
		  /* 82068D8Ch */ case   14:  		/* andi. R10, R10, 832 */
		/* 82068D8Ch case   14:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R10,0x340);
		/* 82068D8Ch case   14:*/		return 0x82068D90;
		  /* 82068D90h */ case   15:  		/* addi R10, R10, 40 */
		/* 82068D90h case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x28);
		/* 82068D90h case   15:*/		return 0x82068D94;
		  /* 82068D94h */ case   16:  		/* add R11, R10, R11 */
		/* 82068D94h case   16:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82068D94h case   16:*/		return 0x82068D98;
		  /* 82068D98h */ case   17:  		/* stw R11, <#[R4 + 4]> */
		/* 82068D98h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 82068D98h case   17:*/		return 0x82068D9C;
		  /* 82068D9Ch */ case   18:  		/* lwz R11, <#[R3 + 8]> */
		/* 82068D9Ch case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82068D9Ch case   18:*/		return 0x82068DA0;
		  /* 82068DA0h */ case   19:  		/* stw R11, <#[R4 + 12]> */
		/* 82068DA0h case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 82068DA0h case   19:*/		return 0x82068DA4;
		  /* 82068DA4h */ case   20:  		/* bclr 20, CR0_LT */
		/* 82068DA4h case   20:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82068DA4h case   20:*/		return 0x82068DA8;
	}
	return 0x82068DA8;
} // Block from 82068D54h-82068DA8h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82068DA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068DA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068DA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068DA8);
		  /* 82068DA8h */ case    0:  		/* li R11, 0 */
		/* 82068DA8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82068DA8h case    0:*/		return 0x82068DAC;
		  /* 82068DACh */ case    1:  		/* li R10, 7 */
		/* 82068DACh case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x7);
		/* 82068DACh case    1:*/		return 0x82068DB0;
		  /* 82068DB0h */ case    2:  		/* std R11, <#[R3]> */
		/* 82068DB0h case    2:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82068DB0h case    2:*/		return 0x82068DB4;
		  /* 82068DB4h */ case    3:  		/* li R9, 1 */
		/* 82068DB4h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82068DB4h case    3:*/		return 0x82068DB8;
		  /* 82068DB8h */ case    4:  		/* std R11, <#[R3 + 8]> */
		/* 82068DB8h case    4:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82068DB8h case    4:*/		return 0x82068DBC;
		  /* 82068DBCh */ case    5:  		/* lis R8, -1 */
		/* 82068DBCh case    5:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFFFFFF);
		/* 82068DBCh case    5:*/		return 0x82068DC0;
		  /* 82068DC0h */ case    6:  		/* std R11, <#[R3 + 16]> */
		/* 82068DC0h case    6:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82068DC0h case    6:*/		return 0x82068DC4;
		  /* 82068DC4h */ case    7:  		/* std R11, <#[R3 + 24]> */
		/* 82068DC4h case    7:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82068DC4h case    7:*/		return 0x82068DC8;
		  /* 82068DC8h */ case    8:  		/* std R11, <#[R3 + 32]> */
		/* 82068DC8h case    8:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000020) );
		/* 82068DC8h case    8:*/		return 0x82068DCC;
		  /* 82068DCCh */ case    9:  		/* stw R10, <#[R3]> */
		/* 82068DCCh case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82068DCCh case    9:*/		return 0x82068DD0;
		  /* 82068DD0h */ case   10:  		/* stw R9, <#[R3 + 4]> */
		/* 82068DD0h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000004) );
		/* 82068DD0h case   10:*/		return 0x82068DD4;
		  /* 82068DD4h */ case   11:  		/* stw R8, <#[R3 + 20]> */
		/* 82068DD4h case   11:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000014) );
		/* 82068DD4h case   11:*/		return 0x82068DD8;
		  /* 82068DD8h */ case   12:  		/* stw R4, <#[R3 + 24]> */
		/* 82068DD8h case   12:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000018) );
		/* 82068DD8h case   12:*/		return 0x82068DDC;
		  /* 82068DDCh */ case   13:  		/* bclr 20, CR0_LT */
		/* 82068DDCh case   13:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82068DDCh case   13:*/		return 0x82068DE0;
	}
	return 0x82068DE0;
} // Block from 82068DA8h-82068DE0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82068DE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068DE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068DE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068DE0);
		  /* 82068DE0h */ case    0:  		/* mfspr R12, LR */
		/* 82068DE0h case    0:*/		regs.R12 = regs.LR;
		/* 82068DE0h case    0:*/		return 0x82068DE4;
		  /* 82068DE4h */ case    1:  		/* bl 164980 */
		/* 82068DE4h case    1:*/		regs.LR = 0x82068DE8; return 0x82091258;
		/* 82068DE4h case    1:*/		return 0x82068DE8;
		  /* 82068DE8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82068DE8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82068DE8h case    2:*/		return 0x82068DEC;
		  /* 82068DECh */ case    3:  		/* lwz R31, <#[R3 + 13068]> */
		/* 82068DECh case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x0000330C) );
		/* 82068DECh case    3:*/		return 0x82068DF0;
		  /* 82068DF0h */ case    4:  		/* mr R30, R3 */
		/* 82068DF0h case    4:*/		regs.R30 = regs.R3;
		/* 82068DF0h case    4:*/		return 0x82068DF4;
		  /* 82068DF4h */ case    5:  		/* mr R29, R4 */
		/* 82068DF4h case    5:*/		regs.R29 = regs.R4;
		/* 82068DF4h case    5:*/		return 0x82068DF8;
		  /* 82068DF8h */ case    6:  		/* cmplwi CR6, R31, 0 */
		/* 82068DF8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82068DF8h case    6:*/		return 0x82068DFC;
		  /* 82068DFCh */ case    7:  		/* bc 12, CR6_EQ, 104 */
		/* 82068DFCh case    7:*/		if ( regs.CR[6].eq ) { return 0x82068E64;  }
		/* 82068DFCh case    7:*/		return 0x82068E00;
		  /* 82068E00h */ case    8:  		/* lwz R11, <#[R3 + 11036]> */
		/* 82068E00h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002B1C) );
		/* 82068E00h case    8:*/		return 0x82068E04;
		  /* 82068E04h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 82068E04h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82068E04h case    9:*/		return 0x82068E08;
	}
	return 0x82068E08;
} // Block from 82068DE0h-82068E08h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82068E08h
// Function '?AddVFetchWithSemantic@Microcode@CMicrocodeBuilder@D3D@@QAAKPATGPUVERTEX_FETCH_INSTRUCTION@@KH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068E08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068E08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068E08);
		  /* 82068E08h */ case    0:  		/* bc 12, CR6_EQ, 12 */
		/* 82068E08h case    0:*/		if ( regs.CR[6].eq ) { return 0x82068E14;  }
		/* 82068E08h case    0:*/		return 0x82068E0C;
		  /* 82068E0Ch */ case    1:  		/* stw R11, <#[R31 + 8]> */
		/* 82068E0Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82068E0Ch case    1:*/		return 0x82068E10;
		  /* 82068E10h */ case    2:  		/* b 84 */
		/* 82068E10h case    2:*/		return 0x82068E64;
		/* 82068E10h case    2:*/		return 0x82068E14;
	}
	return 0x82068E14;
} // Block from 82068E08h-82068E14h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82068E14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068E14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068E14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068E14);
		  /* 82068E14h */ case    0:  		/* lwz R11, <#[R30 + 11040]> */
		/* 82068E14h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00002B20) );
		/* 82068E14h case    0:*/		return 0x82068E18;
		  /* 82068E18h */ case    1:  		/* lwz R10, <#[R31]> */
		/* 82068E18h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82068E18h case    1:*/		return 0x82068E1C;
		  /* 82068E1Ch */ case    2:  		/* and. R11, R11, R10 */
		/* 82068E1Ch case    2:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82068E1Ch case    2:*/		return 0x82068E20;
		  /* 82068E20h */ case    3:  		/* bc 12, CR0_EQ, 68 */
		/* 82068E20h case    3:*/		if ( regs.CR[0].eq ) { return 0x82068E64;  }
		/* 82068E20h case    3:*/		return 0x82068E24;
		  /* 82068E24h */ case    4:  		/* lwz R11, <#[R30 + 13932]> */
		/* 82068E24h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000366C) );
		/* 82068E24h case    4:*/		return 0x82068E28;
		  /* 82068E28h */ case    5:  		/* lwz R3, <#[R30 + 13928]> */
		/* 82068E28h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00003668) );
		/* 82068E28h case    5:*/		return 0x82068E2C;
		  /* 82068E2Ch */ case    6:  		/* cmplw CR6, R3, R11 */
		/* 82068E2Ch case    6:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 82068E2Ch case    6:*/		return 0x82068E30;
		  /* 82068E30h */ case    7:  		/* bc 12, CR6_LT, 12 */
		/* 82068E30h case    7:*/		if ( regs.CR[6].lt ) { return 0x82068E3C;  }
		/* 82068E30h case    7:*/		return 0x82068E34;
		  /* 82068E34h */ case    8:  		/* mr R3, R30 */
		/* 82068E34h case    8:*/		regs.R3 = regs.R30;
		/* 82068E34h case    8:*/		return 0x82068E38;
		  /* 82068E38h */ case    9:  		/* bl 47928 */
		/* 82068E38h case    9:*/		regs.LR = 0x82068E3C; return 0x82074970;
		/* 82068E38h case    9:*/		return 0x82068E3C;
	}
	return 0x82068E3C;
} // Block from 82068E14h-82068E3Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 82068E3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068E3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068E3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068E3C);
		  /* 82068E3Ch */ case    0:  		/* lwz R11, <#[R1 + 80]> */
		/* 82068E3Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82068E3Ch case    0:*/		return 0x82068E40;
		  /* 82068E40h */ case    1:  		/* li R10, -1 */
		/* 82068E40h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 82068E40h case    1:*/		return 0x82068E44;
		  /* 82068E44h */ case    2:  		/* addi R9, R3, 8 */
		/* 82068E44h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R3,0x8);
		/* 82068E44h case    2:*/		return 0x82068E48;
		  /* 82068E48h */ case    3:  		/* rlwimi R11, R31, 30, 2, 31 */
		/* 82068E48h case    3:*/		cpu::op::rlwimi<0,30,2,31>(regs,&regs.R11,regs.R31);
		/* 82068E48h case    3:*/		return 0x82068E4C;
		  /* 82068E4Ch */ case    4:  		/* stw R10, <#[R1 + 84]> */
		/* 82068E4Ch case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 82068E4Ch case    4:*/		return 0x82068E50;
		  /* 82068E50h */ case    5:  		/* rlwinm R11, R11, 0, 2, 0 */
		/* 82068E50h case    5:*/		cpu::op::rlwinm<0,0,2,0>(regs,&regs.R11,regs.R11);
		/* 82068E50h case    5:*/		return 0x82068E54;
		  /* 82068E54h */ case    6:  		/* stw R11, <#[R1 + 80]> */
		/* 82068E54h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82068E54h case    6:*/		return 0x82068E58;
		  /* 82068E58h */ case    7:  		/* ld R11, <#[R1 + 80]> */
		/* 82068E58h case    7:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82068E58h case    7:*/		return 0x82068E5C;
		  /* 82068E5Ch */ case    8:  		/* std R11, <#[R3]> */
		/* 82068E5Ch case    8:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82068E5Ch case    8:*/		return 0x82068E60;
		  /* 82068E60h */ case    9:  		/* stw R9, <#[R30 + 13928]> */
		/* 82068E60h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R30 + 0x00003668) );
		/* 82068E60h case    9:*/		return 0x82068E64;
	}
	return 0x82068E64;
} // Block from 82068E3Ch-82068E64h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82068E64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068E64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068E64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068E64);
		  /* 82068E64h */ case    0:  		/* stw R29, <#[R30 + 13068]> */
		/* 82068E64h case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R30 + 0x0000330C) );
		/* 82068E64h case    0:*/		return 0x82068E68;
		  /* 82068E68h */ case    1:  		/* cmplwi CR6, R29, 0 */
		/* 82068E68h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82068E68h case    1:*/		return 0x82068E6C;
		  /* 82068E6Ch */ case    2:  		/* ld R11, <#[R30 + 16]> */
		/* 82068E6Ch case    2:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 82068E6Ch case    2:*/		return 0x82068E70;
		  /* 82068E70h */ case    3:  		/* oris R11, R11, 16 */
		/* 82068E70h case    3:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x10);
		/* 82068E70h case    3:*/		return 0x82068E74;
		  /* 82068E74h */ case    4:  		/* std R11, <#[R30 + 16]> */
		/* 82068E74h case    4:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 82068E74h case    4:*/		return 0x82068E78;
		  /* 82068E78h */ case    5:  		/* oris R11, R11, 2 */
		/* 82068E78h case    5:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82068E78h case    5:*/		return 0x82068E7C;
		  /* 82068E7Ch */ case    6:  		/* std R11, <#[R30 + 16]> */
		/* 82068E7Ch case    6:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 82068E7Ch case    6:*/		return 0x82068E80;
		  /* 82068E80h */ case    7:  		/* bc 12, CR6_EQ, 276 */
		/* 82068E80h case    7:*/		if ( regs.CR[6].eq ) { return 0x82068F94;  }
		/* 82068E80h case    7:*/		return 0x82068E84;
		  /* 82068E84h */ case    8:  		/* lwz R10, <#[R29 + 60]> */
		/* 82068E84h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x0000003C) );
		/* 82068E84h case    8:*/		return 0x82068E88;
		  /* 82068E88h */ case    9:  		/* addi R11, R29, 40 */
		/* 82068E88h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0x28);
		/* 82068E88h case    9:*/		return 0x82068E8C;
		  /* 82068E8Ch */ case   10:  		/* cmplwi CR6, R10, 0 */
		/* 82068E8Ch case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82068E8Ch case   10:*/		return 0x82068E90;
		  /* 82068E90h */ case   11:  		/* bc 12, CR6_EQ, 260 */
		/* 82068E90h case   11:*/		if ( regs.CR[6].eq ) { return 0x82068F94;  }
		/* 82068E90h case   11:*/		return 0x82068E94;
		  /* 82068E94h */ case   12:  		/* add R11, R10, R11 */
		/* 82068E94h case   12:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82068E94h case   12:*/		return 0x82068E98;
		  /* 82068E98h */ case   13:  		/* ld R10, <#[R30 + 8]> */
		/* 82068E98h case   13:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 82068E98h case   13:*/		return 0x82068E9C;
		  /* 82068E9Ch */ case   14:  		/* ld R9, <#[R11]> */
		/* 82068E9Ch case   14:*/		cpu::mem::load64( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82068E9Ch case   14:*/		return 0x82068EA0;
		  /* 82068EA0h */ case   15:  		/* andc R10, R10, R9 */
		/* 82068EA0h case   15:*/		cpu::op::andc<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82068EA0h case   15:*/		return 0x82068EA4;
		  /* 82068EA4h */ case   16:  		/* std R10, <#[R30 + 8]> */
		/* 82068EA4h case   16:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 82068EA4h case   16:*/		return 0x82068EA8;
		  /* 82068EA8h */ case   17:  		/* ld R10, <#[R11 + 8]> */
		/* 82068EA8h case   17:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82068EA8h case   17:*/		return 0x82068EAC;
		  /* 82068EACh */ case   18:  		/* cmpldi CR6, R10, 0 */
		/* 82068EACh case   18:*/		cpu::op::cmpldi<6>(regs,regs.R10,0x00000000);
		/* 82068EACh case   18:*/		return 0x82068EB0;
		  /* 82068EB0h */ case   19:  		/* bc 12, CR6_EQ, 24 */
		/* 82068EB0h case   19:*/		if ( regs.CR[6].eq ) { return 0x82068EC8;  }
		/* 82068EB0h case   19:*/		return 0x82068EB4;
		  /* 82068EB4h */ case   20:  		/* li R12, 1 */
		/* 82068EB4h case   20:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 82068EB4h case   20:*/		return 0x82068EB8;
		  /* 82068EB8h */ case   21:  		/* ld R10, <#[R30 + 32]> */
		/* 82068EB8h case   21:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R30 + 0x00000020) );
		/* 82068EB8h case   21:*/		return 0x82068EBC;
		  /* 82068EBCh */ case   22:  		/* rldicr R12, R12, 56, 63 */
		/* 82068EBCh case   22:*/		cpu::op::rldicr<0,56,63>(regs,&regs.R12,regs.R12);
		/* 82068EBCh case   22:*/		return 0x82068EC0;
		  /* 82068EC0h */ case   23:  		/* or R10, R10, R12 */
		/* 82068EC0h case   23:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R12);
		/* 82068EC0h case   23:*/		return 0x82068EC4;
		  /* 82068EC4h */ case   24:  		/* std R10, <#[R30 + 32]> */
		/* 82068EC4h case   24:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R30 + 0x00000020) );
		/* 82068EC4h case   24:*/		return 0x82068EC8;
	}
	return 0x82068EC8;
} // Block from 82068E64h-82068EC8h (25 instructions)

//////////////////////////////////////////////////////
// Block at 82068EC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068EC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068EC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068EC8);
		  /* 82068EC8h */ case    0:  		/* lwz R10, <#[R11 + 16]> */
		/* 82068EC8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 82068EC8h case    0:*/		return 0x82068ECC;
		  /* 82068ECCh */ case    1:  		/* addi R31, R11, 20 */
		/* 82068ECCh case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x14);
		/* 82068ECCh case    1:*/		return 0x82068ED0;
		  /* 82068ED0h */ case    2:  		/* addi R28, R30, 1152 */
		/* 82068ED0h case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R30,0x480);
		/* 82068ED0h case    2:*/		return 0x82068ED4;
		  /* 82068ED4h */ case    3:  		/* add R29, R10, R31 */
		/* 82068ED4h case    3:*/		cpu::op::add<0>(regs,&regs.R29,regs.R10,regs.R31);
		/* 82068ED4h case    3:*/		return 0x82068ED8;
		  /* 82068ED8h */ case    4:  		/* cmplw CR6, R31, R29 */
		/* 82068ED8h case    4:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R29);
		/* 82068ED8h case    4:*/		return 0x82068EDC;
		  /* 82068EDCh */ case    5:  		/* bc 4, CR6_LT, 184 */
		/* 82068EDCh case    5:*/		if ( !regs.CR[6].lt ) { return 0x82068F94;  }
		/* 82068EDCh case    5:*/		return 0x82068EE0;
		  /* 82068EE0h */ case    6:  		/* lhz R11, <#[R31 + 2]> */
		/* 82068EE0h case    6:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000002) );
		/* 82068EE0h case    6:*/		return 0x82068EE4;
		  /* 82068EE4h */ case    7:  		/* addi R31, R31, 4 */
		/* 82068EE4h case    7:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 82068EE4h case    7:*/		return 0x82068EE8;
		  /* 82068EE8h */ case    8:  		/* cmplwi CR0, R11, 0 */
		/* 82068EE8h case    8:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82068EE8h case    8:*/		return 0x82068EEC;
		  /* 82068EECh */ case    9:  		/* bc 12, CR0_EQ, 16 */
		/* 82068EECh case    9:*/		if ( regs.CR[0].eq ) { return 0x82068EFC;  }
		/* 82068EECh case    9:*/		return 0x82068EF0;
		  /* 82068EF0h */ case   10:  		/* addi R31, R31, 4 */
		/* 82068EF0h case   10:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 82068EF0h case   10:*/		return 0x82068EF4;
		  /* 82068EF4h */ case   11:  		/* cmplw CR6, R31, R29 */
		/* 82068EF4h case   11:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R29);
		/* 82068EF4h case   11:*/		return 0x82068EF8;
		  /* 82068EF8h */ case   12:  		/* bc 12, CR6_LT, -24 */
		/* 82068EF8h case   12:*/		if ( regs.CR[6].lt ) { return 0x82068EE0;  }
		/* 82068EF8h case   12:*/		return 0x82068EFC;
	}
	return 0x82068EFC;
} // Block from 82068EC8h-82068EFCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 82068EFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068EFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068EFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068EFC);
		  /* 82068EFCh */ case    0:  		/* cmplw CR6, R31, R29 */
		/* 82068EFCh case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R29);
		/* 82068EFCh case    0:*/		return 0x82068F00;
		  /* 82068F00h */ case    1:  		/* bc 4, CR6_LT, 148 */
		/* 82068F00h case    1:*/		if ( !regs.CR[6].lt ) { return 0x82068F94;  }
		/* 82068F00h case    1:*/		return 0x82068F04;
		  /* 82068F04h */ case    2:  		/* lhz R11, <#[R31 + 2]> */
		/* 82068F04h case    2:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000002) );
		/* 82068F04h case    2:*/		return 0x82068F08;
		  /* 82068F08h */ case    3:  		/* lhz R10, <#[R31]> */
		/* 82068F08h case    3:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82068F08h case    3:*/		return 0x82068F0C;
		  /* 82068F0Ch */ case    4:  		/* addi R31, R31, 4 */
		/* 82068F0Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 82068F0Ch case    4:*/		return 0x82068F10;
		  /* 82068F10h */ case    5:  		/* cmplwi CR0, R11, 0 */
		/* 82068F10h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82068F10h case    5:*/		return 0x82068F14;
		  /* 82068F14h */ case    6:  		/* bc 12, CR0_EQ, 120 */
		/* 82068F14h case    6:*/		if ( regs.CR[0].eq ) { return 0x82068F8C;  }
		/* 82068F14h case    6:*/		return 0x82068F18;
		  /* 82068F18h */ case    7:  		/* rlwinm R30, R11, 2, 0, 29 */
		/* 82068F18h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R11);
		/* 82068F18h case    7:*/		return 0x82068F1C;
		  /* 82068F1Ch */ case    8:  		/* rlwinm R11, R10, 0, 16, 31 */
		/* 82068F1Ch case    8:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R10);
		/* 82068F1Ch case    8:*/		return 0x82068F20;
	}
	return 0x82068F20;
} // Block from 82068EFCh-82068F20h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82068F20h
// Function '?RequiresVSOuputPatch@Microcode@CMicrocodeBuilder@D3D@@SAHPBTGPUALU_INSTRUCTION@@PAK@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068F20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068F20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068F20);
		  /* 82068F20h */ case    0:  		/* mr R5, R30 */
		/* 82068F20h case    0:*/		regs.R5 = regs.R30;
		/* 82068F20h case    0:*/		return 0x82068F24;
		  /* 82068F24h */ case    1:  		/* mr R4, R31 */
		/* 82068F24h case    1:*/		regs.R4 = regs.R31;
		/* 82068F24h case    1:*/		return 0x82068F28;
		  /* 82068F28h */ case    2:  		/* add R3, R11, R28 */
		/* 82068F28h case    2:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R28);
		/* 82068F28h case    2:*/		return 0x82068F2C;
		  /* 82068F2Ch */ case    3:  		/* bl 166532 */
		/* 82068F2Ch case    3:*/		regs.LR = 0x82068F30; return 0x820919B0;
		/* 82068F2Ch case    3:*/		return 0x82068F30;
		  /* 82068F30h */ case    4:  		/* add R31, R30, R31 */
		/* 82068F30h case    4:*/		cpu::op::add<0>(regs,&regs.R31,regs.R30,regs.R31);
		/* 82068F30h case    4:*/		return 0x82068F34;
		  /* 82068F34h */ case    5:  		/* cmplw CR6, R31, R29 */
		/* 82068F34h case    5:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R29);
		/* 82068F34h case    5:*/		return 0x82068F38;
		  /* 82068F38h */ case    6:  		/* bc 12, CR6_LT, -52 */
		/* 82068F38h case    6:*/		if ( regs.CR[6].lt ) { return 0x82068F04;  }
		/* 82068F38h case    6:*/		return 0x82068F3C;
		  /* 82068F3Ch */ case    7:  		/* b 80 */
		/* 82068F3Ch case    7:*/		return 0x82068F8C;
		/* 82068F3Ch case    7:*/		return 0x82068F40;
		  /* 82068F40h */ case    8:  		/* lhz R10, <#[R31 + 2]> */
		/* 82068F40h case    8:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000002) );
		/* 82068F40h case    8:*/		return 0x82068F44;
		  /* 82068F44h */ case    9:  		/* lhz R11, <#[R31]> */
		/* 82068F44h case    9:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82068F44h case    9:*/		return 0x82068F48;
		  /* 82068F48h */ case   10:  		/* addi R31, R31, 4 */
		/* 82068F48h case   10:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 82068F48h case   10:*/		return 0x82068F4C;
		  /* 82068F4Ch */ case   11:  		/* cmplwi CR0, R10, 0 */
		/* 82068F4Ch case   11:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 82068F4Ch case   11:*/		return 0x82068F50;
		  /* 82068F50h */ case   12:  		/* bc 12, CR0_EQ, 68 */
		/* 82068F50h case   12:*/		if ( regs.CR[0].eq ) { return 0x82068F94;  }
		/* 82068F50h case   12:*/		return 0x82068F54;
		  /* 82068F54h */ case   13:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 82068F54h case   13:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 82068F54h case   13:*/		return 0x82068F58;
		  /* 82068F58h */ case   14:  		/* add R11, R11, R28 */
		/* 82068F58h case   14:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R28);
		/* 82068F58h case   14:*/		return 0x82068F5C;
		  /* 82068F5Ch */ case   15:  		/* addi R11, R11, -4 */
		/* 82068F5Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 82068F5Ch case   15:*/		return 0x82068F60;
		  /* 82068F60h */ case   16:  		/* lwz R9, <#[R31]> */
		/* 82068F60h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82068F60h case   16:*/		return 0x82068F64;
		  /* 82068F64h */ case   17:  		/* addis R10, R10, 1 */
		/* 82068F64h case   17:*/		cpu::op::addis<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82068F64h case   17:*/		return 0x82068F68;
		  /* 82068F68h */ case   18:  		/* lwz R8, <#[R11 + 4]> */
		/* 82068F68h case   18:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 82068F68h case   18:*/		return 0x82068F6C;
		  /* 82068F6Ch */ case   19:  		/* lwz R7, <#[R31 + 4]> */
		/* 82068F6Ch case   19:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000004) );
		/* 82068F6Ch case   19:*/		return 0x82068F70;
		  /* 82068F70h */ case   20:  		/* addi R10, R10, -2 */
		/* 82068F70h case   20:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFE);
		/* 82068F70h case   20:*/		return 0x82068F74;
		  /* 82068F74h */ case   21:  		/* and R9, R8, R9 */
		/* 82068F74h case   21:*/		cpu::op::and<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 82068F74h case   21:*/		return 0x82068F78;
		  /* 82068F78h */ case   22:  		/* rlwinm. R10, R10, 0, 16, 31 */
		/* 82068F78h case   22:*/		cpu::op::rlwinm<1,0,16,31>(regs,&regs.R10,regs.R10);
		/* 82068F78h case   22:*/		return 0x82068F7C;
		  /* 82068F7Ch */ case   23:  		/* or R9, R9, R7 */
		/* 82068F7Ch case   23:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 82068F7Ch case   23:*/		return 0x82068F80;
		  /* 82068F80h */ case   24:  		/* addi R31, R31, 8 */
		/* 82068F80h case   24:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x8);
		/* 82068F80h case   24:*/		return 0x82068F84;
		  /* 82068F84h */ case   25:  		/* stwu R9, <#[R11 + 4]> */
		/* 82068F84h case   25:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82068F84h case   25:*/		return 0x82068F88;
		  /* 82068F88h */ case   26:  		/* bc 4, CR0_EQ, -40 */
		/* 82068F88h case   26:*/		if ( !regs.CR[0].eq ) { return 0x82068F60;  }
		/* 82068F88h case   26:*/		return 0x82068F8C;
	}
	return 0x82068F8C;
} // Block from 82068F20h-82068F8Ch (27 instructions)

//////////////////////////////////////////////////////
// Block at 82068F8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068F8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068F8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068F8C);
		  /* 82068F8Ch */ case    0:  		/* cmplw CR6, R31, R29 */
		/* 82068F8Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R29);
		/* 82068F8Ch case    0:*/		return 0x82068F90;
		  /* 82068F90h */ case    1:  		/* bc 12, CR6_LT, -80 */
		/* 82068F90h case    1:*/		if ( regs.CR[6].lt ) { return 0x82068F40;  }
		/* 82068F90h case    1:*/		return 0x82068F94;
	}
	return 0x82068F94;
} // Block from 82068F8Ch-82068F94h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82068F94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068F94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068F94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068F94);
		  /* 82068F94h */ case    0:  		/* addi R1, R1, 128 */
		/* 82068F94h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82068F94h case    0:*/		return 0x82068F98;
	}
	return 0x82068F98;
} // Block from 82068F94h-82068F98h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82068F98h
// Function '?AddALU@Microcode@CMicrocodeBuilder@D3D@@QAAKPATGPUALU_INSTRUCTION@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068F98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068F98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068F98);
		  /* 82068F98h */ case    0:  		/* b 164624 */
		/* 82068F98h case    0:*/		return 0x820912A8;
		/* 82068F98h case    0:*/		return 0x82068F9C;
		  /* 82068F9Ch */ case    1:  		/* nop */
		/* 82068F9Ch case    1:*/		cpu::op::nop();
		/* 82068F9Ch case    1:*/		return 0x82068FA0;
	}
	return 0x82068FA0;
} // Block from 82068F98h-82068FA0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82068FA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068FA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068FA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068FA0);
		  /* 82068FA0h */ case    0:  		/* mfspr R12, LR */
		/* 82068FA0h case    0:*/		regs.R12 = regs.LR;
		/* 82068FA0h case    0:*/		return 0x82068FA4;
		  /* 82068FA4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82068FA4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82068FA4h case    1:*/		return 0x82068FA8;
		  /* 82068FA8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82068FA8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82068FA8h case    2:*/		return 0x82068FAC;
		  /* 82068FACh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82068FACh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82068FACh case    3:*/		return 0x82068FB0;
		  /* 82068FB0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82068FB0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82068FB0h case    4:*/		return 0x82068FB4;
		  /* 82068FB4h */ case    5:  		/* lwz R31, <#[R3 + 13068]> */
		/* 82068FB4h case    5:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x0000330C) );
		/* 82068FB4h case    5:*/		return 0x82068FB8;
		  /* 82068FB8h */ case    6:  		/* mr R30, R4 */
		/* 82068FB8h case    6:*/		regs.R30 = regs.R4;
		/* 82068FB8h case    6:*/		return 0x82068FBC;
		  /* 82068FBCh */ case    7:  		/* cmplwi CR6, R31, 0 */
		/* 82068FBCh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82068FBCh case    7:*/		return 0x82068FC0;
		  /* 82068FC0h */ case    8:  		/* bc 12, CR6_EQ, 12 */
		/* 82068FC0h case    8:*/		if ( regs.CR[6].eq ) { return 0x82068FCC;  }
		/* 82068FC0h case    8:*/		return 0x82068FC4;
		  /* 82068FC4h */ case    9:  		/* mr R3, R31 */
		/* 82068FC4h case    9:*/		regs.R3 = regs.R31;
		/* 82068FC4h case    9:*/		return 0x82068FC8;
		  /* 82068FC8h */ case   10:  		/* bl 34320 */
		/* 82068FC8h case   10:*/		regs.LR = 0x82068FCC; return 0x820715D8;
		/* 82068FC8h case   10:*/		return 0x82068FCC;
	}
	return 0x82068FCC;
} // Block from 82068FA0h-82068FCCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 82068FCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068FCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068FCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068FCC);
		  /* 82068FCCh */ case    0:  		/* stw R31, <#[R30]> */
		/* 82068FCCh case    0:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000000) );
		/* 82068FCCh case    0:*/		return 0x82068FD0;
		  /* 82068FD0h */ case    1:  		/* addi R1, R1, 112 */
		/* 82068FD0h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82068FD0h case    1:*/		return 0x82068FD4;
		  /* 82068FD4h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 82068FD4h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82068FD4h case    2:*/		return 0x82068FD8;
		  /* 82068FD8h */ case    3:  		/* mtspr LR, R12 */
		/* 82068FD8h case    3:*/		regs.LR = regs.R12;
		/* 82068FD8h case    3:*/		return 0x82068FDC;
		  /* 82068FDCh */ case    4:  		/* ld R30, <#[R1 - 24]> */
		/* 82068FDCh case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82068FDCh case    4:*/		return 0x82068FE0;
		  /* 82068FE0h */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 82068FE0h case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82068FE0h case    5:*/		return 0x82068FE4;
		  /* 82068FE4h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82068FE4h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82068FE4h case    6:*/		return 0x82068FE8;
	}
	return 0x82068FE8;
} // Block from 82068FCCh-82068FE8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82068FE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82068FE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82068FE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82068FE8);
		  /* 82068FE8h */ case    0:  		/* mfspr R12, LR */
		/* 82068FE8h case    0:*/		regs.R12 = regs.LR;
		/* 82068FE8h case    0:*/		return 0x82068FEC;
		  /* 82068FECh */ case    1:  		/* bl 164460 */
		/* 82068FECh case    1:*/		regs.LR = 0x82068FF0; return 0x82091258;
		/* 82068FECh case    1:*/		return 0x82068FF0;
		  /* 82068FF0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82068FF0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82068FF0h case    2:*/		return 0x82068FF4;
		  /* 82068FF4h */ case    3:  		/* mr R30, R3 */
		/* 82068FF4h case    3:*/		regs.R30 = regs.R3;
		/* 82068FF4h case    3:*/		return 0x82068FF8;
		  /* 82068FF8h */ case    4:  		/* mr R29, R4 */
		/* 82068FF8h case    4:*/		regs.R29 = regs.R4;
		/* 82068FF8h case    4:*/		return 0x82068FFC;
		  /* 82068FFCh */ case    5:  		/* cmplwi CR6, R4, 0 */
		/* 82068FFCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 82068FFCh case    5:*/		return 0x82069000;
		  /* 82069000h */ case    6:  		/* bc 12, CR6_EQ, 16 */
		/* 82069000h case    6:*/		if ( regs.CR[6].eq ) { return 0x82069010;  }
		/* 82069000h case    6:*/		return 0x82069004;
		  /* 82069004h */ case    7:  		/* ld R11, <#[R3 + 16]> */
		/* 82069004h case    7:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82069004h case    7:*/		return 0x82069008;
		  /* 82069008h */ case    8:  		/* oris R11, R11, 8 */
		/* 82069008h case    8:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8);
		/* 82069008h case    8:*/		return 0x8206900C;
		  /* 8206900Ch */ case    9:  		/* std R11, <#[R3 + 16]> */
		/* 8206900Ch case    9:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8206900Ch case    9:*/		return 0x82069010;
	}
	return 0x82069010;
} // Block from 82068FE8h-82069010h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82069010h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069010( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069010) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069010);
		  /* 82069010h */ case    0:  		/* lwz R31, <#[R30 + 13072]> */
		/* 82069010h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00003310) );
		/* 82069010h case    0:*/		return 0x82069014;
		  /* 82069014h */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 82069014h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82069014h case    1:*/		return 0x82069018;
		  /* 82069018h */ case    2:  		/* bc 12, CR6_EQ, 104 */
		/* 82069018h case    2:*/		if ( regs.CR[6].eq ) { return 0x82069080;  }
		/* 82069018h case    2:*/		return 0x8206901C;
		  /* 8206901Ch */ case    3:  		/* lwz R11, <#[R30 + 11036]> */
		/* 8206901Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00002B1C) );
		/* 8206901Ch case    3:*/		return 0x82069020;
		  /* 82069020h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82069020h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82069020h case    4:*/		return 0x82069024;
		  /* 82069024h */ case    5:  		/* bc 12, CR6_EQ, 12 */
		/* 82069024h case    5:*/		if ( regs.CR[6].eq ) { return 0x82069030;  }
		/* 82069024h case    5:*/		return 0x82069028;
		  /* 82069028h */ case    6:  		/* stw R11, <#[R31 + 8]> */
		/* 82069028h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82069028h case    6:*/		return 0x8206902C;
		  /* 8206902Ch */ case    7:  		/* b 84 */
		/* 8206902Ch case    7:*/		return 0x82069080;
		/* 8206902Ch case    7:*/		return 0x82069030;
	}
	return 0x82069030;
} // Block from 82069010h-82069030h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82069030h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069030( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069030) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069030);
		  /* 82069030h */ case    0:  		/* lwz R11, <#[R30 + 11040]> */
		/* 82069030h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00002B20) );
		/* 82069030h case    0:*/		return 0x82069034;
		  /* 82069034h */ case    1:  		/* lwz R10, <#[R31]> */
		/* 82069034h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82069034h case    1:*/		return 0x82069038;
		  /* 82069038h */ case    2:  		/* and. R11, R11, R10 */
		/* 82069038h case    2:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82069038h case    2:*/		return 0x8206903C;
		  /* 8206903Ch */ case    3:  		/* bc 12, CR0_EQ, 68 */
		/* 8206903Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x82069080;  }
		/* 8206903Ch case    3:*/		return 0x82069040;
		  /* 82069040h */ case    4:  		/* lwz R11, <#[R30 + 13932]> */
		/* 82069040h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000366C) );
		/* 82069040h case    4:*/		return 0x82069044;
		  /* 82069044h */ case    5:  		/* lwz R3, <#[R30 + 13928]> */
		/* 82069044h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00003668) );
		/* 82069044h case    5:*/		return 0x82069048;
	}
	return 0x82069048;
} // Block from 82069030h-82069048h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82069048h
// Function '?SetSerialize@Microcode@CMicrocodeBuilder@D3D@@QAAXKH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069048( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069048) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069048);
		  /* 82069048h */ case    0:  		/* cmplw CR6, R3, R11 */
		/* 82069048h case    0:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R11);
		/* 82069048h case    0:*/		return 0x8206904C;
		  /* 8206904Ch */ case    1:  		/* bc 12, CR6_LT, 12 */
		/* 8206904Ch case    1:*/		if ( regs.CR[6].lt ) { return 0x82069058;  }
		/* 8206904Ch case    1:*/		return 0x82069050;
		  /* 82069050h */ case    2:  		/* mr R3, R30 */
		/* 82069050h case    2:*/		regs.R3 = regs.R30;
		/* 82069050h case    2:*/		return 0x82069054;
		  /* 82069054h */ case    3:  		/* bl 47388 */
		/* 82069054h case    3:*/		regs.LR = 0x82069058; return 0x82074970;
		/* 82069054h case    3:*/		return 0x82069058;
	}
	return 0x82069058;
} // Block from 82069048h-82069058h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82069058h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069058( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069058) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069058);
		  /* 82069058h */ case    0:  		/* lwz R11, <#[R1 + 80]> */
		/* 82069058h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82069058h case    0:*/		return 0x8206905C;
		  /* 8206905Ch */ case    1:  		/* li R10, -1 */
		/* 8206905Ch case    1:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 8206905Ch case    1:*/		return 0x82069060;
		  /* 82069060h */ case    2:  		/* addi R9, R3, 8 */
		/* 82069060h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R3,0x8);
		/* 82069060h case    2:*/		return 0x82069064;
		  /* 82069064h */ case    3:  		/* rlwimi R11, R31, 30, 2, 31 */
		/* 82069064h case    3:*/		cpu::op::rlwimi<0,30,2,31>(regs,&regs.R11,regs.R31);
		/* 82069064h case    3:*/		return 0x82069068;
		  /* 82069068h */ case    4:  		/* stw R10, <#[R1 + 84]> */
		/* 82069068h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 82069068h case    4:*/		return 0x8206906C;
		  /* 8206906Ch */ case    5:  		/* rlwinm R11, R11, 0, 2, 0 */
		/* 8206906Ch case    5:*/		cpu::op::rlwinm<0,0,2,0>(regs,&regs.R11,regs.R11);
		/* 8206906Ch case    5:*/		return 0x82069070;
		  /* 82069070h */ case    6:  		/* stw R11, <#[R1 + 80]> */
		/* 82069070h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82069070h case    6:*/		return 0x82069074;
		  /* 82069074h */ case    7:  		/* ld R11, <#[R1 + 80]> */
		/* 82069074h case    7:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82069074h case    7:*/		return 0x82069078;
		  /* 82069078h */ case    8:  		/* std R11, <#[R3]> */
		/* 82069078h case    8:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82069078h case    8:*/		return 0x8206907C;
		  /* 8206907Ch */ case    9:  		/* stw R9, <#[R30 + 13928]> */
		/* 8206907Ch case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R30 + 0x00003668) );
		/* 8206907Ch case    9:*/		return 0x82069080;
	}
	return 0x82069080;
} // Block from 82069058h-82069080h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82069080h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069080( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069080) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069080);
		  /* 82069080h */ case    0:  		/* lbz R11, <#[R30 + 11070]> */
		/* 82069080h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + 0x00002B3E) );
		/* 82069080h case    0:*/		return 0x82069084;
		  /* 82069084h */ case    1:  		/* cmplwi CR6, R29, 0 */
		/* 82069084h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82069084h case    1:*/		return 0x82069088;
		  /* 82069088h */ case    2:  		/* stw R29, <#[R30 + 13072]> */
		/* 82069088h case    2:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R30 + 0x00003310) );
		/* 82069088h case    2:*/		return 0x8206908C;
		  /* 8206908Ch */ case    3:  		/* rlwinm R11, R11, 0, 25, 31 */
		/* 8206908Ch case    3:*/		cpu::op::rlwinm<0,0,25,31>(regs,&regs.R11,regs.R11);
		/* 8206908Ch case    3:*/		return 0x82069090;
		  /* 82069090h */ case    4:  		/* stb R11, <#[R30 + 11070]> */
		/* 82069090h case    4:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R30 + 0x00002B3E) );
		/* 82069090h case    4:*/		return 0x82069094;
		  /* 82069094h */ case    5:  		/* bc 12, CR6_EQ, 280 */
		/* 82069094h case    5:*/		if ( regs.CR[6].eq ) { return 0x820691AC;  }
		/* 82069094h case    5:*/		return 0x82069098;
		  /* 82069098h */ case    6:  		/* addic. R11, R29, 872 */
		/* 82069098h case    6:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R29,0x368);
		/* 82069098h case    6:*/		return 0x8206909C;
		  /* 8206909Ch */ case    7:  		/* bc 12, CR0_EQ, 272 */
		/* 8206909Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x820691AC;  }
		/* 8206909Ch case    7:*/		return 0x820690A0;
		  /* 820690A0h */ case    8:  		/* lwz R10, <#[R11 + 20]> */
		/* 820690A0h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000014) );
		/* 820690A0h case    8:*/		return 0x820690A4;
		  /* 820690A4h */ case    9:  		/* cmplwi CR6, R10, 0 */
		/* 820690A4h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 820690A4h case    9:*/		return 0x820690A8;
		  /* 820690A8h */ case   10:  		/* bc 12, CR6_EQ, 260 */
		/* 820690A8h case   10:*/		if ( regs.CR[6].eq ) { return 0x820691AC;  }
		/* 820690A8h case   10:*/		return 0x820690AC;
		  /* 820690ACh */ case   11:  		/* add R11, R10, R11 */
		/* 820690ACh case   11:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820690ACh case   11:*/		return 0x820690B0;
		  /* 820690B0h */ case   12:  		/* ld R10, <#[R30]> */
		/* 820690B0h case   12:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 820690B0h case   12:*/		return 0x820690B4;
		  /* 820690B4h */ case   13:  		/* ld R9, <#[R11]> */
		/* 820690B4h case   13:*/		cpu::mem::load64( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 820690B4h case   13:*/		return 0x820690B8;
		  /* 820690B8h */ case   14:  		/* andc R10, R10, R9 */
		/* 820690B8h case   14:*/		cpu::op::andc<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 820690B8h case   14:*/		return 0x820690BC;
		  /* 820690BCh */ case   15:  		/* std R10, <#[R30]> */
		/* 820690BCh case   15:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 820690BCh case   15:*/		return 0x820690C0;
		  /* 820690C0h */ case   16:  		/* ld R10, <#[R11 + 8]> */
		/* 820690C0h case   16:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 820690C0h case   16:*/		return 0x820690C4;
		  /* 820690C4h */ case   17:  		/* cmpldi CR6, R10, 0 */
		/* 820690C4h case   17:*/		cpu::op::cmpldi<6>(regs,regs.R10,0x00000000);
		/* 820690C4h case   17:*/		return 0x820690C8;
		  /* 820690C8h */ case   18:  		/* bc 12, CR6_EQ, 24 */
		/* 820690C8h case   18:*/		if ( regs.CR[6].eq ) { return 0x820690E0;  }
		/* 820690C8h case   18:*/		return 0x820690CC;
		  /* 820690CCh */ case   19:  		/* li R12, 1 */
		/* 820690CCh case   19:*/		cpu::op::li<0>(regs,&regs.R12,0x1);
		/* 820690CCh case   19:*/		return 0x820690D0;
		  /* 820690D0h */ case   20:  		/* ld R10, <#[R30 + 32]> */
		/* 820690D0h case   20:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R30 + 0x00000020) );
		/* 820690D0h case   20:*/		return 0x820690D4;
		  /* 820690D4h */ case   21:  		/* rldicr R12, R12, 56, 63 */
		/* 820690D4h case   21:*/		cpu::op::rldicr<0,56,63>(regs,&regs.R12,regs.R12);
		/* 820690D4h case   21:*/		return 0x820690D8;
		  /* 820690D8h */ case   22:  		/* or R10, R10, R12 */
		/* 820690D8h case   22:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R12);
		/* 820690D8h case   22:*/		return 0x820690DC;
		  /* 820690DCh */ case   23:  		/* std R10, <#[R30 + 32]> */
		/* 820690DCh case   23:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R30 + 0x00000020) );
		/* 820690DCh case   23:*/		return 0x820690E0;
	}
	return 0x820690E0;
} // Block from 82069080h-820690E0h (24 instructions)

//////////////////////////////////////////////////////
// Block at 820690E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820690E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820690E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820690E0);
		  /* 820690E0h */ case    0:  		/* lwz R10, <#[R11 + 16]> */
		/* 820690E0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 820690E0h case    0:*/		return 0x820690E4;
		  /* 820690E4h */ case    1:  		/* addi R31, R11, 20 */
		/* 820690E4h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x14);
		/* 820690E4h case    1:*/		return 0x820690E8;
		  /* 820690E8h */ case    2:  		/* addi R28, R30, 1152 */
		/* 820690E8h case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R30,0x480);
		/* 820690E8h case    2:*/		return 0x820690EC;
		  /* 820690ECh */ case    3:  		/* add R29, R10, R31 */
		/* 820690ECh case    3:*/		cpu::op::add<0>(regs,&regs.R29,regs.R10,regs.R31);
		/* 820690ECh case    3:*/		return 0x820690F0;
		  /* 820690F0h */ case    4:  		/* cmplw CR6, R31, R29 */
		/* 820690F0h case    4:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R29);
		/* 820690F0h case    4:*/		return 0x820690F4;
		  /* 820690F4h */ case    5:  		/* bc 4, CR6_LT, 184 */
		/* 820690F4h case    5:*/		if ( !regs.CR[6].lt ) { return 0x820691AC;  }
		/* 820690F4h case    5:*/		return 0x820690F8;
		  /* 820690F8h */ case    6:  		/* lhz R11, <#[R31 + 2]> */
		/* 820690F8h case    6:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000002) );
		/* 820690F8h case    6:*/		return 0x820690FC;
		  /* 820690FCh */ case    7:  		/* addi R31, R31, 4 */
		/* 820690FCh case    7:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 820690FCh case    7:*/		return 0x82069100;
		  /* 82069100h */ case    8:  		/* cmplwi CR0, R11, 0 */
		/* 82069100h case    8:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82069100h case    8:*/		return 0x82069104;
		  /* 82069104h */ case    9:  		/* bc 12, CR0_EQ, 16 */
		/* 82069104h case    9:*/		if ( regs.CR[0].eq ) { return 0x82069114;  }
		/* 82069104h case    9:*/		return 0x82069108;
		  /* 82069108h */ case   10:  		/* addi R31, R31, 4 */
		/* 82069108h case   10:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 82069108h case   10:*/		return 0x8206910C;
		  /* 8206910Ch */ case   11:  		/* cmplw CR6, R31, R29 */
		/* 8206910Ch case   11:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R29);
		/* 8206910Ch case   11:*/		return 0x82069110;
		  /* 82069110h */ case   12:  		/* bc 12, CR6_LT, -24 */
		/* 82069110h case   12:*/		if ( regs.CR[6].lt ) { return 0x820690F8;  }
		/* 82069110h case   12:*/		return 0x82069114;
	}
	return 0x82069114;
} // Block from 820690E0h-82069114h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82069114h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069114( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069114) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069114);
		  /* 82069114h */ case    0:  		/* cmplw CR6, R31, R29 */
		/* 82069114h case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R29);
		/* 82069114h case    0:*/		return 0x82069118;
		  /* 82069118h */ case    1:  		/* bc 4, CR6_LT, 148 */
		/* 82069118h case    1:*/		if ( !regs.CR[6].lt ) { return 0x820691AC;  }
		/* 82069118h case    1:*/		return 0x8206911C;
		  /* 8206911Ch */ case    2:  		/* lhz R11, <#[R31 + 2]> */
		/* 8206911Ch case    2:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000002) );
		/* 8206911Ch case    2:*/		return 0x82069120;
		  /* 82069120h */ case    3:  		/* lhz R10, <#[R31]> */
		/* 82069120h case    3:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82069120h case    3:*/		return 0x82069124;
		  /* 82069124h */ case    4:  		/* addi R31, R31, 4 */
		/* 82069124h case    4:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 82069124h case    4:*/		return 0x82069128;
		  /* 82069128h */ case    5:  		/* cmplwi CR0, R11, 0 */
		/* 82069128h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82069128h case    5:*/		return 0x8206912C;
		  /* 8206912Ch */ case    6:  		/* bc 12, CR0_EQ, 120 */
		/* 8206912Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x820691A4;  }
		/* 8206912Ch case    6:*/		return 0x82069130;
		  /* 82069130h */ case    7:  		/* rlwinm R30, R11, 2, 0, 29 */
		/* 82069130h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R11);
		/* 82069130h case    7:*/		return 0x82069134;
		  /* 82069134h */ case    8:  		/* rlwinm R11, R10, 0, 16, 31 */
		/* 82069134h case    8:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R10);
		/* 82069134h case    8:*/		return 0x82069138;
		  /* 82069138h */ case    9:  		/* mr R5, R30 */
		/* 82069138h case    9:*/		regs.R5 = regs.R30;
		/* 82069138h case    9:*/		return 0x8206913C;
		  /* 8206913Ch */ case   10:  		/* mr R4, R31 */
		/* 8206913Ch case   10:*/		regs.R4 = regs.R31;
		/* 8206913Ch case   10:*/		return 0x82069140;
		  /* 82069140h */ case   11:  		/* add R3, R11, R28 */
		/* 82069140h case   11:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R28);
		/* 82069140h case   11:*/		return 0x82069144;
		  /* 82069144h */ case   12:  		/* bl 165996 */
		/* 82069144h case   12:*/		regs.LR = 0x82069148; return 0x820919B0;
		/* 82069144h case   12:*/		return 0x82069148;
		  /* 82069148h */ case   13:  		/* add R31, R30, R31 */
		/* 82069148h case   13:*/		cpu::op::add<0>(regs,&regs.R31,regs.R30,regs.R31);
		/* 82069148h case   13:*/		return 0x8206914C;
		  /* 8206914Ch */ case   14:  		/* cmplw CR6, R31, R29 */
		/* 8206914Ch case   14:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R29);
		/* 8206914Ch case   14:*/		return 0x82069150;
		  /* 82069150h */ case   15:  		/* bc 12, CR6_LT, -52 */
		/* 82069150h case   15:*/		if ( regs.CR[6].lt ) { return 0x8206911C;  }
		/* 82069150h case   15:*/		return 0x82069154;
		  /* 82069154h */ case   16:  		/* b 80 */
		/* 82069154h case   16:*/		return 0x820691A4;
		/* 82069154h case   16:*/		return 0x82069158;
		  /* 82069158h */ case   17:  		/* lhz R10, <#[R31 + 2]> */
		/* 82069158h case   17:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000002) );
		/* 82069158h case   17:*/		return 0x8206915C;
		  /* 8206915Ch */ case   18:  		/* lhz R11, <#[R31]> */
		/* 8206915Ch case   18:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8206915Ch case   18:*/		return 0x82069160;
		  /* 82069160h */ case   19:  		/* addi R31, R31, 4 */
		/* 82069160h case   19:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 82069160h case   19:*/		return 0x82069164;
		  /* 82069164h */ case   20:  		/* cmplwi CR0, R10, 0 */
		/* 82069164h case   20:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 82069164h case   20:*/		return 0x82069168;
		  /* 82069168h */ case   21:  		/* bc 12, CR0_EQ, 68 */
		/* 82069168h case   21:*/		if ( regs.CR[0].eq ) { return 0x820691AC;  }
		/* 82069168h case   21:*/		return 0x8206916C;
		  /* 8206916Ch */ case   22:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 8206916Ch case   22:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 8206916Ch case   22:*/		return 0x82069170;
		  /* 82069170h */ case   23:  		/* add R11, R11, R28 */
		/* 82069170h case   23:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R28);
		/* 82069170h case   23:*/		return 0x82069174;
		  /* 82069174h */ case   24:  		/* addi R11, R11, -4 */
		/* 82069174h case   24:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 82069174h case   24:*/		return 0x82069178;
		  /* 82069178h */ case   25:  		/* lwz R9, <#[R31]> */
		/* 82069178h case   25:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 82069178h case   25:*/		return 0x8206917C;
		  /* 8206917Ch */ case   26:  		/* addis R10, R10, 1 */
		/* 8206917Ch case   26:*/		cpu::op::addis<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8206917Ch case   26:*/		return 0x82069180;
		  /* 82069180h */ case   27:  		/* lwz R8, <#[R11 + 4]> */
		/* 82069180h case   27:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 82069180h case   27:*/		return 0x82069184;
		  /* 82069184h */ case   28:  		/* lwz R7, <#[R31 + 4]> */
		/* 82069184h case   28:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000004) );
		/* 82069184h case   28:*/		return 0x82069188;
		  /* 82069188h */ case   29:  		/* addi R10, R10, -2 */
		/* 82069188h case   29:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFE);
		/* 82069188h case   29:*/		return 0x8206918C;
		  /* 8206918Ch */ case   30:  		/* and R9, R8, R9 */
		/* 8206918Ch case   30:*/		cpu::op::and<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 8206918Ch case   30:*/		return 0x82069190;
		  /* 82069190h */ case   31:  		/* rlwinm. R10, R10, 0, 16, 31 */
		/* 82069190h case   31:*/		cpu::op::rlwinm<1,0,16,31>(regs,&regs.R10,regs.R10);
		/* 82069190h case   31:*/		return 0x82069194;
		  /* 82069194h */ case   32:  		/* or R9, R9, R7 */
		/* 82069194h case   32:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 82069194h case   32:*/		return 0x82069198;
		  /* 82069198h */ case   33:  		/* addi R31, R31, 8 */
		/* 82069198h case   33:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x8);
		/* 82069198h case   33:*/		return 0x8206919C;
		  /* 8206919Ch */ case   34:  		/* stwu R9, <#[R11 + 4]> */
		/* 8206919Ch case   34:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206919Ch case   34:*/		return 0x820691A0;
		  /* 820691A0h */ case   35:  		/* bc 4, CR0_EQ, -40 */
		/* 820691A0h case   35:*/		if ( !regs.CR[0].eq ) { return 0x82069178;  }
		/* 820691A0h case   35:*/		return 0x820691A4;
	}
	return 0x820691A4;
} // Block from 82069114h-820691A4h (36 instructions)

//////////////////////////////////////////////////////
// Block at 820691A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820691A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820691A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820691A4);
		  /* 820691A4h */ case    0:  		/* cmplw CR6, R31, R29 */
		/* 820691A4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R29);
		/* 820691A4h case    0:*/		return 0x820691A8;
	}
	return 0x820691A8;
} // Block from 820691A4h-820691A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820691A8h
// Function '?GetALU@Microcode@CMicrocodeBuilder@D3D@@QAAPATGPUSHADER_INSTRUCTION@@KPAH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820691A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820691A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820691A8);
		  /* 820691A8h */ case    0:  		/* bc 12, CR6_LT, -80 */
		/* 820691A8h case    0:*/		if ( regs.CR[6].lt ) { return 0x82069158;  }
		/* 820691A8h case    0:*/		return 0x820691AC;
	}
	return 0x820691AC;
} // Block from 820691A8h-820691ACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 820691ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820691AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820691AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820691AC);
		  /* 820691ACh */ case    0:  		/* addi R1, R1, 128 */
		/* 820691ACh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 820691ACh case    0:*/		return 0x820691B0;
		  /* 820691B0h */ case    1:  		/* b 164088 */
		/* 820691B0h case    1:*/		return 0x820912A8;
		/* 820691B0h case    1:*/		return 0x820691B4;
		  /* 820691B4h */ case    2:  		/* nop */
		/* 820691B4h case    2:*/		cpu::op::nop();
		/* 820691B4h case    2:*/		return 0x820691B8;
	}
	return 0x820691B8;
} // Block from 820691ACh-820691B8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820691B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820691B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820691B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820691B8);
		  /* 820691B8h */ case    0:  		/* mfspr R12, LR */
		/* 820691B8h case    0:*/		regs.R12 = regs.LR;
		/* 820691B8h case    0:*/		return 0x820691BC;
		  /* 820691BCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820691BCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820691BCh case    1:*/		return 0x820691C0;
		  /* 820691C0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 820691C0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820691C0h case    2:*/		return 0x820691C4;
		  /* 820691C4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 820691C4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820691C4h case    3:*/		return 0x820691C8;
		  /* 820691C8h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 820691C8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820691C8h case    4:*/		return 0x820691CC;
		  /* 820691CCh */ case    5:  		/* lwz R31, <#[R3 + 13072]> */
		/* 820691CCh case    5:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x00003310) );
		/* 820691CCh case    5:*/		return 0x820691D0;
		  /* 820691D0h */ case    6:  		/* mr R30, R4 */
		/* 820691D0h case    6:*/		regs.R30 = regs.R4;
		/* 820691D0h case    6:*/		return 0x820691D4;
		  /* 820691D4h */ case    7:  		/* cmplwi CR6, R31, 0 */
		/* 820691D4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 820691D4h case    7:*/		return 0x820691D8;
		  /* 820691D8h */ case    8:  		/* bc 12, CR6_EQ, 12 */
		/* 820691D8h case    8:*/		if ( regs.CR[6].eq ) { return 0x820691E4;  }
		/* 820691D8h case    8:*/		return 0x820691DC;
		  /* 820691DCh */ case    9:  		/* mr R3, R31 */
		/* 820691DCh case    9:*/		regs.R3 = regs.R31;
		/* 820691DCh case    9:*/		return 0x820691E0;
		  /* 820691E0h */ case   10:  		/* bl 33784 */
		/* 820691E0h case   10:*/		regs.LR = 0x820691E4; return 0x820715D8;
		/* 820691E0h case   10:*/		return 0x820691E4;
	}
	return 0x820691E4;
} // Block from 820691B8h-820691E4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 820691E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820691E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820691E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820691E4);
		  /* 820691E4h */ case    0:  		/* stw R31, <#[R30]> */
		/* 820691E4h case    0:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000000) );
		/* 820691E4h case    0:*/		return 0x820691E8;
		  /* 820691E8h */ case    1:  		/* addi R1, R1, 112 */
		/* 820691E8h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820691E8h case    1:*/		return 0x820691EC;
		  /* 820691ECh */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 820691ECh case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820691ECh case    2:*/		return 0x820691F0;
		  /* 820691F0h */ case    3:  		/* mtspr LR, R12 */
		/* 820691F0h case    3:*/		regs.LR = regs.R12;
		/* 820691F0h case    3:*/		return 0x820691F4;
		  /* 820691F4h */ case    4:  		/* ld R30, <#[R1 - 24]> */
		/* 820691F4h case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820691F4h case    4:*/		return 0x820691F8;
		  /* 820691F8h */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 820691F8h case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820691F8h case    5:*/		return 0x820691FC;
		  /* 820691FCh */ case    6:  		/* bclr 20, CR0_LT */
		/* 820691FCh case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820691FCh case    6:*/		return 0x82069200;
	}
	return 0x82069200;
} // Block from 820691E4h-82069200h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82069200h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069200( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069200) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069200);
		  /* 82069200h */ case    0:  		/* stw R4, <#[R3 + 12240]> */
		/* 82069200h case    0:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00002FD0) );
		/* 82069200h case    0:*/		return 0x82069204;
		  /* 82069204h */ case    1:  		/* ld R11, <#[R3 + 16]> */
		/* 82069204h case    1:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82069204h case    1:*/		return 0x82069208;
		  /* 82069208h */ case    2:  		/* oris R11, R11, 8 */
		/* 82069208h case    2:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x8);
		/* 82069208h case    2:*/		return 0x8206920C;
		  /* 8206920Ch */ case    3:  		/* std R11, <#[R3 + 16]> */
		/* 8206920Ch case    3:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8206920Ch case    3:*/		return 0x82069210;
		  /* 82069210h */ case    4:  		/* bclr 20, CR0_LT */
		/* 82069210h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82069210h case    4:*/		return 0x82069214;
	}
	return 0x82069214;
} // Block from 82069200h-82069214h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82069214h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069214( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069214) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069214);
		  /* 82069214h */ case    0:  		/* nop */
		/* 82069214h case    0:*/		cpu::op::nop();
		/* 82069214h case    0:*/		return 0x82069218;
	}
	return 0x82069218;
} // Block from 82069214h-82069218h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82069218h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069218( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069218) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069218);
		  /* 82069218h */ case    0:  		/* mfspr R12, LR */
		/* 82069218h case    0:*/		regs.R12 = regs.LR;
		/* 82069218h case    0:*/		return 0x8206921C;
		  /* 8206921Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8206921Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206921Ch case    1:*/		return 0x82069220;
		  /* 82069220h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82069220h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82069220h case    2:*/		return 0x82069224;
		  /* 82069224h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82069224h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82069224h case    3:*/		return 0x82069228;
		  /* 82069228h */ case    4:  		/* lwz R31, <#[R3 + 12240]> */
		/* 82069228h case    4:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x00002FD0) );
		/* 82069228h case    4:*/		return 0x8206922C;
		  /* 8206922Ch */ case    5:  		/* cmplwi CR6, R31, 0 */
		/* 8206922Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8206922Ch case    5:*/		return 0x82069230;
		  /* 82069230h */ case    6:  		/* bc 12, CR6_EQ, 12 */
		/* 82069230h case    6:*/		if ( regs.CR[6].eq ) { return 0x8206923C;  }
		/* 82069230h case    6:*/		return 0x82069234;
		  /* 82069234h */ case    7:  		/* mr R3, R31 */
		/* 82069234h case    7:*/		regs.R3 = regs.R31;
		/* 82069234h case    7:*/		return 0x82069238;
		  /* 82069238h */ case    8:  		/* bl 33696 */
		/* 82069238h case    8:*/		regs.LR = 0x8206923C; return 0x820715D8;
		/* 82069238h case    8:*/		return 0x8206923C;
	}
	return 0x8206923C;
} // Block from 82069218h-8206923Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8206923Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206923C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206923C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206923C);
		  /* 8206923Ch */ case    0:  		/* mr R3, R31 */
		/* 8206923Ch case    0:*/		regs.R3 = regs.R31;
		/* 8206923Ch case    0:*/		return 0x82069240;
		  /* 82069240h */ case    1:  		/* addi R1, R1, 96 */
		/* 82069240h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82069240h case    1:*/		return 0x82069244;
		  /* 82069244h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 82069244h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82069244h case    2:*/		return 0x82069248;
		  /* 82069248h */ case    3:  		/* mtspr LR, R12 */
		/* 82069248h case    3:*/		regs.LR = regs.R12;
		/* 82069248h case    3:*/		return 0x8206924C;
		  /* 8206924Ch */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 8206924Ch case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206924Ch case    4:*/		return 0x82069250;
		  /* 82069250h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82069250h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82069250h case    5:*/		return 0x82069254;
	}
	return 0x82069254;
} // Block from 8206923Ch-82069254h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82069254h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069254( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069254) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069254);
		  /* 82069254h */ case    0:  		/* nop */
		/* 82069254h case    0:*/		cpu::op::nop();
		/* 82069254h case    0:*/		return 0x82069258;
	}
	return 0x82069258;
} // Block from 82069254h-82069258h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82069258h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069258( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069258) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069258);
		  /* 82069258h */ case    0:  		/* mfspr R12, LR */
		/* 82069258h case    0:*/		regs.R12 = regs.LR;
		/* 82069258h case    0:*/		return 0x8206925C;
		  /* 8206925Ch */ case    1:  		/* bl 163832 */
		/* 8206925Ch case    1:*/		regs.LR = 0x82069260; return 0x82091254;
		/* 8206925Ch case    1:*/		return 0x82069260;
		  /* 82069260h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82069260h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82069260h case    2:*/		return 0x82069264;
		  /* 82069264h */ case    3:  		/* li R27, 0 */
		/* 82069264h case    3:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 82069264h case    3:*/		return 0x82069268;
	}
	return 0x82069268;
} // Block from 82069258h-82069268h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82069268h
// Function '?RenumberPSTemporaryRegistersVisitor@Microcode@CMicrocodeBuilder@D3D@@SAX_N00KPATGPUSHADER_INSTRUCTION@@PAX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069268( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069268) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069268);
		  /* 82069268h */ case    0:  		/* lhz R11, <#[R3]> */
		/* 82069268h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82069268h case    0:*/		return 0x8206926C;
		  /* 8206926Ch */ case    1:  		/* mr R29, R3 */
		/* 8206926Ch case    1:*/		regs.R29 = regs.R3;
		/* 8206926Ch case    1:*/		return 0x82069270;
		  /* 82069270h */ case    2:  		/* mr R31, R4 */
		/* 82069270h case    2:*/		regs.R31 = regs.R4;
		/* 82069270h case    2:*/		return 0x82069274;
		  /* 82069274h */ case    3:  		/* std R27, <#[R1 + 80]> */
		/* 82069274h case    3:*/		cpu::mem::store64( regs, regs.R27, (uint32)(regs.R1 + 0x00000050) );
		/* 82069274h case    3:*/		return 0x82069278;
		  /* 82069278h */ case    4:  		/* mr R10, R3 */
		/* 82069278h case    4:*/		regs.R10 = regs.R3;
		/* 82069278h case    4:*/		return 0x8206927C;
		  /* 8206927Ch */ case    5:  		/* std R27, <#[R1 + 88]> */
		/* 8206927Ch case    5:*/		cpu::mem::store64( regs, regs.R27, (uint32)(regs.R1 + 0x00000058) );
		/* 8206927Ch case    5:*/		return 0x82069280;
		  /* 82069280h */ case    6:  		/* mr R30, R27 */
		/* 82069280h case    6:*/		regs.R30 = regs.R27;
		/* 82069280h case    6:*/		return 0x82069284;
		  /* 82069284h */ case    7:  		/* mr R28, R27 */
		/* 82069284h case    7:*/		regs.R28 = regs.R27;
		/* 82069284h case    7:*/		return 0x82069288;
		  /* 82069288h */ case    8:  		/* b 40 */
		/* 82069288h case    8:*/		return 0x820692B0;
		/* 82069288h case    8:*/		return 0x8206928C;
		  /* 8206928Ch */ case    9:  		/* cmplw CR6, R28, R11 */
		/* 8206928Ch case    9:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 8206928Ch case    9:*/		return 0x82069290;
		  /* 82069290h */ case   10:  		/* bc 12, CR6_GT, 8 */
		/* 82069290h case   10:*/		if ( regs.CR[6].gt ) { return 0x82069298;  }
		/* 82069290h case   10:*/		return 0x82069294;
		  /* 82069294h */ case   11:  		/* mr R28, R11 */
		/* 82069294h case   11:*/		regs.R28 = regs.R11;
		/* 82069294h case   11:*/		return 0x82069298;
	}
	return 0x82069298;
} // Block from 82069268h-82069298h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82069298h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069298( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069298) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069298);
		  /* 82069298h */ case    0:  		/* addi R8, R1, 80 */
		/* 82069298h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x50);
		/* 82069298h case    0:*/		return 0x8206929C;
		  /* 8206929Ch */ case    1:  		/* lhzu R9, <#[R10 + 12]> */
		/* 8206929Ch case    1:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R10 + 0x0000000C) );
		regs.R10 = (uint32)(regs.R10 + 0x0000000C);
		/* 8206929Ch case    1:*/		return 0x820692A0;
		  /* 820692A0h */ case    2:  		/* li R7, 255 */
		/* 820692A0h case    2:*/		cpu::op::li<0>(regs,&regs.R7,0xFF);
		/* 820692A0h case    2:*/		return 0x820692A4;
		  /* 820692A4h */ case    3:  		/* addi R30, R30, 1 */
		/* 820692A4h case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 820692A4h case    3:*/		return 0x820692A8;
		  /* 820692A8h */ case    4:  		/* stbx R7, <#[R11 + R8]> */
		/* 820692A8h case    4:*/		cpu::mem::store8( regs, regs.R7, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 820692A8h case    4:*/		return 0x820692AC;
		  /* 820692ACh */ case    5:  		/* mr R11, R9 */
		/* 820692ACh case    5:*/		regs.R11 = regs.R9;
		/* 820692ACh case    5:*/		return 0x820692B0;
	}
	return 0x820692B0;
} // Block from 82069298h-820692B0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820692B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820692B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820692B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820692B0);
		  /* 820692B0h */ case    0:  		/* cmplwi CR6, R11, 255 */
		/* 820692B0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x000000FF);
		/* 820692B0h case    0:*/		return 0x820692B4;
		  /* 820692B4h */ case    1:  		/* bc 4, CR6_EQ, -40 */
		/* 820692B4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8206928C;  }
		/* 820692B4h case    1:*/		return 0x820692B8;
		  /* 820692B8h */ case    2:  		/* mulli R11, R30, 12 */
		/* 820692B8h case    2:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R30,0xC);
		/* 820692B8h case    2:*/		return 0x820692BC;
		  /* 820692BCh */ case    3:  		/* addi R5, R11, 56 */
		/* 820692BCh case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x38);
		/* 820692BCh case    3:*/		return 0x820692C0;
		  /* 820692C0h */ case    4:  		/* li R4, 0 */
		/* 820692C0h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820692C0h case    4:*/		return 0x820692C4;
		  /* 820692C4h */ case    5:  		/* mr R3, R31 */
		/* 820692C4h case    5:*/		regs.R3 = regs.R31;
		/* 820692C4h case    5:*/		return 0x820692C8;
		  /* 820692C8h */ case    6:  		/* bl 163960 */
		/* 820692C8h case    6:*/		regs.LR = 0x820692CC; return 0x82091340;
		/* 820692C8h case    6:*/		return 0x820692CC;
		  /* 820692CCh */ case    7:  		/* ld R11, <#[R1 + 80]> */
		/* 820692CCh case    7:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 820692CCh case    7:*/		return 0x820692D0;
		  /* 820692D0h */ case    8:  		/* ld R10, <#[R1 + 88]> */
		/* 820692D0h case    8:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 820692D0h case    8:*/		return 0x820692D4;
		  /* 820692D4h */ case    9:  		/* lis R9, 16 */
		/* 820692D4h case    9:*/		cpu::op::lis<0>(regs,&regs.R9,0x10);
		/* 820692D4h case    9:*/		return 0x820692D8;
		  /* 820692D8h */ case   10:  		/* li R8, 1 */
		/* 820692D8h case   10:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 820692D8h case   10:*/		return 0x820692DC;
		  /* 820692DCh */ case   11:  		/* stw R30, <#[R31 + 24]> */
		/* 820692DCh case   11:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000018) );
		/* 820692DCh case   11:*/		return 0x820692E0;
		  /* 820692E0h */ case   12:  		/* ori R9, R9, 5 */
		/* 820692E0h case   12:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x5);
		/* 820692E0h case   12:*/		return 0x820692E4;
		  /* 820692E4h */ case   13:  		/* stw R28, <#[R31 + 28]> */
		/* 820692E4h case   13:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x0000001C) );
		/* 820692E4h case   13:*/		return 0x820692E8;
		  /* 820692E8h */ case   14:  		/* lis R7, -1 */
		/* 820692E8h case   14:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFFFFFF);
		/* 820692E8h case   14:*/		return 0x820692EC;
		  /* 820692ECh */ case   15:  		/* stw R8, <#[R31 + 4]> */
		/* 820692ECh case   15:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00000004) );
		/* 820692ECh case   15:*/		return 0x820692F0;
		  /* 820692F0h */ case   16:  		/* stw R9, <#[R31]> */
		/* 820692F0h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 820692F0h case   16:*/		return 0x820692F4;
		  /* 820692F4h */ case   17:  		/* cmplwi CR6, R30, 0 */
		/* 820692F4h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 820692F4h case   17:*/		return 0x820692F8;
		  /* 820692F8h */ case   18:  		/* stw R7, <#[R31 + 20]> */
		/* 820692F8h case   18:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R31 + 0x00000014) );
		/* 820692F8h case   18:*/		return 0x820692FC;
		  /* 820692FCh */ case   19:  		/* stw R27, <#[R31 + 48]> */
		/* 820692FCh case   19:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00000030) );
		/* 820692FCh case   19:*/		return 0x82069300;
		  /* 82069300h */ case   20:  		/* std R11, <#[R31 + 32]> */
		/* 82069300h case   20:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 82069300h case   20:*/		return 0x82069304;
		  /* 82069304h */ case   21:  		/* std R10, <#[R31 + 40]> */
		/* 82069304h case   21:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R31 + 0x00000028) );
		/* 82069304h case   21:*/		return 0x82069308;
		  /* 82069308h */ case   22:  		/* bc 12, CR6_EQ, 52 */
		/* 82069308h case   22:*/		if ( regs.CR[6].eq ) { return 0x8206933C;  }
		/* 82069308h case   22:*/		return 0x8206930C;
		  /* 8206930Ch */ case   23:  		/* mr R11, R29 */
		/* 8206930Ch case   23:*/		regs.R11 = regs.R29;
		/* 8206930Ch case   23:*/		return 0x82069310;
		  /* 82069310h */ case   24:  		/* addi R10, R31, 52 */
		/* 82069310h case   24:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x34);
		/* 82069310h case   24:*/		return 0x82069314;
		  /* 82069314h */ case   25:  		/* lwz R9, <#[R11]> */
		/* 82069314h case   25:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82069314h case   25:*/		return 0x82069318;
		  /* 82069318h */ case   26:  		/* addic. R30, R30, -1 */
		/* 82069318h case   26:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R30,0xFFFFFFFF);
		/* 82069318h case   26:*/		return 0x8206931C;
		  /* 8206931Ch */ case   27:  		/* stw R9, <#[R10]> */
		/* 8206931Ch case   27:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 8206931Ch case   27:*/		return 0x82069320;
		  /* 82069320h */ case   28:  		/* lwz R9, <#[R11 + 4]> */
		/* 82069320h case   28:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 82069320h case   28:*/		return 0x82069324;
		  /* 82069324h */ case   29:  		/* stw R9, <#[R10 + 4]> */
		/* 82069324h case   29:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 82069324h case   29:*/		return 0x82069328;
		  /* 82069328h */ case   30:  		/* lwz R9, <#[R11 + 8]> */
		/* 82069328h case   30:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 82069328h case   30:*/		return 0x8206932C;
		  /* 8206932Ch */ case   31:  		/* addi R11, R11, 12 */
		/* 8206932Ch case   31:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xC);
		/* 8206932Ch case   31:*/		return 0x82069330;
		  /* 82069330h */ case   32:  		/* stw R9, <#[R10 + 8]> */
		/* 82069330h case   32:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 82069330h case   32:*/		return 0x82069334;
		  /* 82069334h */ case   33:  		/* addi R10, R10, 12 */
		/* 82069334h case   33:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xC);
		/* 82069334h case   33:*/		return 0x82069338;
		  /* 82069338h */ case   34:  		/* bc 4, CR0_EQ, -36 */
		/* 82069338h case   34:*/		if ( !regs.CR[0].eq ) { return 0x82069314;  }
		/* 82069338h case   34:*/		return 0x8206933C;
	}
	return 0x8206933C;
} // Block from 820692B0h-8206933Ch (35 instructions)

//////////////////////////////////////////////////////
// Block at 8206933Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206933C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206933C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206933C);
		  /* 8206933Ch */ case    0:  		/* addi R1, R1, 144 */
		/* 8206933Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8206933Ch case    0:*/		return 0x82069340;
		  /* 82069340h */ case    1:  		/* b 163684 */
		/* 82069340h case    1:*/		return 0x820912A4;
		/* 82069340h case    1:*/		return 0x82069344;
		  /* 82069344h */ case    2:  		/* nop */
		/* 82069344h case    2:*/		cpu::op::nop();
		/* 82069344h case    2:*/		return 0x82069348;
	}
	return 0x82069348;
} // Block from 8206933Ch-82069348h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82069348h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069348( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069348) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069348);
		  /* 82069348h */ case    0:  		/* mfspr R12, LR */
		/* 82069348h case    0:*/		regs.R12 = regs.LR;
		/* 82069348h case    0:*/		return 0x8206934C;
		  /* 8206934Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8206934Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206934Ch case    1:*/		return 0x82069350;
		  /* 82069350h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82069350h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82069350h case    2:*/		return 0x82069354;
		  /* 82069354h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82069354h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82069354h case    3:*/		return 0x82069358;
		  /* 82069358h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82069358h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82069358h case    4:*/		return 0x8206935C;
		  /* 8206935Ch */ case    5:  		/* lhz R9, <#[R3]> */
		/* 8206935Ch case    5:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 8206935Ch case    5:*/		return 0x82069360;
		  /* 82069360h */ case    6:  		/* mr R30, R3 */
		/* 82069360h case    6:*/		regs.R30 = regs.R3;
		/* 82069360h case    6:*/		return 0x82069364;
		  /* 82069364h */ case    7:  		/* mr R10, R3 */
		/* 82069364h case    7:*/		regs.R10 = regs.R3;
		/* 82069364h case    7:*/		return 0x82069368;
		  /* 82069368h */ case    8:  		/* li R11, 0 */
		/* 82069368h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82069368h case    8:*/		return 0x8206936C;
		  /* 8206936Ch */ case    9:  		/* b 12 */
		/* 8206936Ch case    9:*/		return 0x82069378;
		/* 8206936Ch case    9:*/		return 0x82069370;
		  /* 82069370h */ case   10:  		/* lhzu R9, <#[R10 + 12]> */
		/* 82069370h case   10:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R10 + 0x0000000C) );
		regs.R10 = (uint32)(regs.R10 + 0x0000000C);
		/* 82069370h case   10:*/		return 0x82069374;
		  /* 82069374h */ case   11:  		/* addi R11, R11, 1 */
		/* 82069374h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82069374h case   11:*/		return 0x82069378;
	}
	return 0x82069378;
} // Block from 82069348h-82069378h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82069378h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069378( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069378) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069378);
		  /* 82069378h */ case    0:  		/* cmplwi CR6, R9, 255 */
		/* 82069378h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x000000FF);
		/* 82069378h case    0:*/		return 0x8206937C;
		  /* 8206937Ch */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 8206937Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82069370;  }
		/* 8206937Ch case    1:*/		return 0x82069380;
		  /* 82069380h */ case    2:  		/* mulli R11, R11, 12 */
		/* 82069380h case    2:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 82069380h case    2:*/		return 0x82069384;
		  /* 82069384h */ case    3:  		/* lis R4, 9344 */
		/* 82069384h case    3:*/		cpu::op::lis<0>(regs,&regs.R4,0x2480);
		/* 82069384h case    3:*/		return 0x82069388;
		  /* 82069388h */ case    4:  		/* addi R3, R11, 56 */
		/* 82069388h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x38);
		/* 82069388h case    4:*/		return 0x8206938C;
		  /* 8206938Ch */ case    5:  		/* bl 126580 */
		/* 8206938Ch case    5:*/		regs.LR = 0x82069390; return 0x82088200;
		/* 8206938Ch case    5:*/		return 0x82069390;
		  /* 82069390h */ case    6:  		/* or. R31, R3, R3 */
		/* 82069390h case    6:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 82069390h case    6:*/		return 0x82069394;
		  /* 82069394h */ case    7:  		/* bc 4, CR0_EQ, 12 */
		/* 82069394h case    7:*/		if ( !regs.CR[0].eq ) { return 0x820693A0;  }
		/* 82069394h case    7:*/		return 0x82069398;
		  /* 82069398h */ case    8:  		/* li R3, 0 */
		/* 82069398h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82069398h case    8:*/		return 0x8206939C;
		  /* 8206939Ch */ case    9:  		/* b 20 */
		/* 8206939Ch case    9:*/		return 0x820693B0;
		/* 8206939Ch case    9:*/		return 0x820693A0;
	}
	return 0x820693A0;
} // Block from 82069378h-820693A0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820693A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820693A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820693A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820693A0);
		  /* 820693A0h */ case    0:  		/* mr R4, R31 */
		/* 820693A0h case    0:*/		regs.R4 = regs.R31;
		/* 820693A0h case    0:*/		return 0x820693A4;
		  /* 820693A4h */ case    1:  		/* mr R3, R30 */
		/* 820693A4h case    1:*/		regs.R3 = regs.R30;
		/* 820693A4h case    1:*/		return 0x820693A8;
		  /* 820693A8h */ case    2:  		/* bl -336 */
		/* 820693A8h case    2:*/		regs.LR = 0x820693AC; return 0x82069258;
		/* 820693A8h case    2:*/		return 0x820693AC;
		  /* 820693ACh */ case    3:  		/* mr R3, R31 */
		/* 820693ACh case    3:*/		regs.R3 = regs.R31;
		/* 820693ACh case    3:*/		return 0x820693B0;
	}
	return 0x820693B0;
} // Block from 820693A0h-820693B0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820693B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820693B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820693B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820693B0);
		  /* 820693B0h */ case    0:  		/* addi R1, R1, 112 */
		/* 820693B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820693B0h case    0:*/		return 0x820693B4;
		  /* 820693B4h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 820693B4h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820693B4h case    1:*/		return 0x820693B8;
		  /* 820693B8h */ case    2:  		/* mtspr LR, R12 */
		/* 820693B8h case    2:*/		regs.LR = regs.R12;
		/* 820693B8h case    2:*/		return 0x820693BC;
		  /* 820693BCh */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 820693BCh case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 820693BCh case    3:*/		return 0x820693C0;
	}
	return 0x820693C0;
} // Block from 820693B0h-820693C0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820693C0h
// Function '?RenumberVSOutputRegistersVisitor@Microcode@CMicrocodeBuilder@D3D@@SAX_N00KPATGPUSHADER_INSTRUCTION@@PAX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820693C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820693C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820693C0);
		  /* 820693C0h */ case    0:  		/* ld R31, <#[R1 - 16]> */
		/* 820693C0h case    0:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820693C0h case    0:*/		return 0x820693C4;
		  /* 820693C4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 820693C4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820693C4h case    1:*/		return 0x820693C8;
	}
	return 0x820693C8;
} // Block from 820693C0h-820693C8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820693C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820693C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820693C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820693C8);
		  /* 820693C8h */ case    0:  		/* mfspr R12, LR */
		/* 820693C8h case    0:*/		regs.R12 = regs.LR;
		/* 820693C8h case    0:*/		return 0x820693CC;
		  /* 820693CCh */ case    1:  		/* bl 163472 */
		/* 820693CCh case    1:*/		regs.LR = 0x820693D0; return 0x8209125C;
		/* 820693CCh case    1:*/		return 0x820693D0;
		  /* 820693D0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 820693D0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 820693D0h case    2:*/		return 0x820693D4;
		  /* 820693D4h */ case    3:  		/* mr R31, R3 */
		/* 820693D4h case    3:*/		regs.R31 = regs.R3;
		/* 820693D4h case    3:*/		return 0x820693D8;
		  /* 820693D8h */ case    4:  		/* mr R30, R5 */
		/* 820693D8h case    4:*/		regs.R30 = regs.R5;
		/* 820693D8h case    4:*/		return 0x820693DC;
		  /* 820693DCh */ case    5:  		/* cmplwi CR6, R5, 0 */
		/* 820693DCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 820693DCh case    5:*/		return 0x820693E0;
		  /* 820693E0h */ case    6:  		/* bc 4, CR6_EQ, 20 */
		/* 820693E0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x820693F4;  }
		/* 820693E0h case    6:*/		return 0x820693E4;
		  /* 820693E4h */ case    7:  		/* cmplwi CR6, R6, 0 */
		/* 820693E4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 820693E4h case    7:*/		return 0x820693E8;
		  /* 820693E8h */ case    8:  		/* bc 4, CR6_EQ, 12 */
		/* 820693E8h case    8:*/		if ( !regs.CR[6].eq ) { return 0x820693F4;  }
		/* 820693E8h case    8:*/		return 0x820693EC;
		  /* 820693ECh */ case    9:  		/* li R30, 64 */
		/* 820693ECh case    9:*/		cpu::op::li<0>(regs,&regs.R30,0x40);
		/* 820693ECh case    9:*/		return 0x820693F0;
	}
	return 0x820693F0;
} // Block from 820693C8h-820693F0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 820693F0h
// Function '?GetMaxGPRVisitor@Microcode@CMicrocodeBuilder@D3D@@SAX_N00KPATGPUSHADER_INSTRUCTION@@PAX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820693F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820693F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820693F0);
		  /* 820693F0h */ case    0:  		/* li R6, 64 */
		/* 820693F0h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x40);
		/* 820693F0h case    0:*/		return 0x820693F4;
	}
	return 0x820693F4;
} // Block from 820693F0h-820693F4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 820693F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820693F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820693F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820693F4);
		  /* 820693F4h */ case    0:  		/* rlwinm. R11, R4, 0, 31, 31 */
		/* 820693F4h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R4);
		/* 820693F4h case    0:*/		return 0x820693F8;
		  /* 820693F8h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 820693F8h case    1:*/		if ( regs.CR[0].eq ) { return 0x82069404;  }
		/* 820693F8h case    1:*/		return 0x820693FC;
		  /* 820693FCh */ case    2:  		/* li R11, 0 */
		/* 820693FCh case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820693FCh case    2:*/		return 0x82069400;
		  /* 82069400h */ case    3:  		/* b 20 */
		/* 82069400h case    3:*/		return 0x82069414;
		/* 82069400h case    3:*/		return 0x82069404;
	}
	return 0x82069404;
} // Block from 820693F4h-82069404h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82069404h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069404( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069404) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069404);
		  /* 82069404h */ case    0:  		/* lwz R11, <#[R31 + 11048]> */
		/* 82069404h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002B28) );
		/* 82069404h case    0:*/		return 0x82069408;
		  /* 82069408h */ case    1:  		/* rlwimi R6, R30, 8, 17, 23 */
		/* 82069408h case    1:*/		cpu::op::rlwimi<0,8,17,23>(regs,&regs.R6,regs.R30);
		/* 82069408h case    1:*/		return 0x8206940C;
		  /* 8206940Ch */ case    2:  		/* rlwimi R11, R6, 4, 21, 27 */
		/* 8206940Ch case    2:*/		cpu::op::rlwimi<0,4,21,27>(regs,&regs.R11,regs.R6);
		/* 8206940Ch case    2:*/		return 0x82069410;
		  /* 82069410h */ case    3:  		/* rlwimi R11, R6, 4, 13, 19 */
		/* 82069410h case    3:*/		cpu::op::rlwimi<0,4,13,19>(regs,&regs.R11,regs.R6);
		/* 82069410h case    3:*/		return 0x82069414;
	}
	return 0x82069414;
} // Block from 82069404h-82069414h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82069414h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069414( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069414) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069414);
		  /* 82069414h */ case    0:  		/* stw R11, <#[R31 + 11048]> */
		/* 82069414h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00002B28) );
		/* 82069414h case    0:*/		return 0x82069418;
		  /* 82069418h */ case    1:  		/* lwz R10, <#[R31 + 13092]> */
		/* 82069418h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00003324) );
		/* 82069418h case    1:*/		return 0x8206941C;
		  /* 8206941Ch */ case    2:  		/* lwz R9, <#[R31 + 56]> */
		/* 8206941Ch case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000038) );
		/* 8206941Ch case    2:*/		return 0x82069420;
		  /* 82069420h */ case    3:  		/* lwz R11, <#[R31 + 48]> */
		/* 82069420h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 82069420h case    3:*/		return 0x82069424;
		  /* 82069424h */ case    4:  		/* and R29, R10, R4 */
		/* 82069424h case    4:*/		cpu::op::and<0>(regs,&regs.R29,regs.R10,regs.R4);
		/* 82069424h case    4:*/		return 0x82069428;
		  /* 82069428h */ case    5:  		/* cmplw CR6, R11, R9 */
		/* 82069428h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82069428h case    5:*/		return 0x8206942C;
		  /* 8206942Ch */ case    6:  		/* bc 4, CR6_GT, 16 */
		/* 8206942Ch case    6:*/		if ( !regs.CR[6].gt ) { return 0x8206943C;  }
		/* 8206942Ch case    6:*/		return 0x82069430;
		  /* 82069430h */ case    7:  		/* mr R3, R31 */
		/* 82069430h case    7:*/		regs.R3 = regs.R31;
		/* 82069430h case    7:*/		return 0x82069434;
		  /* 82069434h */ case    8:  		/* bl 44244 */
		/* 82069434h case    8:*/		regs.LR = 0x82069438; return 0x82074108;
		/* 82069434h case    8:*/		return 0x82069438;
		  /* 82069438h */ case    9:  		/* mr R11, R3 */
		/* 82069438h case    9:*/		regs.R11 = regs.R3;
		/* 82069438h case    9:*/		return 0x8206943C;
	}
	return 0x8206943C;
} // Block from 82069414h-8206943Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8206943Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206943C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206943C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206943C);
		  /* 8206943Ch */ case    0:  		/* oris R9, R29, 49153 */
		/* 8206943Ch case    0:*/		cpu::op::oris<0>(regs,&regs.R9,regs.R29,0xC001);
		/* 8206943Ch case    0:*/		return 0x82069440;
		  /* 82069440h */ case    1:  		/* addi R8, R30, 1775 */
		/* 82069440h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R30,0x6EF);
		/* 82069440h case    1:*/		return 0x82069444;
		  /* 82069444h */ case    2:  		/* ori R9, R9, 16128 */
		/* 82069444h case    2:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x3F00);
		/* 82069444h case    2:*/		return 0x82069448;
		  /* 82069448h */ case    3:  		/* rlwinm R8, R8, 3, 0, 28 */
		/* 82069448h case    3:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R8,regs.R8);
		/* 82069448h case    3:*/		return 0x8206944C;
		  /* 8206944Ch */ case    4:  		/* stwu R9, <#[R11 + 4]> */
		/* 8206944Ch case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206944Ch case    4:*/		return 0x82069450;
		  /* 82069450h */ case    5:  		/* rlwinm R10, R30, 3, 0, 28 */
		/* 82069450h case    5:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R30);
		/* 82069450h case    5:*/		return 0x82069454;
		  /* 82069454h */ case    6:  		/* lwz R7, <#[R31 + 14192]> */
		/* 82069454h case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00003770) );
		/* 82069454h case    6:*/		return 0x82069458;
		  /* 82069458h */ case    7:  		/* mr R3, R31 */
		/* 82069458h case    7:*/		regs.R3 = regs.R31;
		/* 82069458h case    7:*/		return 0x8206945C;
		  /* 8206945Ch */ case    8:  		/* add R10, R10, R31 */
		/* 8206945Ch case    8:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R31);
		/* 8206945Ch case    8:*/		return 0x82069460;
		  /* 82069460h */ case    9:  		/* stwu R7, <#[R11 + 4]> */
		/* 82069460h case    9:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82069460h case    9:*/		return 0x82069464;
		  /* 82069464h */ case   10:  		/* lwz R7, <#[R31 + 14188]> */
		/* 82069464h case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x0000376C) );
		/* 82069464h case   10:*/		return 0x82069468;
		  /* 82069468h */ case   11:  		/* rlwinm R7, R7, 0, 8, 31 */
		/* 82069468h case   11:*/		cpu::op::rlwinm<0,0,8,31>(regs,&regs.R7,regs.R7);
		/* 82069468h case   11:*/		return 0x8206946C;
		  /* 8206946Ch */ case   12:  		/* stwu R7, <#[R11 + 4]> */
		/* 8206946Ch case   12:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206946Ch case   12:*/		return 0x82069470;
		  /* 82069470h */ case   13:  		/* stwu R9, <#[R11 + 4]> */
		/* 82069470h case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82069470h case   13:*/		return 0x82069474;
		  /* 82069474h */ case   14:  		/* lwzx R8, <#[R8 + R31]> */
		/* 82069474h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R31 + 0x00000000) );
		/* 82069474h case   14:*/		return 0x82069478;
		  /* 82069478h */ case   15:  		/* stwu R8, <#[R11 + 4]> */
		/* 82069478h case   15:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82069478h case   15:*/		return 0x8206947C;
		  /* 8206947Ch */ case   16:  		/* lwz R10, <#[R10 + 14196]> */
		/* 8206947Ch case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00003774) );
		/* 8206947Ch case   16:*/		return 0x82069480;
		  /* 82069480h */ case   17:  		/* rlwinm R10, R10, 0, 8, 31 */
		/* 82069480h case   17:*/		cpu::op::rlwinm<0,0,8,31>(regs,&regs.R10,regs.R10);
		/* 82069480h case   17:*/		return 0x82069484;
		  /* 82069484h */ case   18:  		/* stwu R10, <#[R11 + 4]> */
		/* 82069484h case   18:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82069484h case   18:*/		return 0x82069488;
		  /* 82069488h */ case   19:  		/* stwu R9, <#[R11 + 4]> */
		/* 82069488h case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82069488h case   19:*/		return 0x8206948C;
		  /* 8206948Ch */ case   20:  		/* lwz R10, <#[R31 + 15224]> */
		/* 8206948Ch case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00003B78) );
		/* 8206948Ch case   20:*/		return 0x82069490;
		  /* 82069490h */ case   21:  		/* stwu R10, <#[R11 + 4]> */
		/* 82069490h case   21:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82069490h case   21:*/		return 0x82069494;
		  /* 82069494h */ case   22:  		/* lwz R10, <#[R31 + 15220]> */
		/* 82069494h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00003B74) );
		/* 82069494h case   22:*/		return 0x82069498;
		  /* 82069498h */ case   23:  		/* rlwinm R10, R10, 0, 8, 31 */
		/* 82069498h case   23:*/		cpu::op::rlwinm<0,0,8,31>(regs,&regs.R10,regs.R10);
		/* 82069498h case   23:*/		return 0x8206949C;
		  /* 8206949Ch */ case   24:  		/* stwu R10, <#[R11 + 4]> */
		/* 8206949Ch case   24:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206949Ch case   24:*/		return 0x820694A0;
		  /* 820694A0h */ case   25:  		/* stw R11, <#[R31 + 48]> */
		/* 820694A0h case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 820694A0h case   25:*/		return 0x820694A4;
		  /* 820694A4h */ case   26:  		/* bl -3060 */
		/* 820694A4h case   26:*/		regs.LR = 0x820694A8; return 0x820688B0;
		/* 820694A4h case   26:*/		return 0x820694A8;
		  /* 820694A8h */ case   27:  		/* addi R1, R1, 112 */
		/* 820694A8h case   27:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 820694A8h case   27:*/		return 0x820694AC;
		  /* 820694ACh */ case   28:  		/* b 163328 */
		/* 820694ACh case   28:*/		return 0x820912AC;
		/* 820694ACh case   28:*/		return 0x820694B0;
		  /* 820694B0h */ case   29:  		/* lwz R11, <#[R3 + 11048]> */
		/* 820694B0h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002B28) );
		/* 820694B0h case   29:*/		return 0x820694B4;
		  /* 820694B4h */ case   30:  		/* rlwinm R11, R11, 0, 13, 19 */
		/* 820694B4h case   30:*/		cpu::op::rlwinm<0,0,13,19>(regs,&regs.R11,regs.R11);
		/* 820694B4h case   30:*/		return 0x820694B8;
		  /* 820694B8h */ case   31:  		/* cntlzw R11, R11 */
		/* 820694B8h case   31:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 820694B8h case   31:*/		return 0x820694BC;
		  /* 820694BCh */ case   32:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 820694BCh case   32:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 820694BCh case   32:*/		return 0x820694C0;
		  /* 820694C0h */ case   33:  		/* stw R11, <#[R4]> */
		/* 820694C0h case   33:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 820694C0h case   33:*/		return 0x820694C4;
		  /* 820694C4h */ case   34:  		/* lwz R11, <#[R3 + 11048]> */
		/* 820694C4h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002B28) );
		/* 820694C4h case   34:*/		return 0x820694C8;
		  /* 820694C8h */ case   35:  		/* rlwinm R11, R11, 20, 25, 31 */
		/* 820694C8h case   35:*/		cpu::op::rlwinm<0,20,25,31>(regs,&regs.R11,regs.R11);
		/* 820694C8h case   35:*/		return 0x820694CC;
		  /* 820694CCh */ case   36:  		/* stw R11, <#[R5]> */
		/* 820694CCh case   36:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 820694CCh case   36:*/		return 0x820694D0;
		  /* 820694D0h */ case   37:  		/* lwz R11, <#[R3 + 11048]> */
		/* 820694D0h case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002B28) );
		/* 820694D0h case   37:*/		return 0x820694D4;
		  /* 820694D4h */ case   38:  		/* rlwinm R11, R11, 28, 25, 31 */
		/* 820694D4h case   38:*/		cpu::op::rlwinm<0,28,25,31>(regs,&regs.R11,regs.R11);
		/* 820694D4h case   38:*/		return 0x820694D8;
		  /* 820694D8h */ case   39:  		/* stw R11, <#[R6]> */
		/* 820694D8h case   39:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R6 + 0x00000000) );
		/* 820694D8h case   39:*/		return 0x820694DC;
		  /* 820694DCh */ case   40:  		/* bclr 20, CR0_LT */
		/* 820694DCh case   40:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820694DCh case   40:*/		return 0x820694E0;
	}
	return 0x820694E0;
} // Block from 8206943Ch-820694E0h (41 instructions)

//////////////////////////////////////////////////////
// Block at 820694E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820694E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820694E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820694E0);
		  /* 820694E0h */ case    0:  		/* b 125480 */
		/* 820694E0h case    0:*/		return 0x82087F08;
		/* 820694E0h case    0:*/		return 0x820694E4;
		  /* 820694E4h */ case    1:  		/* nop */
		/* 820694E4h case    1:*/		cpu::op::nop();
		/* 820694E4h case    1:*/		return 0x820694E8;
	}
	return 0x820694E8;
} // Block from 820694E0h-820694E8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820694E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820694E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820694E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820694E8);
		  /* 820694E8h */ case    0:  		/* mfspr R12, LR */
		/* 820694E8h case    0:*/		regs.R12 = regs.LR;
		/* 820694E8h case    0:*/		return 0x820694EC;
		  /* 820694ECh */ case    1:  		/* bl 163180 */
		/* 820694ECh case    1:*/		regs.LR = 0x820694F0; return 0x82091258;
		/* 820694ECh case    1:*/		return 0x820694F0;
		  /* 820694F0h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 820694F0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 820694F0h case    2:*/		return 0x820694F4;
		  /* 820694F4h */ case    3:  		/* mr R31, R3 */
		/* 820694F4h case    3:*/		regs.R31 = regs.R3;
		/* 820694F4h case    3:*/		return 0x820694F8;
		  /* 820694F8h */ case    4:  		/* rlwinm. R29, R4, 0, 24, 31 */
		/* 820694F8h case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R29,regs.R4);
		/* 820694F8h case    4:*/		return 0x820694FC;
		  /* 820694FCh */ case    5:  		/* bc 4, CR0_EQ, 28 */
		/* 820694FCh case    5:*/		if ( !regs.CR[0].eq ) { return 0x82069518;  }
		/* 820694FCh case    5:*/		return 0x82069500;
		  /* 82069500h */ case    6:  		/* lis R11, -32250 */
		/* 82069500h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8206);
		/* 82069500h case    6:*/		return 0x82069504;
		  /* 82069504h */ case    7:  		/* lwz R4, <#[R3]> */
		/* 82069504h case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000000) );
		/* 82069504h case    7:*/		return 0x82069508;
	}
	return 0x82069508;
} // Block from 820694E8h-82069508h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82069508h
// Function '?IsExecPredicateClean@Microcode@CMicrocodeBuilder@D3D@@SA_NPATGPUFLOW_EXEC@@PATGPUSHADER_INSTRUCTION@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069508( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069508) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069508);
		  /* 82069508h */ case    0:  		/* li R5, 4 */
		/* 82069508h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x4);
		/* 82069508h case    0:*/		return 0x8206950C;
		  /* 8206950Ch */ case    1:  		/* addi R6, R11, 30264 */
		/* 8206950Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x7638);
		/* 8206950Ch case    1:*/		return 0x82069510;
		  /* 82069510h */ case    2:  		/* addi R3, R3, 4 */
		/* 82069510h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x4);
		/* 82069510h case    2:*/		return 0x82069514;
		  /* 82069514h */ case    3:  		/* bl 166604 */
		/* 82069514h case    3:*/		regs.LR = 0x82069518; return 0x82091FE0;
		/* 82069514h case    3:*/		return 0x82069518;
	}
	return 0x82069518;
} // Block from 82069508h-82069518h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82069518h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069518( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069518) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069518);
		  /* 82069518h */ case    0:  		/* addi R10, R1, 80 */
		/* 82069518h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 82069518h case    0:*/		return 0x8206951C;
		  /* 8206951Ch */ case    1:  		/* lwz R9, <#[R31]> */
		/* 8206951Ch case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8206951Ch case    1:*/		return 0x82069520;
		  /* 82069520h */ case    2:  		/* li R11, -1 */
		/* 82069520h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 82069520h case    2:*/		return 0x82069524;
		  /* 82069524h */ case    3:  		/* li R3, 1 */
		/* 82069524h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82069524h case    3:*/		return 0x82069528;
		  /* 82069528h */ case    4:  		/* li R30, 0 */
		/* 82069528h case    4:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82069528h case    4:*/		return 0x8206952C;
		  /* 8206952Ch */ case    5:  		/* li R4, 0 */
		/* 8206952Ch case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206952Ch case    5:*/		return 0x82069530;
		  /* 82069530h */ case    6:  		/* std R11, <#[R10]> */
		/* 82069530h case    6:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82069530h case    6:*/		return 0x82069534;
		  /* 82069534h */ case    7:  		/* li R5, 0 */
		/* 82069534h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82069534h case    7:*/		return 0x82069538;
		  /* 82069538h */ case    8:  		/* std R11, <#[R10 + 8]> */
		/* 82069538h case    8:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 82069538h case    8:*/		return 0x8206953C;
		  /* 8206953Ch */ case    9:  		/* li R6, 0 */
		/* 8206953Ch case    9:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8206953Ch case    9:*/		return 0x82069540;
		  /* 82069540h */ case   10:  		/* cmplwi CR6, R9, 0 */
		/* 82069540h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82069540h case   10:*/		return 0x82069544;
		  /* 82069544h */ case   11:  		/* bc 4, CR6_GT, 116 */
		/* 82069544h case   11:*/		if ( !regs.CR[6].gt ) { return 0x820695B8;  }
		/* 82069544h case   11:*/		return 0x82069548;
		  /* 82069548h */ case   12:  		/* mr R7, R31 */
		/* 82069548h case   12:*/		regs.R7 = regs.R31;
		/* 82069548h case   12:*/		return 0x8206954C;
		  /* 8206954Ch */ case   13:  		/* lwz R9, <#[R7 + 4]> */
		/* 8206954Ch case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R7 + 0x00000004) );
		/* 8206954Ch case   13:*/		return 0x82069550;
		  /* 82069550h */ case   14:  		/* addi R8, R1, 80 */
		/* 82069550h case   14:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x50);
		/* 82069550h case   14:*/		return 0x82069554;
		  /* 82069554h */ case   15:  		/* rlwinm R11, R9, 12, 28, 31 */
		/* 82069554h case   15:*/		cpu::op::rlwinm<0,12,28,31>(regs,&regs.R11,regs.R9);
		/* 82069554h case   15:*/		return 0x82069558;
		  /* 82069558h */ case   16:  		/* lbzx R10, <#[R11 + R8]> */
		/* 82069558h case   16:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82069558h case   16:*/		return 0x8206955C;
		  /* 8206955Ch */ case   17:  		/* cmplwi CR6, R10, 255 */
		/* 8206955Ch case   17:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x000000FF);
		/* 8206955Ch case   17:*/		return 0x82069560;
		  /* 82069560h */ case   18:  		/* bc 4, CR6_EQ, 64 */
		/* 82069560h case   18:*/		if ( !regs.CR[6].eq ) { return 0x820695A0;  }
		/* 82069560h case   18:*/		return 0x82069564;
		  /* 82069564h */ case   19:  		/* cmplwi CR6, R29, 0 */
		/* 82069564h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82069564h case   19:*/		return 0x82069568;
		  /* 82069568h */ case   20:  		/* bc 12, CR6_EQ, 12 */
		/* 82069568h case   20:*/		if ( regs.CR[6].eq ) { return 0x82069574;  }
		/* 82069568h case   20:*/		return 0x8206956C;
		  /* 8206956Ch */ case   21:  		/* mr R10, R11 */
		/* 8206956Ch case   21:*/		regs.R10 = regs.R11;
		/* 8206956Ch case   21:*/		return 0x82069570;
		  /* 82069570h */ case   22:  		/* b 12 */
		/* 82069570h case   22:*/		return 0x8206957C;
		/* 82069570h case   22:*/		return 0x82069574;
	}
	return 0x82069574;
} // Block from 82069518h-82069574h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82069574h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069574( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069574) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069574);
		  /* 82069574h */ case    0:  		/* mr R10, R30 */
		/* 82069574h case    0:*/		regs.R10 = regs.R30;
		/* 82069574h case    0:*/		return 0x82069578;
		  /* 82069578h */ case    1:  		/* addi R30, R30, 1 */
		/* 82069578h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82069578h case    1:*/		return 0x8206957C;
	}
	return 0x8206957C;
} // Block from 82069574h-8206957Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206957Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206957C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206957C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206957C);
		  /* 8206957Ch */ case    0:  		/* cmplwi CR6, R11, 16 */
		/* 8206957Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000010);
		/* 8206957Ch case    0:*/		return 0x82069580;
		  /* 82069580h */ case    1:  		/* stbx R10, <#[R11 + R8]> */
		/* 82069580h case    1:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 82069580h case    1:*/		return 0x82069584;
		  /* 82069584h */ case    2:  		/* bc 4, CR6_LT, 12 */
		/* 82069584h case    2:*/		if ( !regs.CR[6].lt ) { return 0x82069590;  }
		/* 82069584h case    2:*/		return 0x82069588;
		  /* 82069588h */ case    3:  		/* slw R11, R3, R11 */
		/* 82069588h case    3:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 82069588h case    3:*/		return 0x8206958C;
		  /* 8206958Ch */ case    4:  		/* or R4, R11, R4 */
		/* 8206958Ch case    4:*/		cpu::op::or<0>(regs,&regs.R4,regs.R11,regs.R4);
		/* 8206958Ch case    4:*/		return 0x82069590;
	}
	return 0x82069590;
} // Block from 8206957Ch-82069590h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82069590h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069590( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069590) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069590);
		  /* 82069590h */ case    0:  		/* cmplwi CR6, R10, 16 */
		/* 82069590h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000010);
		/* 82069590h case    0:*/		return 0x82069594;
		  /* 82069594h */ case    1:  		/* bc 4, CR6_LT, 12 */
		/* 82069594h case    1:*/		if ( !regs.CR[6].lt ) { return 0x820695A0;  }
		/* 82069594h case    1:*/		return 0x82069598;
		  /* 82069598h */ case    2:  		/* slw R11, R3, R10 */
		/* 82069598h case    2:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R3,regs.R10);
		/* 82069598h case    2:*/		return 0x8206959C;
		  /* 8206959Ch */ case    3:  		/* or R5, R11, R5 */
		/* 8206959Ch case    3:*/		cpu::op::or<0>(regs,&regs.R5,regs.R11,regs.R5);
		/* 8206959Ch case    3:*/		return 0x820695A0;
	}
	return 0x820695A0;
} // Block from 82069590h-820695A0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820695A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820695A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820695A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820695A0);
		  /* 820695A0h */ case    0:  		/* rlwimi R9, R10, 16, 12, 15 */
		/* 820695A0h case    0:*/		cpu::op::rlwimi<0,16,12,15>(regs,&regs.R9,regs.R10);
		/* 820695A0h case    0:*/		return 0x820695A4;
		  /* 820695A4h */ case    1:  		/* addi R6, R6, 1 */
		/* 820695A4h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 820695A4h case    1:*/		return 0x820695A8;
		  /* 820695A8h */ case    2:  		/* stwu R9, <#[R7 + 4]> */
		/* 820695A8h case    2:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R7 + 0x00000004) );
		regs.R7 = (uint32)(regs.R7 + 0x00000004);
		/* 820695A8h case    2:*/		return 0x820695AC;
		  /* 820695ACh */ case    3:  		/* lwz R11, <#[R31]> */
		/* 820695ACh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820695ACh case    3:*/		return 0x820695B0;
	}
	return 0x820695B0;
} // Block from 820695A0h-820695B0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820695B0h
// Function '?SetPredicateCleanBitsVisitor@Microcode@CMicrocodeBuilder@D3D@@SAX_N00KPATGPUSHADER_INSTRUCTION@@PAX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820695B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820695B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820695B0);
		  /* 820695B0h */ case    0:  		/* cmplw CR6, R6, R11 */
		/* 820695B0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 820695B0h case    0:*/		return 0x820695B4;
		  /* 820695B4h */ case    1:  		/* bc 12, CR6_LT, -104 */
		/* 820695B4h case    1:*/		if ( regs.CR[6].lt ) { return 0x8206954C;  }
		/* 820695B4h case    1:*/		return 0x820695B8;
	}
	return 0x820695B8;
} // Block from 820695B0h-820695B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 820695B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820695B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820695B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820695B8);
		  /* 820695B8h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 820695B8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 820695B8h case    0:*/		return 0x820695BC;
		  /* 820695BCh */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 820695BCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x820695CC;  }
		/* 820695BCh case    1:*/		return 0x820695C0;
		  /* 820695C0h */ case    2:  		/* cmplw CR6, R4, R5 */
		/* 820695C0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R5);
		/* 820695C0h case    2:*/		return 0x820695C4;
		  /* 820695C4h */ case    3:  		/* bc 12, CR6_EQ, 8 */
		/* 820695C4h case    3:*/		if ( regs.CR[6].eq ) { return 0x820695CC;  }
		/* 820695C4h case    3:*/		return 0x820695C8;
		  /* 820695C8h */ case    4:  		/* li R3, 0 */
		/* 820695C8h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 820695C8h case    4:*/		return 0x820695CC;
	}
	return 0x820695CC;
} // Block from 820695B8h-820695CCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 820695CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820695CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820695CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820695CC);
		  /* 820695CCh */ case    0:  		/* addi R1, R1, 144 */
		/* 820695CCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 820695CCh case    0:*/		return 0x820695D0;
		  /* 820695D0h */ case    1:  		/* b 163032 */
		/* 820695D0h case    1:*/		return 0x820912A8;
		/* 820695D0h case    1:*/		return 0x820695D4;
		  /* 820695D4h */ case    2:  		/* nop */
		/* 820695D4h case    2:*/		cpu::op::nop();
		/* 820695D4h case    2:*/		return 0x820695D8;
	}
	return 0x820695D8;
} // Block from 820695CCh-820695D8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 820695D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820695D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820695D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820695D8);
		  /* 820695D8h */ case    0:  		/* mfspr R12, LR */
		/* 820695D8h case    0:*/		regs.R12 = regs.LR;
		/* 820695D8h case    0:*/		return 0x820695DC;
		  /* 820695DCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 820695DCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 820695DCh case    1:*/		return 0x820695E0;
		  /* 820695E0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 820695E0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 820695E0h case    2:*/		return 0x820695E4;
		  /* 820695E4h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 820695E4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 820695E4h case    3:*/		return 0x820695E8;
		  /* 820695E8h */ case    4:  		/* li R11, 0 */
		/* 820695E8h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820695E8h case    4:*/		return 0x820695EC;
		  /* 820695ECh */ case    5:  		/* stw R4, <#[R3 + 9572]> */
		/* 820695ECh case    5:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00002564) );
		/* 820695ECh case    5:*/		return 0x820695F0;
		  /* 820695F0h */ case    6:  		/* li R5, 9120 */
		/* 820695F0h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x23A0);
		/* 820695F0h case    6:*/		return 0x820695F4;
		  /* 820695F4h */ case    7:  		/* stw R11, <#[R3 + 9568]> */
		/* 820695F4h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00002560) );
		/* 820695F4h case    7:*/		return 0x820695F8;
		  /* 820695F8h */ case    8:  		/* li R4, 0 */
		/* 820695F8h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820695F8h case    8:*/		return 0x820695FC;
		  /* 820695FCh */ case    9:  		/* std R11, <#[R3 + 9120]> */
		/* 820695FCh case    9:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x000023A0) );
		/* 820695FCh case    9:*/		return 0x82069600;
		  /* 82069600h */ case   10:  		/* mr R31, R3 */
		/* 82069600h case   10:*/		regs.R31 = regs.R3;
		/* 82069600h case   10:*/		return 0x82069604;
		  /* 82069604h */ case   11:  		/* std R11, <#[R3 + 9128]> */
		/* 82069604h case   11:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x000023A8) );
		/* 82069604h case   11:*/		return 0x82069608;
		  /* 82069608h */ case   12:  		/* std R11, <#[R3 + 9136]> */
		/* 82069608h case   12:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x000023B0) );
		/* 82069608h case   12:*/		return 0x8206960C;
		  /* 8206960Ch */ case   13:  		/* bl 163124 */
		/* 8206960Ch case   13:*/		regs.LR = 0x82069610; return 0x82091340;
		/* 8206960Ch case   13:*/		return 0x82069610;
		  /* 82069610h */ case   14:  		/* li R5, 288 */
		/* 82069610h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0x120);
		/* 82069610h case   14:*/		return 0x82069614;
		  /* 82069614h */ case   15:  		/* li R4, 0 */
		/* 82069614h case   15:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82069614h case   15:*/		return 0x82069618;
		  /* 82069618h */ case   16:  		/* addi R3, R31, 9208 */
		/* 82069618h case   16:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x23F8);
		/* 82069618h case   16:*/		return 0x8206961C;
		  /* 8206961Ch */ case   17:  		/* bl 163108 */
		/* 8206961Ch case   17:*/		regs.LR = 0x82069620; return 0x82091340;
		/* 8206961Ch case   17:*/		return 0x82069620;
		  /* 82069620h */ case   18:  		/* li R5, 32 */
		/* 82069620h case   18:*/		cpu::op::li<0>(regs,&regs.R5,0x20);
		/* 82069620h case   18:*/		return 0x82069624;
		  /* 82069624h */ case   19:  		/* li R4, 0 */
		/* 82069624h case   19:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82069624h case   19:*/		return 0x82069628;
		  /* 82069628h */ case   20:  		/* addi R3, R31, 9496 */
		/* 82069628h case   20:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x2518);
		/* 82069628h case   20:*/		return 0x8206962C;
		  /* 8206962Ch */ case   21:  		/* bl 163092 */
		/* 8206962Ch case   21:*/		regs.LR = 0x82069630; return 0x82091340;
		/* 8206962Ch case   21:*/		return 0x82069630;
		  /* 82069630h */ case   22:  		/* li R5, 32 */
		/* 82069630h case   22:*/		cpu::op::li<0>(regs,&regs.R5,0x20);
		/* 82069630h case   22:*/		return 0x82069634;
		  /* 82069634h */ case   23:  		/* li R4, 0 */
		/* 82069634h case   23:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82069634h case   23:*/		return 0x82069638;
		  /* 82069638h */ case   24:  		/* addi R3, R31, 9528 */
		/* 82069638h case   24:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x2538);
		/* 82069638h case   24:*/		return 0x8206963C;
		  /* 8206963Ch */ case   25:  		/* bl 163076 */
		/* 8206963Ch case   25:*/		regs.LR = 0x82069640; return 0x82091340;
		/* 8206963Ch case   25:*/		return 0x82069640;
		  /* 82069640h */ case   26:  		/* li R5, 64 */
		/* 82069640h case   26:*/		cpu::op::li<0>(regs,&regs.R5,0x40);
		/* 82069640h case   26:*/		return 0x82069644;
		  /* 82069644h */ case   27:  		/* li R4, 0 */
		/* 82069644h case   27:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82069644h case   27:*/		return 0x82069648;
		  /* 82069648h */ case   28:  		/* addi R3, R31, 9144 */
		/* 82069648h case   28:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x23B8);
		/* 82069648h case   28:*/		return 0x8206964C;
		  /* 8206964Ch */ case   29:  		/* bl 163060 */
		/* 8206964Ch case   29:*/		regs.LR = 0x82069650; return 0x82091340;
		/* 8206964Ch case   29:*/		return 0x82069650;
		  /* 82069650h */ case   30:  		/* addi R1, R1, 96 */
		/* 82069650h case   30:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82069650h case   30:*/		return 0x82069654;
		  /* 82069654h */ case   31:  		/* lwz R12, <#[R1 - 8]> */
		/* 82069654h case   31:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82069654h case   31:*/		return 0x82069658;
		  /* 82069658h */ case   32:  		/* mtspr LR, R12 */
		/* 82069658h case   32:*/		regs.LR = regs.R12;
		/* 82069658h case   32:*/		return 0x8206965C;
		  /* 8206965Ch */ case   33:  		/* ld R31, <#[R1 - 16]> */
		/* 8206965Ch case   33:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206965Ch case   33:*/		return 0x82069660;
		  /* 82069660h */ case   34:  		/* bclr 20, CR0_LT */
		/* 82069660h case   34:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82069660h case   34:*/		return 0x82069664;
	}
	return 0x82069664;
} // Block from 820695D8h-82069664h (35 instructions)

//////////////////////////////////////////////////////
// Block at 82069664h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069664( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069664) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069664);
		  /* 82069664h */ case    0:  		/* nop */
		/* 82069664h case    0:*/		cpu::op::nop();
		/* 82069664h case    0:*/		return 0x82069668;
		  /* 82069668h */ case    1:  		/* li R11, 0 */
		/* 82069668h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82069668h case    1:*/		return 0x8206966C;
		  /* 8206966Ch */ case    2:  		/* li R9, 1 */
		/* 8206966Ch case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8206966Ch case    2:*/		return 0x82069670;
		  /* 82069670h */ case    3:  		/* cmpwi CR6, R5, 0 */
		/* 82069670h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 82069670h case    3:*/		return 0x82069674;
		  /* 82069674h */ case    4:  		/* stw R11, <#[R3 + 9564]> */
		/* 82069674h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000255C) );
		/* 82069674h case    4:*/		return 0x82069678;
		  /* 82069678h */ case    5:  		/* bc 12, CR6_EQ, 32 */
		/* 82069678h case    5:*/		if ( regs.CR[6].eq ) { return 0x82069698;  }
		/* 82069678h case    5:*/		return 0x8206967C;
		  /* 8206967Ch */ case    6:  		/* addi R11, R3, 9496 */
		/* 8206967Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x2518);
		/* 8206967Ch case    6:*/		return 0x82069680;
	}
	return 0x82069680;
} // Block from 82069664h-82069680h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82069680h
// Function '?CreateVSOutputPatchesVisitor@Microcode@CMicrocodeBuilder@D3D@@SAX_N00KPATGPUSHADER_INSTRUCTION@@PAX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069680( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069680) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069680);
		  /* 82069680h */ case    0:  		/* rlwinm R10, R4, 29, 3, 29 */
		/* 82069680h case    0:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R10,regs.R4);
		/* 82069680h case    0:*/		return 0x82069684;
		  /* 82069684h */ case    1:  		/* rlwinm R8, R4, 0, 27, 31 */
		/* 82069684h case    1:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R8,regs.R4);
		/* 82069684h case    1:*/		return 0x82069688;
		  /* 82069688h */ case    2:  		/* slw R8, R9, R8 */
		/* 82069688h case    2:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R9,regs.R8);
		/* 82069688h case    2:*/		return 0x8206968C;
		  /* 8206968Ch */ case    3:  		/* lwzx R7, <#[R10 + R11]> */
		/* 8206968Ch case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8206968Ch case    3:*/		return 0x82069690;
		  /* 82069690h */ case    4:  		/* or R8, R8, R7 */
		/* 82069690h case    4:*/		cpu::op::or<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 82069690h case    4:*/		return 0x82069694;
		  /* 82069694h */ case    5:  		/* stwx R8, <#[R10 + R11]> */
		/* 82069694h case    5:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82069694h case    5:*/		return 0x82069698;
	}
	return 0x82069698;
} // Block from 82069680h-82069698h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82069698h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069698( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069698) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069698);
		  /* 82069698h */ case    0:  		/* addi R11, R3, 9528 */
		/* 82069698h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x2538);
		/* 82069698h case    0:*/		return 0x8206969C;
		  /* 8206969Ch */ case    1:  		/* rlwinm R10, R4, 29, 3, 29 */
		/* 8206969Ch case    1:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R10,regs.R4);
		/* 8206969Ch case    1:*/		return 0x820696A0;
		  /* 820696A0h */ case    2:  		/* rlwinm R8, R4, 0, 27, 31 */
		/* 820696A0h case    2:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R8,regs.R4);
		/* 820696A0h case    2:*/		return 0x820696A4;
		  /* 820696A4h */ case    3:  		/* rlwinm R7, R4, 27, 5, 31 */
		/* 820696A4h case    3:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R7,regs.R4);
		/* 820696A4h case    3:*/		return 0x820696A8;
		  /* 820696A8h */ case    4:  		/* slw R8, R9, R8 */
		/* 820696A8h case    4:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R9,regs.R8);
		/* 820696A8h case    4:*/		return 0x820696AC;
		  /* 820696ACh */ case    5:  		/* lwzx R6, <#[R10 + R11]> */
		/* 820696ACh case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820696ACh case    5:*/		return 0x820696B0;
		  /* 820696B0h */ case    6:  		/* subfic R7, R7, 31 */
		/* 820696B0h case    6:*/		cpu::op::subfic<0>(regs,&regs.R7,regs.R7,0x1F);
		/* 820696B0h case    6:*/		return 0x820696B4;
		  /* 820696B4h */ case    7:  		/* or R8, R8, R6 */
		/* 820696B4h case    7:*/		cpu::op::or<0>(regs,&regs.R8,regs.R8,regs.R6);
		/* 820696B4h case    7:*/		return 0x820696B8;
		  /* 820696B8h */ case    8:  		/* rldicl R7, R7, 0, 32 */
		/* 820696B8h case    8:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R7,regs.R7);
		/* 820696B8h case    8:*/		return 0x820696BC;
		  /* 820696BCh */ case    9:  		/* stwx R8, <#[R10 + R11]> */
		/* 820696BCh case    9:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 820696BCh case    9:*/		return 0x820696C0;
		  /* 820696C0h */ case   10:  		/* sld R11, R9, R7 */
		/* 820696C0h case   10:*/		cpu::op::sld<0>(regs,&regs.R11,regs.R9,regs.R7);
		/* 820696C0h case   10:*/		return 0x820696C4;
		  /* 820696C4h */ case   11:  		/* ld R10, <#[R3 + 9128]> */
		/* 820696C4h case   11:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R3 + 0x000023A8) );
		/* 820696C4h case   11:*/		return 0x820696C8;
		  /* 820696C8h */ case   12:  		/* or R11, R11, R10 */
		/* 820696C8h case   12:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 820696C8h case   12:*/		return 0x820696CC;
		  /* 820696CCh */ case   13:  		/* std R11, <#[R3 + 9128]> */
		/* 820696CCh case   13:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x000023A8) );
		/* 820696CCh case   13:*/		return 0x820696D0;
		  /* 820696D0h */ case   14:  		/* bclr 20, CR0_LT */
		/* 820696D0h case   14:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820696D0h case   14:*/		return 0x820696D4;
	}
	return 0x820696D4;
} // Block from 82069698h-820696D4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 820696D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820696D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820696D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820696D4);
		  /* 820696D4h */ case    0:  		/* nop */
		/* 820696D4h case    0:*/		cpu::op::nop();
		/* 820696D4h case    0:*/		return 0x820696D8;
		  /* 820696D8h */ case    1:  		/* li R11, 0 */
		/* 820696D8h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820696D8h case    1:*/		return 0x820696DC;
		  /* 820696DCh */ case    2:  		/* ld R10, <#[R3 + 9120]> */
		/* 820696DCh case    2:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R3 + 0x000023A0) );
		/* 820696DCh case    2:*/		return 0x820696E0;
		  /* 820696E0h */ case    3:  		/* rlwinm R9, R4, 30, 2, 31 */
		/* 820696E0h case    3:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R9,regs.R4);
		/* 820696E0h case    3:*/		return 0x820696E4;
		  /* 820696E4h */ case    4:  		/* lwz R8, <#[R3 + 9572]> */
		/* 820696E4h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00002564) );
		/* 820696E4h case    4:*/		return 0x820696E8;
		  /* 820696E8h */ case    5:  		/* stw R11, <#[R3 + 9564]> */
		/* 820696E8h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x0000255C) );
		/* 820696E8h case    5:*/		return 0x820696EC;
		  /* 820696ECh */ case    6:  		/* li R7, 1 */
		/* 820696ECh case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 820696ECh case    6:*/		return 0x820696F0;
		  /* 820696F0h */ case    7:  		/* subfic R11, R9, 63 */
		/* 820696F0h case    7:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R9,0x3F);
		/* 820696F0h case    7:*/		return 0x820696F4;
		  /* 820696F4h */ case    8:  		/* addi R9, R3, 9144 */
		/* 820696F4h case    8:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R3,0x23B8);
		/* 820696F4h case    8:*/		return 0x820696F8;
		  /* 820696F8h */ case    9:  		/* rldicl R11, R11, 0, 32 */
		/* 820696F8h case    9:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R11,regs.R11);
		/* 820696F8h case    9:*/		return 0x820696FC;
		  /* 820696FCh */ case   10:  		/* sld R11, R7, R11 */
		/* 820696FCh case   10:*/		cpu::op::sld<0>(regs,&regs.R11,regs.R7,regs.R11);
		/* 820696FCh case   10:*/		return 0x82069700;
		  /* 82069700h */ case   11:  		/* or R11, R11, R10 */
		/* 82069700h case   11:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82069700h case   11:*/		return 0x82069704;
		  /* 82069704h */ case   12:  		/* std R11, <#[R3 + 9120]> */
		/* 82069704h case   12:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R3 + 0x000023A0) );
		/* 82069704h case   12:*/		return 0x82069708;
		  /* 82069708h */ case   13:  		/* lwz R11, <#[R8 + 19892]> */
		/* 82069708h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00004DB4) );
		/* 82069708h case   13:*/		return 0x8206970C;
		  /* 8206970Ch */ case   14:  		/* rlwinm R11, R11, 6, 23, 23 */
		/* 8206970Ch case   14:*/		cpu::op::rlwinm<0,6,23,23>(regs,&regs.R11,regs.R11);
		/* 8206970Ch case   14:*/		return 0x82069710;
		  /* 82069710h */ case   15:  		/* add R10, R11, R4 */
		/* 82069710h case   15:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R4);
		/* 82069710h case   15:*/		return 0x82069714;
		  /* 82069714h */ case   16:  		/* lwz R6, <#[R5]> */
		/* 82069714h case   16:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R5 + 0x00000000) );
		/* 82069714h case   16:*/		return 0x82069718;
		  /* 82069718h */ case   17:  		/* addi R11, R10, 48 */
		/* 82069718h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x30);
		/* 82069718h case   17:*/		return 0x8206971C;
		  /* 8206971Ch */ case   18:  		/* rlwinm R8, R10, 29, 3, 29 */
		/* 8206971Ch case   18:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R8,regs.R10);
		/* 8206971Ch case   18:*/		return 0x82069720;
		  /* 82069720h */ case   19:  		/* rlwinm R11, R11, 4, 0, 27 */
		/* 82069720h case   19:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R11,regs.R11);
		/* 82069720h case   19:*/		return 0x82069724;
		  /* 82069724h */ case   20:  		/* rlwinm R10, R10, 0, 27, 31 */
		/* 82069724h case   20:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R10);
		/* 82069724h case   20:*/		return 0x82069728;
		  /* 82069728h */ case   21:  		/* add R11, R11, R3 */
		/* 82069728h case   21:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 82069728h case   21:*/		return 0x8206972C;
		  /* 8206972Ch */ case   22:  		/* stw R6, <#[R11]> */
		/* 8206972Ch case   22:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 8206972Ch case   22:*/		return 0x82069730;
		  /* 82069730h */ case   23:  		/* lwz R6, <#[R5 + 4]> */
		/* 82069730h case   23:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R5 + 0x00000004) );
		/* 82069730h case   23:*/		return 0x82069734;
		  /* 82069734h */ case   24:  		/* slw R10, R7, R10 */
		/* 82069734h case   24:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R7,regs.R10);
		/* 82069734h case   24:*/		return 0x82069738;
		  /* 82069738h */ case   25:  		/* stw R6, <#[R11 + 4]> */
		/* 82069738h case   25:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 82069738h case   25:*/		return 0x8206973C;
		  /* 8206973Ch */ case   26:  		/* lwz R7, <#[R5 + 8]> */
		/* 8206973Ch case   26:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R5 + 0x00000008) );
		/* 8206973Ch case   26:*/		return 0x82069740;
		  /* 82069740h */ case   27:  		/* stw R7, <#[R11 + 8]> */
		/* 82069740h case   27:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000008) );
		/* 82069740h case   27:*/		return 0x82069744;
		  /* 82069744h */ case   28:  		/* lwz R7, <#[R5 + 12]> */
		/* 82069744h case   28:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R5 + 0x0000000C) );
		/* 82069744h case   28:*/		return 0x82069748;
		  /* 82069748h */ case   29:  		/* stw R7, <#[R11 + 12]> */
		/* 82069748h case   29:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x0000000C) );
		/* 82069748h case   29:*/		return 0x8206974C;
		  /* 8206974Ch */ case   30:  		/* lwzx R11, <#[R8 + R9]> */
		/* 8206974Ch case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 8206974Ch case   30:*/		return 0x82069750;
		  /* 82069750h */ case   31:  		/* or R11, R10, R11 */
		/* 82069750h case   31:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82069750h case   31:*/		return 0x82069754;
		  /* 82069754h */ case   32:  		/* stwx R11, <#[R8 + R9]> */
		/* 82069754h case   32:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 82069754h case   32:*/		return 0x82069758;
	}
	return 0x82069758;
} // Block from 820696D4h-82069758h (33 instructions)

//////////////////////////////////////////////////////
// Block at 82069758h
// Function '?SetVSOutputDeclarationPatchOffsetsVisitor@Microcode@CMicrocodeBuilder@D3D@@SAX_N00KPATGPUSHADER_INSTRUCTION@@PAX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069758( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069758) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069758);
		  /* 82069758h */ case    0:  		/* bclr 20, CR0_LT */
		/* 82069758h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82069758h case    0:*/		return 0x8206975C;
	}
	return 0x8206975C;
} // Block from 82069758h-8206975Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206975Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206975C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206975C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206975C);
		  /* 8206975Ch */ case    0:  		/* nop */
		/* 8206975Ch case    0:*/		cpu::op::nop();
		/* 8206975Ch case    0:*/		return 0x82069760;
		  /* 82069760h */ case    1:  		/* rlwinm R10, R4, 27, 5, 31 */
		/* 82069760h case    1:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R4);
		/* 82069760h case    1:*/		return 0x82069764;
		  /* 82069764h */ case    2:  		/* rlwinm R9, R4, 0, 27, 31 */
		/* 82069764h case    2:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R4);
		/* 82069764h case    2:*/		return 0x82069768;
		  /* 82069768h */ case    3:  		/* addi R10, R10, 2286 */
		/* 82069768h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x8EE);
		/* 82069768h case    3:*/		return 0x8206976C;
		  /* 8206976Ch */ case    4:  		/* li R8, 1 */
		/* 8206976Ch case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 8206976Ch case    4:*/		return 0x82069770;
		  /* 82069770h */ case    5:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82069770h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82069770h case    5:*/		return 0x82069774;
		  /* 82069774h */ case    6:  		/* slw R9, R8, R9 */
		/* 82069774h case    6:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 82069774h case    6:*/		return 0x82069778;
		  /* 82069778h */ case    7:  		/* lwzx R10, <#[R10 + R3]> */
		/* 82069778h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 82069778h case    7:*/		return 0x8206977C;
		  /* 8206977Ch */ case    8:  		/* mr R11, R3 */
		/* 8206977Ch case    8:*/		regs.R11 = regs.R3;
		/* 8206977Ch case    8:*/		return 0x82069780;
		  /* 82069780h */ case    9:  		/* and R10, R9, R10 */
		/* 82069780h case    9:*/		cpu::op::and<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82069780h case    9:*/		return 0x82069784;
		  /* 82069784h */ case   10:  		/* addic R9, R10, -1 */
		/* 82069784h case   10:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R10,0xFFFFFFFF);
		/* 82069784h case   10:*/		return 0x82069788;
		  /* 82069788h */ case   11:  		/* subfe. R3, R9, R10 */
		/* 82069788h case   11:*/		cpu::op::subfe<1>(regs,&regs.R3,regs.R9,regs.R10);
		/* 82069788h case   11:*/		return 0x8206978C;
		  /* 8206978Ch */ case   12:  		/* bclr 12, CR0_EQ */
		/* 8206978Ch case   12:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 8206978Ch case   12:*/		return 0x82069790;
	}
	return 0x82069790;
} // Block from 8206975Ch-82069790h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82069790h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069790( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069790) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069790);
		  /* 82069790h */ case    0:  		/* addi R10, R4, 48 */
		/* 82069790h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x30);
		/* 82069790h case    0:*/		return 0x82069794;
		  /* 82069794h */ case    1:  		/* rlwinm R10, R10, 4, 0, 27 */
		/* 82069794h case    1:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R10,regs.R10);
		/* 82069794h case    1:*/		return 0x82069798;
		  /* 82069798h */ case    2:  		/* add R9, R10, R11 */
		/* 82069798h case    2:*/		cpu::op::add<0>(regs,&regs.R9,regs.R10,regs.R11);
		/* 82069798h case    2:*/		return 0x8206979C;
		  /* 8206979Ch */ case    3:  		/* lwzx R11, <#[R10 + R11]> */
		/* 8206979Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8206979Ch case    3:*/		return 0x820697A0;
		  /* 820697A0h */ case    4:  		/* stw R11, <#[R5]> */
		/* 820697A0h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 820697A0h case    4:*/		return 0x820697A4;
		  /* 820697A4h */ case    5:  		/* lwz R11, <#[R9 + 4]> */
		/* 820697A4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 820697A4h case    5:*/		return 0x820697A8;
		  /* 820697A8h */ case    6:  		/* stw R11, <#[R5 + 4]> */
		/* 820697A8h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000004) );
		/* 820697A8h case    6:*/		return 0x820697AC;
		  /* 820697ACh */ case    7:  		/* lwz R11, <#[R9 + 8]> */
		/* 820697ACh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000008) );
		/* 820697ACh case    7:*/		return 0x820697B0;
		  /* 820697B0h */ case    8:  		/* stw R11, <#[R5 + 8]> */
		/* 820697B0h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000008) );
		/* 820697B0h case    8:*/		return 0x820697B4;
		  /* 820697B4h */ case    9:  		/* lwz R11, <#[R9 + 12]> */
		/* 820697B4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x0000000C) );
		/* 820697B4h case    9:*/		return 0x820697B8;
		  /* 820697B8h */ case   10:  		/* stw R11, <#[R5 + 12]> */
		/* 820697B8h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x0000000C) );
		/* 820697B8h case   10:*/		return 0x820697BC;
		  /* 820697BCh */ case   11:  		/* bclr 20, CR0_LT */
		/* 820697BCh case   11:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820697BCh case   11:*/		return 0x820697C0;
	}
	return 0x820697C0;
} // Block from 82069790h-820697C0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 820697C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820697C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820697C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820697C0);
		  /* 820697C0h */ case    0:  		/* lwz R11, <#[R3 + 112]> */
		/* 820697C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000070) );
		/* 820697C0h case    0:*/		return 0x820697C4;
		  /* 820697C4h */ case    1:  		/* lwz R10, <#[R3 + 108]> */
		/* 820697C4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000006C) );
		/* 820697C4h case    1:*/		return 0x820697C8;
		  /* 820697C8h */ case    2:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 820697C8h case    2:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 820697C8h case    2:*/		return 0x820697CC;
		  /* 820697CCh */ case    3:  		/* extsw R3, R10 */
		/* 820697CCh case    3:*/		cpu::op::extsw<0>(regs,&regs.R3,regs.R10);
		/* 820697CCh case    3:*/		return 0x820697D0;
		  /* 820697D0h */ case    4:  		/* add R9, R11, R10 */
		/* 820697D0h case    4:*/		cpu::op::add<0>(regs,&regs.R9,regs.R11,regs.R10);
		/* 820697D0h case    4:*/		return 0x820697D4;
		  /* 820697D4h */ case    5:  		/* b 76 */
		/* 820697D4h case    5:*/		return 0x82069820;
		/* 820697D4h case    5:*/		return 0x820697D8;
		  /* 820697D8h */ case    6:  		/* lwz R11, <#[R3 + 4]> */
		/* 820697D8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 820697D8h case    6:*/		return 0x820697DC;
		  /* 820697DCh */ case    7:  		/* li R10, 1 */
		/* 820697DCh case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 820697DCh case    7:*/		return 0x820697E0;
		  /* 820697E0h */ case    8:  		/* rlwinm R8, R11, 20, 28, 31 */
		/* 820697E0h case    8:*/		cpu::op::rlwinm<0,20,28,31>(regs,&regs.R8,regs.R11);
		/* 820697E0h case    8:*/		return 0x820697E4;
		  /* 820697E4h */ case    9:  		/* slw R10, R10, R8 */
		/* 820697E4h case    9:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 820697E4h case    9:*/		return 0x820697E8;
		  /* 820697E8h */ case   10:  		/* andi. R10, R10, 24702 */
		/* 820697E8h case   10:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R10,0x607E);
		/* 820697E8h case   10:*/		return 0x820697EC;
		  /* 820697ECh */ case   11:  		/* cmplwi CR0, R10, 0 */
		/* 820697ECh case   11:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 820697ECh case   11:*/		return 0x820697F0;
		  /* 820697F0h */ case   12:  		/* bc 12, CR0_EQ, 44 */
		/* 820697F0h case   12:*/		if ( regs.CR[0].eq ) { return 0x8206981C;  }
		/* 820697F0h case   12:*/		return 0x820697F4;
		  /* 820697F4h */ case   13:  		/* rlwinm. R11, R11, 0, 20, 20 */
		/* 820697F4h case   13:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R11,regs.R11);
		/* 820697F4h case   13:*/		return 0x820697F8;
		  /* 820697F8h */ case   14:  		/* bc 4, CR0_EQ, 36 */
		/* 820697F8h case   14:*/		if ( !regs.CR[0].eq ) { return 0x8206981C;  }
		/* 820697F8h case   14:*/		return 0x820697FC;
		  /* 820697FCh */ case   15:  		/* lwz R11, <#[R3]> */
		/* 820697FCh case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 820697FCh case   15:*/		return 0x82069800;
		  /* 82069800h */ case   16:  		/* rlwinm R10, R11, 0, 20, 31 */
		/* 82069800h case   16:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R10,regs.R11);
		/* 82069800h case   16:*/		return 0x82069804;
		  /* 82069804h */ case   17:  		/* cmplw CR6, R10, R4 */
		/* 82069804h case   17:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R4);
		/* 82069804h case   17:*/		return 0x82069808;
		  /* 82069808h */ case   18:  		/* bc 12, CR6_GT, 20 */
		/* 82069808h case   18:*/		if ( regs.CR[6].gt ) { return 0x8206981C;  }
		/* 82069808h case   18:*/		return 0x8206980C;
		  /* 8206980Ch */ case   19:  		/* rlwinm R11, R11, 20, 29, 31 */
		/* 8206980Ch case   19:*/		cpu::op::rlwinm<0,20,29,31>(regs,&regs.R11,regs.R11);
		/* 8206980Ch case   19:*/		return 0x82069810;
		  /* 82069810h */ case   20:  		/* add R11, R11, R10 */
		/* 82069810h case   20:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82069810h case   20:*/		return 0x82069814;
		  /* 82069814h */ case   21:  		/* cmplw CR6, R4, R11 */
		/* 82069814h case   21:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 82069814h case   21:*/		return 0x82069818;
		  /* 82069818h */ case   22:  		/* bclr 12, CR6_LT */
		/* 82069818h case   22:*/		if ( regs.CR[6].lt ) { return (uint32)regs.LR; }
		/* 82069818h case   22:*/		return 0x8206981C;
	}
	return 0x8206981C;
} // Block from 820697C0h-8206981Ch (23 instructions)

//////////////////////////////////////////////////////
// Block at 8206981Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206981C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206981C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206981C);
		  /* 8206981Ch */ case    0:  		/* addi R3, R3, 8 */
		/* 8206981Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x8);
		/* 8206981Ch case    0:*/		return 0x82069820;
	}
	return 0x82069820;
} // Block from 8206981Ch-82069820h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82069820h
// Function '?SetPSOutputMaskVisitor@Microcode@CMicrocodeBuilder@D3D@@SAX_N00KPATGPUSHADER_INSTRUCTION@@PAX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069820( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069820) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069820);
		  /* 82069820h */ case    0:  		/* cmplw CR6, R3, R9 */
		/* 82069820h case    0:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R9);
		/* 82069820h case    0:*/		return 0x82069824;
		  /* 82069824h */ case    1:  		/* bc 12, CR6_LT, -76 */
		/* 82069824h case    1:*/		if ( regs.CR[6].lt ) { return 0x820697D8;  }
		/* 82069824h case    1:*/		return 0x82069828;
		  /* 82069828h */ case    2:  		/* li R3, 0 */
		/* 82069828h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82069828h case    2:*/		return 0x8206982C;
		  /* 8206982Ch */ case    3:  		/* bclr 20, CR0_LT */
		/* 8206982Ch case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206982Ch case    3:*/		return 0x82069830;
	}
	return 0x82069830;
} // Block from 82069820h-82069830h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82069830h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069830( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069830) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069830);
		  /* 82069830h */ case    0:  		/* mfspr R12, LR */
		/* 82069830h case    0:*/		regs.R12 = regs.LR;
		/* 82069830h case    0:*/		return 0x82069834;
		  /* 82069834h */ case    1:  		/* bl 162344 */
		/* 82069834h case    1:*/		regs.LR = 0x82069838; return 0x8209125C;
		/* 82069834h case    1:*/		return 0x82069838;
		  /* 82069838h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82069838h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82069838h case    2:*/		return 0x8206983C;
		  /* 8206983Ch */ case    3:  		/* mr R31, R3 */
		/* 8206983Ch case    3:*/		regs.R31 = regs.R3;
		/* 8206983Ch case    3:*/		return 0x82069840;
		  /* 82069840h */ case    4:  		/* mr R30, R4 */
		/* 82069840h case    4:*/		regs.R30 = regs.R4;
		/* 82069840h case    4:*/		return 0x82069844;
		  /* 82069844h */ case    5:  		/* mr R29, R5 */
		/* 82069844h case    5:*/		regs.R29 = regs.R5;
		/* 82069844h case    5:*/		return 0x82069848;
		  /* 82069848h */ case    6:  		/* bl -136 */
		/* 82069848h case    6:*/		regs.LR = 0x8206984C; return 0x820697C0;
		/* 82069848h case    6:*/		return 0x8206984C;
		  /* 8206984Ch */ case    7:  		/* cmplwi CR0, R3, 0 */
		/* 8206984Ch case    7:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8206984Ch case    7:*/		return 0x82069850;
		  /* 82069850h */ case    8:  		/* bc 12, CR0_EQ, 200 */
		/* 82069850h case    8:*/		if ( regs.CR[0].eq ) { return 0x82069918;  }
		/* 82069850h case    8:*/		return 0x82069854;
		  /* 82069854h */ case    9:  		/* lwz R11, <#[R3]> */
		/* 82069854h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82069854h case    9:*/		return 0x82069858;
		  /* 82069858h */ case   10:  		/* li R10, 2 */
		/* 82069858h case   10:*/		cpu::op::li<0>(regs,&regs.R10,0x2);
		/* 82069858h case   10:*/		return 0x8206985C;
		  /* 8206985Ch */ case   11:  		/* cmpwi CR6, R29, 0 */
		/* 8206985Ch case   11:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 8206985Ch case   11:*/		return 0x82069860;
		  /* 82069860h */ case   12:  		/* rlwinm R9, R11, 0, 20, 31 */
		/* 82069860h case   12:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R9,regs.R11);
		/* 82069860h case   12:*/		return 0x82069864;
		  /* 82069864h */ case   13:  		/* subf R9, R9, R30 */
		/* 82069864h case   13:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R9,regs.R30);
		/* 82069864h case   13:*/		return 0x82069868;
		  /* 82069868h */ case   14:  		/* rlwinm R9, R9, 1, 0, 30 */
		/* 82069868h case   14:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R9,regs.R9);
		/* 82069868h case   14:*/		return 0x8206986C;
		  /* 8206986Ch */ case   15:  		/* slw R10, R10, R9 */
		/* 8206986Ch case   15:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 8206986Ch case   15:*/		return 0x82069870;
		  /* 82069870h */ case   16:  		/* bc 12, CR6_EQ, 24 */
		/* 82069870h case   16:*/		if ( regs.CR[6].eq ) { return 0x82069888;  }
		/* 82069870h case   16:*/		return 0x82069874;
		  /* 82069874h */ case   17:  		/* rlwinm R10, R10, 16, 0, 15 */
		/* 82069874h case   17:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R10,regs.R10);
		/* 82069874h case   17:*/		return 0x82069878;
		  /* 82069878h */ case   18:  		/* or R10, R10, R11 */
		/* 82069878h case   18:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 82069878h case   18:*/		return 0x8206987C;
		  /* 8206987Ch */ case   19:  		/* rlwimi R10, R11, 0, 16, 3 */
		/* 8206987Ch case   19:*/		cpu::op::rlwimi<0,0,16,3>(regs,&regs.R10,regs.R11);
		/* 8206987Ch case   19:*/		return 0x82069880;
		  /* 82069880h */ case   20:  		/* stw R10, <#[R3]> */
		/* 82069880h case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82069880h case   20:*/		return 0x82069884;
		  /* 82069884h */ case   21:  		/* b 28 */
		/* 82069884h case   21:*/		return 0x820698A0;
		/* 82069884h case   21:*/		return 0x82069888;
	}
	return 0x82069888;
} // Block from 82069830h-82069888h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82069888h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069888( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069888) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069888);
		  /* 82069888h */ case    0:  		/* lis R9, -4096 */
		/* 82069888h case    0:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFFF000);
		/* 82069888h case    0:*/		return 0x8206988C;
		  /* 8206988Ch */ case    1:  		/* nor R10, R10, R10 */
		/* 8206988Ch case    1:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8206988Ch case    1:*/		return 0x82069890;
		  /* 82069890h */ case    2:  		/* ori R9, R9, 65535 */
		/* 82069890h case    2:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0xFFFF);
		/* 82069890h case    2:*/		return 0x82069894;
		  /* 82069894h */ case    3:  		/* rlwimi R9, R10, 16, 4, 15 */
		/* 82069894h case    3:*/		cpu::op::rlwimi<0,16,4,15>(regs,&regs.R9,regs.R10);
		/* 82069894h case    3:*/		return 0x82069898;
		  /* 82069898h */ case    4:  		/* and R11, R9, R11 */
		/* 82069898h case    4:*/		cpu::op::and<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82069898h case    4:*/		return 0x8206989C;
		  /* 8206989Ch */ case    5:  		/* stw R11, <#[R3]> */
		/* 8206989Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8206989Ch case    5:*/		return 0x820698A0;
	}
	return 0x820698A0;
} // Block from 82069888h-820698A0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820698A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820698A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820698A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820698A0);
		  /* 820698A0h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 820698A0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 820698A0h case    0:*/		return 0x820698A4;
		  /* 820698A4h */ case    1:  		/* lwz R11, <#[R11 + 19892]> */
		/* 820698A4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00004DB4) );
		/* 820698A4h case    1:*/		return 0x820698A8;
		  /* 820698A8h */ case    2:  		/* nor R11, R11, R11 */
		/* 820698A8h case    2:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 820698A8h case    2:*/		return 0x820698AC;
		  /* 820698ACh */ case    3:  		/* rlwinm. R11, R11, 27, 31, 31 */
		/* 820698ACh case    3:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R11,regs.R11);
		/* 820698ACh case    3:*/		return 0x820698B0;
		  /* 820698B0h */ case    4:  		/* bc 12, CR0_EQ, 104 */
		/* 820698B0h case    4:*/		if ( regs.CR[0].eq ) { return 0x82069918;  }
		/* 820698B0h case    4:*/		return 0x820698B4;
		  /* 820698B4h */ case    5:  		/* cmpwi CR6, R29, 0 */
		/* 820698B4h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 820698B4h case    5:*/		return 0x820698B8;
	}
	return 0x820698B8;
} // Block from 820698A0h-820698B8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 820698B8h
// Function '?AnalyzeCodeVisitor@Microcode@CMicrocodeBuilder@D3D@@SAX_N00KPATGPUSHADER_INSTRUCTION@@PAX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820698B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820698B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820698B8);
		  /* 820698B8h */ case    0:  		/* bc 12, CR6_EQ, 96 */
		/* 820698B8h case    0:*/		if ( regs.CR[6].eq ) { return 0x82069918;  }
		/* 820698B8h case    0:*/		return 0x820698BC;
		  /* 820698BCh */ case    1:  		/* lwz R11, <#[R31 + 100]> */
		/* 820698BCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000064) );
		/* 820698BCh case    1:*/		return 0x820698C0;
		  /* 820698C0h */ case    2:  		/* addi R11, R11, -1 */
		/* 820698C0h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 820698C0h case    2:*/		return 0x820698C4;
		  /* 820698C4h */ case    3:  		/* cmplw CR6, R30, R11 */
		/* 820698C4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 820698C4h case    3:*/		return 0x820698C8;
		  /* 820698C8h */ case    4:  		/* bc 4, CR6_EQ, 80 */
		/* 820698C8h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82069918;  }
		/* 820698C8h case    4:*/		return 0x820698CC;
		  /* 820698CCh */ case    5:  		/* li R11, 0 */
		/* 820698CCh case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 820698CCh case    5:*/		return 0x820698D0;
		  /* 820698D0h */ case    6:  		/* li R5, 32 */
		/* 820698D0h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x20);
		/* 820698D0h case    6:*/		return 0x820698D4;
		  /* 820698D4h */ case    7:  		/* li R4, 0 */
		/* 820698D4h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820698D4h case    7:*/		return 0x820698D8;
		  /* 820698D8h */ case    8:  		/* stw R11, <#[R31 + 4]> */
		/* 820698D8h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 820698D8h case    8:*/		return 0x820698DC;
		  /* 820698DCh */ case    9:  		/* addi R3, R31, 128 */
		/* 820698DCh case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x80);
		/* 820698DCh case    9:*/		return 0x820698E0;
		  /* 820698E0h */ case   10:  		/* stb R11, <#[R31 + 124]> */
		/* 820698E0h case   10:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x0000007C) );
		/* 820698E0h case   10:*/		return 0x820698E4;
		  /* 820698E4h */ case   11:  		/* bl 162396 */
		/* 820698E4h case   11:*/		regs.LR = 0x820698E8; return 0x82091340;
		/* 820698E4h case   11:*/		return 0x820698E8;
		  /* 820698E8h */ case   12:  		/* li R5, 32 */
		/* 820698E8h case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x20);
		/* 820698E8h case   12:*/		return 0x820698EC;
		  /* 820698ECh */ case   13:  		/* li R4, 0 */
		/* 820698ECh case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820698ECh case   13:*/		return 0x820698F0;
		  /* 820698F0h */ case   14:  		/* addi R3, R31, 160 */
		/* 820698F0h case   14:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0xA0);
		/* 820698F0h case   14:*/		return 0x820698F4;
		  /* 820698F4h */ case   15:  		/* bl 162380 */
		/* 820698F4h case   15:*/		regs.LR = 0x820698F8; return 0x82091340;
		/* 820698F4h case   15:*/		return 0x820698F8;
		  /* 820698F8h */ case   16:  		/* li R5, 32 */
		/* 820698F8h case   16:*/		cpu::op::li<0>(regs,&regs.R5,0x20);
		/* 820698F8h case   16:*/		return 0x820698FC;
		  /* 820698FCh */ case   17:  		/* li R4, 0 */
		/* 820698FCh case   17:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 820698FCh case   17:*/		return 0x82069900;
		  /* 82069900h */ case   18:  		/* addi R3, R31, 192 */
		/* 82069900h case   18:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0xC0);
		/* 82069900h case   18:*/		return 0x82069904;
		  /* 82069904h */ case   19:  		/* bl 162364 */
		/* 82069904h case   19:*/		regs.LR = 0x82069908; return 0x82091340;
		/* 82069904h case   19:*/		return 0x82069908;
		  /* 82069908h */ case   20:  		/* li R5, 32 */
		/* 82069908h case   20:*/		cpu::op::li<0>(regs,&regs.R5,0x20);
		/* 82069908h case   20:*/		return 0x8206990C;
		  /* 8206990Ch */ case   21:  		/* li R4, 0 */
		/* 8206990Ch case   21:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206990Ch case   21:*/		return 0x82069910;
		  /* 82069910h */ case   22:  		/* addi R3, R31, 224 */
		/* 82069910h case   22:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0xE0);
		/* 82069910h case   22:*/		return 0x82069914;
		  /* 82069914h */ case   23:  		/* bl 162348 */
		/* 82069914h case   23:*/		regs.LR = 0x82069918; return 0x82091340;
		/* 82069914h case   23:*/		return 0x82069918;
	}
	return 0x82069918;
} // Block from 820698B8h-82069918h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82069918h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069918( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069918) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069918);
		  /* 82069918h */ case    0:  		/* addi R1, R1, 112 */
		/* 82069918h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82069918h case    0:*/		return 0x8206991C;
		  /* 8206991Ch */ case    1:  		/* b 162192 */
		/* 8206991Ch case    1:*/		return 0x820912AC;
		/* 8206991Ch case    1:*/		return 0x82069920;
		  /* 82069920h */ case    2:  		/* lwz R11, <#[R3 + 80]> */
		/* 82069920h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000050) );
		/* 82069920h case    2:*/		return 0x82069924;
		  /* 82069924h */ case    3:  		/* cmpwi CR6, R11, 0 */
		/* 82069924h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82069924h case    3:*/		return 0x82069928;
		  /* 82069928h */ case    4:  		/* bc 4, CR6_LT, 12 */
		/* 82069928h case    4:*/		if ( !regs.CR[6].lt ) { return 0x82069934;  }
		/* 82069928h case    4:*/		return 0x8206992C;
		  /* 8206992Ch */ case    5:  		/* li R3, 0 */
		/* 8206992Ch case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8206992Ch case    5:*/		return 0x82069930;
		  /* 82069930h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82069930h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82069930h case    6:*/		return 0x82069934;
	}
	return 0x82069934;
} // Block from 82069918h-82069934h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82069934h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069934( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069934) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069934);
		  /* 82069934h */ case    0:  		/* cmplwi CR6, R5, 0 */
		/* 82069934h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 82069934h case    0:*/		return 0x82069938;
		  /* 82069938h */ case    1:  		/* bc 12, CR6_EQ, 152 */
		/* 82069938h case    1:*/		if ( regs.CR[6].eq ) { return 0x820699D0;  }
		/* 82069938h case    1:*/		return 0x8206993C;
		  /* 8206993Ch */ case    2:  		/* lwz R10, <#[R3 + 112]> */
		/* 8206993Ch case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000070) );
		/* 8206993Ch case    2:*/		return 0x82069940;
		  /* 82069940h */ case    3:  		/* lwz R11, <#[R3 + 108]> */
		/* 82069940h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000006C) );
		/* 82069940h case    3:*/		return 0x82069944;
		  /* 82069944h */ case    4:  		/* rlwinm R10, R10, 3, 0, 28 */
		/* 82069944h case    4:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R10);
		/* 82069944h case    4:*/		return 0x82069948;
		  /* 82069948h */ case    5:  		/* mr R9, R11 */
		/* 82069948h case    5:*/		regs.R9 = regs.R11;
		/* 82069948h case    5:*/		return 0x8206994C;
		  /* 8206994Ch */ case    6:  		/* add R7, R10, R11 */
		/* 8206994Ch case    6:*/		cpu::op::add<0>(regs,&regs.R7,regs.R10,regs.R11);
		/* 8206994Ch case    6:*/		return 0x82069950;
		  /* 82069950h */ case    7:  		/* cmplw CR6, R11, R7 */
		/* 82069950h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R7);
		/* 82069950h case    7:*/		return 0x82069954;
		  /* 82069954h */ case    8:  		/* bc 4, CR6_LT, 124 */
		/* 82069954h case    8:*/		if ( !regs.CR[6].lt ) { return 0x820699D0;  }
		/* 82069954h case    8:*/		return 0x82069958;
		  /* 82069958h */ case    9:  		/* li R6, 1 */
		/* 82069958h case    9:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 82069958h case    9:*/		return 0x8206995C;
		  /* 8206995Ch */ case   10:  		/* lwz R11, <#[R9 + 4]> */
		/* 8206995Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 8206995Ch case   10:*/		return 0x82069960;
		  /* 82069960h */ case   11:  		/* rlwinm R10, R11, 20, 28, 31 */
		/* 82069960h case   11:*/		cpu::op::rlwinm<0,20,28,31>(regs,&regs.R10,regs.R11);
		/* 82069960h case   11:*/		return 0x82069964;
		  /* 82069964h */ case   12:  		/* slw R10, R6, R10 */
		/* 82069964h case   12:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R6,regs.R10);
		/* 82069964h case   12:*/		return 0x82069968;
		  /* 82069968h */ case   13:  		/* andi. R10, R10, 24702 */
		/* 82069968h case   13:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R10,0x607E);
		/* 82069968h case   13:*/		return 0x8206996C;
		  /* 8206996Ch */ case   14:  		/* cmplwi CR0, R10, 0 */
		/* 8206996Ch case   14:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 8206996Ch case   14:*/		return 0x82069970;
		  /* 82069970h */ case   15:  		/* bc 12, CR0_EQ, 44 */
		/* 82069970h case   15:*/		if ( regs.CR[0].eq ) { return 0x8206999C;  }
		/* 82069970h case   15:*/		return 0x82069974;
		  /* 82069974h */ case   16:  		/* rlwinm. R11, R11, 0, 20, 20 */
		/* 82069974h case   16:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R11,regs.R11);
		/* 82069974h case   16:*/		return 0x82069978;
		  /* 82069978h */ case   17:  		/* bc 4, CR0_EQ, 36 */
		/* 82069978h case   17:*/		if ( !regs.CR[0].eq ) { return 0x8206999C;  }
		/* 82069978h case   17:*/		return 0x8206997C;
		  /* 8206997Ch */ case   18:  		/* lwz R11, <#[R9]> */
		/* 8206997Ch case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 8206997Ch case   18:*/		return 0x82069980;
		  /* 82069980h */ case   19:  		/* rlwinm R10, R11, 0, 20, 31 */
		/* 82069980h case   19:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R10,regs.R11);
		/* 82069980h case   19:*/		return 0x82069984;
		  /* 82069984h */ case   20:  		/* cmplw CR6, R10, R4 */
		/* 82069984h case   20:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R4);
		/* 82069984h case   20:*/		return 0x82069988;
		  /* 82069988h */ case   21:  		/* bc 12, CR6_GT, 20 */
		/* 82069988h case   21:*/		if ( regs.CR[6].gt ) { return 0x8206999C;  }
		/* 82069988h case   21:*/		return 0x8206998C;
		  /* 8206998Ch */ case   22:  		/* rlwinm R8, R11, 20, 29, 31 */
		/* 8206998Ch case   22:*/		cpu::op::rlwinm<0,20,29,31>(regs,&regs.R8,regs.R11);
		/* 8206998Ch case   22:*/		return 0x82069990;
		  /* 82069990h */ case   23:  		/* add R8, R8, R10 */
		/* 82069990h case   23:*/		cpu::op::add<0>(regs,&regs.R8,regs.R8,regs.R10);
		/* 82069990h case   23:*/		return 0x82069994;
		  /* 82069994h */ case   24:  		/* cmplw CR6, R4, R8 */
		/* 82069994h case   24:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R8);
		/* 82069994h case   24:*/		return 0x82069998;
		  /* 82069998h */ case   25:  		/* bc 12, CR6_LT, 20 */
		/* 82069998h case   25:*/		if ( regs.CR[6].lt ) { return 0x820699AC;  }
		/* 82069998h case   25:*/		return 0x8206999C;
	}
	return 0x8206999C;
} // Block from 82069934h-8206999Ch (26 instructions)

//////////////////////////////////////////////////////
// Block at 8206999Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206999C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206999C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206999C);
		  /* 8206999Ch */ case    0:  		/* addi R9, R9, 8 */
		/* 8206999Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x8);
		/* 8206999Ch case    0:*/		return 0x820699A0;
		  /* 820699A0h */ case    1:  		/* cmplw CR6, R9, R7 */
		/* 820699A0h case    1:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 820699A0h case    1:*/		return 0x820699A4;
		  /* 820699A4h */ case    2:  		/* bc 12, CR6_LT, -72 */
		/* 820699A4h case    2:*/		if ( regs.CR[6].lt ) { return 0x8206995C;  }
		/* 820699A4h case    2:*/		return 0x820699A8;
		  /* 820699A8h */ case    3:  		/* b 40 */
		/* 820699A8h case    3:*/		return 0x820699D0;
		/* 820699A8h case    3:*/		return 0x820699AC;
	}
	return 0x820699AC;
} // Block from 8206999Ch-820699ACh (4 instructions)

//////////////////////////////////////////////////////
// Block at 820699ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820699AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820699AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820699AC);
		  /* 820699ACh */ case    0:  		/* subf R10, R10, R4 */
		/* 820699ACh case    0:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R10,regs.R4);
		/* 820699ACh case    0:*/		return 0x820699B0;
		  /* 820699B0h */ case    1:  		/* rlwinm R11, R11, 16, 16, 31 */
		/* 820699B0h case    1:*/		cpu::op::rlwinm<0,16,16,31>(regs,&regs.R11,regs.R11);
		/* 820699B0h case    1:*/		return 0x820699B4;
		  /* 820699B4h */ case    2:  		/* rlwinm R10, R10, 1, 0, 30 */
		/* 820699B4h case    2:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R10);
		/* 820699B4h case    2:*/		return 0x820699B8;
		  /* 820699B8h */ case    3:  		/* slw R10, R6, R10 */
		/* 820699B8h case    3:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R6,regs.R10);
		/* 820699B8h case    3:*/		return 0x820699BC;
		  /* 820699BCh */ case    4:  		/* and R11, R10, R11 */
		/* 820699BCh case    4:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820699BCh case    4:*/		return 0x820699C0;
		  /* 820699C0h */ case    5:  		/* rlwinm R11, R11, 0, 20, 31 */
		/* 820699C0h case    5:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R11,regs.R11);
		/* 820699C0h case    5:*/		return 0x820699C4;
		  /* 820699C4h */ case    6:  		/* addic R10, R11, -1 */
		/* 820699C4h case    6:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R11,0xFFFFFFFF);
		/* 820699C4h case    6:*/		return 0x820699C8;
		  /* 820699C8h */ case    7:  		/* subfe R11, R10, R11 */
		/* 820699C8h case    7:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 820699C8h case    7:*/		return 0x820699CC;
		  /* 820699CCh */ case    8:  		/* stw R11, <#[R5]> */
		/* 820699CCh case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 820699CCh case    8:*/		return 0x820699D0;
	}
	return 0x820699D0;
} // Block from 820699ACh-820699D0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 820699D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820699D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820699D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820699D0);
		  /* 820699D0h */ case    0:  		/* lwz R11, <#[R3 + 96]> */
		/* 820699D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000060) );
		/* 820699D0h case    0:*/		return 0x820699D4;
		  /* 820699D4h */ case    1:  		/* mulli R10, R4, 12 */
		/* 820699D4h case    1:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R4,0xC);
		/* 820699D4h case    1:*/		return 0x820699D8;
		  /* 820699D8h */ case    2:  		/* add R3, R11, R10 */
		/* 820699D8h case    2:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 820699D8h case    2:*/		return 0x820699DC;
		  /* 820699DCh */ case    3:  		/* bclr 20, CR0_LT */
		/* 820699DCh case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 820699DCh case    3:*/		return 0x820699E0;
	}
	return 0x820699E0;
} // Block from 820699D0h-820699E0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 820699E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block820699E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x820699E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x820699E0);
		  /* 820699E0h */ case    0:  		/* lwz R11, <#[R3 + 112]> */
		/* 820699E0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000070) );
		/* 820699E0h case    0:*/		return 0x820699E4;
		  /* 820699E4h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 820699E4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 820699E4h case    1:*/		return 0x820699E8;
		  /* 820699E8h */ case    2:  		/* bc 12, CR6_EQ, 88 */
		/* 820699E8h case    2:*/		if ( regs.CR[6].eq ) { return 0x82069A40;  }
		/* 820699E8h case    2:*/		return 0x820699EC;
		  /* 820699ECh */ case    3:  		/* lwz R10, <#[R3 + 80]> */
		/* 820699ECh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000050) );
		/* 820699ECh case    3:*/		return 0x820699F0;
		  /* 820699F0h */ case    4:  		/* cmpwi CR6, R10, 0 */
		/* 820699F0h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 820699F0h case    4:*/		return 0x820699F4;
		  /* 820699F4h */ case    5:  		/* bc 4, CR6_LT, 12 */
		/* 820699F4h case    5:*/		if ( !regs.CR[6].lt ) { return 0x82069A00;  }
		/* 820699F4h case    5:*/		return 0x820699F8;
		  /* 820699F8h */ case    6:  		/* li R10, 0 */
		/* 820699F8h case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 820699F8h case    6:*/		return 0x820699FC;
		  /* 820699FCh */ case    7:  		/* b 20 */
		/* 820699FCh case    7:*/		return 0x82069A10;
		/* 820699FCh case    7:*/		return 0x82069A00;
	}
	return 0x82069A00;
} // Block from 820699E0h-82069A00h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82069A00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069A00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069A00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069A00);
		  /* 82069A00h */ case    0:  		/* lwz R10, <#[R3 + 108]> */
		/* 82069A00h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000006C) );
		/* 82069A00h case    0:*/		return 0x82069A04;
		  /* 82069A04h */ case    1:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 82069A04h case    1:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 82069A04h case    1:*/		return 0x82069A08;
		  /* 82069A08h */ case    2:  		/* add R11, R11, R10 */
		/* 82069A08h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82069A08h case    2:*/		return 0x82069A0C;
		  /* 82069A0Ch */ case    3:  		/* addi R10, R11, -8 */
		/* 82069A0Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xFFFFFFF8);
		/* 82069A0Ch case    3:*/		return 0x82069A10;
	}
	return 0x82069A10;
} // Block from 82069A00h-82069A10h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82069A10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069A10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069A10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069A10);
		  /* 82069A10h */ case    0:  		/* lwz R11, <#[R10 + 4]> */
		/* 82069A10h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 82069A10h case    0:*/		return 0x82069A14;
		  /* 82069A14h */ case    1:  		/* rlwinm. R11, R11, 20, 28, 31 */
		/* 82069A14h case    1:*/		cpu::op::rlwinm<1,20,28,31>(regs,&regs.R11,regs.R11);
		/* 82069A14h case    1:*/		return 0x82069A18;
		  /* 82069A18h */ case    2:  		/* bc 12, CR0_EQ, 40 */
		/* 82069A18h case    2:*/		if ( regs.CR[0].eq ) { return 0x82069A40;  }
		/* 82069A18h case    2:*/		return 0x82069A1C;
		  /* 82069A1Ch */ case    3:  		/* cmplwi CR6, R11, 6 */
		/* 82069A1Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000006);
		/* 82069A1Ch case    3:*/		return 0x82069A20;
		  /* 82069A20h */ case    4:  		/* bc 4, CR6_GT, 20 */
		/* 82069A20h case    4:*/		if ( !regs.CR[6].gt ) { return 0x82069A34;  }
		/* 82069A20h case    4:*/		return 0x82069A24;
		  /* 82069A24h */ case    5:  		/* cmplwi CR6, R11, 12 */
		/* 82069A24h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000C);
		/* 82069A24h case    5:*/		return 0x82069A28;
		  /* 82069A28h */ case    6:  		/* bc 4, CR6_GT, 24 */
		/* 82069A28h case    6:*/		if ( !regs.CR[6].gt ) { return 0x82069A40;  }
		/* 82069A28h case    6:*/		return 0x82069A2C;
		  /* 82069A2Ch */ case    7:  		/* cmplwi CR6, R11, 14 */
		/* 82069A2Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000E);
		/* 82069A2Ch case    7:*/		return 0x82069A30;
		  /* 82069A30h */ case    8:  		/* bc 12, CR6_GT, 16 */
		/* 82069A30h case    8:*/		if ( regs.CR[6].gt ) { return 0x82069A40;  }
		/* 82069A30h case    8:*/		return 0x82069A34;
	}
	return 0x82069A34;
} // Block from 82069A10h-82069A34h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82069A34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069A34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069A34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069A34);
		  /* 82069A34h */ case    0:  		/* lwz R11, <#[R10]> */
		/* 82069A34h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82069A34h case    0:*/		return 0x82069A38;
		  /* 82069A38h */ case    1:  		/* rlwinm R3, R11, 20, 29, 31 */
		/* 82069A38h case    1:*/		cpu::op::rlwinm<0,20,29,31>(regs,&regs.R3,regs.R11);
		/* 82069A38h case    1:*/		return 0x82069A3C;
		  /* 82069A3Ch */ case    2:  		/* bclr 20, CR0_LT */
		/* 82069A3Ch case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82069A3Ch case    2:*/		return 0x82069A40;
	}
	return 0x82069A40;
} // Block from 82069A34h-82069A40h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82069A40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069A40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069A40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069A40);
		  /* 82069A40h */ case    0:  		/* li R3, 0 */
		/* 82069A40h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82069A40h case    0:*/		return 0x82069A44;
		  /* 82069A44h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82069A44h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82069A44h case    1:*/		return 0x82069A48;
	}
	return 0x82069A48;
} // Block from 82069A40h-82069A48h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82069A48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069A48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069A48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069A48);
		  /* 82069A48h */ case    0:  		/* std R31, <#[R1 - 8]> */
		/* 82069A48h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82069A48h case    0:*/		return 0x82069A4C;
		  /* 82069A4Ch */ case    1:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82069A4Ch case    1:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82069A4Ch case    1:*/		return 0x82069A50;
		  /* 82069A50h */ case    2:  		/* bc 12, CR0_EQ, 188 */
		/* 82069A50h case    2:*/		if ( regs.CR[0].eq ) { return 0x82069B0C;  }
		/* 82069A50h case    2:*/		return 0x82069A54;
		  /* 82069A54h */ case    3:  		/* lwz R10, <#[R7 + 4]> */
		/* 82069A54h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + 0x00000004) );
		/* 82069A54h case    3:*/		return 0x82069A58;
		  /* 82069A58h */ case    4:  		/* lwz R11, <#[R8]> */
		/* 82069A58h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 82069A58h case    4:*/		return 0x82069A5C;
		  /* 82069A5Ch */ case    5:  		/* rlwinm R9, R10, 20, 28, 31 */
		/* 82069A5Ch case    5:*/		cpu::op::rlwinm<0,20,28,31>(regs,&regs.R9,regs.R10);
		/* 82069A5Ch case    5:*/		return 0x82069A60;
		  /* 82069A60h */ case    6:  		/* addi R9, R9, -3 */
		/* 82069A60h case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFD);
		/* 82069A60h case    6:*/		return 0x82069A64;
		  /* 82069A64h */ case    7:  		/* cmplwi CR6, R9, 11 */
		/* 82069A64h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x0000000B);
		/* 82069A64h case    7:*/		return 0x82069A68;
		  /* 82069A68h */ case    8:  		/* bc 12, CR6_GT, 156 */
		/* 82069A68h case    8:*/		if ( regs.CR[6].gt ) { return 0x82069B04;  }
		/* 82069A68h case    8:*/		return 0x82069A6C;
		  /* 82069A6Ch */ case    9:  		/* lis R12, -32256 */
		/* 82069A6Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8200);
		/* 82069A6Ch case    9:*/		return 0x82069A70;
		  /* 82069A70h */ case   10:  		/* addi R12, R12, 3560 */
		/* 82069A70h case   10:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xDE8);
		/* 82069A70h case   10:*/		return 0x82069A74;
		  /* 82069A74h */ case   11:  		/* lbzx R0, <#[R12 + R9]> */
		/* 82069A74h case   11:*/		cpu::mem::load8z( regs, &regs.R0, (uint32)(regs.R12 + regs.R9 + 0x00000000) );
		/* 82069A74h case   11:*/		return 0x82069A78;
		  /* 82069A78h */ case   12:  		/* lis R12, -32249 */
		/* 82069A78h case   12:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8207);
		/* 82069A78h case   12:*/		return 0x82069A7C;
		  /* 82069A7Ch */ case   13:  		/* ori R0, R0, 0 */
		/* 82069A7Ch case   13:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 82069A7Ch case   13:*/		return 0x82069A80;
		  /* 82069A80h */ case   14:  		/* addi R12, R12, -25964 */
		/* 82069A80h case   14:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFF9A94);
		/* 82069A80h case   14:*/		return 0x82069A84;
		  /* 82069A84h */ case   15:  		/* ori R0, R0, 0 */
		/* 82069A84h case   15:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 82069A84h case   15:*/		return 0x82069A88;
		  /* 82069A88h */ case   16:  		/* add R12, R12, R0 */
		/* 82069A88h case   16:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 82069A88h case   16:*/		return 0x82069A8C;
		  /* 82069A8Ch */ case   17:  		/* mtspr CTR, R12 */
		/* 82069A8Ch case   17:*/		regs.CTR = regs.R12;
		/* 82069A8Ch case   17:*/		return 0x82069A90;
		  /* 82069A90h */ case   18:  		/* bcctr 20, CR0_LT */
		/* 82069A90h case   18:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 82069A90h case   18:*/		return 0x82069A94;
		  /* 82069A94h */ case   19:  		/* rlwinm R10, R10, 24, 30, 31 */
		/* 82069A94h case   19:*/		cpu::op::rlwinm<0,24,30,31>(regs,&regs.R10,regs.R10);
		/* 82069A94h case   19:*/		return 0x82069A98;
		  /* 82069A98h */ case   20:  		/* li R9, 1 */
		/* 82069A98h case   20:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82069A98h case   20:*/		return 0x82069A9C;
		  /* 82069A9Ch */ case   21:  		/* subfic R10, R10, 3 */
		/* 82069A9Ch case   21:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R10,0x3);
		/* 82069A9Ch case   21:*/		return 0x82069AA0;
		  /* 82069AA0h */ case   22:  		/* slw R10, R9, R10 */
		/* 82069AA0h case   22:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82069AA0h case   22:*/		return 0x82069AA4;
		  /* 82069AA4h */ case   23:  		/* rlwinm R10, R10, 16, 0, 15 */
		/* 82069AA4h case   23:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R10,regs.R10);
		/* 82069AA4h case   23:*/		return 0x82069AA8;
		  /* 82069AA8h */ case   24:  		/* or R10, R10, R11 */
		/* 82069AA8h case   24:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 82069AA8h case   24:*/		return 0x82069AAC;
		  /* 82069AACh */ case   25:  		/* rlwimi R10, R11, 0, 16, 11 */
		/* 82069AACh case   25:*/		cpu::op::rlwimi<0,0,16,11>(regs,&regs.R10,regs.R11);
		/* 82069AACh case   25:*/		return 0x82069AB0;
		  /* 82069AB0h */ case   26:  		/* mr R11, R10 */
		/* 82069AB0h case   26:*/		regs.R11 = regs.R10;
		/* 82069AB0h case   26:*/		return 0x82069AB4;
		  /* 82069AB4h */ case   27:  		/* b 80 */
		/* 82069AB4h case   27:*/		return 0x82069B04;
		/* 82069AB4h case   27:*/		return 0x82069AB8;
		  /* 82069AB8h */ case   28:  		/* lwz R10, <#[R7]> */
		/* 82069AB8h case   28:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + 0x00000000) );
		/* 82069AB8h case   28:*/		return 0x82069ABC;
		  /* 82069ABCh */ case   29:  		/* li R9, 1 */
		/* 82069ABCh case   29:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 82069ABCh case   29:*/		return 0x82069AC0;
		  /* 82069AC0h */ case   30:  		/* rlwinm R10, R10, 15, 28, 31 */
		/* 82069AC0h case   30:*/		cpu::op::rlwinm<0,15,28,31>(regs,&regs.R10,regs.R10);
		/* 82069AC0h case   30:*/		return 0x82069AC4;
		  /* 82069AC4h */ case   31:  		/* subfic R10, R10, 15 */
		/* 82069AC4h case   31:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R10,0xF);
		/* 82069AC4h case   31:*/		return 0x82069AC8;
		  /* 82069AC8h */ case   32:  		/* slw R10, R9, R10 */
		/* 82069AC8h case   32:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82069AC8h case   32:*/		return 0x82069ACC;
		  /* 82069ACCh */ case   33:  		/* or R10, R10, R11 */
		/* 82069ACCh case   33:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 82069ACCh case   33:*/		return 0x82069AD0;
		  /* 82069AD0h */ case   34:  		/* rlwimi R10, R11, 0, 0, 15 */
		/* 82069AD0h case   34:*/		cpu::op::rlwimi<0,0,0,15>(regs,&regs.R10,regs.R11);
		/* 82069AD0h case   34:*/		return 0x82069AD4;
		  /* 82069AD4h */ case   35:  		/* b -36 */
		/* 82069AD4h case   35:*/		return 0x82069AB0;
		/* 82069AD4h case   35:*/		return 0x82069AD8;
		  /* 82069AD8h */ case   36:  		/* lwz R9, <#[R7]> */
		/* 82069AD8h case   36:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R7 + 0x00000000) );
		/* 82069AD8h case   36:*/		return 0x82069ADC;
		  /* 82069ADCh */ case   37:  		/* rlwinm. R7, R9, 0, 18, 18 */
		/* 82069ADCh case   37:*/		cpu::op::rlwinm<1,0,18,18>(regs,&regs.R7,regs.R9);
		/* 82069ADCh case   37:*/		return 0x82069AE0;
		  /* 82069AE0h */ case   38:  		/* bc 4, CR0_EQ, 36 */
		/* 82069AE0h case   38:*/		if ( !regs.CR[0].eq ) { return 0x82069B04;  }
		/* 82069AE0h case   38:*/		return 0x82069AE4;
		  /* 82069AE4h */ case   39:  		/* rlwinm. R9, R9, 0, 17, 17 */
		/* 82069AE4h case   39:*/		cpu::op::rlwinm<1,0,17,17>(regs,&regs.R9,regs.R9);
		/* 82069AE4h case   39:*/		return 0x82069AE8;
		  /* 82069AE8h */ case   40:  		/* bc 4, CR0_EQ, 28 */
		/* 82069AE8h case   40:*/		if ( !regs.CR[0].eq ) { return 0x82069B04;  }
		/* 82069AE8h case   40:*/		return 0x82069AEC;
		  /* 82069AECh */ case   41:  		/* b -88 */
		/* 82069AECh case   41:*/		return 0x82069A94;
		/* 82069AECh case   41:*/		return 0x82069AF0;
		  /* 82069AF0h */ case   42:  		/* rlwinm R10, R10, 0, 21, 22 */
		/* 82069AF0h case   42:*/		cpu::op::rlwinm<0,0,21,22>(regs,&regs.R10,regs.R10);
		/* 82069AF0h case   42:*/		return 0x82069AF4;
		  /* 82069AF4h */ case   43:  		/* cmplwi CR6, R10, 1536 */
		/* 82069AF4h case   43:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000600);
		/* 82069AF4h case   43:*/		return 0x82069AF8;
		  /* 82069AF8h */ case   44:  		/* bc 4, CR6_EQ, 12 */
		/* 82069AF8h case   44:*/		if ( !regs.CR[6].eq ) { return 0x82069B04;  }
		/* 82069AF8h case   44:*/		return 0x82069AFC;
		  /* 82069AFCh */ case   45:  		/* li R10, 1 */
		/* 82069AFCh case   45:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82069AFCh case   45:*/		return 0x82069B00;
		  /* 82069B00h */ case   46:  		/* stw R10, <#[R8 + 24]> */
		/* 82069B00h case   46:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R8 + 0x00000018) );
		/* 82069B00h case   46:*/		return 0x82069B04;
	}
	return 0x82069B04;
} // Block from 82069A48h-82069B04h (47 instructions)

//////////////////////////////////////////////////////
// Block at 82069B04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069B04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069B04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069B04);
		  /* 82069B04h */ case    0:  		/* stw R11, <#[R8]> */
		/* 82069B04h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 82069B04h case    0:*/		return 0x82069B08;
		  /* 82069B08h */ case    1:  		/* b 420 */
		/* 82069B08h case    1:*/		return 0x82069CAC;
		/* 82069B08h case    1:*/		return 0x82069B0C;
	}
	return 0x82069B0C;
} // Block from 82069B04h-82069B0Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82069B0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069B0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069B0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069B0C);
		  /* 82069B0Ch */ case    0:  		/* lwz R11, <#[R8 + 12]> */
		/* 82069B0Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x0000000C) );
		/* 82069B0Ch case    0:*/		return 0x82069B10;
		  /* 82069B10h */ case    1:  		/* li R3, 1 */
		/* 82069B10h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82069B10h case    1:*/		return 0x82069B14;
		  /* 82069B14h */ case    2:  		/* cmpwi CR6, R11, 0 */
		/* 82069B14h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82069B14h case    2:*/		return 0x82069B18;
		  /* 82069B18h */ case    3:  		/* bc 4, CR6_EQ, 48 */
		/* 82069B18h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82069B48;  }
		/* 82069B18h case    3:*/		return 0x82069B1C;
		  /* 82069B1Ch */ case    4:  		/* rlwinm. R11, R4, 0, 24, 31 */
		/* 82069B1Ch case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R4);
		/* 82069B1Ch case    4:*/		return 0x82069B20;
		  /* 82069B20h */ case    5:  		/* stw R3, <#[R8 + 12]> */
		/* 82069B20h case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R8 + 0x0000000C) );
		/* 82069B20h case    5:*/		return 0x82069B24;
		  /* 82069B24h */ case    6:  		/* addic R10, R11, -1 */
		/* 82069B24h case    6:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R11,0xFFFFFFFF);
		/* 82069B24h case    6:*/		return 0x82069B28;
	}
	return 0x82069B28;
} // Block from 82069B0Ch-82069B28h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82069B28h
// Function '?GenCommon@Microcode@CMicrocodeBuilder@D3D@@QAAXPAU_UCODE_R500UCODE_COMMON@@PAVStreamWriter@23@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069B28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069B28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069B28);
		  /* 82069B28h */ case    0:  		/* subfe R11, R10, R11 */
		/* 82069B28h case    0:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82069B28h case    0:*/		return 0x82069B2C;
		  /* 82069B2Ch */ case    1:  		/* stw R11, <#[R8 + 16]> */
		/* 82069B2Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00000010) );
		/* 82069B2Ch case    1:*/		return 0x82069B30;
		  /* 82069B30h */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 82069B30h case    2:*/		if ( regs.CR[0].eq ) { return 0x82069B40;  }
		/* 82069B30h case    2:*/		return 0x82069B34;
		  /* 82069B34h */ case    3:  		/* rlwinm. R11, R5, 0, 24, 31 */
		/* 82069B34h case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R5);
		/* 82069B34h case    3:*/		return 0x82069B38;
		  /* 82069B38h */ case    4:  		/* mr R11, R3 */
		/* 82069B38h case    4:*/		regs.R11 = regs.R3;
		/* 82069B38h case    4:*/		return 0x82069B3C;
		  /* 82069B3Ch */ case    5:  		/* bc 12, CR0_EQ, 8 */
		/* 82069B3Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x82069B44;  }
		/* 82069B3Ch case    5:*/		return 0x82069B40;
	}
	return 0x82069B40;
} // Block from 82069B28h-82069B40h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82069B40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069B40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069B40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069B40);
		  /* 82069B40h */ case    0:  		/* li R11, 0 */
		/* 82069B40h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82069B40h case    0:*/		return 0x82069B44;
	}
	return 0x82069B44;
} // Block from 82069B40h-82069B44h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82069B44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069B44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069B44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069B44);
		  /* 82069B44h */ case    0:  		/* stw R11, <#[R8 + 20]> */
		/* 82069B44h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00000014) );
		/* 82069B44h case    0:*/		return 0x82069B48;
	}
	return 0x82069B48;
} // Block from 82069B44h-82069B48h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82069B48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069B48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069B48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069B48);
		  /* 82069B48h */ case    0:  		/* lwz R11, <#[R8 + 4]> */
		/* 82069B48h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000004) );
		/* 82069B48h case    0:*/		return 0x82069B4C;
		  /* 82069B4Ch */ case    1:  		/* rlwinm. R10, R4, 0, 24, 31 */
		/* 82069B4Ch case    1:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R4);
		/* 82069B4Ch case    1:*/		return 0x82069B50;
		  /* 82069B50h */ case    2:  		/* bc 12, CR0_EQ, 44 */
		/* 82069B50h case    2:*/		if ( regs.CR[0].eq ) { return 0x82069B7C;  }
		/* 82069B50h case    2:*/		return 0x82069B54;
		  /* 82069B54h */ case    3:  		/* lwz R10, <#[R7]> */
		/* 82069B54h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + 0x00000000) );
		/* 82069B54h case    3:*/		return 0x82069B58;
		  /* 82069B58h */ case    4:  		/* cmpwi CR6, R11, -1 */
		/* 82069B58h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82069B58h case    4:*/		return 0x82069B5C;
		  /* 82069B5Ch */ case    5:  		/* rlwinm. R9, R10, 0, 27, 31 */
		/* 82069B5Ch case    5:*/		cpu::op::rlwinm<1,0,27,31>(regs,&regs.R9,regs.R10);
		/* 82069B5Ch case    5:*/		return 0x82069B60;
		  /* 82069B60h */ case    6:  		/* rlwinm R9, R10, 20, 26, 31 */
		/* 82069B60h case    6:*/		cpu::op::rlwinm<0,20,26,31>(regs,&regs.R9,regs.R10);
		/* 82069B60h case    6:*/		return 0x82069B64;
		  /* 82069B64h */ case    7:  		/* bc 12, CR6_EQ, 12 */
		/* 82069B64h case    7:*/		if ( regs.CR[6].eq ) { return 0x82069B70;  }
		/* 82069B64h case    7:*/		return 0x82069B68;
		  /* 82069B68h */ case    8:  		/* cmplw CR6, R11, R9 */
		/* 82069B68h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82069B68h case    8:*/		return 0x82069B6C;
		  /* 82069B6Ch */ case    9:  		/* bc 4, CR6_LT, 8 */
		/* 82069B6Ch case    9:*/		if ( !regs.CR[6].lt ) { return 0x82069B74;  }
		/* 82069B6Ch case    9:*/		return 0x82069B70;
	}
	return 0x82069B70;
} // Block from 82069B48h-82069B70h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82069B70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069B70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069B70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069B70);
		  /* 82069B70h */ case    0:  		/* mr R11, R9 */
		/* 82069B70h case    0:*/		regs.R11 = regs.R9;
		/* 82069B70h case    0:*/		return 0x82069B74;
	}
	return 0x82069B74;
} // Block from 82069B70h-82069B74h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82069B74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069B74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069B74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069B74);
		  /* 82069B74h */ case    0:  		/* rlwinm R10, R10, 27, 26, 31 */
		/* 82069B74h case    0:*/		cpu::op::rlwinm<0,27,26,31>(regs,&regs.R10,regs.R10);
		/* 82069B74h case    0:*/		return 0x82069B78;
		  /* 82069B78h */ case    1:  		/* b 284 */
		/* 82069B78h case    1:*/		return 0x82069C94;
		/* 82069B78h case    1:*/		return 0x82069B7C;
	}
	return 0x82069B7C;
} // Block from 82069B74h-82069B7Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82069B7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069B7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069B7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069B7C);
		  /* 82069B7Ch */ case    0:  		/* lwz R9, <#[R7 + 8]> */
		/* 82069B7Ch case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R7 + 0x00000008) );
		/* 82069B7Ch case    0:*/		return 0x82069B80;
		  /* 82069B80h */ case    1:  		/* lis R10, -32217 */
		/* 82069B80h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8227);
		/* 82069B80h case    1:*/		return 0x82069B84;
		  /* 82069B84h */ case    2:  		/* lwz R5, <#[R7]> */
		/* 82069B84h case    2:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R7 + 0x00000000) );
		/* 82069B84h case    2:*/		return 0x82069B88;
		  /* 82069B88h */ case    3:  		/* addi R10, R10, 1568 */
		/* 82069B88h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x620);
		/* 82069B88h case    3:*/		return 0x82069B8C;
		  /* 82069B8Ch */ case    4:  		/* rlwinm R6, R9, 8, 27, 31 */
		/* 82069B8Ch case    4:*/		cpu::op::rlwinm<0,8,27,31>(regs,&regs.R6,regs.R9);
		/* 82069B8Ch case    4:*/		return 0x82069B90;
		  /* 82069B90h */ case    5:  		/* addi R4, R10, 32 */
		/* 82069B90h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0x20);
		/* 82069B90h case    5:*/		return 0x82069B94;
		  /* 82069B94h */ case    6:  		/* rlwinm R31, R5, 6, 26, 31 */
		/* 82069B94h case    6:*/		cpu::op::rlwinm<0,6,26,31>(regs,&regs.R31,regs.R5);
		/* 82069B94h case    6:*/		return 0x82069B98;
		  /* 82069B98h */ case    7:  		/* lbzx R6, <#[R6 + R10]> */
		/* 82069B98h case    7:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R6 + regs.R10 + 0x00000000) );
		/* 82069B98h case    7:*/		return 0x82069B9C;
		  /* 82069B9Ch */ case    8:  		/* lbzx R4, <#[R31 + R4]> */
		/* 82069B9Ch case    8:*/		cpu::mem::load8z( regs, &regs.R4, (uint32)(regs.R31 + regs.R4 + 0x00000000) );
		/* 82069B9Ch case    8:*/		return 0x82069BA0;
		  /* 82069BA0h */ case    9:  		/* cmplwi CR6, R6, 1 */
		/* 82069BA0h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000001);
		/* 82069BA0h case    9:*/		return 0x82069BA4;
		  /* 82069BA4h */ case   10:  		/* bc 12, CR6_LT, 40 */
		/* 82069BA4h case   10:*/		if ( regs.CR[6].lt ) { return 0x82069BCC;  }
		/* 82069BA4h case   10:*/		return 0x82069BA8;
		  /* 82069BA8h */ case   11:  		/* rlwinm. R10, R9, 0, 0, 0 */
		/* 82069BA8h case   11:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R10,regs.R9);
		/* 82069BA8h case   11:*/		return 0x82069BAC;
		  /* 82069BACh */ case   12:  		/* bc 12, CR0_EQ, 32 */
		/* 82069BACh case   12:*/		if ( regs.CR[0].eq ) { return 0x82069BCC;  }
		/* 82069BACh case   12:*/		return 0x82069BB0;
		  /* 82069BB0h */ case   13:  		/* lbz R10, <#[R7 + 9]> */
		/* 82069BB0h case   13:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R7 + 0x00000009) );
		/* 82069BB0h case   13:*/		return 0x82069BB4;
		  /* 82069BB4h */ case   14:  		/* cmpwi CR6, R11, -1 */
		/* 82069BB4h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82069BB4h case   14:*/		return 0x82069BB8;
		  /* 82069BB8h */ case   15:  		/* rlwinm R10, R10, 0, 26, 31 */
		/* 82069BB8h case   15:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R10,regs.R10);
		/* 82069BB8h case   15:*/		return 0x82069BBC;
		  /* 82069BBCh */ case   16:  		/* bc 12, CR6_EQ, 12 */
		/* 82069BBCh case   16:*/		if ( regs.CR[6].eq ) { return 0x82069BC8;  }
		/* 82069BBCh case   16:*/		return 0x82069BC0;
		  /* 82069BC0h */ case   17:  		/* cmplw CR6, R11, R10 */
		/* 82069BC0h case   17:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82069BC0h case   17:*/		return 0x82069BC4;
		  /* 82069BC4h */ case   18:  		/* bc 4, CR6_LT, 8 */
		/* 82069BC4h case   18:*/		if ( !regs.CR[6].lt ) { return 0x82069BCC;  }
		/* 82069BC4h case   18:*/		return 0x82069BC8;
	}
	return 0x82069BC8;
} // Block from 82069B7Ch-82069BC8h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82069BC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069BC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069BC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069BC8);
		  /* 82069BC8h */ case    0:  		/* mr R11, R10 */
		/* 82069BC8h case    0:*/		regs.R11 = regs.R10;
		/* 82069BC8h case    0:*/		return 0x82069BCC;
	}
	return 0x82069BCC;
} // Block from 82069BC8h-82069BCCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82069BCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069BCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069BCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069BCC);
		  /* 82069BCCh */ case    0:  		/* cmplwi CR6, R6, 2 */
		/* 82069BCCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000002);
		/* 82069BCCh case    0:*/		return 0x82069BD0;
		  /* 82069BD0h */ case    1:  		/* bc 12, CR6_LT, 40 */
		/* 82069BD0h case    1:*/		if ( regs.CR[6].lt ) { return 0x82069BF8;  }
		/* 82069BD0h case    1:*/		return 0x82069BD4;
		  /* 82069BD4h */ case    2:  		/* rlwinm. R10, R9, 0, 1, 1 */
		/* 82069BD4h case    2:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R9);
		/* 82069BD4h case    2:*/		return 0x82069BD8;
		  /* 82069BD8h */ case    3:  		/* bc 12, CR0_EQ, 32 */
		/* 82069BD8h case    3:*/		if ( regs.CR[0].eq ) { return 0x82069BF8;  }
		/* 82069BD8h case    3:*/		return 0x82069BDC;
		  /* 82069BDCh */ case    4:  		/* lbz R10, <#[R7 + 10]> */
		/* 82069BDCh case    4:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R7 + 0x0000000A) );
		/* 82069BDCh case    4:*/		return 0x82069BE0;
		  /* 82069BE0h */ case    5:  		/* cmpwi CR6, R11, -1 */
		/* 82069BE0h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82069BE0h case    5:*/		return 0x82069BE4;
		  /* 82069BE4h */ case    6:  		/* rlwinm R10, R10, 0, 26, 31 */
		/* 82069BE4h case    6:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R10,regs.R10);
		/* 82069BE4h case    6:*/		return 0x82069BE8;
		  /* 82069BE8h */ case    7:  		/* bc 12, CR6_EQ, 12 */
		/* 82069BE8h case    7:*/		if ( regs.CR[6].eq ) { return 0x82069BF4;  }
		/* 82069BE8h case    7:*/		return 0x82069BEC;
		  /* 82069BECh */ case    8:  		/* cmplw CR6, R11, R10 */
		/* 82069BECh case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82069BECh case    8:*/		return 0x82069BF0;
		  /* 82069BF0h */ case    9:  		/* bc 4, CR6_LT, 8 */
		/* 82069BF0h case    9:*/		if ( !regs.CR[6].lt ) { return 0x82069BF8;  }
		/* 82069BF0h case    9:*/		return 0x82069BF4;
	}
	return 0x82069BF4;
} // Block from 82069BCCh-82069BF4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82069BF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069BF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069BF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069BF4);
		  /* 82069BF4h */ case    0:  		/* mr R11, R10 */
		/* 82069BF4h case    0:*/		regs.R11 = regs.R10;
		/* 82069BF4h case    0:*/		return 0x82069BF8;
	}
	return 0x82069BF8;
} // Block from 82069BF4h-82069BF8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82069BF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069BF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069BF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069BF8);
		  /* 82069BF8h */ case    0:  		/* cmplwi CR6, R6, 3 */
		/* 82069BF8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000003);
		/* 82069BF8h case    0:*/		return 0x82069BFC;
		  /* 82069BFCh */ case    1:  		/* bc 4, CR6_LT, 12 */
		/* 82069BFCh case    1:*/		if ( !regs.CR[6].lt ) { return 0x82069C08;  }
		/* 82069BFCh case    1:*/		return 0x82069C00;
		  /* 82069C00h */ case    2:  		/* cmplwi CR6, R4, 1 */
		/* 82069C00h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000001);
		/* 82069C00h case    2:*/		return 0x82069C04;
		  /* 82069C04h */ case    3:  		/* bc 4, CR6_EQ, 36 */
		/* 82069C04h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82069C28;  }
		/* 82069C04h case    3:*/		return 0x82069C08;
	}
	return 0x82069C08;
} // Block from 82069BF8h-82069C08h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82069C08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069C08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069C08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069C08);
		  /* 82069C08h */ case    0:  		/* rlwinm. R10, R9, 0, 2, 2 */
		/* 82069C08h case    0:*/		cpu::op::rlwinm<1,0,2,2>(regs,&regs.R10,regs.R9);
		/* 82069C08h case    0:*/		return 0x82069C0C;
		  /* 82069C0Ch */ case    1:  		/* bc 12, CR0_EQ, 28 */
		/* 82069C0Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82069C28;  }
		/* 82069C0Ch case    1:*/		return 0x82069C10;
		  /* 82069C10h */ case    2:  		/* rlwinm R10, R9, 0, 26, 31 */
		/* 82069C10h case    2:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R10,regs.R9);
		/* 82069C10h case    2:*/		return 0x82069C14;
		  /* 82069C14h */ case    3:  		/* cmpwi CR6, R11, -1 */
		/* 82069C14h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82069C14h case    3:*/		return 0x82069C18;
		  /* 82069C18h */ case    4:  		/* bc 12, CR6_EQ, 12 */
		/* 82069C18h case    4:*/		if ( regs.CR[6].eq ) { return 0x82069C24;  }
		/* 82069C18h case    4:*/		return 0x82069C1C;
		  /* 82069C1Ch */ case    5:  		/* cmplw CR6, R11, R10 */
		/* 82069C1Ch case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82069C1Ch case    5:*/		return 0x82069C20;
		  /* 82069C20h */ case    6:  		/* bc 4, CR6_LT, 8 */
		/* 82069C20h case    6:*/		if ( !regs.CR[6].lt ) { return 0x82069C28;  }
		/* 82069C20h case    6:*/		return 0x82069C24;
	}
	return 0x82069C24;
} // Block from 82069C08h-82069C24h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82069C24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069C24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069C24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069C24);
		  /* 82069C24h */ case    0:  		/* mr R11, R10 */
		/* 82069C24h case    0:*/		regs.R11 = regs.R10;
		/* 82069C24h case    0:*/		return 0x82069C28;
	}
	return 0x82069C28;
} // Block from 82069C24h-82069C28h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82069C28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069C28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069C28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069C28);
		  /* 82069C28h */ case    0:  		/* cmplwi CR6, R4, 2 */
		/* 82069C28h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000002);
		/* 82069C28h case    0:*/		return 0x82069C2C;
		  /* 82069C2Ch */ case    1:  		/* bc 4, CR6_EQ, 44 */
		/* 82069C2Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82069C58;  }
		/* 82069C2Ch case    1:*/		return 0x82069C30;
		  /* 82069C30h */ case    2:  		/* mr R10, R5 */
		/* 82069C30h case    2:*/		regs.R10 = regs.R5;
		/* 82069C30h case    2:*/		return 0x82069C34;
		  /* 82069C34h */ case    3:  		/* lwz R7, <#[R7 + 4]> */
		/* 82069C34h case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000004) );
		/* 82069C34h case    3:*/		return 0x82069C38;
		  /* 82069C38h */ case    4:  		/* cmpwi CR6, R11, -1 */
		/* 82069C38h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82069C38h case    4:*/		return 0x82069C3C;
		  /* 82069C3Ch */ case    5:  		/* rlwimi R10, R9, 30, 4, 4 */
		/* 82069C3Ch case    5:*/		cpu::op::rlwimi<0,30,4,4>(regs,&regs.R10,regs.R9);
		/* 82069C3Ch case    5:*/		return 0x82069C40;
		  /* 82069C40h */ case    6:  		/* rlwimi R7, R10, 6, 30, 31 */
		/* 82069C40h case    6:*/		cpu::op::rlwimi<0,6,30,31>(regs,&regs.R7,regs.R10);
		/* 82069C40h case    6:*/		return 0x82069C44;
		  /* 82069C44h */ case    7:  		/* rlwinm R10, R7, 0, 26, 31 */
		/* 82069C44h case    7:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R10,regs.R7);
		/* 82069C44h case    7:*/		return 0x82069C48;
		  /* 82069C48h */ case    8:  		/* bc 12, CR6_EQ, 12 */
		/* 82069C48h case    8:*/		if ( regs.CR[6].eq ) { return 0x82069C54;  }
		/* 82069C48h case    8:*/		return 0x82069C4C;
		  /* 82069C4Ch */ case    9:  		/* cmplw CR6, R11, R10 */
		/* 82069C4Ch case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82069C4Ch case    9:*/		return 0x82069C50;
		  /* 82069C50h */ case   10:  		/* bc 4, CR6_LT, 8 */
		/* 82069C50h case   10:*/		if ( !regs.CR[6].lt ) { return 0x82069C58;  }
		/* 82069C50h case   10:*/		return 0x82069C54;
	}
	return 0x82069C54;
} // Block from 82069C28h-82069C54h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82069C54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069C54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069C54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069C54);
		  /* 82069C54h */ case    0:  		/* mr R11, R10 */
		/* 82069C54h case    0:*/		regs.R11 = regs.R10;
		/* 82069C54h case    0:*/		return 0x82069C58;
	}
	return 0x82069C58;
} // Block from 82069C54h-82069C58h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82069C58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069C58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069C58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069C58);
		  /* 82069C58h */ case    0:  		/* rlwinm. R10, R5, 0, 16, 16 */
		/* 82069C58h case    0:*/		cpu::op::rlwinm<1,0,16,16>(regs,&regs.R10,regs.R5);
		/* 82069C58h case    0:*/		return 0x82069C5C;
		  /* 82069C5Ch */ case    1:  		/* rlwinm R10, R5, 0, 26, 31 */
		/* 82069C5Ch case    1:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R10,regs.R5);
		/* 82069C5Ch case    1:*/		return 0x82069C60;
		  /* 82069C60h */ case    2:  		/* bc 12, CR0_EQ, 28 */
		/* 82069C60h case    2:*/		if ( regs.CR[0].eq ) { return 0x82069C7C;  }
		/* 82069C60h case    2:*/		return 0x82069C64;
		  /* 82069C64h */ case    3:  		/* cmplwi CR6, R10, 32 */
		/* 82069C64h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000020);
		/* 82069C64h case    3:*/		return 0x82069C68;
		  /* 82069C68h */ case    4:  		/* bc 12, CR6_LT, 64 */
		/* 82069C68h case    4:*/		if ( regs.CR[6].lt ) { return 0x82069CA8;  }
		/* 82069C68h case    4:*/		return 0x82069C6C;
		  /* 82069C6Ch */ case    5:  		/* cmplwi CR6, R10, 37 */
		/* 82069C6Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000025);
		/* 82069C6Ch case    5:*/		return 0x82069C70;
		  /* 82069C70h */ case    6:  		/* bc 12, CR6_GT, 56 */
		/* 82069C70h case    6:*/		if ( regs.CR[6].gt ) { return 0x82069CA8;  }
		/* 82069C70h case    6:*/		return 0x82069C74;
		  /* 82069C74h */ case    7:  		/* stw R3, <#[R8 + 24]> */
		/* 82069C74h case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R8 + 0x00000018) );
		/* 82069C74h case    7:*/		return 0x82069C78;
		  /* 82069C78h */ case    8:  		/* b 48 */
		/* 82069C78h case    8:*/		return 0x82069CA8;
		/* 82069C78h case    8:*/		return 0x82069C7C;
	}
	return 0x82069C7C;
} // Block from 82069C58h-82069C7Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 82069C7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069C7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069C7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069C7C);
		  /* 82069C7Ch */ case    0:  		/* cmpwi CR6, R11, -1 */
		/* 82069C7Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82069C7Ch case    0:*/		return 0x82069C80;
		  /* 82069C80h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 82069C80h case    1:*/		if ( regs.CR[6].eq ) { return 0x82069C8C;  }
		/* 82069C80h case    1:*/		return 0x82069C84;
		  /* 82069C84h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 82069C84h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82069C84h case    2:*/		return 0x82069C88;
		  /* 82069C88h */ case    3:  		/* bc 4, CR6_LT, 8 */
		/* 82069C88h case    3:*/		if ( !regs.CR[6].lt ) { return 0x82069C90;  }
		/* 82069C88h case    3:*/		return 0x82069C8C;
	}
	return 0x82069C8C;
} // Block from 82069C7Ch-82069C8Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82069C8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069C8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069C8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069C8C);
		  /* 82069C8Ch */ case    0:  		/* mr R11, R10 */
		/* 82069C8Ch case    0:*/		regs.R11 = regs.R10;
		/* 82069C8Ch case    0:*/		return 0x82069C90;
	}
	return 0x82069C90;
} // Block from 82069C8Ch-82069C90h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82069C90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069C90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069C90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069C90);
		  /* 82069C90h */ case    0:  		/* rlwinm R10, R5, 24, 26, 31 */
		/* 82069C90h case    0:*/		cpu::op::rlwinm<0,24,26,31>(regs,&regs.R10,regs.R5);
		/* 82069C90h case    0:*/		return 0x82069C94;
	}
	return 0x82069C94;
} // Block from 82069C90h-82069C94h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82069C94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069C94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069C94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069C94);
		  /* 82069C94h */ case    0:  		/* cmpwi CR6, R11, -1 */
		/* 82069C94h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82069C94h case    0:*/		return 0x82069C98;
		  /* 82069C98h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 82069C98h case    1:*/		if ( regs.CR[6].eq ) { return 0x82069CA4;  }
		/* 82069C98h case    1:*/		return 0x82069C9C;
		  /* 82069C9Ch */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 82069C9Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82069C9Ch case    2:*/		return 0x82069CA0;
		  /* 82069CA0h */ case    3:  		/* bc 4, CR6_LT, 8 */
		/* 82069CA0h case    3:*/		if ( !regs.CR[6].lt ) { return 0x82069CA8;  }
		/* 82069CA0h case    3:*/		return 0x82069CA4;
	}
	return 0x82069CA4;
} // Block from 82069C94h-82069CA4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82069CA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069CA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069CA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069CA4);
		  /* 82069CA4h */ case    0:  		/* mr R11, R10 */
		/* 82069CA4h case    0:*/		regs.R11 = regs.R10;
		/* 82069CA4h case    0:*/		return 0x82069CA8;
	}
	return 0x82069CA8;
} // Block from 82069CA4h-82069CA8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82069CA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069CA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069CA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069CA8);
		  /* 82069CA8h */ case    0:  		/* stw R11, <#[R8 + 4]> */
		/* 82069CA8h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00000004) );
		/* 82069CA8h case    0:*/		return 0x82069CAC;
	}
	return 0x82069CAC;
} // Block from 82069CA8h-82069CACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82069CACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069CAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069CAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069CAC);
		  /* 82069CACh */ case    0:  		/* ld R31, <#[R1 - 8]> */
		/* 82069CACh case    0:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82069CACh case    0:*/		return 0x82069CB0;
		  /* 82069CB0h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82069CB0h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82069CB0h case    1:*/		return 0x82069CB4;
	}
	return 0x82069CB4;
} // Block from 82069CACh-82069CB4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82069CB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069CB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069CB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069CB4);
		  /* 82069CB4h */ case    0:  		/* nop */
		/* 82069CB4h case    0:*/		cpu::op::nop();
		/* 82069CB4h case    0:*/		return 0x82069CB8;
	}
	return 0x82069CB8;
} // Block from 82069CB4h-82069CB8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82069CB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069CB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069CB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069CB8);
		  /* 82069CB8h */ case    0:  		/* mfspr R12, LR */
		/* 82069CB8h case    0:*/		regs.R12 = regs.LR;
		/* 82069CB8h case    0:*/		return 0x82069CBC;
		  /* 82069CBCh */ case    1:  		/* bl 161156 */
		/* 82069CBCh case    1:*/		regs.LR = 0x82069CC0; return 0x82091240;
		/* 82069CBCh case    1:*/		return 0x82069CC0;
		  /* 82069CC0h */ case    2:  		/* stwu R1, <#[R1 - 224]> */
		/* 82069CC0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF20) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF20);
		/* 82069CC0h case    2:*/		return 0x82069CC4;
		  /* 82069CC4h */ case    3:  		/* lwz R27, <#[R3 + 256]> */
		/* 82069CC4h case    3:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R3 + 0x00000100) );
		/* 82069CC4h case    3:*/		return 0x82069CC8;
		  /* 82069CC8h */ case    4:  		/* mr R24, R3 */
		/* 82069CC8h case    4:*/		regs.R24 = regs.R3;
		/* 82069CC8h case    4:*/		return 0x82069CCC;
		  /* 82069CCCh */ case    5:  		/* lwz R28, <#[R3 + 260]> */
		/* 82069CCCh case    5:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R3 + 0x00000104) );
		/* 82069CCCh case    5:*/		return 0x82069CD0;
		  /* 82069CD0h */ case    6:  		/* mr R25, R5 */
		/* 82069CD0h case    6:*/		regs.R25 = regs.R5;
		/* 82069CD0h case    6:*/		return 0x82069CD4;
		  /* 82069CD4h */ case    7:  		/* mr R23, R6 */
		/* 82069CD4h case    7:*/		regs.R23 = regs.R6;
		/* 82069CD4h case    7:*/		return 0x82069CD8;
		  /* 82069CD8h */ case    8:  		/* mr R22, R7 */
		/* 82069CD8h case    8:*/		regs.R22 = regs.R7;
		/* 82069CD8h case    8:*/		return 0x82069CDC;
		  /* 82069CDCh */ case    9:  		/* rlwinm. R11, R4, 0, 24, 31 */
		/* 82069CDCh case    9:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R4);
		/* 82069CDCh case    9:*/		return 0x82069CE0;
		  /* 82069CE0h */ case   10:  		/* li R26, 12 */
		/* 82069CE0h case   10:*/		cpu::op::li<0>(regs,&regs.R26,0xC);
		/* 82069CE0h case   10:*/		return 0x82069CE4;
		  /* 82069CE4h */ case   11:  		/* bc 12, CR0_EQ, 196 */
		/* 82069CE4h case   11:*/		if ( regs.CR[0].eq ) { return 0x82069DA8;  }
		/* 82069CE4h case   11:*/		return 0x82069CE8;
		  /* 82069CE8h */ case   12:  		/* subf R11, R27, R28 */
		/* 82069CE8h case   12:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R27,regs.R28);
		/* 82069CE8h case   12:*/		return 0x82069CEC;
		  /* 82069CECh */ case   13:  		/* divw. R29, R11, R26 */
		/* 82069CECh case   13:*/		cpu::op::divw<1>(regs,&regs.R29,regs.R11,regs.R26);
		/* 82069CECh case   13:*/		return 0x82069CF0;
		  /* 82069CF0h */ case   14:  		/* bc 12, CR0_EQ, 184 */
		/* 82069CF0h case   14:*/		if ( regs.CR[0].eq ) { return 0x82069DA8;  }
		/* 82069CF0h case   14:*/		return 0x82069CF4;
		  /* 82069CF4h */ case   15:  		/* addi R31, R27, 8 */
		/* 82069CF4h case   15:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R27,0x8);
		/* 82069CF4h case   15:*/		return 0x82069CF8;
		  /* 82069CF8h */ case   16:  		/* li R30, 0 */
		/* 82069CF8h case   16:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82069CF8h case   16:*/		return 0x82069CFC;
		  /* 82069CFCh */ case   17:  		/* lwz R11, <#[R31 - 8]> */
		/* 82069CFCh case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0xFFFFFFF8) );
		/* 82069CFCh case   17:*/		return 0x82069D00;
		  /* 82069D00h */ case   18:  		/* mr R8, R22 */
		/* 82069D00h case   18:*/		regs.R8 = regs.R22;
		/* 82069D00h case   18:*/		return 0x82069D04;
		  /* 82069D04h */ case   19:  		/* addi R7, R1, 96 */
		/* 82069D04h case   19:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 82069D04h case   19:*/		return 0x82069D08;
		  /* 82069D08h */ case   20:  		/* mtspr CTR, R23 */
		/* 82069D08h case   20:*/		regs.CTR = regs.R23;
		/* 82069D08h case   20:*/		return 0x82069D0C;
		  /* 82069D0Ch */ case   21:  		/* mr R6, R30 */
		/* 82069D0Ch case   21:*/		regs.R6 = regs.R30;
		/* 82069D0Ch case   21:*/		return 0x82069D10;
		  /* 82069D10h */ case   22:  		/* li R5, 0 */
		/* 82069D10h case   22:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82069D10h case   22:*/		return 0x82069D14;
		  /* 82069D14h */ case   23:  		/* li R4, 0 */
		/* 82069D14h case   23:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82069D14h case   23:*/		return 0x82069D18;
		  /* 82069D18h */ case   24:  		/* stw R11, <#[R1 + 96]> */
		/* 82069D18h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82069D18h case   24:*/		return 0x82069D1C;
		  /* 82069D1Ch */ case   25:  		/* li R3, 1 */
		/* 82069D1Ch case   25:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82069D1Ch case   25:*/		return 0x82069D20;
		  /* 82069D20h */ case   26:  		/* lhz R11, <#[R31 - 2]> */
		/* 82069D20h case   26:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0xFFFFFFFE) );
		/* 82069D20h case   26:*/		return 0x82069D24;
		  /* 82069D24h */ case   27:  		/* stw R11, <#[R1 + 100]> */
		/* 82069D24h case   27:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 82069D24h case   27:*/		return 0x82069D28;
		  /* 82069D28h */ case   28:  		/* lhz R11, <#[R31 - 4]> */
		/* 82069D28h case   28:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0xFFFFFFFC) );
		/* 82069D28h case   28:*/		return 0x82069D2C;
		  /* 82069D2Ch */ case   29:  		/* lwz R10, <#[R31]> */
		/* 82069D2Ch case   29:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82069D2Ch case   29:*/		return 0x82069D30;
		  /* 82069D30h */ case   30:  		/* rlwinm R10, R10, 16, 0, 15 */
		/* 82069D30h case   30:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R10,regs.R10);
		/* 82069D30h case   30:*/		return 0x82069D34;
		  /* 82069D34h */ case   31:  		/* or R11, R10, R11 */
		/* 82069D34h case   31:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82069D34h case   31:*/		return 0x82069D38;
		  /* 82069D38h */ case   32:  		/* stw R11, <#[R1 + 88]> */
		/* 82069D38h case   32:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 82069D38h case   32:*/		return 0x82069D3C;
		  /* 82069D3Ch */ case   33:  		/* lhz R11, <#[R31]> */
		/* 82069D3Ch case   33:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82069D3Ch case   33:*/		return 0x82069D40;
		  /* 82069D40h */ case   34:  		/* stw R11, <#[R1 + 92]> */
		/* 82069D40h case   34:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 82069D40h case   34:*/		return 0x82069D44;
		  /* 82069D44h */ case   35:  		/* bcctrl 20, CR0_LT */
		/* 82069D44h case   35:*/		if ( 1 ) { regs.LR = 0x82069D48; return (uint32)regs.CTR; }
		/* 82069D44h case   35:*/		return 0x82069D48;
		  /* 82069D48h */ case   36:  		/* mr R8, R22 */
		/* 82069D48h case   36:*/		regs.R8 = regs.R22;
		/* 82069D48h case   36:*/		return 0x82069D4C;
		  /* 82069D4Ch */ case   37:  		/* addi R7, R1, 88 */
		/* 82069D4Ch case   37:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x58);
		/* 82069D4Ch case   37:*/		return 0x82069D50;
		  /* 82069D50h */ case   38:  		/* mtspr CTR, R23 */
		/* 82069D50h case   38:*/		regs.CTR = regs.R23;
		/* 82069D50h case   38:*/		return 0x82069D54;
		  /* 82069D54h */ case   39:  		/* addi R6, R30, 1 */
		/* 82069D54h case   39:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R30,0x1);
		/* 82069D54h case   39:*/		return 0x82069D58;
		  /* 82069D58h */ case   40:  		/* li R5, 0 */
		/* 82069D58h case   40:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82069D58h case   40:*/		return 0x82069D5C;
		  /* 82069D5Ch */ case   41:  		/* li R4, 0 */
		/* 82069D5Ch case   41:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82069D5Ch case   41:*/		return 0x82069D60;
		  /* 82069D60h */ case   42:  		/* li R3, 1 */
		/* 82069D60h case   42:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82069D60h case   42:*/		return 0x82069D64;
		  /* 82069D64h */ case   43:  		/* bcctrl 20, CR0_LT */
		/* 82069D64h case   43:*/		if ( 1 ) { regs.LR = 0x82069D68; return (uint32)regs.CTR; }
		/* 82069D64h case   43:*/		return 0x82069D68;
		  /* 82069D68h */ case   44:  		/* lwz R11, <#[R1 + 96]> */
		/* 82069D68h case   44:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82069D68h case   44:*/		return 0x82069D6C;
		  /* 82069D6Ch */ case   45:  		/* addic. R29, R29, -1 */
		/* 82069D6Ch case   45:*/		cpu::op::addic<1>(regs,&regs.R29,regs.R29,0xFFFFFFFF);
		/* 82069D6Ch case   45:*/		return 0x82069D70;
		  /* 82069D70h */ case   46:  		/* addi R30, R30, 2 */
		/* 82069D70h case   46:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x2);
		/* 82069D70h case   46:*/		return 0x82069D74;
		  /* 82069D74h */ case   47:  		/* stw R11, <#[R31 - 8]> */
		/* 82069D74h case   47:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0xFFFFFFF8) );
		/* 82069D74h case   47:*/		return 0x82069D78;
		  /* 82069D78h */ case   48:  		/* lwz R10, <#[R1 + 88]> */
		/* 82069D78h case   48:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 82069D78h case   48:*/		return 0x82069D7C;
		  /* 82069D7Ch */ case   49:  		/* lwz R11, <#[R1 + 100]> */
		/* 82069D7Ch case   49:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 82069D7Ch case   49:*/		return 0x82069D80;
		  /* 82069D80h */ case   50:  		/* rlwimi R11, R10, 16, 0, 15 */
		/* 82069D80h case   50:*/		cpu::op::rlwimi<0,16,0,15>(regs,&regs.R11,regs.R10);
		/* 82069D80h case   50:*/		return 0x82069D84;
		  /* 82069D84h */ case   51:  		/* stw R11, <#[R31 - 4]> */
		/* 82069D84h case   51:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0xFFFFFFFC) );
		/* 82069D84h case   51:*/		return 0x82069D88;
		  /* 82069D88h */ case   52:  		/* lwz R10, <#[R1 + 92]> */
		/* 82069D88h case   52:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000005C) );
		/* 82069D88h case   52:*/		return 0x82069D8C;
		  /* 82069D8Ch */ case   53:  		/* lwz R11, <#[R1 + 88]> */
		/* 82069D8Ch case   53:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 82069D8Ch case   53:*/		return 0x82069D90;
		  /* 82069D90h */ case   54:  		/* rlwinm R11, R11, 16, 16, 31 */
		/* 82069D90h case   54:*/		cpu::op::rlwinm<0,16,16,31>(regs,&regs.R11,regs.R11);
		/* 82069D90h case   54:*/		return 0x82069D94;
		  /* 82069D94h */ case   55:  		/* rlwinm R10, R10, 16, 0, 15 */
		/* 82069D94h case   55:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R10,regs.R10);
		/* 82069D94h case   55:*/		return 0x82069D98;
		  /* 82069D98h */ case   56:  		/* or R11, R11, R10 */
		/* 82069D98h case   56:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82069D98h case   56:*/		return 0x82069D9C;
		  /* 82069D9Ch */ case   57:  		/* stw R11, <#[R31]> */
		/* 82069D9Ch case   57:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82069D9Ch case   57:*/		return 0x82069DA0;
		  /* 82069DA0h */ case   58:  		/* addi R31, R31, 12 */
		/* 82069DA0h case   58:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0xC);
		/* 82069DA0h case   58:*/		return 0x82069DA4;
		  /* 82069DA4h */ case   59:  		/* bc 4, CR0_EQ, -168 */
		/* 82069DA4h case   59:*/		if ( !regs.CR[0].eq ) { return 0x82069CFC;  }
		/* 82069DA4h case   59:*/		return 0x82069DA8;
	}
	return 0x82069DA8;
} // Block from 82069CB8h-82069DA8h (60 instructions)

//////////////////////////////////////////////////////
// Block at 82069DA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069DA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069DA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069DA8);
		  /* 82069DA8h */ case    0:  		/* rlwinm. R11, R25, 0, 24, 31 */
		/* 82069DA8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R25);
		/* 82069DA8h case    0:*/		return 0x82069DAC;
		  /* 82069DACh */ case    1:  		/* bc 12, CR0_EQ, 228 */
		/* 82069DACh case    1:*/		if ( regs.CR[0].eq ) { return 0x82069E90;  }
		/* 82069DACh case    1:*/		return 0x82069DB0;
		  /* 82069DB0h */ case    2:  		/* subf R10, R27, R28 */
		/* 82069DB0h case    2:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R27,regs.R28);
		/* 82069DB0h case    2:*/		return 0x82069DB4;
		  /* 82069DB4h */ case    3:  		/* stw R28, <#[R1 + 80]> */
		/* 82069DB4h case    3:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000050) );
		/* 82069DB4h case    3:*/		return 0x82069DB8;
		  /* 82069DB8h */ case    4:  		/* mr R11, R28 */
		/* 82069DB8h case    4:*/		regs.R11 = regs.R28;
		/* 82069DB8h case    4:*/		return 0x82069DBC;
		  /* 82069DBCh */ case    5:  		/* divw R26, R10, R26 */
		/* 82069DBCh case    5:*/		cpu::op::divw<0>(regs,&regs.R26,regs.R10,regs.R26);
		/* 82069DBCh case    5:*/		return 0x82069DC0;
		  /* 82069DC0h */ case    6:  		/* li R10, 0 */
		/* 82069DC0h case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82069DC0h case    6:*/		return 0x82069DC4;
		  /* 82069DC4h */ case    7:  		/* mr R25, R11 */
		/* 82069DC4h case    7:*/		regs.R25 = regs.R11;
		/* 82069DC4h case    7:*/		return 0x82069DC8;
		  /* 82069DC8h */ case    8:  		/* stw R10, <#[R1 + 84]> */
		/* 82069DC8h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 82069DC8h case    8:*/		return 0x82069DCC;
		  /* 82069DCCh */ case    9:  		/* cmplwi CR6, R26, 0 */
		/* 82069DCCh case    9:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 82069DCCh case    9:*/		return 0x82069DD0;
		  /* 82069DD0h */ case   10:  		/* bc 12, CR6_EQ, 192 */
		/* 82069DD0h case   10:*/		if ( regs.CR[6].eq ) { return 0x82069E90;  }
		/* 82069DD0h case   10:*/		return 0x82069DD4;
		  /* 82069DD4h */ case   11:  		/* addi R30, R27, 8 */
		/* 82069DD4h case   11:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R27,0x8);
		/* 82069DD4h case   11:*/		return 0x82069DD8;
		  /* 82069DD8h */ case   12:  		/* mr R28, R26 */
		/* 82069DD8h case   12:*/		regs.R28 = regs.R26;
		/* 82069DD8h case   12:*/		return 0x82069DDC;
		  /* 82069DDCh */ case   13:  		/* lwz R11, <#[R30 - 4]> */
		/* 82069DDCh case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0xFFFFFFFC) );
		/* 82069DDCh case   13:*/		return 0x82069DE0;
		  /* 82069DE0h */ case   14:  		/* addi R31, R1, 112 */
		/* 82069DE0h case   14:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0x70);
		/* 82069DE0h case   14:*/		return 0x82069DE4;
		  /* 82069DE4h */ case   15:  		/* lwz R10, <#[R30]> */
		/* 82069DE4h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82069DE4h case   15:*/		return 0x82069DE8;
		  /* 82069DE8h */ case   16:  		/* li R29, 2 */
		/* 82069DE8h case   16:*/		cpu::op::li<0>(regs,&regs.R29,0x2);
		/* 82069DE8h case   16:*/		return 0x82069DEC;
		  /* 82069DECh */ case   17:  		/* lwz R9, <#[R30 - 8]> */
		/* 82069DECh case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0xFFFFFFF8) );
		/* 82069DECh case   17:*/		return 0x82069DF0;
		  /* 82069DF0h */ case   18:  		/* rlwinm R8, R11, 16, 16, 31 */
		/* 82069DF0h case   18:*/		cpu::op::rlwinm<0,16,16,31>(regs,&regs.R8,regs.R11);
		/* 82069DF0h case   18:*/		return 0x82069DF4;
		  /* 82069DF4h */ case   19:  		/* rlwinm R7, R10, 16, 0, 15 */
		/* 82069DF4h case   19:*/		cpu::op::rlwinm<0,16,0,15>(regs,&regs.R7,regs.R10);
		/* 82069DF4h case   19:*/		return 0x82069DF8;
		  /* 82069DF8h */ case   20:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 82069DF8h case   20:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 82069DF8h case   20:*/		return 0x82069DFC;
		  /* 82069DFCh */ case   21:  		/* or R8, R8, R7 */
		/* 82069DFCh case   21:*/		cpu::op::or<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 82069DFCh case   21:*/		return 0x82069E00;
		  /* 82069E00h */ case   22:  		/* rlwinm R10, R10, 16, 16, 31 */
		/* 82069E00h case   22:*/		cpu::op::rlwinm<0,16,16,31>(regs,&regs.R10,regs.R10);
		/* 82069E00h case   22:*/		return 0x82069E04;
		  /* 82069E04h */ case   23:  		/* stw R11, <#[R1 + 116]> */
		/* 82069E04h case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000074) );
		/* 82069E04h case   23:*/		return 0x82069E08;
		  /* 82069E08h */ case   24:  		/* stw R9, <#[R1 + 112]> */
		/* 82069E08h case   24:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000070) );
		/* 82069E08h case   24:*/		return 0x82069E0C;
		  /* 82069E0Ch */ case   25:  		/* stw R8, <#[R1 + 120]> */
		/* 82069E0Ch case   25:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000078) );
		/* 82069E0Ch case   25:*/		return 0x82069E10;
		  /* 82069E10h */ case   26:  		/* stw R10, <#[R1 + 124]> */
		/* 82069E10h case   26:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x0000007C) );
		/* 82069E10h case   26:*/		return 0x82069E14;
		  /* 82069E14h */ case   27:  		/* lwz R11, <#[R31 + 4]> */
		/* 82069E14h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82069E14h case   27:*/		return 0x82069E18;
		  /* 82069E18h */ case   28:  		/* li R10, 1 */
		/* 82069E18h case   28:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82069E18h case   28:*/		return 0x82069E1C;
		  /* 82069E1Ch */ case   29:  		/* rlwinm R11, R11, 20, 28, 31 */
		/* 82069E1Ch case   29:*/		cpu::op::rlwinm<0,20,28,31>(regs,&regs.R11,regs.R11);
		/* 82069E1Ch case   29:*/		return 0x82069E20;
		  /* 82069E20h */ case   30:  		/* slw R11, R10, R11 */
		/* 82069E20h case   30:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82069E20h case   30:*/		return 0x82069E24;
		  /* 82069E24h */ case   31:  		/* andi. R11, R11, 24702 */
		/* 82069E24h case   31:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x607E);
		/* 82069E24h case   31:*/		return 0x82069E28;
		  /* 82069E28h */ case   32:  		/* cmplwi CR0, R11, 0 */
		/* 82069E28h case   32:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82069E28h case   32:*/		return 0x82069E2C;
		  /* 82069E2Ch */ case   33:  		/* bc 12, CR0_EQ, 36 */
		/* 82069E2Ch case   33:*/		if ( regs.CR[0].eq ) { return 0x82069E50;  }
		/* 82069E2Ch case   33:*/		return 0x82069E30;
		  /* 82069E30h */ case   34:  		/* addi R9, R1, 84 */
		/* 82069E30h case   34:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x54);
		/* 82069E30h case   34:*/		return 0x82069E34;
		  /* 82069E34h */ case   35:  		/* addi R8, R1, 80 */
		/* 82069E34h case   35:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x50);
		/* 82069E34h case   35:*/		return 0x82069E38;
		  /* 82069E38h */ case   36:  		/* mr R7, R27 */
		/* 82069E38h case   36:*/		regs.R7 = regs.R27;
		/* 82069E38h case   36:*/		return 0x82069E3C;
		  /* 82069E3Ch */ case   37:  		/* mr R6, R22 */
		/* 82069E3Ch case   37:*/		regs.R6 = regs.R22;
		/* 82069E3Ch case   37:*/		return 0x82069E40;
		  /* 82069E40h */ case   38:  		/* mr R5, R23 */
		/* 82069E40h case   38:*/		regs.R5 = regs.R23;
		/* 82069E40h case   38:*/		return 0x82069E44;
		  /* 82069E44h */ case   39:  		/* mr R4, R31 */
		/* 82069E44h case   39:*/		regs.R4 = regs.R31;
		/* 82069E44h case   39:*/		return 0x82069E48;
		  /* 82069E48h */ case   40:  		/* mr R3, R24 */
		/* 82069E48h case   40:*/		regs.R3 = regs.R24;
		/* 82069E48h case   40:*/		return 0x82069E4C;
		  /* 82069E4Ch */ case   41:  		/* bl -8292 */
		/* 82069E4Ch case   41:*/		regs.LR = 0x82069E50; return 0x82067DE8;
		/* 82069E4Ch case   41:*/		return 0x82069E50;
	}
	return 0x82069E50;
} // Block from 82069DA8h-82069E50h (42 instructions)

//////////////////////////////////////////////////////
// Block at 82069E50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069E50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069E50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069E50);
		  /* 82069E50h */ case    0:  		/* addic. R29, R29, -1 */
		/* 82069E50h case    0:*/		cpu::op::addic<1>(regs,&regs.R29,regs.R29,0xFFFFFFFF);
		/* 82069E50h case    0:*/		return 0x82069E54;
		  /* 82069E54h */ case    1:  		/* addi R31, R31, 8 */
		/* 82069E54h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x8);
		/* 82069E54h case    1:*/		return 0x82069E58;
		  /* 82069E58h */ case    2:  		/* bc 4, CR0_EQ, -68 */
		/* 82069E58h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82069E14;  }
		/* 82069E58h case    2:*/		return 0x82069E5C;
		  /* 82069E5Ch */ case    3:  		/* addic. R28, R28, -1 */
		/* 82069E5Ch case    3:*/		cpu::op::addic<1>(regs,&regs.R28,regs.R28,0xFFFFFFFF);
		/* 82069E5Ch case    3:*/		return 0x82069E60;
		  /* 82069E60h */ case    4:  		/* addi R30, R30, 12 */
		/* 82069E60h case    4:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0xC);
		/* 82069E60h case    4:*/		return 0x82069E64;
		  /* 82069E64h */ case    5:  		/* bc 4, CR0_EQ, -136 */
		/* 82069E64h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82069DDC;  }
		/* 82069E64h case    5:*/		return 0x82069E68;
		  /* 82069E68h */ case    6:  		/* lwz R11, <#[R1 + 80]> */
		/* 82069E68h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82069E68h case    6:*/		return 0x82069E6C;
		  /* 82069E6Ch */ case    7:  		/* lwz R10, <#[R1 + 84]> */
		/* 82069E6Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 82069E6Ch case    7:*/		return 0x82069E70;
		  /* 82069E70h */ case    8:  		/* cmplw CR6, R25, R11 */
		/* 82069E70h case    8:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R11);
		/* 82069E70h case    8:*/		return 0x82069E74;
		  /* 82069E74h */ case    9:  		/* bc 4, CR6_EQ, 20 */
		/* 82069E74h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82069E88;  }
		/* 82069E74h case    9:*/		return 0x82069E78;
		  /* 82069E78h */ case   10:  		/* cmpwi CR6, R10, 0 */
		/* 82069E78h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 82069E78h case   10:*/		return 0x82069E7C;
		  /* 82069E7Ch */ case   11:  		/* bc 12, CR6_EQ, 20 */
		/* 82069E7Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x82069E90;  }
		/* 82069E7Ch case   11:*/		return 0x82069E80;
		  /* 82069E80h */ case   12:  		/* addi R11, R11, 12 */
		/* 82069E80h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xC);
		/* 82069E80h case   12:*/		return 0x82069E84;
		  /* 82069E84h */ case   13:  		/* stw R11, <#[R1 + 80]> */
		/* 82069E84h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82069E84h case   13:*/		return 0x82069E88;
	}
	return 0x82069E88;
} // Block from 82069E50h-82069E88h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82069E88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069E88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069E88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069E88);
		  /* 82069E88h */ case    0:  		/* cmpwi CR6, R10, 0 */
		/* 82069E88h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 82069E88h case    0:*/		return 0x82069E8C;
		  /* 82069E8Ch */ case    1:  		/* bc 4, CR6_EQ, -204 */
		/* 82069E8Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82069DC0;  }
		/* 82069E8Ch case    1:*/		return 0x82069E90;
	}
	return 0x82069E90;
} // Block from 82069E88h-82069E90h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82069E90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069E90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069E90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069E90);
		  /* 82069E90h */ case    0:  		/* addi R1, R1, 224 */
		/* 82069E90h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xE0);
		/* 82069E90h case    0:*/		return 0x82069E94;
		  /* 82069E94h */ case    1:  		/* b 160764 */
		/* 82069E94h case    1:*/		return 0x82091290;
		/* 82069E94h case    1:*/		return 0x82069E98;
		  /* 82069E98h */ case    2:  		/* lwz R11, <#[R5]> */
		/* 82069E98h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 82069E98h case    2:*/		return 0x82069E9C;
		  /* 82069E9Ch */ case    3:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 82069E9Ch case    3:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 82069E9Ch case    3:*/		return 0x82069EA0;
		  /* 82069EA0h */ case    4:  		/* cmplwi CR6, R11, 19 */
		/* 82069EA0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000013);
		/* 82069EA0h case    4:*/		return 0x82069EA4;
		  /* 82069EA4h */ case    5:  		/* bclr 12, CR6_GT */
		/* 82069EA4h case    5:*/		if ( regs.CR[6].gt ) { return (uint32)regs.LR; }
		/* 82069EA4h case    5:*/		return 0x82069EA8;
	}
	return 0x82069EA8;
} // Block from 82069E90h-82069EA8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82069EA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069EA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069EA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069EA8);
		  /* 82069EA8h */ case    0:  		/* lwz R9, <#[R5 + 4]> */
		/* 82069EA8h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R5 + 0x00000004) );
		/* 82069EA8h case    0:*/		return 0x82069EAC;
		  /* 82069EACh */ case    1:  		/* li R10, 1 */
		/* 82069EACh case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82069EACh case    1:*/		return 0x82069EB0;
		  /* 82069EB0h */ case    2:  		/* rlwinm R11, R4, 2, 0, 29 */
		/* 82069EB0h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R4);
		/* 82069EB0h case    2:*/		return 0x82069EB4;
		  /* 82069EB4h */ case    3:  		/* rlwinm R9, R9, 0, 29, 31 */
		/* 82069EB4h case    3:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R9,regs.R9);
		/* 82069EB4h case    3:*/		return 0x82069EB8;
		  /* 82069EB8h */ case    4:  		/* cmplwi CR6, R9, 7 */
		/* 82069EB8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000007);
		/* 82069EB8h case    4:*/		return 0x82069EBC;
		  /* 82069EBCh */ case    5:  		/* bc 12, CR6_EQ, 28 */
		/* 82069EBCh case    5:*/		if ( regs.CR[6].eq ) { return 0x82069ED8;  }
		/* 82069EBCh case    5:*/		return 0x82069EC0;
		  /* 82069EC0h */ case    6:  		/* rlwinm R9, R11, 29, 3, 29 */
		/* 82069EC0h case    6:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R9,regs.R11);
		/* 82069EC0h case    6:*/		return 0x82069EC4;
		  /* 82069EC4h */ case    7:  		/* rlwinm R8, R11, 0, 27, 31 */
		/* 82069EC4h case    7:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R8,regs.R11);
		/* 82069EC4h case    7:*/		return 0x82069EC8;
		  /* 82069EC8h */ case    8:  		/* slw R8, R10, R8 */
		/* 82069EC8h case    8:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R10,regs.R8);
		/* 82069EC8h case    8:*/		return 0x82069ECC;
		  /* 82069ECCh */ case    9:  		/* lwzx R7, <#[R9 + R3]> */
		/* 82069ECCh case    9:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 82069ECCh case    9:*/		return 0x82069ED0;
		  /* 82069ED0h */ case   10:  		/* or R8, R8, R7 */
		/* 82069ED0h case   10:*/		cpu::op::or<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 82069ED0h case   10:*/		return 0x82069ED4;
		  /* 82069ED4h */ case   11:  		/* stwx R8, <#[R9 + R3]> */
		/* 82069ED4h case   11:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 82069ED4h case   11:*/		return 0x82069ED8;
	}
	return 0x82069ED8;
} // Block from 82069EA8h-82069ED8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82069ED8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069ED8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069ED8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069ED8);
		  /* 82069ED8h */ case    0:  		/* lwz R9, <#[R5 + 4]> */
		/* 82069ED8h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R5 + 0x00000004) );
		/* 82069ED8h case    0:*/		return 0x82069EDC;
		  /* 82069EDCh */ case    1:  		/* rlwinm R9, R9, 0, 26, 28 */
		/* 82069EDCh case    1:*/		cpu::op::rlwinm<0,0,26,28>(regs,&regs.R9,regs.R9);
		/* 82069EDCh case    1:*/		return 0x82069EE0;
		  /* 82069EE0h */ case    2:  		/* cmplwi CR6, R9, 56 */
		/* 82069EE0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000038);
		/* 82069EE0h case    2:*/		return 0x82069EE4;
		  /* 82069EE4h */ case    3:  		/* bc 12, CR6_EQ, 32 */
		/* 82069EE4h case    3:*/		if ( regs.CR[6].eq ) { return 0x82069F04;  }
		/* 82069EE4h case    3:*/		return 0x82069EE8;
		  /* 82069EE8h */ case    4:  		/* addi R9, R11, 1 */
		/* 82069EE8h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x1);
		/* 82069EE8h case    4:*/		return 0x82069EEC;
		  /* 82069EECh */ case    5:  		/* rlwinm R8, R9, 29, 3, 29 */
		/* 82069EECh case    5:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R8,regs.R9);
		/* 82069EECh case    5:*/		return 0x82069EF0;
		  /* 82069EF0h */ case    6:  		/* rlwinm R9, R9, 0, 27, 31 */
		/* 82069EF0h case    6:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R9);
		/* 82069EF0h case    6:*/		return 0x82069EF4;
		  /* 82069EF4h */ case    7:  		/* slw R9, R10, R9 */
		/* 82069EF4h case    7:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 82069EF4h case    7:*/		return 0x82069EF8;
		  /* 82069EF8h */ case    8:  		/* lwzx R7, <#[R8 + R3]> */
		/* 82069EF8h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R8 + regs.R3 + 0x00000000) );
		/* 82069EF8h case    8:*/		return 0x82069EFC;
		  /* 82069EFCh */ case    9:  		/* or R9, R9, R7 */
		/* 82069EFCh case    9:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 82069EFCh case    9:*/		return 0x82069F00;
		  /* 82069F00h */ case   10:  		/* stwx R9, <#[R8 + R3]> */
		/* 82069F00h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R8 + regs.R3 + 0x00000000) );
		/* 82069F00h case   10:*/		return 0x82069F04;
	}
	return 0x82069F04;
} // Block from 82069ED8h-82069F04h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82069F04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069F04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069F04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069F04);
		  /* 82069F04h */ case    0:  		/* lwz R9, <#[R5 + 4]> */
		/* 82069F04h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R5 + 0x00000004) );
		/* 82069F04h case    0:*/		return 0x82069F08;
		  /* 82069F08h */ case    1:  		/* rlwinm R9, R9, 0, 23, 25 */
		/* 82069F08h case    1:*/		cpu::op::rlwinm<0,0,23,25>(regs,&regs.R9,regs.R9);
		/* 82069F08h case    1:*/		return 0x82069F0C;
		  /* 82069F0Ch */ case    2:  		/* cmplwi CR6, R9, 448 */
		/* 82069F0Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x000001C0);
		/* 82069F0Ch case    2:*/		return 0x82069F10;
		  /* 82069F10h */ case    3:  		/* bc 12, CR6_EQ, 32 */
		/* 82069F10h case    3:*/		if ( regs.CR[6].eq ) { return 0x82069F30;  }
		/* 82069F10h case    3:*/		return 0x82069F14;
		  /* 82069F14h */ case    4:  		/* addi R9, R11, 2 */
		/* 82069F14h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x2);
		/* 82069F14h case    4:*/		return 0x82069F18;
	}
	return 0x82069F18;
} // Block from 82069F04h-82069F18h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82069F18h
// Function '?ForEachInstruction@Microcode@CMicrocodeBuilder@D3D@@QAAX_N0P6AX000KPATGPUSHADER_INSTRUCTION@@PAX@Z2@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069F18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069F18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069F18);
		  /* 82069F18h */ case    0:  		/* rlwinm R8, R9, 29, 3, 29 */
		/* 82069F18h case    0:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R8,regs.R9);
		/* 82069F18h case    0:*/		return 0x82069F1C;
		  /* 82069F1Ch */ case    1:  		/* rlwinm R9, R9, 0, 27, 31 */
		/* 82069F1Ch case    1:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R9);
		/* 82069F1Ch case    1:*/		return 0x82069F20;
		  /* 82069F20h */ case    2:  		/* slw R9, R10, R9 */
		/* 82069F20h case    2:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 82069F20h case    2:*/		return 0x82069F24;
		  /* 82069F24h */ case    3:  		/* lwzx R7, <#[R8 + R3]> */
		/* 82069F24h case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R8 + regs.R3 + 0x00000000) );
		/* 82069F24h case    3:*/		return 0x82069F28;
		  /* 82069F28h */ case    4:  		/* or R9, R9, R7 */
		/* 82069F28h case    4:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 82069F28h case    4:*/		return 0x82069F2C;
		  /* 82069F2Ch */ case    5:  		/* stwx R9, <#[R8 + R3]> */
		/* 82069F2Ch case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R8 + regs.R3 + 0x00000000) );
		/* 82069F2Ch case    5:*/		return 0x82069F30;
	}
	return 0x82069F30;
} // Block from 82069F18h-82069F30h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82069F30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069F30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069F30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069F30);
		  /* 82069F30h */ case    0:  		/* lwz R9, <#[R5 + 4]> */
		/* 82069F30h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R5 + 0x00000004) );
		/* 82069F30h case    0:*/		return 0x82069F34;
		  /* 82069F34h */ case    1:  		/* rlwinm R9, R9, 0, 20, 22 */
		/* 82069F34h case    1:*/		cpu::op::rlwinm<0,0,20,22>(regs,&regs.R9,regs.R9);
		/* 82069F34h case    1:*/		return 0x82069F38;
		  /* 82069F38h */ case    2:  		/* cmplwi CR6, R9, 3584 */
		/* 82069F38h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000E00);
		/* 82069F38h case    2:*/		return 0x82069F3C;
		  /* 82069F3Ch */ case    3:  		/* bclr 12, CR6_EQ */
		/* 82069F3Ch case    3:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 82069F3Ch case    3:*/		return 0x82069F40;
	}
	return 0x82069F40;
} // Block from 82069F30h-82069F40h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82069F40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069F40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069F40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069F40);
		  /* 82069F40h */ case    0:  		/* addi R11, R11, 3 */
		/* 82069F40h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x3);
		/* 82069F40h case    0:*/		return 0x82069F44;
		  /* 82069F44h */ case    1:  		/* rlwinm R9, R11, 29, 3, 29 */
		/* 82069F44h case    1:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R9,regs.R11);
		/* 82069F44h case    1:*/		return 0x82069F48;
		  /* 82069F48h */ case    2:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 82069F48h case    2:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 82069F48h case    2:*/		return 0x82069F4C;
		  /* 82069F4Ch */ case    3:  		/* slw R11, R10, R11 */
		/* 82069F4Ch case    3:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82069F4Ch case    3:*/		return 0x82069F50;
		  /* 82069F50h */ case    4:  		/* lwzx R10, <#[R9 + R3]> */
		/* 82069F50h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 82069F50h case    4:*/		return 0x82069F54;
		  /* 82069F54h */ case    5:  		/* or R11, R11, R10 */
		/* 82069F54h case    5:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82069F54h case    5:*/		return 0x82069F58;
		  /* 82069F58h */ case    6:  		/* stwx R11, <#[R9 + R3]> */
		/* 82069F58h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 82069F58h case    6:*/		return 0x82069F5C;
		  /* 82069F5Ch */ case    7:  		/* bclr 20, CR0_LT */
		/* 82069F5Ch case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82069F5Ch case    7:*/		return 0x82069F60;
	}
	return 0x82069F60;
} // Block from 82069F40h-82069F60h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82069F60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069F60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069F60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069F60);
		  /* 82069F60h */ case    0:  		/* lwz R9, <#[R6]> */
		/* 82069F60h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + 0x00000000) );
		/* 82069F60h case    0:*/		return 0x82069F64;
		  /* 82069F64h */ case    1:  		/* rlwinm R11, R9, 0, 27, 31 */
		/* 82069F64h case    1:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R9);
		/* 82069F64h case    1:*/		return 0x82069F68;
		  /* 82069F68h */ case    2:  		/* cmplwi CR6, R11, 18 */
		/* 82069F68h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000012);
		/* 82069F68h case    2:*/		return 0x82069F6C;
		  /* 82069F6Ch */ case    3:  		/* bc 12, CR6_GT, 308 */
		/* 82069F6Ch case    3:*/		if ( regs.CR[6].gt ) { return 0x8206A0A0;  }
		/* 82069F6Ch case    3:*/		return 0x82069F70;
		  /* 82069F70h */ case    4:  		/* bc 12, CR6_EQ, 248 */
		/* 82069F70h case    4:*/		if ( regs.CR[6].eq ) { return 0x8206A068;  }
		/* 82069F70h case    4:*/		return 0x82069F74;
		  /* 82069F74h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 82069F74h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82069F74h case    5:*/		return 0x82069F78;
		  /* 82069F78h */ case    6:  		/* bc 12, CR6_EQ, 176 */
		/* 82069F78h case    6:*/		if ( regs.CR[6].eq ) { return 0x8206A028;  }
		/* 82069F78h case    6:*/		return 0x82069F7C;
		  /* 82069F7Ch */ case    7:  		/* cmplwi CR6, R11, 1 */
		/* 82069F7Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82069F7Ch case    7:*/		return 0x82069F80;
		  /* 82069F80h */ case    8:  		/* bc 12, CR6_EQ, 20 */
		/* 82069F80h case    8:*/		if ( regs.CR[6].eq ) { return 0x82069F94;  }
		/* 82069F80h case    8:*/		return 0x82069F84;
		  /* 82069F84h */ case    9:  		/* cmplwi CR6, R11, 15 */
		/* 82069F84h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000F);
		/* 82069F84h case    9:*/		return 0x82069F88;
		  /* 82069F88h */ case   10:  		/* bclr 4, CR6_GT */
		/* 82069F88h case   10:*/		if ( !regs.CR[6].gt ) { return (uint32)regs.LR; }
		/* 82069F88h case   10:*/		return 0x82069F8C;
	}
	return 0x82069F8C;
} // Block from 82069F60h-82069F8Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 82069F8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069F8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069F8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069F8C);
		  /* 82069F8Ch */ case    0:  		/* cmplwi CR6, R11, 17 */
		/* 82069F8Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000011);
		/* 82069F8Ch case    0:*/		return 0x82069F90;
		  /* 82069F90h */ case    1:  		/* bclr 12, CR6_GT */
		/* 82069F90h case    1:*/		if ( regs.CR[6].gt ) { return (uint32)regs.LR; }
		/* 82069F90h case    1:*/		return 0x82069F94;
	}
	return 0x82069F94;
} // Block from 82069F8Ch-82069F94h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82069F94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069F94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069F94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069F94);
		  /* 82069F94h */ case    0:  		/* rlwinm R9, R9, 6, 30, 31 */
		/* 82069F94h case    0:*/		cpu::op::rlwinm<0,6,30,31>(regs,&regs.R9,regs.R9);
		/* 82069F94h case    0:*/		return 0x82069F98;
		  /* 82069F98h */ case    1:  		/* rlwinm R10, R4, 2, 0, 29 */
		/* 82069F98h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R4);
		/* 82069F98h case    1:*/		return 0x82069F9C;
		  /* 82069F9Ch */ case    2:  		/* li R11, 1 */
		/* 82069F9Ch case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82069F9Ch case    2:*/		return 0x82069FA0;
		  /* 82069FA0h */ case    3:  		/* add R9, R9, R10 */
		/* 82069FA0h case    3:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 82069FA0h case    3:*/		return 0x82069FA4;
		  /* 82069FA4h */ case    4:  		/* rlwinm R8, R9, 29, 3, 29 */
		/* 82069FA4h case    4:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R8,regs.R9);
		/* 82069FA4h case    4:*/		return 0x82069FA8;
		  /* 82069FA8h */ case    5:  		/* rlwinm R9, R9, 0, 27, 31 */
		/* 82069FA8h case    5:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R9);
		/* 82069FA8h case    5:*/		return 0x82069FAC;
		  /* 82069FACh */ case    6:  		/* slw R9, R11, R9 */
		/* 82069FACh case    6:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 82069FACh case    6:*/		return 0x82069FB0;
		  /* 82069FB0h */ case    7:  		/* lwzx R7, <#[R8 + R3]> */
		/* 82069FB0h case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R8 + regs.R3 + 0x00000000) );
		/* 82069FB0h case    7:*/		return 0x82069FB4;
		  /* 82069FB4h */ case    8:  		/* or R9, R9, R7 */
		/* 82069FB4h case    8:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 82069FB4h case    8:*/		return 0x82069FB8;
		  /* 82069FB8h */ case    9:  		/* stwx R9, <#[R8 + R3]> */
		/* 82069FB8h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R8 + regs.R3 + 0x00000000) );
		/* 82069FB8h case    9:*/		return 0x82069FBC;
		  /* 82069FBCh */ case   10:  		/* lwz R9, <#[R6 + 8]> */
		/* 82069FBCh case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + 0x00000008) );
		/* 82069FBCh case   10:*/		return 0x82069FC0;
		  /* 82069FC0h */ case   11:  		/* rlwinm R9, R9, 0, 16, 17 */
		/* 82069FC0h case   11:*/		cpu::op::rlwinm<0,0,16,17>(regs,&regs.R9,regs.R9);
		/* 82069FC0h case   11:*/		return 0x82069FC4;
		  /* 82069FC4h */ case   12:  		/* cmplwi CR6, R9, 16384 */
		/* 82069FC4h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00004000);
		/* 82069FC4h case   12:*/		return 0x82069FC8;
		  /* 82069FC8h */ case   13:  		/* bc 12, CR6_LT, 40 */
		/* 82069FC8h case   13:*/		if ( regs.CR[6].lt ) { return 0x82069FF0;  }
		/* 82069FC8h case   13:*/		return 0x82069FCC;
		  /* 82069FCCh */ case   14:  		/* lwz R9, <#[R6]> */
		/* 82069FCCh case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + 0x00000000) );
		/* 82069FCCh case   14:*/		return 0x82069FD0;
		  /* 82069FD0h */ case   15:  		/* rlwinm R9, R9, 4, 30, 31 */
		/* 82069FD0h case   15:*/		cpu::op::rlwinm<0,4,30,31>(regs,&regs.R9,regs.R9);
		/* 82069FD0h case   15:*/		return 0x82069FD4;
		  /* 82069FD4h */ case   16:  		/* add R9, R9, R10 */
		/* 82069FD4h case   16:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 82069FD4h case   16:*/		return 0x82069FD8;
		  /* 82069FD8h */ case   17:  		/* rlwinm R8, R9, 29, 3, 29 */
		/* 82069FD8h case   17:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R8,regs.R9);
		/* 82069FD8h case   17:*/		return 0x82069FDC;
		  /* 82069FDCh */ case   18:  		/* rlwinm R9, R9, 0, 27, 31 */
		/* 82069FDCh case   18:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R9);
		/* 82069FDCh case   18:*/		return 0x82069FE0;
		  /* 82069FE0h */ case   19:  		/* slw R9, R11, R9 */
		/* 82069FE0h case   19:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 82069FE0h case   19:*/		return 0x82069FE4;
		  /* 82069FE4h */ case   20:  		/* lwzx R7, <#[R8 + R3]> */
		/* 82069FE4h case   20:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R8 + regs.R3 + 0x00000000) );
		/* 82069FE4h case   20:*/		return 0x82069FE8;
		  /* 82069FE8h */ case   21:  		/* or R9, R9, R7 */
		/* 82069FE8h case   21:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 82069FE8h case   21:*/		return 0x82069FEC;
		  /* 82069FECh */ case   22:  		/* stwx R9, <#[R8 + R3]> */
		/* 82069FECh case   22:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R8 + regs.R3 + 0x00000000) );
		/* 82069FECh case   22:*/		return 0x82069FF0;
	}
	return 0x82069FF0;
} // Block from 82069F94h-82069FF0h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82069FF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82069FF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82069FF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82069FF0);
		  /* 82069FF0h */ case    0:  		/* lwz R9, <#[R6 + 8]> */
		/* 82069FF0h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + 0x00000008) );
		/* 82069FF0h case    0:*/		return 0x82069FF4;
		  /* 82069FF4h */ case    1:  		/* rlwinm R9, R9, 0, 16, 17 */
		/* 82069FF4h case    1:*/		cpu::op::rlwinm<0,0,16,17>(regs,&regs.R9,regs.R9);
		/* 82069FF4h case    1:*/		return 0x82069FF8;
		  /* 82069FF8h */ case    2:  		/* cmplwi CR6, R9, 32768 */
		/* 82069FF8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00008000);
		/* 82069FF8h case    2:*/		return 0x82069FFC;
		  /* 82069FFCh */ case    3:  		/* bclr 12, CR6_LT */
		/* 82069FFCh case    3:*/		if ( regs.CR[6].lt ) { return (uint32)regs.LR; }
		/* 82069FFCh case    3:*/		return 0x8206A000;
	}
	return 0x8206A000;
} // Block from 82069FF0h-8206A000h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8206A000h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A000( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A000) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A000);
		  /* 8206A000h */ case    0:  		/* lwz R9, <#[R6]> */
		/* 8206A000h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + 0x00000000) );
		/* 8206A000h case    0:*/		return 0x8206A004;
		  /* 8206A004h */ case    1:  		/* rlwinm R9, R9, 2, 30, 31 */
		/* 8206A004h case    1:*/		cpu::op::rlwinm<0,2,30,31>(regs,&regs.R9,regs.R9);
		/* 8206A004h case    1:*/		return 0x8206A008;
		  /* 8206A008h */ case    2:  		/* add R10, R9, R10 */
		/* 8206A008h case    2:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8206A008h case    2:*/		return 0x8206A00C;
		  /* 8206A00Ch */ case    3:  		/* rlwinm R9, R10, 29, 3, 29 */
		/* 8206A00Ch case    3:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R9,regs.R10);
		/* 8206A00Ch case    3:*/		return 0x8206A010;
		  /* 8206A010h */ case    4:  		/* rlwinm R10, R10, 0, 27, 31 */
		/* 8206A010h case    4:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R10);
		/* 8206A010h case    4:*/		return 0x8206A014;
		  /* 8206A014h */ case    5:  		/* slw R11, R11, R10 */
		/* 8206A014h case    5:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8206A014h case    5:*/		return 0x8206A018;
		  /* 8206A018h */ case    6:  		/* lwzx R10, <#[R9 + R3]> */
		/* 8206A018h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 8206A018h case    6:*/		return 0x8206A01C;
		  /* 8206A01Ch */ case    7:  		/* or R11, R11, R10 */
		/* 8206A01Ch case    7:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8206A01Ch case    7:*/		return 0x8206A020;
		  /* 8206A020h */ case    8:  		/* stwx R11, <#[R9 + R3]> */
		/* 8206A020h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 8206A020h case    8:*/		return 0x8206A024;
		  /* 8206A024h */ case    9:  		/* bclr 20, CR0_LT */
		/* 8206A024h case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206A024h case    9:*/		return 0x8206A028;
	}
	return 0x8206A028;
} // Block from 8206A000h-8206A028h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8206A028h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A028( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A028) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A028);
		  /* 8206A028h */ case    0:  		/* cmpwi CR6, R5, 0 */
		/* 8206A028h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 8206A028h case    0:*/		return 0x8206A02C;
		  /* 8206A02Ch */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 8206A02Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8206A03C;  }
		/* 8206A02Ch case    1:*/		return 0x8206A030;
		  /* 8206A030h */ case    2:  		/* lwz R11, <#[R6 + 4]> */
		/* 8206A030h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000004) );
		/* 8206A030h case    2:*/		return 0x8206A034;
		  /* 8206A034h */ case    3:  		/* rlwinm. R11, R11, 0, 1, 1 */
		/* 8206A034h case    3:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R11);
		/* 8206A034h case    3:*/		return 0x8206A038;
		  /* 8206A038h */ case    4:  		/* bclr 4, CR0_EQ */
		/* 8206A038h case    4:*/		if ( !regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 8206A038h case    4:*/		return 0x8206A03C;
	}
	return 0x8206A03C;
} // Block from 8206A028h-8206A03Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8206A03Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A03C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A03C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A03C);
		  /* 8206A03Ch */ case    0:  		/* rlwinm R10, R9, 2, 30, 31 */
		/* 8206A03Ch case    0:*/		cpu::op::rlwinm<0,2,30,31>(regs,&regs.R10,regs.R9);
		/* 8206A03Ch case    0:*/		return 0x8206A040;
		  /* 8206A040h */ case    1:  		/* rlwinm R11, R4, 2, 0, 29 */
		/* 8206A040h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R4);
		/* 8206A040h case    1:*/		return 0x8206A044;
		  /* 8206A044h */ case    2:  		/* add R11, R10, R11 */
		/* 8206A044h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8206A044h case    2:*/		return 0x8206A048;
		  /* 8206A048h */ case    3:  		/* rlwinm R10, R11, 29, 3, 29 */
		/* 8206A048h case    3:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R10,regs.R11);
		/* 8206A048h case    3:*/		return 0x8206A04C;
		  /* 8206A04Ch */ case    4:  		/* li R9, 1 */
		/* 8206A04Ch case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8206A04Ch case    4:*/		return 0x8206A050;
		  /* 8206A050h */ case    5:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 8206A050h case    5:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8206A050h case    5:*/		return 0x8206A054;
		  /* 8206A054h */ case    6:  		/* slw R11, R9, R11 */
		/* 8206A054h case    6:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 8206A054h case    6:*/		return 0x8206A058;
		  /* 8206A058h */ case    7:  		/* lwzx R9, <#[R10 + R3]> */
		/* 8206A058h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 8206A058h case    7:*/		return 0x8206A05C;
		  /* 8206A05Ch */ case    8:  		/* or R11, R11, R9 */
		/* 8206A05Ch case    8:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 8206A05Ch case    8:*/		return 0x8206A060;
		  /* 8206A060h */ case    9:  		/* stwx R11, <#[R10 + R3]> */
		/* 8206A060h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R3 + 0x00000000) );
		/* 8206A060h case    9:*/		return 0x8206A064;
		  /* 8206A064h */ case   10:  		/* bclr 20, CR0_LT */
		/* 8206A064h case   10:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206A064h case   10:*/		return 0x8206A068;
	}
	return 0x8206A068;
} // Block from 8206A03Ch-8206A068h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8206A068h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A068( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A068) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A068);
		  /* 8206A068h */ case    0:  		/* rlwinm R10, R9, 6, 30, 31 */
		/* 8206A068h case    0:*/		cpu::op::rlwinm<0,6,30,31>(regs,&regs.R10,regs.R9);
		/* 8206A068h case    0:*/		return 0x8206A06C;
		  /* 8206A06Ch */ case    1:  		/* rlwinm R8, R4, 2, 0, 29 */
		/* 8206A06Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R4);
		/* 8206A06Ch case    1:*/		return 0x8206A070;
		  /* 8206A070h */ case    2:  		/* li R11, 1 */
		/* 8206A070h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8206A070h case    2:*/		return 0x8206A074;
		  /* 8206A074h */ case    3:  		/* add R10, R10, R8 */
		/* 8206A074h case    3:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 8206A074h case    3:*/		return 0x8206A078;
		  /* 8206A078h */ case    4:  		/* rlwinm R9, R10, 29, 3, 29 */
		/* 8206A078h case    4:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R9,regs.R10);
		/* 8206A078h case    4:*/		return 0x8206A07C;
		  /* 8206A07Ch */ case    5:  		/* rlwinm R10, R10, 0, 27, 31 */
		/* 8206A07Ch case    5:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R10);
		/* 8206A07Ch case    5:*/		return 0x8206A080;
		  /* 8206A080h */ case    6:  		/* slw R10, R11, R10 */
		/* 8206A080h case    6:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 8206A080h case    6:*/		return 0x8206A084;
		  /* 8206A084h */ case    7:  		/* lwzx R7, <#[R9 + R3]> */
		/* 8206A084h case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 8206A084h case    7:*/		return 0x8206A088;
		  /* 8206A088h */ case    8:  		/* or R10, R10, R7 */
		/* 8206A088h case    8:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R7);
		/* 8206A088h case    8:*/		return 0x8206A08C;
		  /* 8206A08Ch */ case    9:  		/* stwx R10, <#[R9 + R3]> */
		/* 8206A08Ch case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 8206A08Ch case    9:*/		return 0x8206A090;
		  /* 8206A090h */ case   10:  		/* lwz R10, <#[R6]> */
		/* 8206A090h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x00000000) );
		/* 8206A090h case   10:*/		return 0x8206A094;
		  /* 8206A094h */ case   11:  		/* rlwinm R10, R10, 4, 30, 31 */
		/* 8206A094h case   11:*/		cpu::op::rlwinm<0,4,30,31>(regs,&regs.R10,regs.R10);
		/* 8206A094h case   11:*/		return 0x8206A098;
		  /* 8206A098h */ case   12:  		/* add R10, R10, R8 */
		/* 8206A098h case   12:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 8206A098h case   12:*/		return 0x8206A09C;
		  /* 8206A09Ch */ case   13:  		/* b -144 */
		/* 8206A09Ch case   13:*/		return 0x8206A00C;
		/* 8206A09Ch case   13:*/		return 0x8206A0A0;
	}
	return 0x8206A0A0;
} // Block from 8206A068h-8206A0A0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8206A0A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A0A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A0A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A0A0);
		  /* 8206A0A0h */ case    0:  		/* cmplwi CR6, R11, 19 */
		/* 8206A0A0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000013);
		/* 8206A0A0h case    0:*/		return 0x8206A0A4;
		  /* 8206A0A4h */ case    1:  		/* bc 12, CR6_EQ, -272 */
		/* 8206A0A4h case    1:*/		if ( regs.CR[6].eq ) { return 0x82069F94;  }
		/* 8206A0A4h case    1:*/		return 0x8206A0A8;
		  /* 8206A0A8h */ case    2:  		/* cmplwi CR6, R11, 24 */
		/* 8206A0A8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000018);
		/* 8206A0A8h case    2:*/		return 0x8206A0AC;
		  /* 8206A0ACh */ case    3:  		/* bc 12, CR6_EQ, 96 */
		/* 8206A0ACh case    3:*/		if ( regs.CR[6].eq ) { return 0x8206A10C;  }
		/* 8206A0ACh case    3:*/		return 0x8206A0B0;
		  /* 8206A0B0h */ case    4:  		/* bclr 4, CR6_GT */
		/* 8206A0B0h case    4:*/		if ( !regs.CR[6].gt ) { return (uint32)regs.LR; }
		/* 8206A0B0h case    4:*/		return 0x8206A0B4;
	}
	return 0x8206A0B4;
} // Block from 8206A0A0h-8206A0B4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8206A0B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A0B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A0B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A0B4);
		  /* 8206A0B4h */ case    0:  		/* cmplwi CR6, R11, 26 */
		/* 8206A0B4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001A);
		/* 8206A0B4h case    0:*/		return 0x8206A0B8;
		  /* 8206A0B8h */ case    1:  		/* bclr 12, CR6_GT */
		/* 8206A0B8h case    1:*/		if ( regs.CR[6].gt ) { return (uint32)regs.LR; }
		/* 8206A0B8h case    1:*/		return 0x8206A0BC;
	}
	return 0x8206A0BC;
} // Block from 8206A0B4h-8206A0BCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206A0BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A0BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A0BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A0BC);
		  /* 8206A0BCh */ case    0:  		/* rlwinm R9, R9, 6, 30, 31 */
		/* 8206A0BCh case    0:*/		cpu::op::rlwinm<0,6,30,31>(regs,&regs.R9,regs.R9);
		/* 8206A0BCh case    0:*/		return 0x8206A0C0;
		  /* 8206A0C0h */ case    1:  		/* rlwinm R10, R4, 2, 0, 29 */
		/* 8206A0C0h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R4);
		/* 8206A0C0h case    1:*/		return 0x8206A0C4;
		  /* 8206A0C4h */ case    2:  		/* li R11, 1 */
		/* 8206A0C4h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8206A0C4h case    2:*/		return 0x8206A0C8;
		  /* 8206A0C8h */ case    3:  		/* add R9, R9, R10 */
		/* 8206A0C8h case    3:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 8206A0C8h case    3:*/		return 0x8206A0CC;
		  /* 8206A0CCh */ case    4:  		/* rlwinm R8, R9, 29, 3, 29 */
		/* 8206A0CCh case    4:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R8,regs.R9);
		/* 8206A0CCh case    4:*/		return 0x8206A0D0;
		  /* 8206A0D0h */ case    5:  		/* rlwinm R9, R9, 0, 27, 31 */
		/* 8206A0D0h case    5:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R9);
		/* 8206A0D0h case    5:*/		return 0x8206A0D4;
		  /* 8206A0D4h */ case    6:  		/* slw R9, R11, R9 */
		/* 8206A0D4h case    6:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 8206A0D4h case    6:*/		return 0x8206A0D8;
		  /* 8206A0D8h */ case    7:  		/* lwzx R7, <#[R8 + R3]> */
		/* 8206A0D8h case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R8 + regs.R3 + 0x00000000) );
		/* 8206A0D8h case    7:*/		return 0x8206A0DC;
		  /* 8206A0DCh */ case    8:  		/* or R9, R9, R7 */
		/* 8206A0DCh case    8:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 8206A0DCh case    8:*/		return 0x8206A0E0;
		  /* 8206A0E0h */ case    9:  		/* stwx R9, <#[R8 + R3]> */
		/* 8206A0E0h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R8 + regs.R3 + 0x00000000) );
		/* 8206A0E0h case    9:*/		return 0x8206A0E4;
		  /* 8206A0E4h */ case   10:  		/* lwz R9, <#[R6]> */
		/* 8206A0E4h case   10:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + 0x00000000) );
		/* 8206A0E4h case   10:*/		return 0x8206A0E8;
		  /* 8206A0E8h */ case   11:  		/* rlwinm R9, R9, 4, 30, 31 */
		/* 8206A0E8h case   11:*/		cpu::op::rlwinm<0,4,30,31>(regs,&regs.R9,regs.R9);
		/* 8206A0E8h case   11:*/		return 0x8206A0EC;
		  /* 8206A0ECh */ case   12:  		/* add R9, R9, R10 */
		/* 8206A0ECh case   12:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 8206A0ECh case   12:*/		return 0x8206A0F0;
		  /* 8206A0F0h */ case   13:  		/* rlwinm R8, R9, 29, 3, 29 */
		/* 8206A0F0h case   13:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R8,regs.R9);
		/* 8206A0F0h case   13:*/		return 0x8206A0F4;
		  /* 8206A0F4h */ case   14:  		/* rlwinm R9, R9, 0, 27, 31 */
		/* 8206A0F4h case   14:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R9);
		/* 8206A0F4h case   14:*/		return 0x8206A0F8;
		  /* 8206A0F8h */ case   15:  		/* slw R9, R11, R9 */
		/* 8206A0F8h case   15:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 8206A0F8h case   15:*/		return 0x8206A0FC;
		  /* 8206A0FCh */ case   16:  		/* lwzx R7, <#[R8 + R3]> */
		/* 8206A0FCh case   16:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R8 + regs.R3 + 0x00000000) );
		/* 8206A0FCh case   16:*/		return 0x8206A100;
		  /* 8206A100h */ case   17:  		/* or R9, R9, R7 */
		/* 8206A100h case   17:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 8206A100h case   17:*/		return 0x8206A104;
		  /* 8206A104h */ case   18:  		/* stwx R9, <#[R8 + R3]> */
		/* 8206A104h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R8 + regs.R3 + 0x00000000) );
		/* 8206A104h case   18:*/		return 0x8206A108;
		  /* 8206A108h */ case   19:  		/* b -264 */
		/* 8206A108h case   19:*/		return 0x8206A000;
		/* 8206A108h case   19:*/		return 0x8206A10C;
	}
	return 0x8206A10C;
} // Block from 8206A0BCh-8206A10Ch (20 instructions)

//////////////////////////////////////////////////////
// Block at 8206A10Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A10C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A10C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A10C);
		  /* 8206A10Ch */ case    0:  		/* rlwinm R10, R4, 2, 0, 29 */
		/* 8206A10Ch case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R4);
		/* 8206A10Ch case    0:*/		return 0x8206A110;
		  /* 8206A110h */ case    1:  		/* rlwinm R11, R9, 6, 30, 31 */
		/* 8206A110h case    1:*/		cpu::op::rlwinm<0,6,30,31>(regs,&regs.R11,regs.R9);
		/* 8206A110h case    1:*/		return 0x8206A114;
		  /* 8206A114h */ case    2:  		/* add R11, R11, R10 */
		/* 8206A114h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8206A114h case    2:*/		return 0x8206A118;
		  /* 8206A118h */ case    3:  		/* b -208 */
		/* 8206A118h case    3:*/		return 0x8206A048;
		/* 8206A118h case    3:*/		return 0x8206A11C;
		  /* 8206A11Ch */ case    4:  		/* nop */
		/* 8206A11Ch case    4:*/		cpu::op::nop();
		/* 8206A11Ch case    4:*/		return 0x8206A120;
		  /* 8206A120h */ case    5:  		/* lwz R10, <#[R4]> */
		/* 8206A120h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 8206A120h case    5:*/		return 0x8206A124;
		  /* 8206A124h */ case    6:  		/* li R8, 2 */
		/* 8206A124h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x2);
		/* 8206A124h case    6:*/		return 0x8206A128;
		  /* 8206A128h */ case    7:  		/* lwz R11, <#[R3 + 96]> */
		/* 8206A128h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000060) );
		/* 8206A128h case    7:*/		return 0x8206A12C;
		  /* 8206A12Ch */ case    8:  		/* rlwinm R9, R10, 0, 20, 31 */
		/* 8206A12Ch case    8:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R9,regs.R10);
		/* 8206A12Ch case    8:*/		return 0x8206A130;
		  /* 8206A130h */ case    9:  		/* mulli R9, R9, 12 */
		/* 8206A130h case    9:*/		cpu::op::mulli<0>(regs,&regs.R9,regs.R9,0xC);
		/* 8206A130h case    9:*/		return 0x8206A134;
		  /* 8206A134h */ case   10:  		/* add R9, R9, R11 */
		/* 8206A134h case   10:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 8206A134h case   10:*/		return 0x8206A138;
		  /* 8206A138h */ case   11:  		/* lwz R11, <#[R9]> */
		/* 8206A138h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 8206A138h case   11:*/		return 0x8206A13C;
		  /* 8206A13Ch */ case   12:  		/* rlwinm R7, R11, 25, 7, 31 */
		/* 8206A13Ch case   12:*/		cpu::op::rlwinm<0,25,7,31>(regs,&regs.R7,regs.R11);
		/* 8206A13Ch case   12:*/		return 0x8206A140;
		  /* 8206A140h */ case   13:  		/* xor R7, R7, R11 */
		/* 8206A140h case   13:*/		cpu::op::xor<0>(regs,&regs.R7,regs.R7,regs.R11);
		/* 8206A140h case   13:*/		return 0x8206A144;
		  /* 8206A144h */ case   14:  		/* rlwinm. R7, R7, 0, 21, 26 */
		/* 8206A144h case   14:*/		cpu::op::rlwinm<1,0,21,26>(regs,&regs.R7,regs.R7);
		/* 8206A144h case   14:*/		return 0x8206A148;
		  /* 8206A148h */ case   15:  		/* bc 4, CR0_EQ, 64 */
		/* 8206A148h case   15:*/		if ( !regs.CR[0].eq ) { return 0x8206A188;  }
		/* 8206A148h case   15:*/		return 0x8206A14C;
		  /* 8206A14Ch */ case   16:  		/* lwz R9, <#[R9 + 4]> */
		/* 8206A14Ch case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 8206A14Ch case   16:*/		return 0x8206A150;
		  /* 8206A150h */ case   17:  		/* rlwinm R11, R11, 4, 28, 29 */
		/* 8206A150h case   17:*/		cpu::op::rlwinm<0,4,28,29>(regs,&regs.R11,regs.R11);
		/* 8206A150h case   17:*/		return 0x8206A154;
		  /* 8206A154h */ case   18:  		/* addi R7, R1, -16 */
		/* 8206A154h case   18:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0xFFFFFFF0);
		/* 8206A154h case   18:*/		return 0x8206A158;
		  /* 8206A158h */ case   19:  		/* rlwinm R6, R9, 0, 29, 31 */
		/* 8206A158h case   19:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R6,regs.R9);
		/* 8206A158h case   19:*/		return 0x8206A15C;
		  /* 8206A15Ch */ case   20:  		/* rlwinm R5, R9, 29, 29, 31 */
		/* 8206A15Ch case   20:*/		cpu::op::rlwinm<0,29,29,31>(regs,&regs.R5,regs.R9);
		/* 8206A15Ch case   20:*/		return 0x8206A160;
	}
	return 0x8206A160;
} // Block from 8206A10Ch-8206A160h (21 instructions)

//////////////////////////////////////////////////////
// Block at 8206A160h
// Function '?EnsureSerializeIsUpToDate@Microcode@CMicrocodeBuilder@D3D@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A160( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A160) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A160);
		  /* 8206A160h */ case    0:  		/* rlwinm R3, R9, 26, 29, 31 */
		/* 8206A160h case    0:*/		cpu::op::rlwinm<0,26,29,31>(regs,&regs.R3,regs.R9);
		/* 8206A160h case    0:*/		return 0x8206A164;
		  /* 8206A164h */ case    1:  		/* stw R6, <#[R1 - 16]> */
		/* 8206A164h case    1:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8206A164h case    1:*/		return 0x8206A168;
		  /* 8206A168h */ case    2:  		/* rlwinm R9, R9, 23, 29, 31 */
		/* 8206A168h case    2:*/		cpu::op::rlwinm<0,23,29,31>(regs,&regs.R9,regs.R9);
		/* 8206A168h case    2:*/		return 0x8206A16C;
		  /* 8206A16Ch */ case    3:  		/* stw R5, <#[R1 - 12]> */
		/* 8206A16Ch case    3:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0xFFFFFFF4) );
		/* 8206A16Ch case    3:*/		return 0x8206A170;
		  /* 8206A170h */ case    4:  		/* stw R3, <#[R1 - 8]> */
		/* 8206A170h case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8206A170h case    4:*/		return 0x8206A174;
		  /* 8206A174h */ case    5:  		/* stw R9, <#[R1 - 4]> */
		/* 8206A174h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0xFFFFFFFC) );
		/* 8206A174h case    5:*/		return 0x8206A178;
		  /* 8206A178h */ case    6:  		/* lwzx R11, <#[R11 + R7]> */
		/* 8206A178h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 8206A178h case    6:*/		return 0x8206A17C;
		  /* 8206A17Ch */ case    7:  		/* cmpwi CR6, R11, 7 */
		/* 8206A17Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000007);
		/* 8206A17Ch case    7:*/		return 0x8206A180;
		  /* 8206A180h */ case    8:  		/* bc 12, CR6_EQ, 8 */
		/* 8206A180h case    8:*/		if ( regs.CR[6].eq ) { return 0x8206A188;  }
		/* 8206A180h case    8:*/		return 0x8206A184;
		  /* 8206A184h */ case    9:  		/* li R8, 3 */
		/* 8206A184h case    9:*/		cpu::op::li<0>(regs,&regs.R8,0x3);
		/* 8206A184h case    9:*/		return 0x8206A188;
	}
	return 0x8206A188;
} // Block from 8206A160h-8206A188h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8206A188h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A188( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A188) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A188);
		  /* 8206A188h */ case    0:  		/* rlwimi R10, R8, 20, 10, 11 */
		/* 8206A188h case    0:*/		cpu::op::rlwimi<0,20,10,11>(regs,&regs.R10,regs.R8);
		/* 8206A188h case    0:*/		return 0x8206A18C;
		  /* 8206A18Ch */ case    1:  		/* stw R10, <#[R4]> */
		/* 8206A18Ch case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 8206A18Ch case    1:*/		return 0x8206A190;
		  /* 8206A190h */ case    2:  		/* bclr 20, CR0_LT */
		/* 8206A190h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206A190h case    2:*/		return 0x8206A194;
	}
	return 0x8206A194;
} // Block from 8206A188h-8206A194h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206A194h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A194( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A194) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A194);
		  /* 8206A194h */ case    0:  		/* nop */
		/* 8206A194h case    0:*/		cpu::op::nop();
		/* 8206A194h case    0:*/		return 0x8206A198;
	}
	return 0x8206A198;
} // Block from 8206A194h-8206A198h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206A198h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A198( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A198) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A198);
		  /* 8206A198h */ case    0:  		/* mfspr R12, LR */
		/* 8206A198h case    0:*/		regs.R12 = regs.LR;
		/* 8206A198h case    0:*/		return 0x8206A19C;
		  /* 8206A19Ch */ case    1:  		/* bl 159928 */
		/* 8206A19Ch case    1:*/		regs.LR = 0x8206A1A0; return 0x82091254;
		/* 8206A19Ch case    1:*/		return 0x8206A1A0;
		  /* 8206A1A0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8206A1A0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8206A1A0h case    2:*/		return 0x8206A1A4;
		  /* 8206A1A4h */ case    3:  		/* li R31, 0 */
		/* 8206A1A4h case    3:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 8206A1A4h case    3:*/		return 0x8206A1A8;
		  /* 8206A1A8h */ case    4:  		/* mr R28, R4 */
		/* 8206A1A8h case    4:*/		regs.R28 = regs.R4;
		/* 8206A1A8h case    4:*/		return 0x8206A1AC;
		  /* 8206A1ACh */ case    5:  		/* mr R27, R5 */
		/* 8206A1ACh case    5:*/		regs.R27 = regs.R5;
		/* 8206A1ACh case    5:*/		return 0x8206A1B0;
		  /* 8206A1B0h */ case    6:  		/* stw R31, <#[R7]> */
		/* 8206A1B0h case    6:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R7 + 0x00000000) );
		/* 8206A1B0h case    6:*/		return 0x8206A1B4;
		  /* 8206A1B4h */ case    7:  		/* mr R30, R6 */
		/* 8206A1B4h case    7:*/		regs.R30 = regs.R6;
		/* 8206A1B4h case    7:*/		return 0x8206A1B8;
		  /* 8206A1B8h */ case    8:  		/* mr R29, R7 */
		/* 8206A1B8h case    8:*/		regs.R29 = regs.R7;
		/* 8206A1B8h case    8:*/		return 0x8206A1BC;
		  /* 8206A1BCh */ case    9:  		/* mr R5, R30 */
		/* 8206A1BCh case    9:*/		regs.R5 = regs.R30;
		/* 8206A1BCh case    9:*/		return 0x8206A1C0;
		  /* 8206A1C0h */ case   10:  		/* add R4, R31, R27 */
		/* 8206A1C0h case   10:*/		cpu::op::add<0>(regs,&regs.R4,regs.R31,regs.R27);
		/* 8206A1C0h case   10:*/		return 0x8206A1C4;
		  /* 8206A1C4h */ case   11:  		/* mr R3, R28 */
		/* 8206A1C4h case   11:*/		regs.R3 = regs.R28;
		/* 8206A1C4h case   11:*/		return 0x8206A1C8;
		  /* 8206A1C8h */ case   12:  		/* bl -2664 */
		/* 8206A1C8h case   12:*/		regs.LR = 0x8206A1CC; return 0x82069760;
		/* 8206A1C8h case   12:*/		return 0x8206A1CC;
		  /* 8206A1CCh */ case   13:  		/* cmpwi CR0, R3, 0 */
		/* 8206A1CCh case   13:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8206A1CCh case   13:*/		return 0x8206A1D0;
		  /* 8206A1D0h */ case   14:  		/* bc 12, CR0_EQ, 24 */
		/* 8206A1D0h case   14:*/		if ( regs.CR[0].eq ) { return 0x8206A1E8;  }
		/* 8206A1D0h case   14:*/		return 0x8206A1D4;
		  /* 8206A1D4h */ case   15:  		/* li R11, 1 */
		/* 8206A1D4h case   15:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8206A1D4h case   15:*/		return 0x8206A1D8;
		  /* 8206A1D8h */ case   16:  		/* lwz R10, <#[R29]> */
		/* 8206A1D8h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 8206A1D8h case   16:*/		return 0x8206A1DC;
		  /* 8206A1DCh */ case   17:  		/* slw R11, R11, R31 */
		/* 8206A1DCh case   17:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 8206A1DCh case   17:*/		return 0x8206A1E0;
		  /* 8206A1E0h */ case   18:  		/* or R11, R11, R10 */
		/* 8206A1E0h case   18:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8206A1E0h case   18:*/		return 0x8206A1E4;
		  /* 8206A1E4h */ case   19:  		/* stw R11, <#[R29]> */
		/* 8206A1E4h case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8206A1E4h case   19:*/		return 0x8206A1E8;
	}
	return 0x8206A1E8;
} // Block from 8206A198h-8206A1E8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 8206A1E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A1E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A1E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A1E8);
		  /* 8206A1E8h */ case    0:  		/* addi R31, R31, 1 */
		/* 8206A1E8h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8206A1E8h case    0:*/		return 0x8206A1EC;
		  /* 8206A1ECh */ case    1:  		/* addi R30, R30, 16 */
		/* 8206A1ECh case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x10);
		/* 8206A1ECh case    1:*/		return 0x8206A1F0;
	}
	return 0x8206A1F0;
} // Block from 8206A1E8h-8206A1F0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206A1F0h
// Function '?HandleFetchWrite@Microcode@CMicrocodeBuilder@D3D@@SAXAAV?$BitVector@$0BAA@@3@KPBTGPUVERTEX_FETCH_INSTRUCTION@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A1F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A1F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A1F0);
		  /* 8206A1F0h */ case    0:  		/* cmplwi CR6, R31, 4 */
		/* 8206A1F0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000004);
		/* 8206A1F0h case    0:*/		return 0x8206A1F4;
		  /* 8206A1F4h */ case    1:  		/* bc 12, CR6_LT, -56 */
		/* 8206A1F4h case    1:*/		if ( regs.CR[6].lt ) { return 0x8206A1BC;  }
		/* 8206A1F4h case    1:*/		return 0x8206A1F8;
		  /* 8206A1F8h */ case    2:  		/* addi R1, R1, 128 */
		/* 8206A1F8h case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8206A1F8h case    2:*/		return 0x8206A1FC;
		  /* 8206A1FCh */ case    3:  		/* b 159912 */
		/* 8206A1FCh case    3:*/		return 0x820912A4;
		/* 8206A1FCh case    3:*/		return 0x8206A200;
		  /* 8206A200h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 8206A200h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8206A200h case    4:*/		return 0x8206A204;
		  /* 8206A204h */ case    5:  		/* lwz R10, <#[R4]> */
		/* 8206A204h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 8206A204h case    5:*/		return 0x8206A208;
		  /* 8206A208h */ case    6:  		/* mulli R11, R11, 9936 */
		/* 8206A208h case    6:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x26D0);
		/* 8206A208h case    6:*/		return 0x8206A20C;
		  /* 8206A20Ch */ case    7:  		/* add R11, R11, R3 */
		/* 8206A20Ch case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 8206A20Ch case    7:*/		return 0x8206A210;
		  /* 8206A210h */ case    8:  		/* stw R10, <#[R11 + 356]> */
		/* 8206A210h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000164) );
		/* 8206A210h case    8:*/		return 0x8206A214;
		  /* 8206A214h */ case    9:  		/* lwz R10, <#[R4 + 4]> */
		/* 8206A214h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000004) );
		/* 8206A214h case    9:*/		return 0x8206A218;
		  /* 8206A218h */ case   10:  		/* stw R10, <#[R11 + 360]> */
		/* 8206A218h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000168) );
		/* 8206A218h case   10:*/		return 0x8206A21C;
		  /* 8206A21Ch */ case   11:  		/* lwz R10, <#[R4 + 8]> */
		/* 8206A21Ch case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000008) );
		/* 8206A21Ch case   11:*/		return 0x8206A220;
		  /* 8206A220h */ case   12:  		/* stw R10, <#[R11 + 364]> */
		/* 8206A220h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000016C) );
		/* 8206A220h case   12:*/		return 0x8206A224;
		  /* 8206A224h */ case   13:  		/* bclr 20, CR0_LT */
		/* 8206A224h case   13:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206A224h case   13:*/		return 0x8206A228;
	}
	return 0x8206A228;
} // Block from 8206A1F0h-8206A228h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8206A228h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A228( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A228) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A228);
		  /* 8206A228h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 8206A228h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8206A228h case    0:*/		return 0x8206A22C;
		  /* 8206A22Ch */ case    1:  		/* mulli R11, R11, 9936 */
		/* 8206A22Ch case    1:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x26D0);
		/* 8206A22Ch case    1:*/		return 0x8206A230;
		  /* 8206A230h */ case    2:  		/* add R11, R11, R3 */
		/* 8206A230h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 8206A230h case    2:*/		return 0x8206A234;
		  /* 8206A234h */ case    3:  		/* addi R3, R11, 368 */
		/* 8206A234h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x170);
		/* 8206A234h case    3:*/		return 0x8206A238;
		  /* 8206A238h */ case    4:  		/* b -3024 */
		/* 8206A238h case    4:*/		return 0x82069668;
		/* 8206A238h case    4:*/		return 0x8206A23C;
		  /* 8206A23Ch */ case    5:  		/* nop */
		/* 8206A23Ch case    5:*/		cpu::op::nop();
		/* 8206A23Ch case    5:*/		return 0x8206A240;
		  /* 8206A240h */ case    6:  		/* lwz R11, <#[R3]> */
		/* 8206A240h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8206A240h case    6:*/		return 0x8206A244;
		  /* 8206A244h */ case    7:  		/* mulli R11, R11, 9936 */
		/* 8206A244h case    7:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x26D0);
		/* 8206A244h case    7:*/		return 0x8206A248;
		  /* 8206A248h */ case    8:  		/* add R11, R11, R3 */
		/* 8206A248h case    8:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 8206A248h case    8:*/		return 0x8206A24C;
		  /* 8206A24Ch */ case    9:  		/* addi R3, R11, 368 */
		/* 8206A24Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x170);
		/* 8206A24Ch case    9:*/		return 0x8206A250;
		  /* 8206A250h */ case   10:  		/* b -2936 */
		/* 8206A250h case   10:*/		return 0x820696D8;
		/* 8206A250h case   10:*/		return 0x8206A254;
		  /* 8206A254h */ case   11:  		/* nop */
		/* 8206A254h case   11:*/		cpu::op::nop();
		/* 8206A254h case   11:*/		return 0x8206A258;
		  /* 8206A258h */ case   12:  		/* lwz R11, <#[R3]> */
		/* 8206A258h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8206A258h case   12:*/		return 0x8206A25C;
		  /* 8206A25Ch */ case   13:  		/* mulli R11, R11, 9936 */
		/* 8206A25Ch case   13:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x26D0);
		/* 8206A25Ch case   13:*/		return 0x8206A260;
		  /* 8206A260h */ case   14:  		/* add R11, R11, R3 */
		/* 8206A260h case   14:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 8206A260h case   14:*/		return 0x8206A264;
		  /* 8206A264h */ case   15:  		/* addi R3, R11, 16 */
		/* 8206A264h case   15:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x10);
		/* 8206A264h case   15:*/		return 0x8206A268;
		  /* 8206A268h */ case   16:  		/* b -2616 */
		/* 8206A268h case   16:*/		return 0x82069830;
		/* 8206A268h case   16:*/		return 0x8206A26C;
		  /* 8206A26Ch */ case   17:  		/* nop */
		/* 8206A26Ch case   17:*/		cpu::op::nop();
		/* 8206A26Ch case   17:*/		return 0x8206A270;
		  /* 8206A270h */ case   18:  		/* lwz R11, <#[R3]> */
		/* 8206A270h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8206A270h case   18:*/		return 0x8206A274;
		  /* 8206A274h */ case   19:  		/* mulli R11, R11, 9936 */
		/* 8206A274h case   19:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x26D0);
		/* 8206A274h case   19:*/		return 0x8206A278;
		  /* 8206A278h */ case   20:  		/* add R11, R11, R3 */
		/* 8206A278h case   20:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 8206A278h case   20:*/		return 0x8206A27C;
		  /* 8206A27Ch */ case   21:  		/* lwz R3, <#[R11 + 116]> */
		/* 8206A27Ch case   21:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000074) );
		/* 8206A27Ch case   21:*/		return 0x8206A280;
		  /* 8206A280h */ case   22:  		/* bclr 20, CR0_LT */
		/* 8206A280h case   22:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206A280h case   22:*/		return 0x8206A284;
	}
	return 0x8206A284;
} // Block from 8206A228h-8206A284h (23 instructions)

//////////////////////////////////////////////////////
// Block at 8206A284h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A284( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A284) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A284);
		  /* 8206A284h */ case    0:  		/* nop */
		/* 8206A284h case    0:*/		cpu::op::nop();
		/* 8206A284h case    0:*/		return 0x8206A288;
		  /* 8206A288h */ case    1:  		/* lwz R11, <#[R3]> */
		/* 8206A288h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8206A288h case    1:*/		return 0x8206A28C;
		  /* 8206A28Ch */ case    2:  		/* mulli R11, R11, 9936 */
		/* 8206A28Ch case    2:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x26D0);
		/* 8206A28Ch case    2:*/		return 0x8206A290;
		  /* 8206A290h */ case    3:  		/* add R11, R11, R3 */
		/* 8206A290h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 8206A290h case    3:*/		return 0x8206A294;
		  /* 8206A294h */ case    4:  		/* lwz R11, <#[R11 + 128]> */
		/* 8206A294h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000080) );
		/* 8206A294h case    4:*/		return 0x8206A298;
		  /* 8206A298h */ case    5:  		/* addi R3, R11, -1 */
		/* 8206A298h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFFFFF);
		/* 8206A298h case    5:*/		return 0x8206A29C;
		  /* 8206A29Ch */ case    6:  		/* bclr 20, CR0_LT */
		/* 8206A29Ch case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206A29Ch case    6:*/		return 0x8206A2A0;
	}
	return 0x8206A2A0;
} // Block from 8206A284h-8206A2A0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8206A2A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A2A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A2A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A2A0);
		  /* 8206A2A0h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 8206A2A0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8206A2A0h case    0:*/		return 0x8206A2A4;
		  /* 8206A2A4h */ case    1:  		/* mulli R11, R11, 9936 */
		/* 8206A2A4h case    1:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x26D0);
		/* 8206A2A4h case    1:*/		return 0x8206A2A8;
		  /* 8206A2A8h */ case    2:  		/* add R11, R11, R3 */
		/* 8206A2A8h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 8206A2A8h case    2:*/		return 0x8206A2AC;
		  /* 8206A2ACh */ case    3:  		/* lwz R10, <#[R11 + 96]> */
		/* 8206A2ACh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000060) );
		/* 8206A2ACh case    3:*/		return 0x8206A2B0;
		  /* 8206A2B0h */ case    4:  		/* cmpwi CR6, R10, 0 */
		/* 8206A2B0h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 8206A2B0h case    4:*/		return 0x8206A2B4;
		  /* 8206A2B4h */ case    5:  		/* bc 4, CR6_LT, 12 */
		/* 8206A2B4h case    5:*/		if ( !regs.CR[6].lt ) { return 0x8206A2C0;  }
		/* 8206A2B4h case    5:*/		return 0x8206A2B8;
	}
	return 0x8206A2B8;
} // Block from 8206A2A0h-8206A2B8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8206A2B8h
// Function '?HandleFetchRead@Microcode@CMicrocodeBuilder@D3D@@SAXAAV?$BitVector@$0BAA@@3@KHPBTGPUVERTEX_FETCH_INSTRUCTION@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A2B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A2B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A2B8);
		  /* 8206A2B8h */ case    0:  		/* li R3, 0 */
		/* 8206A2B8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8206A2B8h case    0:*/		return 0x8206A2BC;
		  /* 8206A2BCh */ case    1:  		/* bclr 20, CR0_LT */
		/* 8206A2BCh case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206A2BCh case    1:*/		return 0x8206A2C0;
	}
	return 0x8206A2C0;
} // Block from 8206A2B8h-8206A2C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206A2C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A2C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A2C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A2C0);
		  /* 8206A2C0h */ case    0:  		/* lwz R11, <#[R11 + 124]> */
		/* 8206A2C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000007C) );
		/* 8206A2C0h case    0:*/		return 0x8206A2C4;
		  /* 8206A2C4h */ case    1:  		/* rlwinm R10, R4, 3, 0, 28 */
		/* 8206A2C4h case    1:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R4);
		/* 8206A2C4h case    1:*/		return 0x8206A2C8;
		  /* 8206A2C8h */ case    2:  		/* add R3, R11, R10 */
		/* 8206A2C8h case    2:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 8206A2C8h case    2:*/		return 0x8206A2CC;
		  /* 8206A2CCh */ case    3:  		/* bclr 20, CR0_LT */
		/* 8206A2CCh case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206A2CCh case    3:*/		return 0x8206A2D0;
	}
	return 0x8206A2D0;
} // Block from 8206A2C0h-8206A2D0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8206A2D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A2D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A2D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A2D0);
		  /* 8206A2D0h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 8206A2D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8206A2D0h case    0:*/		return 0x8206A2D4;
		  /* 8206A2D4h */ case    1:  		/* mulli R11, R11, 9936 */
		/* 8206A2D4h case    1:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x26D0);
		/* 8206A2D4h case    1:*/		return 0x8206A2D8;
		  /* 8206A2D8h */ case    2:  		/* add R11, R11, R3 */
		/* 8206A2D8h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 8206A2D8h case    2:*/		return 0x8206A2DC;
		  /* 8206A2DCh */ case    3:  		/* addi R3, R11, 16 */
		/* 8206A2DCh case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x10);
		/* 8206A2DCh case    3:*/		return 0x8206A2E0;
		  /* 8206A2E0h */ case    4:  		/* b -2496 */
		/* 8206A2E0h case    4:*/		return 0x82069920;
		/* 8206A2E0h case    4:*/		return 0x8206A2E4;
		  /* 8206A2E4h */ case    5:  		/* nop */
		/* 8206A2E4h case    5:*/		cpu::op::nop();
		/* 8206A2E4h case    5:*/		return 0x8206A2E8;
		  /* 8206A2E8h */ case    6:  		/* lwz R11, <#[R3]> */
		/* 8206A2E8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8206A2E8h case    6:*/		return 0x8206A2EC;
		  /* 8206A2ECh */ case    7:  		/* mulli R11, R11, 9936 */
		/* 8206A2ECh case    7:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x26D0);
		/* 8206A2ECh case    7:*/		return 0x8206A2F0;
		  /* 8206A2F0h */ case    8:  		/* add R11, R11, R3 */
		/* 8206A2F0h case    8:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 8206A2F0h case    8:*/		return 0x8206A2F4;
		  /* 8206A2F4h */ case    9:  		/* addi R3, R11, 16 */
		/* 8206A2F4h case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x10);
		/* 8206A2F4h case    9:*/		return 0x8206A2F8;
		  /* 8206A2F8h */ case   10:  		/* b -2328 */
		/* 8206A2F8h case   10:*/		return 0x820699E0;
		/* 8206A2F8h case   10:*/		return 0x8206A2FC;
		  /* 8206A2FCh */ case   11:  		/* nop */
		/* 8206A2FCh case   11:*/		cpu::op::nop();
		/* 8206A2FCh case   11:*/		return 0x8206A300;
		  /* 8206A300h */ case   12:  		/* lwz R11, <#[R3 + 16]> */
		/* 8206A300h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 8206A300h case   12:*/		return 0x8206A304;
		  /* 8206A304h */ case   13:  		/* cmplwi CR6, R11, 0 */
		/* 8206A304h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8206A304h case   13:*/		return 0x8206A308;
		  /* 8206A308h */ case   14:  		/* bc 4, CR6_EQ, 28 */
		/* 8206A308h case   14:*/		if ( !regs.CR[6].eq ) { return 0x8206A324;  }
		/* 8206A308h case   14:*/		return 0x8206A30C;
		  /* 8206A30Ch */ case   15:  		/* cmplwi CR6, R5, 0 */
		/* 8206A30Ch case   15:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 8206A30Ch case   15:*/		return 0x8206A310;
		  /* 8206A310h */ case   16:  		/* bc 12, CR6_EQ, 8 */
		/* 8206A310h case   16:*/		if ( regs.CR[6].eq ) { return 0x8206A318;  }
		/* 8206A310h case   16:*/		return 0x8206A314;
		  /* 8206A314h */ case   17:  		/* stw R11, <#[R5]> */
		/* 8206A314h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 8206A314h case   17:*/		return 0x8206A318;
	}
	return 0x8206A318;
} // Block from 8206A2D0h-8206A318h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8206A318h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A318( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A318) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A318);
		  /* 8206A318h */ case    0:  		/* cmplwi CR6, R4, 0 */
		/* 8206A318h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8206A318h case    0:*/		return 0x8206A31C;
		  /* 8206A31Ch */ case    1:  		/* bc 12, CR6_EQ, 44 */
		/* 8206A31Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8206A348;  }
		/* 8206A31Ch case    1:*/		return 0x8206A320;
		  /* 8206A320h */ case    2:  		/* b 36 */
		/* 8206A320h case    2:*/		return 0x8206A344;
		/* 8206A320h case    2:*/		return 0x8206A324;
	}
	return 0x8206A324;
} // Block from 8206A318h-8206A324h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206A324h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A324( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A324) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A324);
		  /* 8206A324h */ case    0:  		/* add R11, R11, R3 */
		/* 8206A324h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R3);
		/* 8206A324h case    0:*/		return 0x8206A328;
		  /* 8206A328h */ case    1:  		/* cmplwi CR6, R5, 0 */
		/* 8206A328h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 8206A328h case    1:*/		return 0x8206A32C;
		  /* 8206A32Ch */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 8206A32Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x8206A338;  }
		/* 8206A32Ch case    2:*/		return 0x8206A330;
		  /* 8206A330h */ case    3:  		/* lwz R10, <#[R11]> */
		/* 8206A330h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8206A330h case    3:*/		return 0x8206A334;
		  /* 8206A334h */ case    4:  		/* stw R10, <#[R5]> */
		/* 8206A334h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R5 + 0x00000000) );
		/* 8206A334h case    4:*/		return 0x8206A338;
	}
	return 0x8206A338;
} // Block from 8206A324h-8206A338h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8206A338h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A338( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A338) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A338);
		  /* 8206A338h */ case    0:  		/* cmplwi CR6, R4, 0 */
		/* 8206A338h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8206A338h case    0:*/		return 0x8206A33C;
		  /* 8206A33Ch */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 8206A33Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8206A348;  }
		/* 8206A33Ch case    1:*/		return 0x8206A340;
		  /* 8206A340h */ case    2:  		/* addi R11, R11, 4 */
		/* 8206A340h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8206A340h case    2:*/		return 0x8206A344;
	}
	return 0x8206A344;
} // Block from 8206A338h-8206A344h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206A344h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A344( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A344) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A344);
		  /* 8206A344h */ case    0:  		/* stw R11, <#[R4]> */
		/* 8206A344h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 8206A344h case    0:*/		return 0x8206A348;
	}
	return 0x8206A348;
} // Block from 8206A344h-8206A348h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206A348h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A348( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A348) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A348);
		  /* 8206A348h */ case    0:  		/* li R3, 0 */
		/* 8206A348h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8206A348h case    0:*/		return 0x8206A34C;
		  /* 8206A34Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 8206A34Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8206A34Ch case    1:*/		return 0x8206A350;
	}
	return 0x8206A350;
} // Block from 8206A348h-8206A350h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206A350h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A350( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A350) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A350);
		  /* 8206A350h */ case    0:  		/* mr R11, R4 */
		/* 8206A350h case    0:*/		regs.R11 = regs.R4;
		/* 8206A350h case    0:*/		return 0x8206A354;
		  /* 8206A354h */ case    1:  		/* mr R4, R3 */
		/* 8206A354h case    1:*/		regs.R4 = regs.R3;
		/* 8206A354h case    1:*/		return 0x8206A358;
		  /* 8206A358h */ case    2:  		/* mr R3, R11 */
		/* 8206A358h case    2:*/		regs.R3 = regs.R11;
		/* 8206A358h case    2:*/		return 0x8206A35C;
		  /* 8206A35Ch */ case    3:  		/* b 121772 */
		/* 8206A35Ch case    3:*/		return 0x82087F08;
		/* 8206A35Ch case    3:*/		return 0x8206A360;
	}
	return 0x8206A360;
} // Block from 8206A350h-8206A360h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8206A360h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A360( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A360) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A360);
		  /* 8206A360h */ case    0:  		/* mfspr R12, LR */
		/* 8206A360h case    0:*/		regs.R12 = regs.LR;
		/* 8206A360h case    0:*/		return 0x8206A364;
		  /* 8206A364h */ case    1:  		/* bl 159420 */
		/* 8206A364h case    1:*/		regs.LR = 0x8206A368; return 0x82091220;
		/* 8206A364h case    1:*/		return 0x8206A368;
		  /* 8206A368h */ case    2:  		/* stwu R1, <#[R1 - 288]> */
		/* 8206A368h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEE0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEE0);
		/* 8206A368h case    2:*/		return 0x8206A36C;
		  /* 8206A36Ch */ case    3:  		/* lwz R11, <#[R3]> */
		/* 8206A36Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8206A36Ch case    3:*/		return 0x8206A370;
		  /* 8206A370h */ case    4:  		/* mr R23, R3 */
		/* 8206A370h case    4:*/		regs.R23 = regs.R3;
		/* 8206A370h case    4:*/		return 0x8206A374;
		  /* 8206A374h */ case    5:  		/* li R20, 0 */
		/* 8206A374h case    5:*/		cpu::op::li<0>(regs,&regs.R20,0x0);
		/* 8206A374h case    5:*/		return 0x8206A378;
		  /* 8206A378h */ case    6:  		/* lwz R17, <#[R3 + 4]> */
		/* 8206A378h case    6:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R3 + 0x00000004) );
		/* 8206A378h case    6:*/		return 0x8206A37C;
		  /* 8206A37Ch */ case    7:  		/* nor R11, R11, R11 */
		/* 8206A37Ch case    7:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8206A37Ch case    7:*/		return 0x8206A380;
		  /* 8206A380h */ case    8:  		/* mr R22, R4 */
		/* 8206A380h case    8:*/		regs.R22 = regs.R4;
		/* 8206A380h case    8:*/		return 0x8206A384;
		  /* 8206A384h */ case    9:  		/* mr R21, R5 */
		/* 8206A384h case    9:*/		regs.R21 = regs.R5;
		/* 8206A384h case    9:*/		return 0x8206A388;
		  /* 8206A388h */ case   10:  		/* rlwinm R14, R6, 0, 31, 31 */
		/* 8206A388h case   10:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R14,regs.R6);
		/* 8206A388h case   10:*/		return 0x8206A38C;
		  /* 8206A38Ch */ case   11:  		/* mr R3, R20 */
		/* 8206A38Ch case   11:*/		regs.R3 = regs.R20;
		/* 8206A38Ch case   11:*/		return 0x8206A390;
		  /* 8206A390h */ case   12:  		/* mr R24, R20 */
		/* 8206A390h case   12:*/		regs.R24 = regs.R20;
		/* 8206A390h case   12:*/		return 0x8206A394;
		  /* 8206A394h */ case   13:  		/* rlwinm R15, R11, 0, 31, 31 */
		/* 8206A394h case   13:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R15,regs.R11);
		/* 8206A394h case   13:*/		return 0x8206A398;
		  /* 8206A398h */ case   14:  		/* addi R16, R23, 20 */
		/* 8206A398h case   14:*/		cpu::op::addi<0>(regs,&regs.R16,regs.R23,0x14);
		/* 8206A398h case   14:*/		return 0x8206A39C;
		  /* 8206A39Ch */ case   15:  		/* lwz R11, <#[R16]> */
		/* 8206A39Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000000) );
		/* 8206A39Ch case   15:*/		return 0x8206A3A0;
		  /* 8206A3A0h */ case   16:  		/* cmplwi CR6, R11, 0 */
		/* 8206A3A0h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8206A3A0h case   16:*/		return 0x8206A3A4;
		  /* 8206A3A4h */ case   17:  		/* bc 12, CR6_EQ, 556 */
		/* 8206A3A4h case   17:*/		if ( regs.CR[6].eq ) { return 0x8206A5D0;  }
		/* 8206A3A4h case   17:*/		return 0x8206A3A8;
		  /* 8206A3A8h */ case   18:  		/* add R11, R11, R23 */
		/* 8206A3A8h case   18:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R23);
		/* 8206A3A8h case   18:*/		return 0x8206A3AC;
		  /* 8206A3ACh */ case   19:  		/* mr R18, R20 */
		/* 8206A3ACh case   19:*/		regs.R18 = regs.R20;
		/* 8206A3ACh case   19:*/		return 0x8206A3B0;
		  /* 8206A3B0h */ case   20:  		/* addi R31, R11, 20 */
		/* 8206A3B0h case   20:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x14);
		/* 8206A3B0h case   20:*/		return 0x8206A3B4;
		  /* 8206A3B4h */ case   21:  		/* lwz R11, <#[R11 + 16]> */
		/* 8206A3B4h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 8206A3B4h case   21:*/		return 0x8206A3B8;
		  /* 8206A3B8h */ case   22:  		/* rlwinm R11, R11, 0, 0, 29 */
		/* 8206A3B8h case   22:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R11,regs.R11);
		/* 8206A3B8h case   22:*/		return 0x8206A3BC;
		  /* 8206A3BCh */ case   23:  		/* add R19, R11, R31 */
		/* 8206A3BCh case   23:*/		cpu::op::add<0>(regs,&regs.R19,regs.R11,regs.R31);
		/* 8206A3BCh case   23:*/		return 0x8206A3C0;
		  /* 8206A3C0h */ case   24:  		/* b 520 */
		/* 8206A3C0h case   24:*/		return 0x8206A5C8;
		/* 8206A3C0h case   24:*/		return 0x8206A3C4;
		  /* 8206A3C4h */ case   25:  		/* lhz R11, <#[R31 + 2]> */
		/* 8206A3C4h case   25:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000002) );
		/* 8206A3C4h case   25:*/		return 0x8206A3C8;
		  /* 8206A3C8h */ case   26:  		/* lhz R10, <#[R31]> */
		/* 8206A3C8h case   26:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8206A3C8h case   26:*/		return 0x8206A3CC;
		  /* 8206A3CCh */ case   27:  		/* addi R31, R31, 4 */
		/* 8206A3CCh case   27:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 8206A3CCh case   27:*/		return 0x8206A3D0;
		  /* 8206A3D0h */ case   28:  		/* cmplwi CR0, R11, 0 */
		/* 8206A3D0h case   28:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8206A3D0h case   28:*/		return 0x8206A3D4;
		  /* 8206A3D4h */ case   29:  		/* bc 4, CR0_EQ, 20 */
		/* 8206A3D4h case   29:*/		if ( !regs.CR[0].eq ) { return 0x8206A3E8;  }
		/* 8206A3D4h case   29:*/		return 0x8206A3D8;
		  /* 8206A3D8h */ case   30:  		/* addi R18, R18, 1 */
		/* 8206A3D8h case   30:*/		cpu::op::addi<0>(regs,&regs.R18,regs.R18,0x1);
		/* 8206A3D8h case   30:*/		return 0x8206A3DC;
		  /* 8206A3DCh */ case   31:  		/* cmplwi CR6, R18, 3 */
		/* 8206A3DCh case   31:*/		cpu::op::cmplwi<6>(regs,regs.R18,0x00000003);
		/* 8206A3DCh case   31:*/		return 0x8206A3E0;
		  /* 8206A3E0h */ case   32:  		/* bc 4, CR6_LT, 496 */
		/* 8206A3E0h case   32:*/		if ( !regs.CR[6].lt ) { return 0x8206A5D0;  }
		/* 8206A3E0h case   32:*/		return 0x8206A3E4;
		  /* 8206A3E4h */ case   33:  		/* b 484 */
		/* 8206A3E4h case   33:*/		return 0x8206A5C8;
		/* 8206A3E4h case   33:*/		return 0x8206A3E8;
	}
	return 0x8206A3E8;
} // Block from 8206A360h-8206A3E8h (34 instructions)

//////////////////////////////////////////////////////
// Block at 8206A3E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A3E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A3E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A3E8);
		  /* 8206A3E8h */ case    0:  		/* cmplwi CR6, R18, 0 */
		/* 8206A3E8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R18,0x00000000);
		/* 8206A3E8h case    0:*/		return 0x8206A3EC;
		  /* 8206A3ECh */ case    1:  		/* bc 4, CR6_EQ, 184 */
		/* 8206A3ECh case    1:*/		if ( !regs.CR[6].eq ) { return 0x8206A4A4;  }
		/* 8206A3ECh case    1:*/		return 0x8206A3F0;
		  /* 8206A3F0h */ case    2:  		/* rlwinm. R9, R11, 0, 28, 31 */
		/* 8206A3F0h case    2:*/		cpu::op::rlwinm<1,0,28,31>(regs,&regs.R9,regs.R11);
		/* 8206A3F0h case    2:*/		return 0x8206A3F4;
		  /* 8206A3F4h */ case    3:  		/* bc 4, CR0_EQ, 496 */
		/* 8206A3F4h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8206A5E4;  }
		/* 8206A3F4h case    3:*/		return 0x8206A3F8;
		  /* 8206A3F8h */ case    4:  		/* lwz R9, <#[R31]> */
		/* 8206A3F8h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8206A3F8h case    4:*/		return 0x8206A3FC;
		  /* 8206A3FCh */ case    5:  		/* addi R31, R31, 4 */
		/* 8206A3FCh case    5:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 8206A3FCh case    5:*/		return 0x8206A400;
		  /* 8206A400h */ case    6:  		/* add R9, R9, R17 */
		/* 8206A400h case    6:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R17);
		/* 8206A400h case    6:*/		return 0x8206A404;
		  /* 8206A404h */ case    7:  		/* add R30, R9, R23 */
		/* 8206A404h case    7:*/		cpu::op::add<0>(regs,&regs.R30,regs.R9,regs.R23);
		/* 8206A404h case    7:*/		return 0x8206A408;
		  /* 8206A408h */ case    8:  		/* rlwinm R28, R10, 0, 16, 31 */
		/* 8206A408h case    8:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R28,regs.R10);
		/* 8206A408h case    8:*/		return 0x8206A40C;
		  /* 8206A40Ch */ case    9:  		/* cmplwi CR6, R28, 512 */
		/* 8206A40Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000200);
		/* 8206A40Ch case    9:*/		return 0x8206A410;
		  /* 8206A410h */ case   10:  		/* bc 4, CR6_LT, 468 */
		/* 8206A410h case   10:*/		if ( !regs.CR[6].lt ) { return 0x8206A5E4;  }
		/* 8206A410h case   10:*/		return 0x8206A414;
		  /* 8206A414h */ case   11:  		/* mr R6, R28 */
		/* 8206A414h case   11:*/		regs.R6 = regs.R28;
		/* 8206A414h case   11:*/		return 0x8206A418;
		  /* 8206A418h */ case   12:  		/* cmpwi CR6, R15, 0 */
		/* 8206A418h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R15,0x00000000);
		/* 8206A418h case   12:*/		return 0x8206A41C;
		  /* 8206A41Ch */ case   13:  		/* bc 12, CR6_EQ, 8 */
		/* 8206A41Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x8206A424;  }
		/* 8206A41Ch case   13:*/		return 0x8206A420;
		  /* 8206A420h */ case   14:  		/* addi R6, R6, -256 */
		/* 8206A420h case   14:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0xFFFFFF00);
		/* 8206A420h case   14:*/		return 0x8206A424;
	}
	return 0x8206A424;
} // Block from 8206A3E8h-8206A424h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8206A424h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A424( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A424) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A424);
		  /* 8206A424h */ case    0:  		/* cmpwi CR6, R14, 0 */
		/* 8206A424h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R14,0x00000000);
		/* 8206A424h case    0:*/		return 0x8206A428;
		  /* 8206A428h */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 8206A428h case    1:*/		if ( regs.CR[6].eq ) { return 0x8206A43C;  }
		/* 8206A428h case    1:*/		return 0x8206A42C;
		  /* 8206A42Ch */ case    2:  		/* addi R10, R1, 112 */
		/* 8206A42Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x70);
		/* 8206A42Ch case    2:*/		return 0x8206A430;
		  /* 8206A430h */ case    3:  		/* std R20, <#[R10]> */
		/* 8206A430h case    3:*/		cpu::mem::store64( regs, regs.R20, (uint32)(regs.R10 + 0x00000000) );
		/* 8206A430h case    3:*/		return 0x8206A434;
		  /* 8206A434h */ case    4:  		/* std R20, <#[R10 + 8]> */
		/* 8206A434h case    4:*/		cpu::mem::store64( regs, regs.R20, (uint32)(regs.R10 + 0x00000008) );
		/* 8206A434h case    4:*/		return 0x8206A438;
		  /* 8206A438h */ case    5:  		/* b 40 */
		/* 8206A438h case    5:*/		return 0x8206A460;
		/* 8206A438h case    5:*/		return 0x8206A43C;
	}
	return 0x8206A43C;
} // Block from 8206A424h-8206A43Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8206A43Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A43C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A43C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A43C);
		  /* 8206A43Ch */ case    0:  		/* lwz R10, <#[R30]> */
		/* 8206A43Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 8206A43Ch case    0:*/		return 0x8206A440;
		  /* 8206A440h */ case    1:  		/* addi R9, R1, 112 */
		/* 8206A440h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x70);
		/* 8206A440h case    1:*/		return 0x8206A444;
		  /* 8206A444h */ case    2:  		/* lwz R8, <#[R30 + 4]> */
		/* 8206A444h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000004) );
		/* 8206A444h case    2:*/		return 0x8206A448;
		  /* 8206A448h */ case    3:  		/* lwz R7, <#[R30 + 8]> */
		/* 8206A448h case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000008) );
		/* 8206A448h case    3:*/		return 0x8206A44C;
		  /* 8206A44Ch */ case    4:  		/* lwz R5, <#[R30 + 12]> */
		/* 8206A44Ch case    4:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x0000000C) );
		/* 8206A44Ch case    4:*/		return 0x8206A450;
		  /* 8206A450h */ case    5:  		/* stw R10, <#[R9]> */
		/* 8206A450h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 8206A450h case    5:*/		return 0x8206A454;
		  /* 8206A454h */ case    6:  		/* stw R8, <#[R9 + 4]> */
		/* 8206A454h case    6:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + 0x00000004) );
		/* 8206A454h case    6:*/		return 0x8206A458;
		  /* 8206A458h */ case    7:  		/* stw R7, <#[R9 + 8]> */
		/* 8206A458h case    7:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + 0x00000008) );
		/* 8206A458h case    7:*/		return 0x8206A45C;
		  /* 8206A45Ch */ case    8:  		/* stw R5, <#[R9 + 12]> */
		/* 8206A45Ch case    8:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R9 + 0x0000000C) );
		/* 8206A45Ch case    8:*/		return 0x8206A460;
	}
	return 0x8206A460;
} // Block from 8206A43Ch-8206A460h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8206A460h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A460( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A460) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A460);
		  /* 8206A460h */ case    0:  		/* addis R11, R11, 1 */
		/* 8206A460h case    0:*/		cpu::op::addis<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8206A460h case    0:*/		return 0x8206A464;
		  /* 8206A464h */ case    1:  		/* mtspr CTR, R21 */
		/* 8206A464h case    1:*/		regs.CTR = regs.R21;
		/* 8206A464h case    1:*/		return 0x8206A468;
		  /* 8206A468h */ case    2:  		/* addi R7, R1, 112 */
		/* 8206A468h case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x70);
		/* 8206A468h case    2:*/		return 0x8206A46C;
		  /* 8206A46Ch */ case    3:  		/* addi R11, R11, -4 */
		/* 8206A46Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 8206A46Ch case    3:*/		return 0x8206A470;
		  /* 8206A470h */ case    4:  		/* li R5, 1 */
		/* 8206A470h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 8206A470h case    4:*/		return 0x8206A474;
		  /* 8206A474h */ case    5:  		/* mr R4, R24 */
		/* 8206A474h case    5:*/		regs.R4 = regs.R24;
		/* 8206A474h case    5:*/		return 0x8206A478;
	}
	return 0x8206A478;
} // Block from 8206A460h-8206A478h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8206A478h
// Function '?UpdateCurrentExec@Microcode@CMicrocodeBuilder@D3D@@QAAX_N00PATGPUSHADER_INSTRUCTION@@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A478( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A478) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A478);
		  /* 8206A478h */ case    0:  		/* mr R3, R22 */
		/* 8206A478h case    0:*/		regs.R3 = regs.R22;
		/* 8206A478h case    0:*/		return 0x8206A47C;
		  /* 8206A47Ch */ case    1:  		/* addi R30, R30, 16 */
		/* 8206A47Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x10);
		/* 8206A47Ch case    1:*/		return 0x8206A480;
		  /* 8206A480h */ case    2:  		/* rlwinm R29, R11, 0, 16, 31 */
		/* 8206A480h case    2:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R29,regs.R11);
		/* 8206A480h case    2:*/		return 0x8206A484;
		  /* 8206A484h */ case    3:  		/* bcctrl 20, CR0_LT */
		/* 8206A484h case    3:*/		if ( 1 ) { regs.LR = 0x8206A488; return (uint32)regs.CTR; }
		/* 8206A484h case    3:*/		return 0x8206A488;
		  /* 8206A488h */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 8206A488h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8206A488h case    4:*/		return 0x8206A48C;
		  /* 8206A48Ch */ case    5:  		/* bc 12, CR0_LT, 352 */
		/* 8206A48Ch case    5:*/		if ( regs.CR[0].lt ) { return 0x8206A5EC;  }
		/* 8206A48Ch case    5:*/		return 0x8206A490;
		  /* 8206A490h */ case    6:  		/* addi R10, R28, 1 */
		/* 8206A490h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R28,0x1);
		/* 8206A490h case    6:*/		return 0x8206A494;
		  /* 8206A494h */ case    7:  		/* rlwinm. R11, R29, 0, 16, 31 */
		/* 8206A494h case    7:*/		cpu::op::rlwinm<1,0,16,31>(regs,&regs.R11,regs.R29);
		/* 8206A494h case    7:*/		return 0x8206A498;
		  /* 8206A498h */ case    8:  		/* rlwinm R10, R10, 0, 16, 31 */
		/* 8206A498h case    8:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R10,regs.R10);
		/* 8206A498h case    8:*/		return 0x8206A49C;
		  /* 8206A49Ch */ case    9:  		/* bc 4, CR0_EQ, -148 */
		/* 8206A49Ch case    9:*/		if ( !regs.CR[0].eq ) { return 0x8206A408;  }
		/* 8206A49Ch case    9:*/		return 0x8206A4A0;
		  /* 8206A4A0h */ case   10:  		/* b 296 */
		/* 8206A4A0h case   10:*/		return 0x8206A5C8;
		/* 8206A4A0h case   10:*/		return 0x8206A4A4;
	}
	return 0x8206A4A4;
} // Block from 8206A478h-8206A4A4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8206A4A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A4A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A4A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A4A4);
		  /* 8206A4A4h */ case    0:  		/* cmplwi CR6, R18, 1 */
		/* 8206A4A4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R18,0x00000001);
		/* 8206A4A4h case    0:*/		return 0x8206A4A8;
		  /* 8206A4A8h */ case    1:  		/* bc 4, CR6_EQ, 136 */
		/* 8206A4A8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8206A530;  }
		/* 8206A4A8h case    1:*/		return 0x8206A4AC;
		  /* 8206A4ACh */ case    2:  		/* rlwinm R30, R10, 0, 16, 31 */
		/* 8206A4ACh case    2:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R30,regs.R10);
		/* 8206A4ACh case    2:*/		return 0x8206A4B0;
		  /* 8206A4B0h */ case    3:  		/* cmplwi CR6, R30, 8992 */
		/* 8206A4B0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00002320);
		/* 8206A4B0h case    3:*/		return 0x8206A4B4;
		  /* 8206A4B4h */ case    4:  		/* bc 12, CR6_LT, 304 */
		/* 8206A4B4h case    4:*/		if ( regs.CR[6].lt ) { return 0x8206A5E4;  }
		/* 8206A4B4h case    4:*/		return 0x8206A4B8;
		  /* 8206A4B8h */ case    5:  		/* cmplwi CR6, R30, 9120 */
		/* 8206A4B8h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x000023A0);
		/* 8206A4B8h case    5:*/		return 0x8206A4BC;
		  /* 8206A4BCh */ case    6:  		/* bc 4, CR6_LT, 296 */
		/* 8206A4BCh case    6:*/		if ( !regs.CR[6].lt ) { return 0x8206A5E4;  }
		/* 8206A4BCh case    6:*/		return 0x8206A4C0;
		  /* 8206A4C0h */ case    7:  		/* lwz R10, <#[R31]> */
		/* 8206A4C0h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8206A4C0h case    7:*/		return 0x8206A4C4;
		  /* 8206A4C4h */ case    8:  		/* addis R11, R11, 1 */
		/* 8206A4C4h case    8:*/		cpu::op::addis<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8206A4C4h case    8:*/		return 0x8206A4C8;
		  /* 8206A4C8h */ case    9:  		/* stw R20, <#[R1 + 108]> */
		/* 8206A4C8h case    9:*/		cpu::mem::store32( regs, regs.R20, (uint32)(regs.R1 + 0x0000006C) );
		/* 8206A4C8h case    9:*/		return 0x8206A4CC;
		  /* 8206A4CCh */ case   10:  		/* addi R9, R30, -8992 */
		/* 8206A4CCh case   10:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R30,0xFFFFDCE0);
		/* 8206A4CCh case   10:*/		return 0x8206A4D0;
		  /* 8206A4D0h */ case   11:  		/* rlwinm R8, R10, 16, 24, 31 */
		/* 8206A4D0h case   11:*/		cpu::op::rlwinm<0,16,24,31>(regs,&regs.R8,regs.R10);
		/* 8206A4D0h case   11:*/		return 0x8206A4D4;
		  /* 8206A4D4h */ case   12:  		/* mtspr CTR, R21 */
		/* 8206A4D4h case   12:*/		regs.CTR = regs.R21;
		/* 8206A4D4h case   12:*/		return 0x8206A4D8;
		  /* 8206A4D8h */ case   13:  		/* rlwinm R7, R10, 0, 24, 31 */
		/* 8206A4D8h case   13:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R7,regs.R10);
		/* 8206A4D8h case   13:*/		return 0x8206A4DC;
		  /* 8206A4DCh */ case   14:  		/* rlwinm R10, R10, 24, 24, 31 */
		/* 8206A4DCh case   14:*/		cpu::op::rlwinm<0,24,24,31>(regs,&regs.R10,regs.R10);
		/* 8206A4DCh case   14:*/		return 0x8206A4E0;
		  /* 8206A4E0h */ case   15:  		/* extsb R8, R8 */
		/* 8206A4E0h case   15:*/		cpu::op::extsb<0>(regs,&regs.R8,regs.R8);
		/* 8206A4E0h case   15:*/		return 0x8206A4E4;
		  /* 8206A4E4h */ case   16:  		/* stw R7, <#[R1 + 96]> */
		/* 8206A4E4h case   16:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x00000060) );
		/* 8206A4E4h case   16:*/		return 0x8206A4E8;
		  /* 8206A4E8h */ case   17:  		/* stw R10, <#[R1 + 100]> */
		/* 8206A4E8h case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000064) );
		/* 8206A4E8h case   17:*/		return 0x8206A4EC;
		  /* 8206A4ECh */ case   18:  		/* addi R11, R11, -1 */
		/* 8206A4ECh case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8206A4ECh case   18:*/		return 0x8206A4F0;
		  /* 8206A4F0h */ case   19:  		/* stw R8, <#[R1 + 104]> */
		/* 8206A4F0h case   19:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000068) );
		/* 8206A4F0h case   19:*/		return 0x8206A4F4;
		  /* 8206A4F4h */ case   20:  		/* addi R7, R1, 96 */
		/* 8206A4F4h case   20:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 8206A4F4h case   20:*/		return 0x8206A4F8;
		  /* 8206A4F8h */ case   21:  		/* rlwinm R6, R9, 30, 2, 31 */
		/* 8206A4F8h case   21:*/		cpu::op::rlwinm<0,30,2,31>(regs,&regs.R6,regs.R9);
		/* 8206A4F8h case   21:*/		return 0x8206A4FC;
		  /* 8206A4FCh */ case   22:  		/* li R5, 2 */
		/* 8206A4FCh case   22:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 8206A4FCh case   22:*/		return 0x8206A500;
		  /* 8206A500h */ case   23:  		/* mr R4, R24 */
		/* 8206A500h case   23:*/		regs.R4 = regs.R24;
		/* 8206A500h case   23:*/		return 0x8206A504;
		  /* 8206A504h */ case   24:  		/* mr R3, R22 */
		/* 8206A504h case   24:*/		regs.R3 = regs.R22;
		/* 8206A504h case   24:*/		return 0x8206A508;
		  /* 8206A508h */ case   25:  		/* addi R31, R31, 4 */
		/* 8206A508h case   25:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 8206A508h case   25:*/		return 0x8206A50C;
		  /* 8206A50Ch */ case   26:  		/* rlwinm R29, R11, 0, 16, 31 */
		/* 8206A50Ch case   26:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R29,regs.R11);
		/* 8206A50Ch case   26:*/		return 0x8206A510;
		  /* 8206A510h */ case   27:  		/* bcctrl 20, CR0_LT */
		/* 8206A510h case   27:*/		if ( 1 ) { regs.LR = 0x8206A514; return (uint32)regs.CTR; }
		/* 8206A510h case   27:*/		return 0x8206A514;
		  /* 8206A514h */ case   28:  		/* cmpwi CR0, R3, 0 */
		/* 8206A514h case   28:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8206A514h case   28:*/		return 0x8206A518;
		  /* 8206A518h */ case   29:  		/* bc 12, CR0_LT, 212 */
		/* 8206A518h case   29:*/		if ( regs.CR[0].lt ) { return 0x8206A5EC;  }
		/* 8206A518h case   29:*/		return 0x8206A51C;
		  /* 8206A51Ch */ case   30:  		/* addi R10, R30, 4 */
		/* 8206A51Ch case   30:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0x4);
		/* 8206A51Ch case   30:*/		return 0x8206A520;
		  /* 8206A520h */ case   31:  		/* rlwinm. R11, R29, 0, 16, 31 */
		/* 8206A520h case   31:*/		cpu::op::rlwinm<1,0,16,31>(regs,&regs.R11,regs.R29);
		/* 8206A520h case   31:*/		return 0x8206A524;
		  /* 8206A524h */ case   32:  		/* rlwinm R10, R10, 0, 16, 31 */
		/* 8206A524h case   32:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R10,regs.R10);
		/* 8206A524h case   32:*/		return 0x8206A528;
		  /* 8206A528h */ case   33:  		/* bc 4, CR0_EQ, -124 */
		/* 8206A528h case   33:*/		if ( !regs.CR[0].eq ) { return 0x8206A4AC;  }
		/* 8206A528h case   33:*/		return 0x8206A52C;
		  /* 8206A52Ch */ case   34:  		/* b 156 */
		/* 8206A52Ch case   34:*/		return 0x8206A5C8;
		/* 8206A52Ch case   34:*/		return 0x8206A530;
	}
	return 0x8206A530;
} // Block from 8206A4A4h-8206A530h (35 instructions)

//////////////////////////////////////////////////////
// Block at 8206A530h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A530);
		  /* 8206A530h */ case    0:  		/* rlwinm R27, R10, 0, 16, 31 */
		/* 8206A530h case    0:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R27,regs.R10);
		/* 8206A530h case    0:*/		return 0x8206A534;
		  /* 8206A534h */ case    1:  		/* cmplwi CR6, R27, 8960 */
		/* 8206A534h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00002300);
		/* 8206A534h case    1:*/		return 0x8206A538;
		  /* 8206A538h */ case    2:  		/* bc 12, CR6_LT, 172 */
		/* 8206A538h case    2:*/		if ( regs.CR[6].lt ) { return 0x8206A5E4;  }
		/* 8206A538h case    2:*/		return 0x8206A53C;
		  /* 8206A53Ch */ case    3:  		/* cmplwi CR6, R27, 8992 */
		/* 8206A53Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00002320);
		/* 8206A53Ch case    3:*/		return 0x8206A540;
		  /* 8206A540h */ case    4:  		/* bc 4, CR6_LT, 164 */
		/* 8206A540h case    4:*/		if ( !regs.CR[6].lt ) { return 0x8206A5E4;  }
		/* 8206A540h case    4:*/		return 0x8206A544;
		  /* 8206A544h */ case    5:  		/* addis R11, R11, 1 */
		/* 8206A544h case    5:*/		cpu::op::addis<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8206A544h case    5:*/		return 0x8206A548;
		  /* 8206A548h */ case    6:  		/* lwz R26, <#[R31]> */
		/* 8206A548h case    6:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R31 + 0x00000000) );
		/* 8206A548h case    6:*/		return 0x8206A54C;
		  /* 8206A54Ch */ case    7:  		/* lwzu R29, <#[R31 + 4]> */
		/* 8206A54Ch case    7:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x00000004) );
		regs.R31 = (uint32)(regs.R31 + 0x00000004);
		/* 8206A54Ch case    7:*/		return 0x8206A550;
		  /* 8206A550h */ case    8:  		/* addi R10, R27, -8960 */
		/* 8206A550h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R27,0xFFFFDD00);
		/* 8206A550h case    8:*/		return 0x8206A554;
		  /* 8206A554h */ case    9:  		/* addi R11, R11, -2 */
		/* 8206A554h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFE);
		/* 8206A554h case    9:*/		return 0x8206A558;
		  /* 8206A558h */ case   10:  		/* rlwinm R28, R10, 3, 0, 26 */
		/* 8206A558h case   10:*/		cpu::op::rlwinm<0,3,0,26>(regs,&regs.R28,regs.R10);
		/* 8206A558h case   10:*/		return 0x8206A55C;
		  /* 8206A55Ch */ case   11:  		/* rlwinm R25, R11, 0, 16, 31 */
		/* 8206A55Ch case   11:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R25,regs.R11);
		/* 8206A55Ch case   11:*/		return 0x8206A560;
		  /* 8206A560h */ case   12:  		/* addi R31, R31, 4 */
		/* 8206A560h case   12:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 8206A560h case   12:*/		return 0x8206A564;
		  /* 8206A564h */ case   13:  		/* mr R30, R20 */
		/* 8206A564h case   13:*/		regs.R30 = regs.R20;
		/* 8206A564h case   13:*/		return 0x8206A568;
		  /* 8206A568h */ case   14:  		/* li R11, 1 */
		/* 8206A568h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8206A568h case   14:*/		return 0x8206A56C;
		  /* 8206A56Ch */ case   15:  		/* slw R11, R11, R30 */
		/* 8206A56Ch case   15:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 8206A56Ch case   15:*/		return 0x8206A570;
		  /* 8206A570h */ case   16:  		/* and. R10, R11, R26 */
		/* 8206A570h case   16:*/		cpu::op::and<1>(regs,&regs.R10,regs.R11,regs.R26);
		/* 8206A570h case   16:*/		return 0x8206A574;
		  /* 8206A574h */ case   17:  		/* bc 4, CR0_EQ, 56 */
		/* 8206A574h case   17:*/		if ( !regs.CR[0].eq ) { return 0x8206A5AC;  }
		/* 8206A574h case   17:*/		return 0x8206A578;
		  /* 8206A578h */ case   18:  		/* and R11, R11, R29 */
		/* 8206A578h case   18:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R29);
		/* 8206A578h case   18:*/		return 0x8206A57C;
		  /* 8206A57Ch */ case   19:  		/* mtspr CTR, R21 */
		/* 8206A57Ch case   19:*/		regs.CTR = regs.R21;
		/* 8206A57Ch case   19:*/		return 0x8206A580;
		  /* 8206A580h */ case   20:  		/* addi R7, R1, 80 */
		/* 8206A580h case   20:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 8206A580h case   20:*/		return 0x8206A584;
		  /* 8206A584h */ case   21:  		/* addic R10, R11, -1 */
		/* 8206A584h case   21:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R11,0xFFFFFFFF);
		/* 8206A584h case   21:*/		return 0x8206A588;
		  /* 8206A588h */ case   22:  		/* add R6, R30, R28 */
		/* 8206A588h case   22:*/		cpu::op::add<0>(regs,&regs.R6,regs.R30,regs.R28);
		/* 8206A588h case   22:*/		return 0x8206A58C;
		  /* 8206A58Ch */ case   23:  		/* subfe R11, R10, R11 */
		/* 8206A58Ch case   23:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8206A58Ch case   23:*/		return 0x8206A590;
		  /* 8206A590h */ case   24:  		/* li R5, 0 */
		/* 8206A590h case   24:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8206A590h case   24:*/		return 0x8206A594;
		  /* 8206A594h */ case   25:  		/* stw R11, <#[R1 + 80]> */
		/* 8206A594h case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 8206A594h case   25:*/		return 0x8206A598;
		  /* 8206A598h */ case   26:  		/* mr R4, R24 */
		/* 8206A598h case   26:*/		regs.R4 = regs.R24;
		/* 8206A598h case   26:*/		return 0x8206A59C;
		  /* 8206A59Ch */ case   27:  		/* mr R3, R22 */
		/* 8206A59Ch case   27:*/		regs.R3 = regs.R22;
		/* 8206A59Ch case   27:*/		return 0x8206A5A0;
		  /* 8206A5A0h */ case   28:  		/* bcctrl 20, CR0_LT */
		/* 8206A5A0h case   28:*/		if ( 1 ) { regs.LR = 0x8206A5A4; return (uint32)regs.CTR; }
		/* 8206A5A0h case   28:*/		return 0x8206A5A4;
		  /* 8206A5A4h */ case   29:  		/* cmpwi CR0, R3, 0 */
		/* 8206A5A4h case   29:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8206A5A4h case   29:*/		return 0x8206A5A8;
		  /* 8206A5A8h */ case   30:  		/* bc 12, CR0_LT, 68 */
		/* 8206A5A8h case   30:*/		if ( regs.CR[0].lt ) { return 0x8206A5EC;  }
		/* 8206A5A8h case   30:*/		return 0x8206A5AC;
	}
	return 0x8206A5AC;
} // Block from 8206A530h-8206A5ACh (31 instructions)

//////////////////////////////////////////////////////
// Block at 8206A5ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A5AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A5AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A5AC);
		  /* 8206A5ACh */ case    0:  		/* addi R30, R30, 1 */
		/* 8206A5ACh case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8206A5ACh case    0:*/		return 0x8206A5B0;
		  /* 8206A5B0h */ case    1:  		/* cmplwi CR6, R30, 32 */
		/* 8206A5B0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000020);
		/* 8206A5B0h case    1:*/		return 0x8206A5B4;
		  /* 8206A5B4h */ case    2:  		/* bc 12, CR6_LT, -76 */
		/* 8206A5B4h case    2:*/		if ( regs.CR[6].lt ) { return 0x8206A568;  }
		/* 8206A5B4h case    2:*/		return 0x8206A5B8;
		  /* 8206A5B8h */ case    3:  		/* addi R10, R27, 4 */
		/* 8206A5B8h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R27,0x4);
		/* 8206A5B8h case    3:*/		return 0x8206A5BC;
		  /* 8206A5BCh */ case    4:  		/* rlwinm. R11, R25, 0, 16, 31 */
		/* 8206A5BCh case    4:*/		cpu::op::rlwinm<1,0,16,31>(regs,&regs.R11,regs.R25);
		/* 8206A5BCh case    4:*/		return 0x8206A5C0;
		  /* 8206A5C0h */ case    5:  		/* rlwinm R10, R10, 0, 16, 31 */
		/* 8206A5C0h case    5:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R10,regs.R10);
		/* 8206A5C0h case    5:*/		return 0x8206A5C4;
		  /* 8206A5C4h */ case    6:  		/* bc 4, CR0_EQ, -148 */
		/* 8206A5C4h case    6:*/		if ( !regs.CR[0].eq ) { return 0x8206A530;  }
		/* 8206A5C4h case    6:*/		return 0x8206A5C8;
	}
	return 0x8206A5C8;
} // Block from 8206A5ACh-8206A5C8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8206A5C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A5C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A5C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A5C8);
		  /* 8206A5C8h */ case    0:  		/* cmplw CR6, R31, R19 */
		/* 8206A5C8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R19);
		/* 8206A5C8h case    0:*/		return 0x8206A5CC;
		  /* 8206A5CCh */ case    1:  		/* bc 12, CR6_LT, -520 */
		/* 8206A5CCh case    1:*/		if ( regs.CR[6].lt ) { return 0x8206A3C4;  }
		/* 8206A5CCh case    1:*/		return 0x8206A5D0;
	}
	return 0x8206A5D0;
} // Block from 8206A5C8h-8206A5D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206A5D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A5D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A5D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A5D0);
		  /* 8206A5D0h */ case    0:  		/* addi R24, R24, 1 */
		/* 8206A5D0h case    0:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x1);
		/* 8206A5D0h case    0:*/		return 0x8206A5D4;
		  /* 8206A5D4h */ case    1:  		/* addi R16, R16, 8 */
		/* 8206A5D4h case    1:*/		cpu::op::addi<0>(regs,&regs.R16,regs.R16,0x8);
		/* 8206A5D4h case    1:*/		return 0x8206A5D8;
		  /* 8206A5D8h */ case    2:  		/* cmplwi CR6, R24, 2 */
		/* 8206A5D8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000002);
		/* 8206A5D8h case    2:*/		return 0x8206A5DC;
		  /* 8206A5DCh */ case    3:  		/* bc 12, CR6_LT, -576 */
		/* 8206A5DCh case    3:*/		if ( regs.CR[6].lt ) { return 0x8206A39C;  }
		/* 8206A5DCh case    3:*/		return 0x8206A5E0;
		  /* 8206A5E0h */ case    4:  		/* b 12 */
		/* 8206A5E0h case    4:*/		return 0x8206A5EC;
		/* 8206A5E0h case    4:*/		return 0x8206A5E4;
	}
	return 0x8206A5E4;
} // Block from 8206A5D0h-8206A5E4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8206A5E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A5E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A5E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A5E4);
		  /* 8206A5E4h */ case    0:  		/* lis R3, -32768 */
		/* 8206A5E4h case    0:*/		cpu::op::lis<0>(regs,&regs.R3,0xFFFF8000);
		/* 8206A5E4h case    0:*/		return 0x8206A5E8;
		  /* 8206A5E8h */ case    1:  		/* ori R3, R3, 16389 */
		/* 8206A5E8h case    1:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4005);
		/* 8206A5E8h case    1:*/		return 0x8206A5EC;
	}
	return 0x8206A5EC;
} // Block from 8206A5E4h-8206A5ECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206A5ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A5EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A5EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A5EC);
		  /* 8206A5ECh */ case    0:  		/* addi R1, R1, 288 */
		/* 8206A5ECh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x120);
		/* 8206A5ECh case    0:*/		return 0x8206A5F0;
		  /* 8206A5F0h */ case    1:  		/* b 158848 */
		/* 8206A5F0h case    1:*/		return 0x82091270;
		/* 8206A5F0h case    1:*/		return 0x8206A5F4;
		  /* 8206A5F4h */ case    2:  		/* nop */
		/* 8206A5F4h case    2:*/		cpu::op::nop();
		/* 8206A5F4h case    2:*/		return 0x8206A5F8;
		  /* 8206A5F8h */ case    3:  		/* li R6, 0 */
		/* 8206A5F8h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8206A5F8h case    3:*/		return 0x8206A5FC;
		  /* 8206A5FCh */ case    4:  		/* b -668 */
		/* 8206A5FCh case    4:*/		return 0x8206A360;
		/* 8206A5FCh case    4:*/		return 0x8206A600;
	}
	return 0x8206A600;
} // Block from 8206A5ECh-8206A600h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8206A600h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A600( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A600) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A600);
		  /* 8206A600h */ case    0:  		/* mfspr R12, LR */
		/* 8206A600h case    0:*/		regs.R12 = regs.LR;
		/* 8206A600h case    0:*/		return 0x8206A604;
		  /* 8206A604h */ case    1:  		/* bl 158804 */
		/* 8206A604h case    1:*/		regs.LR = 0x8206A608; return 0x82091258;
		/* 8206A604h case    1:*/		return 0x8206A608;
		  /* 8206A608h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8206A608h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8206A608h case    2:*/		return 0x8206A60C;
		  /* 8206A60Ch */ case    3:  		/* lwz R11, <#[R3 + 8]> */
		/* 8206A60Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8206A60Ch case    3:*/		return 0x8206A610;
		  /* 8206A610h */ case    4:  		/* mr R31, R3 */
		/* 8206A610h case    4:*/		regs.R31 = regs.R3;
		/* 8206A610h case    4:*/		return 0x8206A614;
		  /* 8206A614h */ case    5:  		/* mr R28, R5 */
		/* 8206A614h case    5:*/		regs.R28 = regs.R5;
		/* 8206A614h case    5:*/		return 0x8206A618;
		  /* 8206A618h */ case    6:  		/* cmplw CR6, R4, R11 */
		/* 8206A618h case    6:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 8206A618h case    6:*/		return 0x8206A61C;
		  /* 8206A61Ch */ case    7:  		/* bc 4, CR6_GT, 104 */
		/* 8206A61Ch case    7:*/		if ( !regs.CR[6].gt ) { return 0x8206A684;  }
		/* 8206A61Ch case    7:*/		return 0x8206A620;
		  /* 8206A620h */ case    8:  		/* rlwinm R30, R11, 1, 0, 30 */
		/* 8206A620h case    8:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R30,regs.R11);
		/* 8206A620h case    8:*/		return 0x8206A624;
		  /* 8206A624h */ case    9:  		/* cmplw CR6, R30, R4 */
		/* 8206A624h case    9:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R4);
		/* 8206A624h case    9:*/		return 0x8206A628;
		  /* 8206A628h */ case   10:  		/* bc 4, CR6_LT, 8 */
		/* 8206A628h case   10:*/		if ( !regs.CR[6].lt ) { return 0x8206A630;  }
		/* 8206A628h case   10:*/		return 0x8206A62C;
		  /* 8206A62Ch */ case   11:  		/* mr R30, R4 */
		/* 8206A62Ch case   11:*/		regs.R30 = regs.R4;
		/* 8206A62Ch case   11:*/		return 0x8206A630;
	}
	return 0x8206A630;
} // Block from 8206A600h-8206A630h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8206A630h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A630( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A630) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A630);
		  /* 8206A630h */ case    0:  		/* lis R4, 25728 */
		/* 8206A630h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x6480);
		/* 8206A630h case    0:*/		return 0x8206A634;
		  /* 8206A634h */ case    1:  		/* mulli R3, R30, 12 */
		/* 8206A634h case    1:*/		cpu::op::mulli<0>(regs,&regs.R3,regs.R30,0xC);
		/* 8206A634h case    1:*/		return 0x8206A638;
		  /* 8206A638h */ case    2:  		/* bl 121800 */
		/* 8206A638h case    2:*/		regs.LR = 0x8206A63C; return 0x82088200;
		/* 8206A638h case    2:*/		return 0x8206A63C;
		  /* 8206A63Ch */ case    3:  		/* or. R29, R3, R3 */
		/* 8206A63Ch case    3:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 8206A63Ch case    3:*/		return 0x8206A640;
		  /* 8206A640h */ case    4:  		/* bc 4, CR0_EQ, 20 */
		/* 8206A640h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8206A654;  }
		/* 8206A640h case    4:*/		return 0x8206A644;
		  /* 8206A644h */ case    5:  		/* lis R11, -32761 */
		/* 8206A644h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8007);
		/* 8206A644h case    5:*/		return 0x8206A648;
		  /* 8206A648h */ case    6:  		/* ori R11, R11, 14 */
		/* 8206A648h case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xE);
		/* 8206A648h case    6:*/		return 0x8206A64C;
		  /* 8206A64Ch */ case    7:  		/* stw R11, <#[R28]> */
		/* 8206A64Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8206A64Ch case    7:*/		return 0x8206A650;
		  /* 8206A650h */ case    8:  		/* b 52 */
		/* 8206A650h case    8:*/		return 0x8206A684;
		/* 8206A650h case    8:*/		return 0x8206A654;
	}
	return 0x8206A654;
} // Block from 8206A630h-8206A654h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8206A654h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A654( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A654) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A654);
		  /* 8206A654h */ case    0:  		/* lwz R4, <#[R31]> */
		/* 8206A654h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000000) );
		/* 8206A654h case    0:*/		return 0x8206A658;
		  /* 8206A658h */ case    1:  		/* stw R30, <#[R31 + 8]> */
		/* 8206A658h case    1:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000008) );
		/* 8206A658h case    1:*/		return 0x8206A65C;
		  /* 8206A65Ch */ case    2:  		/* cmplwi CR6, R4, 0 */
		/* 8206A65Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8206A65Ch case    2:*/		return 0x8206A660;
		  /* 8206A660h */ case    3:  		/* bc 12, CR6_EQ, 32 */
		/* 8206A660h case    3:*/		if ( regs.CR[6].eq ) { return 0x8206A680;  }
		/* 8206A660h case    3:*/		return 0x8206A664;
		  /* 8206A664h */ case    4:  		/* lwz R11, <#[R31 + 4]> */
		/* 8206A664h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8206A664h case    4:*/		return 0x8206A668;
		  /* 8206A668h */ case    5:  		/* mr R3, R29 */
		/* 8206A668h case    5:*/		regs.R3 = regs.R29;
		/* 8206A668h case    5:*/		return 0x8206A66C;
		  /* 8206A66Ch */ case    6:  		/* mulli R5, R11, 12 */
		/* 8206A66Ch case    6:*/		cpu::op::mulli<0>(regs,&regs.R5,regs.R11,0xC);
		/* 8206A66Ch case    6:*/		return 0x8206A670;
		  /* 8206A670h */ case    7:  		/* bl 160576 */
		/* 8206A670h case    7:*/		regs.LR = 0x8206A674; return 0x820919B0;
		/* 8206A670h case    7:*/		return 0x8206A674;
		  /* 8206A674h */ case    8:  		/* lwz R3, <#[R31]> */
		/* 8206A674h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 8206A674h case    8:*/		return 0x8206A678;
		  /* 8206A678h */ case    9:  		/* lis R4, 9344 */
		/* 8206A678h case    9:*/		cpu::op::lis<0>(regs,&regs.R4,0x2480);
		/* 8206A678h case    9:*/		return 0x8206A67C;
		  /* 8206A67Ch */ case   10:  		/* bl 122044 */
		/* 8206A67Ch case   10:*/		regs.LR = 0x8206A680; return 0x82088338;
		/* 8206A67Ch case   10:*/		return 0x8206A680;
	}
	return 0x8206A680;
} // Block from 8206A654h-8206A680h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8206A680h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A680( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A680) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A680);
		  /* 8206A680h */ case    0:  		/* stw R29, <#[R31]> */
		/* 8206A680h case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000000) );
		/* 8206A680h case    0:*/		return 0x8206A684;
	}
	return 0x8206A684;
} // Block from 8206A680h-8206A684h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206A684h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A684( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A684) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A684);
		  /* 8206A684h */ case    0:  		/* addi R1, R1, 128 */
		/* 8206A684h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8206A684h case    0:*/		return 0x8206A688;
		  /* 8206A688h */ case    1:  		/* b 158752 */
		/* 8206A688h case    1:*/		return 0x820912A8;
		/* 8206A688h case    1:*/		return 0x8206A68C;
		  /* 8206A68Ch */ case    2:  		/* nop */
		/* 8206A68Ch case    2:*/		cpu::op::nop();
		/* 8206A68Ch case    2:*/		return 0x8206A690;
	}
	return 0x8206A690;
} // Block from 8206A684h-8206A690h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206A690h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A690( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A690) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A690);
		  /* 8206A690h */ case    0:  		/* mfspr R12, LR */
		/* 8206A690h case    0:*/		regs.R12 = regs.LR;
		/* 8206A690h case    0:*/		return 0x8206A694;
		  /* 8206A694h */ case    1:  		/* bl 158660 */
		/* 8206A694h case    1:*/		regs.LR = 0x8206A698; return 0x82091258;
		/* 8206A694h case    1:*/		return 0x8206A698;
		  /* 8206A698h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8206A698h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8206A698h case    2:*/		return 0x8206A69C;
		  /* 8206A69Ch */ case    3:  		/* lwz R11, <#[R3 + 8]> */
		/* 8206A69Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8206A69Ch case    3:*/		return 0x8206A6A0;
		  /* 8206A6A0h */ case    4:  		/* mr R31, R3 */
		/* 8206A6A0h case    4:*/		regs.R31 = regs.R3;
		/* 8206A6A0h case    4:*/		return 0x8206A6A4;
		  /* 8206A6A4h */ case    5:  		/* mr R28, R5 */
		/* 8206A6A4h case    5:*/		regs.R28 = regs.R5;
		/* 8206A6A4h case    5:*/		return 0x8206A6A8;
		  /* 8206A6A8h */ case    6:  		/* cmplw CR6, R4, R11 */
		/* 8206A6A8h case    6:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 8206A6A8h case    6:*/		return 0x8206A6AC;
		  /* 8206A6ACh */ case    7:  		/* bc 4, CR6_GT, 104 */
		/* 8206A6ACh case    7:*/		if ( !regs.CR[6].gt ) { return 0x8206A714;  }
		/* 8206A6ACh case    7:*/		return 0x8206A6B0;
		  /* 8206A6B0h */ case    8:  		/* rlwinm R30, R11, 1, 0, 30 */
		/* 8206A6B0h case    8:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R30,regs.R11);
		/* 8206A6B0h case    8:*/		return 0x8206A6B4;
		  /* 8206A6B4h */ case    9:  		/* cmplw CR6, R30, R4 */
		/* 8206A6B4h case    9:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R4);
		/* 8206A6B4h case    9:*/		return 0x8206A6B8;
		  /* 8206A6B8h */ case   10:  		/* bc 4, CR6_LT, 8 */
		/* 8206A6B8h case   10:*/		if ( !regs.CR[6].lt ) { return 0x8206A6C0;  }
		/* 8206A6B8h case   10:*/		return 0x8206A6BC;
		  /* 8206A6BCh */ case   11:  		/* mr R30, R4 */
		/* 8206A6BCh case   11:*/		regs.R30 = regs.R4;
		/* 8206A6BCh case   11:*/		return 0x8206A6C0;
	}
	return 0x8206A6C0;
} // Block from 8206A690h-8206A6C0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8206A6C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A6C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A6C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A6C0);
		  /* 8206A6C0h */ case    0:  		/* lis R4, 25728 */
		/* 8206A6C0h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x6480);
		/* 8206A6C0h case    0:*/		return 0x8206A6C4;
		  /* 8206A6C4h */ case    1:  		/* rlwinm R3, R30, 3, 0, 28 */
		/* 8206A6C4h case    1:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R3,regs.R30);
		/* 8206A6C4h case    1:*/		return 0x8206A6C8;
		  /* 8206A6C8h */ case    2:  		/* bl 121656 */
		/* 8206A6C8h case    2:*/		regs.LR = 0x8206A6CC; return 0x82088200;
		/* 8206A6C8h case    2:*/		return 0x8206A6CC;
		  /* 8206A6CCh */ case    3:  		/* or. R29, R3, R3 */
		/* 8206A6CCh case    3:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 8206A6CCh case    3:*/		return 0x8206A6D0;
		  /* 8206A6D0h */ case    4:  		/* bc 4, CR0_EQ, 20 */
		/* 8206A6D0h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8206A6E4;  }
		/* 8206A6D0h case    4:*/		return 0x8206A6D4;
		  /* 8206A6D4h */ case    5:  		/* lis R11, -32761 */
		/* 8206A6D4h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8007);
		/* 8206A6D4h case    5:*/		return 0x8206A6D8;
		  /* 8206A6D8h */ case    6:  		/* ori R11, R11, 14 */
		/* 8206A6D8h case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xE);
		/* 8206A6D8h case    6:*/		return 0x8206A6DC;
		  /* 8206A6DCh */ case    7:  		/* stw R11, <#[R28]> */
		/* 8206A6DCh case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8206A6DCh case    7:*/		return 0x8206A6E0;
		  /* 8206A6E0h */ case    8:  		/* b 52 */
		/* 8206A6E0h case    8:*/		return 0x8206A714;
		/* 8206A6E0h case    8:*/		return 0x8206A6E4;
	}
	return 0x8206A6E4;
} // Block from 8206A6C0h-8206A6E4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8206A6E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A6E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A6E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A6E4);
		  /* 8206A6E4h */ case    0:  		/* lwz R4, <#[R31]> */
		/* 8206A6E4h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000000) );
		/* 8206A6E4h case    0:*/		return 0x8206A6E8;
		  /* 8206A6E8h */ case    1:  		/* stw R30, <#[R31 + 8]> */
		/* 8206A6E8h case    1:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000008) );
		/* 8206A6E8h case    1:*/		return 0x8206A6EC;
		  /* 8206A6ECh */ case    2:  		/* cmplwi CR6, R4, 0 */
		/* 8206A6ECh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8206A6ECh case    2:*/		return 0x8206A6F0;
		  /* 8206A6F0h */ case    3:  		/* bc 12, CR6_EQ, 32 */
		/* 8206A6F0h case    3:*/		if ( regs.CR[6].eq ) { return 0x8206A710;  }
		/* 8206A6F0h case    3:*/		return 0x8206A6F4;
		  /* 8206A6F4h */ case    4:  		/* lwz R11, <#[R31 + 4]> */
		/* 8206A6F4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8206A6F4h case    4:*/		return 0x8206A6F8;
		  /* 8206A6F8h */ case    5:  		/* mr R3, R29 */
		/* 8206A6F8h case    5:*/		regs.R3 = regs.R29;
		/* 8206A6F8h case    5:*/		return 0x8206A6FC;
		  /* 8206A6FCh */ case    6:  		/* rlwinm R5, R11, 3, 0, 28 */
		/* 8206A6FCh case    6:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R5,regs.R11);
		/* 8206A6FCh case    6:*/		return 0x8206A700;
		  /* 8206A700h */ case    7:  		/* bl 160432 */
		/* 8206A700h case    7:*/		regs.LR = 0x8206A704; return 0x820919B0;
		/* 8206A700h case    7:*/		return 0x8206A704;
		  /* 8206A704h */ case    8:  		/* lis R4, 9344 */
		/* 8206A704h case    8:*/		cpu::op::lis<0>(regs,&regs.R4,0x2480);
		/* 8206A704h case    8:*/		return 0x8206A708;
		  /* 8206A708h */ case    9:  		/* lwz R3, <#[R31]> */
		/* 8206A708h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 8206A708h case    9:*/		return 0x8206A70C;
		  /* 8206A70Ch */ case   10:  		/* bl 121900 */
		/* 8206A70Ch case   10:*/		regs.LR = 0x8206A710; return 0x82088338;
		/* 8206A70Ch case   10:*/		return 0x8206A710;
	}
	return 0x8206A710;
} // Block from 8206A6E4h-8206A710h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8206A710h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A710( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A710) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A710);
		  /* 8206A710h */ case    0:  		/* stw R29, <#[R31]> */
		/* 8206A710h case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000000) );
		/* 8206A710h case    0:*/		return 0x8206A714;
	}
	return 0x8206A714;
} // Block from 8206A710h-8206A714h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206A714h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A714( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A714) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A714);
		  /* 8206A714h */ case    0:  		/* addi R1, R1, 128 */
		/* 8206A714h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8206A714h case    0:*/		return 0x8206A718;
		  /* 8206A718h */ case    1:  		/* b 158608 */
		/* 8206A718h case    1:*/		return 0x820912A8;
		/* 8206A718h case    1:*/		return 0x8206A71C;
		  /* 8206A71Ch */ case    2:  		/* nop */
		/* 8206A71Ch case    2:*/		cpu::op::nop();
		/* 8206A71Ch case    2:*/		return 0x8206A720;
	}
	return 0x8206A720;
} // Block from 8206A714h-8206A720h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206A720h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A720( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A720) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A720);
		  /* 8206A720h */ case    0:  		/* mfspr R12, LR */
		/* 8206A720h case    0:*/		regs.R12 = regs.LR;
		/* 8206A720h case    0:*/		return 0x8206A724;
		  /* 8206A724h */ case    1:  		/* bl 158516 */
		/* 8206A724h case    1:*/		regs.LR = 0x8206A728; return 0x82091258;
		/* 8206A724h case    1:*/		return 0x8206A728;
		  /* 8206A728h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8206A728h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8206A728h case    2:*/		return 0x8206A72C;
		  /* 8206A72Ch */ case    3:  		/* lwz R11, <#[R3 + 8]> */
		/* 8206A72Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8206A72Ch case    3:*/		return 0x8206A730;
		  /* 8206A730h */ case    4:  		/* mr R31, R3 */
		/* 8206A730h case    4:*/		regs.R31 = regs.R3;
		/* 8206A730h case    4:*/		return 0x8206A734;
		  /* 8206A734h */ case    5:  		/* mr R28, R5 */
		/* 8206A734h case    5:*/		regs.R28 = regs.R5;
		/* 8206A734h case    5:*/		return 0x8206A738;
		  /* 8206A738h */ case    6:  		/* cmplw CR6, R4, R11 */
		/* 8206A738h case    6:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 8206A738h case    6:*/		return 0x8206A73C;
		  /* 8206A73Ch */ case    7:  		/* bc 4, CR6_GT, 104 */
		/* 8206A73Ch case    7:*/		if ( !regs.CR[6].gt ) { return 0x8206A7A4;  }
		/* 8206A73Ch case    7:*/		return 0x8206A740;
		  /* 8206A740h */ case    8:  		/* rlwinm R30, R11, 1, 0, 30 */
		/* 8206A740h case    8:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R30,regs.R11);
		/* 8206A740h case    8:*/		return 0x8206A744;
		  /* 8206A744h */ case    9:  		/* cmplw CR6, R30, R4 */
		/* 8206A744h case    9:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R4);
		/* 8206A744h case    9:*/		return 0x8206A748;
		  /* 8206A748h */ case   10:  		/* bc 4, CR6_LT, 8 */
		/* 8206A748h case   10:*/		if ( !regs.CR[6].lt ) { return 0x8206A750;  }
		/* 8206A748h case   10:*/		return 0x8206A74C;
		  /* 8206A74Ch */ case   11:  		/* mr R30, R4 */
		/* 8206A74Ch case   11:*/		regs.R30 = regs.R4;
		/* 8206A74Ch case   11:*/		return 0x8206A750;
	}
	return 0x8206A750;
} // Block from 8206A720h-8206A750h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8206A750h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A750( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A750) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A750);
		  /* 8206A750h */ case    0:  		/* lis R4, 25728 */
		/* 8206A750h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0x6480);
		/* 8206A750h case    0:*/		return 0x8206A754;
		  /* 8206A754h */ case    1:  		/* rlwinm R3, R30, 2, 0, 29 */
		/* 8206A754h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R30);
		/* 8206A754h case    1:*/		return 0x8206A758;
		  /* 8206A758h */ case    2:  		/* bl 121512 */
		/* 8206A758h case    2:*/		regs.LR = 0x8206A75C; return 0x82088200;
		/* 8206A758h case    2:*/		return 0x8206A75C;
		  /* 8206A75Ch */ case    3:  		/* or. R29, R3, R3 */
		/* 8206A75Ch case    3:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 8206A75Ch case    3:*/		return 0x8206A760;
		  /* 8206A760h */ case    4:  		/* bc 4, CR0_EQ, 20 */
		/* 8206A760h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8206A774;  }
		/* 8206A760h case    4:*/		return 0x8206A764;
		  /* 8206A764h */ case    5:  		/* lis R11, -32761 */
		/* 8206A764h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8007);
		/* 8206A764h case    5:*/		return 0x8206A768;
		  /* 8206A768h */ case    6:  		/* ori R11, R11, 14 */
		/* 8206A768h case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xE);
		/* 8206A768h case    6:*/		return 0x8206A76C;
		  /* 8206A76Ch */ case    7:  		/* stw R11, <#[R28]> */
		/* 8206A76Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 8206A76Ch case    7:*/		return 0x8206A770;
		  /* 8206A770h */ case    8:  		/* b 52 */
		/* 8206A770h case    8:*/		return 0x8206A7A4;
		/* 8206A770h case    8:*/		return 0x8206A774;
	}
	return 0x8206A774;
} // Block from 8206A750h-8206A774h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8206A774h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A774( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A774) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A774);
		  /* 8206A774h */ case    0:  		/* lwz R4, <#[R31]> */
		/* 8206A774h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000000) );
		/* 8206A774h case    0:*/		return 0x8206A778;
		  /* 8206A778h */ case    1:  		/* stw R30, <#[R31 + 8]> */
		/* 8206A778h case    1:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000008) );
		/* 8206A778h case    1:*/		return 0x8206A77C;
		  /* 8206A77Ch */ case    2:  		/* cmplwi CR6, R4, 0 */
		/* 8206A77Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8206A77Ch case    2:*/		return 0x8206A780;
		  /* 8206A780h */ case    3:  		/* bc 12, CR6_EQ, 32 */
		/* 8206A780h case    3:*/		if ( regs.CR[6].eq ) { return 0x8206A7A0;  }
		/* 8206A780h case    3:*/		return 0x8206A784;
		  /* 8206A784h */ case    4:  		/* lwz R11, <#[R31 + 4]> */
		/* 8206A784h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8206A784h case    4:*/		return 0x8206A788;
		  /* 8206A788h */ case    5:  		/* mr R3, R29 */
		/* 8206A788h case    5:*/		regs.R3 = regs.R29;
		/* 8206A788h case    5:*/		return 0x8206A78C;
		  /* 8206A78Ch */ case    6:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 8206A78Ch case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 8206A78Ch case    6:*/		return 0x8206A790;
		  /* 8206A790h */ case    7:  		/* bl 160288 */
		/* 8206A790h case    7:*/		regs.LR = 0x8206A794; return 0x820919B0;
		/* 8206A790h case    7:*/		return 0x8206A794;
		  /* 8206A794h */ case    8:  		/* lis R4, 9344 */
		/* 8206A794h case    8:*/		cpu::op::lis<0>(regs,&regs.R4,0x2480);
		/* 8206A794h case    8:*/		return 0x8206A798;
		  /* 8206A798h */ case    9:  		/* lwz R3, <#[R31]> */
		/* 8206A798h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 8206A798h case    9:*/		return 0x8206A79C;
		  /* 8206A79Ch */ case   10:  		/* bl 121756 */
		/* 8206A79Ch case   10:*/		regs.LR = 0x8206A7A0; return 0x82088338;
		/* 8206A79Ch case   10:*/		return 0x8206A7A0;
	}
	return 0x8206A7A0;
} // Block from 8206A774h-8206A7A0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8206A7A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A7A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A7A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A7A0);
		  /* 8206A7A0h */ case    0:  		/* stw R29, <#[R31]> */
		/* 8206A7A0h case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000000) );
		/* 8206A7A0h case    0:*/		return 0x8206A7A4;
	}
	return 0x8206A7A4;
} // Block from 8206A7A0h-8206A7A4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8206A7A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A7A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A7A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A7A4);
		  /* 8206A7A4h */ case    0:  		/* addi R1, R1, 128 */
		/* 8206A7A4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8206A7A4h case    0:*/		return 0x8206A7A8;
		  /* 8206A7A8h */ case    1:  		/* b 158464 */
		/* 8206A7A8h case    1:*/		return 0x820912A8;
		/* 8206A7A8h case    1:*/		return 0x8206A7AC;
		  /* 8206A7ACh */ case    2:  		/* nop */
		/* 8206A7ACh case    2:*/		cpu::op::nop();
		/* 8206A7ACh case    2:*/		return 0x8206A7B0;
	}
	return 0x8206A7B0;
} // Block from 8206A7A4h-8206A7B0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206A7B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A7B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A7B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A7B0);
		  /* 8206A7B0h */ case    0:  		/* mfspr R12, LR */
		/* 8206A7B0h case    0:*/		regs.R12 = regs.LR;
		/* 8206A7B0h case    0:*/		return 0x8206A7B4;
		  /* 8206A7B4h */ case    1:  		/* bl 158376 */
		/* 8206A7B4h case    1:*/		regs.LR = 0x8206A7B8; return 0x8209125C;
		/* 8206A7B4h case    1:*/		return 0x8206A7B8;
		  /* 8206A7B8h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 8206A7B8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8206A7B8h case    2:*/		return 0x8206A7BC;
		  /* 8206A7BCh */ case    3:  		/* mr R31, R3 */
		/* 8206A7BCh case    3:*/		regs.R31 = regs.R3;
		/* 8206A7BCh case    3:*/		return 0x8206A7C0;
		  /* 8206A7C0h */ case    4:  		/* lis R4, -19072 */
		/* 8206A7C0h case    4:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFFB580);
		/* 8206A7C0h case    4:*/		return 0x8206A7C4;
		  /* 8206A7C4h */ case    5:  		/* li R3, 8192 */
		/* 8206A7C4h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x2000);
		/* 8206A7C4h case    5:*/		return 0x8206A7C8;
		  /* 8206A7C8h */ case    6:  		/* bl 121400 */
		/* 8206A7C8h case    6:*/		regs.LR = 0x8206A7CC; return 0x82088200;
		/* 8206A7C8h case    6:*/		return 0x8206A7CC;
		  /* 8206A7CCh */ case    7:  		/* or. R30, R3, R3 */
		/* 8206A7CCh case    7:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 8206A7CCh case    7:*/		return 0x8206A7D0;
		  /* 8206A7D0h */ case    8:  		/* addi R29, R30, 8192 */
		/* 8206A7D0h case    8:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R30,0x2000);
		/* 8206A7D0h case    8:*/		return 0x8206A7D4;
		  /* 8206A7D4h */ case    9:  		/* bc 4, CR0_EQ, 12 */
		/* 8206A7D4h case    9:*/		if ( !regs.CR[0].eq ) { return 0x8206A7E0;  }
		/* 8206A7D4h case    9:*/		return 0x8206A7D8;
		  /* 8206A7D8h */ case   10:  		/* li R3, 0 */
		/* 8206A7D8h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8206A7D8h case   10:*/		return 0x8206A7DC;
		  /* 8206A7DCh */ case   11:  		/* b 248 */
		/* 8206A7DCh case   11:*/		return 0x8206A8D4;
		/* 8206A7DCh case   11:*/		return 0x8206A7E0;
	}
	return 0x8206A7E0;
} // Block from 8206A7B0h-8206A7E0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8206A7E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A7E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A7E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A7E0);
		  /* 8206A7E0h */ case    0:  		/* stw R30, <#[R31 + 14184]> */
		/* 8206A7E0h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00003768) );
		/* 8206A7E0h case    0:*/		return 0x8206A7E4;
		  /* 8206A7E4h */ case    1:  		/* mr R5, R29 */
		/* 8206A7E4h case    1:*/		regs.R5 = regs.R29;
		/* 8206A7E4h case    1:*/		return 0x8206A7E8;
		  /* 8206A7E8h */ case    2:  		/* mr R4, R30 */
		/* 8206A7E8h case    2:*/		regs.R4 = regs.R30;
		/* 8206A7E8h case    2:*/		return 0x8206A7EC;
		  /* 8206A7ECh */ case    3:  		/* mr R3, R31 */
		/* 8206A7ECh case    3:*/		regs.R3 = regs.R31;
		/* 8206A7ECh case    3:*/		return 0x8206A7F0;
		  /* 8206A7F0h */ case    4:  		/* bl -8472 */
		/* 8206A7F0h case    4:*/		regs.LR = 0x8206A7F4; return 0x820686D8;
		/* 8206A7F0h case    4:*/		return 0x8206A7F4;
		  /* 8206A7F4h */ case    5:  		/* rlwinm R11, R30, 12, 20, 31 */
		/* 8206A7F4h case    5:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R11,regs.R30);
		/* 8206A7F4h case    5:*/		return 0x8206A7F8;
		  /* 8206A7F8h */ case    6:  		/* addi R8, R3, 7 */
		/* 8206A7F8h case    6:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R3,0x7);
		/* 8206A7F8h case    6:*/		return 0x8206A7FC;
		  /* 8206A7FCh */ case    7:  		/* lwz R9, <#[R31 + 14188]> */
		/* 8206A7FCh case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000376C) );
		/* 8206A7FCh case    7:*/		return 0x8206A800;
		  /* 8206A800h */ case    8:  		/* addi R10, R11, 512 */
		/* 8206A800h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x200);
		/* 8206A800h case    8:*/		return 0x8206A804;
		  /* 8206A804h */ case    9:  		/* rlwinm R11, R30, 0, 3, 31 */
		/* 8206A804h case    9:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R11,regs.R30);
		/* 8206A804h case    9:*/		return 0x8206A808;
		  /* 8206A808h */ case   10:  		/* rlwinm R10, R10, 0, 19, 19 */
		/* 8206A808h case   10:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R10,regs.R10);
		/* 8206A808h case   10:*/		return 0x8206A80C;
		  /* 8206A80Ch */ case   11:  		/* rlwimi R3, R9, 0, 0, 7 */
		/* 8206A80Ch case   11:*/		cpu::op::rlwimi<0,0,0,7>(regs,&regs.R3,regs.R9);
		/* 8206A80Ch case   11:*/		return 0x8206A810;
		  /* 8206A810h */ case   12:  		/* add R10, R10, R11 */
		/* 8206A810h case   12:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 8206A810h case   12:*/		return 0x8206A814;
		  /* 8206A814h */ case   13:  		/* rlwinm R11, R8, 2, 0, 26 */
		/* 8206A814h case   13:*/		cpu::op::rlwinm<0,2,0,26>(regs,&regs.R11,regs.R8);
		/* 8206A814h case   13:*/		return 0x8206A818;
		  /* 8206A818h */ case   14:  		/* stw R3, <#[R31 + 14188]> */
		/* 8206A818h case   14:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000376C) );
		/* 8206A818h case   14:*/		return 0x8206A81C;
		  /* 8206A81Ch */ case   15:  		/* stw R10, <#[R31 + 14192]> */
		/* 8206A81Ch case   15:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00003770) );
		/* 8206A81Ch case   15:*/		return 0x8206A820;
		  /* 8206A820h */ case   16:  		/* li R4, 16 */
		/* 8206A820h case   16:*/		cpu::op::li<0>(regs,&regs.R4,0x10);
		/* 8206A820h case   16:*/		return 0x8206A824;
		  /* 8206A824h */ case   17:  		/* add R5, R11, R30 */
		/* 8206A824h case   17:*/		cpu::op::add<0>(regs,&regs.R5,regs.R11,regs.R30);
		/* 8206A824h case   17:*/		return 0x8206A828;
		  /* 8206A828h */ case   18:  		/* addi R30, R31, 14316 */
		/* 8206A828h case   18:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x37EC);
		/* 8206A828h case   18:*/		return 0x8206A82C;
		  /* 8206A82Ch */ case   19:  		/* mr R6, R29 */
		/* 8206A82Ch case   19:*/		regs.R6 = regs.R29;
		/* 8206A82Ch case   19:*/		return 0x8206A830;
		  /* 8206A830h */ case   20:  		/* mr R3, R31 */
		/* 8206A830h case   20:*/		regs.R3 = regs.R31;
		/* 8206A830h case   20:*/		return 0x8206A834;
		  /* 8206A834h */ case   21:  		/* bl -7788 */
		/* 8206A834h case   21:*/		regs.LR = 0x8206A838; return 0x820689C8;
		/* 8206A834h case   21:*/		return 0x8206A838;
		  /* 8206A838h */ case   22:  		/* rlwinm R11, R5, 12, 20, 31 */
		/* 8206A838h case   22:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R11,regs.R5);
		/* 8206A838h case   22:*/		return 0x8206A83C;
		  /* 8206A83Ch */ case   23:  		/* lwz R9, <#[R30 + 8]> */
		/* 8206A83Ch case   23:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000008) );
		/* 8206A83Ch case   23:*/		return 0x8206A840;
		  /* 8206A840h */ case   24:  		/* mr R8, R3 */
		/* 8206A840h case   24:*/		regs.R8 = regs.R3;
		/* 8206A840h case   24:*/		return 0x8206A844;
		  /* 8206A844h */ case   25:  		/* addi R11, R11, 512 */
		/* 8206A844h case   25:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x200);
		/* 8206A844h case   25:*/		return 0x8206A848;
		  /* 8206A848h */ case   26:  		/* rlwinm R10, R5, 0, 3, 31 */
		/* 8206A848h case   26:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R10,regs.R5);
		/* 8206A848h case   26:*/		return 0x8206A84C;
		  /* 8206A84Ch */ case   27:  		/* rlwimi R8, R9, 0, 0, 7 */
		/* 8206A84Ch case   27:*/		cpu::op::rlwimi<0,0,0,7>(regs,&regs.R8,regs.R9);
		/* 8206A84Ch case   27:*/		return 0x8206A850;
		  /* 8206A850h */ case   28:  		/* rlwinm R11, R11, 0, 19, 19 */
		/* 8206A850h case   28:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R11,regs.R11);
		/* 8206A850h case   28:*/		return 0x8206A854;
		  /* 8206A854h */ case   29:  		/* addi R9, R3, 7 */
		/* 8206A854h case   29:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R3,0x7);
		/* 8206A854h case   29:*/		return 0x8206A858;
		  /* 8206A858h */ case   30:  		/* add R11, R11, R10 */
		/* 8206A858h case   30:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8206A858h case   30:*/		return 0x8206A85C;
		  /* 8206A85Ch */ case   31:  		/* rlwinm R10, R9, 2, 0, 26 */
		/* 8206A85Ch case   31:*/		cpu::op::rlwinm<0,2,0,26>(regs,&regs.R10,regs.R9);
		/* 8206A85Ch case   31:*/		return 0x8206A860;
		  /* 8206A860h */ case   32:  		/* addi R4, R4, 1 */
		/* 8206A860h case   32:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 8206A860h case   32:*/		return 0x8206A864;
		  /* 8206A864h */ case   33:  		/* stw R11, <#[R30 + 12]> */
		/* 8206A864h case   33:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 8206A864h case   33:*/		return 0x8206A868;
		  /* 8206A868h */ case   34:  		/* stwu R8, <#[R30 + 8]> */
		/* 8206A868h case   34:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R30 + 0x00000008) );
		regs.R30 = (uint32)(regs.R30 + 0x00000008);
		/* 8206A868h case   34:*/		return 0x8206A86C;
		  /* 8206A86Ch */ case   35:  		/* add R5, R10, R5 */
		/* 8206A86Ch case   35:*/		cpu::op::add<0>(regs,&regs.R5,regs.R10,regs.R5);
		/* 8206A86Ch case   35:*/		return 0x8206A870;
		  /* 8206A870h */ case   36:  		/* cmplwi CR6, R4, 112 */
		/* 8206A870h case   36:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000070);
		/* 8206A870h case   36:*/		return 0x8206A874;
		  /* 8206A874h */ case   37:  		/* bc 4, CR6_GT, -72 */
		/* 8206A874h case   37:*/		if ( !regs.CR[6].gt ) { return 0x8206A82C;  }
		/* 8206A874h case   37:*/		return 0x8206A878;
		  /* 8206A878h */ case   38:  		/* li R10, 24 */
		/* 8206A878h case   38:*/		cpu::op::li<0>(regs,&regs.R10,0x18);
		/* 8206A878h case   38:*/		return 0x8206A87C;
		  /* 8206A87Ch */ case   39:  		/* addi R11, R5, -4 */
		/* 8206A87Ch case   39:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R5,0xFFFFFFFC);
		/* 8206A87Ch case   39:*/		return 0x8206A880;
		  /* 8206A880h */ case   40:  		/* mtspr CTR, R10 */
		/* 8206A880h case   40:*/		regs.CTR = regs.R10;
		/* 8206A880h case   40:*/		return 0x8206A884;
		  /* 8206A884h */ case   41:  		/* lis R10, -16384 */
		/* 8206A884h case   41:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFC000);
		/* 8206A884h case   41:*/		return 0x8206A888;
		  /* 8206A888h */ case   42:  		/* lis R9, 1 */
		/* 8206A888h case   42:*/		cpu::op::lis<0>(regs,&regs.R9,0x1);
		/* 8206A888h case   42:*/		return 0x8206A88C;
		  /* 8206A88Ch */ case   43:  		/* ori R10, R10, 13824 */
		/* 8206A88Ch case   43:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x3600);
		/* 8206A88Ch case   43:*/		return 0x8206A890;
		  /* 8206A890h */ case   44:  		/* ori R9, R9, 129 */
		/* 8206A890h case   44:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x81);
		/* 8206A890h case   44:*/		return 0x8206A894;
		  /* 8206A894h */ case   45:  		/* stwu R10, <#[R11 + 4]> */
		/* 8206A894h case   45:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206A894h case   45:*/		return 0x8206A898;
		  /* 8206A898h */ case   46:  		/* stwu R9, <#[R11 + 4]> */
		/* 8206A898h case   46:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 8206A898h case   46:*/		return 0x8206A89C;
		  /* 8206A89Ch */ case   47:  		/* bc 16, CR0_LT, -24 */
		/* 8206A89Ch case   47:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x8206A884;  }
		/* 8206A89Ch case   47:*/		return 0x8206A8A0;
		  /* 8206A8A0h */ case   48:  		/* rlwinm R10, R5, 12, 20, 31 */
		/* 8206A8A0h case   48:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R10,regs.R5);
		/* 8206A8A0h case   48:*/		return 0x8206A8A4;
		  /* 8206A8A4h */ case   49:  		/* lwz R9, <#[R31 + 15220]> */
		/* 8206A8A4h case   49:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00003B74) );
		/* 8206A8A4h case   49:*/		return 0x8206A8A8;
		  /* 8206A8A8h */ case   50:  		/* subf R11, R5, R11 */
		/* 8206A8A8h case   50:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R5,regs.R11);
		/* 8206A8A8h case   50:*/		return 0x8206A8AC;
		  /* 8206A8ACh */ case   51:  		/* addi R10, R10, 512 */
		/* 8206A8ACh case   51:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x200);
		/* 8206A8ACh case   51:*/		return 0x8206A8B0;
		  /* 8206A8B0h */ case   52:  		/* addi R8, R11, 4 */
		/* 8206A8B0h case   52:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x4);
		/* 8206A8B0h case   52:*/		return 0x8206A8B4;
		  /* 8206A8B4h */ case   53:  		/* rlwinm R11, R10, 0, 19, 19 */
		/* 8206A8B4h case   53:*/		cpu::op::rlwinm<0,0,19,19>(regs,&regs.R11,regs.R10);
		/* 8206A8B4h case   53:*/		return 0x8206A8B8;
		  /* 8206A8B8h */ case   54:  		/* rlwinm R10, R5, 0, 3, 31 */
		/* 8206A8B8h case   54:*/		cpu::op::rlwinm<0,0,3,31>(regs,&regs.R10,regs.R5);
		/* 8206A8B8h case   54:*/		return 0x8206A8BC;
		  /* 8206A8BCh */ case   55:  		/* srawi R8, R8, 2 */
		/* 8206A8BCh case   55:*/		cpu::op::srawi<0,2>(regs,&regs.R8,regs.R8);
		/* 8206A8BCh case   55:*/		return 0x8206A8C0;
		  /* 8206A8C0h */ case   56:  		/* add R11, R11, R10 */
		/* 8206A8C0h case   56:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8206A8C0h case   56:*/		return 0x8206A8C4;
		  /* 8206A8C4h */ case   57:  		/* rlwimi R8, R9, 0, 0, 7 */
		/* 8206A8C4h case   57:*/		cpu::op::rlwimi<0,0,0,7>(regs,&regs.R8,regs.R9);
		/* 8206A8C4h case   57:*/		return 0x8206A8C8;
		  /* 8206A8C8h */ case   58:  		/* stw R11, <#[R31 + 15224]> */
		/* 8206A8C8h case   58:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00003B78) );
		/* 8206A8C8h case   58:*/		return 0x8206A8CC;
		  /* 8206A8CCh */ case   59:  		/* li R3, 1 */
		/* 8206A8CCh case   59:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8206A8CCh case   59:*/		return 0x8206A8D0;
		  /* 8206A8D0h */ case   60:  		/* stw R8, <#[R31 + 15220]> */
		/* 8206A8D0h case   60:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00003B74) );
		/* 8206A8D0h case   60:*/		return 0x8206A8D4;
	}
	return 0x8206A8D4;
} // Block from 8206A7E0h-8206A8D4h (61 instructions)

//////////////////////////////////////////////////////
// Block at 8206A8D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A8D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A8D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A8D4);
		  /* 8206A8D4h */ case    0:  		/* addi R1, R1, 112 */
		/* 8206A8D4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8206A8D4h case    0:*/		return 0x8206A8D8;
		  /* 8206A8D8h */ case    1:  		/* b 158164 */
		/* 8206A8D8h case    1:*/		return 0x820912AC;
		/* 8206A8D8h case    1:*/		return 0x8206A8DC;
		  /* 8206A8DCh */ case    2:  		/* nop */
		/* 8206A8DCh case    2:*/		cpu::op::nop();
		/* 8206A8DCh case    2:*/		return 0x8206A8E0;
	}
	return 0x8206A8E0;
} // Block from 8206A8D4h-8206A8E0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8206A8E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A8E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A8E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A8E0);
		  /* 8206A8E0h */ case    0:  		/* mfspr R12, LR */
		/* 8206A8E0h case    0:*/		regs.R12 = regs.LR;
		/* 8206A8E0h case    0:*/		return 0x8206A8E4;
		  /* 8206A8E4h */ case    1:  		/* bl 158068 */
		/* 8206A8E4h case    1:*/		regs.LR = 0x8206A8E8; return 0x82091258;
		/* 8206A8E4h case    1:*/		return 0x8206A8E8;
		  /* 8206A8E8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 8206A8E8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8206A8E8h case    2:*/		return 0x8206A8EC;
		  /* 8206A8ECh */ case    3:  		/* lis R11, -32216 */
		/* 8206A8ECh case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 8206A8ECh case    3:*/		return 0x8206A8F0;
		  /* 8206A8F0h */ case    4:  		/* mr R30, R3 */
		/* 8206A8F0h case    4:*/		regs.R30 = regs.R3;
		/* 8206A8F0h case    4:*/		return 0x8206A8F4;
		  /* 8206A8F4h */ case    5:  		/* lwz R10, <#[R11 + 28684]> */
		/* 8206A8F4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000700C) );
		/* 8206A8F4h case    5:*/		return 0x8206A8F8;
		  /* 8206A8F8h */ case    6:  		/* cmplwi CR6, R10, 0 */
		/* 8206A8F8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8206A8F8h case    6:*/		return 0x8206A8FC;
		  /* 8206A8FCh */ case    7:  		/* bc 12, CR6_EQ, 32 */
		/* 8206A8FCh case    7:*/		if ( regs.CR[6].eq ) { return 0x8206A91C;  }
		/* 8206A8FCh case    7:*/		return 0x8206A900;
		  /* 8206A900h */ case    8:  		/* rlwinm R11, R10, 0, 0, 31 */
		/* 8206A900h case    8:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R10);
		/* 8206A900h case    8:*/		return 0x8206A904;
		  /* 8206A904h */ case    9:  		/* mtspr CTR, R11 */
		/* 8206A904h case    9:*/		regs.CTR = regs.R11;
		/* 8206A904h case    9:*/		return 0x8206A908;
		  /* 8206A908h */ case   10:  		/* bcctrl 20, CR0_LT */
		/* 8206A908h case   10:*/		if ( 1 ) { regs.LR = 0x8206A90C; return (uint32)regs.CTR; }
		/* 8206A908h case   10:*/		return 0x8206A90C;
		  /* 8206A90Ch */ case   11:  		/* cmpwi CR0, R3, 0 */
		/* 8206A90Ch case   11:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8206A90Ch case   11:*/		return 0x8206A910;
		  /* 8206A910h */ case   12:  		/* bc 4, CR0_EQ, 12 */
		/* 8206A910h case   12:*/		if ( !regs.CR[0].eq ) { return 0x8206A91C;  }
		/* 8206A910h case   12:*/		return 0x8206A914;
		  /* 8206A914h */ case   13:  		/* li R3, 0 */
		/* 8206A914h case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8206A914h case   13:*/		return 0x8206A918;
		  /* 8206A918h */ case   14:  		/* b 176 */
		/* 8206A918h case   14:*/		return 0x8206A9C8;
		/* 8206A918h case   14:*/		return 0x8206A91C;
	}
	return 0x8206A91C;
} // Block from 8206A8E0h-8206A91Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8206A91Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A91C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A91C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A91C);
		  /* 8206A91Ch */ case    0:  		/* lwz R10, <#[R30]> */
		/* 8206A91Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 8206A91Ch case    0:*/		return 0x8206A920;
		  /* 8206A920h */ case    1:  		/* lis R4, 9344 */
		/* 8206A920h case    1:*/		cpu::op::lis<0>(regs,&regs.R4,0x2480);
		/* 8206A920h case    1:*/		return 0x8206A924;
		  /* 8206A924h */ case    2:  		/* lwz R11, <#[R30 + 4]> */
		/* 8206A924h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 8206A924h case    2:*/		return 0x8206A928;
		  /* 8206A928h */ case    3:  		/* rlwinm R10, R10, 0, 31, 31 */
		/* 8206A928h case    3:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R10);
		/* 8206A928h case    3:*/		return 0x8206A92C;
		  /* 8206A92Ch */ case    4:  		/* lwz R29, <#[R30 + 8]> */
		/* 8206A92Ch case    4:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R30 + 0x00000008) );
		/* 8206A92Ch case    4:*/		return 0x8206A930;
		  /* 8206A930h */ case    5:  		/* add R28, R11, R30 */
		/* 8206A930h case    5:*/		cpu::op::add<0>(regs,&regs.R28,regs.R11,regs.R30);
		/* 8206A930h case    5:*/		return 0x8206A934;
		  /* 8206A934h */ case    6:  		/* subfic R10, R10, 0 */
		/* 8206A934h case    6:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R10,0x0);
		/* 8206A934h case    6:*/		return 0x8206A938;
		  /* 8206A938h */ case    7:  		/* subfe R10, R10, R10 */
		/* 8206A938h case    7:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8206A938h case    7:*/		return 0x8206A93C;
		  /* 8206A93Ch */ case    8:  		/* andi. R10, R10, 832 */
		/* 8206A93Ch case    8:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R10,0x340);
		/* 8206A93Ch case    8:*/		return 0x8206A940;
		  /* 8206A940h */ case    9:  		/* addi R10, R10, 40 */
		/* 8206A940h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x28);
		/* 8206A940h case    9:*/		return 0x8206A944;
		  /* 8206A944h */ case   10:  		/* add R3, R10, R11 */
		/* 8206A944h case   10:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 8206A944h case   10:*/		return 0x8206A948;
		  /* 8206A948h */ case   11:  		/* bl 121016 */
		/* 8206A948h case   11:*/		regs.LR = 0x8206A94C; return 0x82088200;
		/* 8206A948h case   11:*/		return 0x8206A94C;
		  /* 8206A94Ch */ case   12:  		/* or. R31, R3, R3 */
		/* 8206A94Ch case   12:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 8206A94Ch case   12:*/		return 0x8206A950;
		  /* 8206A950h */ case   13:  		/* bc 12, CR0_EQ, -60 */
		/* 8206A950h case   13:*/		if ( regs.CR[0].eq ) { return 0x8206A914;  }
		/* 8206A950h case   13:*/		return 0x8206A954;
		  /* 8206A954h */ case   14:  		/* li R11, 0 */
		/* 8206A954h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8206A954h case   14:*/		return 0x8206A958;
		  /* 8206A958h */ case   15:  		/* lwz R5, <#[R30 + 4]> */
		/* 8206A958h case   15:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x00000004) );
		/* 8206A958h case   15:*/		return 0x8206A95C;
		  /* 8206A95Ch */ case   16:  		/* mr R4, R30 */
		/* 8206A95Ch case   16:*/		regs.R4 = regs.R30;
		/* 8206A95Ch case   16:*/		return 0x8206A960;
		  /* 8206A960h */ case   17:  		/* std R11, <#[R31]> */
		/* 8206A960h case   17:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8206A960h case   17:*/		return 0x8206A964;
		  /* 8206A964h */ case   18:  		/* addi R3, R31, 40 */
		/* 8206A964h case   18:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0x28);
		/* 8206A964h case   18:*/		return 0x8206A968;
		  /* 8206A968h */ case   19:  		/* std R11, <#[R31 + 8]> */
		/* 8206A968h case   19:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8206A968h case   19:*/		return 0x8206A96C;
		  /* 8206A96Ch */ case   20:  		/* std R11, <#[R31 + 16]> */
		/* 8206A96Ch case   20:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 8206A96Ch case   20:*/		return 0x8206A970;
		  /* 8206A970h */ case   21:  		/* std R11, <#[R31 + 24]> */
		/* 8206A970h case   21:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 8206A970h case   21:*/		return 0x8206A974;
		  /* 8206A974h */ case   22:  		/* std R11, <#[R31 + 32]> */
		/* 8206A974h case   22:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 8206A974h case   22:*/		return 0x8206A978;
		  /* 8206A978h */ case   23:  		/* bl 120208 */
		/* 8206A978h case   23:*/		regs.LR = 0x8206A97C; return 0x82087F08;
		/* 8206A978h case   23:*/		return 0x8206A97C;
		  /* 8206A97Ch */ case   24:  		/* lis R4, -19072 */
		/* 8206A97Ch case   24:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFFB580);
		/* 8206A97Ch case   24:*/		return 0x8206A980;
		  /* 8206A980h */ case   25:  		/* mr R3, R29 */
		/* 8206A980h case   25:*/		regs.R3 = regs.R29;
		/* 8206A980h case   25:*/		return 0x8206A984;
		  /* 8206A984h */ case   26:  		/* bl 120956 */
		/* 8206A984h case   26:*/		regs.LR = 0x8206A988; return 0x82088200;
		/* 8206A984h case   26:*/		return 0x8206A988;
		  /* 8206A988h */ case   27:  		/* or. R30, R3, R3 */
		/* 8206A988h case   27:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 8206A988h case   27:*/		return 0x8206A98C;
		  /* 8206A98Ch */ case   28:  		/* bc 4, CR0_EQ, 20 */
		/* 8206A98Ch case   28:*/		if ( !regs.CR[0].eq ) { return 0x8206A9A0;  }
		/* 8206A98Ch case   28:*/		return 0x8206A990;
		  /* 8206A990h */ case   29:  		/* lis R4, 9344 */
		/* 8206A990h case   29:*/		cpu::op::lis<0>(regs,&regs.R4,0x2480);
		/* 8206A990h case   29:*/		return 0x8206A994;
		  /* 8206A994h */ case   30:  		/* mr R3, R31 */
		/* 8206A994h case   30:*/		regs.R3 = regs.R31;
		/* 8206A994h case   30:*/		return 0x8206A998;
		  /* 8206A998h */ case   31:  		/* bl 121248 */
		/* 8206A998h case   31:*/		regs.LR = 0x8206A99C; return 0x82088338;
		/* 8206A998h case   31:*/		return 0x8206A99C;
		  /* 8206A99Ch */ case   32:  		/* b -136 */
		/* 8206A99Ch case   32:*/		return 0x8206A914;
		/* 8206A99Ch case   32:*/		return 0x8206A9A0;
	}
	return 0x8206A9A0;
} // Block from 8206A91Ch-8206A9A0h (33 instructions)

//////////////////////////////////////////////////////
// Block at 8206A9A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A9A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A9A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A9A0);
		  /* 8206A9A0h */ case    0:  		/* mr R5, R29 */
		/* 8206A9A0h case    0:*/		regs.R5 = regs.R29;
		/* 8206A9A0h case    0:*/		return 0x8206A9A4;
		  /* 8206A9A4h */ case    1:  		/* mr R4, R28 */
		/* 8206A9A4h case    1:*/		regs.R4 = regs.R28;
		/* 8206A9A4h case    1:*/		return 0x8206A9A8;
		  /* 8206A9A8h */ case    2:  		/* mr R3, R30 */
		/* 8206A9A8h case    2:*/		regs.R3 = regs.R30;
		/* 8206A9A8h case    2:*/		return 0x8206A9AC;
		  /* 8206A9ACh */ case    3:  		/* bl 159748 */
		/* 8206A9ACh case    3:*/		regs.LR = 0x8206A9B0; return 0x820919B0;
		/* 8206A9ACh case    3:*/		return 0x8206A9B0;
		  /* 8206A9B0h */ case    4:  		/* mr R4, R30 */
		/* 8206A9B0h case    4:*/		regs.R4 = regs.R30;
		/* 8206A9B0h case    4:*/		return 0x8206A9B4;
		  /* 8206A9B4h */ case    5:  		/* mr R3, R31 */
		/* 8206A9B4h case    5:*/		regs.R3 = regs.R31;
		/* 8206A9B4h case    5:*/		return 0x8206A9B8;
		  /* 8206A9B8h */ case    6:  		/* bl -7184 */
		/* 8206A9B8h case    6:*/		regs.LR = 0x8206A9BC; return 0x82068DA8;
		/* 8206A9B8h case    6:*/		return 0x8206A9BC;
		  /* 8206A9BCh */ case    7:  		/* lwz R11, <#[R31]> */
		/* 8206A9BCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8206A9BCh case    7:*/		return 0x8206A9C0;
		  /* 8206A9C0h */ case    8:  		/* oris R11, R11, 16 */
		/* 8206A9C0h case    8:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x10);
		/* 8206A9C0h case    8:*/		return 0x8206A9C4;
		  /* 8206A9C4h */ case    9:  		/* stw R11, <#[R31]> */
		/* 8206A9C4h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8206A9C4h case    9:*/		return 0x8206A9C8;
	}
	return 0x8206A9C8;
} // Block from 8206A9A0h-8206A9C8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8206A9C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A9C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A9C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A9C8);
		  /* 8206A9C8h */ case    0:  		/* addi R1, R1, 128 */
		/* 8206A9C8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8206A9C8h case    0:*/		return 0x8206A9CC;
		  /* 8206A9CCh */ case    1:  		/* b 157916 */
		/* 8206A9CCh case    1:*/		return 0x820912A8;
		/* 8206A9CCh case    1:*/		return 0x8206A9D0;
	}
	return 0x8206A9D0;
} // Block from 8206A9C8h-8206A9D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8206A9D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206A9D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206A9D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206A9D0);
		  /* 8206A9D0h */ case    0:  		/* mfspr R12, LR */
		/* 8206A9D0h case    0:*/		regs.R12 = regs.LR;
		/* 8206A9D0h case    0:*/		return 0x8206A9D4;
		  /* 8206A9D4h */ case    1:  		/* bl 157812 */
		/* 8206A9D4h case    1:*/		regs.LR = 0x8206A9D8; return 0x82091248;
		/* 8206A9D4h case    1:*/		return 0x8206A9D8;
		  /* 8206A9D8h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 8206A9D8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 8206A9D8h case    2:*/		return 0x8206A9DC;
		  /* 8206A9DCh */ case    3:  		/* mr R30, R4 */
		/* 8206A9DCh case    3:*/		regs.R30 = regs.R4;
		/* 8206A9DCh case    3:*/		return 0x8206A9E0;
		  /* 8206A9E0h */ case    4:  		/* li R5, 872 */
		/* 8206A9E0h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x368);
		/* 8206A9E0h case    4:*/		return 0x8206A9E4;
		  /* 8206A9E4h */ case    5:  		/* li R4, 0 */
		/* 8206A9E4h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8206A9E4h case    5:*/		return 0x8206A9E8;
		  /* 8206A9E8h */ case    6:  		/* mr R31, R3 */
		/* 8206A9E8h case    6:*/		regs.R31 = regs.R3;
		/* 8206A9E8h case    6:*/		return 0x8206A9EC;
		  /* 8206A9ECh */ case    7:  		/* bl 158036 */
		/* 8206A9ECh case    7:*/		regs.LR = 0x8206A9F0; return 0x82091340;
		/* 8206A9ECh case    7:*/		return 0x8206A9F0;
		  /* 8206A9F0h */ case    8:  		/* li R11, 6 */
		/* 8206A9F0h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x6);
		/* 8206A9F0h case    8:*/		return 0x8206A9F4;
		  /* 8206A9F4h */ case    9:  		/* li R10, 1 */
		/* 8206A9F4h case    9:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8206A9F4h case    9:*/		return 0x8206A9F8;
		  /* 8206A9F8h */ case   10:  		/* stw R30, <#[R31 + 32]> */
		/* 8206A9F8h case   10:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000020) );
		/* 8206A9F8h case   10:*/		return 0x8206A9FC;
		  /* 8206A9FCh */ case   11:  		/* stw R11, <#[R31]> */
		/* 8206A9FCh case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8206A9FCh case   11:*/		return 0x8206AA00;
		  /* 8206AA00h */ case   12:  		/* lis R9, -1 */
		/* 8206AA00h case   12:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFFFFFF);
		/* 8206AA00h case   12:*/		return 0x8206AA04;
		  /* 8206AA04h */ case   13:  		/* stw R10, <#[R31 + 4]> */
		/* 8206AA04h case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8206AA04h case   13:*/		return 0x8206AA08;
		  /* 8206AA08h */ case   14:  		/* stw R9, <#[R31 + 20]> */
		/* 8206AA08h case   14:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000014) );
		/* 8206AA08h case   14:*/		return 0x8206AA0C;
		  /* 8206AA0Ch */ case   15:  		/* lwz R11, <#[R31 + 872]> */
		/* 8206AA0Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000368) );
		/* 8206AA0Ch case   15:*/		return 0x8206AA10;
		  /* 8206AA10h */ case   16:  		/* rlwinm R11, R11, 0, 26, 26 */
		/* 8206AA10h case   16:*/		cpu::op::rlwinm<0,0,26,26>(regs,&regs.R11,regs.R11);
		/* 8206AA10h case   16:*/		return 0x8206AA14;
		  /* 8206AA14h */ case   17:  		/* cntlzw R11, R11 */
		/* 8206AA14h case   17:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 8206AA14h case   17:*/		return 0x8206AA18;
		  /* 8206AA18h */ case   18:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 8206AA18h case   18:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 8206AA18h case   18:*/		return 0x8206AA1C;
		  /* 8206AA1Ch */ case   19:  		/* xori R11, R11, 1 */
		/* 8206AA1Ch case   19:*/		cpu::op::xori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8206AA1Ch case   19:*/		return 0x8206AA20;
		  /* 8206AA20h */ case   20:  		/* addic. R11, R11, 1 */
		/* 8206AA20h case   20:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0x1);
		/* 8206AA20h case   20:*/		return 0x8206AA24;
		  /* 8206AA24h */ case   21:  		/* bc 12, CR0_EQ, 156 */
		/* 8206AA24h case   21:*/		if ( regs.CR[0].eq ) { return 0x8206AAC0;  }
		/* 8206AA24h case   21:*/		return 0x8206AA28;
		  /* 8206AA28h */ case   22:  		/* addi R25, R31, 40 */
		/* 8206AA28h case   22:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R31,0x28);
		/* 8206AA28h case   22:*/		return 0x8206AA2C;
		  /* 8206AA2Ch */ case   23:  		/* addi R27, R31, 896 */
		/* 8206AA2Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R31,0x380);
		/* 8206AA2Ch case   23:*/		return 0x8206AA30;
		  /* 8206AA30h */ case   24:  		/* mr R24, R11 */
		/* 8206AA30h case   24:*/		regs.R24 = regs.R11;
		/* 8206AA30h case   24:*/		return 0x8206AA34;
		  /* 8206AA34h */ case   25:  		/* lwz R11, <#[R27]> */
		/* 8206AA34h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 8206AA34h case   25:*/		return 0x8206AA38;
		  /* 8206AA38h */ case   26:  		/* lwz R9, <#[R31 + 32]> */
		/* 8206AA38h case   26:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000020) );
		/* 8206AA38h case   26:*/		return 0x8206AA3C;
		  /* 8206AA3Ch */ case   27:  		/* add R11, R11, R31 */
		/* 8206AA3Ch case   27:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 8206AA3Ch case   27:*/		return 0x8206AA40;
		  /* 8206AA40h */ case   28:  		/* addi R10, R11, 872 */
		/* 8206AA40h case   28:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x368);
		/* 8206AA40h case   28:*/		return 0x8206AA44;
		  /* 8206AA44h */ case   29:  		/* lwz R8, <#[R11 + 896]> */
		/* 8206AA44h case   29:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000380) );
		/* 8206AA44h case   29:*/		return 0x8206AA48;
		  /* 8206AA48h */ case   30:  		/* lwz R7, <#[R11 + 872]> */
		/* 8206AA48h case   30:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000368) );
		/* 8206AA48h case   30:*/		return 0x8206AA4C;
		  /* 8206AA4Ch */ case   31:  		/* addi R8, R8, 9 */
		/* 8206AA4Ch case   31:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x9);
		/* 8206AA4Ch case   31:*/		return 0x8206AA50;
		  /* 8206AA50h */ case   32:  		/* lwz R11, <#[R11 + 900]> */
		/* 8206AA50h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000384) );
		/* 8206AA50h case   32:*/		return 0x8206AA54;
		  /* 8206AA54h */ case   33:  		/* add R26, R9, R7 */
		/* 8206AA54h case   33:*/		cpu::op::add<0>(regs,&regs.R26,regs.R9,regs.R7);
		/* 8206AA54h case   33:*/		return 0x8206AA58;
		  /* 8206AA58h */ case   34:  		/* rlwinm R9, R8, 2, 0, 29 */
		/* 8206AA58h case   34:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R8);
		/* 8206AA58h case   34:*/		return 0x8206AA5C;
		  /* 8206AA5Ch */ case   35:  		/* cmplwi CR6, R11, 0 */
		/* 8206AA5Ch case   35:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8206AA5Ch case   35:*/		return 0x8206AA60;
		  /* 8206AA60h */ case   36:  		/* add R10, R9, R10 */
		/* 8206AA60h case   36:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 8206AA60h case   36:*/		return 0x8206AA64;
		  /* 8206AA64h */ case   37:  		/* bc 12, CR6_EQ, 68 */
		/* 8206AA64h case   37:*/		if ( regs.CR[6].eq ) { return 0x8206AAA8;  }
		/* 8206AA64h case   37:*/		return 0x8206AA68;
		  /* 8206AA68h */ case   38:  		/* addi R30, R25, 28 */
		/* 8206AA68h case   38:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R25,0x1C);
		/* 8206AA68h case   38:*/		return 0x8206AA6C;
		  /* 8206AA6Ch */ case   39:  		/* mr R29, R10 */
		/* 8206AA6Ch case   39:*/		regs.R29 = regs.R10;
		/* 8206AA6Ch case   39:*/		return 0x8206AA70;
		  /* 8206AA70h */ case   40:  		/* mr R28, R11 */
		/* 8206AA70h case   40:*/		regs.R28 = regs.R11;
		/* 8206AA70h case   40:*/		return 0x8206AA74;
		  /* 8206AA74h */ case   41:  		/* lwz R11, <#[R29]> */
		/* 8206AA74h case   41:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8206AA74h case   41:*/		return 0x8206AA78;
		  /* 8206AA78h */ case   42:  		/* rlwinm R11, R11, 0, 20, 31 */
		/* 8206AA78h case   42:*/		cpu::op::rlwinm<0,0,20,31>(regs,&regs.R11,regs.R11);
		/* 8206AA78h case   42:*/		return 0x8206AA7C;
		  /* 8206AA7Ch */ case   43:  		/* mulli R11, R11, 12 */
		/* 8206AA7Ch case   43:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 8206AA7Ch case   43:*/		return 0x8206AA80;
		  /* 8206AA80h */ case   44:  		/* add R4, R11, R26 */
		/* 8206AA80h case   44:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R26);
		/* 8206AA80h case   44:*/		return 0x8206AA84;
		  /* 8206AA84h */ case   45:  		/* cmplw CR6, R30, R4 */
		/* 8206AA84h case   45:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R4);
		/* 8206AA84h case   45:*/		return 0x8206AA88;
		  /* 8206AA88h */ case   46:  		/* bc 12, CR6_EQ, 16 */
		/* 8206AA88h case   46:*/		if ( regs.CR[6].eq ) { return 0x8206AA98;  }
		/* 8206AA88h case   46:*/		return 0x8206AA8C;
		  /* 8206AA8Ch */ case   47:  		/* li R5, 12 */
		/* 8206AA8Ch case   47:*/		cpu::op::li<0>(regs,&regs.R5,0xC);
		/* 8206AA8Ch case   47:*/		return 0x8206AA90;
		  /* 8206AA90h */ case   48:  		/* mr R3, R30 */
		/* 8206AA90h case   48:*/		regs.R3 = regs.R30;
		/* 8206AA90h case   48:*/		return 0x8206AA94;
		  /* 8206AA94h */ case   49:  		/* bl 159516 */
		/* 8206AA94h case   49:*/		regs.LR = 0x8206AA98; return 0x820919B0;
		/* 8206AA94h case   49:*/		return 0x8206AA98;
	}
	return 0x8206AA98;
} // Block from 8206A9D0h-8206AA98h (50 instructions)

//////////////////////////////////////////////////////
// Block at 8206AA98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206AA98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206AA98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206AA98);
		  /* 8206AA98h */ case    0:  		/* addic. R28, R28, -1 */
		/* 8206AA98h case    0:*/		cpu::op::addic<1>(regs,&regs.R28,regs.R28,0xFFFFFFFF);
		/* 8206AA98h case    0:*/		return 0x8206AA9C;
		  /* 8206AA9Ch */ case    1:  		/* addi R29, R29, 4 */
		/* 8206AA9Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 8206AA9Ch case    1:*/		return 0x8206AAA0;
		  /* 8206AAA0h */ case    2:  		/* addi R30, R30, 12 */
		/* 8206AAA0h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0xC);
		/* 8206AAA0h case    2:*/		return 0x8206AAA4;
		  /* 8206AAA4h */ case    3:  		/* bc 4, CR0_EQ, -48 */
		/* 8206AAA4h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8206AA74;  }
		/* 8206AAA4h case    3:*/		return 0x8206AAA8;
	}
	return 0x8206AAA8;
} // Block from 8206AA98h-8206AAA8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8206AAA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8206AAA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8206AAA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8206AAA8);
		  /* 8206AAA8h */ case    0:  		/* li R11, -1 */
		/* 8206AAA8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 8206AAA8h case    0:*/		return 0x8206AAAC;
		  /* 8206AAACh */ case    1:  		/* addic. R24, R24, -1 */
		/* 8206AAACh case    1:*/		cpu::op::addic<1>(regs,&regs.R24,regs.R24,0xFFFFFFFF);
		/* 8206AAACh case    1:*/		return 0x8206AAB0;
		  /* 8206AAB0h */ case    2:  		/* stw R11, <#[R25]> */
		/* 8206AAB0h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 8206AAB0h case    2:*/		return 0x8206AAB4;
		  /* 8206AAB4h */ case    3:  		/* addi R27, R27, 8 */
		/* 8206AAB4h case    3:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x8);
		/* 8206AAB4h case    3:*/		return 0x8206AAB8;
		  /* 8206AAB8h */ case    4:  		/* addi R25, R25, 416 */
		/* 8206AAB8h case    4:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x1A0);
		/* 8206AAB8h case    4:*/		return 0x8206AABC;
		  /* 8206AABCh */ case    5:  		/* bc 4, CR0_EQ, -136 */
		/* 8206AABCh case    5:*/		if ( !regs.CR[0].eq ) { return 0x8206AA34;  }
		/* 8206AABCh case    5:*/		return 0x8206AAC0;
	}
	return 0x8206AAC0;
} // Block from 8206AAA8h-8206AAC0h (6 instructions)

