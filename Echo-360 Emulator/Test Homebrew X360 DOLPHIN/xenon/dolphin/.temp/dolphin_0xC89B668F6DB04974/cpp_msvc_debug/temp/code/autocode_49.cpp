#include "C:\Users\xdfah\Downloads\recompiler\Echo-360\Echo-360 0.0.1\../../dev/src/xenon_launcher/xenonCPU.h"

//////////////////////////////////////////////////////
// Block at 82260EF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260EF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260EF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260EF8);
		  /* 82260EF8h */ case    0:  		/* li R11, 0 */
		/* 82260EF8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82260EF8h case    0:*/		return 0x82260EFC;
	}
	return 0x82260EFC;
} // Block from 82260EF8h-82260EFCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82260EFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260EFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260EFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260EFC);
		  /* 82260EFCh */ case    0:  		/* lwz R30, <#[R11]> */
		/* 82260EFCh case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 82260EFCh case    0:*/		return 0x82260F00;
		  /* 82260F00h */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 82260F00h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82260F00h case    1:*/		return 0x82260F04;
		  /* 82260F04h */ case    2:  		/* bc 4, CR6_EQ, 28 */
		/* 82260F04h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82260F20;  }
		/* 82260F04h case    2:*/		return 0x82260F08;
		  /* 82260F08h */ case    3:  		/* li R7, 3742 */
		/* 82260F08h case    3:*/		cpu::op::li<0>(regs,&regs.R7,0xE9E);
		/* 82260F08h case    3:*/		return 0x82260F0C;
		  /* 82260F0Ch */ case    4:  		/* lwz R6, <#[R1 + 128]> */
		/* 82260F0Ch case    4:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 82260F0Ch case    4:*/		return 0x82260F10;
		  /* 82260F10h */ case    5:  		/* li R3, 0 */
		/* 82260F10h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82260F10h case    5:*/		return 0x82260F14;
		  /* 82260F14h */ case    6:  		/* lwz R5, <#[R1 + 528]> */
		/* 82260F14h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000210) );
		/* 82260F14h case    6:*/		return 0x82260F18;
		  /* 82260F18h */ case    7:  		/* lwz R4, <#[R1 + 132]> */
		/* 82260F18h case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 82260F18h case    7:*/		return 0x82260F1C;
		  /* 82260F1Ch */ case    8:  		/* bl -1086228 */
		/* 82260F1Ch case    8:*/		regs.LR = 0x82260F20; return 0x82157C08;
		/* 82260F1Ch case    8:*/		return 0x82260F20;
	}
	return 0x82260F20;
} // Block from 82260EFCh-82260F20h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82260F20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260F20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260F20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260F20);
		  /* 82260F20h */ case    0:  		/* lwz R28, <#[R30 + 152]> */
		/* 82260F20h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R30 + 0x00000098) );
		/* 82260F20h case    0:*/		return 0x82260F24;
		  /* 82260F24h */ case    1:  		/* mr R3, R31 */
		/* 82260F24h case    1:*/		regs.R3 = regs.R31;
		/* 82260F24h case    1:*/		return 0x82260F28;
		  /* 82260F28h */ case    2:  		/* lwz R29, <#[R1 + 160]> */
		/* 82260F28h case    2:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x000000A0) );
		/* 82260F28h case    2:*/		return 0x82260F2C;
		  /* 82260F2Ch */ case    3:  		/* mr R5, R28 */
		/* 82260F2Ch case    3:*/		regs.R5 = regs.R28;
		/* 82260F2Ch case    3:*/		return 0x82260F30;
		  /* 82260F30h */ case    4:  		/* mr R4, R29 */
		/* 82260F30h case    4:*/		regs.R4 = regs.R29;
		/* 82260F30h case    4:*/		return 0x82260F34;
		  /* 82260F34h */ case    5:  		/* bl -176860 */
		/* 82260F34h case    5:*/		regs.LR = 0x82260F38; return 0x82235C58;
		/* 82260F34h case    5:*/		return 0x82260F38;
		  /* 82260F38h */ case    6:  		/* lwz R11, <#[R29]> */
		/* 82260F38h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82260F38h case    6:*/		return 0x82260F3C;
		  /* 82260F3Ch */ case    7:  		/* mr R3, R29 */
		/* 82260F3Ch case    7:*/		regs.R3 = regs.R29;
		/* 82260F3Ch case    7:*/		return 0x82260F40;
		  /* 82260F40h */ case    8:  		/* lwz R11, <#[R11 + 28]> */
		/* 82260F40h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 82260F40h case    8:*/		return 0x82260F44;
		  /* 82260F44h */ case    9:  		/* mtspr CTR, R11 */
		/* 82260F44h case    9:*/		regs.CTR = regs.R11;
		/* 82260F44h case    9:*/		return 0x82260F48;
		  /* 82260F48h */ case   10:  		/* bcctrl 20, CR0_LT */
		/* 82260F48h case   10:*/		if ( 1 ) { regs.LR = 0x82260F4C; return (uint32)regs.CTR; }
		/* 82260F48h case   10:*/		return 0x82260F4C;
		  /* 82260F4Ch */ case   11:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82260F4Ch case   11:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82260F4Ch case   11:*/		return 0x82260F50;
		  /* 82260F50h */ case   12:  		/* bc 4, CR0_EQ, 44 */
		/* 82260F50h case   12:*/		if ( !regs.CR[0].eq ) { return 0x82260F7C;  }
		/* 82260F50h case   12:*/		return 0x82260F54;
		  /* 82260F54h */ case   13:  		/* lwz R11, <#[R29]> */
		/* 82260F54h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82260F54h case   13:*/		return 0x82260F58;
		  /* 82260F58h */ case   14:  		/* mr R3, R29 */
		/* 82260F58h case   14:*/		regs.R3 = regs.R29;
		/* 82260F58h case   14:*/		return 0x82260F5C;
		  /* 82260F5Ch */ case   15:  		/* lwz R11, <#[R11 + 32]> */
		/* 82260F5Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000020) );
		/* 82260F5Ch case   15:*/		return 0x82260F60;
		  /* 82260F60h */ case   16:  		/* mtspr CTR, R11 */
		/* 82260F60h case   16:*/		regs.CTR = regs.R11;
		/* 82260F60h case   16:*/		return 0x82260F64;
		  /* 82260F64h */ case   17:  		/* bcctrl 20, CR0_LT */
		/* 82260F64h case   17:*/		if ( 1 ) { regs.LR = 0x82260F68; return (uint32)regs.CTR; }
		/* 82260F64h case   17:*/		return 0x82260F68;
		  /* 82260F68h */ case   18:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82260F68h case   18:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82260F68h case   18:*/		return 0x82260F6C;
		  /* 82260F6Ch */ case   19:  		/* bc 4, CR0_EQ, 16 */
		/* 82260F6Ch case   19:*/		if ( !regs.CR[0].eq ) { return 0x82260F7C;  }
		/* 82260F6Ch case   19:*/		return 0x82260F70;
		  /* 82260F70h */ case   20:  		/* mr R4, R28 */
		/* 82260F70h case   20:*/		regs.R4 = regs.R28;
		/* 82260F70h case   20:*/		return 0x82260F74;
		  /* 82260F74h */ case   21:  		/* mr R3, R29 */
		/* 82260F74h case   21:*/		regs.R3 = regs.R29;
		/* 82260F74h case   21:*/		return 0x82260F78;
		  /* 82260F78h */ case   22:  		/* bl -30376 */
		/* 82260F78h case   22:*/		regs.LR = 0x82260F7C; return 0x822598D0;
		/* 82260F78h case   22:*/		return 0x82260F7C;
	}
	return 0x82260F7C;
} // Block from 82260F20h-82260F7Ch (23 instructions)

//////////////////////////////////////////////////////
// Block at 82260F7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260F7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260F7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260F7C);
		  /* 82260F7Ch */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 82260F7Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82260F7Ch case    0:*/		return 0x82260F80;
		  /* 82260F80h */ case    1:  		/* li R3, 136 */
		/* 82260F80h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x88);
		/* 82260F80h case    1:*/		return 0x82260F84;
		  /* 82260F84h */ case    2:  		/* lwz R4, <#[R11 + 1452]> */
		/* 82260F84h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005AC) );
		/* 82260F84h case    2:*/		return 0x82260F88;
		  /* 82260F88h */ case    3:  		/* bl -26776 */
		/* 82260F88h case    3:*/		regs.LR = 0x82260F8C; return 0x8225A6F0;
		/* 82260F88h case    3:*/		return 0x82260F8C;
		  /* 82260F8Ch */ case    4:  		/* cmplwi CR0, R3, 0 */
		/* 82260F8Ch case    4:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82260F8Ch case    4:*/		return 0x82260F90;
		  /* 82260F90h */ case    5:  		/* bc 12, CR0_EQ, 20 */
		/* 82260F90h case    5:*/		if ( regs.CR[0].eq ) { return 0x82260FA4;  }
		/* 82260F90h case    5:*/		return 0x82260F94;
		  /* 82260F94h */ case    6:  		/* lwz R4, <#[R31 + 12]> */
		/* 82260F94h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 82260F94h case    6:*/		return 0x82260F98;
		  /* 82260F98h */ case    7:  		/* bl -32328 */
		/* 82260F98h case    7:*/		regs.LR = 0x82260F9C; return 0x82259150;
		/* 82260F98h case    7:*/		return 0x82260F9C;
		  /* 82260F9Ch */ case    8:  		/* mr R29, R3 */
		/* 82260F9Ch case    8:*/		regs.R29 = regs.R3;
		/* 82260F9Ch case    8:*/		return 0x82260FA0;
		  /* 82260FA0h */ case    9:  		/* b 8 */
		/* 82260FA0h case    9:*/		return 0x82260FA8;
		/* 82260FA0h case    9:*/		return 0x82260FA4;
	}
	return 0x82260FA4;
} // Block from 82260F7Ch-82260FA4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82260FA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260FA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260FA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260FA4);
		  /* 82260FA4h */ case    0:  		/* li R29, 0 */
		/* 82260FA4h case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82260FA4h case    0:*/		return 0x82260FA8;
	}
	return 0x82260FA8;
} // Block from 82260FA4h-82260FA8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82260FA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82260FA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82260FA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82260FA8);
		  /* 82260FA8h */ case    0:  		/* mr R4, R29 */
		/* 82260FA8h case    0:*/		regs.R4 = regs.R29;
		/* 82260FA8h case    0:*/		return 0x82260FAC;
		  /* 82260FACh */ case    1:  		/* mr R3, R30 */
		/* 82260FACh case    1:*/		regs.R3 = regs.R30;
		/* 82260FACh case    1:*/		return 0x82260FB0;
		  /* 82260FB0h */ case    2:  		/* bl -30432 */
		/* 82260FB0h case    2:*/		regs.LR = 0x82260FB4; return 0x822598D0;
		/* 82260FB0h case    2:*/		return 0x82260FB4;
		  /* 82260FB4h */ case    3:  		/* mr R5, R29 */
		/* 82260FB4h case    3:*/		regs.R5 = regs.R29;
		/* 82260FB4h case    3:*/		return 0x82260FB8;
		  /* 82260FB8h */ case    4:  		/* mr R4, R28 */
		/* 82260FB8h case    4:*/		regs.R4 = regs.R28;
		/* 82260FB8h case    4:*/		return 0x82260FBC;
		  /* 82260FBCh */ case    5:  		/* mr R3, R31 */
		/* 82260FBCh case    5:*/		regs.R3 = regs.R31;
		/* 82260FBCh case    5:*/		return 0x82260FC0;
		  /* 82260FC0h */ case    6:  		/* bl -177000 */
		/* 82260FC0h case    6:*/		regs.LR = 0x82260FC4; return 0x82235C58;
		/* 82260FC0h case    6:*/		return 0x82260FC4;
		  /* 82260FC4h */ case    7:  		/* mr R3, R29 */
		/* 82260FC4h case    7:*/		regs.R3 = regs.R29;
		/* 82260FC4h case    7:*/		return 0x82260FC8;
		  /* 82260FC8h */ case    8:  		/* lwz R30, <#[R30 + 156]> */
		/* 82260FC8h case    8:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x0000009C) );
		/* 82260FC8h case    8:*/		return 0x82260FCC;
		  /* 82260FCCh */ case    9:  		/* mr R4, R30 */
		/* 82260FCCh case    9:*/		regs.R4 = regs.R30;
		/* 82260FCCh case    9:*/		return 0x82260FD0;
		  /* 82260FD0h */ case   10:  		/* bl -30464 */
		/* 82260FD0h case   10:*/		regs.LR = 0x82260FD4; return 0x822598D0;
		/* 82260FD0h case   10:*/		return 0x82260FD4;
		  /* 82260FD4h */ case   11:  		/* mr R5, R30 */
		/* 82260FD4h case   11:*/		regs.R5 = regs.R30;
		/* 82260FD4h case   11:*/		return 0x82260FD8;
		  /* 82260FD8h */ case   12:  		/* mr R4, R29 */
		/* 82260FD8h case   12:*/		regs.R4 = regs.R29;
		/* 82260FD8h case   12:*/		return 0x82260FDC;
		  /* 82260FDCh */ case   13:  		/* mr R3, R31 */
		/* 82260FDCh case   13:*/		regs.R3 = regs.R31;
		/* 82260FDCh case   13:*/		return 0x82260FE0;
		  /* 82260FE0h */ case   14:  		/* bl -177032 */
		/* 82260FE0h case   14:*/		regs.LR = 0x82260FE4; return 0x82235C58;
		/* 82260FE0h case   14:*/		return 0x82260FE4;
		  /* 82260FE4h */ case   15:  		/* lwz R11, <#[R31 + 12]> */
		/* 82260FE4h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82260FE4h case   15:*/		return 0x82260FE8;
		  /* 82260FE8h */ case   16:  		/* li R3, 136 */
		/* 82260FE8h case   16:*/		cpu::op::li<0>(regs,&regs.R3,0x88);
		/* 82260FE8h case   16:*/		return 0x82260FEC;
		  /* 82260FECh */ case   17:  		/* lwz R4, <#[R11 + 1452]> */
		/* 82260FECh case   17:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005AC) );
		/* 82260FECh case   17:*/		return 0x82260FF0;
		  /* 82260FF0h */ case   18:  		/* bl -26880 */
		/* 82260FF0h case   18:*/		regs.LR = 0x82260FF4; return 0x8225A6F0;
		/* 82260FF0h case   18:*/		return 0x82260FF4;
		  /* 82260FF4h */ case   19:  		/* cmplwi CR0, R3, 0 */
		/* 82260FF4h case   19:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82260FF4h case   19:*/		return 0x82260FF8;
		  /* 82260FF8h */ case   20:  		/* bc 12, CR0_EQ, 20 */
		/* 82260FF8h case   20:*/		if ( regs.CR[0].eq ) { return 0x8226100C;  }
		/* 82260FF8h case   20:*/		return 0x82260FFC;
		  /* 82260FFCh */ case   21:  		/* lwz R4, <#[R31 + 12]> */
		/* 82260FFCh case   21:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 82260FFCh case   21:*/		return 0x82261000;
		  /* 82261000h */ case   22:  		/* bl -32432 */
		/* 82261000h case   22:*/		regs.LR = 0x82261004; return 0x82259150;
		/* 82261000h case   22:*/		return 0x82261004;
		  /* 82261004h */ case   23:  		/* mr R14, R3 */
		/* 82261004h case   23:*/		regs.R14 = regs.R3;
		/* 82261004h case   23:*/		return 0x82261008;
		  /* 82261008h */ case   24:  		/* b 8 */
		/* 82261008h case   24:*/		return 0x82261010;
		/* 82261008h case   24:*/		return 0x8226100C;
	}
	return 0x8226100C;
} // Block from 82260FA8h-8226100Ch (25 instructions)

//////////////////////////////////////////////////////
// Block at 8226100Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226100C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226100C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226100C);
		  /* 8226100Ch */ case    0:  		/* li R14, 0 */
		/* 8226100Ch case    0:*/		cpu::op::li<0>(regs,&regs.R14,0x0);
		/* 8226100Ch case    0:*/		return 0x82261010;
	}
	return 0x82261010;
} // Block from 8226100Ch-82261010h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82261010h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261010( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261010) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261010);
		  /* 82261010h */ case    0:  		/* mr R5, R14 */
		/* 82261010h case    0:*/		regs.R5 = regs.R14;
		/* 82261010h case    0:*/		return 0x82261014;
		  /* 82261014h */ case    1:  		/* mr R4, R30 */
		/* 82261014h case    1:*/		regs.R4 = regs.R30;
		/* 82261014h case    1:*/		return 0x82261018;
		  /* 82261018h */ case    2:  		/* mr R3, R31 */
		/* 82261018h case    2:*/		regs.R3 = regs.R31;
		/* 82261018h case    2:*/		return 0x8226101C;
		  /* 8226101Ch */ case    3:  		/* bl -177092 */
		/* 8226101Ch case    3:*/		regs.LR = 0x82261020; return 0x82235C58;
		/* 8226101Ch case    3:*/		return 0x82261020;
		  /* 82261020h */ case    4:  		/* mr R4, R14 */
		/* 82261020h case    4:*/		regs.R4 = regs.R14;
		/* 82261020h case    4:*/		return 0x82261024;
		  /* 82261024h */ case    5:  		/* mr R3, R30 */
		/* 82261024h case    5:*/		regs.R3 = regs.R30;
		/* 82261024h case    5:*/		return 0x82261028;
		  /* 82261028h */ case    6:  		/* bl -30552 */
		/* 82261028h case    6:*/		regs.LR = 0x8226102C; return 0x822598D0;
		/* 82261028h case    6:*/		return 0x8226102C;
		  /* 8226102Ch */ case    7:  		/* mr R3, R27 */
		/* 8226102Ch case    7:*/		regs.R3 = regs.R27;
		/* 8226102Ch case    7:*/		return 0x82261030;
		  /* 82261030h */ case    8:  		/* stw R14, <#[R1 + 160]> */
		/* 82261030h case    8:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R1 + 0x000000A0) );
		/* 82261030h case    8:*/		return 0x82261034;
		  /* 82261034h */ case    9:  		/* bl -25316 */
		/* 82261034h case    9:*/		regs.LR = 0x82261038; return 0x8225AD50;
		/* 82261034h case    9:*/		return 0x82261038;
		  /* 82261038h */ case   10:  		/* lwz R11, <#[R1 + 188]> */
		/* 82261038h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000BC) );
		/* 82261038h case   10:*/		return 0x8226103C;
		  /* 8226103Ch */ case   11:  		/* addic. R27, R11, -1 */
		/* 8226103Ch case   11:*/		cpu::op::addic<1>(regs,&regs.R27,regs.R11,0xFFFFFFFF);
		/* 8226103Ch case   11:*/		return 0x82261040;
		  /* 82261040h */ case   12:  		/* stw R27, <#[R1 + 188]> */
		/* 82261040h case   12:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x000000BC) );
		/* 82261040h case   12:*/		return 0x82261044;
		  /* 82261044h */ case   13:  		/* bc 4, CR0_LT, 28 */
		/* 82261044h case   13:*/		if ( !regs.CR[0].lt ) { return 0x82261060;  }
		/* 82261044h case   13:*/		return 0x82261048;
		  /* 82261048h */ case   14:  		/* li R7, 3772 */
		/* 82261048h case   14:*/		cpu::op::li<0>(regs,&regs.R7,0xEBC);
		/* 82261048h case   14:*/		return 0x8226104C;
		  /* 8226104Ch */ case   15:  		/* lwz R6, <#[R1 + 128]> */
		/* 8226104Ch case   15:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 8226104Ch case   15:*/		return 0x82261050;
		  /* 82261050h */ case   16:  		/* li R3, 0 */
		/* 82261050h case   16:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82261050h case   16:*/		return 0x82261054;
		  /* 82261054h */ case   17:  		/* lwz R5, <#[R1 + 340]> */
		/* 82261054h case   17:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000154) );
		/* 82261054h case   17:*/		return 0x82261058;
		  /* 82261058h */ case   18:  		/* lwz R4, <#[R1 + 132]> */
		/* 82261058h case   18:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 82261058h case   18:*/		return 0x8226105C;
		  /* 8226105Ch */ case   19:  		/* bl -1086548 */
		/* 8226105Ch case   19:*/		regs.LR = 0x82261060; return 0x82157C08;
		/* 8226105Ch case   19:*/		return 0x82261060;
	}
	return 0x82261060;
} // Block from 82261010h-82261060h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82261060h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261060( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261060) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261060);
		  /* 82261060h */ case    0:  		/* stw R27, <#[R29 + 52]> */
		/* 82261060h case    0:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R29 + 0x00000034) );
		/* 82261060h case    0:*/		return 0x82261064;
		  /* 82261064h */ case    1:  		/* stw R27, <#[R28 + 52]> */
		/* 82261064h case    1:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R28 + 0x00000034) );
		/* 82261064h case    1:*/		return 0x82261068;
		  /* 82261068h */ case    2:  		/* stw R27, <#[R30 + 52]> */
		/* 82261068h case    2:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R30 + 0x00000034) );
		/* 82261068h case    2:*/		return 0x8226106C;
		  /* 8226106Ch */ case    3:  		/* stw R27, <#[R14 + 52]> */
		/* 8226106Ch case    3:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R14 + 0x00000034) );
		/* 8226106Ch case    3:*/		return 0x82261070;
		  /* 82261070h */ case    4:  		/* b 3408 */
		/* 82261070h case    4:*/		return 0x82261DC0;
		/* 82261070h case    4:*/		return 0x82261074;
		  /* 82261074h */ case    5:  		/* lwz R11, <#[R1 + 164]> */
		/* 82261074h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000A4) );
		/* 82261074h case    5:*/		return 0x82261078;
		  /* 82261078h */ case    6:  		/* lwz R27, <#[R1 + 128]> */
		/* 82261078h case    6:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000080) );
		/* 82261078h case    6:*/		return 0x8226107C;
		  /* 8226107Ch */ case    7:  		/* lwz R28, <#[R1 + 132]> */
		/* 8226107Ch case    7:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000084) );
		/* 8226107Ch case    7:*/		return 0x82261080;
		  /* 82261080h */ case    8:  		/* lwz R11, <#[R11 + 4]> */
		/* 82261080h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82261080h case    8:*/		return 0x82261084;
		  /* 82261084h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 82261084h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82261084h case    9:*/		return 0x82261088;
		  /* 82261088h */ case   10:  		/* bc 12, CR6_EQ, 28 */
		/* 82261088h case   10:*/		if ( regs.CR[6].eq ) { return 0x822610A4;  }
		/* 82261088h case   10:*/		return 0x8226108C;
		  /* 8226108Ch */ case   11:  		/* li R7, 3787 */
		/* 8226108Ch case   11:*/		cpu::op::li<0>(regs,&regs.R7,0xECB);
		/* 8226108Ch case   11:*/		return 0x82261090;
		  /* 82261090h */ case   12:  		/* lwz R5, <#[R1 + 376]> */
		/* 82261090h case   12:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000178) );
		/* 82261090h case   12:*/		return 0x82261094;
		  /* 82261094h */ case   13:  		/* li R3, 0 */
		/* 82261094h case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82261094h case   13:*/		return 0x82261098;
		  /* 82261098h */ case   14:  		/* mr R6, R27 */
		/* 82261098h case   14:*/		regs.R6 = regs.R27;
		/* 82261098h case   14:*/		return 0x8226109C;
		  /* 8226109Ch */ case   15:  		/* mr R4, R28 */
		/* 8226109Ch case   15:*/		regs.R4 = regs.R28;
		/* 8226109Ch case   15:*/		return 0x822610A0;
		  /* 822610A0h */ case   16:  		/* bl -1086616 */
		/* 822610A0h case   16:*/		regs.LR = 0x822610A4; return 0x82157C08;
		/* 822610A0h case   16:*/		return 0x822610A4;
	}
	return 0x822610A4;
} // Block from 82261060h-822610A4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 822610A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822610A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822610A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822610A4);
		  /* 822610A4h */ case    0:  		/* lwz R11, <#[R1 + 220]> */
		/* 822610A4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000DC) );
		/* 822610A4h case    0:*/		return 0x822610A8;
		  /* 822610A8h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 822610A8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 822610A8h case    1:*/		return 0x822610AC;
		  /* 822610ACh */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 822610ACh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822610ACh case    2:*/		return 0x822610B0;
		  /* 822610B0h */ case    3:  		/* bc 12, CR6_EQ, 28 */
		/* 822610B0h case    3:*/		if ( regs.CR[6].eq ) { return 0x822610CC;  }
		/* 822610B0h case    3:*/		return 0x822610B4;
		  /* 822610B4h */ case    4:  		/* mr R6, R27 */
		/* 822610B4h case    4:*/		regs.R6 = regs.R27;
		/* 822610B4h case    4:*/		return 0x822610B8;
		  /* 822610B8h */ case    5:  		/* lwz R5, <#[R1 + 380]> */
		/* 822610B8h case    5:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x0000017C) );
		/* 822610B8h case    5:*/		return 0x822610BC;
		  /* 822610BCh */ case    6:  		/* mr R4, R28 */
		/* 822610BCh case    6:*/		regs.R4 = regs.R28;
		/* 822610BCh case    6:*/		return 0x822610C0;
		  /* 822610C0h */ case    7:  		/* li R7, 3788 */
		/* 822610C0h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0xECC);
		/* 822610C0h case    7:*/		return 0x822610C4;
		  /* 822610C4h */ case    8:  		/* li R3, 0 */
		/* 822610C4h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822610C4h case    8:*/		return 0x822610C8;
		  /* 822610C8h */ case    9:  		/* bl -1086656 */
		/* 822610C8h case    9:*/		regs.LR = 0x822610CC; return 0x82157C08;
		/* 822610C8h case    9:*/		return 0x822610CC;
	}
	return 0x822610CC;
} // Block from 822610A4h-822610CCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 822610CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822610CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822610CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822610CC);
		  /* 822610CCh */ case    0:  		/* mr R3, R31 */
		/* 822610CCh case    0:*/		regs.R3 = regs.R31;
		/* 822610CCh case    0:*/		return 0x822610D0;
		  /* 822610D0h */ case    1:  		/* lwz R4, <#[R1 + 204]> */
		/* 822610D0h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x000000CC) );
		/* 822610D0h case    1:*/		return 0x822610D4;
		  /* 822610D4h */ case    2:  		/* bl -28500 */
		/* 822610D4h case    2:*/		regs.LR = 0x822610D8; return 0x8225A180;
		/* 822610D4h case    2:*/		return 0x822610D8;
		  /* 822610D8h */ case    3:  		/* lwz R11, <#[R3]> */
		/* 822610D8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822610D8h case    3:*/		return 0x822610DC;
		  /* 822610DCh */ case    4:  		/* li R4, 1 */
		/* 822610DCh case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 822610DCh case    4:*/		return 0x822610E0;
		  /* 822610E0h */ case    5:  		/* mr R30, R3 */
		/* 822610E0h case    5:*/		regs.R30 = regs.R3;
		/* 822610E0h case    5:*/		return 0x822610E4;
		  /* 822610E4h */ case    6:  		/* lwz R11, <#[R11 + 104]> */
		/* 822610E4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000068) );
		/* 822610E4h case    6:*/		return 0x822610E8;
		  /* 822610E8h */ case    7:  		/* mtspr CTR, R11 */
		/* 822610E8h case    7:*/		regs.CTR = regs.R11;
		/* 822610E8h case    7:*/		return 0x822610EC;
		  /* 822610ECh */ case    8:  		/* bcctrl 20, CR0_LT */
		/* 822610ECh case    8:*/		if ( 1 ) { regs.LR = 0x822610F0; return (uint32)regs.CTR; }
		/* 822610ECh case    8:*/		return 0x822610F0;
		  /* 822610F0h */ case    9:  		/* lwz R29, <#[R1 + 180]> */
		/* 822610F0h case    9:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x000000B4) );
		/* 822610F0h case    9:*/		return 0x822610F4;
		  /* 822610F4h */ case   10:  		/* mr R3, R31 */
		/* 822610F4h case   10:*/		regs.R3 = regs.R31;
		/* 822610F4h case   10:*/		return 0x822610F8;
		  /* 822610F8h */ case   11:  		/* lwz R11, <#[R29]> */
		/* 822610F8h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 822610F8h case   11:*/		return 0x822610FC;
		  /* 822610FCh */ case   12:  		/* lwz R26, <#[R31 + 12]> */
		/* 822610FCh case   12:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R31 + 0x0000000C) );
		/* 822610FCh case   12:*/		return 0x82261100;
		  /* 82261100h */ case   13:  		/* lwz R11, <#[R11]> */
		/* 82261100h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82261100h case   13:*/		return 0x82261104;
		  /* 82261104h */ case   14:  		/* extsh R24, R11 */
		/* 82261104h case   14:*/		cpu::op::extsh<0>(regs,&regs.R24,regs.R11);
		/* 82261104h case   14:*/		return 0x82261108;
		  /* 82261108h */ case   15:  		/* lwz R25, <#[R26 + 1536]> */
		/* 82261108h case   15:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R26 + 0x00000600) );
		/* 82261108h case   15:*/		return 0x8226110C;
		  /* 8226110Ch */ case   16:  		/* bl -177236 */
		/* 8226110Ch case   16:*/		regs.LR = 0x82261110; return 0x82235CB8;
		/* 8226110Ch case   16:*/		return 0x82261110;
		  /* 82261110h */ case   17:  		/* rlwinm R11, R3, 0, 24, 31 */
		/* 82261110h case   17:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82261110h case   17:*/		return 0x82261114;
		  /* 82261114h */ case   18:  		/* lis R10, -32222 */
		/* 82261114h case   18:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8222);
		/* 82261114h case   18:*/		return 0x82261118;
		  /* 82261118h */ case   19:  		/* cntlzw R11, R11 */
		/* 82261118h case   19:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 82261118h case   19:*/		return 0x8226111C;
		  /* 8226111Ch */ case   20:  		/* mr R3, R25 */
		/* 8226111Ch case   20:*/		regs.R3 = regs.R25;
		/* 8226111Ch case   20:*/		return 0x82261120;
		  /* 82261120h */ case   21:  		/* rlwinm R4, R11, 27, 31, 31 */
		/* 82261120h case   21:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R4,regs.R11);
		/* 82261120h case   21:*/		return 0x82261124;
		  /* 82261124h */ case   22:  		/* mr R5, R24 */
		/* 82261124h case   22:*/		regs.R5 = regs.R24;
		/* 82261124h case   22:*/		return 0x82261128;
		  /* 82261128h */ case   23:  		/* addi R6, R1, 388 */
		/* 82261128h case   23:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x184);
		/* 82261128h case   23:*/		return 0x8226112C;
		  /* 8226112Ch */ case   24:  		/* addi R7, R10, -12392 */
		/* 8226112Ch case   24:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0xFFFFCF98);
		/* 8226112Ch case   24:*/		return 0x82261130;
		  /* 82261130h */ case   25:  		/* mr R8, R26 */
		/* 82261130h case   25:*/		regs.R8 = regs.R26;
		/* 82261130h case   25:*/		return 0x82261134;
		  /* 82261134h */ case   26:  		/* bl -190820 */
		/* 82261134h case   26:*/		regs.LR = 0x82261138; return 0x822327D0;
		/* 82261134h case   26:*/		return 0x82261138;
		  /* 82261138h */ case   27:  		/* cmpwi CR6, R3, 1 */
		/* 82261138h case   27:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 82261138h case   27:*/		return 0x8226113C;
		  /* 8226113Ch */ case   28:  		/* bc 12, CR6_EQ, 28 */
		/* 8226113Ch case   28:*/		if ( regs.CR[6].eq ) { return 0x82261158;  }
		/* 8226113Ch case   28:*/		return 0x82261140;
		  /* 82261140h */ case   29:  		/* mr R6, R27 */
		/* 82261140h case   29:*/		regs.R6 = regs.R27;
		/* 82261140h case   29:*/		return 0x82261144;
		  /* 82261144h */ case   30:  		/* lwz R5, <#[R1 + 300]> */
		/* 82261144h case   30:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x0000012C) );
		/* 82261144h case   30:*/		return 0x82261148;
		  /* 82261148h */ case   31:  		/* mr R4, R28 */
		/* 82261148h case   31:*/		regs.R4 = regs.R28;
		/* 82261148h case   31:*/		return 0x8226114C;
		  /* 8226114Ch */ case   32:  		/* li R7, 3805 */
		/* 8226114Ch case   32:*/		cpu::op::li<0>(regs,&regs.R7,0xEDD);
		/* 8226114Ch case   32:*/		return 0x82261150;
		  /* 82261150h */ case   33:  		/* li R3, 0 */
		/* 82261150h case   33:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82261150h case   33:*/		return 0x82261154;
		  /* 82261154h */ case   34:  		/* bl -1086796 */
		/* 82261154h case   34:*/		regs.LR = 0x82261158; return 0x82157C08;
		/* 82261154h case   34:*/		return 0x82261158;
	}
	return 0x82261158;
} // Block from 822610CCh-82261158h (35 instructions)

//////////////////////////////////////////////////////
// Block at 82261158h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261158( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261158) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261158);
		  /* 82261158h */ case    0:  		/* lwz R10, <#[R29]> */
		/* 82261158h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 82261158h case    0:*/		return 0x8226115C;
		  /* 8226115Ch */ case    1:  		/* mr R4, R30 */
		/* 8226115Ch case    1:*/		regs.R4 = regs.R30;
		/* 8226115Ch case    1:*/		return 0x82261160;
		  /* 82261160h */ case    2:  		/* lwz R11, <#[R31 + 92]> */
		/* 82261160h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 82261160h case    2:*/		return 0x82261164;
		  /* 82261164h */ case    3:  		/* mr R3, R31 */
		/* 82261164h case    3:*/		regs.R3 = regs.R31;
		/* 82261164h case    3:*/		return 0x82261168;
		  /* 82261168h */ case    4:  		/* lwz R9, <#[R1 + 388]> */
		/* 82261168h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000184) );
		/* 82261168h case    4:*/		return 0x8226116C;
		  /* 8226116Ch */ case    5:  		/* lhz R10, <#[R10]> */
		/* 8226116Ch case    5:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 8226116Ch case    5:*/		return 0x82261170;
		  /* 82261170h */ case    6:  		/* rlwinm R10, R10, 3, 23, 28 */
		/* 82261170h case    6:*/		cpu::op::rlwinm<0,3,23,28>(regs,&regs.R10,regs.R10);
		/* 82261170h case    6:*/		return 0x82261174;
		  /* 82261174h */ case    7:  		/* add R11, R10, R11 */
		/* 82261174h case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82261174h case    7:*/		return 0x82261178;
		  /* 82261178h */ case    8:  		/* lwz R11, <#[R11 + 4]> */
		/* 82261178h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82261178h case    8:*/		return 0x8226117C;
		  /* 8226117Ch */ case    9:  		/* stw R9, <#[R30 + 60]> */
		/* 8226117Ch case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R30 + 0x0000003C) );
		/* 8226117Ch case    9:*/		return 0x82261180;
		  /* 82261180h */ case   10:  		/* stw R11, <#[R30 + 84]> */
		/* 82261180h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000054) );
		/* 82261180h case   10:*/		return 0x82261184;
		  /* 82261184h */ case   11:  		/* bl -175068 */
		/* 82261184h case   11:*/		regs.LR = 0x82261188; return 0x822365A8;
		/* 82261184h case   11:*/		return 0x82261188;
		  /* 82261188h */ case   12:  		/* stw R30, <#[R14 + 120]> */
		/* 82261188h case   12:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R14 + 0x00000078) );
		/* 82261188h case   12:*/		return 0x8226118C;
		  /* 8226118Ch */ case   13:  		/* mr R4, R30 */
		/* 8226118Ch case   13:*/		regs.R4 = regs.R30;
		/* 8226118Ch case   13:*/		return 0x82261190;
		  /* 82261190h */ case   14:  		/* mr R3, R14 */
		/* 82261190h case   14:*/		regs.R3 = regs.R14;
		/* 82261190h case   14:*/		return 0x82261194;
		  /* 82261194h */ case   15:  		/* bl -33380 */
		/* 82261194h case   15:*/		regs.LR = 0x82261198; return 0x82258F30;
		/* 82261194h case   15:*/		return 0x82261198;
		  /* 82261198h */ case   16:  		/* mr R3, R30 */
		/* 82261198h case   16:*/		regs.R3 = regs.R30;
		/* 82261198h case   16:*/		return 0x8226119C;
		  /* 8226119Ch */ case   17:  		/* bl -45532 */
		/* 8226119Ch case   17:*/		regs.LR = 0x822611A0; return 0x82255FC0;
		/* 8226119Ch case   17:*/		return 0x822611A0;
		  /* 822611A0h */ case   18:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822611A0h case   18:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822611A0h case   18:*/		return 0x822611A4;
		  /* 822611A4h */ case   19:  		/* bc 4, CR0_EQ, 28 */
		/* 822611A4h case   19:*/		if ( !regs.CR[0].eq ) { return 0x822611C0;  }
		/* 822611A4h case   19:*/		return 0x822611A8;
		  /* 822611A8h */ case   20:  		/* mr R6, R27 */
		/* 822611A8h case   20:*/		regs.R6 = regs.R27;
		/* 822611A8h case   20:*/		return 0x822611AC;
		  /* 822611ACh */ case   21:  		/* lwz R5, <#[R1 + 184]> */
		/* 822611ACh case   21:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000000B8) );
		/* 822611ACh case   21:*/		return 0x822611B0;
		  /* 822611B0h */ case   22:  		/* mr R4, R28 */
		/* 822611B0h case   22:*/		regs.R4 = regs.R28;
		/* 822611B0h case   22:*/		return 0x822611B4;
		  /* 822611B4h */ case   23:  		/* li R7, 3812 */
		/* 822611B4h case   23:*/		cpu::op::li<0>(regs,&regs.R7,0xEE4);
		/* 822611B4h case   23:*/		return 0x822611B8;
		  /* 822611B8h */ case   24:  		/* li R3, 0 */
		/* 822611B8h case   24:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822611B8h case   24:*/		return 0x822611BC;
		  /* 822611BCh */ case   25:  		/* bl -1086900 */
		/* 822611BCh case   25:*/		regs.LR = 0x822611C0; return 0x82157C08;
		/* 822611BCh case   25:*/		return 0x822611C0;
	}
	return 0x822611C0;
} // Block from 82261158h-822611C0h (26 instructions)

//////////////////////////////////////////////////////
// Block at 822611C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822611C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822611C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822611C0);
		  /* 822611C0h */ case    0:  		/* mr R4, R30 */
		/* 822611C0h case    0:*/		regs.R4 = regs.R30;
		/* 822611C0h case    0:*/		return 0x822611C4;
		  /* 822611C4h */ case    1:  		/* mr R3, R31 */
		/* 822611C4h case    1:*/		regs.R3 = regs.R31;
		/* 822611C4h case    1:*/		return 0x822611C8;
		  /* 822611C8h */ case    2:  		/* bl -176592 */
		/* 822611C8h case    2:*/		regs.LR = 0x822611CC; return 0x82235FF8;
		/* 822611C8h case    2:*/		return 0x822611CC;
		  /* 822611CCh */ case    3:  		/* lwz R10, <#[R1 + 940]> */
		/* 822611CCh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000003AC) );
		/* 822611CCh case    3:*/		return 0x822611D0;
		  /* 822611D0h */ case    4:  		/* li R14, 0 */
		/* 822611D0h case    4:*/		cpu::op::li<0>(regs,&regs.R14,0x0);
		/* 822611D0h case    4:*/		return 0x822611D4;
		  /* 822611D4h */ case    5:  		/* addi R3, R1, 592 */
		/* 822611D4h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x250);
		/* 822611D4h case    5:*/		return 0x822611D8;
		  /* 822611D8h */ case    6:  		/* lwz R11, <#[R10 + 20]> */
		/* 822611D8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000014) );
		/* 822611D8h case    6:*/		return 0x822611DC;
		  /* 822611DCh */ case    7:  		/* addi R9, R11, 4 */
		/* 822611DCh case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 822611DCh case    7:*/		return 0x822611E0;
		  /* 822611E0h */ case    8:  		/* stw R9, <#[R10 + 20]> */
		/* 822611E0h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000014) );
		/* 822611E0h case    8:*/		return 0x822611E4;
		  /* 822611E4h */ case    9:  		/* lwz R11, <#[R11]> */
		/* 822611E4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 822611E4h case    9:*/		return 0x822611E8;
		  /* 822611E8h */ case   10:  		/* stw R14, <#[R1 + 596]> */
		/* 822611E8h case   10:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R1 + 0x00000254) );
		/* 822611E8h case   10:*/		return 0x822611EC;
		  /* 822611ECh */ case   11:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 822611ECh case   11:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 822611ECh case   11:*/		return 0x822611F0;
		  /* 822611F0h */ case   12:  		/* stw R14, <#[R1 + 600]> */
		/* 822611F0h case   12:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R1 + 0x00000258) );
		/* 822611F0h case   12:*/		return 0x822611F4;
		  /* 822611F4h */ case   13:  		/* lwz R4, <#[R31 + 12]> */
		/* 822611F4h case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 822611F4h case   13:*/		return 0x822611F8;
		  /* 822611F8h */ case   14:  		/* stw R11, <#[R1 + 592]> */
		/* 822611F8h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000250) );
		/* 822611F8h case   14:*/		return 0x822611FC;
		  /* 822611FCh */ case   15:  		/* bl -25676 */
		/* 822611FCh case   15:*/		regs.LR = 0x82261200; return 0x8225ADB0;
		/* 822611FCh case   15:*/		return 0x82261200;
		  /* 82261200h */ case   16:  		/* bl -27344 */
		/* 82261200h case   16:*/		regs.LR = 0x82261204; return 0x8225A730;
		/* 82261200h case   16:*/		return 0x82261204;
		  /* 82261204h */ case   17:  		/* lwz R11, <#[R31 + 12]> */
		/* 82261204h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82261204h case   17:*/		return 0x82261208;
		  /* 82261208h */ case   18:  		/* li R3, 136 */
		/* 82261208h case   18:*/		cpu::op::li<0>(regs,&regs.R3,0x88);
		/* 82261208h case   18:*/		return 0x8226120C;
		  /* 8226120Ch */ case   19:  		/* lwz R4, <#[R11 + 1452]> */
		/* 8226120Ch case   19:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005AC) );
		/* 8226120Ch case   19:*/		return 0x82261210;
		  /* 82261210h */ case   20:  		/* bl -27424 */
		/* 82261210h case   20:*/		regs.LR = 0x82261214; return 0x8225A6F0;
		/* 82261210h case   20:*/		return 0x82261214;
		  /* 82261214h */ case   21:  		/* cmplwi CR0, R3, 0 */
		/* 82261214h case   21:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82261214h case   21:*/		return 0x82261218;
		  /* 82261218h */ case   22:  		/* bc 12, CR0_EQ, 16 */
		/* 82261218h case   22:*/		if ( regs.CR[0].eq ) { return 0x82261228;  }
		/* 82261218h case   22:*/		return 0x8226121C;
		  /* 8226121Ch */ case   23:  		/* lwz R4, <#[R31 + 12]> */
		/* 8226121Ch case   23:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 8226121Ch case   23:*/		return 0x82261220;
		  /* 82261220h */ case   24:  		/* bl -32976 */
		/* 82261220h case   24:*/		regs.LR = 0x82261224; return 0x82259150;
		/* 82261220h case   24:*/		return 0x82261224;
		  /* 82261224h */ case   25:  		/* mr R14, R3 */
		/* 82261224h case   25:*/		regs.R14 = regs.R3;
		/* 82261224h case   25:*/		return 0x82261228;
	}
	return 0x82261228;
} // Block from 822611C0h-82261228h (26 instructions)

//////////////////////////////////////////////////////
// Block at 82261228h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261228( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261228) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261228);
		  /* 82261228h */ case    0:  		/* lwz R11, <#[R1 + 188]> */
		/* 82261228h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000BC) );
		/* 82261228h case    0:*/		return 0x8226122C;
		  /* 8226122Ch */ case    1:  		/* lwz R30, <#[R1 + 160]> */
		/* 8226122Ch case    1:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x000000A0) );
		/* 8226122Ch case    1:*/		return 0x82261230;
		  /* 82261230h */ case    2:  		/* stw R11, <#[R14 + 52]> */
		/* 82261230h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R14 + 0x00000034) );
		/* 82261230h case    2:*/		return 0x82261234;
		  /* 82261234h */ case    3:  		/* b -900 */
		/* 82261234h case    3:*/		return 0x82260EB0;
		/* 82261234h case    3:*/		return 0x82261238;
		  /* 82261238h */ case    4:  		/* lwz R11, <#[R31 + 12]> */
		/* 82261238h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82261238h case    4:*/		return 0x8226123C;
		  /* 8226123Ch */ case    5:  		/* li R3, 136 */
		/* 8226123Ch case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x88);
		/* 8226123Ch case    5:*/		return 0x82261240;
		  /* 82261240h */ case    6:  		/* lwz R4, <#[R11 + 1452]> */
		/* 82261240h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005AC) );
		/* 82261240h case    6:*/		return 0x82261244;
		  /* 82261244h */ case    7:  		/* bl -27476 */
		/* 82261244h case    7:*/		regs.LR = 0x82261248; return 0x8225A6F0;
		/* 82261244h case    7:*/		return 0x82261248;
		  /* 82261248h */ case    8:  		/* cmplwi CR0, R3, 0 */
		/* 82261248h case    8:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82261248h case    8:*/		return 0x8226124C;
		  /* 8226124Ch */ case    9:  		/* bc 12, CR0_EQ, 20 */
		/* 8226124Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x82261260;  }
		/* 8226124Ch case    9:*/		return 0x82261250;
		  /* 82261250h */ case   10:  		/* lwz R4, <#[R31 + 12]> */
		/* 82261250h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 82261250h case   10:*/		return 0x82261254;
		  /* 82261254h */ case   11:  		/* bl -33028 */
		/* 82261254h case   11:*/		regs.LR = 0x82261258; return 0x82259150;
		/* 82261254h case   11:*/		return 0x82261258;
		  /* 82261258h */ case   12:  		/* mr R14, R3 */
		/* 82261258h case   12:*/		regs.R14 = regs.R3;
		/* 82261258h case   12:*/		return 0x8226125C;
		  /* 8226125Ch */ case   13:  		/* b 8 */
		/* 8226125Ch case   13:*/		return 0x82261264;
		/* 8226125Ch case   13:*/		return 0x82261260;
	}
	return 0x82261260;
} // Block from 82261228h-82261260h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82261260h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261260( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261260) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261260);
		  /* 82261260h */ case    0:  		/* li R14, 0 */
		/* 82261260h case    0:*/		cpu::op::li<0>(regs,&regs.R14,0x0);
		/* 82261260h case    0:*/		return 0x82261264;
	}
	return 0x82261264;
} // Block from 82261260h-82261264h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82261264h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261264( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261264) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261264);
		  /* 82261264h */ case    0:  		/* lwz R30, <#[R1 + 160]> */
		/* 82261264h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x000000A0) );
		/* 82261264h case    0:*/		return 0x82261268;
		  /* 82261268h */ case    1:  		/* mr R5, R14 */
		/* 82261268h case    1:*/		regs.R5 = regs.R14;
		/* 82261268h case    1:*/		return 0x8226126C;
		  /* 8226126Ch */ case    2:  		/* mr R3, R31 */
		/* 8226126Ch case    2:*/		regs.R3 = regs.R31;
		/* 8226126Ch case    2:*/		return 0x82261270;
		  /* 82261270h */ case    3:  		/* mr R4, R30 */
		/* 82261270h case    3:*/		regs.R4 = regs.R30;
		/* 82261270h case    3:*/		return 0x82261274;
		  /* 82261274h */ case    4:  		/* bl -177692 */
		/* 82261274h case    4:*/		regs.LR = 0x82261278; return 0x82235C58;
		/* 82261274h case    4:*/		return 0x82261278;
		  /* 82261278h */ case    5:  		/* mr R4, R14 */
		/* 82261278h case    5:*/		regs.R4 = regs.R14;
		/* 82261278h case    5:*/		return 0x8226127C;
		  /* 8226127Ch */ case    6:  		/* mr R3, R30 */
		/* 8226127Ch case    6:*/		regs.R3 = regs.R30;
		/* 8226127Ch case    6:*/		return 0x82261280;
		  /* 82261280h */ case    7:  		/* bl -31152 */
		/* 82261280h case    7:*/		regs.LR = 0x82261284; return 0x822598D0;
		/* 82261280h case    7:*/		return 0x82261284;
		  /* 82261284h */ case    8:  		/* lwz R10, <#[R1 + 940]> */
		/* 82261284h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x000003AC) );
		/* 82261284h case    8:*/		return 0x82261288;
		  /* 82261288h */ case    9:  		/* addi R3, R1, 608 */
		/* 82261288h case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x260);
		/* 82261288h case    9:*/		return 0x8226128C;
		  /* 8226128Ch */ case   10:  		/* lwz R11, <#[R10 + 20]> */
		/* 8226128Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000014) );
		/* 8226128Ch case   10:*/		return 0x82261290;
		  /* 82261290h */ case   11:  		/* addi R9, R11, 4 */
		/* 82261290h case   11:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 82261290h case   11:*/		return 0x82261294;
		  /* 82261294h */ case   12:  		/* stw R9, <#[R10 + 20]> */
		/* 82261294h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000014) );
		/* 82261294h case   12:*/		return 0x82261298;
		  /* 82261298h */ case   13:  		/* lwz R4, <#[R31 + 12]> */
		/* 82261298h case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 82261298h case   13:*/		return 0x8226129C;
		  /* 8226129Ch */ case   14:  		/* lwz R10, <#[R11]> */
		/* 8226129Ch case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8226129Ch case   14:*/		return 0x822612A0;
		  /* 822612A0h */ case   15:  		/* li R11, 0 */
		/* 822612A0h case   15:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822612A0h case   15:*/		return 0x822612A4;
		  /* 822612A4h */ case   16:  		/* rlwinm R10, R10, 0, 16, 31 */
		/* 822612A4h case   16:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R10,regs.R10);
		/* 822612A4h case   16:*/		return 0x822612A8;
		  /* 822612A8h */ case   17:  		/* stw R11, <#[R1 + 612]> */
		/* 822612A8h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000264) );
		/* 822612A8h case   17:*/		return 0x822612AC;
		  /* 822612ACh */ case   18:  		/* stw R11, <#[R1 + 616]> */
		/* 822612ACh case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000268) );
		/* 822612ACh case   18:*/		return 0x822612B0;
		  /* 822612B0h */ case   19:  		/* stw R10, <#[R1 + 608]> */
		/* 822612B0h case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000260) );
		/* 822612B0h case   19:*/		return 0x822612B4;
		  /* 822612B4h */ case   20:  		/* bl -25860 */
		/* 822612B4h case   20:*/		regs.LR = 0x822612B8; return 0x8225ADB0;
		/* 822612B4h case   20:*/		return 0x822612B8;
		  /* 822612B8h */ case   21:  		/* stw R14, <#[R3]> */
		/* 822612B8h case   21:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R3 + 0x00000000) );
		/* 822612B8h case   21:*/		return 0x822612BC;
		  /* 822612BCh */ case   22:  		/* bl -27532 */
		/* 822612BCh case   22:*/		regs.LR = 0x822612C0; return 0x8225A730;
		/* 822612BCh case   22:*/		return 0x822612C0;
		  /* 822612C0h */ case   23:  		/* b -1012 */
		/* 822612C0h case   23:*/		return 0x82260ECC;
		/* 822612C0h case   23:*/		return 0x822612C4;
		  /* 822612C4h */ case   24:  		/* lwz R22, <#[R1 + 220]> */
		/* 822612C4h case   24:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R1 + 0x000000DC) );
		/* 822612C4h case   24:*/		return 0x822612C8;
		  /* 822612C8h */ case   25:  		/* li R23, 0 */
		/* 822612C8h case   25:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 822612C8h case   25:*/		return 0x822612CC;
		  /* 822612CCh */ case   26:  		/* mr R29, R23 */
		/* 822612CCh case   26:*/		regs.R29 = regs.R23;
		/* 822612CCh case   26:*/		return 0x822612D0;
		  /* 822612D0h */ case   27:  		/* mr R25, R23 */
		/* 822612D0h case   27:*/		regs.R25 = regs.R23;
		/* 822612D0h case   27:*/		return 0x822612D4;
		  /* 822612D4h */ case   28:  		/* lwz R11, <#[R22 + 4]> */
		/* 822612D4h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000004) );
		/* 822612D4h case   28:*/		return 0x822612D8;
		  /* 822612D8h */ case   29:  		/* cmplwi CR6, R11, 0 */
		/* 822612D8h case   29:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822612D8h case   29:*/		return 0x822612DC;
		  /* 822612DCh */ case   30:  		/* bc 12, CR6_EQ, 48 */
		/* 822612DCh case   30:*/		if ( regs.CR[6].eq ) { return 0x8226130C;  }
		/* 822612DCh case   30:*/		return 0x822612E0;
		  /* 822612E0h */ case   31:  		/* rlwinm R10, R11, 0, 0, 31 */
		/* 822612E0h case   31:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R11);
		/* 822612E0h case   31:*/		return 0x822612E4;
		  /* 822612E4h */ case   32:  		/* addi R11, R10, -1 */
		/* 822612E4h case   32:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0xFFFFFFFF);
		/* 822612E4h case   32:*/		return 0x822612E8;
		  /* 822612E8h */ case   33:  		/* cmplw CR6, R11, R10 */
		/* 822612E8h case   33:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 822612E8h case   33:*/		return 0x822612EC;
		  /* 822612ECh */ case   34:  		/* bc 4, CR6_LT, 20 */
		/* 822612ECh case   34:*/		if ( !regs.CR[6].lt ) { return 0x82261300;  }
		/* 822612ECh case   34:*/		return 0x822612F0;
		  /* 822612F0h */ case   35:  		/* lwz R10, <#[R22 + 8]> */
		/* 822612F0h case   35:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R22 + 0x00000008) );
		/* 822612F0h case   35:*/		return 0x822612F4;
		  /* 822612F4h */ case   36:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 822612F4h case   36:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 822612F4h case   36:*/		return 0x822612F8;
		  /* 822612F8h */ case   37:  		/* add R11, R11, R10 */
		/* 822612F8h case   37:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 822612F8h case   37:*/		return 0x822612FC;
		  /* 822612FCh */ case   38:  		/* b 8 */
		/* 822612FCh case   38:*/		return 0x82261304;
		/* 822612FCh case   38:*/		return 0x82261300;
	}
	return 0x82261300;
} // Block from 82261264h-82261300h (39 instructions)

//////////////////////////////////////////////////////
// Block at 82261300h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261300( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261300) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261300);
		  /* 82261300h */ case    0:  		/* mr R11, R23 */
		/* 82261300h case    0:*/		regs.R11 = regs.R23;
		/* 82261300h case    0:*/		return 0x82261304;
	}
	return 0x82261304;
} // Block from 82261300h-82261304h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82261304h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261304( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261304) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261304);
		  /* 82261304h */ case    0:  		/* lwz R25, <#[R11]> */
		/* 82261304h case    0:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R11 + 0x00000000) );
		/* 82261304h case    0:*/		return 0x82261308;
		  /* 82261308h */ case    1:  		/* stb R23, <#[R25 + 140]> */
		/* 82261308h case    1:*/		cpu::mem::store8( regs, regs.R23, (uint32)(regs.R25 + 0x0000008C) );
		/* 82261308h case    1:*/		return 0x8226130C;
	}
	return 0x8226130C;
} // Block from 82261304h-8226130Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226130Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226130C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226130C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226130C);
		  /* 8226130Ch */ case    0:  		/* lwz R11, <#[R1 + 140]> */
		/* 8226130Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000008C) );
		/* 8226130Ch case    0:*/		return 0x82261310;
		  /* 82261310h */ case    1:  		/* lwz R10, <#[R1 + 144]> */
		/* 82261310h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000090) );
		/* 82261310h case    1:*/		return 0x82261314;
		  /* 82261314h */ case    2:  		/* addi R11, R11, 1 */
		/* 82261314h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82261314h case    2:*/		return 0x82261318;
		  /* 82261318h */ case    3:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 82261318h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 82261318h case    3:*/		return 0x8226131C;
		  /* 8226131Ch */ case    4:  		/* stw R11, <#[R1 + 140]> */
		/* 8226131Ch case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000008C) );
		/* 8226131Ch case    4:*/		return 0x82261320;
		  /* 82261320h */ case    5:  		/* lwzx R11, <#[R9 + R10]> */
		/* 82261320h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82261320h case    5:*/		return 0x82261324;
		  /* 82261324h */ case    6:  		/* cmplwi CR6, R11, 90 */
		/* 82261324h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005A);
		/* 82261324h case    6:*/		return 0x82261328;
		  /* 82261328h */ case    7:  		/* bc 12, CR6_EQ, 680 */
		/* 82261328h case    7:*/		if ( regs.CR[6].eq ) { return 0x822615D0;  }
		/* 82261328h case    7:*/		return 0x8226132C;
		  /* 8226132Ch */ case    8:  		/* cmplwi CR6, R11, 91 */
		/* 8226132Ch case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005B);
		/* 8226132Ch case    8:*/		return 0x82261330;
		  /* 82261330h */ case    9:  		/* bc 12, CR6_EQ, 428 */
		/* 82261330h case    9:*/		if ( regs.CR[6].eq ) { return 0x822614DC;  }
		/* 82261330h case    9:*/		return 0x82261334;
		  /* 82261334h */ case   10:  		/* cmplwi CR6, R11, 92 */
		/* 82261334h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005C);
		/* 82261334h case   10:*/		return 0x82261338;
		  /* 82261338h */ case   11:  		/* bc 4, CR6_EQ, 808 */
		/* 82261338h case   11:*/		if ( !regs.CR[6].eq ) { return 0x82261660;  }
		/* 82261338h case   11:*/		return 0x8226133C;
		  /* 8226133Ch */ case   12:  		/* lwz R24, <#[R1 + 180]> */
		/* 8226133Ch case   12:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R1 + 0x000000B4) );
		/* 8226133Ch case   12:*/		return 0x82261340;
		  /* 82261340h */ case   13:  		/* mr R30, R23 */
		/* 82261340h case   13:*/		regs.R30 = regs.R23;
		/* 82261340h case   13:*/		return 0x82261344;
		  /* 82261344h */ case   14:  		/* lwz R11, <#[R1 + 176]> */
		/* 82261344h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B0) );
		/* 82261344h case   14:*/		return 0x82261348;
		  /* 82261348h */ case   15:  		/* lwz R10, <#[R24]> */
		/* 82261348h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R24 + 0x00000000) );
		/* 82261348h case   15:*/		return 0x8226134C;
		  /* 8226134Ch */ case   16:  		/* lwz R9, <#[R24 + 4]> */
		/* 8226134Ch case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R24 + 0x00000004) );
		/* 8226134Ch case   16:*/		return 0x82261350;
		  /* 82261350h */ case   17:  		/* lhz R11, <#[R11]> */
		/* 82261350h case   17:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82261350h case   17:*/		return 0x82261354;
		  /* 82261354h */ case   18:  		/* rlwinm R11, R11, 0, 29, 31 */
		/* 82261354h case   18:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R11,regs.R11);
		/* 82261354h case   18:*/		return 0x82261358;
		  /* 82261358h */ case   19:  		/* lwz R10, <#[R10]> */
		/* 82261358h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 82261358h case   19:*/		return 0x8226135C;
		  /* 8226135Ch */ case   20:  		/* lwz R9, <#[R9]> */
		/* 8226135Ch case   20:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000000) );
		/* 8226135Ch case   20:*/		return 0x82261360;
		  /* 82261360h */ case   21:  		/* cmplwi CR6, R11, 1 */
		/* 82261360h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82261360h case   21:*/		return 0x82261364;
		  /* 82261364h */ case   22:  		/* rlwinm R29, R10, 16, 26, 31 */
		/* 82261364h case   22:*/		cpu::op::rlwinm<0,16,26,31>(regs,&regs.R29,regs.R10);
		/* 82261364h case   22:*/		return 0x82261368;
		  /* 82261368h */ case   23:  		/* extsh R28, R10 */
		/* 82261368h case   23:*/		cpu::op::extsh<0>(regs,&regs.R28,regs.R10);
		/* 82261368h case   23:*/		return 0x8226136C;
		  /* 8226136Ch */ case   24:  		/* rlwinm R27, R9, 16, 26, 31 */
		/* 8226136Ch case   24:*/		cpu::op::rlwinm<0,16,26,31>(regs,&regs.R27,regs.R9);
		/* 8226136Ch case   24:*/		return 0x82261370;
		  /* 82261370h */ case   25:  		/* extsh R26, R9 */
		/* 82261370h case   25:*/		cpu::op::extsh<0>(regs,&regs.R26,regs.R9);
		/* 82261370h case   25:*/		return 0x82261374;
		  /* 82261374h */ case   26:  		/* bc 12, CR6_LT, 104 */
		/* 82261374h case   26:*/		if ( regs.CR[6].lt ) { return 0x822613DC;  }
		/* 82261374h case   26:*/		return 0x82261378;
		  /* 82261378h */ case   27:  		/* bc 12, CR6_EQ, 92 */
		/* 82261378h case   27:*/		if ( regs.CR[6].eq ) { return 0x822613D4;  }
		/* 82261378h case   27:*/		return 0x8226137C;
		  /* 8226137Ch */ case   28:  		/* cmplwi CR6, R11, 3 */
		/* 8226137Ch case   28:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 8226137Ch case   28:*/		return 0x82261380;
		  /* 82261380h */ case   29:  		/* bc 12, CR6_LT, 76 */
		/* 82261380h case   29:*/		if ( regs.CR[6].lt ) { return 0x822613CC;  }
		/* 82261380h case   29:*/		return 0x82261384;
		  /* 82261384h */ case   30:  		/* bc 12, CR6_EQ, 64 */
		/* 82261384h case   30:*/		if ( regs.CR[6].eq ) { return 0x822613C4;  }
		/* 82261384h case   30:*/		return 0x82261388;
		  /* 82261388h */ case   31:  		/* cmplwi CR6, R11, 5 */
		/* 82261388h case   31:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000005);
		/* 82261388h case   31:*/		return 0x8226138C;
		  /* 8226138Ch */ case   32:  		/* bc 12, CR6_LT, 48 */
		/* 8226138Ch case   32:*/		if ( regs.CR[6].lt ) { return 0x822613BC;  }
		/* 8226138Ch case   32:*/		return 0x82261390;
		  /* 82261390h */ case   33:  		/* bc 12, CR6_EQ, 32 */
		/* 82261390h case   33:*/		if ( regs.CR[6].eq ) { return 0x822613B0;  }
		/* 82261390h case   33:*/		return 0x82261394;
		  /* 82261394h */ case   34:  		/* li R7, 3905 */
		/* 82261394h case   34:*/		cpu::op::li<0>(regs,&regs.R7,0xF41);
		/* 82261394h case   34:*/		return 0x82261398;
		  /* 82261398h */ case   35:  		/* lwz R6, <#[R1 + 128]> */
		/* 82261398h case   35:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 82261398h case   35:*/		return 0x8226139C;
		  /* 8226139Ch */ case   36:  		/* li R3, 0 */
		/* 8226139Ch case   36:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8226139Ch case   36:*/		return 0x822613A0;
		  /* 822613A0h */ case   37:  		/* lwz R5, <#[R1 + 196]> */
		/* 822613A0h case   37:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000000C4) );
		/* 822613A0h case   37:*/		return 0x822613A4;
		  /* 822613A4h */ case   38:  		/* lwz R4, <#[R1 + 132]> */
		/* 822613A4h case   38:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 822613A4h case   38:*/		return 0x822613A8;
		  /* 822613A8h */ case   39:  		/* bl -1087392 */
		/* 822613A8h case   39:*/		regs.LR = 0x822613AC; return 0x82157C08;
		/* 822613A8h case   39:*/		return 0x822613AC;
		  /* 822613ACh */ case   40:  		/* b 56 */
		/* 822613ACh case   40:*/		return 0x822613E4;
		/* 822613ACh case   40:*/		return 0x822613B0;
	}
	return 0x822613B0;
} // Block from 8226130Ch-822613B0h (41 instructions)

//////////////////////////////////////////////////////
// Block at 822613B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822613B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822613B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822613B0);
		  /* 822613B0h */ case    0:  		/* li R11, 40 */
		/* 822613B0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x28);
		/* 822613B0h case    0:*/		return 0x822613B4;
		  /* 822613B4h */ case    1:  		/* li R30, 1 */
		/* 822613B4h case    1:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 822613B4h case    1:*/		return 0x822613B8;
		  /* 822613B8h */ case    2:  		/* b 40 */
		/* 822613B8h case    2:*/		return 0x822613E0;
		/* 822613B8h case    2:*/		return 0x822613BC;
	}
	return 0x822613BC;
} // Block from 822613B0h-822613BCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 822613BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822613BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822613BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822613BC);
		  /* 822613BCh */ case    0:  		/* li R11, 41 */
		/* 822613BCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x29);
		/* 822613BCh case    0:*/		return 0x822613C0;
		  /* 822613C0h */ case    1:  		/* b -12 */
		/* 822613C0h case    1:*/		return 0x822613B4;
		/* 822613C0h case    1:*/		return 0x822613C4;
	}
	return 0x822613C4;
} // Block from 822613BCh-822613C4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822613C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822613C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822613C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822613C4);
		  /* 822613C4h */ case    0:  		/* li R11, 40 */
		/* 822613C4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x28);
		/* 822613C4h case    0:*/		return 0x822613C8;
		  /* 822613C8h */ case    1:  		/* b 24 */
		/* 822613C8h case    1:*/		return 0x822613E0;
		/* 822613C8h case    1:*/		return 0x822613CC;
	}
	return 0x822613CC;
} // Block from 822613C4h-822613CCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 822613CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822613CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822613CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822613CC);
		  /* 822613CCh */ case    0:  		/* li R11, 41 */
		/* 822613CCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x29);
		/* 822613CCh case    0:*/		return 0x822613D0;
		  /* 822613D0h */ case    1:  		/* b 16 */
		/* 822613D0h case    1:*/		return 0x822613E0;
		/* 822613D0h case    1:*/		return 0x822613D4;
	}
	return 0x822613D4;
} // Block from 822613CCh-822613D4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822613D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822613D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822613D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822613D4);
		  /* 822613D4h */ case    0:  		/* li R11, 39 */
		/* 822613D4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x27);
		/* 822613D4h case    0:*/		return 0x822613D8;
		  /* 822613D8h */ case    1:  		/* b 8 */
		/* 822613D8h case    1:*/		return 0x822613E0;
		/* 822613D8h case    1:*/		return 0x822613DC;
	}
	return 0x822613DC;
} // Block from 822613D4h-822613DCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 822613DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822613DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822613DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822613DC);
		  /* 822613DCh */ case    0:  		/* li R11, 42 */
		/* 822613DCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x2A);
		/* 822613DCh case    0:*/		return 0x822613E0;
	}
	return 0x822613E0;
} // Block from 822613DCh-822613E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822613E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822613E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822613E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822613E0);
		  /* 822613E0h */ case    0:  		/* stw R11, <#[R1 + 248]> */
		/* 822613E0h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x000000F8) );
		/* 822613E0h case    0:*/		return 0x822613E4;
	}
	return 0x822613E4;
} // Block from 822613E0h-822613E4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822613E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822613E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822613E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822613E4);
		  /* 822613E4h */ case    0:  		/* lwz R3, <#[R1 + 248]> */
		/* 822613E4h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x000000F8) );
		/* 822613E4h case    0:*/		return 0x822613E8;
		  /* 822613E8h */ case    1:  		/* lwz R4, <#[R31 + 12]> */
		/* 822613E8h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 822613E8h case    1:*/		return 0x822613EC;
		  /* 822613ECh */ case    2:  		/* bl -46268 */
		/* 822613ECh case    2:*/		regs.LR = 0x822613F0; return 0x82255F30;
		/* 822613ECh case    2:*/		return 0x822613F0;
		  /* 822613F0h */ case    3:  		/* rlwinm R8, R30, 0, 24, 31 */
		/* 822613F0h case    3:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R8,regs.R30);
		/* 822613F0h case    3:*/		return 0x822613F4;
		  /* 822613F4h */ case    4:  		/* lwz R10, <#[R31 + 92]> */
		/* 822613F4h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000005C) );
		/* 822613F4h case    4:*/		return 0x822613F8;
		  /* 822613F8h */ case    5:  		/* rlwinm R9, R29, 3, 0, 28 */
		/* 822613F8h case    5:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R9,regs.R29);
		/* 822613F8h case    5:*/		return 0x822613FC;
		  /* 822613FCh */ case    6:  		/* cntlzw R11, R8 */
		/* 822613FCh case    6:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R8);
		/* 822613FCh case    6:*/		return 0x82261400;
		  /* 82261400h */ case    7:  		/* add R10, R9, R10 */
		/* 82261400h case    7:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82261400h case    7:*/		return 0x82261404;
		  /* 82261404h */ case    8:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 82261404h case    8:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 82261404h case    8:*/		return 0x82261408;
		  /* 82261408h */ case    9:  		/* cntlzw R9, R8 */
		/* 82261408h case    9:*/		cpu::op::cntlzw<0>(regs,&regs.R9,regs.R8);
		/* 82261408h case    9:*/		return 0x8226140C;
		  /* 8226140Ch */ case   10:  		/* xori R11, R11, 1 */
		/* 8226140Ch case   10:*/		cpu::op::xori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8226140Ch case   10:*/		return 0x82261410;
		  /* 82261410h */ case   11:  		/* mr R21, R3 */
		/* 82261410h case   11:*/		regs.R21 = regs.R3;
		/* 82261410h case   11:*/		return 0x82261414;
		  /* 82261414h */ case   12:  		/* addi R6, R11, 1 */
		/* 82261414h case   12:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x1);
		/* 82261414h case   12:*/		return 0x82261418;
		  /* 82261418h */ case   13:  		/* lwz R8, <#[R10 + 4]> */
		/* 82261418h case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 82261418h case   13:*/		return 0x8226141C;
		  /* 8226141Ch */ case   14:  		/* rlwinm R11, R9, 27, 31, 31 */
		/* 8226141Ch case   14:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R9);
		/* 8226141Ch case   14:*/		return 0x82261420;
		  /* 82261420h */ case   15:  		/* addi R9, R6, 20 */
		/* 82261420h case   15:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R6,0x14);
		/* 82261420h case   15:*/		return 0x82261424;
		  /* 82261424h */ case   16:  		/* addi R10, R6, 14 */
		/* 82261424h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R6,0xE);
		/* 82261424h case   16:*/		return 0x82261428;
		  /* 82261428h */ case   17:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82261428h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82261428h case   17:*/		return 0x8226142C;
		  /* 8226142Ch */ case   18:  		/* addi R30, R11, 1 */
		/* 8226142Ch case   18:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0x1);
		/* 8226142Ch case   18:*/		return 0x82261430;
		  /* 82261430h */ case   19:  		/* rlwinm R7, R10, 2, 0, 29 */
		/* 82261430h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R7,regs.R10);
		/* 82261430h case   19:*/		return 0x82261434;
		  /* 82261434h */ case   20:  		/* addi R11, R30, 14 */
		/* 82261434h case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xE);
		/* 82261434h case   20:*/		return 0x82261438;
		  /* 82261438h */ case   21:  		/* rlwinm R10, R27, 3, 0, 28 */
		/* 82261438h case   21:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R27);
		/* 82261438h case   21:*/		return 0x8226143C;
		  /* 8226143Ch */ case   22:  		/* stwx R8, <#[R9 + R3]> */
		/* 8226143Ch case   22:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 8226143Ch case   22:*/		return 0x82261440;
		  /* 82261440h */ case   23:  		/* rlwinm R8, R11, 2, 0, 29 */
		/* 82261440h case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R11);
		/* 82261440h case   23:*/		return 0x82261444;
		  /* 82261444h */ case   24:  		/* addi R9, R30, 20 */
		/* 82261444h case   24:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R30,0x14);
		/* 82261444h case   24:*/		return 0x82261448;
		  /* 82261448h */ case   25:  		/* stwx R28, <#[R7 + R3]> */
		/* 82261448h case   25:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R7 + regs.R3 + 0x00000000) );
		/* 82261448h case   25:*/		return 0x8226144C;
		  /* 8226144Ch */ case   26:  		/* addi R4, R1, 152 */
		/* 8226144Ch case   26:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x98);
		/* 8226144Ch case   26:*/		return 0x82261450;
		  /* 82261450h */ case   27:  		/* lwz R11, <#[R31 + 92]> */
		/* 82261450h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 82261450h case   27:*/		return 0x82261454;
		  /* 82261454h */ case   28:  		/* add R11, R10, R11 */
		/* 82261454h case   28:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82261454h case   28:*/		return 0x82261458;
		  /* 82261458h */ case   29:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82261458h case   29:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82261458h case   29:*/		return 0x8226145C;
		  /* 8226145Ch */ case   30:  		/* lwz R11, <#[R11 + 4]> */
		/* 8226145Ch case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8226145Ch case   30:*/		return 0x82261460;
		  /* 82261460h */ case   31:  		/* stwx R26, <#[R8 + R21]> */
		/* 82261460h case   31:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R8 + regs.R21 + 0x00000000) );
		/* 82261460h case   31:*/		return 0x82261464;
		  /* 82261464h */ case   32:  		/* mr R3, R31 */
		/* 82261464h case   32:*/		regs.R3 = regs.R31;
		/* 82261464h case   32:*/		return 0x82261468;
		  /* 82261468h */ case   33:  		/* mr R7, R21 */
		/* 82261468h case   33:*/		regs.R7 = regs.R21;
		/* 82261468h case   33:*/		return 0x8226146C;
		  /* 8226146Ch */ case   34:  		/* stwx R11, <#[R9 + R21]> */
		/* 8226146Ch case   34:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + regs.R21 + 0x00000000) );
		/* 8226146Ch case   34:*/		return 0x82261470;
		  /* 82261470h */ case   35:  		/* lwz R5, <#[R24]> */
		/* 82261470h case   35:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R24 + 0x00000000) );
		/* 82261470h case   35:*/		return 0x82261474;
		  /* 82261474h */ case   36:  		/* bl -27764 */
		/* 82261474h case   36:*/		regs.LR = 0x82261478; return 0x8225A800;
		/* 82261474h case   36:*/		return 0x82261478;
		  /* 82261478h */ case   37:  		/* mr R7, R21 */
		/* 82261478h case   37:*/		regs.R7 = regs.R21;
		/* 82261478h case   37:*/		return 0x8226147C;
		  /* 8226147Ch */ case   38:  		/* lwz R5, <#[R24 + 4]> */
		/* 8226147Ch case   38:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R24 + 0x00000004) );
		/* 8226147Ch case   38:*/		return 0x82261480;
		  /* 82261480h */ case   39:  		/* mr R6, R30 */
		/* 82261480h case   39:*/		regs.R6 = regs.R30;
		/* 82261480h case   39:*/		return 0x82261484;
		  /* 82261484h */ case   40:  		/* addi R4, R1, 152 */
		/* 82261484h case   40:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x98);
		/* 82261484h case   40:*/		return 0x82261488;
		  /* 82261488h */ case   41:  		/* mr R3, R31 */
		/* 82261488h case   41:*/		regs.R3 = regs.R31;
		/* 82261488h case   41:*/		return 0x8226148C;
		  /* 8226148Ch */ case   42:  		/* bl -27788 */
		/* 8226148Ch case   42:*/		regs.LR = 0x82261490; return 0x8225A800;
		/* 8226148Ch case   42:*/		return 0x82261490;
		  /* 82261490h */ case   43:  		/* lwz R10, <#[R31 + 12]> */
		/* 82261490h case   43:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 82261490h case   43:*/		return 0x82261494;
		  /* 82261494h */ case   44:  		/* mr R4, R21 */
		/* 82261494h case   44:*/		regs.R4 = regs.R21;
		/* 82261494h case   44:*/		return 0x82261498;
		  /* 82261498h */ case   45:  		/* mr R3, R31 */
		/* 82261498h case   45:*/		regs.R3 = regs.R31;
		/* 82261498h case   45:*/		return 0x8226149C;
		  /* 8226149Ch */ case   46:  		/* lwz R11, <#[R10 + 1508]> */
		/* 8226149Ch case   46:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x000005E4) );
		/* 8226149Ch case   46:*/		return 0x822614A0;
		  /* 822614A0h */ case   47:  		/* addi R29, R11, -1 */
		/* 822614A0h case   47:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0xFFFFFFFF);
		/* 822614A0h case   47:*/		return 0x822614A4;
		  /* 822614A4h */ case   48:  		/* stw R29, <#[R10 + 1508]> */
		/* 822614A4h case   48:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R10 + 0x000005E4) );
		/* 822614A4h case   48:*/		return 0x822614A8;
		  /* 822614A8h */ case   49:  		/* stw R29, <#[R21 + 56]> */
		/* 822614A8h case   49:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R21 + 0x00000038) );
		/* 822614A8h case   49:*/		return 0x822614AC;
		  /* 822614ACh */ case   50:  		/* stw R23, <#[R21 + 80]> */
		/* 822614ACh case   50:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R21 + 0x00000050) );
		/* 822614ACh case   50:*/		return 0x822614B0;
		  /* 822614B0h */ case   51:  		/* bl -175880 */
		/* 822614B0h case   51:*/		regs.LR = 0x822614B4; return 0x822365A8;
		/* 822614B0h case   51:*/		return 0x822614B4;
		  /* 822614B4h */ case   52:  		/* mr R4, R21 */
		/* 822614B4h case   52:*/		regs.R4 = regs.R21;
		/* 822614B4h case   52:*/		return 0x822614B8;
		  /* 822614B8h */ case   53:  		/* mr R3, R14 */
		/* 822614B8h case   53:*/		regs.R3 = regs.R14;
		/* 822614B8h case   53:*/		return 0x822614BC;
		  /* 822614BCh */ case   54:  		/* bl -34188 */
		/* 822614BCh case   54:*/		regs.LR = 0x822614C0; return 0x82258F30;
		/* 822614BCh case   54:*/		return 0x822614C0;
		  /* 822614C0h */ case   55:  		/* li R3, 135 */
		/* 822614C0h case   55:*/		cpu::op::li<0>(regs,&regs.R3,0x87);
		/* 822614C0h case   55:*/		return 0x822614C4;
		  /* 822614C4h */ case   56:  		/* lwz R4, <#[R31 + 12]> */
		/* 822614C4h case   56:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 822614C4h case   56:*/		return 0x822614C8;
		  /* 822614C8h */ case   57:  		/* bl -46488 */
		/* 822614C8h case   57:*/		regs.LR = 0x822614CC; return 0x82255F30;
		/* 822614C8h case   57:*/		return 0x822614CC;
		  /* 822614CCh */ case   58:  		/* mr R30, R3 */
		/* 822614CCh case   58:*/		regs.R30 = regs.R3;
		/* 822614CCh case   58:*/		return 0x822614D0;
		  /* 822614D0h */ case   59:  		/* stw R29, <#[R3 + 60]> */
		/* 822614D0h case   59:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x0000003C) );
		/* 822614D0h case   59:*/		return 0x822614D4;
		  /* 822614D4h */ case   60:  		/* stw R23, <#[R3 + 84]> */
		/* 822614D4h case   60:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R3 + 0x00000054) );
		/* 822614D4h case   60:*/		return 0x822614D8;
		  /* 822614D8h */ case   61:  		/* b 292 */
		/* 822614D8h case   61:*/		return 0x822615FC;
		/* 822614D8h case   61:*/		return 0x822614DC;
	}
	return 0x822614DC;
} // Block from 822613E4h-822614DCh (62 instructions)

//////////////////////////////////////////////////////
// Block at 822614DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822614DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822614DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822614DC);
		  /* 822614DCh */ case    0:  		/* lwz R30, <#[R1 + 180]> */
		/* 822614DCh case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x000000B4) );
		/* 822614DCh case    0:*/		return 0x822614E0;
		  /* 822614E0h */ case    1:  		/* mr R3, R31 */
		/* 822614E0h case    1:*/		regs.R3 = regs.R31;
		/* 822614E0h case    1:*/		return 0x822614E4;
		  /* 822614E4h */ case    2:  		/* lwz R29, <#[R31 + 12]> */
		/* 822614E4h case    2:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x0000000C) );
		/* 822614E4h case    2:*/		return 0x822614E8;
		  /* 822614E8h */ case    3:  		/* lwz R11, <#[R30]> */
		/* 822614E8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 822614E8h case    3:*/		return 0x822614EC;
		  /* 822614ECh */ case    4:  		/* lwz R28, <#[R29 + 1536]> */
		/* 822614ECh case    4:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R29 + 0x00000600) );
		/* 822614ECh case    4:*/		return 0x822614F0;
		  /* 822614F0h */ case    5:  		/* lwz R11, <#[R11]> */
		/* 822614F0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 822614F0h case    5:*/		return 0x822614F4;
		  /* 822614F4h */ case    6:  		/* extsh R27, R11 */
		/* 822614F4h case    6:*/		cpu::op::extsh<0>(regs,&regs.R27,regs.R11);
		/* 822614F4h case    6:*/		return 0x822614F8;
		  /* 822614F8h */ case    7:  		/* bl -178240 */
		/* 822614F8h case    7:*/		regs.LR = 0x822614FC; return 0x82235CB8;
		/* 822614F8h case    7:*/		return 0x822614FC;
		  /* 822614FCh */ case    8:  		/* rlwinm R11, R3, 0, 24, 31 */
		/* 822614FCh case    8:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822614FCh case    8:*/		return 0x82261500;
		  /* 82261500h */ case    9:  		/* lis R10, -32222 */
		/* 82261500h case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8222);
		/* 82261500h case    9:*/		return 0x82261504;
		  /* 82261504h */ case   10:  		/* cntlzw R11, R11 */
		/* 82261504h case   10:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 82261504h case   10:*/		return 0x82261508;
		  /* 82261508h */ case   11:  		/* mr R3, R28 */
		/* 82261508h case   11:*/		regs.R3 = regs.R28;
		/* 82261508h case   11:*/		return 0x8226150C;
		  /* 8226150Ch */ case   12:  		/* rlwinm R4, R11, 27, 31, 31 */
		/* 8226150Ch case   12:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R4,regs.R11);
		/* 8226150Ch case   12:*/		return 0x82261510;
		  /* 82261510h */ case   13:  		/* mr R5, R27 */
		/* 82261510h case   13:*/		regs.R5 = regs.R27;
		/* 82261510h case   13:*/		return 0x82261514;
		  /* 82261514h */ case   14:  		/* addi R6, R1, 404 */
		/* 82261514h case   14:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x194);
		/* 82261514h case   14:*/		return 0x82261518;
		  /* 82261518h */ case   15:  		/* addi R7, R10, -12392 */
		/* 82261518h case   15:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0xFFFFCF98);
		/* 82261518h case   15:*/		return 0x8226151C;
		  /* 8226151Ch */ case   16:  		/* mr R8, R29 */
		/* 8226151Ch case   16:*/		regs.R8 = regs.R29;
		/* 8226151Ch case   16:*/		return 0x82261520;
		  /* 82261520h */ case   17:  		/* bl -191824 */
		/* 82261520h case   17:*/		regs.LR = 0x82261524; return 0x822327D0;
		/* 82261520h case   17:*/		return 0x82261524;
		  /* 82261524h */ case   18:  		/* cmpwi CR6, R3, 1 */
		/* 82261524h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 82261524h case   18:*/		return 0x82261528;
		  /* 82261528h */ case   19:  		/* bc 12, CR6_EQ, 28 */
		/* 82261528h case   19:*/		if ( regs.CR[6].eq ) { return 0x82261544;  }
		/* 82261528h case   19:*/		return 0x8226152C;
		  /* 8226152Ch */ case   20:  		/* li R7, 3969 */
		/* 8226152Ch case   20:*/		cpu::op::li<0>(regs,&regs.R7,0xF81);
		/* 8226152Ch case   20:*/		return 0x82261530;
		  /* 82261530h */ case   21:  		/* lwz R6, <#[R1 + 128]> */
		/* 82261530h case   21:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 82261530h case   21:*/		return 0x82261534;
		  /* 82261534h */ case   22:  		/* li R3, 0 */
		/* 82261534h case   22:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82261534h case   22:*/		return 0x82261538;
		  /* 82261538h */ case   23:  		/* lwz R5, <#[R1 + 300]> */
		/* 82261538h case   23:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x0000012C) );
		/* 82261538h case   23:*/		return 0x8226153C;
		  /* 8226153Ch */ case   24:  		/* lwz R4, <#[R1 + 132]> */
		/* 8226153Ch case   24:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 8226153Ch case   24:*/		return 0x82261540;
		  /* 82261540h */ case   25:  		/* bl -1087800 */
		/* 82261540h case   25:*/		regs.LR = 0x82261544; return 0x82157C08;
		/* 82261540h case   25:*/		return 0x82261544;
	}
	return 0x82261544;
} // Block from 822614DCh-82261544h (26 instructions)

//////////////////////////////////////////////////////
// Block at 82261544h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261544( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261544) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261544);
		  /* 82261544h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 82261544h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82261544h case    0:*/		return 0x82261548;
		  /* 82261548h */ case    1:  		/* lhz R11, <#[R11]> */
		/* 82261548h case    1:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82261548h case    1:*/		return 0x8226154C;
		  /* 8226154Ch */ case    2:  		/* rlwinm. R30, R11, 0, 26, 31 */
		/* 8226154Ch case    2:*/		cpu::op::rlwinm<1,0,26,31>(regs,&regs.R30,regs.R11);
		/* 8226154Ch case    2:*/		return 0x82261550;
		  /* 82261550h */ case    3:  		/* bc 12, CR0_EQ, 28 */
		/* 82261550h case    3:*/		if ( regs.CR[0].eq ) { return 0x8226156C;  }
		/* 82261550h case    3:*/		return 0x82261554;
		  /* 82261554h */ case    4:  		/* li R7, 3972 */
		/* 82261554h case    4:*/		cpu::op::li<0>(regs,&regs.R7,0xF84);
		/* 82261554h case    4:*/		return 0x82261558;
		  /* 82261558h */ case    5:  		/* lwz R6, <#[R1 + 128]> */
		/* 82261558h case    5:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 82261558h case    5:*/		return 0x8226155C;
		  /* 8226155Ch */ case    6:  		/* li R3, 0 */
		/* 8226155Ch case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8226155Ch case    6:*/		return 0x82261560;
		  /* 82261560h */ case    7:  		/* lwz R5, <#[R1 + 396]> */
		/* 82261560h case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x0000018C) );
		/* 82261560h case    7:*/		return 0x82261564;
		  /* 82261564h */ case    8:  		/* lwz R4, <#[R1 + 132]> */
		/* 82261564h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 82261564h case    8:*/		return 0x82261568;
		  /* 82261568h */ case    9:  		/* bl -1087840 */
		/* 82261568h case    9:*/		regs.LR = 0x8226156C; return 0x82157C08;
		/* 82261568h case    9:*/		return 0x8226156C;
	}
	return 0x8226156C;
} // Block from 82261544h-8226156Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8226156Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226156C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226156C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226156C);
		  /* 8226156Ch */ case    0:  		/* li R3, 136 */
		/* 8226156Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x88);
		/* 8226156Ch case    0:*/		return 0x82261570;
		  /* 82261570h */ case    1:  		/* lwz R4, <#[R31 + 12]> */
		/* 82261570h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 82261570h case    1:*/		return 0x82261574;
		  /* 82261574h */ case    2:  		/* bl -46660 */
		/* 82261574h case    2:*/		regs.LR = 0x82261578; return 0x82255F30;
		/* 82261574h case    2:*/		return 0x82261578;
		  /* 82261578h */ case    3:  		/* lwz R11, <#[R31 + 92]> */
		/* 82261578h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 82261578h case    3:*/		return 0x8226157C;
		  /* 8226157Ch */ case    4:  		/* rlwinm R10, R30, 3, 0, 28 */
		/* 8226157Ch case    4:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R30);
		/* 8226157Ch case    4:*/		return 0x82261580;
		  /* 82261580h */ case    5:  		/* lwz R9, <#[R1 + 404]> */
		/* 82261580h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000194) );
		/* 82261580h case    5:*/		return 0x82261584;
		  /* 82261584h */ case    6:  		/* mr R30, R3 */
		/* 82261584h case    6:*/		regs.R30 = regs.R3;
		/* 82261584h case    6:*/		return 0x82261588;
		  /* 82261588h */ case    7:  		/* add R11, R10, R11 */
		/* 82261588h case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82261588h case    7:*/		return 0x8226158C;
		  /* 8226158Ch */ case    8:  		/* li R10, 1 */
		/* 8226158Ch case    8:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8226158Ch case    8:*/		return 0x82261590;
		  /* 82261590h */ case    9:  		/* li R3, 160 */
		/* 82261590h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0xA0);
		/* 82261590h case    9:*/		return 0x82261594;
		  /* 82261594h */ case   10:  		/* lwz R11, <#[R11 + 4]> */
		/* 82261594h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82261594h case   10:*/		return 0x82261598;
		  /* 82261598h */ case   11:  		/* stw R9, <#[R30 + 60]> */
		/* 82261598h case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R30 + 0x0000003C) );
		/* 82261598h case   11:*/		return 0x8226159C;
		  /* 8226159Ch */ case   12:  		/* stw R10, <#[R30 + 168]> */
		/* 8226159Ch case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x000000A8) );
		/* 8226159Ch case   12:*/		return 0x822615A0;
		  /* 822615A0h */ case   13:  		/* stw R11, <#[R30 + 84]> */
		/* 822615A0h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000054) );
		/* 822615A0h case   13:*/		return 0x822615A4;
		  /* 822615A4h */ case   14:  		/* lwz R11, <#[R31 + 12]> */
		/* 822615A4h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 822615A4h case   14:*/		return 0x822615A8;
		  /* 822615A8h */ case   15:  		/* lwz R4, <#[R11 + 1452]> */
		/* 822615A8h case   15:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005AC) );
		/* 822615A8h case   15:*/		return 0x822615AC;
		  /* 822615ACh */ case   16:  		/* bl -28348 */
		/* 822615ACh case   16:*/		regs.LR = 0x822615B0; return 0x8225A6F0;
		/* 822615ACh case   16:*/		return 0x822615B0;
		  /* 822615B0h */ case   17:  		/* cmplwi CR0, R3, 0 */
		/* 822615B0h case   17:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 822615B0h case   17:*/		return 0x822615B4;
		  /* 822615B4h */ case   18:  		/* bc 12, CR0_EQ, 132 */
		/* 822615B4h case   18:*/		if ( regs.CR[0].eq ) { return 0x82261638;  }
		/* 822615B4h case   18:*/		return 0x822615B8;
		  /* 822615B8h */ case   19:  		/* mr R7, R31 */
		/* 822615B8h case   19:*/		regs.R7 = regs.R31;
		/* 822615B8h case   19:*/		return 0x822615BC;
		  /* 822615BCh */ case   20:  		/* lwz R6, <#[R31 + 12]> */
		/* 822615BCh case   20:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x0000000C) );
		/* 822615BCh case   20:*/		return 0x822615C0;
		  /* 822615C0h */ case   21:  		/* mr R5, R25 */
		/* 822615C0h case   21:*/		regs.R5 = regs.R25;
		/* 822615C0h case   21:*/		return 0x822615C4;
		  /* 822615C4h */ case   22:  		/* mr R4, R30 */
		/* 822615C4h case   22:*/		regs.R4 = regs.R30;
		/* 822615C4h case   22:*/		return 0x822615C8;
		  /* 822615C8h */ case   23:  		/* bl -30032 */
		/* 822615C8h case   23:*/		regs.LR = 0x822615CC; return 0x8225A078;
		/* 822615C8h case   23:*/		return 0x822615CC;
		  /* 822615CCh */ case   24:  		/* b 100 */
		/* 822615CCh case   24:*/		return 0x82261630;
		/* 822615CCh case   24:*/		return 0x822615D0;
	}
	return 0x822615D0;
} // Block from 8226156Ch-822615D0h (25 instructions)

//////////////////////////////////////////////////////
// Block at 822615D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822615D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822615D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822615D0);
		  /* 822615D0h */ case    0:  		/* li R3, 135 */
		/* 822615D0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x87);
		/* 822615D0h case    0:*/		return 0x822615D4;
		  /* 822615D4h */ case    1:  		/* lwz R4, <#[R31 + 12]> */
		/* 822615D4h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 822615D4h case    1:*/		return 0x822615D8;
		  /* 822615D8h */ case    2:  		/* bl -46760 */
		/* 822615D8h case    2:*/		regs.LR = 0x822615DC; return 0x82255F30;
		/* 822615D8h case    2:*/		return 0x822615DC;
		  /* 822615DCh */ case    3:  		/* li R5, 1 */
		/* 822615DCh case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 822615DCh case    3:*/		return 0x822615E0;
		  /* 822615E0h */ case    4:  		/* mr R4, R31 */
		/* 822615E0h case    4:*/		regs.R4 = regs.R31;
		/* 822615E0h case    4:*/		return 0x822615E4;
		  /* 822615E4h */ case    5:  		/* fmr FR4, FR31 */
		/* 822615E4h case    5:*/		cpu::op::fmr<0>(regs,&regs.FR4,regs.FR31);
		/* 822615E4h case    5:*/		return 0x822615E8;
		  /* 822615E8h */ case    6:  		/* mr R30, R3 */
		/* 822615E8h case    6:*/		regs.R30 = regs.R3;
		/* 822615E8h case    6:*/		return 0x822615EC;
		  /* 822615ECh */ case    7:  		/* fmr FR3, FR31 */
		/* 822615ECh case    7:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR31);
		/* 822615ECh case    7:*/		return 0x822615F0;
		  /* 822615F0h */ case    8:  		/* fmr FR2, FR31 */
		/* 822615F0h case    8:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR31);
		/* 822615F0h case    8:*/		return 0x822615F4;
		  /* 822615F4h */ case    9:  		/* fmr FR1, FR31 */
		/* 822615F4h case    9:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 822615F4h case    9:*/		return 0x822615F8;
		  /* 822615F8h */ case   10:  		/* bl -42720 */
		/* 822615F8h case   10:*/		regs.LR = 0x822615FC; return 0x82256F18;
		/* 822615F8h case   10:*/		return 0x822615FC;
	}
	return 0x822615FC;
} // Block from 822615D0h-822615FCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 822615FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822615FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822615FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822615FC);
		  /* 822615FCh */ case    0:  		/* li R11, 1 */
		/* 822615FCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 822615FCh case    0:*/		return 0x82261600;
		  /* 82261600h */ case    1:  		/* li R3, 160 */
		/* 82261600h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0xA0);
		/* 82261600h case    1:*/		return 0x82261604;
		  /* 82261604h */ case    2:  		/* stw R11, <#[R30 + 168]> */
		/* 82261604h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x000000A8) );
		/* 82261604h case    2:*/		return 0x82261608;
		  /* 82261608h */ case    3:  		/* lwz R11, <#[R31 + 12]> */
		/* 82261608h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82261608h case    3:*/		return 0x8226160C;
		  /* 8226160Ch */ case    4:  		/* lwz R4, <#[R11 + 1452]> */
		/* 8226160Ch case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005AC) );
		/* 8226160Ch case    4:*/		return 0x82261610;
		  /* 82261610h */ case    5:  		/* bl -28448 */
		/* 82261610h case    5:*/		regs.LR = 0x82261614; return 0x8225A6F0;
		/* 82261610h case    5:*/		return 0x82261614;
		  /* 82261614h */ case    6:  		/* cmplwi CR0, R3, 0 */
		/* 82261614h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82261614h case    6:*/		return 0x82261618;
		  /* 82261618h */ case    7:  		/* bc 12, CR0_EQ, 32 */
		/* 82261618h case    7:*/		if ( regs.CR[0].eq ) { return 0x82261638;  }
		/* 82261618h case    7:*/		return 0x8226161C;
		  /* 8226161Ch */ case    8:  		/* mr R7, R31 */
		/* 8226161Ch case    8:*/		regs.R7 = regs.R31;
		/* 8226161Ch case    8:*/		return 0x82261620;
		  /* 82261620h */ case    9:  		/* lwz R6, <#[R31 + 12]> */
		/* 82261620h case    9:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x0000000C) );
		/* 82261620h case    9:*/		return 0x82261624;
		  /* 82261624h */ case   10:  		/* mr R5, R25 */
		/* 82261624h case   10:*/		regs.R5 = regs.R25;
		/* 82261624h case   10:*/		return 0x82261628;
		  /* 82261628h */ case   11:  		/* mr R4, R30 */
		/* 82261628h case   11:*/		regs.R4 = regs.R30;
		/* 82261628h case   11:*/		return 0x8226162C;
		  /* 8226162Ch */ case   12:  		/* bl -30380 */
		/* 8226162Ch case   12:*/		regs.LR = 0x82261630; return 0x82259F80;
		/* 8226162Ch case   12:*/		return 0x82261630;
	}
	return 0x82261630;
} // Block from 822615FCh-82261630h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82261630h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261630( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261630) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261630);
		  /* 82261630h */ case    0:  		/* mr R29, R3 */
		/* 82261630h case    0:*/		regs.R29 = regs.R3;
		/* 82261630h case    0:*/		return 0x82261634;
		  /* 82261634h */ case    1:  		/* b 8 */
		/* 82261634h case    1:*/		return 0x8226163C;
		/* 82261634h case    1:*/		return 0x82261638;
	}
	return 0x82261638;
} // Block from 82261630h-82261638h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82261638h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261638( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261638) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261638);
		  /* 82261638h */ case    0:  		/* mr R29, R23 */
		/* 82261638h case    0:*/		regs.R29 = regs.R23;
		/* 82261638h case    0:*/		return 0x8226163C;
	}
	return 0x8226163C;
} // Block from 82261638h-8226163Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226163Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226163C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226163C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226163C);
		  /* 8226163Ch */ case    0:  		/* lwz R11, <#[R1 + 188]> */
		/* 8226163Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000BC) );
		/* 8226163Ch case    0:*/		return 0x82261640;
		  /* 82261640h */ case    1:  		/* mr R4, R30 */
		/* 82261640h case    1:*/		regs.R4 = regs.R30;
		/* 82261640h case    1:*/		return 0x82261644;
		  /* 82261644h */ case    2:  		/* mr R3, R31 */
		/* 82261644h case    2:*/		regs.R3 = regs.R31;
		/* 82261644h case    2:*/		return 0x82261648;
		  /* 82261648h */ case    3:  		/* stw R11, <#[R29 + 52]> */
		/* 82261648h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000034) );
		/* 82261648h case    3:*/		return 0x8226164C;
		  /* 8226164Ch */ case    4:  		/* bl -176292 */
		/* 8226164Ch case    4:*/		regs.LR = 0x82261650; return 0x822365A8;
		/* 8226164Ch case    4:*/		return 0x82261650;
		  /* 82261650h */ case    5:  		/* mr R3, R22 */
		/* 82261650h case    5:*/		regs.R3 = regs.R22;
		/* 82261650h case    5:*/		return 0x82261654;
		  /* 82261654h */ case    6:  		/* lwz R4, <#[R22 + 4]> */
		/* 82261654h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R22 + 0x00000004) );
		/* 82261654h case    6:*/		return 0x82261658;
		  /* 82261658h */ case    7:  		/* bl -56216 */
		/* 82261658h case    7:*/		regs.LR = 0x8226165C; return 0x82253AC0;
		/* 82261658h case    7:*/		return 0x8226165C;
		  /* 8226165Ch */ case    8:  		/* stw R29, <#[R3]> */
		/* 8226165Ch case    8:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 8226165Ch case    8:*/		return 0x82261660;
	}
	return 0x82261660;
} // Block from 8226163Ch-82261660h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82261660h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261660( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261660) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261660);
		  /* 82261660h */ case    0:  		/* lwz R30, <#[R1 + 160]> */
		/* 82261660h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x000000A0) );
		/* 82261660h case    0:*/		return 0x82261664;
		  /* 82261664h */ case    1:  		/* mr R5, R29 */
		/* 82261664h case    1:*/		regs.R5 = regs.R29;
		/* 82261664h case    1:*/		return 0x82261668;
		  /* 82261668h */ case    2:  		/* mr R3, R31 */
		/* 82261668h case    2:*/		regs.R3 = regs.R31;
		/* 82261668h case    2:*/		return 0x8226166C;
		  /* 8226166Ch */ case    3:  		/* mr R4, R30 */
		/* 8226166Ch case    3:*/		regs.R4 = regs.R30;
		/* 8226166Ch case    3:*/		return 0x82261670;
		  /* 82261670h */ case    4:  		/* bl -178712 */
		/* 82261670h case    4:*/		regs.LR = 0x82261674; return 0x82235C58;
		/* 82261670h case    4:*/		return 0x82261674;
		  /* 82261674h */ case    5:  		/* mr R4, R29 */
		/* 82261674h case    5:*/		regs.R4 = regs.R29;
		/* 82261674h case    5:*/		return 0x82261678;
		  /* 82261678h */ case    6:  		/* mr R3, R30 */
		/* 82261678h case    6:*/		regs.R3 = regs.R30;
		/* 82261678h case    6:*/		return 0x8226167C;
		  /* 8226167Ch */ case    7:  		/* bl -32172 */
		/* 8226167Ch case    7:*/		regs.LR = 0x82261680; return 0x822598D0;
		/* 8226167Ch case    7:*/		return 0x82261680;
		  /* 82261680h */ case    8:  		/* mr R4, R29 */
		/* 82261680h case    8:*/		regs.R4 = regs.R29;
		/* 82261680h case    8:*/		return 0x82261684;
		  /* 82261684h */ case    9:  		/* lwz R14, <#[R29 + 144]> */
		/* 82261684h case    9:*/		cpu::mem::load32z( regs, &regs.R14, (uint32)(regs.R29 + 0x00000090) );
		/* 82261684h case    9:*/		return 0x82261688;
		  /* 82261688h */ case   10:  		/* mr R5, R14 */
		/* 82261688h case   10:*/		regs.R5 = regs.R14;
		/* 82261688h case   10:*/		return 0x8226168C;
		  /* 8226168Ch */ case   11:  		/* mr R3, R31 */
		/* 8226168Ch case   11:*/		regs.R3 = regs.R31;
		/* 8226168Ch case   11:*/		return 0x82261690;
		  /* 82261690h */ case   12:  		/* bl -178744 */
		/* 82261690h case   12:*/		regs.LR = 0x82261694; return 0x82235C58;
		/* 82261690h case   12:*/		return 0x82261694;
		  /* 82261694h */ case   13:  		/* b -1992 */
		/* 82261694h case   13:*/		return 0x82260ECC;
		/* 82261694h case   13:*/		return 0x82261698;
		  /* 82261698h */ case   14:  		/* lwz R30, <#[R1 + 220]> */
		/* 82261698h case   14:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x000000DC) );
		/* 82261698h case   14:*/		return 0x8226169C;
		  /* 8226169Ch */ case   15:  		/* lwz R11, <#[R30 + 4]> */
		/* 8226169Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 8226169Ch case   15:*/		return 0x822616A0;
		  /* 822616A0h */ case   16:  		/* cmplwi CR6, R11, 0 */
		/* 822616A0h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822616A0h case   16:*/		return 0x822616A4;
		  /* 822616A4h */ case   17:  		/* bc 4, CR6_EQ, 28 */
		/* 822616A4h case   17:*/		if ( !regs.CR[6].eq ) { return 0x822616C0;  }
		/* 822616A4h case   17:*/		return 0x822616A8;
		  /* 822616A8h */ case   18:  		/* li R7, 4002 */
		/* 822616A8h case   18:*/		cpu::op::li<0>(regs,&regs.R7,0xFA2);
		/* 822616A8h case   18:*/		return 0x822616AC;
		  /* 822616ACh */ case   19:  		/* lwz R6, <#[R1 + 128]> */
		/* 822616ACh case   19:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 822616ACh case   19:*/		return 0x822616B0;
		  /* 822616B0h */ case   20:  		/* li R3, 0 */
		/* 822616B0h case   20:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822616B0h case   20:*/		return 0x822616B4;
		  /* 822616B4h */ case   21:  		/* lwz R5, <#[R1 + 356]> */
		/* 822616B4h case   21:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000164) );
		/* 822616B4h case   21:*/		return 0x822616B8;
		  /* 822616B8h */ case   22:  		/* lwz R4, <#[R1 + 132]> */
		/* 822616B8h case   22:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 822616B8h case   22:*/		return 0x822616BC;
		  /* 822616BCh */ case   23:  		/* bl -1088180 */
		/* 822616BCh case   23:*/		regs.LR = 0x822616C0; return 0x82157C08;
		/* 822616BCh case   23:*/		return 0x822616C0;
	}
	return 0x822616C0;
} // Block from 82261660h-822616C0h (24 instructions)

//////////////////////////////////////////////////////
// Block at 822616C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822616C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822616C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822616C0);
		  /* 822616C0h */ case    0:  		/* lwz R10, <#[R30 + 4]> */
		/* 822616C0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000004) );
		/* 822616C0h case    0:*/		return 0x822616C4;
		  /* 822616C4h */ case    1:  		/* addi R11, R10, -1 */
		/* 822616C4h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0xFFFFFFFF);
		/* 822616C4h case    1:*/		return 0x822616C8;
		  /* 822616C8h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 822616C8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 822616C8h case    2:*/		return 0x822616CC;
		  /* 822616CCh */ case    3:  		/* bc 4, CR6_LT, 20 */
		/* 822616CCh case    3:*/		if ( !regs.CR[6].lt ) { return 0x822616E0;  }
		/* 822616CCh case    3:*/		return 0x822616D0;
		  /* 822616D0h */ case    4:  		/* lwz R10, <#[R30 + 8]> */
		/* 822616D0h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 822616D0h case    4:*/		return 0x822616D4;
		  /* 822616D4h */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 822616D4h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 822616D4h case    5:*/		return 0x822616D8;
		  /* 822616D8h */ case    6:  		/* add R11, R11, R10 */
		/* 822616D8h case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 822616D8h case    6:*/		return 0x822616DC;
		  /* 822616DCh */ case    7:  		/* b 8 */
		/* 822616DCh case    7:*/		return 0x822616E4;
		/* 822616DCh case    7:*/		return 0x822616E0;
	}
	return 0x822616E0;
} // Block from 822616C0h-822616E0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 822616E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822616E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822616E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822616E0);
		  /* 822616E0h */ case    0:  		/* li R11, 0 */
		/* 822616E0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822616E0h case    0:*/		return 0x822616E4;
	}
	return 0x822616E4;
} // Block from 822616E0h-822616E4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822616E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822616E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822616E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822616E4);
		  /* 822616E4h */ case    0:  		/* lwz R10, <#[R31 + 12]> */
		/* 822616E4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 822616E4h case    0:*/		return 0x822616E8;
		  /* 822616E8h */ case    1:  		/* li R3, 136 */
		/* 822616E8h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x88);
		/* 822616E8h case    1:*/		return 0x822616EC;
		  /* 822616ECh */ case    2:  		/* lwz R30, <#[R11]> */
		/* 822616ECh case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 822616ECh case    2:*/		return 0x822616F0;
		  /* 822616F0h */ case    3:  		/* lwz R4, <#[R10 + 1452]> */
		/* 822616F0h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x000005AC) );
		/* 822616F0h case    3:*/		return 0x822616F4;
		  /* 822616F4h */ case    4:  		/* bl -28676 */
		/* 822616F4h case    4:*/		regs.LR = 0x822616F8; return 0x8225A6F0;
		/* 822616F4h case    4:*/		return 0x822616F8;
		  /* 822616F8h */ case    5:  		/* cmplwi CR0, R3, 0 */
		/* 822616F8h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 822616F8h case    5:*/		return 0x822616FC;
		  /* 822616FCh */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 822616FCh case    6:*/		if ( regs.CR[0].eq ) { return 0x82261710;  }
		/* 822616FCh case    6:*/		return 0x82261700;
		  /* 82261700h */ case    7:  		/* lwz R4, <#[R31 + 12]> */
		/* 82261700h case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 82261700h case    7:*/		return 0x82261704;
		  /* 82261704h */ case    8:  		/* bl -34228 */
		/* 82261704h case    8:*/		regs.LR = 0x82261708; return 0x82259150;
		/* 82261704h case    8:*/		return 0x82261708;
		  /* 82261708h */ case    9:  		/* mr R14, R3 */
		/* 82261708h case    9:*/		regs.R14 = regs.R3;
		/* 82261708h case    9:*/		return 0x8226170C;
		  /* 8226170Ch */ case   10:  		/* b 8 */
		/* 8226170Ch case   10:*/		return 0x82261714;
		/* 8226170Ch case   10:*/		return 0x82261710;
	}
	return 0x82261710;
} // Block from 822616E4h-82261710h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82261710h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261710( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261710) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261710);
		  /* 82261710h */ case    0:  		/* li R14, 0 */
		/* 82261710h case    0:*/		cpu::op::li<0>(regs,&regs.R14,0x0);
		/* 82261710h case    0:*/		return 0x82261714;
	}
	return 0x82261714;
} // Block from 82261710h-82261714h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82261714h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261714( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261714) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261714);
		  /* 82261714h */ case    0:  		/* lwz R11, <#[R1 + 188]> */
		/* 82261714h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000BC) );
		/* 82261714h case    0:*/		return 0x82261718;
		  /* 82261718h */ case    1:  		/* mr R4, R14 */
		/* 82261718h case    1:*/		regs.R4 = regs.R14;
		/* 82261718h case    1:*/		return 0x8226171C;
		  /* 8226171Ch */ case    2:  		/* mr R3, R30 */
		/* 8226171Ch case    2:*/		regs.R3 = regs.R30;
		/* 8226171Ch case    2:*/		return 0x82261720;
		  /* 82261720h */ case    3:  		/* stw R11, <#[R14 + 52]> */
		/* 82261720h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R14 + 0x00000034) );
		/* 82261720h case    3:*/		return 0x82261724;
		  /* 82261724h */ case    4:  		/* stw R14, <#[R30 + 148]> */
		/* 82261724h case    4:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R30 + 0x00000094) );
		/* 82261724h case    4:*/		return 0x82261728;
		  /* 82261728h */ case    5:  		/* bl -32344 */
		/* 82261728h case    5:*/		regs.LR = 0x8226172C; return 0x822598D0;
		/* 82261728h case    5:*/		return 0x8226172C;
		  /* 8226172Ch */ case    6:  		/* lwz R4, <#[R1 + 160]> */
		/* 8226172Ch case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x000000A0) );
		/* 8226172Ch case    6:*/		return 0x82261730;
		  /* 82261730h */ case    7:  		/* b -168 */
		/* 82261730h case    7:*/		return 0x82261688;
		/* 82261730h case    7:*/		return 0x82261734;
		  /* 82261734h */ case    8:  		/* lwz R25, <#[R1 + 220]> */
		/* 82261734h case    8:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x000000DC) );
		/* 82261734h case    8:*/		return 0x82261738;
		  /* 82261738h */ case    9:  		/* lwz R11, <#[R25 + 4]> */
		/* 82261738h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 82261738h case    9:*/		return 0x8226173C;
		  /* 8226173Ch */ case   10:  		/* cmplwi CR6, R11, 0 */
		/* 8226173Ch case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8226173Ch case   10:*/		return 0x82261740;
		  /* 82261740h */ case   11:  		/* bc 4, CR6_EQ, 28 */
		/* 82261740h case   11:*/		if ( !regs.CR[6].eq ) { return 0x8226175C;  }
		/* 82261740h case   11:*/		return 0x82261744;
		  /* 82261744h */ case   12:  		/* li R7, 4015 */
		/* 82261744h case   12:*/		cpu::op::li<0>(regs,&regs.R7,0xFAF);
		/* 82261744h case   12:*/		return 0x82261748;
		  /* 82261748h */ case   13:  		/* lwz R6, <#[R1 + 128]> */
		/* 82261748h case   13:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 82261748h case   13:*/		return 0x8226174C;
		  /* 8226174Ch */ case   14:  		/* li R3, 0 */
		/* 8226174Ch case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8226174Ch case   14:*/		return 0x82261750;
		  /* 82261750h */ case   15:  		/* lwz R5, <#[R1 + 356]> */
		/* 82261750h case   15:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000164) );
		/* 82261750h case   15:*/		return 0x82261754;
		  /* 82261754h */ case   16:  		/* lwz R4, <#[R1 + 132]> */
		/* 82261754h case   16:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 82261754h case   16:*/		return 0x82261758;
		  /* 82261758h */ case   17:  		/* bl -1088336 */
		/* 82261758h case   17:*/		regs.LR = 0x8226175C; return 0x82157C08;
		/* 82261758h case   17:*/		return 0x8226175C;
	}
	return 0x8226175C;
} // Block from 82261714h-8226175Ch (18 instructions)

//////////////////////////////////////////////////////
// Block at 8226175Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226175C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226175C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226175C);
		  /* 8226175Ch */ case    0:  		/* lwz R10, <#[R25 + 4]> */
		/* 8226175Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000004) );
		/* 8226175Ch case    0:*/		return 0x82261760;
		  /* 82261760h */ case    1:  		/* addi R11, R10, -1 */
		/* 82261760h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0xFFFFFFFF);
		/* 82261760h case    1:*/		return 0x82261764;
		  /* 82261764h */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 82261764h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82261764h case    2:*/		return 0x82261768;
		  /* 82261768h */ case    3:  		/* bc 4, CR6_LT, 20 */
		/* 82261768h case    3:*/		if ( !regs.CR[6].lt ) { return 0x8226177C;  }
		/* 82261768h case    3:*/		return 0x8226176C;
		  /* 8226176Ch */ case    4:  		/* lwz R10, <#[R25 + 8]> */
		/* 8226176Ch case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000008) );
		/* 8226176Ch case    4:*/		return 0x82261770;
		  /* 82261770h */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82261770h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82261770h case    5:*/		return 0x82261774;
		  /* 82261774h */ case    6:  		/* add R11, R11, R10 */
		/* 82261774h case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82261774h case    6:*/		return 0x82261778;
		  /* 82261778h */ case    7:  		/* b 8 */
		/* 82261778h case    7:*/		return 0x82261780;
		/* 82261778h case    7:*/		return 0x8226177C;
	}
	return 0x8226177C;
} // Block from 8226175Ch-8226177Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8226177Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226177C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226177C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226177C);
		  /* 8226177Ch */ case    0:  		/* li R11, 0 */
		/* 8226177Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8226177Ch case    0:*/		return 0x82261780;
	}
	return 0x82261780;
} // Block from 8226177Ch-82261780h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82261780h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261780( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261780) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261780);
		  /* 82261780h */ case    0:  		/* lwz R29, <#[R11]> */
		/* 82261780h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x00000000) );
		/* 82261780h case    0:*/		return 0x82261784;
		  /* 82261784h */ case    1:  		/* mr R3, R31 */
		/* 82261784h case    1:*/		regs.R3 = regs.R31;
		/* 82261784h case    1:*/		return 0x82261788;
		  /* 82261788h */ case    2:  		/* lwz R27, <#[R1 + 188]> */
		/* 82261788h case    2:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x000000BC) );
		/* 82261788h case    2:*/		return 0x8226178C;
		  /* 8226178Ch */ case    3:  		/* lwz R26, <#[R1 + 160]> */
		/* 8226178Ch case    3:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x000000A0) );
		/* 8226178Ch case    3:*/		return 0x82261790;
		  /* 82261790h */ case    4:  		/* mr R4, R26 */
		/* 82261790h case    4:*/		regs.R4 = regs.R26;
		/* 82261790h case    4:*/		return 0x82261794;
		  /* 82261794h */ case    5:  		/* lwz R28, <#[R29 + 152]> */
		/* 82261794h case    5:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R29 + 0x00000098) );
		/* 82261794h case    5:*/		return 0x82261798;
		  /* 82261798h */ case    6:  		/* mr R5, R28 */
		/* 82261798h case    6:*/		regs.R5 = regs.R28;
		/* 82261798h case    6:*/		return 0x8226179C;
		  /* 8226179Ch */ case    7:  		/* stw R27, <#[R28 + 52]> */
		/* 8226179Ch case    7:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R28 + 0x00000034) );
		/* 8226179Ch case    7:*/		return 0x822617A0;
		  /* 822617A0h */ case    8:  		/* bl -179016 */
		/* 822617A0h case    8:*/		regs.LR = 0x822617A4; return 0x82235C58;
		/* 822617A0h case    8:*/		return 0x822617A4;
		  /* 822617A4h */ case    9:  		/* mr R3, R29 */
		/* 822617A4h case    9:*/		regs.R3 = regs.R29;
		/* 822617A4h case    9:*/		return 0x822617A8;
		  /* 822617A8h */ case   10:  		/* bl -33344 */
		/* 822617A8h case   10:*/		regs.LR = 0x822617AC; return 0x82259568;
		/* 822617A8h case   10:*/		return 0x822617AC;
		  /* 822617ACh */ case   11:  		/* stw R27, <#[R3 + 52]> */
		/* 822617ACh case   11:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R3 + 0x00000034) );
		/* 822617ACh case   11:*/		return 0x822617B0;
		  /* 822617B0h */ case   12:  		/* lwz R11, <#[R3]> */
		/* 822617B0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822617B0h case   12:*/		return 0x822617B4;
		  /* 822617B4h */ case   13:  		/* mr R30, R3 */
		/* 822617B4h case   13:*/		regs.R30 = regs.R3;
		/* 822617B4h case   13:*/		return 0x822617B8;
		  /* 822617B8h */ case   14:  		/* lwz R11, <#[R11 + 28]> */
		/* 822617B8h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 822617B8h case   14:*/		return 0x822617BC;
		  /* 822617BCh */ case   15:  		/* mtspr CTR, R11 */
		/* 822617BCh case   15:*/		regs.CTR = regs.R11;
		/* 822617BCh case   15:*/		return 0x822617C0;
		  /* 822617C0h */ case   16:  		/* bcctrl 20, CR0_LT */
		/* 822617C0h case   16:*/		if ( 1 ) { regs.LR = 0x822617C4; return (uint32)regs.CTR; }
		/* 822617C0h case   16:*/		return 0x822617C4;
		  /* 822617C4h */ case   17:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822617C4h case   17:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822617C4h case   17:*/		return 0x822617C8;
		  /* 822617C8h */ case   18:  		/* bc 4, CR0_EQ, 44 */
		/* 822617C8h case   18:*/		if ( !regs.CR[0].eq ) { return 0x822617F4;  }
		/* 822617C8h case   18:*/		return 0x822617CC;
		  /* 822617CCh */ case   19:  		/* lwz R11, <#[R30]> */
		/* 822617CCh case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 822617CCh case   19:*/		return 0x822617D0;
		  /* 822617D0h */ case   20:  		/* mr R3, R30 */
		/* 822617D0h case   20:*/		regs.R3 = regs.R30;
		/* 822617D0h case   20:*/		return 0x822617D4;
		  /* 822617D4h */ case   21:  		/* lwz R11, <#[R11 + 32]> */
		/* 822617D4h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000020) );
		/* 822617D4h case   21:*/		return 0x822617D8;
		  /* 822617D8h */ case   22:  		/* mtspr CTR, R11 */
		/* 822617D8h case   22:*/		regs.CTR = regs.R11;
		/* 822617D8h case   22:*/		return 0x822617DC;
		  /* 822617DCh */ case   23:  		/* bcctrl 20, CR0_LT */
		/* 822617DCh case   23:*/		if ( 1 ) { regs.LR = 0x822617E0; return (uint32)regs.CTR; }
		/* 822617DCh case   23:*/		return 0x822617E0;
		  /* 822617E0h */ case   24:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822617E0h case   24:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822617E0h case   24:*/		return 0x822617E4;
		  /* 822617E4h */ case   25:  		/* bc 4, CR0_EQ, 16 */
		/* 822617E4h case   25:*/		if ( !regs.CR[0].eq ) { return 0x822617F4;  }
		/* 822617E4h case   25:*/		return 0x822617E8;
		  /* 822617E8h */ case   26:  		/* mr R4, R28 */
		/* 822617E8h case   26:*/		regs.R4 = regs.R28;
		/* 822617E8h case   26:*/		return 0x822617EC;
		  /* 822617ECh */ case   27:  		/* mr R3, R30 */
		/* 822617ECh case   27:*/		regs.R3 = regs.R30;
		/* 822617ECh case   27:*/		return 0x822617F0;
		  /* 822617F0h */ case   28:  		/* bl -32544 */
		/* 822617F0h case   28:*/		regs.LR = 0x822617F4; return 0x822598D0;
		/* 822617F0h case   28:*/		return 0x822617F4;
	}
	return 0x822617F4;
} // Block from 82261780h-822617F4h (29 instructions)

//////////////////////////////////////////////////////
// Block at 822617F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822617F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822617F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822617F4);
		  /* 822617F4h */ case    0:  		/* mr R3, R29 */
		/* 822617F4h case    0:*/		regs.R3 = regs.R29;
		/* 822617F4h case    0:*/		return 0x822617F8;
		  /* 822617F8h */ case    1:  		/* bl -33192 */
		/* 822617F8h case    1:*/		regs.LR = 0x822617FC; return 0x82259650;
		/* 822617F8h case    1:*/		return 0x822617FC;
		  /* 822617FCh */ case    2:  		/* mr R30, R3 */
		/* 822617FCh case    2:*/		regs.R30 = regs.R3;
		/* 822617FCh case    2:*/		return 0x82261800;
		  /* 82261800h */ case    3:  		/* cmplw CR6, R3, R29 */
		/* 82261800h case    3:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R29);
		/* 82261800h case    3:*/		return 0x82261804;
		  /* 82261804h */ case    4:  		/* stw R27, <#[R3 + 52]> */
		/* 82261804h case    4:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R3 + 0x00000034) );
		/* 82261804h case    4:*/		return 0x82261808;
		  /* 82261808h */ case    5:  		/* bc 4, CR6_EQ, 84 */
		/* 82261808h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8226185C;  }
		/* 82261808h case    5:*/		return 0x8226180C;
		  /* 8226180Ch */ case    6:  		/* lwz R11, <#[R31 + 12]> */
		/* 8226180Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8226180Ch case    6:*/		return 0x82261810;
		  /* 82261810h */ case    7:  		/* li R3, 136 */
		/* 82261810h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x88);
		/* 82261810h case    7:*/		return 0x82261814;
		  /* 82261814h */ case    8:  		/* lwz R4, <#[R11 + 1452]> */
		/* 82261814h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005AC) );
		/* 82261814h case    8:*/		return 0x82261818;
		  /* 82261818h */ case    9:  		/* bl -28968 */
		/* 82261818h case    9:*/		regs.LR = 0x8226181C; return 0x8225A6F0;
		/* 82261818h case    9:*/		return 0x8226181C;
		  /* 8226181Ch */ case   10:  		/* cmplwi CR0, R3, 0 */
		/* 8226181Ch case   10:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 8226181Ch case   10:*/		return 0x82261820;
		  /* 82261820h */ case   11:  		/* bc 12, CR0_EQ, 20 */
		/* 82261820h case   11:*/		if ( regs.CR[0].eq ) { return 0x82261834;  }
		/* 82261820h case   11:*/		return 0x82261824;
		  /* 82261824h */ case   12:  		/* lwz R4, <#[R31 + 12]> */
		/* 82261824h case   12:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 82261824h case   12:*/		return 0x82261828;
		  /* 82261828h */ case   13:  		/* bl -34520 */
		/* 82261828h case   13:*/		regs.LR = 0x8226182C; return 0x82259150;
		/* 82261828h case   13:*/		return 0x8226182C;
		  /* 8226182Ch */ case   14:  		/* mr R30, R3 */
		/* 8226182Ch case   14:*/		regs.R30 = regs.R3;
		/* 8226182Ch case   14:*/		return 0x82261830;
		  /* 82261830h */ case   15:  		/* b 8 */
		/* 82261830h case   15:*/		return 0x82261838;
		/* 82261830h case   15:*/		return 0x82261834;
	}
	return 0x82261834;
} // Block from 822617F4h-82261834h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82261834h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261834( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261834) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261834);
		  /* 82261834h */ case    0:  		/* li R30, 0 */
		/* 82261834h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82261834h case    0:*/		return 0x82261838;
	}
	return 0x82261838;
} // Block from 82261834h-82261838h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82261838h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261838( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261838) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261838);
		  /* 82261838h */ case    0:  		/* stw R27, <#[R30 + 52]> */
		/* 82261838h case    0:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R30 + 0x00000034) );
		/* 82261838h case    0:*/		return 0x8226183C;
		  /* 8226183Ch */ case    1:  		/* mr R4, R30 */
		/* 8226183Ch case    1:*/		regs.R4 = regs.R30;
		/* 8226183Ch case    1:*/		return 0x82261840;
		  /* 82261840h */ case    2:  		/* stw R30, <#[R29 + 148]> */
		/* 82261840h case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R29 + 0x00000094) );
		/* 82261840h case    2:*/		return 0x82261844;
		  /* 82261844h */ case    3:  		/* mr R3, R29 */
		/* 82261844h case    3:*/		regs.R3 = regs.R29;
		/* 82261844h case    3:*/		return 0x82261848;
		  /* 82261848h */ case    4:  		/* bl -32632 */
		/* 82261848h case    4:*/		regs.LR = 0x8226184C; return 0x822598D0;
		/* 82261848h case    4:*/		return 0x8226184C;
		  /* 8226184Ch */ case    5:  		/* mr R5, R30 */
		/* 8226184Ch case    5:*/		regs.R5 = regs.R30;
		/* 8226184Ch case    5:*/		return 0x82261850;
		  /* 82261850h */ case    6:  		/* mr R4, R26 */
		/* 82261850h case    6:*/		regs.R4 = regs.R26;
		/* 82261850h case    6:*/		return 0x82261854;
		  /* 82261854h */ case    7:  		/* mr R3, R31 */
		/* 82261854h case    7:*/		regs.R3 = regs.R31;
		/* 82261854h case    7:*/		return 0x82261858;
		  /* 82261858h */ case    8:  		/* bl -179200 */
		/* 82261858h case    8:*/		regs.LR = 0x8226185C; return 0x82235C58;
		/* 82261858h case    8:*/		return 0x8226185C;
	}
	return 0x8226185C;
} // Block from 82261838h-8226185Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8226185Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226185C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226185C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226185C);
		  /* 8226185Ch */ case    0:  		/* lwz R11, <#[R30]> */
		/* 8226185Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8226185Ch case    0:*/		return 0x82261860;
		  /* 82261860h */ case    1:  		/* mr R3, R30 */
		/* 82261860h case    1:*/		regs.R3 = regs.R30;
		/* 82261860h case    1:*/		return 0x82261864;
		  /* 82261864h */ case    2:  		/* lwz R11, <#[R11 + 28]> */
		/* 82261864h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 82261864h case    2:*/		return 0x82261868;
		  /* 82261868h */ case    3:  		/* mtspr CTR, R11 */
		/* 82261868h case    3:*/		regs.CTR = regs.R11;
		/* 82261868h case    3:*/		return 0x8226186C;
		  /* 8226186Ch */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 8226186Ch case    4:*/		if ( 1 ) { regs.LR = 0x82261870; return (uint32)regs.CTR; }
		/* 8226186Ch case    4:*/		return 0x82261870;
		  /* 82261870h */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82261870h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82261870h case    5:*/		return 0x82261874;
		  /* 82261874h */ case    6:  		/* bc 4, CR0_EQ, 44 */
		/* 82261874h case    6:*/		if ( !regs.CR[0].eq ) { return 0x822618A0;  }
		/* 82261874h case    6:*/		return 0x82261878;
		  /* 82261878h */ case    7:  		/* lwz R11, <#[R30]> */
		/* 82261878h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82261878h case    7:*/		return 0x8226187C;
		  /* 8226187Ch */ case    8:  		/* mr R3, R30 */
		/* 8226187Ch case    8:*/		regs.R3 = regs.R30;
		/* 8226187Ch case    8:*/		return 0x82261880;
		  /* 82261880h */ case    9:  		/* lwz R11, <#[R11 + 32]> */
		/* 82261880h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000020) );
		/* 82261880h case    9:*/		return 0x82261884;
		  /* 82261884h */ case   10:  		/* mtspr CTR, R11 */
		/* 82261884h case   10:*/		regs.CTR = regs.R11;
		/* 82261884h case   10:*/		return 0x82261888;
		  /* 82261888h */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 82261888h case   11:*/		if ( 1 ) { regs.LR = 0x8226188C; return (uint32)regs.CTR; }
		/* 82261888h case   11:*/		return 0x8226188C;
		  /* 8226188Ch */ case   12:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8226188Ch case   12:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8226188Ch case   12:*/		return 0x82261890;
		  /* 82261890h */ case   13:  		/* bc 4, CR0_EQ, 16 */
		/* 82261890h case   13:*/		if ( !regs.CR[0].eq ) { return 0x822618A0;  }
		/* 82261890h case   13:*/		return 0x82261894;
		  /* 82261894h */ case   14:  		/* mr R4, R28 */
		/* 82261894h case   14:*/		regs.R4 = regs.R28;
		/* 82261894h case   14:*/		return 0x82261898;
		  /* 82261898h */ case   15:  		/* mr R3, R30 */
		/* 82261898h case   15:*/		regs.R3 = regs.R30;
		/* 82261898h case   15:*/		return 0x8226189C;
		  /* 8226189Ch */ case   16:  		/* bl -32716 */
		/* 8226189Ch case   16:*/		regs.LR = 0x822618A0; return 0x822598D0;
		/* 8226189Ch case   16:*/		return 0x822618A0;
	}
	return 0x822618A0;
} // Block from 8226185Ch-822618A0h (17 instructions)

//////////////////////////////////////////////////////
// Block at 822618A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822618A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822618A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822618A0);
		  /* 822618A0h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 822618A0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 822618A0h case    0:*/		return 0x822618A4;
		  /* 822618A4h */ case    1:  		/* li R3, 136 */
		/* 822618A4h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x88);
		/* 822618A4h case    1:*/		return 0x822618A8;
		  /* 822618A8h */ case    2:  		/* lwz R4, <#[R11 + 1452]> */
		/* 822618A8h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005AC) );
		/* 822618A8h case    2:*/		return 0x822618AC;
		  /* 822618ACh */ case    3:  		/* bl -29116 */
		/* 822618ACh case    3:*/		regs.LR = 0x822618B0; return 0x8225A6F0;
		/* 822618ACh case    3:*/		return 0x822618B0;
		  /* 822618B0h */ case    4:  		/* cmplwi CR0, R3, 0 */
		/* 822618B0h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 822618B0h case    4:*/		return 0x822618B4;
		  /* 822618B4h */ case    5:  		/* bc 12, CR0_EQ, 20 */
		/* 822618B4h case    5:*/		if ( regs.CR[0].eq ) { return 0x822618C8;  }
		/* 822618B4h case    5:*/		return 0x822618B8;
		  /* 822618B8h */ case    6:  		/* lwz R4, <#[R31 + 12]> */
		/* 822618B8h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 822618B8h case    6:*/		return 0x822618BC;
		  /* 822618BCh */ case    7:  		/* bl -34668 */
		/* 822618BCh case    7:*/		regs.LR = 0x822618C0; return 0x82259150;
		/* 822618BCh case    7:*/		return 0x822618C0;
		  /* 822618C0h */ case    8:  		/* mr R14, R3 */
		/* 822618C0h case    8:*/		regs.R14 = regs.R3;
		/* 822618C0h case    8:*/		return 0x822618C4;
		  /* 822618C4h */ case    9:  		/* b 8 */
		/* 822618C4h case    9:*/		return 0x822618CC;
		/* 822618C4h case    9:*/		return 0x822618C8;
	}
	return 0x822618C8;
} // Block from 822618A0h-822618C8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 822618C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822618C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822618C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822618C8);
		  /* 822618C8h */ case    0:  		/* li R14, 0 */
		/* 822618C8h case    0:*/		cpu::op::li<0>(regs,&regs.R14,0x0);
		/* 822618C8h case    0:*/		return 0x822618CC;
	}
	return 0x822618CC;
} // Block from 822618C8h-822618CCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 822618CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822618CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822618CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822618CC);
		  /* 822618CCh */ case    0:  		/* stw R27, <#[R14 + 52]> */
		/* 822618CCh case    0:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R14 + 0x00000034) );
		/* 822618CCh case    0:*/		return 0x822618D0;
		  /* 822618D0h */ case    1:  		/* mr R5, R14 */
		/* 822618D0h case    1:*/		regs.R5 = regs.R14;
		/* 822618D0h case    1:*/		return 0x822618D4;
		  /* 822618D4h */ case    2:  		/* mr R4, R28 */
		/* 822618D4h case    2:*/		regs.R4 = regs.R28;
		/* 822618D4h case    2:*/		return 0x822618D8;
		  /* 822618D8h */ case    3:  		/* mr R3, R31 */
		/* 822618D8h case    3:*/		regs.R3 = regs.R31;
		/* 822618D8h case    3:*/		return 0x822618DC;
		  /* 822618DCh */ case    4:  		/* bl -179332 */
		/* 822618DCh case    4:*/		regs.LR = 0x822618E0; return 0x82235C58;
		/* 822618DCh case    4:*/		return 0x822618E0;
		  /* 822618E0h */ case    5:  		/* mr R4, R14 */
		/* 822618E0h case    5:*/		regs.R4 = regs.R14;
		/* 822618E0h case    5:*/		return 0x822618E4;
		  /* 822618E4h */ case    6:  		/* mr R3, R28 */
		/* 822618E4h case    6:*/		regs.R3 = regs.R28;
		/* 822618E4h case    6:*/		return 0x822618E8;
		  /* 822618E8h */ case    7:  		/* bl -32792 */
		/* 822618E8h case    7:*/		regs.LR = 0x822618EC; return 0x822598D0;
		/* 822618E8h case    7:*/		return 0x822618EC;
		  /* 822618ECh */ case    8:  		/* mr R3, R25 */
		/* 822618ECh case    8:*/		regs.R3 = regs.R25;
		/* 822618ECh case    8:*/		return 0x822618F0;
		  /* 822618F0h */ case    9:  		/* stw R14, <#[R1 + 160]> */
		/* 822618F0h case    9:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R1 + 0x000000A0) );
		/* 822618F0h case    9:*/		return 0x822618F4;
		  /* 822618F4h */ case   10:  		/* bl -27556 */
		/* 822618F4h case   10:*/		regs.LR = 0x822618F8; return 0x8225AD50;
		/* 822618F4h case   10:*/		return 0x822618F8;
		  /* 822618F8h */ case   11:  		/* b 1224 */
		/* 822618F8h case   11:*/		return 0x82261DC0;
		/* 822618F8h case   11:*/		return 0x822618FC;
		  /* 822618FCh */ case   12:  		/* lwz R11, <#[R1 + 164]> */
		/* 822618FCh case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000A4) );
		/* 822618FCh case   12:*/		return 0x82261900;
		  /* 82261900h */ case   13:  		/* lwz R11, <#[R11 + 4]> */
		/* 82261900h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82261900h case   13:*/		return 0x82261904;
		  /* 82261904h */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 82261904h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82261904h case   14:*/		return 0x82261908;
		  /* 82261908h */ case   15:  		/* bc 12, CR6_EQ, 1208 */
		/* 82261908h case   15:*/		if ( regs.CR[6].eq ) { return 0x82261DC0;  }
		/* 82261908h case   15:*/		return 0x8226190C;
		  /* 8226190Ch */ case   16:  		/* lwz R9, <#[R1 + 164]> */
		/* 8226190Ch case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x000000A4) );
		/* 8226190Ch case   16:*/		return 0x82261910;
		  /* 82261910h */ case   17:  		/* lwz R10, <#[R9 + 4]> */
		/* 82261910h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000004) );
		/* 82261910h case   17:*/		return 0x82261914;
		  /* 82261914h */ case   18:  		/* addi R11, R10, -1 */
		/* 82261914h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0xFFFFFFFF);
		/* 82261914h case   18:*/		return 0x82261918;
		  /* 82261918h */ case   19:  		/* cmplw CR6, R11, R10 */
		/* 82261918h case   19:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82261918h case   19:*/		return 0x8226191C;
		  /* 8226191Ch */ case   20:  		/* bc 4, CR6_LT, 20 */
		/* 8226191Ch case   20:*/		if ( !regs.CR[6].lt ) { return 0x82261930;  }
		/* 8226191Ch case   20:*/		return 0x82261920;
		  /* 82261920h */ case   21:  		/* lwz R10, <#[R9 + 8]> */
		/* 82261920h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000008) );
		/* 82261920h case   21:*/		return 0x82261924;
		  /* 82261924h */ case   22:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82261924h case   22:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82261924h case   22:*/		return 0x82261928;
		  /* 82261928h */ case   23:  		/* add R11, R11, R10 */
		/* 82261928h case   23:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82261928h case   23:*/		return 0x8226192C;
		  /* 8226192Ch */ case   24:  		/* b 8 */
		/* 8226192Ch case   24:*/		return 0x82261934;
		/* 8226192Ch case   24:*/		return 0x82261930;
	}
	return 0x82261930;
} // Block from 822618CCh-82261930h (25 instructions)

//////////////////////////////////////////////////////
// Block at 82261930h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261930( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261930) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261930);
		  /* 82261930h */ case    0:  		/* li R11, 0 */
		/* 82261930h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82261930h case    0:*/		return 0x82261934;
	}
	return 0x82261934;
} // Block from 82261930h-82261934h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82261934h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261934( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261934) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261934);
		  /* 82261934h */ case    0:  		/* lwz R9, <#[R1 + 220]> */
		/* 82261934h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x000000DC) );
		/* 82261934h case    0:*/		return 0x82261938;
		  /* 82261938h */ case    1:  		/* lwz R28, <#[R11]> */
		/* 82261938h case    1:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x00000000) );
		/* 82261938h case    1:*/		return 0x8226193C;
		  /* 8226193Ch */ case    2:  		/* lwz R11, <#[R9 + 4]> */
		/* 8226193Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 8226193Ch case    2:*/		return 0x82261940;
		  /* 82261940h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 82261940h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82261940h case    3:*/		return 0x82261944;
		  /* 82261944h */ case    4:  		/* bc 12, CR6_EQ, 176 */
		/* 82261944h case    4:*/		if ( regs.CR[6].eq ) { return 0x822619F4;  }
		/* 82261944h case    4:*/		return 0x82261948;
		  /* 82261948h */ case    5:  		/* rlwinm R10, R11, 0, 0, 31 */
		/* 82261948h case    5:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R11);
		/* 82261948h case    5:*/		return 0x8226194C;
		  /* 8226194Ch */ case    6:  		/* addi R11, R10, -1 */
		/* 8226194Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0xFFFFFFFF);
		/* 8226194Ch case    6:*/		return 0x82261950;
		  /* 82261950h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 82261950h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82261950h case    7:*/		return 0x82261954;
		  /* 82261954h */ case    8:  		/* bc 4, CR6_LT, 20 */
		/* 82261954h case    8:*/		if ( !regs.CR[6].lt ) { return 0x82261968;  }
		/* 82261954h case    8:*/		return 0x82261958;
		  /* 82261958h */ case    9:  		/* lwz R10, <#[R9 + 8]> */
		/* 82261958h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000008) );
		/* 82261958h case    9:*/		return 0x8226195C;
		  /* 8226195Ch */ case   10:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8226195Ch case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8226195Ch case   10:*/		return 0x82261960;
		  /* 82261960h */ case   11:  		/* add R11, R11, R10 */
		/* 82261960h case   11:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82261960h case   11:*/		return 0x82261964;
		  /* 82261964h */ case   12:  		/* b 8 */
		/* 82261964h case   12:*/		return 0x8226196C;
		/* 82261964h case   12:*/		return 0x82261968;
	}
	return 0x82261968;
} // Block from 82261934h-82261968h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82261968h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261968( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261968) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261968);
		  /* 82261968h */ case    0:  		/* li R11, 0 */
		/* 82261968h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82261968h case    0:*/		return 0x8226196C;
	}
	return 0x8226196C;
} // Block from 82261968h-8226196Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226196Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226196C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226196C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226196C);
		  /* 8226196Ch */ case    0:  		/* lwz R11, <#[R11]> */
		/* 8226196Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8226196Ch case    0:*/		return 0x82261970;
		  /* 82261970h */ case    1:  		/* lwz R27, <#[R1 + 188]> */
		/* 82261970h case    1:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x000000BC) );
		/* 82261970h case    1:*/		return 0x82261974;
		  /* 82261974h */ case    2:  		/* lwz R11, <#[R11 + 52]> */
		/* 82261974h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000034) );
		/* 82261974h case    2:*/		return 0x82261978;
		  /* 82261978h */ case    3:  		/* cmpw CR6, R11, R27 */
		/* 82261978h case    3:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R27);
		/* 82261978h case    3:*/		return 0x8226197C;
		  /* 8226197Ch */ case    4:  		/* bc 12, CR6_LT, 120 */
		/* 8226197Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x822619F4;  }
		/* 8226197Ch case    4:*/		return 0x82261980;
		  /* 82261980h */ case    5:  		/* lwz R11, <#[R31 + 12]> */
		/* 82261980h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82261980h case    5:*/		return 0x82261984;
		  /* 82261984h */ case    6:  		/* li R3, 140 */
		/* 82261984h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x8C);
		/* 82261984h case    6:*/		return 0x82261988;
		  /* 82261988h */ case    7:  		/* lwz R29, <#[R28 + 156]> */
		/* 82261988h case    7:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R28 + 0x0000009C) );
		/* 82261988h case    7:*/		return 0x8226198C;
		  /* 8226198Ch */ case    8:  		/* lwz R4, <#[R11 + 1452]> */
		/* 8226198Ch case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005AC) );
		/* 8226198Ch case    8:*/		return 0x82261990;
		  /* 82261990h */ case    9:  		/* bl -29344 */
		/* 82261990h case    9:*/		regs.LR = 0x82261994; return 0x8225A6F0;
		/* 82261990h case    9:*/		return 0x82261994;
		  /* 82261994h */ case   10:  		/* cmplwi CR0, R3, 0 */
		/* 82261994h case   10:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82261994h case   10:*/		return 0x82261998;
		  /* 82261998h */ case   11:  		/* bc 12, CR0_EQ, 24 */
		/* 82261998h case   11:*/		if ( regs.CR[0].eq ) { return 0x822619B0;  }
		/* 82261998h case   11:*/		return 0x8226199C;
		  /* 8226199Ch */ case   12:  		/* mr R4, R29 */
		/* 8226199Ch case   12:*/		regs.R4 = regs.R29;
		/* 8226199Ch case   12:*/		return 0x822619A0;
		  /* 822619A0h */ case   13:  		/* lwz R5, <#[R31 + 12]> */
		/* 822619A0h case   13:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000000C) );
		/* 822619A0h case   13:*/		return 0x822619A4;
		  /* 822619A4h */ case   14:  		/* bl -31900 */
		/* 822619A4h case   14:*/		regs.LR = 0x822619A8; return 0x82259D08;
		/* 822619A4h case   14:*/		return 0x822619A8;
		  /* 822619A8h */ case   15:  		/* mr R30, R3 */
		/* 822619A8h case   15:*/		regs.R30 = regs.R3;
		/* 822619A8h case   15:*/		return 0x822619AC;
		  /* 822619ACh */ case   16:  		/* b 8 */
		/* 822619ACh case   16:*/		return 0x822619B4;
		/* 822619ACh case   16:*/		return 0x822619B0;
	}
	return 0x822619B0;
} // Block from 8226196Ch-822619B0h (17 instructions)

//////////////////////////////////////////////////////
// Block at 822619B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822619B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822619B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822619B0);
		  /* 822619B0h */ case    0:  		/* li R30, 0 */
		/* 822619B0h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 822619B0h case    0:*/		return 0x822619B4;
	}
	return 0x822619B4;
} // Block from 822619B0h-822619B4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822619B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822619B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822619B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822619B4);
		  /* 822619B4h */ case    0:  		/* stw R27, <#[R30 + 52]> */
		/* 822619B4h case    0:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R30 + 0x00000034) );
		/* 822619B4h case    0:*/		return 0x822619B8;
		  /* 822619B8h */ case    1:  		/* mr R5, R30 */
		/* 822619B8h case    1:*/		regs.R5 = regs.R30;
		/* 822619B8h case    1:*/		return 0x822619BC;
		  /* 822619BCh */ case    2:  		/* lwz R27, <#[R1 + 160]> */
		/* 822619BCh case    2:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x000000A0) );
		/* 822619BCh case    2:*/		return 0x822619C0;
		  /* 822619C0h */ case    3:  		/* mr R3, R31 */
		/* 822619C0h case    3:*/		regs.R3 = regs.R31;
		/* 822619C0h case    3:*/		return 0x822619C4;
		  /* 822619C4h */ case    4:  		/* mr R4, R27 */
		/* 822619C4h case    4:*/		regs.R4 = regs.R27;
		/* 822619C4h case    4:*/		return 0x822619C8;
		  /* 822619C8h */ case    5:  		/* bl -179568 */
		/* 822619C8h case    5:*/		regs.LR = 0x822619CC; return 0x82235C58;
		/* 822619C8h case    5:*/		return 0x822619CC;
		  /* 822619CCh */ case    6:  		/* mr R4, R30 */
		/* 822619CCh case    6:*/		regs.R4 = regs.R30;
		/* 822619CCh case    6:*/		return 0x822619D0;
		  /* 822619D0h */ case    7:  		/* mr R3, R27 */
		/* 822619D0h case    7:*/		regs.R3 = regs.R27;
		/* 822619D0h case    7:*/		return 0x822619D4;
		  /* 822619D4h */ case    8:  		/* bl -33028 */
		/* 822619D4h case    8:*/		regs.LR = 0x822619D8; return 0x822598D0;
		/* 822619D4h case    8:*/		return 0x822619D8;
		  /* 822619D8h */ case    9:  		/* mr R4, R29 */
		/* 822619D8h case    9:*/		regs.R4 = regs.R29;
		/* 822619D8h case    9:*/		return 0x822619DC;
		  /* 822619DCh */ case   10:  		/* mr R3, R30 */
		/* 822619DCh case   10:*/		regs.R3 = regs.R30;
		/* 822619DCh case   10:*/		return 0x822619E0;
		  /* 822619E0h */ case   11:  		/* bl -33040 */
		/* 822619E0h case   11:*/		regs.LR = 0x822619E4; return 0x822598D0;
		/* 822619E0h case   11:*/		return 0x822619E4;
		  /* 822619E4h */ case   12:  		/* li R11, 1 */
		/* 822619E4h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 822619E4h case   12:*/		return 0x822619E8;
		  /* 822619E8h */ case   13:  		/* stw R30, <#[R1 + 160]> */
		/* 822619E8h case   13:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x000000A0) );
		/* 822619E8h case   13:*/		return 0x822619EC;
		  /* 822619ECh */ case   14:  		/* stb R11, <#[R28 + 140]> */
		/* 822619ECh case   14:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R28 + 0x0000008C) );
		/* 822619ECh case   14:*/		return 0x822619F0;
		  /* 822619F0h */ case   15:  		/* b 976 */
		/* 822619F0h case   15:*/		return 0x82261DC0;
		/* 822619F0h case   15:*/		return 0x822619F4;
	}
	return 0x822619F4;
} // Block from 822619B4h-822619F4h (16 instructions)

//////////////////////////////////////////////////////
// Block at 822619F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822619F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822619F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822619F4);
		  /* 822619F4h */ case    0:  		/* lwz R11, <#[R1 + 136]> */
		/* 822619F4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000088) );
		/* 822619F4h case    0:*/		return 0x822619F8;
		  /* 822619F8h */ case    1:  		/* li R6, 0 */
		/* 822619F8h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 822619F8h case    1:*/		return 0x822619FC;
		  /* 822619FCh */ case    2:  		/* addi R7, R11, -24 */
		/* 822619FCh case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFE8);
		/* 822619FCh case    2:*/		return 0x82261A00;
		  /* 82261A00h */ case    3:  		/* b -4744 */
		/* 82261A00h case    3:*/		return 0x82260778;
		/* 82261A00h case    3:*/		return 0x82261A04;
		  /* 82261A04h */ case    4:  		/* lwz R11, <#[R1 + 164]> */
		/* 82261A04h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000A4) );
		/* 82261A04h case    4:*/		return 0x82261A08;
		  /* 82261A08h */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 82261A08h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82261A08h case    5:*/		return 0x82261A0C;
		  /* 82261A0Ch */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 82261A0Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82261A0Ch case    6:*/		return 0x82261A10;
		  /* 82261A10h */ case    7:  		/* bc 12, CR6_EQ, 944 */
		/* 82261A10h case    7:*/		if ( regs.CR[6].eq ) { return 0x82261DC0;  }
		/* 82261A10h case    7:*/		return 0x82261A14;
		  /* 82261A14h */ case    8:  		/* lwz R9, <#[R1 + 220]> */
		/* 82261A14h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x000000DC) );
		/* 82261A14h case    8:*/		return 0x82261A18;
		  /* 82261A18h */ case    9:  		/* lwz R11, <#[R9 + 4]> */
		/* 82261A18h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 82261A18h case    9:*/		return 0x82261A1C;
		  /* 82261A1Ch */ case   10:  		/* cmplwi CR6, R11, 0 */
		/* 82261A1Ch case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82261A1Ch case   10:*/		return 0x82261A20;
		  /* 82261A20h */ case   11:  		/* bc 12, CR6_EQ, 220 */
		/* 82261A20h case   11:*/		if ( regs.CR[6].eq ) { return 0x82261AFC;  }
		/* 82261A20h case   11:*/		return 0x82261A24;
		  /* 82261A24h */ case   12:  		/* rlwinm R10, R11, 0, 0, 31 */
		/* 82261A24h case   12:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R11);
		/* 82261A24h case   12:*/		return 0x82261A28;
		  /* 82261A28h */ case   13:  		/* addi R11, R10, -1 */
		/* 82261A28h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0xFFFFFFFF);
		/* 82261A28h case   13:*/		return 0x82261A2C;
		  /* 82261A2Ch */ case   14:  		/* cmplw CR6, R11, R10 */
		/* 82261A2Ch case   14:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82261A2Ch case   14:*/		return 0x82261A30;
		  /* 82261A30h */ case   15:  		/* bc 4, CR6_LT, 20 */
		/* 82261A30h case   15:*/		if ( !regs.CR[6].lt ) { return 0x82261A44;  }
		/* 82261A30h case   15:*/		return 0x82261A34;
		  /* 82261A34h */ case   16:  		/* lwz R10, <#[R9 + 8]> */
		/* 82261A34h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000008) );
		/* 82261A34h case   16:*/		return 0x82261A38;
		  /* 82261A38h */ case   17:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82261A38h case   17:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82261A38h case   17:*/		return 0x82261A3C;
		  /* 82261A3Ch */ case   18:  		/* add R11, R11, R10 */
		/* 82261A3Ch case   18:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82261A3Ch case   18:*/		return 0x82261A40;
		  /* 82261A40h */ case   19:  		/* b 8 */
		/* 82261A40h case   19:*/		return 0x82261A48;
		/* 82261A40h case   19:*/		return 0x82261A44;
	}
	return 0x82261A44;
} // Block from 822619F4h-82261A44h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82261A44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261A44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261A44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261A44);
		  /* 82261A44h */ case    0:  		/* li R11, 0 */
		/* 82261A44h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82261A44h case    0:*/		return 0x82261A48;
	}
	return 0x82261A48;
} // Block from 82261A44h-82261A48h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82261A48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261A48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261A48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261A48);
		  /* 82261A48h */ case    0:  		/* lwz R11, <#[R11]> */
		/* 82261A48h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82261A48h case    0:*/		return 0x82261A4C;
		  /* 82261A4Ch */ case    1:  		/* lwz R27, <#[R1 + 188]> */
		/* 82261A4Ch case    1:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x000000BC) );
		/* 82261A4Ch case    1:*/		return 0x82261A50;
		  /* 82261A50h */ case    2:  		/* lwz R11, <#[R11 + 52]> */
		/* 82261A50h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000034) );
		/* 82261A50h case    2:*/		return 0x82261A54;
		  /* 82261A54h */ case    3:  		/* cmpw CR6, R11, R27 */
		/* 82261A54h case    3:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R27);
		/* 82261A54h case    3:*/		return 0x82261A58;
		  /* 82261A58h */ case    4:  		/* bc 12, CR6_LT, 164 */
		/* 82261A58h case    4:*/		if ( regs.CR[6].lt ) { return 0x82261AFC;  }
		/* 82261A58h case    4:*/		return 0x82261A5C;
		  /* 82261A5Ch */ case    5:  		/* lwz R9, <#[R1 + 164]> */
		/* 82261A5Ch case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x000000A4) );
		/* 82261A5Ch case    5:*/		return 0x82261A60;
		  /* 82261A60h */ case    6:  		/* lwz R10, <#[R9 + 4]> */
		/* 82261A60h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000004) );
		/* 82261A60h case    6:*/		return 0x82261A64;
		  /* 82261A64h */ case    7:  		/* addi R11, R10, -1 */
		/* 82261A64h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0xFFFFFFFF);
		/* 82261A64h case    7:*/		return 0x82261A68;
		  /* 82261A68h */ case    8:  		/* cmplw CR6, R11, R10 */
		/* 82261A68h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82261A68h case    8:*/		return 0x82261A6C;
		  /* 82261A6Ch */ case    9:  		/* bc 4, CR6_LT, 20 */
		/* 82261A6Ch case    9:*/		if ( !regs.CR[6].lt ) { return 0x82261A80;  }
		/* 82261A6Ch case    9:*/		return 0x82261A70;
		  /* 82261A70h */ case   10:  		/* lwz R10, <#[R9 + 8]> */
		/* 82261A70h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000008) );
		/* 82261A70h case   10:*/		return 0x82261A74;
		  /* 82261A74h */ case   11:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82261A74h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82261A74h case   11:*/		return 0x82261A78;
		  /* 82261A78h */ case   12:  		/* add R11, R11, R10 */
		/* 82261A78h case   12:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82261A78h case   12:*/		return 0x82261A7C;
		  /* 82261A7Ch */ case   13:  		/* b 8 */
		/* 82261A7Ch case   13:*/		return 0x82261A84;
		/* 82261A7Ch case   13:*/		return 0x82261A80;
	}
	return 0x82261A80;
} // Block from 82261A48h-82261A80h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82261A80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261A80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261A80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261A80);
		  /* 82261A80h */ case    0:  		/* li R11, 0 */
		/* 82261A80h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82261A80h case    0:*/		return 0x82261A84;
	}
	return 0x82261A84;
} // Block from 82261A80h-82261A84h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82261A84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261A84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261A84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261A84);
		  /* 82261A84h */ case    0:  		/* lwz R10, <#[R31 + 12]> */
		/* 82261A84h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 82261A84h case    0:*/		return 0x82261A88;
		  /* 82261A88h */ case    1:  		/* li R3, 140 */
		/* 82261A88h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x8C);
		/* 82261A88h case    1:*/		return 0x82261A8C;
		  /* 82261A8Ch */ case    2:  		/* lwz R28, <#[R11]> */
		/* 82261A8Ch case    2:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x00000000) );
		/* 82261A8Ch case    2:*/		return 0x82261A90;
		  /* 82261A90h */ case    3:  		/* lwz R4, <#[R10 + 1452]> */
		/* 82261A90h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x000005AC) );
		/* 82261A90h case    3:*/		return 0x82261A94;
		  /* 82261A94h */ case    4:  		/* lwz R29, <#[R28 + 152]> */
		/* 82261A94h case    4:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R28 + 0x00000098) );
		/* 82261A94h case    4:*/		return 0x82261A98;
		  /* 82261A98h */ case    5:  		/* bl -29608 */
		/* 82261A98h case    5:*/		regs.LR = 0x82261A9C; return 0x8225A6F0;
		/* 82261A98h case    5:*/		return 0x82261A9C;
		  /* 82261A9Ch */ case    6:  		/* cmplwi CR0, R3, 0 */
		/* 82261A9Ch case    6:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82261A9Ch case    6:*/		return 0x82261AA0;
		  /* 82261AA0h */ case    7:  		/* bc 12, CR0_EQ, 24 */
		/* 82261AA0h case    7:*/		if ( regs.CR[0].eq ) { return 0x82261AB8;  }
		/* 82261AA0h case    7:*/		return 0x82261AA4;
		  /* 82261AA4h */ case    8:  		/* mr R4, R29 */
		/* 82261AA4h case    8:*/		regs.R4 = regs.R29;
		/* 82261AA4h case    8:*/		return 0x82261AA8;
		  /* 82261AA8h */ case    9:  		/* lwz R5, <#[R31 + 12]> */
		/* 82261AA8h case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000000C) );
		/* 82261AA8h case    9:*/		return 0x82261AAC;
		  /* 82261AACh */ case   10:  		/* bl -32068 */
		/* 82261AACh case   10:*/		regs.LR = 0x82261AB0; return 0x82259D68;
		/* 82261AACh case   10:*/		return 0x82261AB0;
		  /* 82261AB0h */ case   11:  		/* mr R30, R3 */
		/* 82261AB0h case   11:*/		regs.R30 = regs.R3;
		/* 82261AB0h case   11:*/		return 0x82261AB4;
		  /* 82261AB4h */ case   12:  		/* b 8 */
		/* 82261AB4h case   12:*/		return 0x82261ABC;
		/* 82261AB4h case   12:*/		return 0x82261AB8;
	}
	return 0x82261AB8;
} // Block from 82261A84h-82261AB8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82261AB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261AB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261AB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261AB8);
		  /* 82261AB8h */ case    0:  		/* li R30, 0 */
		/* 82261AB8h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82261AB8h case    0:*/		return 0x82261ABC;
	}
	return 0x82261ABC;
} // Block from 82261AB8h-82261ABCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82261ABCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261ABC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261ABC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261ABC);
		  /* 82261ABCh */ case    0:  		/* stw R27, <#[R30 + 52]> */
		/* 82261ABCh case    0:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R30 + 0x00000034) );
		/* 82261ABCh case    0:*/		return 0x82261AC0;
		  /* 82261AC0h */ case    1:  		/* mr R5, R30 */
		/* 82261AC0h case    1:*/		regs.R5 = regs.R30;
		/* 82261AC0h case    1:*/		return 0x82261AC4;
		  /* 82261AC4h */ case    2:  		/* lwz R27, <#[R1 + 160]> */
		/* 82261AC4h case    2:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x000000A0) );
		/* 82261AC4h case    2:*/		return 0x82261AC8;
		  /* 82261AC8h */ case    3:  		/* mr R3, R31 */
		/* 82261AC8h case    3:*/		regs.R3 = regs.R31;
		/* 82261AC8h case    3:*/		return 0x82261ACC;
		  /* 82261ACCh */ case    4:  		/* mr R4, R27 */
		/* 82261ACCh case    4:*/		regs.R4 = regs.R27;
		/* 82261ACCh case    4:*/		return 0x82261AD0;
		  /* 82261AD0h */ case    5:  		/* bl -179832 */
		/* 82261AD0h case    5:*/		regs.LR = 0x82261AD4; return 0x82235C58;
		/* 82261AD0h case    5:*/		return 0x82261AD4;
		  /* 82261AD4h */ case    6:  		/* mr R4, R30 */
		/* 82261AD4h case    6:*/		regs.R4 = regs.R30;
		/* 82261AD4h case    6:*/		return 0x82261AD8;
		  /* 82261AD8h */ case    7:  		/* mr R3, R27 */
		/* 82261AD8h case    7:*/		regs.R3 = regs.R27;
		/* 82261AD8h case    7:*/		return 0x82261ADC;
		  /* 82261ADCh */ case    8:  		/* bl -33292 */
		/* 82261ADCh case    8:*/		regs.LR = 0x82261AE0; return 0x822598D0;
		/* 82261ADCh case    8:*/		return 0x82261AE0;
		  /* 82261AE0h */ case    9:  		/* mr R4, R29 */
		/* 82261AE0h case    9:*/		regs.R4 = regs.R29;
		/* 82261AE0h case    9:*/		return 0x82261AE4;
		  /* 82261AE4h */ case   10:  		/* mr R3, R30 */
		/* 82261AE4h case   10:*/		regs.R3 = regs.R30;
		/* 82261AE4h case   10:*/		return 0x82261AE8;
		  /* 82261AE8h */ case   11:  		/* bl -33304 */
		/* 82261AE8h case   11:*/		regs.LR = 0x82261AEC; return 0x822598D0;
		/* 82261AE8h case   11:*/		return 0x82261AEC;
		  /* 82261AECh */ case   12:  		/* li R11, 1 */
		/* 82261AECh case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82261AECh case   12:*/		return 0x82261AF0;
		  /* 82261AF0h */ case   13:  		/* stw R30, <#[R1 + 160]> */
		/* 82261AF0h case   13:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x000000A0) );
		/* 82261AF0h case   13:*/		return 0x82261AF4;
		  /* 82261AF4h */ case   14:  		/* stb R11, <#[R28 + 141]> */
		/* 82261AF4h case   14:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R28 + 0x0000008D) );
		/* 82261AF4h case   14:*/		return 0x82261AF8;
		  /* 82261AF8h */ case   15:  		/* b 712 */
		/* 82261AF8h case   15:*/		return 0x82261DC0;
		/* 82261AF8h case   15:*/		return 0x82261AFC;
	}
	return 0x82261AFC;
} // Block from 82261ABCh-82261AFCh (16 instructions)

//////////////////////////////////////////////////////
// Block at 82261AFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261AFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261AFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261AFC);
		  /* 82261AFCh */ case    0:  		/* lwz R7, <#[R1 + 136]> */
		/* 82261AFCh case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000088) );
		/* 82261AFCh case    0:*/		return 0x82261B00;
		  /* 82261B00h */ case    1:  		/* li R6, 0 */
		/* 82261B00h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82261B00h case    1:*/		return 0x82261B04;
		  /* 82261B04h */ case    2:  		/* b -5004 */
		/* 82261B04h case    2:*/		return 0x82260778;
		/* 82261B04h case    2:*/		return 0x82261B08;
		  /* 82261B08h */ case    3:  		/* lwz R11, <#[R31 + 12]> */
		/* 82261B08h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82261B08h case    3:*/		return 0x82261B0C;
		  /* 82261B0Ch */ case    4:  		/* li R3, 12 */
		/* 82261B0Ch case    4:*/		cpu::op::li<0>(regs,&regs.R3,0xC);
		/* 82261B0Ch case    4:*/		return 0x82261B10;
		  /* 82261B10h */ case    5:  		/* lwz R4, <#[R11 + 1456]> */
		/* 82261B10h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 82261B10h case    5:*/		return 0x82261B14;
		  /* 82261B14h */ case    6:  		/* bl -29732 */
		/* 82261B14h case    6:*/		regs.LR = 0x82261B18; return 0x8225A6F0;
		/* 82261B14h case    6:*/		return 0x82261B18;
		  /* 82261B18h */ case    7:  		/* lwz R11, <#[R1 + 140]> */
		/* 82261B18h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000008C) );
		/* 82261B18h case    7:*/		return 0x82261B1C;
		  /* 82261B1Ch */ case    8:  		/* mr R30, R3 */
		/* 82261B1Ch case    8:*/		regs.R30 = regs.R3;
		/* 82261B1Ch case    8:*/		return 0x82261B20;
		  /* 82261B20h */ case    9:  		/* lwz R10, <#[R1 + 144]> */
		/* 82261B20h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000090) );
		/* 82261B20h case    9:*/		return 0x82261B24;
		  /* 82261B24h */ case   10:  		/* addi R11, R11, 1 */
		/* 82261B24h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82261B24h case   10:*/		return 0x82261B28;
		  /* 82261B28h */ case   11:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 82261B28h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 82261B28h case   11:*/		return 0x82261B2C;
		  /* 82261B2Ch */ case   12:  		/* stw R11, <#[R1 + 140]> */
		/* 82261B2Ch case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000008C) );
		/* 82261B2Ch case   12:*/		return 0x82261B30;
		  /* 82261B30h */ case   13:  		/* lwzx R11, <#[R9 + R10]> */
		/* 82261B30h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82261B30h case   13:*/		return 0x82261B34;
		  /* 82261B34h */ case   14:  		/* cmpwi CR6, R11, 87 */
		/* 82261B34h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000057);
		/* 82261B34h case   14:*/		return 0x82261B38;
		  /* 82261B38h */ case   15:  		/* bc 12, CR6_EQ, 244 */
		/* 82261B38h case   15:*/		if ( regs.CR[6].eq ) { return 0x82261C2C;  }
		/* 82261B38h case   15:*/		return 0x82261B3C;
		  /* 82261B3Ch */ case   16:  		/* cmpwi CR6, R11, 93 */
		/* 82261B3Ch case   16:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000005D);
		/* 82261B3Ch case   16:*/		return 0x82261B40;
		  /* 82261B40h */ case   17:  		/* bc 12, CR6_EQ, 180 */
		/* 82261B40h case   17:*/		if ( regs.CR[6].eq ) { return 0x82261BF4;  }
		/* 82261B40h case   17:*/		return 0x82261B44;
		  /* 82261B44h */ case   18:  		/* cmpwi CR6, R11, 94 */
		/* 82261B44h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000005E);
		/* 82261B44h case   18:*/		return 0x82261B48;
		  /* 82261B48h */ case   19:  		/* bc 12, CR6_EQ, 116 */
		/* 82261B48h case   19:*/		if ( regs.CR[6].eq ) { return 0x82261BBC;  }
		/* 82261B48h case   19:*/		return 0x82261B4C;
		  /* 82261B4Ch */ case   20:  		/* cmpwi CR6, R11, 95 */
		/* 82261B4Ch case   20:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000005F);
		/* 82261B4Ch case   20:*/		return 0x82261B50;
		  /* 82261B50h */ case   21:  		/* bc 12, CR6_EQ, 40 */
		/* 82261B50h case   21:*/		if ( regs.CR[6].eq ) { return 0x82261B78;  }
		/* 82261B50h case   21:*/		return 0x82261B54;
		  /* 82261B54h */ case   22:  		/* li R11, 0 */
		/* 82261B54h case   22:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82261B54h case   22:*/		return 0x82261B58;
		  /* 82261B58h */ case   23:  		/* lwz R6, <#[R1 + 128]> */
		/* 82261B58h case   23:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 82261B58h case   23:*/		return 0x82261B5C;
		  /* 82261B5Ch */ case   24:  		/* li R7, 4159 */
		/* 82261B5Ch case   24:*/		cpu::op::li<0>(regs,&regs.R7,0x103F);
		/* 82261B5Ch case   24:*/		return 0x82261B60;
		  /* 82261B60h */ case   25:  		/* lwz R5, <#[R1 + 196]> */
		/* 82261B60h case   25:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000000C4) );
		/* 82261B60h case   25:*/		return 0x82261B64;
		  /* 82261B64h */ case   26:  		/* stb R11, <#[R3]> */
		/* 82261B64h case   26:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82261B64h case   26:*/		return 0x82261B68;
		  /* 82261B68h */ case   27:  		/* li R3, 0 */
		/* 82261B68h case   27:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82261B68h case   27:*/		return 0x82261B6C;
		  /* 82261B6Ch */ case   28:  		/* lwz R4, <#[R1 + 132]> */
		/* 82261B6Ch case   28:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 82261B6Ch case   28:*/		return 0x82261B70;
		  /* 82261B70h */ case   29:  		/* bl -1089384 */
		/* 82261B70h case   29:*/		regs.LR = 0x82261B74; return 0x82157C08;
		/* 82261B70h case   29:*/		return 0x82261B74;
		  /* 82261B74h */ case   30:  		/* b 200 */
		/* 82261B74h case   30:*/		return 0x82261C3C;
		/* 82261B74h case   30:*/		return 0x82261B78;
	}
	return 0x82261B78;
} // Block from 82261AFCh-82261B78h (31 instructions)

//////////////////////////////////////////////////////
// Block at 82261B78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261B78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261B78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261B78);
		  /* 82261B78h */ case    0:  		/* lwz R29, <#[R31 + 12]> */
		/* 82261B78h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x0000000C) );
		/* 82261B78h case    0:*/		return 0x82261B7C;
		  /* 82261B7Ch */ case    1:  		/* lwz R3, <#[R29 + 1488]> */
		/* 82261B7Ch case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x000005D0) );
		/* 82261B7Ch case    1:*/		return 0x82261B80;
		  /* 82261B80h */ case    2:  		/* lwz R11, <#[R3]> */
		/* 82261B80h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82261B80h case    2:*/		return 0x82261B84;
		  /* 82261B84h */ case    3:  		/* lwz R11, <#[R11 + 28]> */
		/* 82261B84h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 82261B84h case    3:*/		return 0x82261B88;
		  /* 82261B88h */ case    4:  		/* mtspr CTR, R11 */
		/* 82261B88h case    4:*/		regs.CTR = regs.R11;
		/* 82261B88h case    4:*/		return 0x82261B8C;
		  /* 82261B8Ch */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 82261B8Ch case    5:*/		if ( 1 ) { regs.LR = 0x82261B90; return (uint32)regs.CTR; }
		/* 82261B8Ch case    5:*/		return 0x82261B90;
		  /* 82261B90h */ case    6:  		/* lis R11, -32222 */
		/* 82261B90h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 82261B90h case    6:*/		return 0x82261B94;
		  /* 82261B94h */ case    7:  		/* mr R5, R3 */
		/* 82261B94h case    7:*/		regs.R5 = regs.R3;
		/* 82261B94h case    7:*/		return 0x82261B98;
		  /* 82261B98h */ case    8:  		/* lwz R3, <#[R31 + 16]> */
		/* 82261B98h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 82261B98h case    8:*/		return 0x82261B9C;
		  /* 82261B9Ch */ case    9:  		/* li R4, 0 */
		/* 82261B9Ch case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82261B9Ch case    9:*/		return 0x82261BA0;
		  /* 82261BA0h */ case   10:  		/* addi R6, R11, -12392 */
		/* 82261BA0h case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 82261BA0h case   10:*/		return 0x82261BA4;
		  /* 82261BA4h */ case   11:  		/* mr R7, R29 */
		/* 82261BA4h case   11:*/		regs.R7 = regs.R29;
		/* 82261BA4h case   11:*/		return 0x82261BA8;
		  /* 82261BA8h */ case   12:  		/* bl -195480 */
		/* 82261BA8h case   12:*/		regs.LR = 0x82261BAC; return 0x82232010;
		/* 82261BA8h case   12:*/		return 0x82261BAC;
		  /* 82261BACh */ case   13:  		/* addi R11, R3, -1 */
		/* 82261BACh case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0xFFFFFFFF);
		/* 82261BACh case   13:*/		return 0x82261BB0;
		  /* 82261BB0h */ case   14:  		/* cntlzw R11, R11 */
		/* 82261BB0h case   14:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 82261BB0h case   14:*/		return 0x82261BB4;
		  /* 82261BB4h */ case   15:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 82261BB4h case   15:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 82261BB4h case   15:*/		return 0x82261BB8;
		  /* 82261BB8h */ case   16:  		/* b 128 */
		/* 82261BB8h case   16:*/		return 0x82261C38;
		/* 82261BB8h case   16:*/		return 0x82261BBC;
	}
	return 0x82261BBC;
} // Block from 82261B78h-82261BBCh (17 instructions)

//////////////////////////////////////////////////////
// Block at 82261BBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261BBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261BBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261BBC);
		  /* 82261BBCh */ case    0:  		/* lwz R29, <#[R31 + 12]> */
		/* 82261BBCh case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x0000000C) );
		/* 82261BBCh case    0:*/		return 0x82261BC0;
		  /* 82261BC0h */ case    1:  		/* lwz R3, <#[R29 + 1488]> */
		/* 82261BC0h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x000005D0) );
		/* 82261BC0h case    1:*/		return 0x82261BC4;
		  /* 82261BC4h */ case    2:  		/* lwz R11, <#[R3]> */
		/* 82261BC4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82261BC4h case    2:*/		return 0x82261BC8;
		  /* 82261BC8h */ case    3:  		/* lwz R11, <#[R11 + 28]> */
		/* 82261BC8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 82261BC8h case    3:*/		return 0x82261BCC;
		  /* 82261BCCh */ case    4:  		/* mtspr CTR, R11 */
		/* 82261BCCh case    4:*/		regs.CTR = regs.R11;
		/* 82261BCCh case    4:*/		return 0x82261BD0;
		  /* 82261BD0h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 82261BD0h case    5:*/		if ( 1 ) { regs.LR = 0x82261BD4; return (uint32)regs.CTR; }
		/* 82261BD0h case    5:*/		return 0x82261BD4;
		  /* 82261BD4h */ case    6:  		/* lis R11, -32222 */
		/* 82261BD4h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 82261BD4h case    6:*/		return 0x82261BD8;
		  /* 82261BD8h */ case    7:  		/* mr R5, R3 */
		/* 82261BD8h case    7:*/		regs.R5 = regs.R3;
		/* 82261BD8h case    7:*/		return 0x82261BDC;
		  /* 82261BDCh */ case    8:  		/* lwz R3, <#[R31 + 16]> */
		/* 82261BDCh case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 82261BDCh case    8:*/		return 0x82261BE0;
		  /* 82261BE0h */ case    9:  		/* li R4, 0 */
		/* 82261BE0h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82261BE0h case    9:*/		return 0x82261BE4;
		  /* 82261BE4h */ case   10:  		/* addi R6, R11, -12392 */
		/* 82261BE4h case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 82261BE4h case   10:*/		return 0x82261BE8;
		  /* 82261BE8h */ case   11:  		/* mr R7, R29 */
		/* 82261BE8h case   11:*/		regs.R7 = regs.R29;
		/* 82261BE8h case   11:*/		return 0x82261BEC;
		  /* 82261BECh */ case   12:  		/* bl -195844 */
		/* 82261BECh case   12:*/		regs.LR = 0x82261BF0; return 0x82231EE8;
		/* 82261BECh case   12:*/		return 0x82261BF0;
		  /* 82261BF0h */ case   13:  		/* b -68 */
		/* 82261BF0h case   13:*/		return 0x82261BAC;
		/* 82261BF0h case   13:*/		return 0x82261BF4;
	}
	return 0x82261BF4;
} // Block from 82261BBCh-82261BF4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82261BF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261BF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261BF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261BF4);
		  /* 82261BF4h */ case    0:  		/* lwz R29, <#[R31 + 12]> */
		/* 82261BF4h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x0000000C) );
		/* 82261BF4h case    0:*/		return 0x82261BF8;
		  /* 82261BF8h */ case    1:  		/* lwz R3, <#[R29 + 1488]> */
		/* 82261BF8h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x000005D0) );
		/* 82261BF8h case    1:*/		return 0x82261BFC;
		  /* 82261BFCh */ case    2:  		/* lwz R11, <#[R3]> */
		/* 82261BFCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82261BFCh case    2:*/		return 0x82261C00;
		  /* 82261C00h */ case    3:  		/* lwz R11, <#[R11 + 28]> */
		/* 82261C00h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 82261C00h case    3:*/		return 0x82261C04;
		  /* 82261C04h */ case    4:  		/* mtspr CTR, R11 */
		/* 82261C04h case    4:*/		regs.CTR = regs.R11;
		/* 82261C04h case    4:*/		return 0x82261C08;
		  /* 82261C08h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 82261C08h case    5:*/		if ( 1 ) { regs.LR = 0x82261C0C; return (uint32)regs.CTR; }
		/* 82261C08h case    5:*/		return 0x82261C0C;
		  /* 82261C0Ch */ case    6:  		/* lis R11, -32222 */
		/* 82261C0Ch case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8222);
		/* 82261C0Ch case    6:*/		return 0x82261C10;
		  /* 82261C10h */ case    7:  		/* mr R5, R3 */
		/* 82261C10h case    7:*/		regs.R5 = regs.R3;
		/* 82261C10h case    7:*/		return 0x82261C14;
		  /* 82261C14h */ case    8:  		/* lwz R3, <#[R31 + 16]> */
		/* 82261C14h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 82261C14h case    8:*/		return 0x82261C18;
		  /* 82261C18h */ case    9:  		/* li R4, 0 */
		/* 82261C18h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82261C18h case    9:*/		return 0x82261C1C;
		  /* 82261C1Ch */ case   10:  		/* addi R6, R11, -12392 */
		/* 82261C1Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFCF98);
		/* 82261C1Ch case   10:*/		return 0x82261C20;
		  /* 82261C20h */ case   11:  		/* mr R7, R29 */
		/* 82261C20h case   11:*/		regs.R7 = regs.R29;
		/* 82261C20h case   11:*/		return 0x82261C24;
		  /* 82261C24h */ case   12:  		/* bl -196188 */
		/* 82261C24h case   12:*/		regs.LR = 0x82261C28; return 0x82231DC8;
		/* 82261C24h case   12:*/		return 0x82261C28;
		  /* 82261C28h */ case   13:  		/* b -124 */
		/* 82261C28h case   13:*/		return 0x82261BAC;
		/* 82261C28h case   13:*/		return 0x82261C2C;
	}
	return 0x82261C2C;
} // Block from 82261BF4h-82261C2Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 82261C2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261C2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261C2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261C2C);
		  /* 82261C2Ch */ case    0:  		/* lwz R11, <#[R1 + 176]> */
		/* 82261C2Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000B0) );
		/* 82261C2Ch case    0:*/		return 0x82261C30;
		  /* 82261C30h */ case    1:  		/* lbz R11, <#[R11]> */
		/* 82261C30h case    1:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82261C30h case    1:*/		return 0x82261C34;
		  /* 82261C34h */ case    2:  		/* rlwinm R11, R11, 0, 31, 31 */
		/* 82261C34h case    2:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82261C34h case    2:*/		return 0x82261C38;
	}
	return 0x82261C38;
} // Block from 82261C2Ch-82261C38h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82261C38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261C38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261C38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261C38);
		  /* 82261C38h */ case    0:  		/* stb R11, <#[R30]> */
		/* 82261C38h case    0:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82261C38h case    0:*/		return 0x82261C3C;
	}
	return 0x82261C3C;
} // Block from 82261C38h-82261C3Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82261C3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261C3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261C3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261C3C);
		  /* 82261C3Ch */ case    0:  		/* lwz R3, <#[R1 + 156]> */
		/* 82261C3Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x0000009C) );
		/* 82261C3Ch case    0:*/		return 0x82261C40;
		  /* 82261C40h */ case    1:  		/* lwz R4, <#[R3 + 4]> */
		/* 82261C40h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 82261C40h case    1:*/		return 0x82261C44;
		  /* 82261C44h */ case    2:  		/* bl -57732 */
		/* 82261C44h case    2:*/		regs.LR = 0x82261C48; return 0x82253AC0;
		/* 82261C44h case    2:*/		return 0x82261C48;
		  /* 82261C48h */ case    3:  		/* stw R30, <#[R3]> */
		/* 82261C48h case    3:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 82261C48h case    3:*/		return 0x82261C4C;
		  /* 82261C4Ch */ case    4:  		/* b 372 */
		/* 82261C4Ch case    4:*/		return 0x82261DC0;
		/* 82261C4Ch case    4:*/		return 0x82261C50;
		  /* 82261C50h */ case    5:  		/* lwz R8, <#[R1 + 156]> */
		/* 82261C50h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x0000009C) );
		/* 82261C50h case    5:*/		return 0x82261C54;
		  /* 82261C54h */ case    6:  		/* lwz R10, <#[R8 + 4]> */
		/* 82261C54h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000004) );
		/* 82261C54h case    6:*/		return 0x82261C58;
		  /* 82261C58h */ case    7:  		/* addi R11, R10, -1 */
		/* 82261C58h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0xFFFFFFFF);
		/* 82261C58h case    7:*/		return 0x82261C5C;
		  /* 82261C5Ch */ case    8:  		/* cmplw CR6, R11, R10 */
		/* 82261C5Ch case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82261C5Ch case    8:*/		return 0x82261C60;
		  /* 82261C60h */ case    9:  		/* bc 4, CR6_LT, 20 */
		/* 82261C60h case    9:*/		if ( !regs.CR[6].lt ) { return 0x82261C74;  }
		/* 82261C60h case    9:*/		return 0x82261C64;
		  /* 82261C64h */ case   10:  		/* lwz R10, <#[R8 + 8]> */
		/* 82261C64h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000008) );
		/* 82261C64h case   10:*/		return 0x82261C68;
		  /* 82261C68h */ case   11:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82261C68h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82261C68h case   11:*/		return 0x82261C6C;
		  /* 82261C6Ch */ case   12:  		/* add R11, R10, R11 */
		/* 82261C6Ch case   12:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82261C6Ch case   12:*/		return 0x82261C70;
		  /* 82261C70h */ case   13:  		/* b 8 */
		/* 82261C70h case   13:*/		return 0x82261C78;
		/* 82261C70h case   13:*/		return 0x82261C74;
	}
	return 0x82261C74;
} // Block from 82261C3Ch-82261C74h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82261C74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261C74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261C74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261C74);
		  /* 82261C74h */ case    0:  		/* li R11, 0 */
		/* 82261C74h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82261C74h case    0:*/		return 0x82261C78;
	}
	return 0x82261C78;
} // Block from 82261C74h-82261C78h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82261C78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261C78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261C78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261C78);
		  /* 82261C78h */ case    0:  		/* lwz R11, <#[R11]> */
		/* 82261C78h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82261C78h case    0:*/		return 0x82261C7C;
		  /* 82261C7Ch */ case    1:  		/* lbz R11, <#[R11]> */
		/* 82261C7Ch case    1:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82261C7Ch case    1:*/		return 0x82261C80;
		  /* 82261C80h */ case    2:  		/* cmplwi CR0, R11, 0 */
		/* 82261C80h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82261C80h case    2:*/		return 0x82261C84;
		  /* 82261C84h */ case    3:  		/* bc 4, CR0_EQ, 316 */
		/* 82261C84h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82261DC0;  }
		/* 82261C84h case    3:*/		return 0x82261C88;
		  /* 82261C88h */ case    4:  		/* mr R11, R9 */
		/* 82261C88h case    4:*/		regs.R11 = regs.R9;
		/* 82261C88h case    4:*/		return 0x82261C8C;
		  /* 82261C8Ch */ case    5:  		/* lwz R9, <#[R1 + 140]> */
		/* 82261C8Ch case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x0000008C) );
		/* 82261C8Ch case    5:*/		return 0x82261C90;
		  /* 82261C90h */ case    6:  		/* lwz R10, <#[R11]> */
		/* 82261C90h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82261C90h case    6:*/		return 0x82261C94;
		  /* 82261C94h */ case    7:  		/* cmplwi CR6, R10, 51 */
		/* 82261C94h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000033);
		/* 82261C94h case    7:*/		return 0x82261C98;
		  /* 82261C98h */ case    8:  		/* bc 4, CR6_EQ, 12 */
		/* 82261C98h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82261CA4;  }
		/* 82261C98h case    8:*/		return 0x82261C9C;
		  /* 82261C9Ch */ case    9:  		/* addi R9, R9, 1 */
		/* 82261C9Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82261C9Ch case    9:*/		return 0x82261CA0;
		  /* 82261CA0h */ case   10:  		/* addi R11, R11, 4 */
		/* 82261CA0h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82261CA0h case   10:*/		return 0x82261CA4;
	}
	return 0x82261CA4;
} // Block from 82261C78h-82261CA4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82261CA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261CA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261CA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261CA4);
		  /* 82261CA4h */ case    0:  		/* lwzu R10, <#[R11 + 4]> */
		/* 82261CA4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82261CA4h case    0:*/		return 0x82261CA8;
		  /* 82261CA8h */ case    1:  		/* addi R9, R9, 1 */
		/* 82261CA8h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82261CA8h case    1:*/		return 0x82261CAC;
		  /* 82261CACh */ case    2:  		/* cmplwi CR6, R10, 37 */
		/* 82261CACh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000025);
		/* 82261CACh case    2:*/		return 0x82261CB0;
		  /* 82261CB0h */ case    3:  		/* bc 4, CR6_EQ, -32 */
		/* 82261CB0h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82261C90;  }
		/* 82261CB0h case    3:*/		return 0x82261CB4;
		  /* 82261CB4h */ case    4:  		/* addi R11, R9, -1 */
		/* 82261CB4h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0xFFFFFFFF);
		/* 82261CB4h case    4:*/		return 0x82261CB8;
		  /* 82261CB8h */ case    5:  		/* stw R11, <#[R1 + 140]> */
		/* 82261CB8h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000008C) );
		/* 82261CB8h case    5:*/		return 0x82261CBC;
		  /* 82261CBCh */ case    6:  		/* b 260 */
		/* 82261CBCh case    6:*/		return 0x82261DC0;
		/* 82261CBCh case    6:*/		return 0x82261CC0;
		  /* 82261CC0h */ case    7:  		/* lwz R8, <#[R1 + 156]> */
		/* 82261CC0h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x0000009C) );
		/* 82261CC0h case    7:*/		return 0x82261CC4;
		  /* 82261CC4h */ case    8:  		/* lwz R10, <#[R8 + 4]> */
		/* 82261CC4h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000004) );
		/* 82261CC4h case    8:*/		return 0x82261CC8;
		  /* 82261CC8h */ case    9:  		/* addi R11, R10, -1 */
		/* 82261CC8h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0xFFFFFFFF);
		/* 82261CC8h case    9:*/		return 0x82261CCC;
		  /* 82261CCCh */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 82261CCCh case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 82261CCCh case   10:*/		return 0x82261CD0;
		  /* 82261CD0h */ case   11:  		/* bc 4, CR6_LT, 20 */
		/* 82261CD0h case   11:*/		if ( !regs.CR[6].lt ) { return 0x82261CE4;  }
		/* 82261CD0h case   11:*/		return 0x82261CD4;
		  /* 82261CD4h */ case   12:  		/* lwz R10, <#[R8 + 8]> */
		/* 82261CD4h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000008) );
		/* 82261CD4h case   12:*/		return 0x82261CD8;
		  /* 82261CD8h */ case   13:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82261CD8h case   13:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82261CD8h case   13:*/		return 0x82261CDC;
		  /* 82261CDCh */ case   14:  		/* add R11, R10, R11 */
		/* 82261CDCh case   14:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82261CDCh case   14:*/		return 0x82261CE0;
		  /* 82261CE0h */ case   15:  		/* b 8 */
		/* 82261CE0h case   15:*/		return 0x82261CE8;
		/* 82261CE0h case   15:*/		return 0x82261CE4;
	}
	return 0x82261CE4;
} // Block from 82261CA4h-82261CE4h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82261CE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261CE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261CE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261CE4);
		  /* 82261CE4h */ case    0:  		/* li R11, 0 */
		/* 82261CE4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82261CE4h case    0:*/		return 0x82261CE8;
	}
	return 0x82261CE8;
} // Block from 82261CE4h-82261CE8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82261CE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261CE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261CE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261CE8);
		  /* 82261CE8h */ case    0:  		/* lwz R11, <#[R11]> */
		/* 82261CE8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82261CE8h case    0:*/		return 0x82261CEC;
		  /* 82261CECh */ case    1:  		/* lbz R11, <#[R11]> */
		/* 82261CECh case    1:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82261CECh case    1:*/		return 0x82261CF0;
		  /* 82261CF0h */ case    2:  		/* cmplwi CR0, R11, 0 */
		/* 82261CF0h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82261CF0h case    2:*/		return 0x82261CF4;
		  /* 82261CF4h */ case    3:  		/* bc 12, CR0_EQ, 204 */
		/* 82261CF4h case    3:*/		if ( regs.CR[0].eq ) { return 0x82261DC0;  }
		/* 82261CF4h case    3:*/		return 0x82261CF8;
		  /* 82261CF8h */ case    4:  		/* mr R11, R9 */
		/* 82261CF8h case    4:*/		regs.R11 = regs.R9;
		/* 82261CF8h case    4:*/		return 0x82261CFC;
		  /* 82261CFCh */ case    5:  		/* lwz R9, <#[R1 + 140]> */
		/* 82261CFCh case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x0000008C) );
		/* 82261CFCh case    5:*/		return 0x82261D00;
		  /* 82261D00h */ case    6:  		/* lwz R10, <#[R11]> */
		/* 82261D00h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82261D00h case    6:*/		return 0x82261D04;
		  /* 82261D04h */ case    7:  		/* cmplwi CR6, R10, 51 */
		/* 82261D04h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000033);
		/* 82261D04h case    7:*/		return 0x82261D08;
		  /* 82261D08h */ case    8:  		/* bc 4, CR6_EQ, 12 */
		/* 82261D08h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82261D14;  }
		/* 82261D08h case    8:*/		return 0x82261D0C;
		  /* 82261D0Ch */ case    9:  		/* addi R9, R9, 1 */
		/* 82261D0Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82261D0Ch case    9:*/		return 0x82261D10;
		  /* 82261D10h */ case   10:  		/* addi R11, R11, 4 */
		/* 82261D10h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82261D10h case   10:*/		return 0x82261D14;
	}
	return 0x82261D14;
} // Block from 82261CE8h-82261D14h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82261D14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261D14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261D14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261D14);
		  /* 82261D14h */ case    0:  		/* lwzu R10, <#[R11 + 4]> */
		/* 82261D14h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		regs.R11 = (uint32)(regs.R11 + 0x00000004);
		/* 82261D14h case    0:*/		return 0x82261D18;
		  /* 82261D18h */ case    1:  		/* addi R9, R9, 1 */
		/* 82261D18h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82261D18h case    1:*/		return 0x82261D1C;
		  /* 82261D1Ch */ case    2:  		/* cmplwi CR6, R10, 39 */
		/* 82261D1Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000027);
		/* 82261D1Ch case    2:*/		return 0x82261D20;
		  /* 82261D20h */ case    3:  		/* bc 4, CR6_EQ, -32 */
		/* 82261D20h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82261D00;  }
		/* 82261D20h case    3:*/		return 0x82261D24;
		  /* 82261D24h */ case    4:  		/* b -112 */
		/* 82261D24h case    4:*/		return 0x82261CB4;
		/* 82261D24h case    4:*/		return 0x82261D28;
		  /* 82261D28h */ case    5:  		/* lwz R3, <#[R1 + 156]> */
		/* 82261D28h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x0000009C) );
		/* 82261D28h case    5:*/		return 0x82261D2C;
		  /* 82261D2Ch */ case    6:  		/* bl -28636 */
		/* 82261D2Ch case    6:*/		regs.LR = 0x82261D30; return 0x8225AD50;
		/* 82261D2Ch case    6:*/		return 0x82261D30;
		  /* 82261D30h */ case    7:  		/* cmplwi CR0, R3, 0 */
		/* 82261D30h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82261D30h case    7:*/		return 0x82261D34;
		  /* 82261D34h */ case    8:  		/* bc 12, CR0_EQ, 140 */
		/* 82261D34h case    8:*/		if ( regs.CR[0].eq ) { return 0x82261DC0;  }
		/* 82261D34h case    8:*/		return 0x82261D38;
		  /* 82261D38h */ case    9:  		/* addi R4, R3, -4 */
		/* 82261D38h case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R3,0xFFFFFFFC);
		/* 82261D38h case    9:*/		return 0x82261D3C;
		  /* 82261D3Ch */ case   10:  		/* lwz R3, <#[R3 - 4]> */
		/* 82261D3Ch case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0xFFFFFFFC) );
		/* 82261D3Ch case   10:*/		return 0x82261D40;
		  /* 82261D40h */ case   11:  		/* bl -284416 */
		/* 82261D40h case   11:*/		regs.LR = 0x82261D44; return 0x8221C640;
		/* 82261D40h case   11:*/		return 0x82261D44;
		  /* 82261D44h */ case   12:  		/* b 124 */
		/* 82261D44h case   12:*/		return 0x82261DC0;
		/* 82261D44h case   12:*/		return 0x82261D48;
		  /* 82261D48h */ case   13:  		/* lwz R3, <#[R1 + 148]> */
		/* 82261D48h case   13:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000094) );
		/* 82261D48h case   13:*/		return 0x82261D4C;
		  /* 82261D4Ch */ case   14:  		/* lwz R11, <#[R3 + 4]> */
		/* 82261D4Ch case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82261D4Ch case   14:*/		return 0x82261D50;
		  /* 82261D50h */ case   15:  		/* cmplwi CR6, R11, 0 */
		/* 82261D50h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82261D50h case   15:*/		return 0x82261D54;
		  /* 82261D54h */ case   16:  		/* bc 12, CR6_EQ, 100 */
		/* 82261D54h case   16:*/		if ( regs.CR[6].eq ) { return 0x82261DB8;  }
		/* 82261D54h case   16:*/		return 0x82261D58;
		  /* 82261D58h */ case   17:  		/* bl -28680 */
		/* 82261D58h case   17:*/		regs.LR = 0x82261D5C; return 0x8225AD50;
		/* 82261D58h case   17:*/		return 0x82261D5C;
		  /* 82261D5Ch */ case   18:  		/* lwz R11, <#[R3 + 8]> */
		/* 82261D5Ch case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82261D5Ch case   18:*/		return 0x82261D60;
		  /* 82261D60h */ case   19:  		/* cmplwi CR6, R11, 0 */
		/* 82261D60h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82261D60h case   19:*/		return 0x82261D64;
		  /* 82261D64h */ case   20:  		/* bc 12, CR6_EQ, 8 */
		/* 82261D64h case   20:*/		if ( regs.CR[6].eq ) { return 0x82261D6C;  }
		/* 82261D64h case   20:*/		return 0x82261D68;
		  /* 82261D68h */ case   21:  		/* mr R14, R11 */
		/* 82261D68h case   21:*/		regs.R14 = regs.R11;
		/* 82261D68h case   21:*/		return 0x82261D6C;
	}
	return 0x82261D6C;
} // Block from 82261D14h-82261D6Ch (22 instructions)

//////////////////////////////////////////////////////
// Block at 82261D6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261D6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261D6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261D6C);
		  /* 82261D6Ch */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82261D6Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82261D6Ch case    0:*/		return 0x82261D70;
		  /* 82261D70h */ case    1:  		/* lwz R10, <#[R3 + 4]> */
		/* 82261D70h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 82261D70h case    1:*/		return 0x82261D74;
		  /* 82261D74h */ case    2:  		/* stw R11, <#[R1 + 144]> */
		/* 82261D74h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000090) );
		/* 82261D74h case    2:*/		return 0x82261D78;
		  /* 82261D78h */ case    3:  		/* stw R10, <#[R1 + 140]> */
		/* 82261D78h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x0000008C) );
		/* 82261D78h case    3:*/		return 0x82261D7C;
		  /* 82261D7Ch */ case    4:  		/* b -68 */
		/* 82261D7Ch case    4:*/		return 0x82261D38;
		/* 82261D7Ch case    4:*/		return 0x82261D80;
		  /* 82261D80h */ case    5:  		/* lbz R11, <#[R1 + 192]> */
		/* 82261D80h case    5:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000C0) );
		/* 82261D80h case    5:*/		return 0x82261D84;
		  /* 82261D84h */ case    6:  		/* cmplwi CR0, R11, 0 */
		/* 82261D84h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82261D84h case    6:*/		return 0x82261D88;
		  /* 82261D88h */ case    7:  		/* bc 4, CR0_EQ, 56 */
		/* 82261D88h case    7:*/		if ( !regs.CR[0].eq ) { return 0x82261DC0;  }
		/* 82261D88h case    7:*/		return 0x82261D8C;
		  /* 82261D8Ch */ case    8:  		/* lwz R5, <#[R1 + 412]> */
		/* 82261D8Ch case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x0000019C) );
		/* 82261D8Ch case    8:*/		return 0x82261D90;
		  /* 82261D90h */ case    9:  		/* li R7, 4227 */
		/* 82261D90h case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x1083);
		/* 82261D90h case    9:*/		return 0x82261D94;
		  /* 82261D94h */ case   10:  		/* b -5624 */
		/* 82261D94h case   10:*/		return 0x8226079C;
		/* 82261D94h case   10:*/		return 0x82261D98;
		  /* 82261D98h */ case   11:  		/* li R7, 4233 */
		/* 82261D98h case   11:*/		cpu::op::li<0>(regs,&regs.R7,0x1089);
		/* 82261D98h case   11:*/		return 0x82261D9C;
		  /* 82261D9Ch */ case   12:  		/* b -5636 */
		/* 82261D9Ch case   12:*/		return 0x82260798;
		/* 82261D9Ch case   12:*/		return 0x82261DA0;
	}
	return 0x82261DA0;
} // Block from 82261D6Ch-82261DA0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82261DA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261DA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261DA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261DA0);
		  /* 82261DA0h */ case    0:  		/* li R7, 4238 */
		/* 82261DA0h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x108E);
		/* 82261DA0h case    0:*/		return 0x82261DA4;
		  /* 82261DA4h */ case    1:  		/* lwz R6, <#[R1 + 128]> */
		/* 82261DA4h case    1:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 82261DA4h case    1:*/		return 0x82261DA8;
		  /* 82261DA8h */ case    2:  		/* li R3, 0 */
		/* 82261DA8h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82261DA8h case    2:*/		return 0x82261DAC;
		  /* 82261DACh */ case    3:  		/* lwz R5, <#[R1 + 196]> */
		/* 82261DACh case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000000C4) );
		/* 82261DACh case    3:*/		return 0x82261DB0;
		  /* 82261DB0h */ case    4:  		/* lwz R4, <#[R1 + 132]> */
		/* 82261DB0h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 82261DB0h case    4:*/		return 0x82261DB4;
		  /* 82261DB4h */ case    5:  		/* bl -1089964 */
		/* 82261DB4h case    5:*/		regs.LR = 0x82261DB8; return 0x82157C08;
		/* 82261DB4h case    5:*/		return 0x82261DB8;
	}
	return 0x82261DB8;
} // Block from 82261DA0h-82261DB8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82261DB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261DB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261DB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261DB8);
		  /* 82261DB8h */ case    0:  		/* li R11, 1 */
		/* 82261DB8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82261DB8h case    0:*/		return 0x82261DBC;
		  /* 82261DBCh */ case    1:  		/* stb R11, <#[R1 + 172]> */
		/* 82261DBCh case    1:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x000000AC) );
		/* 82261DBCh case    1:*/		return 0x82261DC0;
	}
	return 0x82261DC0;
} // Block from 82261DB8h-82261DC0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82261DC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261DC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261DC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261DC0);
		  /* 82261DC0h */ case    0:  		/* cmplwi CR6, R15, 0 */
		/* 82261DC0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R15,0x00000000);
		/* 82261DC0h case    0:*/		return 0x82261DC4;
		  /* 82261DC4h */ case    1:  		/* bc 12, CR6_EQ, 132 */
		/* 82261DC4h case    1:*/		if ( regs.CR[6].eq ) { return 0x82261E48;  }
		/* 82261DC4h case    1:*/		return 0x82261DC8;
		  /* 82261DC8h */ case    2:  		/* lwz R11, <#[R15]> */
		/* 82261DC8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000000) );
		/* 82261DC8h case    2:*/		return 0x82261DCC;
		  /* 82261DCCh */ case    3:  		/* mr R3, R15 */
		/* 82261DCCh case    3:*/		regs.R3 = regs.R15;
		/* 82261DCCh case    3:*/		return 0x82261DD0;
		  /* 82261DD0h */ case    4:  		/* lwz R11, <#[R11 + 4]> */
		/* 82261DD0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82261DD0h case    4:*/		return 0x82261DD4;
		  /* 82261DD4h */ case    5:  		/* mtspr CTR, R11 */
		/* 82261DD4h case    5:*/		regs.CTR = regs.R11;
		/* 82261DD4h case    5:*/		return 0x82261DD8;
		  /* 82261DD8h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 82261DD8h case    6:*/		if ( 1 ) { regs.LR = 0x82261DDC; return (uint32)regs.CTR; }
		/* 82261DD8h case    6:*/		return 0x82261DDC;
		  /* 82261DDCh */ case    7:  		/* lwz R11, <#[R1 + 168]> */
		/* 82261DDCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000A8) );
		/* 82261DDCh case    7:*/		return 0x82261DE0;
		  /* 82261DE0h */ case    8:  		/* addi R10, R3, 1 */
		/* 82261DE0h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R3,0x1);
		/* 82261DE0h case    8:*/		return 0x82261DE4;
		  /* 82261DE4h */ case    9:  		/* cmpw CR6, R11, R10 */
		/* 82261DE4h case    9:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 82261DE4h case    9:*/		return 0x82261DE8;
		  /* 82261DE8h */ case   10:  		/* bc 4, CR6_EQ, 96 */
		/* 82261DE8h case   10:*/		if ( !regs.CR[6].eq ) { return 0x82261E48;  }
		/* 82261DE8h case   10:*/		return 0x82261DEC;
		  /* 82261DECh */ case   11:  		/* mr R4, R15 */
		/* 82261DECh case   11:*/		regs.R4 = regs.R15;
		/* 82261DECh case   11:*/		return 0x82261DF0;
		  /* 82261DF0h */ case   12:  		/* mr R3, R31 */
		/* 82261DF0h case   12:*/		regs.R3 = regs.R31;
		/* 82261DF0h case   12:*/		return 0x82261DF4;
		  /* 82261DF4h */ case   13:  		/* bl -178252 */
		/* 82261DF4h case   13:*/		regs.LR = 0x82261DF8; return 0x822365A8;
		/* 82261DF4h case   13:*/		return 0x82261DF8;
		  /* 82261DF8h */ case   14:  		/* mr R4, R15 */
		/* 82261DF8h case   14:*/		regs.R4 = regs.R15;
		/* 82261DF8h case   14:*/		return 0x82261DFC;
		  /* 82261DFCh */ case   15:  		/* mr R3, R14 */
		/* 82261DFCh case   15:*/		regs.R3 = regs.R14;
		/* 82261DFCh case   15:*/		return 0x82261E00;
		  /* 82261E00h */ case   16:  		/* bl -36560 */
		/* 82261E00h case   16:*/		regs.LR = 0x82261E04; return 0x82258F30;
		/* 82261E00h case   16:*/		return 0x82261E04;
		  /* 82261E04h */ case   17:  		/* mr R3, R15 */
		/* 82261E04h case   17:*/		regs.R3 = regs.R15;
		/* 82261E04h case   17:*/		return 0x82261E08;
		  /* 82261E08h */ case   18:  		/* bl -48712 */
		/* 82261E08h case   18:*/		regs.LR = 0x82261E0C; return 0x82255FC0;
		/* 82261E08h case   18:*/		return 0x82261E0C;
		  /* 82261E0Ch */ case   19:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82261E0Ch case   19:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82261E0Ch case   19:*/		return 0x82261E10;
		  /* 82261E10h */ case   20:  		/* bc 4, CR0_EQ, 28 */
		/* 82261E10h case   20:*/		if ( !regs.CR[0].eq ) { return 0x82261E2C;  }
		/* 82261E10h case   20:*/		return 0x82261E14;
		  /* 82261E14h */ case   21:  		/* li R7, 4253 */
		/* 82261E14h case   21:*/		cpu::op::li<0>(regs,&regs.R7,0x109D);
		/* 82261E14h case   21:*/		return 0x82261E18;
		  /* 82261E18h */ case   22:  		/* lwz R6, <#[R1 + 128]> */
		/* 82261E18h case   22:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 82261E18h case   22:*/		return 0x82261E1C;
		  /* 82261E1Ch */ case   23:  		/* li R3, 0 */
		/* 82261E1Ch case   23:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82261E1Ch case   23:*/		return 0x82261E20;
		  /* 82261E20h */ case   24:  		/* lwz R5, <#[R1 + 184]> */
		/* 82261E20h case   24:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000000B8) );
		/* 82261E20h case   24:*/		return 0x82261E24;
		  /* 82261E24h */ case   25:  		/* lwz R4, <#[R1 + 132]> */
		/* 82261E24h case   25:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 82261E24h case   25:*/		return 0x82261E28;
		  /* 82261E28h */ case   26:  		/* bl -1090080 */
		/* 82261E28h case   26:*/		regs.LR = 0x82261E2C; return 0x82157C08;
		/* 82261E28h case   26:*/		return 0x82261E2C;
	}
	return 0x82261E2C;
} // Block from 82261DC0h-82261E2Ch (27 instructions)

//////////////////////////////////////////////////////
// Block at 82261E2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261E2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261E2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261E2C);
		  /* 82261E2Ch */ case    0:  		/* lwz R10, <#[R1 + 136]> */
		/* 82261E2Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000088) );
		/* 82261E2Ch case    0:*/		return 0x82261E30;
		  /* 82261E30h */ case    1:  		/* li R15, 0 */
		/* 82261E30h case    1:*/		cpu::op::li<0>(regs,&regs.R15,0x0);
		/* 82261E30h case    1:*/		return 0x82261E34;
		  /* 82261E34h */ case    2:  		/* stw R15, <#[R1 + 168]> */
		/* 82261E34h case    2:*/		cpu::mem::store32( regs, regs.R15, (uint32)(regs.R1 + 0x000000A8) );
		/* 82261E34h case    2:*/		return 0x82261E38;
		  /* 82261E38h */ case    3:  		/* lwz R11, <#[R10 - 1320]> */
		/* 82261E38h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0xFFFFFAD8) );
		/* 82261E38h case    3:*/		return 0x82261E3C;
		  /* 82261E3Ch */ case    4:  		/* lwz R10, <#[R10 - 1312]> */
		/* 82261E3Ch case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0xFFFFFAE0) );
		/* 82261E3Ch case    4:*/		return 0x82261E40;
		  /* 82261E40h */ case    5:  		/* stw R11, <#[R1 + 152]> */
		/* 82261E40h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000098) );
		/* 82261E40h case    5:*/		return 0x82261E44;
		  /* 82261E44h */ case    6:  		/* stw R10, <#[R1 + 236]> */
		/* 82261E44h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x000000EC) );
		/* 82261E44h case    6:*/		return 0x82261E48;
	}
	return 0x82261E48;
} // Block from 82261E2Ch-82261E48h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82261E48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261E48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261E48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261E48);
		  /* 82261E48h */ case    0:  		/* lbz R11, <#[R1 + 172]> */
		/* 82261E48h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000AC) );
		/* 82261E48h case    0:*/		return 0x82261E4C;
		  /* 82261E4Ch */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 82261E4Ch case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82261E4Ch case    1:*/		return 0x82261E50;
		  /* 82261E50h */ case    2:  		/* bc 4, CR0_EQ, 20 */
		/* 82261E50h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82261E64;  }
		/* 82261E50h case    2:*/		return 0x82261E54;
		  /* 82261E54h */ case    3:  		/* lwz R11, <#[R1 + 140]> */
		/* 82261E54h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000008C) );
		/* 82261E54h case    3:*/		return 0x82261E58;
		  /* 82261E58h */ case    4:  		/* addi R11, R11, 1 */
		/* 82261E58h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82261E58h case    4:*/		return 0x82261E5C;
		  /* 82261E5Ch */ case    5:  		/* stw R11, <#[R1 + 140]> */
		/* 82261E5Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000008C) );
		/* 82261E5Ch case    5:*/		return 0x82261E60;
		  /* 82261E60h */ case    6:  		/* b -17152 */
		/* 82261E60h case    6:*/		return 0x8225DB60;
		/* 82261E60h case    6:*/		return 0x82261E64;
	}
	return 0x82261E64;
} // Block from 82261E48h-82261E64h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82261E64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261E64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261E64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261E64);
		  /* 82261E64h */ case    0:  		/* lwz R30, <#[R1 + 632]> */
		/* 82261E64h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000278) );
		/* 82261E64h case    0:*/		return 0x82261E68;
		  /* 82261E68h */ case    1:  		/* lwz R29, <#[R30 + 8]> */
		/* 82261E68h case    1:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R30 + 0x00000008) );
		/* 82261E68h case    1:*/		return 0x82261E6C;
		  /* 82261E6Ch */ case    2:  		/* b 84 */
		/* 82261E6Ch case    2:*/		return 0x82261EC0;
		/* 82261E6Ch case    2:*/		return 0x82261E70;
		  /* 82261E70h */ case    3:  		/* mr R3, R30 */
		/* 82261E70h case    3:*/		regs.R3 = regs.R30;
		/* 82261E70h case    3:*/		return 0x82261E74;
		  /* 82261E74h */ case    4:  		/* bl -58988 */
		/* 82261E74h case    4:*/		regs.LR = 0x82261E78; return 0x82253808;
		/* 82261E74h case    4:*/		return 0x82261E78;
		  /* 82261E78h */ case    5:  		/* mr R4, R30 */
		/* 82261E78h case    5:*/		regs.R4 = regs.R30;
		/* 82261E78h case    5:*/		return 0x82261E7C;
		  /* 82261E7Ch */ case    6:  		/* mr R3, R31 */
		/* 82261E7Ch case    6:*/		regs.R3 = regs.R31;
		/* 82261E7Ch case    6:*/		return 0x82261E80;
		  /* 82261E80h */ case    7:  		/* bl -178392 */
		/* 82261E80h case    7:*/		regs.LR = 0x82261E84; return 0x822365A8;
		/* 82261E80h case    7:*/		return 0x82261E84;
		  /* 82261E84h */ case    8:  		/* mr R4, R30 */
		/* 82261E84h case    8:*/		regs.R4 = regs.R30;
		/* 82261E84h case    8:*/		return 0x82261E88;
		  /* 82261E88h */ case    9:  		/* mr R3, R14 */
		/* 82261E88h case    9:*/		regs.R3 = regs.R14;
		/* 82261E88h case    9:*/		return 0x82261E8C;
		  /* 82261E8Ch */ case   10:  		/* bl -36700 */
		/* 82261E8Ch case   10:*/		regs.LR = 0x82261E90; return 0x82258F30;
		/* 82261E8Ch case   10:*/		return 0x82261E90;
		  /* 82261E90h */ case   11:  		/* mr R3, R30 */
		/* 82261E90h case   11:*/		regs.R3 = regs.R30;
		/* 82261E90h case   11:*/		return 0x82261E94;
		  /* 82261E94h */ case   12:  		/* bl -48852 */
		/* 82261E94h case   12:*/		regs.LR = 0x82261E98; return 0x82255FC0;
		/* 82261E94h case   12:*/		return 0x82261E98;
		  /* 82261E98h */ case   13:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82261E98h case   13:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82261E98h case   13:*/		return 0x82261E9C;
		  /* 82261E9Ch */ case   14:  		/* bc 4, CR0_EQ, 28 */
		/* 82261E9Ch case   14:*/		if ( !regs.CR[0].eq ) { return 0x82261EB8;  }
		/* 82261E9Ch case   14:*/		return 0x82261EA0;
		  /* 82261EA0h */ case   15:  		/* li R7, 4269 */
		/* 82261EA0h case   15:*/		cpu::op::li<0>(regs,&regs.R7,0x10AD);
		/* 82261EA0h case   15:*/		return 0x82261EA4;
		  /* 82261EA4h */ case   16:  		/* lwz R6, <#[R1 + 128]> */
		/* 82261EA4h case   16:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 82261EA4h case   16:*/		return 0x82261EA8;
		  /* 82261EA8h */ case   17:  		/* li R3, 0 */
		/* 82261EA8h case   17:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82261EA8h case   17:*/		return 0x82261EAC;
		  /* 82261EACh */ case   18:  		/* lwz R5, <#[R1 + 252]> */
		/* 82261EACh case   18:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000000FC) );
		/* 82261EACh case   18:*/		return 0x82261EB0;
		  /* 82261EB0h */ case   19:  		/* lwz R4, <#[R1 + 132]> */
		/* 82261EB0h case   19:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 82261EB0h case   19:*/		return 0x82261EB4;
		  /* 82261EB4h */ case   20:  		/* bl -1090220 */
		/* 82261EB4h case   20:*/		regs.LR = 0x82261EB8; return 0x82157C08;
		/* 82261EB4h case   20:*/		return 0x82261EB8;
	}
	return 0x82261EB8;
} // Block from 82261E64h-82261EB8h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82261EB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261EB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261EB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261EB8);
		  /* 82261EB8h */ case    0:  		/* mr R30, R29 */
		/* 82261EB8h case    0:*/		regs.R30 = regs.R29;
		/* 82261EB8h case    0:*/		return 0x82261EBC;
		  /* 82261EBCh */ case    1:  		/* lwz R29, <#[R29 + 8]> */
		/* 82261EBCh case    1:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R29 + 0x00000008) );
		/* 82261EBCh case    1:*/		return 0x82261EC0;
	}
	return 0x82261EC0;
} // Block from 82261EB8h-82261EC0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82261EC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261EC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261EC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261EC0);
		  /* 82261EC0h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 82261EC0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82261EC0h case    0:*/		return 0x82261EC4;
		  /* 82261EC4h */ case    1:  		/* bc 4, CR6_EQ, -84 */
		/* 82261EC4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82261E70;  }
		/* 82261EC4h case    1:*/		return 0x82261EC8;
		  /* 82261EC8h */ case    2:  		/* lwz R3, <#[R1 + 156]> */
		/* 82261EC8h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x0000009C) );
		/* 82261EC8h case    2:*/		return 0x82261ECC;
		  /* 82261ECCh */ case    3:  		/* cmplwi CR6, R3, 0 */
		/* 82261ECCh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82261ECCh case    3:*/		return 0x82261ED0;
		  /* 82261ED0h */ case    4:  		/* bc 12, CR6_EQ, 12 */
		/* 82261ED0h case    4:*/		if ( regs.CR[6].eq ) { return 0x82261EDC;  }
		/* 82261ED0h case    4:*/		return 0x82261ED4;
		  /* 82261ED4h */ case    5:  		/* li R4, 1 */
		/* 82261ED4h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82261ED4h case    5:*/		return 0x82261ED8;
		  /* 82261ED8h */ case    6:  		/* bl -140096 */
		/* 82261ED8h case    6:*/		regs.LR = 0x82261EDC; return 0x8223FB98;
		/* 82261ED8h case    6:*/		return 0x82261EDC;
	}
	return 0x82261EDC;
} // Block from 82261EC0h-82261EDCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 82261EDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261EDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261EDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261EDC);
		  /* 82261EDCh */ case    0:  		/* lwz R11, <#[R1 + 148]> */
		/* 82261EDCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000094) );
		/* 82261EDCh case    0:*/		return 0x82261EE0;
		  /* 82261EE0h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82261EE0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82261EE0h case    1:*/		return 0x82261EE4;
		  /* 82261EE4h */ case    2:  		/* bc 12, CR6_EQ, 5056 */
		/* 82261EE4h case    2:*/		if ( regs.CR[6].eq ) { return 0x822632A4;  }
		/* 82261EE4h case    2:*/		return 0x82261EE8;
		  /* 82261EE8h */ case    3:  		/* li R4, 1 */
		/* 82261EE8h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82261EE8h case    3:*/		return 0x82261EEC;
		  /* 82261EECh */ case    4:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 82261EECh case    4:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 82261EECh case    4:*/		return 0x82261EF0;
		  /* 82261EF0h */ case    5:  		/* bl -140120 */
		/* 82261EF0h case    5:*/		regs.LR = 0x82261EF4; return 0x8223FB98;
		/* 82261EF0h case    5:*/		return 0x82261EF4;
		  /* 82261EF4h */ case    6:  		/* b 5040 */
		/* 82261EF4h case    6:*/		return 0x822632A4;
		/* 82261EF4h case    6:*/		return 0x82261EF8;
	}
	return 0x82261EF8;
} // Block from 82261EDCh-82261EF8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82261EF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261EF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261EF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261EF8);
		  /* 82261EF8h */ case    0:  		/* mr R4, R26 */
		/* 82261EF8h case    0:*/		regs.R4 = regs.R26;
		/* 82261EF8h case    0:*/		return 0x82261EFC;
		  /* 82261EFCh */ case    1:  		/* mr R3, R31 */
		/* 82261EFCh case    1:*/		regs.R3 = regs.R31;
		/* 82261EFCh case    1:*/		return 0x82261F00;
		  /* 82261F00h */ case    2:  		/* bl -32128 */
		/* 82261F00h case    2:*/		regs.LR = 0x82261F04; return 0x8225A180;
		/* 82261F00h case    2:*/		return 0x82261F04;
		  /* 82261F04h */ case    3:  		/* lwz R11, <#[R19 + 20]> */
		/* 82261F04h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82261F04h case    3:*/		return 0x82261F08;
		  /* 82261F08h */ case    4:  		/* mr R29, R3 */
		/* 82261F08h case    4:*/		regs.R29 = regs.R3;
		/* 82261F08h case    4:*/		return 0x82261F0C;
		  /* 82261F0Ch */ case    5:  		/* addi R11, R11, 4 */
		/* 82261F0Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82261F0Ch case    5:*/		return 0x82261F10;
		  /* 82261F10h */ case    6:  		/* mr R3, R26 */
		/* 82261F10h case    6:*/		regs.R3 = regs.R26;
		/* 82261F10h case    6:*/		return 0x82261F14;
		  /* 82261F14h */ case    7:  		/* stw R11, <#[R19 + 20]> */
		/* 82261F14h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82261F14h case    7:*/		return 0x82261F18;
		  /* 82261F18h */ case    8:  		/* bl -31728 */
		/* 82261F18h case    8:*/		regs.LR = 0x82261F1C; return 0x8225A328;
		/* 82261F18h case    8:*/		return 0x82261F1C;
		  /* 82261F1Ch */ case    9:  		/* cmpwi CR6, R3, 1 */
		/* 82261F1Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 82261F1Ch case    9:*/		return 0x82261F20;
		  /* 82261F20h */ case   10:  		/* bc 12, CR6_EQ, 28 */
		/* 82261F20h case   10:*/		if ( regs.CR[6].eq ) { return 0x82261F3C;  }
		/* 82261F20h case   10:*/		return 0x82261F24;
		  /* 82261F24h */ case   11:  		/* li R7, 1955 */
		/* 82261F24h case   11:*/		cpu::op::li<0>(regs,&regs.R7,0x7A3);
		/* 82261F24h case   11:*/		return 0x82261F28;
		  /* 82261F28h */ case   12:  		/* lwz R6, <#[R1 + 128]> */
		/* 82261F28h case   12:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 82261F28h case   12:*/		return 0x82261F2C;
		  /* 82261F2Ch */ case   13:  		/* li R3, 0 */
		/* 82261F2Ch case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82261F2Ch case   13:*/		return 0x82261F30;
		  /* 82261F30h */ case   14:  		/* lwz R5, <#[R1 + 420]> */
		/* 82261F30h case   14:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000001A4) );
		/* 82261F30h case   14:*/		return 0x82261F34;
		  /* 82261F34h */ case   15:  		/* lwz R4, <#[R1 + 132]> */
		/* 82261F34h case   15:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 82261F34h case   15:*/		return 0x82261F38;
		  /* 82261F38h */ case   16:  		/* bl -1090352 */
		/* 82261F38h case   16:*/		regs.LR = 0x82261F3C; return 0x82157C08;
		/* 82261F38h case   16:*/		return 0x82261F3C;
	}
	return 0x82261F3C;
} // Block from 82261EF8h-82261F3Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 82261F3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261F3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261F3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261F3C);
		  /* 82261F3Ch */ case    0:  		/* lwz R30, <#[R19 + 20]> */
		/* 82261F3Ch case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R19 + 0x00000014) );
		/* 82261F3Ch case    0:*/		return 0x82261F40;
		  /* 82261F40h */ case    1:  		/* lwz R11, <#[R30]> */
		/* 82261F40h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82261F40h case    1:*/		return 0x82261F44;
		  /* 82261F44h */ case    2:  		/* stw R11, <#[R25]> */
		/* 82261F44h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 82261F44h case    2:*/		return 0x82261F48;
		  /* 82261F48h */ case    3:  		/* lwz R11, <#[R30 + 4]> */
		/* 82261F48h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 82261F48h case    3:*/		return 0x82261F4C;
		  /* 82261F4Ch */ case    4:  		/* stw R11, <#[R25 + 4]> */
		/* 82261F4Ch case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 82261F4Ch case    4:*/		return 0x82261F50;
		  /* 82261F50h */ case    5:  		/* lwz R11, <#[R19 + 20]> */
		/* 82261F50h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82261F50h case    5:*/		return 0x82261F54;
		  /* 82261F54h */ case    6:  		/* addi R11, R11, 4 */
		/* 82261F54h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82261F54h case    6:*/		return 0x82261F58;
		  /* 82261F58h */ case    7:  		/* stw R11, <#[R19 + 20]> */
		/* 82261F58h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82261F58h case    7:*/		return 0x82261F5C;
		  /* 82261F5Ch */ case    8:  		/* lwz R10, <#[R30]> */
		/* 82261F5Ch case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82261F5Ch case    8:*/		return 0x82261F60;
		  /* 82261F60h */ case    9:  		/* rlwinm. R10, R10, 10, 31, 31 */
		/* 82261F60h case    9:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R10,regs.R10);
		/* 82261F60h case    9:*/		return 0x82261F64;
		  /* 82261F64h */ case   10:  		/* bc 12, CR0_EQ, 36 */
		/* 82261F64h case   10:*/		if ( regs.CR[0].eq ) { return 0x82261F88;  }
		/* 82261F64h case   10:*/		return 0x82261F68;
		  /* 82261F68h */ case   11:  		/* mr R6, R21 */
		/* 82261F68h case   11:*/		regs.R6 = regs.R21;
		/* 82261F68h case   11:*/		return 0x82261F6C;
		  /* 82261F6Ch */ case   12:  		/* mr R5, R25 */
		/* 82261F6Ch case   12:*/		regs.R5 = regs.R25;
		/* 82261F6Ch case   12:*/		return 0x82261F70;
		  /* 82261F70h */ case   13:  		/* addi R4, R1, 624 */
		/* 82261F70h case   13:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x270);
		/* 82261F70h case   13:*/		return 0x82261F74;
		  /* 82261F74h */ case   14:  		/* mr R3, R31 */
		/* 82261F74h case   14:*/		regs.R3 = regs.R31;
		/* 82261F74h case   14:*/		return 0x82261F78;
		  /* 82261F78h */ case   15:  		/* bl -24248 */
		/* 82261F78h case   15:*/		regs.LR = 0x82261F7C; return 0x8225C0C0;
		/* 82261F78h case   15:*/		return 0x82261F7C;
		  /* 82261F7Ch */ case   16:  		/* lwz R11, <#[R19 + 20]> */
		/* 82261F7Ch case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82261F7Ch case   16:*/		return 0x82261F80;
		  /* 82261F80h */ case   17:  		/* addi R11, R11, 4 */
		/* 82261F80h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82261F80h case   17:*/		return 0x82261F84;
		  /* 82261F84h */ case   18:  		/* stw R11, <#[R19 + 20]> */
		/* 82261F84h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82261F84h case   18:*/		return 0x82261F88;
	}
	return 0x82261F88;
} // Block from 82261F3Ch-82261F88h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82261F88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261F88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261F88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261F88);
		  /* 82261F88h */ case    0:  		/* lwz R10, <#[R30]> */
		/* 82261F88h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82261F88h case    0:*/		return 0x82261F8C;
		  /* 82261F8Ch */ case    1:  		/* rlwinm. R10, R10, 9, 31, 31 */
		/* 82261F8Ch case    1:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R10,regs.R10);
		/* 82261F8Ch case    1:*/		return 0x82261F90;
		  /* 82261F90h */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 82261F90h case    2:*/		if ( regs.CR[0].eq ) { return 0x82261F9C;  }
		/* 82261F90h case    2:*/		return 0x82261F94;
		  /* 82261F94h */ case    3:  		/* addi R11, R11, 4 */
		/* 82261F94h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82261F94h case    3:*/		return 0x82261F98;
		  /* 82261F98h */ case    4:  		/* stw R11, <#[R19 + 20]> */
		/* 82261F98h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82261F98h case    4:*/		return 0x82261F9C;
	}
	return 0x82261F9C;
} // Block from 82261F88h-82261F9Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82261F9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82261F9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82261F9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82261F9C);
		  /* 82261F9Ch */ case    0:  		/* lwz R7, <#[R25]> */
		/* 82261F9Ch case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R25 + 0x00000000) );
		/* 82261F9Ch case    0:*/		return 0x82261FA0;
		  /* 82261FA0h */ case    1:  		/* li R9, 0 */
		/* 82261FA0h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82261FA0h case    1:*/		return 0x82261FA4;
		  /* 82261FA4h */ case    2:  		/* lwz R11, <#[R31 + 92]> */
		/* 82261FA4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 82261FA4h case    2:*/		return 0x82261FA8;
		  /* 82261FA8h */ case    3:  		/* mr R8, R29 */
		/* 82261FA8h case    3:*/		regs.R8 = regs.R29;
		/* 82261FA8h case    3:*/		return 0x82261FAC;
		  /* 82261FACh */ case    4:  		/* rlwinm R10, R7, 19, 23, 28 */
		/* 82261FACh case    4:*/		cpu::op::rlwinm<0,19,23,28>(regs,&regs.R10,regs.R7);
		/* 82261FACh case    4:*/		return 0x82261FB0;
		  /* 82261FB0h */ case    5:  		/* lwz R5, <#[R1 + 136]> */
		/* 82261FB0h case    5:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000088) );
		/* 82261FB0h case    5:*/		return 0x82261FB4;
		  /* 82261FB4h */ case    6:  		/* mr R6, R25 */
		/* 82261FB4h case    6:*/		regs.R6 = regs.R25;
		/* 82261FB4h case    6:*/		return 0x82261FB8;
		  /* 82261FB8h */ case    7:  		/* add R11, R10, R11 */
		/* 82261FB8h case    7:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82261FB8h case    7:*/		return 0x82261FBC;
		  /* 82261FBCh */ case    8:  		/* extsh R10, R7 */
		/* 82261FBCh case    8:*/		cpu::op::extsh<0>(regs,&regs.R10,regs.R7);
		/* 82261FBCh case    8:*/		return 0x82261FC0;
		  /* 82261FC0h */ case    9:  		/* li R7, 0 */
		/* 82261FC0h case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82261FC0h case    9:*/		return 0x82261FC4;
		  /* 82261FC4h */ case   10:  		/* mr R4, R21 */
		/* 82261FC4h case   10:*/		regs.R4 = regs.R21;
		/* 82261FC4h case   10:*/		return 0x82261FC8;
		  /* 82261FC8h */ case   11:  		/* mr R3, R31 */
		/* 82261FC8h case   11:*/		regs.R3 = regs.R31;
		/* 82261FC8h case   11:*/		return 0x82261FCC;
		  /* 82261FCCh */ case   12:  		/* lwz R11, <#[R11 + 4]> */
		/* 82261FCCh case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82261FCCh case   12:*/		return 0x82261FD0;
		  /* 82261FD0h */ case   13:  		/* stw R10, <#[R29 + 56]> */
		/* 82261FD0h case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R29 + 0x00000038) );
		/* 82261FD0h case   13:*/		return 0x82261FD4;
		  /* 82261FD4h */ case   14:  		/* stw R11, <#[R29 + 80]> */
		/* 82261FD4h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000050) );
		/* 82261FD4h case   14:*/		return 0x82261FD8;
		  /* 82261FD8h */ case   15:  		/* lwz R5, <#[R5 - 1312]> */
		/* 82261FD8h case   15:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + 0xFFFFFAE0) );
		/* 82261FD8h case   15:*/		return 0x82261FDC;
		  /* 82261FDCh */ case   16:  		/* bl -21748 */
		/* 82261FDCh case   16:*/		regs.LR = 0x82261FE0; return 0x8225CAE8;
		/* 82261FDCh case   16:*/		return 0x82261FE0;
		  /* 82261FE0h */ case   17:  		/* mr R3, R26 */
		/* 82261FE0h case   17:*/		regs.R3 = regs.R26;
		/* 82261FE0h case   17:*/		return 0x82261FE4;
		  /* 82261FE4h */ case   18:  		/* bl -31804 */
		/* 82261FE4h case   18:*/		regs.LR = 0x82261FE8; return 0x8225A3A8;
		/* 82261FE4h case   18:*/		return 0x82261FE8;
		  /* 82261FE8h */ case   19:  		/* addi R25, R3, 1 */
		/* 82261FE8h case   19:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R3,0x1);
		/* 82261FE8h case   19:*/		return 0x82261FEC;
		  /* 82261FECh */ case   20:  		/* li R30, 1 */
		/* 82261FECh case   20:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 82261FECh case   20:*/		return 0x82261FF0;
		  /* 82261FF0h */ case   21:  		/* cmpwi CR6, R25, 1 */
		/* 82261FF0h case   21:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000001);
		/* 82261FF0h case   21:*/		return 0x82261FF4;
		  /* 82261FF4h */ case   22:  		/* bc 4, CR6_GT, 340 */
		/* 82261FF4h case   22:*/		if ( !regs.CR[6].gt ) { return 0x82262148;  }
		/* 82261FF4h case   22:*/		return 0x82261FF8;
		  /* 82261FF8h */ case   23:  		/* lwz R28, <#[R19 + 20]> */
		/* 82261FF8h case   23:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R19 + 0x00000014) );
		/* 82261FF8h case   23:*/		return 0x82261FFC;
		  /* 82261FFCh */ case   24:  		/* li R10, 1 */
		/* 82261FFCh case   24:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82261FFCh case   24:*/		return 0x82262000;
		  /* 82262000h */ case   25:  		/* lwz R11, <#[R1 + 136]> */
		/* 82262000h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000088) );
		/* 82262000h case   25:*/		return 0x82262004;
		  /* 82262004h */ case   26:  		/* lwz R7, <#[R28]> */
		/* 82262004h case   26:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R28 + 0x00000000) );
		/* 82262004h case   26:*/		return 0x82262008;
		  /* 82262008h */ case   27:  		/* lwz R11, <#[R11 - 1320]> */
		/* 82262008h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFFFAD8) );
		/* 82262008h case   27:*/		return 0x8226200C;
		  /* 8226200Ch */ case   28:  		/* rlwinm. R9, R7, 10, 31, 31 */
		/* 8226200Ch case   28:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R9,regs.R7);
		/* 8226200Ch case   28:*/		return 0x82262010;
		  /* 82262010h */ case   29:  		/* rlwinm R8, R7, 9, 31, 31 */
		/* 82262010h case   29:*/		cpu::op::rlwinm<0,9,31,31>(regs,&regs.R8,regs.R7);
		/* 82262010h case   29:*/		return 0x82262014;
		  /* 82262014h */ case   30:  		/* stw R7, <#[R22]> */
		/* 82262014h case   30:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R22 + 0x00000000) );
		/* 82262014h case   30:*/		return 0x82262018;
		  /* 82262018h */ case   31:  		/* mr R27, R9 */
		/* 82262018h case   31:*/		regs.R27 = regs.R9;
		/* 82262018h case   31:*/		return 0x8226201C;
		  /* 8226201Ch */ case   32:  		/* stw R11, <#[R1 + 264]> */
		/* 8226201Ch case   32:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000108) );
		/* 8226201Ch case   32:*/		return 0x82262020;
		  /* 82262020h */ case   33:  		/* bc 12, CR0_EQ, 16 */
		/* 82262020h case   33:*/		if ( regs.CR[0].eq ) { return 0x82262030;  }
		/* 82262020h case   33:*/		return 0x82262024;
		  /* 82262024h */ case   34:  		/* lwz R11, <#[R28 + 4]> */
		/* 82262024h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 82262024h case   34:*/		return 0x82262028;
		  /* 82262028h */ case   35:  		/* li R10, 2 */
		/* 82262028h case   35:*/		cpu::op::li<0>(regs,&regs.R10,0x2);
		/* 82262028h case   35:*/		return 0x8226202C;
		  /* 8226202Ch */ case   36:  		/* stw R11, <#[R22 + 4]> */
		/* 8226202Ch case   36:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R22 + 0x00000004) );
		/* 8226202Ch case   36:*/		return 0x82262030;
	}
	return 0x82262030;
} // Block from 82261F9Ch-82262030h (37 instructions)

//////////////////////////////////////////////////////
// Block at 82262030h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262030( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262030) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262030);
		  /* 82262030h */ case    0:  		/* rlwinm. R26, R8, 0, 24, 31 */
		/* 82262030h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R26,regs.R8);
		/* 82262030h case    0:*/		return 0x82262034;
		  /* 82262034h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 82262034h case    1:*/		if ( regs.CR[0].eq ) { return 0x82262044;  }
		/* 82262034h case    1:*/		return 0x82262038;
		  /* 82262038h */ case    2:  		/* rlwinm R11, R10, 2, 0, 29 */
		/* 82262038h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 82262038h case    2:*/		return 0x8226203C;
		  /* 8226203Ch */ case    3:  		/* lwzx R10, <#[R28 + R11]> */
		/* 8226203Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + regs.R11 + 0x00000000) );
		/* 8226203Ch case    3:*/		return 0x82262040;
		  /* 82262040h */ case    4:  		/* stwx R10, <#[R11 + R22]> */
		/* 82262040h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R22 + 0x00000000) );
		/* 82262040h case    4:*/		return 0x82262044;
	}
	return 0x82262044;
} // Block from 82262030h-82262044h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82262044h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262044( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262044) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262044);
		  /* 82262044h */ case    0:  		/* lwz R11, <#[R19 + 20]> */
		/* 82262044h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82262044h case    0:*/		return 0x82262048;
		  /* 82262048h */ case    1:  		/* cmplwi CR6, R27, 0 */
		/* 82262048h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 82262048h case    1:*/		return 0x8226204C;
		  /* 8226204Ch */ case    2:  		/* addi R11, R11, 4 */
		/* 8226204Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8226204Ch case    2:*/		return 0x82262050;
		  /* 82262050h */ case    3:  		/* stw R11, <#[R19 + 20]> */
		/* 82262050h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82262050h case    3:*/		return 0x82262054;
		  /* 82262054h */ case    4:  		/* bc 4, CR6_EQ, 12 */
		/* 82262054h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82262060;  }
		/* 82262054h case    4:*/		return 0x82262058;
		  /* 82262058h */ case    5:  		/* cmplwi CR6, R26, 0 */
		/* 82262058h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 82262058h case    5:*/		return 0x8226205C;
		  /* 8226205Ch */ case    6:  		/* bc 12, CR6_EQ, 28 */
		/* 8226205Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x82262078;  }
		/* 8226205Ch case    6:*/		return 0x82262060;
	}
	return 0x82262060;
} // Block from 82262044h-82262060h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82262060h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262060( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262060) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262060);
		  /* 82262060h */ case    0:  		/* mr R7, R21 */
		/* 82262060h case    0:*/		regs.R7 = regs.R21;
		/* 82262060h case    0:*/		return 0x82262064;
		  /* 82262064h */ case    1:  		/* mr R6, R22 */
		/* 82262064h case    1:*/		regs.R6 = regs.R22;
		/* 82262064h case    1:*/		return 0x82262068;
		  /* 82262068h */ case    2:  		/* mr R5, R15 */
		/* 82262068h case    2:*/		regs.R5 = regs.R15;
		/* 82262068h case    2:*/		return 0x8226206C;
		  /* 8226206Ch */ case    3:  		/* addi R4, R1, 656 */
		/* 8226206Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x290);
		/* 8226206Ch case    3:*/		return 0x82262070;
		  /* 82262070h */ case    4:  		/* mr R3, R31 */
		/* 82262070h case    4:*/		regs.R3 = regs.R31;
		/* 82262070h case    4:*/		return 0x82262074;
		  /* 82262074h */ case    5:  		/* bl -29100 */
		/* 82262074h case    5:*/		regs.LR = 0x82262078; return 0x8225AEC8;
		/* 82262074h case    5:*/		return 0x82262078;
	}
	return 0x82262078;
} // Block from 82262060h-82262078h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82262078h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262078);
		  /* 82262078h */ case    0:  		/* cmplwi CR6, R27, 0 */
		/* 82262078h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 82262078h case    0:*/		return 0x8226207C;
		  /* 8226207Ch */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 8226207Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8226208C;  }
		/* 8226207Ch case    1:*/		return 0x82262080;
		  /* 82262080h */ case    2:  		/* lwz R11, <#[R19 + 20]> */
		/* 82262080h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82262080h case    2:*/		return 0x82262084;
		  /* 82262084h */ case    3:  		/* addi R11, R11, 4 */
		/* 82262084h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82262084h case    3:*/		return 0x82262088;
		  /* 82262088h */ case    4:  		/* stw R11, <#[R19 + 20]> */
		/* 82262088h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82262088h case    4:*/		return 0x8226208C;
	}
	return 0x8226208C;
} // Block from 82262078h-8226208Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8226208Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226208C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226208C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226208C);
		  /* 8226208Ch */ case    0:  		/* cmplwi CR6, R26, 0 */
		/* 8226208Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 8226208Ch case    0:*/		return 0x82262090;
		  /* 82262090h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 82262090h case    1:*/		if ( regs.CR[6].eq ) { return 0x822620A0;  }
		/* 82262090h case    1:*/		return 0x82262094;
		  /* 82262094h */ case    2:  		/* lwz R11, <#[R19 + 20]> */
		/* 82262094h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82262094h case    2:*/		return 0x82262098;
		  /* 82262098h */ case    3:  		/* addi R11, R11, 4 */
		/* 82262098h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82262098h case    3:*/		return 0x8226209C;
		  /* 8226209Ch */ case    4:  		/* stw R11, <#[R19 + 20]> */
		/* 8226209Ch case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 8226209Ch case    4:*/		return 0x822620A0;
	}
	return 0x822620A0;
} // Block from 8226208Ch-822620A0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822620A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822620A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822620A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822620A0);
		  /* 822620A0h */ case    0:  		/* lwz R11, <#[R22]> */
		/* 822620A0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 822620A0h case    0:*/		return 0x822620A4;
		  /* 822620A4h */ case    1:  		/* rlwinm. R8, R11, 9, 31, 31 */
		/* 822620A4h case    1:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R8,regs.R11);
		/* 822620A4h case    1:*/		return 0x822620A8;
		  /* 822620A8h */ case    2:  		/* extsh R9, R11 */
		/* 822620A8h case    2:*/		cpu::op::extsh<0>(regs,&regs.R9,regs.R11);
		/* 822620A8h case    2:*/		return 0x822620AC;
		  /* 822620ACh */ case    3:  		/* rlwinm R10, R11, 16, 26, 31 */
		/* 822620ACh case    3:*/		cpu::op::rlwinm<0,16,26,31>(regs,&regs.R10,regs.R11);
		/* 822620ACh case    3:*/		return 0x822620B0;
		  /* 822620B0h */ case    4:  		/* bc 12, CR0_EQ, 24 */
		/* 822620B0h case    4:*/		if ( regs.CR[0].eq ) { return 0x822620C8;  }
		/* 822620B0h case    4:*/		return 0x822620B4;
		  /* 822620B4h */ case    5:  		/* addi R8, R30, 50 */
		/* 822620B4h case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R30,0x32);
		/* 822620B4h case    5:*/		return 0x822620B8;
		  /* 822620B8h */ case    6:  		/* lwz R11, <#[R28]> */
		/* 822620B8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 822620B8h case    6:*/		return 0x822620BC;
		  /* 822620BCh */ case    7:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 822620BCh case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 822620BCh case    7:*/		return 0x822620C0;
		  /* 822620C0h */ case    8:  		/* extsh R11, R11 */
		/* 822620C0h case    8:*/		cpu::op::extsh<0>(regs,&regs.R11,regs.R11);
		/* 822620C0h case    8:*/		return 0x822620C4;
		  /* 822620C4h */ case    9:  		/* stwx R11, <#[R8 + R29]> */
		/* 822620C4h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + regs.R29 + 0x00000000) );
		/* 822620C4h case    9:*/		return 0x822620C8;
	}
	return 0x822620C8;
} // Block from 822620A0h-822620C8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 822620C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822620C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822620C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822620C8);
		  /* 822620C8h */ case    0:  		/* lwz R11, <#[R31 + 92]> */
		/* 822620C8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 822620C8h case    0:*/		return 0x822620CC;
		  /* 822620CCh */ case    1:  		/* rlwinm R10, R10, 3, 0, 28 */
		/* 822620CCh case    1:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R10);
		/* 822620CCh case    1:*/		return 0x822620D0;
		  /* 822620D0h */ case    2:  		/* addi R8, R30, 14 */
		/* 822620D0h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R30,0xE);
		/* 822620D0h case    2:*/		return 0x822620D4;
		  /* 822620D4h */ case    3:  		/* add R11, R10, R11 */
		/* 822620D4h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 822620D4h case    3:*/		return 0x822620D8;
		  /* 822620D8h */ case    4:  		/* rlwinm R10, R8, 2, 0, 29 */
		/* 822620D8h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R8);
		/* 822620D8h case    4:*/		return 0x822620DC;
		  /* 822620DCh */ case    5:  		/* addi R8, R30, 20 */
		/* 822620DCh case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R30,0x14);
		/* 822620DCh case    5:*/		return 0x822620E0;
		  /* 822620E0h */ case    6:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 822620E0h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 822620E0h case    6:*/		return 0x822620E4;
		  /* 822620E4h */ case    7:  		/* lwz R11, <#[R11 + 4]> */
		/* 822620E4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 822620E4h case    7:*/		return 0x822620E8;
		  /* 822620E8h */ case    8:  		/* stwx R9, <#[R10 + R29]> */
		/* 822620E8h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R29 + 0x00000000) );
		/* 822620E8h case    8:*/		return 0x822620EC;
		  /* 822620ECh */ case    9:  		/* stwx R11, <#[R8 + R29]> */
		/* 822620ECh case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + regs.R29 + 0x00000000) );
		/* 822620ECh case    9:*/		return 0x822620F0;
		  /* 822620F0h */ case   10:  		/* lwz R11, <#[R29 + 24]> */
		/* 822620F0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000018) );
		/* 822620F0h case   10:*/		return 0x822620F4;
		  /* 822620F4h */ case   11:  		/* mulli R11, R11, 52 */
		/* 822620F4h case   11:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x34);
		/* 822620F4h case   11:*/		return 0x822620F8;
		  /* 822620F8h */ case   12:  		/* lwzx R11, <#[R11 + R24]> */
		/* 822620F8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R24 + 0x00000000) );
		/* 822620F8h case   12:*/		return 0x822620FC;
		  /* 822620FCh */ case   13:  		/* rlwinm. R11, R11, 30, 31, 31 */
		/* 822620FCh case   13:*/		cpu::op::rlwinm<1,30,31,31>(regs,&regs.R11,regs.R11);
		/* 822620FCh case   13:*/		return 0x82262100;
		  /* 82262100h */ case   14:  		/* bc 12, CR0_EQ, 36 */
		/* 82262100h case   14:*/		if ( regs.CR[0].eq ) { return 0x82262124;  }
		/* 82262100h case   14:*/		return 0x82262104;
		  /* 82262104h */ case   15:  		/* lwz R11, <#[R1 + 136]> */
		/* 82262104h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000088) );
		/* 82262104h case   15:*/		return 0x82262108;
		  /* 82262108h */ case   16:  		/* cmpwi CR6, R30, 1 */
		/* 82262108h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000001);
		/* 82262108h case   16:*/		return 0x8226210C;
		  /* 8226210Ch */ case   17:  		/* bc 4, CR6_EQ, 12 */
		/* 8226210Ch case   17:*/		if ( !regs.CR[6].eq ) { return 0x82262118;  }
		/* 8226210Ch case   17:*/		return 0x82262110;
		  /* 82262110h */ case   18:  		/* addi R11, R11, -1272 */
		/* 82262110h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFB08);
		/* 82262110h case   18:*/		return 0x82262114;
		  /* 82262114h */ case   19:  		/* b 8 */
		/* 82262114h case   19:*/		return 0x8226211C;
		/* 82262114h case   19:*/		return 0x82262118;
	}
	return 0x82262118;
} // Block from 822620C8h-82262118h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82262118h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262118( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262118) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262118);
		  /* 82262118h */ case    0:  		/* addi R11, R11, -1284 */
		/* 82262118h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFAFC);
		/* 82262118h case    0:*/		return 0x8226211C;
	}
	return 0x8226211C;
} // Block from 82262118h-8226211Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226211Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226211C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226211C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226211C);
		  /* 8226211Ch */ case    0:  		/* lwz R11, <#[R11]> */
		/* 8226211Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8226211Ch case    0:*/		return 0x82262120;
		  /* 82262120h */ case    1:  		/* stw R11, <#[R1 + 264]> */
		/* 82262120h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000108) );
		/* 82262120h case    1:*/		return 0x82262124;
	}
	return 0x82262124;
} // Block from 8226211Ch-82262124h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82262124h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262124( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262124) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262124);
		  /* 82262124h */ case    0:  		/* mr R7, R29 */
		/* 82262124h case    0:*/		regs.R7 = regs.R29;
		/* 82262124h case    0:*/		return 0x82262128;
		  /* 82262128h */ case    1:  		/* mr R6, R30 */
		/* 82262128h case    1:*/		regs.R6 = regs.R30;
		/* 82262128h case    1:*/		return 0x8226212C;
		  /* 8226212Ch */ case    2:  		/* mr R5, R22 */
		/* 8226212Ch case    2:*/		regs.R5 = regs.R22;
		/* 8226212Ch case    2:*/		return 0x82262130;
		  /* 82262130h */ case    3:  		/* addi R4, R1, 264 */
		/* 82262130h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x108);
		/* 82262130h case    3:*/		return 0x82262134;
		  /* 82262134h */ case    4:  		/* mr R3, R31 */
		/* 82262134h case    4:*/		regs.R3 = regs.R31;
		/* 82262134h case    4:*/		return 0x82262138;
		  /* 82262138h */ case    5:  		/* bl -31032 */
		/* 82262138h case    5:*/		regs.LR = 0x8226213C; return 0x8225A800;
		/* 82262138h case    5:*/		return 0x8226213C;
		  /* 8226213Ch */ case    6:  		/* addi R30, R30, 1 */
		/* 8226213Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8226213Ch case    6:*/		return 0x82262140;
		  /* 82262140h */ case    7:  		/* cmpw CR6, R30, R25 */
		/* 82262140h case    7:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R25);
		/* 82262140h case    7:*/		return 0x82262144;
		  /* 82262144h */ case    8:  		/* bc 12, CR6_LT, -332 */
		/* 82262144h case    8:*/		if ( regs.CR[6].lt ) { return 0x82261FF8;  }
		/* 82262144h case    8:*/		return 0x82262148;
	}
	return 0x82262148;
} // Block from 82262124h-82262148h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82262148h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262148( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262148) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262148);
		  /* 82262148h */ case    0:  		/* lwz R30, <#[R1 + 664]> */
		/* 82262148h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000298) );
		/* 82262148h case    0:*/		return 0x8226214C;
		  /* 8226214Ch */ case    1:  		/* lwz R27, <#[R1 + 132]> */
		/* 8226214Ch case    1:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000084) );
		/* 8226214Ch case    1:*/		return 0x82262150;
		  /* 82262150h */ case    2:  		/* lwz R26, <#[R1 + 128]> */
		/* 82262150h case    2:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x00000080) );
		/* 82262150h case    2:*/		return 0x82262154;
		  /* 82262154h */ case    3:  		/* lwz R28, <#[R30 + 8]> */
		/* 82262154h case    3:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R30 + 0x00000008) );
		/* 82262154h case    3:*/		return 0x82262158;
		  /* 82262158h */ case    4:  		/* cmplwi CR6, R28, 0 */
		/* 82262158h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 82262158h case    4:*/		return 0x8226215C;
		  /* 8226215Ch */ case    5:  		/* bc 12, CR6_EQ, 88 */
		/* 8226215Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x822621B4;  }
		/* 8226215Ch case    5:*/		return 0x82262160;
		  /* 82262160h */ case    6:  		/* mr R3, R30 */
		/* 82262160h case    6:*/		regs.R3 = regs.R30;
		/* 82262160h case    6:*/		return 0x82262164;
		  /* 82262164h */ case    7:  		/* bl -59740 */
		/* 82262164h case    7:*/		regs.LR = 0x82262168; return 0x82253808;
		/* 82262164h case    7:*/		return 0x82262168;
		  /* 82262168h */ case    8:  		/* mr R4, R30 */
		/* 82262168h case    8:*/		regs.R4 = regs.R30;
		/* 82262168h case    8:*/		return 0x8226216C;
		  /* 8226216Ch */ case    9:  		/* mr R3, R31 */
		/* 8226216Ch case    9:*/		regs.R3 = regs.R31;
		/* 8226216Ch case    9:*/		return 0x82262170;
		  /* 82262170h */ case   10:  		/* bl -179144 */
		/* 82262170h case   10:*/		regs.LR = 0x82262174; return 0x822365A8;
		/* 82262170h case   10:*/		return 0x82262174;
		  /* 82262174h */ case   11:  		/* mr R4, R30 */
		/* 82262174h case   11:*/		regs.R4 = regs.R30;
		/* 82262174h case   11:*/		return 0x82262178;
		  /* 82262178h */ case   12:  		/* mr R3, R14 */
		/* 82262178h case   12:*/		regs.R3 = regs.R14;
		/* 82262178h case   12:*/		return 0x8226217C;
		  /* 8226217Ch */ case   13:  		/* bl -37452 */
		/* 8226217Ch case   13:*/		regs.LR = 0x82262180; return 0x82258F30;
		/* 8226217Ch case   13:*/		return 0x82262180;
		  /* 82262180h */ case   14:  		/* mr R3, R30 */
		/* 82262180h case   14:*/		regs.R3 = regs.R30;
		/* 82262180h case   14:*/		return 0x82262184;
		  /* 82262184h */ case   15:  		/* bl -49604 */
		/* 82262184h case   15:*/		regs.LR = 0x82262188; return 0x82255FC0;
		/* 82262184h case   15:*/		return 0x82262188;
		  /* 82262188h */ case   16:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82262188h case   16:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82262188h case   16:*/		return 0x8226218C;
		  /* 8226218Ch */ case   17:  		/* bc 4, CR0_EQ, 28 */
		/* 8226218Ch case   17:*/		if ( !regs.CR[0].eq ) { return 0x822621A8;  }
		/* 8226218Ch case   17:*/		return 0x82262190;
		  /* 82262190h */ case   18:  		/* mr R6, R26 */
		/* 82262190h case   18:*/		regs.R6 = regs.R26;
		/* 82262190h case   18:*/		return 0x82262194;
		  /* 82262194h */ case   19:  		/* lwz R5, <#[R1 + 252]> */
		/* 82262194h case   19:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000000FC) );
		/* 82262194h case   19:*/		return 0x82262198;
		  /* 82262198h */ case   20:  		/* mr R4, R27 */
		/* 82262198h case   20:*/		regs.R4 = regs.R27;
		/* 82262198h case   20:*/		return 0x8226219C;
		  /* 8226219Ch */ case   21:  		/* li R7, 2035 */
		/* 8226219Ch case   21:*/		cpu::op::li<0>(regs,&regs.R7,0x7F3);
		/* 8226219Ch case   21:*/		return 0x822621A0;
		  /* 822621A0h */ case   22:  		/* li R3, 0 */
		/* 822621A0h case   22:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822621A0h case   22:*/		return 0x822621A4;
		  /* 822621A4h */ case   23:  		/* bl -1090972 */
		/* 822621A4h case   23:*/		regs.LR = 0x822621A8; return 0x82157C08;
		/* 822621A4h case   23:*/		return 0x822621A8;
	}
	return 0x822621A8;
} // Block from 82262148h-822621A8h (24 instructions)

//////////////////////////////////////////////////////
// Block at 822621A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822621A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822621A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822621A8);
		  /* 822621A8h */ case    0:  		/* mr R30, R28 */
		/* 822621A8h case    0:*/		regs.R30 = regs.R28;
		/* 822621A8h case    0:*/		return 0x822621AC;
		  /* 822621ACh */ case    1:  		/* lwz R28, <#[R28 + 8]> */
		/* 822621ACh case    1:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R28 + 0x00000008) );
		/* 822621ACh case    1:*/		return 0x822621B0;
		  /* 822621B0h */ case    2:  		/* b -88 */
		/* 822621B0h case    2:*/		return 0x82262158;
		/* 822621B0h case    2:*/		return 0x822621B4;
	}
	return 0x822621B4;
} // Block from 822621A8h-822621B4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822621B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822621B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822621B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822621B4);
		  /* 822621B4h */ case    0:  		/* mr R4, R29 */
		/* 822621B4h case    0:*/		regs.R4 = regs.R29;
		/* 822621B4h case    0:*/		return 0x822621B8;
		  /* 822621B8h */ case    1:  		/* mr R3, R31 */
		/* 822621B8h case    1:*/		regs.R3 = regs.R31;
		/* 822621B8h case    1:*/		return 0x822621BC;
		  /* 822621BCh */ case    2:  		/* bl -179220 */
		/* 822621BCh case    2:*/		regs.LR = 0x822621C0; return 0x822365A8;
		/* 822621BCh case    2:*/		return 0x822621C0;
		  /* 822621C0h */ case    3:  		/* mr R4, R29 */
		/* 822621C0h case    3:*/		regs.R4 = regs.R29;
		/* 822621C0h case    3:*/		return 0x822621C4;
		  /* 822621C4h */ case    4:  		/* mr R3, R14 */
		/* 822621C4h case    4:*/		regs.R3 = regs.R14;
		/* 822621C4h case    4:*/		return 0x822621C8;
		  /* 822621C8h */ case    5:  		/* bl -37528 */
		/* 822621C8h case    5:*/		regs.LR = 0x822621CC; return 0x82258F30;
		/* 822621C8h case    5:*/		return 0x822621CC;
		  /* 822621CCh */ case    6:  		/* mr R3, R29 */
		/* 822621CCh case    6:*/		regs.R3 = regs.R29;
		/* 822621CCh case    6:*/		return 0x822621D0;
		  /* 822621D0h */ case    7:  		/* bl -49680 */
		/* 822621D0h case    7:*/		regs.LR = 0x822621D4; return 0x82255FC0;
		/* 822621D0h case    7:*/		return 0x822621D4;
		  /* 822621D4h */ case    8:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822621D4h case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822621D4h case    8:*/		return 0x822621D8;
		  /* 822621D8h */ case    9:  		/* bc 4, CR0_EQ, 28 */
		/* 822621D8h case    9:*/		if ( !regs.CR[0].eq ) { return 0x822621F4;  }
		/* 822621D8h case    9:*/		return 0x822621DC;
		  /* 822621DCh */ case   10:  		/* mr R6, R26 */
		/* 822621DCh case   10:*/		regs.R6 = regs.R26;
		/* 822621DCh case   10:*/		return 0x822621E0;
		  /* 822621E0h */ case   11:  		/* lwz R5, <#[R1 + 184]> */
		/* 822621E0h case   11:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000000B8) );
		/* 822621E0h case   11:*/		return 0x822621E4;
		  /* 822621E4h */ case   12:  		/* mr R4, R27 */
		/* 822621E4h case   12:*/		regs.R4 = regs.R27;
		/* 822621E4h case   12:*/		return 0x822621E8;
		  /* 822621E8h */ case   13:  		/* li R7, 2040 */
		/* 822621E8h case   13:*/		cpu::op::li<0>(regs,&regs.R7,0x7F8);
		/* 822621E8h case   13:*/		return 0x822621EC;
		  /* 822621ECh */ case   14:  		/* li R3, 0 */
		/* 822621ECh case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822621ECh case   14:*/		return 0x822621F0;
		  /* 822621F0h */ case   15:  		/* bl -1091048 */
		/* 822621F0h case   15:*/		regs.LR = 0x822621F4; return 0x82157C08;
		/* 822621F0h case   15:*/		return 0x822621F4;
	}
	return 0x822621F4;
} // Block from 822621B4h-822621F4h (16 instructions)

//////////////////////////////////////////////////////
// Block at 822621F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822621F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822621F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822621F4);
		  /* 822621F4h */ case    0:  		/* lwz R30, <#[R1 + 632]> */
		/* 822621F4h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000278) );
		/* 822621F4h case    0:*/		return 0x822621F8;
		  /* 822621F8h */ case    1:  		/* lwz R29, <#[R30 + 8]> */
		/* 822621F8h case    1:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R30 + 0x00000008) );
		/* 822621F8h case    1:*/		return 0x822621FC;
		  /* 822621FCh */ case    2:  		/* b 84 */
		/* 822621FCh case    2:*/		return 0x82262250;
		/* 822621FCh case    2:*/		return 0x82262200;
		  /* 82262200h */ case    3:  		/* mr R3, R30 */
		/* 82262200h case    3:*/		regs.R3 = regs.R30;
		/* 82262200h case    3:*/		return 0x82262204;
		  /* 82262204h */ case    4:  		/* bl -59900 */
		/* 82262204h case    4:*/		regs.LR = 0x82262208; return 0x82253808;
		/* 82262204h case    4:*/		return 0x82262208;
		  /* 82262208h */ case    5:  		/* mr R4, R30 */
		/* 82262208h case    5:*/		regs.R4 = regs.R30;
		/* 82262208h case    5:*/		return 0x8226220C;
		  /* 8226220Ch */ case    6:  		/* mr R3, R31 */
		/* 8226220Ch case    6:*/		regs.R3 = regs.R31;
		/* 8226220Ch case    6:*/		return 0x82262210;
		  /* 82262210h */ case    7:  		/* bl -179304 */
		/* 82262210h case    7:*/		regs.LR = 0x82262214; return 0x822365A8;
		/* 82262210h case    7:*/		return 0x82262214;
		  /* 82262214h */ case    8:  		/* mr R4, R30 */
		/* 82262214h case    8:*/		regs.R4 = regs.R30;
		/* 82262214h case    8:*/		return 0x82262218;
		  /* 82262218h */ case    9:  		/* mr R3, R14 */
		/* 82262218h case    9:*/		regs.R3 = regs.R14;
		/* 82262218h case    9:*/		return 0x8226221C;
		  /* 8226221Ch */ case   10:  		/* bl -37612 */
		/* 8226221Ch case   10:*/		regs.LR = 0x82262220; return 0x82258F30;
		/* 8226221Ch case   10:*/		return 0x82262220;
		  /* 82262220h */ case   11:  		/* mr R3, R30 */
		/* 82262220h case   11:*/		regs.R3 = regs.R30;
		/* 82262220h case   11:*/		return 0x82262224;
		  /* 82262224h */ case   12:  		/* bl -49764 */
		/* 82262224h case   12:*/		regs.LR = 0x82262228; return 0x82255FC0;
		/* 82262224h case   12:*/		return 0x82262228;
		  /* 82262228h */ case   13:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82262228h case   13:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82262228h case   13:*/		return 0x8226222C;
		  /* 8226222Ch */ case   14:  		/* bc 4, CR0_EQ, 28 */
		/* 8226222Ch case   14:*/		if ( !regs.CR[0].eq ) { return 0x82262248;  }
		/* 8226222Ch case   14:*/		return 0x82262230;
		  /* 82262230h */ case   15:  		/* mr R6, R26 */
		/* 82262230h case   15:*/		regs.R6 = regs.R26;
		/* 82262230h case   15:*/		return 0x82262234;
		  /* 82262234h */ case   16:  		/* lwz R5, <#[R1 + 252]> */
		/* 82262234h case   16:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000000FC) );
		/* 82262234h case   16:*/		return 0x82262238;
		  /* 82262238h */ case   17:  		/* mr R4, R27 */
		/* 82262238h case   17:*/		regs.R4 = regs.R27;
		/* 82262238h case   17:*/		return 0x8226223C;
		  /* 8226223Ch */ case   18:  		/* li R7, 2047 */
		/* 8226223Ch case   18:*/		cpu::op::li<0>(regs,&regs.R7,0x7FF);
		/* 8226223Ch case   18:*/		return 0x82262240;
		  /* 82262240h */ case   19:  		/* li R3, 0 */
		/* 82262240h case   19:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82262240h case   19:*/		return 0x82262244;
		  /* 82262244h */ case   20:  		/* bl -1091132 */
		/* 82262244h case   20:*/		regs.LR = 0x82262248; return 0x82157C08;
		/* 82262244h case   20:*/		return 0x82262248;
	}
	return 0x82262248;
} // Block from 822621F4h-82262248h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82262248h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262248( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262248) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262248);
		  /* 82262248h */ case    0:  		/* mr R30, R29 */
		/* 82262248h case    0:*/		regs.R30 = regs.R29;
		/* 82262248h case    0:*/		return 0x8226224C;
		  /* 8226224Ch */ case    1:  		/* lwz R29, <#[R29 + 8]> */
		/* 8226224Ch case    1:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R29 + 0x00000008) );
		/* 8226224Ch case    1:*/		return 0x82262250;
	}
	return 0x82262250;
} // Block from 82262248h-82262250h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82262250h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262250( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262250) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262250);
		  /* 82262250h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 82262250h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82262250h case    0:*/		return 0x82262254;
		  /* 82262254h */ case    1:  		/* bc 4, CR6_EQ, -84 */
		/* 82262254h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82262200;  }
		/* 82262254h case    1:*/		return 0x82262258;
		  /* 82262258h */ case    2:  		/* lwz R3, <#[R1 + 204]> */
		/* 82262258h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x000000CC) );
		/* 82262258h case    2:*/		return 0x8226225C;
		  /* 8226225Ch */ case    3:  		/* bl -32324 */
		/* 8226225Ch case    3:*/		regs.LR = 0x82262260; return 0x8225A418;
		/* 8226225Ch case    3:*/		return 0x82262260;
		  /* 82262260h */ case    4:  		/* cmpwi CR0, R3, 0 */
		/* 82262260h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82262260h case    4:*/		return 0x82262264;
		  /* 82262264h */ case    5:  		/* bc 12, CR0_EQ, 4160 */
		/* 82262264h case    5:*/		if ( regs.CR[0].eq ) { return 0x822632A4;  }
		/* 82262264h case    5:*/		return 0x82262268;
		  /* 82262268h */ case    6:  		/* lwz R5, <#[R1 + 428]> */
		/* 82262268h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000001AC) );
		/* 82262268h case    6:*/		return 0x8226226C;
		  /* 8226226Ch */ case    7:  		/* mr R6, R26 */
		/* 8226226Ch case    7:*/		regs.R6 = regs.R26;
		/* 8226226Ch case    7:*/		return 0x82262270;
		  /* 82262270h */ case    8:  		/* mr R4, R27 */
		/* 82262270h case    8:*/		regs.R4 = regs.R27;
		/* 82262270h case    8:*/		return 0x82262274;
		  /* 82262274h */ case    9:  		/* li R7, 2051 */
		/* 82262274h case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x803);
		/* 82262274h case    9:*/		return 0x82262278;
		  /* 82262278h */ case   10:  		/* b 2972 */
		/* 82262278h case   10:*/		return 0x82262E14;
		/* 82262278h case   10:*/		return 0x8226227C;
	}
	return 0x8226227C;
} // Block from 82262250h-8226227Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 8226227Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226227C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226227C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226227C);
		  /* 8226227Ch */ case    0:  		/* li R7, 1936 */
		/* 8226227Ch case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x790);
		/* 8226227Ch case    0:*/		return 0x82262280;
		  /* 82262280h */ case    1:  		/* b 2952 */
		/* 82262280h case    1:*/		return 0x82262E08;
		/* 82262280h case    1:*/		return 0x82262284;
	}
	return 0x82262284;
} // Block from 8226227Ch-82262284h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82262284h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262284( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262284) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262284);
		  /* 82262284h */ case    0:  		/* li R7, 1916 */
		/* 82262284h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x77C);
		/* 82262284h case    0:*/		return 0x82262288;
		  /* 82262288h */ case    1:  		/* b 2944 */
		/* 82262288h case    1:*/		return 0x82262E08;
		/* 82262288h case    1:*/		return 0x8226228C;
	}
	return 0x8226228C;
} // Block from 82262284h-8226228Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226228Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226228C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226228C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226228C);
		  /* 8226228Ch */ case    0:  		/* lwz R6, <#[R1 + 128]> */
		/* 8226228Ch case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 8226228Ch case    0:*/		return 0x82262290;
		  /* 82262290h */ case    1:  		/* cmpwi CR6, R26, 79 */
		/* 82262290h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R26,0x0000004F);
		/* 82262290h case    1:*/		return 0x82262294;
		  /* 82262294h */ case    2:  		/* lwz R4, <#[R1 + 132]> */
		/* 82262294h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 82262294h case    2:*/		return 0x82262298;
		  /* 82262298h */ case    3:  		/* mr R5, R28 */
		/* 82262298h case    3:*/		regs.R5 = regs.R28;
		/* 82262298h case    3:*/		return 0x8226229C;
		  /* 8226229Ch */ case    4:  		/* li R3, 0 */
		/* 8226229Ch case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8226229Ch case    4:*/		return 0x822622A0;
		  /* 822622A0h */ case    5:  		/* li R7, 1388 */
		/* 822622A0h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x56C);
		/* 822622A0h case    5:*/		return 0x822622A4;
		  /* 822622A4h */ case    6:  		/* bc 4, CR6_EQ, 8 */
		/* 822622A4h case    6:*/		if ( !regs.CR[6].eq ) { return 0x822622AC;  }
		/* 822622A4h case    6:*/		return 0x822622A8;
		  /* 822622A8h */ case    7:  		/* li R7, 1385 */
		/* 822622A8h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x569);
		/* 822622A8h case    7:*/		return 0x822622AC;
	}
	return 0x822622AC;
} // Block from 8226228Ch-822622ACh (8 instructions)

//////////////////////////////////////////////////////
// Block at 822622ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822622AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822622AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822622AC);
		  /* 822622ACh */ case    0:  		/* bl -1091236 */
		/* 822622ACh case    0:*/		regs.LR = 0x822622B0; return 0x82157C08;
		/* 822622ACh case    0:*/		return 0x822622B0;
	}
	return 0x822622B0;
} // Block from 822622ACh-822622B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822622B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822622B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822622B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822622B0);
		  /* 822622B0h */ case    0:  		/* cmpwi CR6, R26, 66 */
		/* 822622B0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R26,0x00000042);
		/* 822622B0h case    0:*/		return 0x822622B4;
		  /* 822622B4h */ case    1:  		/* bc 12, CR6_GT, 3760 */
		/* 822622B4h case    1:*/		if ( regs.CR[6].gt ) { return 0x82263164;  }
		/* 822622B4h case    1:*/		return 0x822622B8;
		  /* 822622B8h */ case    2:  		/* bc 12, CR6_EQ, 2920 */
		/* 822622B8h case    2:*/		if ( regs.CR[6].eq ) { return 0x82262E20;  }
		/* 822622B8h case    2:*/		return 0x822622BC;
		  /* 822622BCh */ case    3:  		/* addi R11, R26, -20 */
		/* 822622BCh case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0xFFFFFFEC);
		/* 822622BCh case    3:*/		return 0x822622C0;
		  /* 822622C0h */ case    4:  		/* cmplwi CR6, R11, 9 */
		/* 822622C0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000009);
		/* 822622C0h case    4:*/		return 0x822622C4;
		  /* 822622C4h */ case    5:  		/* bc 12, CR6_GT, 4064 */
		/* 822622C4h case    5:*/		if ( regs.CR[6].gt ) { return 0x822632A4;  }
		/* 822622C4h case    5:*/		return 0x822622C8;
		  /* 822622C8h */ case    6:  		/* lis R12, -32251 */
		/* 822622C8h case    6:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8205);
		/* 822622C8h case    6:*/		return 0x822622CC;
		  /* 822622CCh */ case    7:  		/* rlwinm R0, R11, 1, 0, 30 */
		/* 822622CCh case    7:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R0,regs.R11);
		/* 822622CCh case    7:*/		return 0x822622D0;
		  /* 822622D0h */ case    8:  		/* addi R12, R12, -22168 */
		/* 822622D0h case    8:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0xFFFFA968);
		/* 822622D0h case    8:*/		return 0x822622D4;
		  /* 822622D4h */ case    9:  		/* lhzx R0, <#[R12 + R0]> */
		/* 822622D4h case    9:*/		cpu::mem::load16z( regs, &regs.R0, (uint32)(regs.R12 + regs.R0 + 0x00000000) );
		/* 822622D4h case    9:*/		return 0x822622D8;
		  /* 822622D8h */ case   10:  		/* lis R12, -32218 */
		/* 822622D8h case   10:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8226);
		/* 822622D8h case   10:*/		return 0x822622DC;
		  /* 822622DCh */ case   11:  		/* addi R12, R12, 8944 */
		/* 822622DCh case   11:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R12,0x22F0);
		/* 822622DCh case   11:*/		return 0x822622E0;
		  /* 822622E0h */ case   12:  		/* ori R0, R0, 0 */
		/* 822622E0h case   12:*/		cpu::op::ori<0>(regs,&regs.R0,regs.R0,0x0);
		/* 822622E0h case   12:*/		return 0x822622E4;
		  /* 822622E4h */ case   13:  		/* add R12, R12, R0 */
		/* 822622E4h case   13:*/		cpu::op::add<0>(regs,&regs.R12,regs.R12,regs.R0);
		/* 822622E4h case   13:*/		return 0x822622E8;
		  /* 822622E8h */ case   14:  		/* mtspr CTR, R12 */
		/* 822622E8h case   14:*/		regs.CTR = regs.R12;
		/* 822622E8h case   14:*/		return 0x822622EC;
		  /* 822622ECh */ case   15:  		/* bcctr 20, CR0_LT */
		/* 822622ECh case   15:*/		if ( 1 ) { return (uint32)regs.CTR; }
		/* 822622ECh case   15:*/		return 0x822622F0;
		  /* 822622F0h */ case   16:  		/* lwz R11, <#[R19 + 20]> */
		/* 822622F0h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 822622F0h case   16:*/		return 0x822622F4;
		  /* 822622F4h */ case   17:  		/* addi R11, R11, 4 */
		/* 822622F4h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 822622F4h case   17:*/		return 0x822622F8;
		  /* 822622F8h */ case   18:  		/* stw R11, <#[R19 + 20]> */
		/* 822622F8h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 822622F8h case   18:*/		return 0x822622FC;
		  /* 822622FCh */ case   19:  		/* addi R10, R11, 4 */
		/* 822622FCh case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 822622FCh case   19:*/		return 0x82262300;
		  /* 82262300h */ case   20:  		/* addi R7, R10, 4 */
		/* 82262300h case   20:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0x4);
		/* 82262300h case   20:*/		return 0x82262304;
		  /* 82262304h */ case   21:  		/* lwz R6, <#[R11]> */
		/* 82262304h case   21:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 82262304h case   21:*/		return 0x82262308;
		  /* 82262308h */ case   22:  		/* lwz R9, <#[R31 + 92]> */
		/* 82262308h case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000005C) );
		/* 82262308h case   22:*/		return 0x8226230C;
		  /* 8226230Ch */ case   23:  		/* rlwinm R8, R6, 19, 23, 28 */
		/* 8226230Ch case   23:*/		cpu::op::rlwinm<0,19,23,28>(regs,&regs.R8,regs.R6);
		/* 8226230Ch case   23:*/		return 0x82262310;
		  /* 82262310h */ case   24:  		/* extsh R30, R6 */
		/* 82262310h case   24:*/		cpu::op::extsh<0>(regs,&regs.R30,regs.R6);
		/* 82262310h case   24:*/		return 0x82262314;
		  /* 82262314h */ case   25:  		/* add R9, R8, R9 */
		/* 82262314h case   25:*/		cpu::op::add<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 82262314h case   25:*/		return 0x82262318;
		  /* 82262318h */ case   26:  		/* lwz R29, <#[R9 + 4]> */
		/* 82262318h case   26:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R9 + 0x00000004) );
		/* 82262318h case   26:*/		return 0x8226231C;
		  /* 8226231Ch */ case   27:  		/* stw R10, <#[R19 + 20]> */
		/* 8226231Ch case   27:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R19 + 0x00000014) );
		/* 8226231Ch case   27:*/		return 0x82262320;
		  /* 82262320h */ case   28:  		/* cmpwi CR6, R29, 19 */
		/* 82262320h case   28:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000013);
		/* 82262320h case   28:*/		return 0x82262324;
		  /* 82262324h */ case   29:  		/* lwz R11, <#[R11 + 4]> */
		/* 82262324h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82262324h case   29:*/		return 0x82262328;
		  /* 82262328h */ case   30:  		/* stw R7, <#[R19 + 20]> */
		/* 82262328h case   30:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R19 + 0x00000014) );
		/* 82262328h case   30:*/		return 0x8226232C;
		  /* 8226232Ch */ case   31:  		/* extsh R28, R11 */
		/* 8226232Ch case   31:*/		cpu::op::extsh<0>(regs,&regs.R28,regs.R11);
		/* 8226232Ch case   31:*/		return 0x82262330;
		  /* 82262330h */ case   32:  		/* bc 12, CR6_EQ, 48 */
		/* 82262330h case   32:*/		if ( regs.CR[6].eq ) { return 0x82262360;  }
		/* 82262330h case   32:*/		return 0x82262334;
		  /* 82262334h */ case   33:  		/* cmpwi CR6, R29, 20 */
		/* 82262334h case   33:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000014);
		/* 82262334h case   33:*/		return 0x82262338;
		  /* 82262338h */ case   34:  		/* bc 12, CR6_EQ, 40 */
		/* 82262338h case   34:*/		if ( regs.CR[6].eq ) { return 0x82262360;  }
		/* 82262338h case   34:*/		return 0x8226233C;
		  /* 8226233Ch */ case   35:  		/* lwz R26, <#[R1 + 128]> */
		/* 8226233Ch case   35:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x00000080) );
		/* 8226233Ch case   35:*/		return 0x82262340;
		  /* 82262340h */ case   36:  		/* li R7, 1409 */
		/* 82262340h case   36:*/		cpu::op::li<0>(regs,&regs.R7,0x581);
		/* 82262340h case   36:*/		return 0x82262344;
		  /* 82262344h */ case   37:  		/* lwz R27, <#[R1 + 132]> */
		/* 82262344h case   37:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000084) );
		/* 82262344h case   37:*/		return 0x82262348;
		  /* 82262348h */ case   38:  		/* li R3, 0 */
		/* 82262348h case   38:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82262348h case   38:*/		return 0x8226234C;
		  /* 8226234Ch */ case   39:  		/* mr R6, R26 */
		/* 8226234Ch case   39:*/		regs.R6 = regs.R26;
		/* 8226234Ch case   39:*/		return 0x82262350;
		  /* 82262350h */ case   40:  		/* lwz R5, <#[R1 + 436]> */
		/* 82262350h case   40:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000001B4) );
		/* 82262350h case   40:*/		return 0x82262354;
		  /* 82262354h */ case   41:  		/* mr R4, R27 */
		/* 82262354h case   41:*/		regs.R4 = regs.R27;
		/* 82262354h case   41:*/		return 0x82262358;
		  /* 82262358h */ case   42:  		/* bl -1091408 */
		/* 82262358h case   42:*/		regs.LR = 0x8226235C; return 0x82157C08;
		/* 82262358h case   42:*/		return 0x8226235C;
		  /* 8226235Ch */ case   43:  		/* b 12 */
		/* 8226235Ch case   43:*/		return 0x82262368;
		/* 8226235Ch case   43:*/		return 0x82262360;
	}
	return 0x82262360;
} // Block from 822622B0h-82262360h (44 instructions)

//////////////////////////////////////////////////////
// Block at 82262360h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262360( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262360) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262360);
		  /* 82262360h */ case    0:  		/* lwz R26, <#[R1 + 128]> */
		/* 82262360h case    0:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x00000080) );
		/* 82262360h case    0:*/		return 0x82262364;
		  /* 82262364h */ case    1:  		/* lwz R27, <#[R1 + 132]> */
		/* 82262364h case    1:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000084) );
		/* 82262364h case    1:*/		return 0x82262368;
	}
	return 0x82262368;
} // Block from 82262360h-82262368h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82262368h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262368( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262368) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262368);
		  /* 82262368h */ case    0:  		/* cmpw CR6, R28, R30 */
		/* 82262368h case    0:*/		cpu::op::cmpw<6>(regs,regs.R28,regs.R30);
		/* 82262368h case    0:*/		return 0x8226236C;
		  /* 8226236Ch */ case    1:  		/* bc 12, CR6_GT, 28 */
		/* 8226236Ch case    1:*/		if ( regs.CR[6].gt ) { return 0x82262388;  }
		/* 8226236Ch case    1:*/		return 0x82262370;
		  /* 82262370h */ case    2:  		/* mr R6, R26 */
		/* 82262370h case    2:*/		regs.R6 = regs.R26;
		/* 82262370h case    2:*/		return 0x82262374;
		  /* 82262374h */ case    3:  		/* lwz R5, <#[R1 + 444]> */
		/* 82262374h case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000001BC) );
		/* 82262374h case    3:*/		return 0x82262378;
		  /* 82262378h */ case    4:  		/* mr R4, R27 */
		/* 82262378h case    4:*/		regs.R4 = regs.R27;
		/* 82262378h case    4:*/		return 0x8226237C;
		  /* 8226237Ch */ case    5:  		/* li R7, 1410 */
		/* 8226237Ch case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x582);
		/* 8226237Ch case    5:*/		return 0x82262380;
		  /* 82262380h */ case    6:  		/* li R3, 0 */
		/* 82262380h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82262380h case    6:*/		return 0x82262384;
		  /* 82262384h */ case    7:  		/* bl -1091452 */
		/* 82262384h case    7:*/		regs.LR = 0x82262388; return 0x82157C08;
		/* 82262384h case    7:*/		return 0x82262388;
	}
	return 0x82262388;
} // Block from 82262368h-82262388h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82262388h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262388( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262388) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262388);
		  /* 82262388h */ case    0:  		/* lbz R11, <#[R31 + 2116]> */
		/* 82262388h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000844) );
		/* 82262388h case    0:*/		return 0x8226238C;
		  /* 8226238Ch */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 8226238Ch case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8226238Ch case    1:*/		return 0x82262390;
		  /* 82262390h */ case    2:  		/* bc 12, CR0_EQ, 28 */
		/* 82262390h case    2:*/		if ( regs.CR[0].eq ) { return 0x822623AC;  }
		/* 82262390h case    2:*/		return 0x82262394;
		  /* 82262394h */ case    3:  		/* mr R6, R26 */
		/* 82262394h case    3:*/		regs.R6 = regs.R26;
		/* 82262394h case    3:*/		return 0x82262398;
		  /* 82262398h */ case    4:  		/* lwz R5, <#[R1 + 452]> */
		/* 82262398h case    4:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000001C4) );
		/* 82262398h case    4:*/		return 0x8226239C;
		  /* 8226239Ch */ case    5:  		/* mr R4, R27 */
		/* 8226239Ch case    5:*/		regs.R4 = regs.R27;
		/* 8226239Ch case    5:*/		return 0x822623A0;
		  /* 822623A0h */ case    6:  		/* li R7, 1412 */
		/* 822623A0h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x584);
		/* 822623A0h case    6:*/		return 0x822623A4;
		  /* 822623A4h */ case    7:  		/* li R3, 0 */
		/* 822623A4h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822623A4h case    7:*/		return 0x822623A8;
		  /* 822623A8h */ case    8:  		/* bl -1091488 */
		/* 822623A8h case    8:*/		regs.LR = 0x822623AC; return 0x82157C08;
		/* 822623A8h case    8:*/		return 0x822623AC;
	}
	return 0x822623AC;
} // Block from 82262388h-822623ACh (9 instructions)

//////////////////////////////////////////////////////
// Block at 822623ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822623AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822623AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822623AC);
		  /* 822623ACh */ case    0:  		/* addi R11, R28, 1 */
		/* 822623ACh case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R28,0x1);
		/* 822623ACh case    0:*/		return 0x822623B0;
		  /* 822623B0h */ case    1:  		/* stw R29, <#[R31 + 2120]> */
		/* 822623B0h case    1:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000848) );
		/* 822623B0h case    1:*/		return 0x822623B4;
		  /* 822623B4h */ case    2:  		/* li R10, 1 */
		/* 822623B4h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 822623B4h case    2:*/		return 0x822623B8;
		  /* 822623B8h */ case    3:  		/* stw R30, <#[R31 + 2124]> */
		/* 822623B8h case    3:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000084C) );
		/* 822623B8h case    3:*/		return 0x822623BC;
		  /* 822623BCh */ case    4:  		/* stw R11, <#[R31 + 2128]> */
		/* 822623BCh case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000850) );
		/* 822623BCh case    4:*/		return 0x822623C0;
		  /* 822623C0h */ case    5:  		/* mr R3, R31 */
		/* 822623C0h case    5:*/		regs.R3 = regs.R31;
		/* 822623C0h case    5:*/		return 0x822623C4;
		  /* 822623C4h */ case    6:  		/* stb R10, <#[R31 + 2116]> */
		/* 822623C4h case    6:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R31 + 0x00000844) );
		/* 822623C4h case    6:*/		return 0x822623C8;
		  /* 822623C8h */ case    7:  		/* bl -182032 */
		/* 822623C8h case    7:*/		regs.LR = 0x822623CC; return 0x82235CB8;
		/* 822623C8h case    7:*/		return 0x822623CC;
		  /* 822623CCh */ case    8:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822623CCh case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822623CCh case    8:*/		return 0x822623D0;
		  /* 822623D0h */ case    9:  		/* bc 12, CR0_EQ, 3796 */
		/* 822623D0h case    9:*/		if ( regs.CR[0].eq ) { return 0x822632A4;  }
		/* 822623D0h case    9:*/		return 0x822623D4;
		  /* 822623D4h */ case   10:  		/* lwz R30, <#[R31 + 2124]> */
		/* 822623D4h case   10:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x0000084C) );
		/* 822623D4h case   10:*/		return 0x822623D8;
		  /* 822623D8h */ case   11:  		/* lwz R11, <#[R31 + 2128]> */
		/* 822623D8h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000850) );
		/* 822623D8h case   11:*/		return 0x822623DC;
		  /* 822623DCh */ case   12:  		/* cmpw CR6, R30, R11 */
		/* 822623DCh case   12:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R11);
		/* 822623DCh case   12:*/		return 0x822623E0;
		  /* 822623E0h */ case   13:  		/* bc 4, CR6_LT, 3780 */
		/* 822623E0h case   13:*/		if ( !regs.CR[6].lt ) { return 0x822632A4;  }
		/* 822623E0h case   13:*/		return 0x822623E4;
		  /* 822623E4h */ case   14:  		/* lwz R28, <#[R1 + 136]> */
		/* 822623E4h case   14:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000088) );
		/* 822623E4h case   14:*/		return 0x822623E8;
		  /* 822623E8h */ case   15:  		/* mr R5, R30 */
		/* 822623E8h case   15:*/		regs.R5 = regs.R30;
		/* 822623E8h case   15:*/		return 0x822623EC;
		  /* 822623ECh */ case   16:  		/* lwz R3, <#[R31 + 172]> */
		/* 822623ECh case   16:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000AC) );
		/* 822623ECh case   16:*/		return 0x822623F0;
		  /* 822623F0h */ case   17:  		/* mr R4, R29 */
		/* 822623F0h case   17:*/		regs.R4 = regs.R29;
		/* 822623F0h case   17:*/		return 0x822623F4;
		  /* 822623F4h */ case   18:  		/* bl -117732 */
		/* 822623F4h case   18:*/		regs.LR = 0x822623F8; return 0x82245810;
		/* 822623F4h case   18:*/		return 0x822623F8;
		  /* 822623F8h */ case   19:  		/* lwz R11, <#[R3]> */
		/* 822623F8h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822623F8h case   19:*/		return 0x822623FC;
		  /* 822623FCh */ case   20:  		/* mr R5, R31 */
		/* 822623FCh case   20:*/		regs.R5 = regs.R31;
		/* 822623FCh case   20:*/		return 0x82262400;
		  /* 82262400h */ case   21:  		/* lwz R4, <#[R28 - 1312]> */
		/* 82262400h case   21:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0xFFFFFAE0) );
		/* 82262400h case   21:*/		return 0x82262404;
		  /* 82262404h */ case   22:  		/* lwz R6, <#[R31 + 12]> */
		/* 82262404h case   22:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x0000000C) );
		/* 82262404h case   22:*/		return 0x82262408;
		  /* 82262408h */ case   23:  		/* lwz R11, <#[R11 + 28]> */
		/* 82262408h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 82262408h case   23:*/		return 0x8226240C;
		  /* 8226240Ch */ case   24:  		/* mtspr CTR, R11 */
		/* 8226240Ch case   24:*/		regs.CTR = regs.R11;
		/* 8226240Ch case   24:*/		return 0x82262410;
		  /* 82262410h */ case   25:  		/* bcctrl 20, CR0_LT */
		/* 82262410h case   25:*/		if ( 1 ) { regs.LR = 0x82262414; return (uint32)regs.CTR; }
		/* 82262410h case   25:*/		return 0x82262414;
		  /* 82262414h */ case   26:  		/* lwz R11, <#[R31 + 2128]> */
		/* 82262414h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000850) );
		/* 82262414h case   26:*/		return 0x82262418;
		  /* 82262418h */ case   27:  		/* addi R30, R30, 1 */
		/* 82262418h case   27:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82262418h case   27:*/		return 0x8226241C;
		  /* 8226241Ch */ case   28:  		/* cmpw CR6, R30, R11 */
		/* 8226241Ch case   28:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R11);
		/* 8226241Ch case   28:*/		return 0x82262420;
		  /* 82262420h */ case   29:  		/* bc 12, CR6_LT, -56 */
		/* 82262420h case   29:*/		if ( regs.CR[6].lt ) { return 0x822623E8;  }
		/* 82262420h case   29:*/		return 0x82262424;
		  /* 82262424h */ case   30:  		/* b 3712 */
		/* 82262424h case   30:*/		return 0x822632A4;
		/* 82262424h case   30:*/		return 0x82262428;
		  /* 82262428h */ case   31:  		/* lwz R11, <#[R19 + 20]> */
		/* 82262428h case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82262428h case   31:*/		return 0x8226242C;
		  /* 8226242Ch */ case   32:  		/* addi R30, R11, 4 */
		/* 8226242Ch case   32:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0x4);
		/* 8226242Ch case   32:*/		return 0x82262430;
		  /* 82262430h */ case   33:  		/* stw R30, <#[R19 + 20]> */
		/* 82262430h case   33:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R19 + 0x00000014) );
		/* 82262430h case   33:*/		return 0x82262434;
		  /* 82262434h */ case   34:  		/* lwz R11, <#[R11 + 4]> */
		/* 82262434h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82262434h case   34:*/		return 0x82262438;
		  /* 82262438h */ case   35:  		/* rlwinm. R11, R11, 10, 31, 31 */
		/* 82262438h case   35:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R11,regs.R11);
		/* 82262438h case   35:*/		return 0x8226243C;
		  /* 8226243Ch */ case   36:  		/* bc 12, CR0_EQ, 40 */
		/* 8226243Ch case   36:*/		if ( regs.CR[0].eq ) { return 0x82262464;  }
		/* 8226243Ch case   36:*/		return 0x82262440;
		  /* 82262440h */ case   37:  		/* mr R5, R28 */
		/* 82262440h case   37:*/		regs.R5 = regs.R28;
		/* 82262440h case   37:*/		return 0x82262444;
		  /* 82262444h */ case   38:  		/* lwz R6, <#[R1 + 128]> */
		/* 82262444h case   38:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 82262444h case   38:*/		return 0x82262448;
		  /* 82262448h */ case   39:  		/* li R7, 1448 */
		/* 82262448h case   39:*/		cpu::op::li<0>(regs,&regs.R7,0x5A8);
		/* 82262448h case   39:*/		return 0x8226244C;
		  /* 8226244Ch */ case   40:  		/* lwz R4, <#[R1 + 132]> */
		/* 8226244Ch case   40:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 8226244Ch case   40:*/		return 0x82262450;
		  /* 82262450h */ case   41:  		/* li R3, 0 */
		/* 82262450h case   41:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82262450h case   41:*/		return 0x82262454;
		  /* 82262454h */ case   42:  		/* bl -1091660 */
		/* 82262454h case   42:*/		regs.LR = 0x82262458; return 0x82157C08;
		/* 82262454h case   42:*/		return 0x82262458;
		  /* 82262458h */ case   43:  		/* lwz R11, <#[R19 + 20]> */
		/* 82262458h case   43:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82262458h case   43:*/		return 0x8226245C;
		  /* 8226245Ch */ case   44:  		/* addi R11, R11, 4 */
		/* 8226245Ch case   44:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8226245Ch case   44:*/		return 0x82262460;
		  /* 82262460h */ case   45:  		/* stw R11, <#[R19 + 20]> */
		/* 82262460h case   45:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82262460h case   45:*/		return 0x82262464;
	}
	return 0x82262464;
} // Block from 822623ACh-82262464h (46 instructions)

//////////////////////////////////////////////////////
// Block at 82262464h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262464( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262464) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262464);
		  /* 82262464h */ case    0:  		/* lwz R11, <#[R19 + 20]> */
		/* 82262464h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82262464h case    0:*/		return 0x82262468;
		  /* 82262468h */ case    1:  		/* addi R11, R11, 4 */
		/* 82262468h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82262468h case    1:*/		return 0x8226246C;
		  /* 8226246Ch */ case    2:  		/* stw R11, <#[R19 + 20]> */
		/* 8226246Ch case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 8226246Ch case    2:*/		return 0x82262470;
		  /* 82262470h */ case    3:  		/* lwz R9, <#[R30]> */
		/* 82262470h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 82262470h case    3:*/		return 0x82262474;
		  /* 82262474h */ case    4:  		/* lwz R11, <#[R31 + 92]> */
		/* 82262474h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 82262474h case    4:*/		return 0x82262478;
		  /* 82262478h */ case    5:  		/* rlwinm R10, R9, 19, 23, 28 */
		/* 82262478h case    5:*/		cpu::op::rlwinm<0,19,23,28>(regs,&regs.R10,regs.R9);
		/* 82262478h case    5:*/		return 0x8226247C;
		  /* 8226247Ch */ case    6:  		/* lwz R3, <#[R31 + 172]> */
		/* 8226247Ch case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000AC) );
		/* 8226247Ch case    6:*/		return 0x82262480;
		  /* 82262480h */ case    7:  		/* extsh R5, R9 */
		/* 82262480h case    7:*/		cpu::op::extsh<0>(regs,&regs.R5,regs.R9);
		/* 82262480h case    7:*/		return 0x82262484;
		  /* 82262484h */ case    8:  		/* add R11, R10, R11 */
		/* 82262484h case    8:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82262484h case    8:*/		return 0x82262488;
		  /* 82262488h */ case    9:  		/* lwz R4, <#[R11 + 4]> */
		/* 82262488h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000004) );
		/* 82262488h case    9:*/		return 0x8226248C;
		  /* 8226248Ch */ case   10:  		/* bl -117884 */
		/* 8226248Ch case   10:*/		regs.LR = 0x82262490; return 0x82245810;
		/* 8226248Ch case   10:*/		return 0x82262490;
		  /* 82262490h */ case   11:  		/* mr R29, R3 */
		/* 82262490h case   11:*/		regs.R29 = regs.R3;
		/* 82262490h case   11:*/		return 0x82262494;
		  /* 82262494h */ case   12:  		/* lhz R11, <#[R15]> */
		/* 82262494h case   12:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000000) );
		/* 82262494h case   12:*/		return 0x82262498;
		  /* 82262498h */ case   13:  		/* addi R30, R31, 184 */
		/* 82262498h case   13:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0xB8);
		/* 82262498h case   13:*/		return 0x8226249C;
		  /* 8226249Ch */ case   14:  		/* rlwinm R3, R11, 0, 30, 31 */
		/* 8226249Ch case   14:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R3,regs.R11);
		/* 8226249Ch case   14:*/		return 0x822624A0;
		  /* 822624A0h */ case   15:  		/* lwz R28, <#[R29 + 16]> */
		/* 822624A0h case   15:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R29 + 0x00000010) );
		/* 822624A0h case   15:*/		return 0x822624A4;
		  /* 822624A4h */ case   16:  		/* bl -32572 */
		/* 822624A4h case   16:*/		regs.LR = 0x822624A8; return 0x8225A568;
		/* 822624A4h case   16:*/		return 0x822624A8;
		  /* 822624A8h */ case   17:  		/* mr R6, R3 */
		/* 822624A8h case   17:*/		regs.R6 = regs.R3;
		/* 822624A8h case   17:*/		return 0x822624AC;
		  /* 822624ACh */ case   18:  		/* mr R3, R30 */
		/* 822624ACh case   18:*/		regs.R3 = regs.R30;
		/* 822624ACh case   18:*/		return 0x822624B0;
		  /* 822624B0h */ case   19:  		/* li R5, 0 */
		/* 822624B0h case   19:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 822624B0h case   19:*/		return 0x822624B4;
		  /* 822624B4h */ case   20:  		/* mr R4, R28 */
		/* 822624B4h case   20:*/		regs.R4 = regs.R28;
		/* 822624B4h case   20:*/		return 0x822624B8;
		  /* 822624B8h */ case   21:  		/* li R7, 19 */
		/* 822624B8h case   21:*/		cpu::op::li<0>(regs,&regs.R7,0x13);
		/* 822624B8h case   21:*/		return 0x822624BC;
		  /* 822624BCh */ case   22:  		/* li R8, 0 */
		/* 822624BCh case   22:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 822624BCh case   22:*/		return 0x822624C0;
		  /* 822624C0h */ case   23:  		/* bl -68696 */
		/* 822624C0h case   23:*/		regs.LR = 0x822624C4; return 0x82251868;
		/* 822624C0h case   23:*/		return 0x822624C4;
		  /* 822624C4h */ case   24:  		/* lwz R11, <#[R15]> */
		/* 822624C4h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000000) );
		/* 822624C4h case   24:*/		return 0x822624C8;
		  /* 822624C8h */ case   25:  		/* rlwinm R3, R11, 14, 30, 31 */
		/* 822624C8h case   25:*/		cpu::op::rlwinm<0,14,30,31>(regs,&regs.R3,regs.R11);
		/* 822624C8h case   25:*/		return 0x822624CC;
		  /* 822624CCh */ case   26:  		/* lwz R28, <#[R29 + 16]> */
		/* 822624CCh case   26:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R29 + 0x00000010) );
		/* 822624CCh case   26:*/		return 0x822624D0;
		  /* 822624D0h */ case   27:  		/* bl -32616 */
		/* 822624D0h case   27:*/		regs.LR = 0x822624D4; return 0x8225A568;
		/* 822624D0h case   27:*/		return 0x822624D4;
		  /* 822624D4h */ case   28:  		/* mr R6, R3 */
		/* 822624D4h case   28:*/		regs.R6 = regs.R3;
		/* 822624D4h case   28:*/		return 0x822624D8;
		  /* 822624D8h */ case   29:  		/* mr R3, R30 */
		/* 822624D8h case   29:*/		regs.R3 = regs.R30;
		/* 822624D8h case   29:*/		return 0x822624DC;
		  /* 822624DCh */ case   30:  		/* li R5, 1 */
		/* 822624DCh case   30:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 822624DCh case   30:*/		return 0x822624E0;
		  /* 822624E0h */ case   31:  		/* mr R4, R28 */
		/* 822624E0h case   31:*/		regs.R4 = regs.R28;
		/* 822624E0h case   31:*/		return 0x822624E4;
		  /* 822624E4h */ case   32:  		/* li R7, 19 */
		/* 822624E4h case   32:*/		cpu::op::li<0>(regs,&regs.R7,0x13);
		/* 822624E4h case   32:*/		return 0x822624E8;
		  /* 822624E8h */ case   33:  		/* li R8, 0 */
		/* 822624E8h case   33:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 822624E8h case   33:*/		return 0x822624EC;
		  /* 822624ECh */ case   34:  		/* bl -68740 */
		/* 822624ECh case   34:*/		regs.LR = 0x822624F0; return 0x82251868;
		/* 822624ECh case   34:*/		return 0x822624F0;
		  /* 822624F0h */ case   35:  		/* lwz R11, <#[R15]> */
		/* 822624F0h case   35:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000000) );
		/* 822624F0h case   35:*/		return 0x822624F4;
		  /* 822624F4h */ case   36:  		/* rlwinm R3, R11, 12, 30, 31 */
		/* 822624F4h case   36:*/		cpu::op::rlwinm<0,12,30,31>(regs,&regs.R3,regs.R11);
		/* 822624F4h case   36:*/		return 0x822624F8;
		  /* 822624F8h */ case   37:  		/* lwz R28, <#[R29 + 16]> */
		/* 822624F8h case   37:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R29 + 0x00000010) );
		/* 822624F8h case   37:*/		return 0x822624FC;
		  /* 822624FCh */ case   38:  		/* bl -32660 */
		/* 822624FCh case   38:*/		regs.LR = 0x82262500; return 0x8225A568;
		/* 822624FCh case   38:*/		return 0x82262500;
		  /* 82262500h */ case   39:  		/* mr R6, R3 */
		/* 82262500h case   39:*/		regs.R6 = regs.R3;
		/* 82262500h case   39:*/		return 0x82262504;
		  /* 82262504h */ case   40:  		/* mr R3, R30 */
		/* 82262504h case   40:*/		regs.R3 = regs.R30;
		/* 82262504h case   40:*/		return 0x82262508;
		  /* 82262508h */ case   41:  		/* li R5, 2 */
		/* 82262508h case   41:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 82262508h case   41:*/		return 0x8226250C;
		  /* 8226250Ch */ case   42:  		/* mr R4, R28 */
		/* 8226250Ch case   42:*/		regs.R4 = regs.R28;
		/* 8226250Ch case   42:*/		return 0x82262510;
		  /* 82262510h */ case   43:  		/* li R7, 19 */
		/* 82262510h case   43:*/		cpu::op::li<0>(regs,&regs.R7,0x13);
		/* 82262510h case   43:*/		return 0x82262514;
		  /* 82262514h */ case   44:  		/* li R8, 0 */
		/* 82262514h case   44:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82262514h case   44:*/		return 0x82262518;
		  /* 82262518h */ case   45:  		/* bl -68784 */
		/* 82262518h case   45:*/		regs.LR = 0x8226251C; return 0x82251868;
		/* 82262518h case   45:*/		return 0x8226251C;
		  /* 8226251Ch */ case   46:  		/* lwz R11, <#[R15]> */
		/* 8226251Ch case   46:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000000) );
		/* 8226251Ch case   46:*/		return 0x82262520;
		  /* 82262520h */ case   47:  		/* rlwinm R3, R11, 10, 30, 31 */
		/* 82262520h case   47:*/		cpu::op::rlwinm<0,10,30,31>(regs,&regs.R3,regs.R11);
		/* 82262520h case   47:*/		return 0x82262524;
		  /* 82262524h */ case   48:  		/* lwz R28, <#[R29 + 16]> */
		/* 82262524h case   48:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R29 + 0x00000010) );
		/* 82262524h case   48:*/		return 0x82262528;
		  /* 82262528h */ case   49:  		/* bl -32704 */
		/* 82262528h case   49:*/		regs.LR = 0x8226252C; return 0x8225A568;
		/* 82262528h case   49:*/		return 0x8226252C;
		  /* 8226252Ch */ case   50:  		/* mr R6, R3 */
		/* 8226252Ch case   50:*/		regs.R6 = regs.R3;
		/* 8226252Ch case   50:*/		return 0x82262530;
		  /* 82262530h */ case   51:  		/* li R5, 3 */
		/* 82262530h case   51:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 82262530h case   51:*/		return 0x82262534;
		  /* 82262534h */ case   52:  		/* mr R4, R28 */
		/* 82262534h case   52:*/		regs.R4 = regs.R28;
		/* 82262534h case   52:*/		return 0x82262538;
		  /* 82262538h */ case   53:  		/* mr R3, R30 */
		/* 82262538h case   53:*/		regs.R3 = regs.R30;
		/* 82262538h case   53:*/		return 0x8226253C;
		  /* 8226253Ch */ case   54:  		/* li R7, 19 */
		/* 8226253Ch case   54:*/		cpu::op::li<0>(regs,&regs.R7,0x13);
		/* 8226253Ch case   54:*/		return 0x82262540;
		  /* 82262540h */ case   55:  		/* li R8, 0 */
		/* 82262540h case   55:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82262540h case   55:*/		return 0x82262544;
		  /* 82262544h */ case   56:  		/* bl -68828 */
		/* 82262544h case   56:*/		regs.LR = 0x82262548; return 0x82251868;
		/* 82262544h case   56:*/		return 0x82262548;
		  /* 82262548h */ case   57:  		/* lbz R11, <#[R15]> */
		/* 82262548h case   57:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000000) );
		/* 82262548h case   57:*/		return 0x8226254C;
		  /* 8226254Ch */ case   58:  		/* rlwinm R11, R11, 0, 31, 31 */
		/* 8226254Ch case   58:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R11,regs.R11);
		/* 8226254Ch case   58:*/		return 0x82262550;
		  /* 82262550h */ case   59:  		/* stw R11, <#[R29 + 48]> */
		/* 82262550h case   59:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000030) );
		/* 82262550h case   59:*/		return 0x82262554;
		  /* 82262554h */ case   60:  		/* lwz R11, <#[R15]> */
		/* 82262554h case   60:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000000) );
		/* 82262554h case   60:*/		return 0x82262558;
		  /* 82262558h */ case   61:  		/* rlwinm R11, R11, 7, 31, 31 */
		/* 82262558h case   61:*/		cpu::op::rlwinm<0,7,31,31>(regs,&regs.R11,regs.R11);
		/* 82262558h case   61:*/		return 0x8226255C;
		  /* 8226255Ch */ case   62:  		/* stw R11, <#[R29 + 52]> */
		/* 8226255Ch case   62:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000034) );
		/* 8226255Ch case   62:*/		return 0x82262560;
		  /* 82262560h */ case   63:  		/* b 3396 */
		/* 82262560h case   63:*/		return 0x822632A4;
		/* 82262560h case   63:*/		return 0x82262564;
		  /* 82262564h */ case   64:  		/* li R11, 1 */
		/* 82262564h case   64:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82262564h case   64:*/		return 0x82262568;
		  /* 82262568h */ case   65:  		/* lbz R29, <#[R15 + 1]> */
		/* 82262568h case   65:*/		cpu::mem::load8z( regs, &regs.R29, (uint32)(regs.R15 + 0x00000001) );
		/* 82262568h case   65:*/		return 0x8226256C;
		  /* 8226256Ch */ case   66:  		/* stb R11, <#[R31 + 2057]> */
		/* 8226256Ch case   66:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000809) );
		/* 8226256Ch case   66:*/		return 0x82262570;
		  /* 82262570h */ case   67:  		/* lwz R11, <#[R19 + 20]> */
		/* 82262570h case   67:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82262570h case   67:*/		return 0x82262574;
		  /* 82262574h */ case   68:  		/* addi R30, R11, 4 */
		/* 82262574h case   68:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0x4);
		/* 82262574h case   68:*/		return 0x82262578;
		  /* 82262578h */ case   69:  		/* stw R30, <#[R19 + 20]> */
		/* 82262578h case   69:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R19 + 0x00000014) );
		/* 82262578h case   69:*/		return 0x8226257C;
		  /* 8226257Ch */ case   70:  		/* lwz R11, <#[R11 + 4]> */
		/* 8226257Ch case   70:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8226257Ch case   70:*/		return 0x82262580;
		  /* 82262580h */ case   71:  		/* rlwinm. R11, R11, 10, 31, 31 */
		/* 82262580h case   71:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R11,regs.R11);
		/* 82262580h case   71:*/		return 0x82262584;
		  /* 82262584h */ case   72:  		/* bc 12, CR0_EQ, 40 */
		/* 82262584h case   72:*/		if ( regs.CR[0].eq ) { return 0x822625AC;  }
		/* 82262584h case   72:*/		return 0x82262588;
		  /* 82262588h */ case   73:  		/* mr R5, R28 */
		/* 82262588h case   73:*/		regs.R5 = regs.R28;
		/* 82262588h case   73:*/		return 0x8226258C;
		  /* 8226258Ch */ case   74:  		/* lwz R6, <#[R1 + 128]> */
		/* 8226258Ch case   74:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 8226258Ch case   74:*/		return 0x82262590;
		  /* 82262590h */ case   75:  		/* li R7, 1493 */
		/* 82262590h case   75:*/		cpu::op::li<0>(regs,&regs.R7,0x5D5);
		/* 82262590h case   75:*/		return 0x82262594;
		  /* 82262594h */ case   76:  		/* lwz R4, <#[R1 + 132]> */
		/* 82262594h case   76:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 82262594h case   76:*/		return 0x82262598;
		  /* 82262598h */ case   77:  		/* li R3, 0 */
		/* 82262598h case   77:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82262598h case   77:*/		return 0x8226259C;
		  /* 8226259Ch */ case   78:  		/* bl -1091988 */
		/* 8226259Ch case   78:*/		regs.LR = 0x822625A0; return 0x82157C08;
		/* 8226259Ch case   78:*/		return 0x822625A0;
		  /* 822625A0h */ case   79:  		/* lwz R11, <#[R19 + 20]> */
		/* 822625A0h case   79:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 822625A0h case   79:*/		return 0x822625A4;
		  /* 822625A4h */ case   80:  		/* addi R11, R11, 4 */
		/* 822625A4h case   80:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 822625A4h case   80:*/		return 0x822625A8;
		  /* 822625A8h */ case   81:  		/* stw R11, <#[R19 + 20]> */
		/* 822625A8h case   81:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 822625A8h case   81:*/		return 0x822625AC;
	}
	return 0x822625AC;
} // Block from 82262464h-822625ACh (82 instructions)

//////////////////////////////////////////////////////
// Block at 822625ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822625AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822625AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822625AC);
		  /* 822625ACh */ case    0:  		/* lwz R11, <#[R19 + 20]> */
		/* 822625ACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 822625ACh case    0:*/		return 0x822625B0;
		  /* 822625B0h */ case    1:  		/* mr R6, R29 */
		/* 822625B0h case    1:*/		regs.R6 = regs.R29;
		/* 822625B0h case    1:*/		return 0x822625B4;
		  /* 822625B4h */ case    2:  		/* addi R11, R11, 4 */
		/* 822625B4h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 822625B4h case    2:*/		return 0x822625B8;
		  /* 822625B8h */ case    3:  		/* stw R11, <#[R19 + 20]> */
		/* 822625B8h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 822625B8h case    3:*/		return 0x822625BC;
		  /* 822625BCh */ case    4:  		/* lwz R9, <#[R30]> */
		/* 822625BCh case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 822625BCh case    4:*/		return 0x822625C0;
		  /* 822625C0h */ case    5:  		/* lwz R11, <#[R31 + 92]> */
		/* 822625C0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 822625C0h case    5:*/		return 0x822625C4;
		  /* 822625C4h */ case    6:  		/* rlwinm R10, R9, 19, 23, 28 */
		/* 822625C4h case    6:*/		cpu::op::rlwinm<0,19,23,28>(regs,&regs.R10,regs.R9);
		/* 822625C4h case    6:*/		return 0x822625C8;
		  /* 822625C8h */ case    7:  		/* lwz R3, <#[R31 + 172]> */
		/* 822625C8h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000AC) );
		/* 822625C8h case    7:*/		return 0x822625CC;
		  /* 822625CCh */ case    8:  		/* extsh R5, R9 */
		/* 822625CCh case    8:*/		cpu::op::extsh<0>(regs,&regs.R5,regs.R9);
		/* 822625CCh case    8:*/		return 0x822625D0;
		  /* 822625D0h */ case    9:  		/* add R11, R10, R11 */
		/* 822625D0h case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 822625D0h case    9:*/		return 0x822625D4;
		  /* 822625D4h */ case   10:  		/* lwz R4, <#[R11 + 4]> */
		/* 822625D4h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000004) );
		/* 822625D4h case   10:*/		return 0x822625D8;
		  /* 822625D8h */ case   11:  		/* bl -118128 */
		/* 822625D8h case   11:*/		regs.LR = 0x822625DC; return 0x82245868;
		/* 822625D8h case   11:*/		return 0x822625DC;
		  /* 822625DCh */ case   12:  		/* lwz R11, <#[R3]> */
		/* 822625DCh case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822625DCh case   12:*/		return 0x822625E0;
		  /* 822625E0h */ case   13:  		/* mr R30, R3 */
		/* 822625E0h case   13:*/		regs.R30 = regs.R3;
		/* 822625E0h case   13:*/		return 0x822625E4;
		  /* 822625E4h */ case   14:  		/* lwz R11, <#[R11 + 8]> */
		/* 822625E4h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 822625E4h case   14:*/		return 0x822625E8;
		  /* 822625E8h */ case   15:  		/* mtspr CTR, R11 */
		/* 822625E8h case   15:*/		regs.CTR = regs.R11;
		/* 822625E8h case   15:*/		return 0x822625EC;
		  /* 822625ECh */ case   16:  		/* bcctrl 20, CR0_LT */
		/* 822625ECh case   16:*/		if ( 1 ) { regs.LR = 0x822625F0; return (uint32)regs.CTR; }
		/* 822625ECh case   16:*/		return 0x822625F0;
		  /* 822625F0h */ case   17:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822625F0h case   17:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822625F0h case   17:*/		return 0x822625F4;
		  /* 822625F4h */ case   18:  		/* bc 4, CR0_EQ, 28 */
		/* 822625F4h case   18:*/		if ( !regs.CR[0].eq ) { return 0x82262610;  }
		/* 822625F4h case   18:*/		return 0x822625F8;
		  /* 822625F8h */ case   19:  		/* li R7, 1504 */
		/* 822625F8h case   19:*/		cpu::op::li<0>(regs,&regs.R7,0x5E0);
		/* 822625F8h case   19:*/		return 0x822625FC;
		  /* 822625FCh */ case   20:  		/* lwz R6, <#[R1 + 128]> */
		/* 822625FCh case   20:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 822625FCh case   20:*/		return 0x82262600;
		  /* 82262600h */ case   21:  		/* li R3, 0 */
		/* 82262600h case   21:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82262600h case   21:*/		return 0x82262604;
		  /* 82262604h */ case   22:  		/* lwz R5, <#[R1 + 460]> */
		/* 82262604h case   22:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000001CC) );
		/* 82262604h case   22:*/		return 0x82262608;
		  /* 82262608h */ case   23:  		/* lwz R4, <#[R1 + 132]> */
		/* 82262608h case   23:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 82262608h case   23:*/		return 0x8226260C;
		  /* 8226260Ch */ case   24:  		/* bl -1092100 */
		/* 8226260Ch case   24:*/		regs.LR = 0x82262610; return 0x82157C08;
		/* 8226260Ch case   24:*/		return 0x82262610;
	}
	return 0x82262610;
} // Block from 822625ACh-82262610h (25 instructions)

//////////////////////////////////////////////////////
// Block at 82262610h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262610( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262610) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262610);
		  /* 82262610h */ case    0:  		/* lhz R11, <#[R15]> */
		/* 82262610h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000000) );
		/* 82262610h case    0:*/		return 0x82262614;
		  /* 82262614h */ case    1:  		/* addi R29, R31, 184 */
		/* 82262614h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R31,0xB8);
		/* 82262614h case    1:*/		return 0x82262618;
		  /* 82262618h */ case    2:  		/* lwz R28, <#[R30 + 16]> */
		/* 82262618h case    2:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R30 + 0x00000010) );
		/* 82262618h case    2:*/		return 0x8226261C;
		  /* 8226261Ch */ case    3:  		/* rlwinm R3, R11, 0, 30, 31 */
		/* 8226261Ch case    3:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R3,regs.R11);
		/* 8226261Ch case    3:*/		return 0x82262620;
		  /* 82262620h */ case    4:  		/* bl -32952 */
		/* 82262620h case    4:*/		regs.LR = 0x82262624; return 0x8225A568;
		/* 82262620h case    4:*/		return 0x82262624;
		  /* 82262624h */ case    5:  		/* mr R6, R3 */
		/* 82262624h case    5:*/		regs.R6 = regs.R3;
		/* 82262624h case    5:*/		return 0x82262628;
		  /* 82262628h */ case    6:  		/* mr R3, R29 */
		/* 82262628h case    6:*/		regs.R3 = regs.R29;
		/* 82262628h case    6:*/		return 0x8226262C;
		  /* 8226262Ch */ case    7:  		/* li R5, 0 */
		/* 8226262Ch case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8226262Ch case    7:*/		return 0x82262630;
		  /* 82262630h */ case    8:  		/* mr R4, R28 */
		/* 82262630h case    8:*/		regs.R4 = regs.R28;
		/* 82262630h case    8:*/		return 0x82262634;
		  /* 82262634h */ case    9:  		/* li R7, 19 */
		/* 82262634h case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x13);
		/* 82262634h case    9:*/		return 0x82262638;
		  /* 82262638h */ case   10:  		/* li R8, 0 */
		/* 82262638h case   10:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82262638h case   10:*/		return 0x8226263C;
		  /* 8226263Ch */ case   11:  		/* bl -69076 */
		/* 8226263Ch case   11:*/		regs.LR = 0x82262640; return 0x82251868;
		/* 8226263Ch case   11:*/		return 0x82262640;
		  /* 82262640h */ case   12:  		/* lwz R11, <#[R15]> */
		/* 82262640h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000000) );
		/* 82262640h case   12:*/		return 0x82262644;
		  /* 82262644h */ case   13:  		/* rlwinm R3, R11, 14, 30, 31 */
		/* 82262644h case   13:*/		cpu::op::rlwinm<0,14,30,31>(regs,&regs.R3,regs.R11);
		/* 82262644h case   13:*/		return 0x82262648;
		  /* 82262648h */ case   14:  		/* lwz R28, <#[R30 + 16]> */
		/* 82262648h case   14:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R30 + 0x00000010) );
		/* 82262648h case   14:*/		return 0x8226264C;
		  /* 8226264Ch */ case   15:  		/* bl -32996 */
		/* 8226264Ch case   15:*/		regs.LR = 0x82262650; return 0x8225A568;
		/* 8226264Ch case   15:*/		return 0x82262650;
		  /* 82262650h */ case   16:  		/* mr R6, R3 */
		/* 82262650h case   16:*/		regs.R6 = regs.R3;
		/* 82262650h case   16:*/		return 0x82262654;
		  /* 82262654h */ case   17:  		/* mr R3, R29 */
		/* 82262654h case   17:*/		regs.R3 = regs.R29;
		/* 82262654h case   17:*/		return 0x82262658;
		  /* 82262658h */ case   18:  		/* li R5, 1 */
		/* 82262658h case   18:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82262658h case   18:*/		return 0x8226265C;
		  /* 8226265Ch */ case   19:  		/* mr R4, R28 */
		/* 8226265Ch case   19:*/		regs.R4 = regs.R28;
		/* 8226265Ch case   19:*/		return 0x82262660;
		  /* 82262660h */ case   20:  		/* li R7, 19 */
		/* 82262660h case   20:*/		cpu::op::li<0>(regs,&regs.R7,0x13);
		/* 82262660h case   20:*/		return 0x82262664;
		  /* 82262664h */ case   21:  		/* li R8, 0 */
		/* 82262664h case   21:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82262664h case   21:*/		return 0x82262668;
		  /* 82262668h */ case   22:  		/* bl -69120 */
		/* 82262668h case   22:*/		regs.LR = 0x8226266C; return 0x82251868;
		/* 82262668h case   22:*/		return 0x8226266C;
		  /* 8226266Ch */ case   23:  		/* lwz R11, <#[R15]> */
		/* 8226266Ch case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000000) );
		/* 8226266Ch case   23:*/		return 0x82262670;
		  /* 82262670h */ case   24:  		/* rlwinm R3, R11, 12, 30, 31 */
		/* 82262670h case   24:*/		cpu::op::rlwinm<0,12,30,31>(regs,&regs.R3,regs.R11);
		/* 82262670h case   24:*/		return 0x82262674;
		  /* 82262674h */ case   25:  		/* lwz R28, <#[R30 + 16]> */
		/* 82262674h case   25:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R30 + 0x00000010) );
		/* 82262674h case   25:*/		return 0x82262678;
		  /* 82262678h */ case   26:  		/* bl -33040 */
		/* 82262678h case   26:*/		regs.LR = 0x8226267C; return 0x8225A568;
		/* 82262678h case   26:*/		return 0x8226267C;
		  /* 8226267Ch */ case   27:  		/* mr R6, R3 */
		/* 8226267Ch case   27:*/		regs.R6 = regs.R3;
		/* 8226267Ch case   27:*/		return 0x82262680;
		  /* 82262680h */ case   28:  		/* mr R3, R29 */
		/* 82262680h case   28:*/		regs.R3 = regs.R29;
		/* 82262680h case   28:*/		return 0x82262684;
		  /* 82262684h */ case   29:  		/* li R5, 2 */
		/* 82262684h case   29:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 82262684h case   29:*/		return 0x82262688;
		  /* 82262688h */ case   30:  		/* mr R4, R28 */
		/* 82262688h case   30:*/		regs.R4 = regs.R28;
		/* 82262688h case   30:*/		return 0x8226268C;
		  /* 8226268Ch */ case   31:  		/* li R7, 19 */
		/* 8226268Ch case   31:*/		cpu::op::li<0>(regs,&regs.R7,0x13);
		/* 8226268Ch case   31:*/		return 0x82262690;
		  /* 82262690h */ case   32:  		/* li R8, 0 */
		/* 82262690h case   32:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82262690h case   32:*/		return 0x82262694;
		  /* 82262694h */ case   33:  		/* bl -69164 */
		/* 82262694h case   33:*/		regs.LR = 0x82262698; return 0x82251868;
		/* 82262694h case   33:*/		return 0x82262698;
		  /* 82262698h */ case   34:  		/* lwz R11, <#[R15]> */
		/* 82262698h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000000) );
		/* 82262698h case   34:*/		return 0x8226269C;
		  /* 8226269Ch */ case   35:  		/* rlwinm R3, R11, 10, 30, 31 */
		/* 8226269Ch case   35:*/		cpu::op::rlwinm<0,10,30,31>(regs,&regs.R3,regs.R11);
		/* 8226269Ch case   35:*/		return 0x822626A0;
		  /* 822626A0h */ case   36:  		/* lwz R28, <#[R30 + 16]> */
		/* 822626A0h case   36:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R30 + 0x00000010) );
		/* 822626A0h case   36:*/		return 0x822626A4;
		  /* 822626A4h */ case   37:  		/* bl -33084 */
		/* 822626A4h case   37:*/		regs.LR = 0x822626A8; return 0x8225A568;
		/* 822626A4h case   37:*/		return 0x822626A8;
		  /* 822626A8h */ case   38:  		/* mr R6, R3 */
		/* 822626A8h case   38:*/		regs.R6 = regs.R3;
		/* 822626A8h case   38:*/		return 0x822626AC;
		  /* 822626ACh */ case   39:  		/* li R5, 3 */
		/* 822626ACh case   39:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 822626ACh case   39:*/		return 0x822626B0;
		  /* 822626B0h */ case   40:  		/* mr R4, R28 */
		/* 822626B0h case   40:*/		regs.R4 = regs.R28;
		/* 822626B0h case   40:*/		return 0x822626B4;
		  /* 822626B4h */ case   41:  		/* mr R3, R29 */
		/* 822626B4h case   41:*/		regs.R3 = regs.R29;
		/* 822626B4h case   41:*/		return 0x822626B8;
		  /* 822626B8h */ case   42:  		/* li R7, 19 */
		/* 822626B8h case   42:*/		cpu::op::li<0>(regs,&regs.R7,0x13);
		/* 822626B8h case   42:*/		return 0x822626BC;
		  /* 822626BCh */ case   43:  		/* li R8, 0 */
		/* 822626BCh case   43:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 822626BCh case   43:*/		return 0x822626C0;
		  /* 822626C0h */ case   44:  		/* bl -69208 */
		/* 822626C0h case   44:*/		regs.LR = 0x822626C4; return 0x82251868;
		/* 822626C0h case   44:*/		return 0x822626C4;
		  /* 822626C4h */ case   45:  		/* lbz R11, <#[R15]> */
		/* 822626C4h case   45:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000000) );
		/* 822626C4h case   45:*/		return 0x822626C8;
		  /* 822626C8h */ case   46:  		/* rlwinm R11, R11, 0, 31, 31 */
		/* 822626C8h case   46:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R11,regs.R11);
		/* 822626C8h case   46:*/		return 0x822626CC;
		  /* 822626CCh */ case   47:  		/* stw R11, <#[R30 + 48]> */
		/* 822626CCh case   47:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000030) );
		/* 822626CCh case   47:*/		return 0x822626D0;
		  /* 822626D0h */ case   48:  		/* lwz R11, <#[R15]> */
		/* 822626D0h case   48:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000000) );
		/* 822626D0h case   48:*/		return 0x822626D4;
		  /* 822626D4h */ case   49:  		/* rlwinm R11, R11, 7, 31, 31 */
		/* 822626D4h case   49:*/		cpu::op::rlwinm<0,7,31,31>(regs,&regs.R11,regs.R11);
		/* 822626D4h case   49:*/		return 0x822626D8;
		  /* 822626D8h */ case   50:  		/* stw R11, <#[R30 + 52]> */
		/* 822626D8h case   50:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000034) );
		/* 822626D8h case   50:*/		return 0x822626DC;
		  /* 822626DCh */ case   51:  		/* b 3016 */
		/* 822626DCh case   51:*/		return 0x822632A4;
		/* 822626DCh case   51:*/		return 0x822626E0;
		  /* 822626E0h */ case   52:  		/* lhz R11, <#[R15]> */
		/* 822626E0h case   52:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000000) );
		/* 822626E0h case   52:*/		return 0x822626E4;
		  /* 822626E4h */ case   53:  		/* rlwinm R3, R11, 0, 27, 31 */
		/* 822626E4h case   53:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R3,regs.R11);
		/* 822626E4h case   53:*/		return 0x822626E8;
		  /* 822626E8h */ case   54:  		/* bl -33024 */
		/* 822626E8h case   54:*/		regs.LR = 0x822626EC; return 0x8225A5E8;
		/* 822626E8h case   54:*/		return 0x822626EC;
		  /* 822626ECh */ case   55:  		/* lwz R11, <#[R19 + 20]> */
		/* 822626ECh case   55:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 822626ECh case   55:*/		return 0x822626F0;
		  /* 822626F0h */ case   56:  		/* lwz R10, <#[R15]> */
		/* 822626F0h case   56:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R15 + 0x00000000) );
		/* 822626F0h case   56:*/		return 0x822626F4;
		  /* 822626F4h */ case   57:  		/* mr R22, R3 */
		/* 822626F4h case   57:*/		regs.R22 = regs.R3;
		/* 822626F4h case   57:*/		return 0x822626F8;
		  /* 822626F8h */ case   58:  		/* addi R30, R11, 4 */
		/* 822626F8h case   58:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0x4);
		/* 822626F8h case   58:*/		return 0x822626FC;
		  /* 822626FCh */ case   59:  		/* rlwinm R24, R10, 11, 24, 31 */
		/* 822626FCh case   59:*/		cpu::op::rlwinm<0,11,24,31>(regs,&regs.R24,regs.R10);
		/* 822626FCh case   59:*/		return 0x82262700;
		  /* 82262700h */ case   60:  		/* stw R30, <#[R19 + 20]> */
		/* 82262700h case   60:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R19 + 0x00000014) );
		/* 82262700h case   60:*/		return 0x82262704;
		  /* 82262704h */ case   61:  		/* lwz R11, <#[R15]> */
		/* 82262704h case   61:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000000) );
		/* 82262704h case   61:*/		return 0x82262708;
		  /* 82262708h */ case   62:  		/* rlwinm. R11, R11, 0, 0, 0 */
		/* 82262708h case   62:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R11,regs.R11);
		/* 82262708h case   62:*/		return 0x8226270C;
		  /* 8226270Ch */ case   63:  		/* bc 12, CR0_EQ, 92 */
		/* 8226270Ch case   63:*/		if ( regs.CR[0].eq ) { return 0x82262768;  }
		/* 8226270Ch case   63:*/		return 0x82262710;
		  /* 82262710h */ case   64:  		/* lwz R11, <#[R30]> */
		/* 82262710h case   64:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82262710h case   64:*/		return 0x82262714;
		  /* 82262714h */ case   65:  		/* rlwinm R3, R11, 0, 30, 31 */
		/* 82262714h case   65:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R3,regs.R11);
		/* 82262714h case   65:*/		return 0x82262718;
		  /* 82262718h */ case   66:  		/* bl -33200 */
		/* 82262718h case   66:*/		regs.LR = 0x8226271C; return 0x8225A568;
		/* 82262718h case   66:*/		return 0x8226271C;
		  /* 8226271Ch */ case   67:  		/* lwz R11, <#[R30]> */
		/* 8226271Ch case   67:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8226271Ch case   67:*/		return 0x82262720;
		  /* 82262720h */ case   68:  		/* mr R27, R3 */
		/* 82262720h case   68:*/		regs.R27 = regs.R3;
		/* 82262720h case   68:*/		return 0x82262724;
		  /* 82262724h */ case   69:  		/* rlwinm R3, R11, 30, 30, 31 */
		/* 82262724h case   69:*/		cpu::op::rlwinm<0,30,30,31>(regs,&regs.R3,regs.R11);
		/* 82262724h case   69:*/		return 0x82262728;
		  /* 82262728h */ case   70:  		/* bl -33216 */
		/* 82262728h case   70:*/		regs.LR = 0x8226272C; return 0x8225A568;
		/* 82262728h case   70:*/		return 0x8226272C;
		  /* 8226272Ch */ case   71:  		/* lwz R11, <#[R30]> */
		/* 8226272Ch case   71:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8226272Ch case   71:*/		return 0x82262730;
		  /* 82262730h */ case   72:  		/* mr R25, R3 */
		/* 82262730h case   72:*/		regs.R25 = regs.R3;
		/* 82262730h case   72:*/		return 0x82262734;
		  /* 82262734h */ case   73:  		/* rlwinm R3, R11, 28, 30, 31 */
		/* 82262734h case   73:*/		cpu::op::rlwinm<0,28,30,31>(regs,&regs.R3,regs.R11);
		/* 82262734h case   73:*/		return 0x82262738;
		  /* 82262738h */ case   74:  		/* bl -33232 */
		/* 82262738h case   74:*/		regs.LR = 0x8226273C; return 0x8225A568;
		/* 82262738h case   74:*/		return 0x8226273C;
		  /* 8226273Ch */ case   75:  		/* lwz R11, <#[R30]> */
		/* 8226273Ch case   75:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8226273Ch case   75:*/		return 0x82262740;
		  /* 82262740h */ case   76:  		/* mr R23, R3 */
		/* 82262740h case   76:*/		regs.R23 = regs.R3;
		/* 82262740h case   76:*/		return 0x82262744;
		  /* 82262744h */ case   77:  		/* rlwinm R3, R11, 26, 30, 31 */
		/* 82262744h case   77:*/		cpu::op::rlwinm<0,26,30,31>(regs,&regs.R3,regs.R11);
		/* 82262744h case   77:*/		return 0x82262748;
		  /* 82262748h */ case   78:  		/* bl -33248 */
		/* 82262748h case   78:*/		regs.LR = 0x8226274C; return 0x8225A568;
		/* 82262748h case   78:*/		return 0x8226274C;
		  /* 8226274Ch */ case   79:  		/* lwz R11, <#[R19 + 20]> */
		/* 8226274Ch case   79:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 8226274Ch case   79:*/		return 0x82262750;
		  /* 82262750h */ case   80:  		/* lwz R10, <#[R30]> */
		/* 82262750h case   80:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82262750h case   80:*/		return 0x82262754;
		  /* 82262754h */ case   81:  		/* mr R21, R3 */
		/* 82262754h case   81:*/		regs.R21 = regs.R3;
		/* 82262754h case   81:*/		return 0x82262758;
		  /* 82262758h */ case   82:  		/* addi R30, R11, 4 */
		/* 82262758h case   82:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0x4);
		/* 82262758h case   82:*/		return 0x8226275C;
		  /* 8226275Ch */ case   83:  		/* rlwinm R20, R10, 24, 31, 31 */
		/* 8226275Ch case   83:*/		cpu::op::rlwinm<0,24,31,31>(regs,&regs.R20,regs.R10);
		/* 8226275Ch case   83:*/		return 0x82262760;
		  /* 82262760h */ case   84:  		/* stw R30, <#[R19 + 20]> */
		/* 82262760h case   84:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R19 + 0x00000014) );
		/* 82262760h case   84:*/		return 0x82262764;
		  /* 82262764h */ case   85:  		/* b 24 */
		/* 82262764h case   85:*/		return 0x8226277C;
		/* 82262764h case   85:*/		return 0x82262768;
	}
	return 0x82262768;
} // Block from 82262610h-82262768h (86 instructions)

//////////////////////////////////////////////////////
// Block at 82262768h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262768( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262768) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262768);
		  /* 82262768h */ case    0:  		/* li R27, 5 */
		/* 82262768h case    0:*/		cpu::op::li<0>(regs,&regs.R27,0x5);
		/* 82262768h case    0:*/		return 0x8226276C;
		  /* 8226276Ch */ case    1:  		/* li R25, 5 */
		/* 8226276Ch case    1:*/		cpu::op::li<0>(regs,&regs.R25,0x5);
		/* 8226276Ch case    1:*/		return 0x82262770;
		  /* 82262770h */ case    2:  		/* li R23, 5 */
		/* 82262770h case    2:*/		cpu::op::li<0>(regs,&regs.R23,0x5);
		/* 82262770h case    2:*/		return 0x82262774;
		  /* 82262774h */ case    3:  		/* li R21, 5 */
		/* 82262774h case    3:*/		cpu::op::li<0>(regs,&regs.R21,0x5);
		/* 82262774h case    3:*/		return 0x82262778;
		  /* 82262778h */ case    4:  		/* li R20, 0 */
		/* 82262778h case    4:*/		cpu::op::li<0>(regs,&regs.R20,0x0);
		/* 82262778h case    4:*/		return 0x8226277C;
	}
	return 0x8226277C;
} // Block from 82262768h-8226277Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8226277Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226277C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226277C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226277C);
		  /* 8226277Ch */ case    0:  		/* lwz R9, <#[R30]> */
		/* 8226277Ch case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 8226277Ch case    0:*/		return 0x82262780;
		  /* 82262780h */ case    1:  		/* lwz R11, <#[R31 + 92]> */
		/* 82262780h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 82262780h case    1:*/		return 0x82262784;
		  /* 82262784h */ case    2:  		/* rlwinm R10, R9, 19, 23, 28 */
		/* 82262784h case    2:*/		cpu::op::rlwinm<0,19,23,28>(regs,&regs.R10,regs.R9);
		/* 82262784h case    2:*/		return 0x82262788;
		  /* 82262788h */ case    3:  		/* lwz R17, <#[R1 + 128]> */
		/* 82262788h case    3:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R1 + 0x00000080) );
		/* 82262788h case    3:*/		return 0x8226278C;
		  /* 8226278Ch */ case    4:  		/* lwz R18, <#[R1 + 132]> */
		/* 8226278Ch case    4:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R1 + 0x00000084) );
		/* 8226278Ch case    4:*/		return 0x82262790;
		  /* 82262790h */ case    5:  		/* extsh R29, R9 */
		/* 82262790h case    5:*/		cpu::op::extsh<0>(regs,&regs.R29,regs.R9);
		/* 82262790h case    5:*/		return 0x82262794;
		  /* 82262794h */ case    6:  		/* add R11, R10, R11 */
		/* 82262794h case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82262794h case    6:*/		return 0x82262798;
		  /* 82262798h */ case    7:  		/* lwz R28, <#[R11 + 4]> */
		/* 82262798h case    7:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x00000004) );
		/* 82262798h case    7:*/		return 0x8226279C;
		  /* 8226279Ch */ case    8:  		/* cmpwi CR6, R28, 33 */
		/* 8226279Ch case    8:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000021);
		/* 8226279Ch case    8:*/		return 0x822627A0;
		  /* 822627A0h */ case    9:  		/* bc 12, CR6_EQ, 28 */
		/* 822627A0h case    9:*/		if ( regs.CR[6].eq ) { return 0x822627BC;  }
		/* 822627A0h case    9:*/		return 0x822627A4;
		  /* 822627A4h */ case   10:  		/* li R7, 1565 */
		/* 822627A4h case   10:*/		cpu::op::li<0>(regs,&regs.R7,0x61D);
		/* 822627A4h case   10:*/		return 0x822627A8;
		  /* 822627A8h */ case   11:  		/* lwz R5, <#[R1 + 468]> */
		/* 822627A8h case   11:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000001D4) );
		/* 822627A8h case   11:*/		return 0x822627AC;
		  /* 822627ACh */ case   12:  		/* li R3, 0 */
		/* 822627ACh case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822627ACh case   12:*/		return 0x822627B0;
		  /* 822627B0h */ case   13:  		/* mr R6, R17 */
		/* 822627B0h case   13:*/		regs.R6 = regs.R17;
		/* 822627B0h case   13:*/		return 0x822627B4;
		  /* 822627B4h */ case   14:  		/* mr R4, R18 */
		/* 822627B4h case   14:*/		regs.R4 = regs.R18;
		/* 822627B4h case   14:*/		return 0x822627B8;
		  /* 822627B8h */ case   15:  		/* bl -1092528 */
		/* 822627B8h case   15:*/		regs.LR = 0x822627BC; return 0x82157C08;
		/* 822627B8h case   15:*/		return 0x822627BC;
	}
	return 0x822627BC;
} // Block from 8226277Ch-822627BCh (16 instructions)

//////////////////////////////////////////////////////
// Block at 822627BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822627BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822627BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822627BC);
		  /* 822627BCh */ case    0:  		/* lwz R11, <#[R31 + 2124]> */
		/* 822627BCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000084C) );
		/* 822627BCh case    0:*/		return 0x822627C0;
		  /* 822627C0h */ case    1:  		/* cmpw CR6, R11, R29 */
		/* 822627C0h case    1:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R29);
		/* 822627C0h case    1:*/		return 0x822627C4;
		  /* 822627C4h */ case    2:  		/* bc 12, CR6_LT, 8 */
		/* 822627C4h case    2:*/		if ( regs.CR[6].lt ) { return 0x822627CC;  }
		/* 822627C4h case    2:*/		return 0x822627C8;
		  /* 822627C8h */ case    3:  		/* mr R11, R29 */
		/* 822627C8h case    3:*/		regs.R11 = regs.R29;
		/* 822627C8h case    3:*/		return 0x822627CC;
	}
	return 0x822627CC;
} // Block from 822627BCh-822627CCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 822627CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822627CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822627CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822627CC);
		  /* 822627CCh */ case    0:  		/* stw R11, <#[R31 + 2124]> */
		/* 822627CCh case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000084C) );
		/* 822627CCh case    0:*/		return 0x822627D0;
		  /* 822627D0h */ case    1:  		/* lwz R11, <#[R31 + 2128]> */
		/* 822627D0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000850) );
		/* 822627D0h case    1:*/		return 0x822627D4;
		  /* 822627D4h */ case    2:  		/* cmpw CR6, R11, R29 */
		/* 822627D4h case    2:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R29);
		/* 822627D4h case    2:*/		return 0x822627D8;
		  /* 822627D8h */ case    3:  		/* bc 12, CR6_GT, 8 */
		/* 822627D8h case    3:*/		if ( regs.CR[6].gt ) { return 0x822627E0;  }
		/* 822627D8h case    3:*/		return 0x822627DC;
		  /* 822627DCh */ case    4:  		/* addi R11, R29, 1 */
		/* 822627DCh case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0x1);
		/* 822627DCh case    4:*/		return 0x822627E0;
	}
	return 0x822627E0;
} // Block from 822627CCh-822627E0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822627E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822627E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822627E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822627E0);
		  /* 822627E0h */ case    0:  		/* li R10, 33 */
		/* 822627E0h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x21);
		/* 822627E0h case    0:*/		return 0x822627E4;
		  /* 822627E4h */ case    1:  		/* stw R11, <#[R31 + 2128]> */
		/* 822627E4h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000850) );
		/* 822627E4h case    1:*/		return 0x822627E8;
		  /* 822627E8h */ case    2:  		/* stw R10, <#[R31 + 2120]> */
		/* 822627E8h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000848) );
		/* 822627E8h case    2:*/		return 0x822627EC;
		  /* 822627ECh */ case    3:  		/* lwz R11, <#[R30]> */
		/* 822627ECh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 822627ECh case    3:*/		return 0x822627F0;
		  /* 822627F0h */ case    4:  		/* rlwinm. R11, R11, 10, 31, 31 */
		/* 822627F0h case    4:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R11,regs.R11);
		/* 822627F0h case    4:*/		return 0x822627F4;
		  /* 822627F4h */ case    5:  		/* bc 12, CR0_EQ, 28 */
		/* 822627F4h case    5:*/		if ( regs.CR[0].eq ) { return 0x82262810;  }
		/* 822627F4h case    5:*/		return 0x822627F8;
		  /* 822627F8h */ case    6:  		/* mr R6, R17 */
		/* 822627F8h case    6:*/		regs.R6 = regs.R17;
		/* 822627F8h case    6:*/		return 0x822627FC;
		  /* 822627FCh */ case    7:  		/* lwz R5, <#[R1 + 476]> */
		/* 822627FCh case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000001DC) );
		/* 822627FCh case    7:*/		return 0x82262800;
		  /* 82262800h */ case    8:  		/* mr R4, R18 */
		/* 82262800h case    8:*/		regs.R4 = regs.R18;
		/* 82262800h case    8:*/		return 0x82262804;
		  /* 82262804h */ case    9:  		/* li R7, 1573 */
		/* 82262804h case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x625);
		/* 82262804h case    9:*/		return 0x82262808;
		  /* 82262808h */ case   10:  		/* li R3, 0 */
		/* 82262808h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82262808h case   10:*/		return 0x8226280C;
		  /* 8226280Ch */ case   11:  		/* bl -1092612 */
		/* 8226280Ch case   11:*/		regs.LR = 0x82262810; return 0x82157C08;
		/* 8226280Ch case   11:*/		return 0x82262810;
	}
	return 0x82262810;
} // Block from 822627E0h-82262810h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82262810h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262810( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262810) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262810);
		  /* 82262810h */ case    0:  		/* lwz R11, <#[R19 + 20]> */
		/* 82262810h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82262810h case    0:*/		return 0x82262814;
		  /* 82262814h */ case    1:  		/* mr R5, R29 */
		/* 82262814h case    1:*/		regs.R5 = regs.R29;
		/* 82262814h case    1:*/		return 0x82262818;
		  /* 82262818h */ case    2:  		/* mr R4, R28 */
		/* 82262818h case    2:*/		regs.R4 = regs.R28;
		/* 82262818h case    2:*/		return 0x8226281C;
		  /* 8226281Ch */ case    3:  		/* addi R11, R11, 4 */
		/* 8226281Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8226281Ch case    3:*/		return 0x82262820;
		  /* 82262820h */ case    4:  		/* stw R11, <#[R19 + 20]> */
		/* 82262820h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82262820h case    4:*/		return 0x82262824;
		  /* 82262824h */ case    5:  		/* lwz R3, <#[R31 + 172]> */
		/* 82262824h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000AC) );
		/* 82262824h case    5:*/		return 0x82262828;
		  /* 82262828h */ case    6:  		/* bl -121120 */
		/* 82262828h case    6:*/		regs.LR = 0x8226282C; return 0x82244F08;
		/* 82262828h case    6:*/		return 0x8226282C;
		  /* 8226282Ch */ case    7:  		/* li R19, 0 */
		/* 8226282Ch case    7:*/		cpu::op::li<0>(regs,&regs.R19,0x0);
		/* 8226282Ch case    7:*/		return 0x82262830;
		  /* 82262830h */ case    8:  		/* or. R30, R3, R3 */
		/* 82262830h case    8:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 82262830h case    8:*/		return 0x82262834;
		  /* 82262834h */ case    9:  		/* mr R26, R19 */
		/* 82262834h case    9:*/		regs.R26 = regs.R19;
		/* 82262834h case    9:*/		return 0x82262838;
		  /* 82262838h */ case   10:  		/* bc 4, CR0_EQ, 28 */
		/* 82262838h case   10:*/		if ( !regs.CR[0].eq ) { return 0x82262854;  }
		/* 82262838h case   10:*/		return 0x8226283C;
		  /* 8226283Ch */ case   11:  		/* mr R5, R29 */
		/* 8226283Ch case   11:*/		regs.R5 = regs.R29;
		/* 8226283Ch case   11:*/		return 0x82262840;
		  /* 82262840h */ case   12:  		/* lwz R3, <#[R31 + 172]> */
		/* 82262840h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000AC) );
		/* 82262840h case   12:*/		return 0x82262844;
		  /* 82262844h */ case   13:  		/* mr R4, R28 */
		/* 82262844h case   13:*/		regs.R4 = regs.R28;
		/* 82262844h case   13:*/		return 0x82262848;
		  /* 82262848h */ case   14:  		/* li R26, 1 */
		/* 82262848h case   14:*/		cpu::op::li<0>(regs,&regs.R26,0x1);
		/* 82262848h case   14:*/		return 0x8226284C;
		  /* 8226284Ch */ case   15:  		/* bl -121124 */
		/* 8226284Ch case   15:*/		regs.LR = 0x82262850; return 0x82244F28;
		/* 8226284Ch case   15:*/		return 0x82262850;
		  /* 82262850h */ case   16:  		/* mr R30, R3 */
		/* 82262850h case   16:*/		regs.R30 = regs.R3;
		/* 82262850h case   16:*/		return 0x82262854;
	}
	return 0x82262854;
} // Block from 82262810h-82262854h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82262854h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262854( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262854) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262854);
		  /* 82262854h */ case    0:  		/* lwz R29, <#[R1 + 136]> */
		/* 82262854h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000088) );
		/* 82262854h case    0:*/		return 0x82262858;
		  /* 82262858h */ case    1:  		/* cmpwi CR6, R27, 0 */
		/* 82262858h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 82262858h case    1:*/		return 0x8226285C;
		  /* 8226285Ch */ case    2:  		/* lwz R11, <#[R29 - 1308]> */
		/* 8226285Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0xFFFFFAE4) );
		/* 8226285Ch case    2:*/		return 0x82262860;
		  /* 82262860h */ case    3:  		/* stw R11, <#[R1 + 156]> */
		/* 82262860h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000009C) );
		/* 82262860h case    3:*/		return 0x82262864;
		  /* 82262864h */ case    4:  		/* bc 12, CR6_EQ, 36 */
		/* 82262864h case    4:*/		if ( regs.CR[6].eq ) { return 0x82262888;  }
		/* 82262864h case    4:*/		return 0x82262868;
		  /* 82262868h */ case    5:  		/* mr R8, R24 */
		/* 82262868h case    5:*/		regs.R8 = regs.R24;
		/* 82262868h case    5:*/		return 0x8226286C;
		  /* 8226286Ch */ case    6:  		/* lwz R4, <#[R30 + 16]> */
		/* 8226286Ch case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000010) );
		/* 8226286Ch case    6:*/		return 0x82262870;
		  /* 82262870h */ case    7:  		/* mr R7, R22 */
		/* 82262870h case    7:*/		regs.R7 = regs.R22;
		/* 82262870h case    7:*/		return 0x82262874;
		  /* 82262874h */ case    8:  		/* mr R6, R27 */
		/* 82262874h case    8:*/		regs.R6 = regs.R27;
		/* 82262874h case    8:*/		return 0x82262878;
		  /* 82262878h */ case    9:  		/* li R5, 0 */
		/* 82262878h case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82262878h case    9:*/		return 0x8226287C;
		  /* 8226287Ch */ case   10:  		/* addi R3, R31, 184 */
		/* 8226287Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0xB8);
		/* 8226287Ch case   10:*/		return 0x82262880;
		  /* 82262880h */ case   11:  		/* bl -69656 */
		/* 82262880h case   11:*/		regs.LR = 0x82262884; return 0x82251868;
		/* 82262880h case   11:*/		return 0x82262884;
		  /* 82262884h */ case   12:  		/* stb R19, <#[R1 + 156]> */
		/* 82262884h case   12:*/		cpu::mem::store8( regs, regs.R19, (uint32)(regs.R1 + 0x0000009C) );
		/* 82262884h case   12:*/		return 0x82262888;
	}
	return 0x82262888;
} // Block from 82262854h-82262888h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82262888h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262888( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262888) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262888);
		  /* 82262888h */ case    0:  		/* cmpwi CR6, R25, 0 */
		/* 82262888h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 82262888h case    0:*/		return 0x8226288C;
		  /* 8226288Ch */ case    1:  		/* bc 12, CR6_EQ, 36 */
		/* 8226288Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x822628B0;  }
		/* 8226288Ch case    1:*/		return 0x82262890;
		  /* 82262890h */ case    2:  		/* mr R8, R24 */
		/* 82262890h case    2:*/		regs.R8 = regs.R24;
		/* 82262890h case    2:*/		return 0x82262894;
		  /* 82262894h */ case    3:  		/* lwz R4, <#[R30 + 16]> */
		/* 82262894h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000010) );
		/* 82262894h case    3:*/		return 0x82262898;
		  /* 82262898h */ case    4:  		/* mr R7, R22 */
		/* 82262898h case    4:*/		regs.R7 = regs.R22;
		/* 82262898h case    4:*/		return 0x8226289C;
		  /* 8226289Ch */ case    5:  		/* mr R6, R25 */
		/* 8226289Ch case    5:*/		regs.R6 = regs.R25;
		/* 8226289Ch case    5:*/		return 0x822628A0;
		  /* 822628A0h */ case    6:  		/* li R5, 1 */
		/* 822628A0h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 822628A0h case    6:*/		return 0x822628A4;
		  /* 822628A4h */ case    7:  		/* addi R3, R31, 184 */
		/* 822628A4h case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0xB8);
		/* 822628A4h case    7:*/		return 0x822628A8;
		  /* 822628A8h */ case    8:  		/* bl -69696 */
		/* 822628A8h case    8:*/		regs.LR = 0x822628AC; return 0x82251868;
		/* 822628A8h case    8:*/		return 0x822628AC;
		  /* 822628ACh */ case    9:  		/* stb R19, <#[R1 + 157]> */
		/* 822628ACh case    9:*/		cpu::mem::store8( regs, regs.R19, (uint32)(regs.R1 + 0x0000009D) );
		/* 822628ACh case    9:*/		return 0x822628B0;
	}
	return 0x822628B0;
} // Block from 82262888h-822628B0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 822628B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822628B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822628B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822628B0);
		  /* 822628B0h */ case    0:  		/* cmpwi CR6, R23, 0 */
		/* 822628B0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R23,0x00000000);
		/* 822628B0h case    0:*/		return 0x822628B4;
		  /* 822628B4h */ case    1:  		/* bc 12, CR6_EQ, 36 */
		/* 822628B4h case    1:*/		if ( regs.CR[6].eq ) { return 0x822628D8;  }
		/* 822628B4h case    1:*/		return 0x822628B8;
		  /* 822628B8h */ case    2:  		/* mr R8, R24 */
		/* 822628B8h case    2:*/		regs.R8 = regs.R24;
		/* 822628B8h case    2:*/		return 0x822628BC;
		  /* 822628BCh */ case    3:  		/* lwz R4, <#[R30 + 16]> */
		/* 822628BCh case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000010) );
		/* 822628BCh case    3:*/		return 0x822628C0;
		  /* 822628C0h */ case    4:  		/* mr R7, R22 */
		/* 822628C0h case    4:*/		regs.R7 = regs.R22;
		/* 822628C0h case    4:*/		return 0x822628C4;
		  /* 822628C4h */ case    5:  		/* mr R6, R23 */
		/* 822628C4h case    5:*/		regs.R6 = regs.R23;
		/* 822628C4h case    5:*/		return 0x822628C8;
		  /* 822628C8h */ case    6:  		/* li R5, 2 */
		/* 822628C8h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 822628C8h case    6:*/		return 0x822628CC;
		  /* 822628CCh */ case    7:  		/* addi R3, R31, 184 */
		/* 822628CCh case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0xB8);
		/* 822628CCh case    7:*/		return 0x822628D0;
		  /* 822628D0h */ case    8:  		/* bl -69736 */
		/* 822628D0h case    8:*/		regs.LR = 0x822628D4; return 0x82251868;
		/* 822628D0h case    8:*/		return 0x822628D4;
		  /* 822628D4h */ case    9:  		/* stb R19, <#[R1 + 158]> */
		/* 822628D4h case    9:*/		cpu::mem::store8( regs, regs.R19, (uint32)(regs.R1 + 0x0000009E) );
		/* 822628D4h case    9:*/		return 0x822628D8;
	}
	return 0x822628D8;
} // Block from 822628B0h-822628D8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 822628D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822628D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822628D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822628D8);
		  /* 822628D8h */ case    0:  		/* cmpwi CR6, R21, 0 */
		/* 822628D8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R21,0x00000000);
		/* 822628D8h case    0:*/		return 0x822628DC;
		  /* 822628DCh */ case    1:  		/* bc 12, CR6_EQ, 36 */
		/* 822628DCh case    1:*/		if ( regs.CR[6].eq ) { return 0x82262900;  }
		/* 822628DCh case    1:*/		return 0x822628E0;
		  /* 822628E0h */ case    2:  		/* mr R8, R24 */
		/* 822628E0h case    2:*/		regs.R8 = regs.R24;
		/* 822628E0h case    2:*/		return 0x822628E4;
		  /* 822628E4h */ case    3:  		/* lwz R4, <#[R30 + 16]> */
		/* 822628E4h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000010) );
		/* 822628E4h case    3:*/		return 0x822628E8;
		  /* 822628E8h */ case    4:  		/* mr R7, R22 */
		/* 822628E8h case    4:*/		regs.R7 = regs.R22;
		/* 822628E8h case    4:*/		return 0x822628EC;
		  /* 822628ECh */ case    5:  		/* mr R6, R21 */
		/* 822628ECh case    5:*/		regs.R6 = regs.R21;
		/* 822628ECh case    5:*/		return 0x822628F0;
		  /* 822628F0h */ case    6:  		/* li R5, 3 */
		/* 822628F0h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 822628F0h case    6:*/		return 0x822628F4;
		  /* 822628F4h */ case    7:  		/* addi R3, R31, 184 */
		/* 822628F4h case    7:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R31,0xB8);
		/* 822628F4h case    7:*/		return 0x822628F8;
		  /* 822628F8h */ case    8:  		/* bl -69776 */
		/* 822628F8h case    8:*/		regs.LR = 0x822628FC; return 0x82251868;
		/* 822628F8h case    8:*/		return 0x822628FC;
		  /* 822628FCh */ case    9:  		/* stb R19, <#[R1 + 159]> */
		/* 822628FCh case    9:*/		cpu::mem::store8( regs, regs.R19, (uint32)(regs.R1 + 0x0000009F) );
		/* 822628FCh case    9:*/		return 0x82262900;
	}
	return 0x82262900;
} // Block from 822628D8h-82262900h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82262900h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262900( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262900) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262900);
		  /* 82262900h */ case    0:  		/* lwz R11, <#[R1 + 204]> */
		/* 82262900h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000CC) );
		/* 82262900h case    0:*/		return 0x82262904;
		  /* 82262904h */ case    1:  		/* cmpwi CR6, R11, 23 */
		/* 82262904h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000017);
		/* 82262904h case    1:*/		return 0x82262908;
		  /* 82262908h */ case    2:  		/* bc 4, CR6_EQ, 20 */
		/* 82262908h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8226291C;  }
		/* 82262908h case    2:*/		return 0x8226290C;
		  /* 8226290Ch */ case    3:  		/* cmpwi CR6, R20, 0 */
		/* 8226290Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R20,0x00000000);
		/* 8226290Ch case    3:*/		return 0x82262910;
		  /* 82262910h */ case    4:  		/* bc 4, CR6_EQ, 2452 */
		/* 82262910h case    4:*/		if ( !regs.CR[6].eq ) { return 0x822632A4;  }
		/* 82262910h case    4:*/		return 0x82262914;
		  /* 82262914h */ case    5:  		/* li R10, 1 */
		/* 82262914h case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82262914h case    5:*/		return 0x82262918;
		  /* 82262918h */ case    6:  		/* stw R10, <#[R30 + 48]> */
		/* 82262918h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000030) );
		/* 82262918h case    6:*/		return 0x8226291C;
	}
	return 0x8226291C;
} // Block from 82262900h-8226291Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8226291Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226291C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226291C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226291C);
		  /* 8226291Ch */ case    0:  		/* cmpwi CR6, R11, 27 */
		/* 8226291Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000001B);
		/* 8226291Ch case    0:*/		return 0x82262920;
		  /* 82262920h */ case    1:  		/* bc 4, CR6_EQ, 2436 */
		/* 82262920h case    1:*/		if ( !regs.CR[6].eq ) { return 0x822632A4;  }
		/* 82262920h case    1:*/		return 0x82262924;
		  /* 82262924h */ case    2:  		/* lwz R28, <#[R1 + 156]> */
		/* 82262924h case    2:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x0000009C) );
		/* 82262924h case    2:*/		return 0x82262928;
		  /* 82262928h */ case    3:  		/* rlwinm. R11, R26, 0, 24, 31 */
		/* 82262928h case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R26);
		/* 82262928h case    3:*/		return 0x8226292C;
		  /* 8226292Ch */ case    4:  		/* lwz R11, <#[R30]> */
		/* 8226292Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 8226292Ch case    4:*/		return 0x82262930;
		  /* 82262930h */ case    5:  		/* mr R5, R31 */
		/* 82262930h case    5:*/		regs.R5 = regs.R31;
		/* 82262930h case    5:*/		return 0x82262934;
		  /* 82262934h */ case    6:  		/* mr R3, R30 */
		/* 82262934h case    6:*/		regs.R3 = regs.R30;
		/* 82262934h case    6:*/		return 0x82262938;
		  /* 82262938h */ case    7:  		/* mr R4, R28 */
		/* 82262938h case    7:*/		regs.R4 = regs.R28;
		/* 82262938h case    7:*/		return 0x8226293C;
		  /* 8226293Ch */ case    8:  		/* bc 12, CR0_EQ, 24 */
		/* 8226293Ch case    8:*/		if ( regs.CR[0].eq ) { return 0x82262954;  }
		/* 8226293Ch case    8:*/		return 0x82262940;
		  /* 82262940h */ case    9:  		/* lwz R11, <#[R11 + 28]> */
		/* 82262940h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 82262940h case    9:*/		return 0x82262944;
		  /* 82262944h */ case   10:  		/* lwz R6, <#[R31 + 12]> */
		/* 82262944h case   10:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x0000000C) );
		/* 82262944h case   10:*/		return 0x82262948;
		  /* 82262948h */ case   11:  		/* mtspr CTR, R11 */
		/* 82262948h case   11:*/		regs.CTR = regs.R11;
		/* 82262948h case   11:*/		return 0x8226294C;
		  /* 8226294Ch */ case   12:  		/* bcctrl 20, CR0_LT */
		/* 8226294Ch case   12:*/		if ( 1 ) { regs.LR = 0x82262950; return (uint32)regs.CTR; }
		/* 8226294Ch case   12:*/		return 0x82262950;
		  /* 82262950h */ case   13:  		/* b 16 */
		/* 82262950h case   13:*/		return 0x82262960;
		/* 82262950h case   13:*/		return 0x82262954;
	}
	return 0x82262954;
} // Block from 8226291Ch-82262954h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82262954h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262954( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262954) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262954);
		  /* 82262954h */ case    0:  		/* lwz R11, <#[R11 + 32]> */
		/* 82262954h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000020) );
		/* 82262954h case    0:*/		return 0x82262958;
		  /* 82262958h */ case    1:  		/* mtspr CTR, R11 */
		/* 82262958h case    1:*/		regs.CTR = regs.R11;
		/* 82262958h case    1:*/		return 0x8226295C;
		  /* 8226295Ch */ case    2:  		/* bcctrl 20, CR0_LT */
		/* 8226295Ch case    2:*/		if ( 1 ) { regs.LR = 0x82262960; return (uint32)regs.CTR; }
		/* 8226295Ch case    2:*/		return 0x82262960;
	}
	return 0x82262960;
} // Block from 82262954h-82262960h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82262960h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262960( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262960) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262960);
		  /* 82262960h */ case    0:  		/* cmpwi CR6, R22, 5 */
		/* 82262960h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R22,0x00000005);
		/* 82262960h case    0:*/		return 0x82262964;
		  /* 82262964h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 82262964h case    1:*/		if ( regs.CR[6].eq ) { return 0x82262970;  }
		/* 82262964h case    1:*/		return 0x82262968;
		  /* 82262968h */ case    2:  		/* cmpwi CR6, R22, 6 */
		/* 82262968h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R22,0x00000006);
		/* 82262968h case    2:*/		return 0x8226296C;
		  /* 8226296Ch */ case    3:  		/* bc 4, CR6_EQ, 2360 */
		/* 8226296Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x822632A4;  }
		/* 8226296Ch case    3:*/		return 0x82262970;
	}
	return 0x82262970;
} // Block from 82262960h-82262970h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82262970h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262970( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262970) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262970);
		  /* 82262970h */ case    0:  		/* lwz R11, <#[R29 - 1312]> */
		/* 82262970h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0xFFFFFAE0) );
		/* 82262970h case    0:*/		return 0x82262974;
		  /* 82262974h */ case    1:  		/* cmplw CR6, R28, R11 */
		/* 82262974h case    1:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 82262974h case    1:*/		return 0x82262978;
		  /* 82262978h */ case    2:  		/* bc 12, CR6_EQ, 28 */
		/* 82262978h case    2:*/		if ( regs.CR[6].eq ) { return 0x82262994;  }
		/* 82262978h case    2:*/		return 0x8226297C;
		  /* 8226297Ch */ case    3:  		/* mr R6, R17 */
		/* 8226297Ch case    3:*/		regs.R6 = regs.R17;
		/* 8226297Ch case    3:*/		return 0x82262980;
		  /* 82262980h */ case    4:  		/* lwz R5, <#[R1 + 484]> */
		/* 82262980h case    4:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000001E4) );
		/* 82262980h case    4:*/		return 0x82262984;
		  /* 82262984h */ case    5:  		/* mr R4, R18 */
		/* 82262984h case    5:*/		regs.R4 = regs.R18;
		/* 82262984h case    5:*/		return 0x82262988;
		  /* 82262988h */ case    6:  		/* li R7, 1628 */
		/* 82262988h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x65C);
		/* 82262988h case    6:*/		return 0x8226298C;
		  /* 8226298Ch */ case    7:  		/* li R3, 0 */
		/* 8226298Ch case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8226298Ch case    7:*/		return 0x82262990;
		  /* 82262990h */ case    8:  		/* bl -1093000 */
		/* 82262990h case    8:*/		regs.LR = 0x82262994; return 0x82157C08;
		/* 82262990h case    8:*/		return 0x82262994;
	}
	return 0x82262994;
} // Block from 82262970h-82262994h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82262994h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262994( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262994) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262994);
		  /* 82262994h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 82262994h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82262994h case    0:*/		return 0x82262998;
		  /* 82262998h */ case    1:  		/* mr R5, R31 */
		/* 82262998h case    1:*/		regs.R5 = regs.R31;
		/* 82262998h case    1:*/		return 0x8226299C;
		  /* 8226299Ch */ case    2:  		/* mr R4, R28 */
		/* 8226299Ch case    2:*/		regs.R4 = regs.R28;
		/* 8226299Ch case    2:*/		return 0x822629A0;
		  /* 822629A0h */ case    3:  		/* mr R3, R30 */
		/* 822629A0h case    3:*/		regs.R3 = regs.R30;
		/* 822629A0h case    3:*/		return 0x822629A4;
		  /* 822629A4h */ case    4:  		/* lwz R11, <#[R11 + 32]> */
		/* 822629A4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000020) );
		/* 822629A4h case    4:*/		return 0x822629A8;
		  /* 822629A8h */ case    5:  		/* mtspr CTR, R11 */
		/* 822629A8h case    5:*/		regs.CTR = regs.R11;
		/* 822629A8h case    5:*/		return 0x822629AC;
		  /* 822629ACh */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 822629ACh case    6:*/		if ( 1 ) { regs.LR = 0x822629B0; return (uint32)regs.CTR; }
		/* 822629ACh case    6:*/		return 0x822629B0;
		  /* 822629B0h */ case    7:  		/* li R5, 0 */
		/* 822629B0h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 822629B0h case    7:*/		return 0x822629B4;
		  /* 822629B4h */ case    8:  		/* mr R4, R22 */
		/* 822629B4h case    8:*/		regs.R4 = regs.R22;
		/* 822629B4h case    8:*/		return 0x822629B8;
		  /* 822629B8h */ case    9:  		/* mr R28, R3 */
		/* 822629B8h case    9:*/		regs.R28 = regs.R3;
		/* 822629B8h case    9:*/		return 0x822629BC;
		  /* 822629BCh */ case   10:  		/* lwz R3, <#[R31 + 172]> */
		/* 822629BCh case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000AC) );
		/* 822629BCh case   10:*/		return 0x822629C0;
		  /* 822629C0h */ case   11:  		/* bl -121496 */
		/* 822629C0h case   11:*/		regs.LR = 0x822629C4; return 0x82244F28;
		/* 822629C0h case   11:*/		return 0x822629C4;
		  /* 822629C4h */ case   12:  		/* lwz R11, <#[R31 + 12]> */
		/* 822629C4h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 822629C4h case   12:*/		return 0x822629C8;
		  /* 822629C8h */ case   13:  		/* mr R27, R3 */
		/* 822629C8h case   13:*/		regs.R27 = regs.R3;
		/* 822629C8h case   13:*/		return 0x822629CC;
		  /* 822629CCh */ case   14:  		/* li R4, 964 */
		/* 822629CCh case   14:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 822629CCh case   14:*/		return 0x822629D0;
		  /* 822629D0h */ case   15:  		/* lwz R29, <#[R11 + 1452]> */
		/* 822629D0h case   15:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x000005AC) );
		/* 822629D0h case   15:*/		return 0x822629D4;
		  /* 822629D4h */ case   16:  		/* mr R3, R29 */
		/* 822629D4h case   16:*/		regs.R3 = regs.R29;
		/* 822629D4h case   16:*/		return 0x822629D8;
		  /* 822629D8h */ case   17:  		/* bl -288032 */
		/* 822629D8h case   17:*/		regs.LR = 0x822629DC; return 0x8221C4B8;
		/* 822629D8h case   17:*/		return 0x822629DC;
		  /* 822629DCh */ case   18:  		/* mr R11, R3 */
		/* 822629DCh case   18:*/		regs.R11 = regs.R3;
		/* 822629DCh case   18:*/		return 0x822629E0;
		  /* 822629E0h */ case   19:  		/* addic. R3, R3, 4 */
		/* 822629E0h case   19:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 822629E0h case   19:*/		return 0x822629E4;
		  /* 822629E4h */ case   20:  		/* stw R29, <#[R11]> */
		/* 822629E4h case   20:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000000) );
		/* 822629E4h case   20:*/		return 0x822629E8;
		  /* 822629E8h */ case   21:  		/* bc 12, CR0_EQ, 20 */
		/* 822629E8h case   21:*/		if ( regs.CR[0].eq ) { return 0x822629FC;  }
		/* 822629E8h case   21:*/		return 0x822629EC;
		  /* 822629ECh */ case   22:  		/* lwz R4, <#[R31 + 12]> */
		/* 822629ECh case   22:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 822629ECh case   22:*/		return 0x822629F0;
		  /* 822629F0h */ case   23:  		/* bl -47224 */
		/* 822629F0h case   23:*/		regs.LR = 0x822629F4; return 0x82257178;
		/* 822629F0h case   23:*/		return 0x822629F4;
		  /* 822629F4h */ case   24:  		/* mr R29, R3 */
		/* 822629F4h case   24:*/		regs.R29 = regs.R3;
		/* 822629F4h case   24:*/		return 0x822629F8;
		  /* 822629F8h */ case   25:  		/* b 8 */
		/* 822629F8h case   25:*/		return 0x82262A00;
		/* 822629F8h case   25:*/		return 0x822629FC;
	}
	return 0x822629FC;
} // Block from 82262994h-822629FCh (26 instructions)

//////////////////////////////////////////////////////
// Block at 822629FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822629FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822629FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822629FC);
		  /* 822629FCh */ case    0:  		/* mr R29, R19 */
		/* 822629FCh case    0:*/		regs.R29 = regs.R19;
		/* 822629FCh case    0:*/		return 0x82262A00;
	}
	return 0x82262A00;
} // Block from 822629FCh-82262A00h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82262A00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262A00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262A00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262A00);
		  /* 82262A00h */ case    0:  		/* mr R5, R27 */
		/* 82262A00h case    0:*/		regs.R5 = regs.R27;
		/* 82262A00h case    0:*/		return 0x82262A04;
		  /* 82262A04h */ case    1:  		/* li R4, 0 */
		/* 82262A04h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82262A04h case    1:*/		return 0x82262A08;
		  /* 82262A08h */ case    2:  		/* mr R3, R29 */
		/* 82262A08h case    2:*/		regs.R3 = regs.R29;
		/* 82262A08h case    2:*/		return 0x82262A0C;
		  /* 82262A0Ch */ case    3:  		/* bl -50804 */
		/* 82262A0Ch case    3:*/		regs.LR = 0x82262A10; return 0x82256398;
		/* 82262A0Ch case    3:*/		return 0x82262A10;
		  /* 82262A10h */ case    4:  		/* mr R5, R28 */
		/* 82262A10h case    4:*/		regs.R5 = regs.R28;
		/* 82262A10h case    4:*/		return 0x82262A14;
		  /* 82262A14h */ case    5:  		/* li R4, 1 */
		/* 82262A14h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82262A14h case    5:*/		return 0x82262A18;
		  /* 82262A18h */ case    6:  		/* mr R3, R29 */
		/* 82262A18h case    6:*/		regs.R3 = regs.R29;
		/* 82262A18h case    6:*/		return 0x82262A1C;
		  /* 82262A1Ch */ case    7:  		/* bl -50820 */
		/* 82262A1Ch case    7:*/		regs.LR = 0x82262A20; return 0x82256398;
		/* 82262A1Ch case    7:*/		return 0x82262A20;
		  /* 82262A20h */ case    8:  		/* mr R5, R29 */
		/* 82262A20h case    8:*/		regs.R5 = regs.R29;
		/* 82262A20h case    8:*/		return 0x82262A24;
		  /* 82262A24h */ case    9:  		/* li R4, 1 */
		/* 82262A24h case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82262A24h case    9:*/		return 0x82262A28;
		  /* 82262A28h */ case   10:  		/* mr R3, R28 */
		/* 82262A28h case   10:*/		regs.R3 = regs.R28;
		/* 82262A28h case   10:*/		return 0x82262A2C;
		  /* 82262A2Ch */ case   11:  		/* bl -58740 */
		/* 82262A2Ch case   11:*/		regs.LR = 0x82262A30; return 0x822544B8;
		/* 82262A2Ch case   11:*/		return 0x82262A30;
		  /* 82262A30h */ case   12:  		/* mr R4, R29 */
		/* 82262A30h case   12:*/		regs.R4 = regs.R29;
		/* 82262A30h case   12:*/		return 0x82262A34;
		  /* 82262A34h */ case   13:  		/* lwz R3, <#[R31 + 168]> */
		/* 82262A34h case   13:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000A8) );
		/* 82262A34h case   13:*/		return 0x82262A38;
		  /* 82262A38h */ case   14:  		/* bl -39688 */
		/* 82262A38h case   14:*/		regs.LR = 0x82262A3C; return 0x82258F30;
		/* 82262A38h case   14:*/		return 0x82262A3C;
		  /* 82262A3Ch */ case   15:  		/* cmpwi CR6, R22, 5 */
		/* 82262A3Ch case   15:*/		cpu::op::cmpwi<6>(regs,regs.R22,0x00000005);
		/* 82262A3Ch case   15:*/		return 0x82262A40;
		  /* 82262A40h */ case   16:  		/* bc 4, CR6_EQ, 12 */
		/* 82262A40h case   16:*/		if ( !regs.CR[6].eq ) { return 0x82262A4C;  }
		/* 82262A40h case   16:*/		return 0x82262A44;
		  /* 82262A44h */ case   17:  		/* stw R29, <#[R31 + 116]> */
		/* 82262A44h case   17:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000074) );
		/* 82262A44h case   17:*/		return 0x82262A48;
		  /* 82262A48h */ case   18:  		/* b 24 */
		/* 82262A48h case   18:*/		return 0x82262A60;
		/* 82262A48h case   18:*/		return 0x82262A4C;
	}
	return 0x82262A4C;
} // Block from 82262A00h-82262A4Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 82262A4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262A4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262A4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262A4C);
		  /* 82262A4Ch */ case    0:  		/* cmpwi CR6, R22, 6 */
		/* 82262A4Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R22,0x00000006);
		/* 82262A4Ch case    0:*/		return 0x82262A50;
		  /* 82262A50h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 82262A50h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82262A60;  }
		/* 82262A50h case    1:*/		return 0x82262A54;
		  /* 82262A54h */ case    2:  		/* li R11, 1 */
		/* 82262A54h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82262A54h case    2:*/		return 0x82262A58;
		  /* 82262A58h */ case    3:  		/* stw R29, <#[R31 + 120]> */
		/* 82262A58h case    3:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000078) );
		/* 82262A58h case    3:*/		return 0x82262A5C;
		  /* 82262A5Ch */ case    4:  		/* stb R11, <#[R31 + 126]> */
		/* 82262A5Ch case    4:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x0000007E) );
		/* 82262A5Ch case    4:*/		return 0x82262A60;
	}
	return 0x82262A60;
} // Block from 82262A4Ch-82262A60h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82262A60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262A60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262A60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262A60);
		  /* 82262A60h */ case    0:  		/* lwz R3, <#[R30 + 56]> */
		/* 82262A60h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000038) );
		/* 82262A60h case    0:*/		return 0x82262A64;
		  /* 82262A64h */ case    1:  		/* lwz R11, <#[R3]> */
		/* 82262A64h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82262A64h case    1:*/		return 0x82262A68;
		  /* 82262A68h */ case    2:  		/* lwz R11, <#[R11 + 96]> */
		/* 82262A68h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000060) );
		/* 82262A68h case    2:*/		return 0x82262A6C;
		  /* 82262A6Ch */ case    3:  		/* mtspr CTR, R11 */
		/* 82262A6Ch case    3:*/		regs.CTR = regs.R11;
		/* 82262A6Ch case    3:*/		return 0x82262A70;
		  /* 82262A70h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 82262A70h case    4:*/		if ( 1 ) { regs.LR = 0x82262A74; return (uint32)regs.CTR; }
		/* 82262A70h case    4:*/		return 0x82262A74;
		  /* 82262A74h */ case    5:  		/* b 2096 */
		/* 82262A74h case    5:*/		return 0x822632A4;
		/* 82262A74h case    5:*/		return 0x82262A78;
		  /* 82262A78h */ case    6:  		/* lbz R11, <#[R15]> */
		/* 82262A78h case    6:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000000) );
		/* 82262A78h case    6:*/		return 0x82262A7C;
		  /* 82262A7Ch */ case    7:  		/* rlwinm R30, R11, 0, 29, 31 */
		/* 82262A7Ch case    7:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R30,regs.R11);
		/* 82262A7Ch case    7:*/		return 0x82262A80;
		  /* 82262A80h */ case    8:  		/* cmpwi CR6, R30, 6 */
		/* 82262A80h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000006);
		/* 82262A80h case    8:*/		return 0x82262A84;
		  /* 82262A84h */ case    9:  		/* bc 12, CR6_LT, 28 */
		/* 82262A84h case    9:*/		if ( regs.CR[6].lt ) { return 0x82262AA0;  }
		/* 82262A84h case    9:*/		return 0x82262A88;
		  /* 82262A88h */ case   10:  		/* li R7, 1657 */
		/* 82262A88h case   10:*/		cpu::op::li<0>(regs,&regs.R7,0x679);
		/* 82262A88h case   10:*/		return 0x82262A8C;
		  /* 82262A8Ch */ case   11:  		/* lwz R6, <#[R1 + 128]> */
		/* 82262A8Ch case   11:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 82262A8Ch case   11:*/		return 0x82262A90;
		  /* 82262A90h */ case   12:  		/* li R3, 0 */
		/* 82262A90h case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82262A90h case   12:*/		return 0x82262A94;
		  /* 82262A94h */ case   13:  		/* lwz R5, <#[R1 + 492]> */
		/* 82262A94h case   13:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000001EC) );
		/* 82262A94h case   13:*/		return 0x82262A98;
		  /* 82262A98h */ case   14:  		/* lwz R4, <#[R1 + 132]> */
		/* 82262A98h case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 82262A98h case   14:*/		return 0x82262A9C;
		  /* 82262A9Ch */ case   15:  		/* bl -1093268 */
		/* 82262A9Ch case   15:*/		regs.LR = 0x82262AA0; return 0x82157C08;
		/* 82262A9Ch case   15:*/		return 0x82262AA0;
	}
	return 0x82262AA0;
} // Block from 82262A60h-82262AA0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82262AA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262AA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262AA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262AA0);
		  /* 82262AA0h */ case    0:  		/* lwz R10, <#[R31 + 12]> */
		/* 82262AA0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 82262AA0h case    0:*/		return 0x82262AA4;
		  /* 82262AA4h */ case    1:  		/* lbz R11, <#[R15 + 1]> */
		/* 82262AA4h case    1:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000001) );
		/* 82262AA4h case    1:*/		return 0x82262AA8;
		  /* 82262AA8h */ case    2:  		/* lwz R9, <#[R10 + 1360]> */
		/* 82262AA8h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000550) );
		/* 82262AA8h case    2:*/		return 0x82262AAC;
		  /* 82262AACh */ case    3:  		/* lwz R9, <#[R9 + 24]> */
		/* 82262AACh case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000018) );
		/* 82262AACh case    3:*/		return 0x82262AB0;
		  /* 82262AB0h */ case    4:  		/* cmpw CR6, R11, R9 */
		/* 82262AB0h case    4:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R9);
		/* 82262AB0h case    4:*/		return 0x82262AB4;
		  /* 82262AB4h */ case    5:  		/* bc 12, CR6_GT, 2336 */
		/* 82262AB4h case    5:*/		if ( regs.CR[6].gt ) { return 0x822633D4;  }
		/* 82262AB4h case    5:*/		return 0x82262AB8;
		  /* 82262AB8h */ case    6:  		/* rlwinm R10, R11, 27, 5, 31 */
		/* 82262AB8h case    6:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R11);
		/* 82262AB8h case    6:*/		return 0x82262ABC;
		  /* 82262ABCh */ case    7:  		/* rlwinm R9, R11, 0, 27, 31 */
		/* 82262ABCh case    7:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R11);
		/* 82262ABCh case    7:*/		return 0x82262AC0;
		  /* 82262AC0h */ case    8:  		/* addi R10, R10, 2 */
		/* 82262AC0h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 82262AC0h case    8:*/		return 0x82262AC4;
		  /* 82262AC4h */ case    9:  		/* li R8, 1 */
		/* 82262AC4h case    9:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82262AC4h case    9:*/		return 0x82262AC8;
		  /* 82262AC8h */ case   10:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82262AC8h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82262AC8h case   10:*/		return 0x82262ACC;
		  /* 82262ACCh */ case   11:  		/* slw R9, R8, R9 */
		/* 82262ACCh case   11:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 82262ACCh case   11:*/		return 0x82262AD0;
		  /* 82262AD0h */ case   12:  		/* lwzx R8, <#[R10 + R29]> */
		/* 82262AD0h case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R29 + 0x00000000) );
		/* 82262AD0h case   12:*/		return 0x82262AD4;
		  /* 82262AD4h */ case   13:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 82262AD4h case   13:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 82262AD4h case   13:*/		return 0x82262AD8;
		  /* 82262AD8h */ case   14:  		/* cmpwi CR6, R30, 0 */
		/* 82262AD8h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 82262AD8h case   14:*/		return 0x82262ADC;
		  /* 82262ADCh */ case   15:  		/* or R9, R9, R8 */
		/* 82262ADCh case   15:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 82262ADCh case   15:*/		return 0x82262AE0;
		  /* 82262AE0h */ case   16:  		/* stwx R9, <#[R10 + R29]> */
		/* 82262AE0h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R29 + 0x00000000) );
		/* 82262AE0h case   16:*/		return 0x82262AE4;
		  /* 82262AE4h */ case   17:  		/* lwz R10, <#[R15]> */
		/* 82262AE4h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R15 + 0x00000000) );
		/* 82262AE4h case   17:*/		return 0x82262AE8;
		  /* 82262AE8h */ case   18:  		/* lwz R9, <#[R31 + 88]> */
		/* 82262AE8h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000058) );
		/* 82262AE8h case   18:*/		return 0x82262AEC;
		  /* 82262AECh */ case   19:  		/* rlwinm R10, R10, 5, 30, 31 */
		/* 82262AECh case   19:*/		cpu::op::rlwinm<0,5,30,31>(regs,&regs.R10,regs.R10);
		/* 82262AECh case   19:*/		return 0x82262AF0;
		  /* 82262AF0h */ case   20:  		/* stwx R10, <#[R9 + R11]> */
		/* 82262AF0h case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82262AF0h case   20:*/		return 0x82262AF4;
		  /* 82262AF4h */ case   21:  		/* bc 12, CR6_EQ, 16 */
		/* 82262AF4h case   21:*/		if ( regs.CR[6].eq ) { return 0x82262B04;  }
		/* 82262AF4h case   21:*/		return 0x82262AF8;
		  /* 82262AF8h */ case   22:  		/* lwz R10, <#[R31 + 88]> */
		/* 82262AF8h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000058) );
		/* 82262AF8h case   22:*/		return 0x82262AFC;
		  /* 82262AFCh */ case   23:  		/* add R11, R10, R11 */
		/* 82262AFCh case   23:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82262AFCh case   23:*/		return 0x82262B00;
		  /* 82262B00h */ case   24:  		/* stw R30, <#[R11 + 4]> */
		/* 82262B00h case   24:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000004) );
		/* 82262B00h case   24:*/		return 0x82262B04;
	}
	return 0x82262B04;
} // Block from 82262AA0h-82262B04h (25 instructions)

//////////////////////////////////////////////////////
// Block at 82262B04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262B04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262B04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262B04);
		  /* 82262B04h */ case    0:  		/* lwz R11, <#[R19 + 20]> */
		/* 82262B04h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82262B04h case    0:*/		return 0x82262B08;
		  /* 82262B08h */ case    1:  		/* addi R11, R11, 4 */
		/* 82262B08h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82262B08h case    1:*/		return 0x82262B0C;
		  /* 82262B0Ch */ case    2:  		/* stw R11, <#[R19 + 20]> */
		/* 82262B0Ch case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82262B0Ch case    2:*/		return 0x82262B10;
		  /* 82262B10h */ case    3:  		/* b 1940 */
		/* 82262B10h case    3:*/		return 0x822632A4;
		/* 82262B10h case    3:*/		return 0x82262B14;
		  /* 82262B14h */ case    4:  		/* addi R3, R1, 688 */
		/* 82262B14h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x2B0);
		/* 82262B14h case    4:*/		return 0x82262B18;
		  /* 82262B18h */ case    5:  		/* bl -62192 */
		/* 82262B18h case    5:*/		regs.LR = 0x82262B1C; return 0x82253828;
		/* 82262B18h case    5:*/		return 0x82262B1C;
		  /* 82262B1Ch */ case    6:  		/* lwz R11, <#[R19 + 20]> */
		/* 82262B1Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82262B1Ch case    6:*/		return 0x82262B20;
		  /* 82262B20h */ case    7:  		/* lhz R9, <#[R15]> */
		/* 82262B20h case    7:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R15 + 0x00000000) );
		/* 82262B20h case    7:*/		return 0x82262B24;
		  /* 82262B24h */ case    8:  		/* li R30, 0 */
		/* 82262B24h case    8:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82262B24h case    8:*/		return 0x82262B28;
		  /* 82262B28h */ case    9:  		/* addi R10, R11, 4 */
		/* 82262B28h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 82262B28h case    9:*/		return 0x82262B2C;
		  /* 82262B2Ch */ case   10:  		/* lwz R26, <#[R1 + 136]> */
		/* 82262B2Ch case   10:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x00000088) );
		/* 82262B2Ch case   10:*/		return 0x82262B30;
		  /* 82262B30h */ case   11:  		/* rlwinm R28, R9, 0, 26, 31 */
		/* 82262B30h case   11:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R28,regs.R9);
		/* 82262B30h case   11:*/		return 0x82262B34;
		  /* 82262B34h */ case   12:  		/* stw R10, <#[R19 + 20]> */
		/* 82262B34h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R19 + 0x00000014) );
		/* 82262B34h case   12:*/		return 0x82262B38;
		  /* 82262B38h */ case   13:  		/* lwz R11, <#[R26 - 1316]> */
		/* 82262B38h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0xFFFFFADC) );
		/* 82262B38h case   13:*/		return 0x82262B3C;
		  /* 82262B3Ch */ case   14:  		/* stw R11, <#[R1 + 148]> */
		/* 82262B3Ch case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000094) );
		/* 82262B3Ch case   14:*/		return 0x82262B40;
		  /* 82262B40h */ case   15:  		/* lwz R11, <#[R15]> */
		/* 82262B40h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000000) );
		/* 82262B40h case   15:*/		return 0x82262B44;
		  /* 82262B44h */ case   16:  		/* rlwinm. R11, R11, 1, 31, 31 */
		/* 82262B44h case   16:*/		cpu::op::rlwinm<1,1,31,31>(regs,&regs.R11,regs.R11);
		/* 82262B44h case   16:*/		return 0x82262B48;
		  /* 82262B48h */ case   17:  		/* bc 12, CR0_EQ, 100 */
		/* 82262B48h case   17:*/		if ( regs.CR[0].eq ) { return 0x82262BAC;  }
		/* 82262B48h case   17:*/		return 0x82262B4C;
		  /* 82262B4Ch */ case   18:  		/* lwz R11, <#[R26 - 1308]> */
		/* 82262B4Ch case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0xFFFFFAE4) );
		/* 82262B4Ch case   18:*/		return 0x82262B50;
		  /* 82262B50h */ case   19:  		/* lwz R9, <#[R10]> */
		/* 82262B50h case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82262B50h case   19:*/		return 0x82262B54;
		  /* 82262B54h */ case   20:  		/* rlwinm. R8, R9, 0, 30, 31 */
		/* 82262B54h case   20:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R8,regs.R9);
		/* 82262B54h case   20:*/		return 0x82262B58;
		  /* 82262B58h */ case   21:  		/* stw R11, <#[R1 + 148]> */
		/* 82262B58h case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000094) );
		/* 82262B58h case   21:*/		return 0x82262B5C;
		  /* 82262B5Ch */ case   22:  		/* bc 12, CR0_EQ, 12 */
		/* 82262B5Ch case   22:*/		if ( regs.CR[0].eq ) { return 0x82262B68;  }
		/* 82262B5Ch case   22:*/		return 0x82262B60;
		  /* 82262B60h */ case   23:  		/* li R30, 1 */
		/* 82262B60h case   23:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 82262B60h case   23:*/		return 0x82262B64;
		  /* 82262B64h */ case   24:  		/* stb R27, <#[R1 + 148]> */
		/* 82262B64h case   24:*/		cpu::mem::store8( regs, regs.R27, (uint32)(regs.R1 + 0x00000094) );
		/* 82262B64h case   24:*/		return 0x82262B68;
	}
	return 0x82262B68;
} // Block from 82262B04h-82262B68h (25 instructions)

//////////////////////////////////////////////////////
// Block at 82262B68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262B68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262B68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262B68);
		  /* 82262B68h */ case    0:  		/* rlwinm. R11, R9, 0, 28, 29 */
		/* 82262B68h case    0:*/		cpu::op::rlwinm<1,0,28,29>(regs,&regs.R11,regs.R9);
		/* 82262B68h case    0:*/		return 0x82262B6C;
		  /* 82262B6Ch */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 82262B6Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82262B7C;  }
		/* 82262B6Ch case    1:*/		return 0x82262B70;
		  /* 82262B70h */ case    2:  		/* addi R11, R30, 4 */
		/* 82262B70h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x4);
		/* 82262B70h case    2:*/		return 0x82262B74;
		  /* 82262B74h */ case    3:  		/* addi R30, R30, 1 */
		/* 82262B74h case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82262B74h case    3:*/		return 0x82262B78;
		  /* 82262B78h */ case    4:  		/* stb R11, <#[R1 + 149]> */
		/* 82262B78h case    4:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000095) );
		/* 82262B78h case    4:*/		return 0x82262B7C;
	}
	return 0x82262B7C;
} // Block from 82262B68h-82262B7Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82262B7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262B7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262B7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262B7C);
		  /* 82262B7Ch */ case    0:  		/* rlwinm. R11, R9, 0, 26, 27 */
		/* 82262B7Ch case    0:*/		cpu::op::rlwinm<1,0,26,27>(regs,&regs.R11,regs.R9);
		/* 82262B7Ch case    0:*/		return 0x82262B80;
		  /* 82262B80h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 82262B80h case    1:*/		if ( regs.CR[0].eq ) { return 0x82262B90;  }
		/* 82262B80h case    1:*/		return 0x82262B84;
		  /* 82262B84h */ case    2:  		/* addi R11, R30, 4 */
		/* 82262B84h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x4);
		/* 82262B84h case    2:*/		return 0x82262B88;
		  /* 82262B88h */ case    3:  		/* addi R30, R30, 1 */
		/* 82262B88h case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82262B88h case    3:*/		return 0x82262B8C;
		  /* 82262B8Ch */ case    4:  		/* stb R11, <#[R1 + 150]> */
		/* 82262B8Ch case    4:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000096) );
		/* 82262B8Ch case    4:*/		return 0x82262B90;
	}
	return 0x82262B90;
} // Block from 82262B7Ch-82262B90h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82262B90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262B90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262B90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262B90);
		  /* 82262B90h */ case    0:  		/* rlwinm. R11, R9, 0, 24, 25 */
		/* 82262B90h case    0:*/		cpu::op::rlwinm<1,0,24,25>(regs,&regs.R11,regs.R9);
		/* 82262B90h case    0:*/		return 0x82262B94;
		  /* 82262B94h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 82262B94h case    1:*/		if ( regs.CR[0].eq ) { return 0x82262BA4;  }
		/* 82262B94h case    1:*/		return 0x82262B98;
		  /* 82262B98h */ case    2:  		/* addi R11, R30, 4 */
		/* 82262B98h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x4);
		/* 82262B98h case    2:*/		return 0x82262B9C;
		  /* 82262B9Ch */ case    3:  		/* addi R30, R30, 1 */
		/* 82262B9Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82262B9Ch case    3:*/		return 0x82262BA0;
		  /* 82262BA0h */ case    4:  		/* stb R11, <#[R1 + 151]> */
		/* 82262BA0h case    4:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000097) );
		/* 82262BA0h case    4:*/		return 0x82262BA4;
	}
	return 0x82262BA4;
} // Block from 82262B90h-82262BA4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82262BA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262BA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262BA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262BA4);
		  /* 82262BA4h */ case    0:  		/* addi R11, R10, 4 */
		/* 82262BA4h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x4);
		/* 82262BA4h case    0:*/		return 0x82262BA8;
		  /* 82262BA8h */ case    1:  		/* stw R11, <#[R19 + 20]> */
		/* 82262BA8h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82262BA8h case    1:*/		return 0x82262BAC;
	}
	return 0x82262BAC;
} // Block from 82262BA4h-82262BACh (2 instructions)

//////////////////////////////////////////////////////
// Block at 82262BACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262BAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262BAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262BAC);
		  /* 82262BACh */ case    0:  		/* lwz R29, <#[R19 + 20]> */
		/* 82262BACh case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R19 + 0x00000014) );
		/* 82262BACh case    0:*/		return 0x82262BB0;
		  /* 82262BB0h */ case    1:  		/* lwz R11, <#[R29]> */
		/* 82262BB0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82262BB0h case    1:*/		return 0x82262BB4;
		  /* 82262BB4h */ case    2:  		/* rlwinm. R11, R11, 10, 31, 31 */
		/* 82262BB4h case    2:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R11,regs.R11);
		/* 82262BB4h case    2:*/		return 0x82262BB8;
		  /* 82262BB8h */ case    3:  		/* bc 12, CR0_EQ, 232 */
		/* 82262BB8h case    3:*/		if ( regs.CR[0].eq ) { return 0x82262CA0;  }
		/* 82262BB8h case    3:*/		return 0x82262BBC;
		  /* 82262BBCh */ case    4:  		/* lwz R11, <#[R15]> */
		/* 82262BBCh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000000) );
		/* 82262BBCh case    4:*/		return 0x82262BC0;
		  /* 82262BC0h */ case    5:  		/* rlwinm. R11, R11, 1, 31, 31 */
		/* 82262BC0h case    5:*/		cpu::op::rlwinm<1,1,31,31>(regs,&regs.R11,regs.R11);
		/* 82262BC0h case    5:*/		return 0x82262BC4;
		  /* 82262BC4h */ case    6:  		/* bc 12, CR0_EQ, 28 */
		/* 82262BC4h case    6:*/		if ( regs.CR[0].eq ) { return 0x82262BE0;  }
		/* 82262BC4h case    6:*/		return 0x82262BC8;
		  /* 82262BC8h */ case    7:  		/* li R7, 1713 */
		/* 82262BC8h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x6B1);
		/* 82262BC8h case    7:*/		return 0x82262BCC;
		  /* 82262BCCh */ case    8:  		/* lwz R6, <#[R1 + 128]> */
		/* 82262BCCh case    8:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 82262BCCh case    8:*/		return 0x82262BD0;
		  /* 82262BD0h */ case    9:  		/* li R3, 0 */
		/* 82262BD0h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82262BD0h case    9:*/		return 0x82262BD4;
		  /* 82262BD4h */ case   10:  		/* lwz R5, <#[R1 + 500]> */
		/* 82262BD4h case   10:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000001F4) );
		/* 82262BD4h case   10:*/		return 0x82262BD8;
		  /* 82262BD8h */ case   11:  		/* lwz R4, <#[R1 + 132]> */
		/* 82262BD8h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 82262BD8h case   11:*/		return 0x82262BDC;
		  /* 82262BDCh */ case   12:  		/* bl -1093588 */
		/* 82262BDCh case   12:*/		regs.LR = 0x82262BE0; return 0x82157C08;
		/* 82262BDCh case   12:*/		return 0x82262BE0;
	}
	return 0x82262BE0;
} // Block from 82262BACh-82262BE0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82262BE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262BE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262BE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262BE0);
		  /* 82262BE0h */ case    0:  		/* lwz R11, <#[R26 - 1308]> */
		/* 82262BE0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0xFFFFFAE4) );
		/* 82262BE0h case    0:*/		return 0x82262BE4;
		  /* 82262BE4h */ case    1:  		/* li R4, 0 */
		/* 82262BE4h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82262BE4h case    1:*/		return 0x82262BE8;
		  /* 82262BE8h */ case    2:  		/* mr R3, R29 */
		/* 82262BE8h case    2:*/		regs.R3 = regs.R29;
		/* 82262BE8h case    2:*/		return 0x82262BEC;
		  /* 82262BECh */ case    3:  		/* stw R11, <#[R1 + 148]> */
		/* 82262BECh case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000094) );
		/* 82262BECh case    3:*/		return 0x82262BF0;
		  /* 82262BF0h */ case    4:  		/* bl 17080 */
		/* 82262BF0h case    4:*/		regs.LR = 0x82262BF4; return 0x82266EA8;
		/* 82262BF0h case    4:*/		return 0x82262BF4;
		  /* 82262BF4h */ case    5:  		/* addi R11, R26, 7964 */
		/* 82262BF4h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x1F1C);
		/* 82262BF4h case    5:*/		return 0x82262BF8;
		  /* 82262BF8h */ case    6:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 82262BF8h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 82262BF8h case    6:*/		return 0x82262BFC;
		  /* 82262BFCh */ case    7:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82262BFCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82262BFCh case    7:*/		return 0x82262C00;
		  /* 82262C00h */ case    8:  		/* cmpwi CR6, R11, 0 */
		/* 82262C00h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82262C00h case    8:*/		return 0x82262C04;
		  /* 82262C04h */ case    9:  		/* bc 4, CR6_EQ, 16 */
		/* 82262C04h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82262C14;  }
		/* 82262C04h case    9:*/		return 0x82262C08;
		  /* 82262C08h */ case   10:  		/* addi R11, R30, 4 */
		/* 82262C08h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x4);
		/* 82262C08h case   10:*/		return 0x82262C0C;
		  /* 82262C0Ch */ case   11:  		/* addi R30, R30, 1 */
		/* 82262C0Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82262C0Ch case   11:*/		return 0x82262C10;
		  /* 82262C10h */ case   12:  		/* stb R11, <#[R1 + 148]> */
		/* 82262C10h case   12:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000094) );
		/* 82262C10h case   12:*/		return 0x82262C14;
	}
	return 0x82262C14;
} // Block from 82262BE0h-82262C14h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82262C14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262C14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262C14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262C14);
		  /* 82262C14h */ case    0:  		/* li R4, 1 */
		/* 82262C14h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82262C14h case    0:*/		return 0x82262C18;
		  /* 82262C18h */ case    1:  		/* mr R3, R29 */
		/* 82262C18h case    1:*/		regs.R3 = regs.R29;
		/* 82262C18h case    1:*/		return 0x82262C1C;
		  /* 82262C1Ch */ case    2:  		/* bl 17036 */
		/* 82262C1Ch case    2:*/		regs.LR = 0x82262C20; return 0x82266EA8;
		/* 82262C1Ch case    2:*/		return 0x82262C20;
		  /* 82262C20h */ case    3:  		/* addi R11, R26, 7964 */
		/* 82262C20h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x1F1C);
		/* 82262C20h case    3:*/		return 0x82262C24;
		  /* 82262C24h */ case    4:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 82262C24h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 82262C24h case    4:*/		return 0x82262C28;
		  /* 82262C28h */ case    5:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82262C28h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82262C28h case    5:*/		return 0x82262C2C;
		  /* 82262C2Ch */ case    6:  		/* cmpwi CR6, R11, 0 */
		/* 82262C2Ch case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82262C2Ch case    6:*/		return 0x82262C30;
		  /* 82262C30h */ case    7:  		/* bc 4, CR6_EQ, 16 */
		/* 82262C30h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82262C40;  }
		/* 82262C30h case    7:*/		return 0x82262C34;
		  /* 82262C34h */ case    8:  		/* addi R11, R30, 4 */
		/* 82262C34h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x4);
		/* 82262C34h case    8:*/		return 0x82262C38;
		  /* 82262C38h */ case    9:  		/* addi R30, R30, 1 */
		/* 82262C38h case    9:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82262C38h case    9:*/		return 0x82262C3C;
		  /* 82262C3Ch */ case   10:  		/* stb R11, <#[R1 + 149]> */
		/* 82262C3Ch case   10:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000095) );
		/* 82262C3Ch case   10:*/		return 0x82262C40;
	}
	return 0x82262C40;
} // Block from 82262C14h-82262C40h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82262C40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262C40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262C40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262C40);
		  /* 82262C40h */ case    0:  		/* li R4, 2 */
		/* 82262C40h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 82262C40h case    0:*/		return 0x82262C44;
		  /* 82262C44h */ case    1:  		/* mr R3, R29 */
		/* 82262C44h case    1:*/		regs.R3 = regs.R29;
		/* 82262C44h case    1:*/		return 0x82262C48;
		  /* 82262C48h */ case    2:  		/* bl 16992 */
		/* 82262C48h case    2:*/		regs.LR = 0x82262C4C; return 0x82266EA8;
		/* 82262C48h case    2:*/		return 0x82262C4C;
		  /* 82262C4Ch */ case    3:  		/* addi R11, R26, 7964 */
		/* 82262C4Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x1F1C);
		/* 82262C4Ch case    3:*/		return 0x82262C50;
		  /* 82262C50h */ case    4:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 82262C50h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 82262C50h case    4:*/		return 0x82262C54;
		  /* 82262C54h */ case    5:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82262C54h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82262C54h case    5:*/		return 0x82262C58;
		  /* 82262C58h */ case    6:  		/* cmpwi CR6, R11, 0 */
		/* 82262C58h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82262C58h case    6:*/		return 0x82262C5C;
		  /* 82262C5Ch */ case    7:  		/* bc 4, CR6_EQ, 16 */
		/* 82262C5Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x82262C6C;  }
		/* 82262C5Ch case    7:*/		return 0x82262C60;
		  /* 82262C60h */ case    8:  		/* addi R11, R30, 4 */
		/* 82262C60h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x4);
		/* 82262C60h case    8:*/		return 0x82262C64;
		  /* 82262C64h */ case    9:  		/* addi R30, R30, 1 */
		/* 82262C64h case    9:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82262C64h case    9:*/		return 0x82262C68;
		  /* 82262C68h */ case   10:  		/* stb R11, <#[R1 + 150]> */
		/* 82262C68h case   10:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000096) );
		/* 82262C68h case   10:*/		return 0x82262C6C;
	}
	return 0x82262C6C;
} // Block from 82262C40h-82262C6Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 82262C6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262C6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262C6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262C6C);
		  /* 82262C6Ch */ case    0:  		/* li R4, 3 */
		/* 82262C6Ch case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x3);
		/* 82262C6Ch case    0:*/		return 0x82262C70;
		  /* 82262C70h */ case    1:  		/* mr R3, R29 */
		/* 82262C70h case    1:*/		regs.R3 = regs.R29;
		/* 82262C70h case    1:*/		return 0x82262C74;
		  /* 82262C74h */ case    2:  		/* bl 16948 */
		/* 82262C74h case    2:*/		regs.LR = 0x82262C78; return 0x82266EA8;
		/* 82262C74h case    2:*/		return 0x82262C78;
		  /* 82262C78h */ case    3:  		/* addi R11, R26, 7964 */
		/* 82262C78h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x1F1C);
		/* 82262C78h case    3:*/		return 0x82262C7C;
		  /* 82262C7Ch */ case    4:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 82262C7Ch case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 82262C7Ch case    4:*/		return 0x82262C80;
		  /* 82262C80h */ case    5:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82262C80h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82262C80h case    5:*/		return 0x82262C84;
		  /* 82262C84h */ case    6:  		/* cmpwi CR6, R11, 0 */
		/* 82262C84h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82262C84h case    6:*/		return 0x82262C88;
		  /* 82262C88h */ case    7:  		/* bc 4, CR6_EQ, 12 */
		/* 82262C88h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82262C94;  }
		/* 82262C88h case    7:*/		return 0x82262C8C;
		  /* 82262C8Ch */ case    8:  		/* addi R11, R30, 4 */
		/* 82262C8Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x4);
		/* 82262C8Ch case    8:*/		return 0x82262C90;
		  /* 82262C90h */ case    9:  		/* stb R11, <#[R1 + 151]> */
		/* 82262C90h case    9:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000097) );
		/* 82262C90h case    9:*/		return 0x82262C94;
	}
	return 0x82262C94;
} // Block from 82262C6Ch-82262C94h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82262C94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262C94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262C94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262C94);
		  /* 82262C94h */ case    0:  		/* lwz R11, <#[R19 + 20]> */
		/* 82262C94h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82262C94h case    0:*/		return 0x82262C98;
		  /* 82262C98h */ case    1:  		/* addi R11, R11, 4 */
		/* 82262C98h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82262C98h case    1:*/		return 0x82262C9C;
		  /* 82262C9Ch */ case    2:  		/* stw R11, <#[R19 + 20]> */
		/* 82262C9Ch case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82262C9Ch case    2:*/		return 0x82262CA0;
	}
	return 0x82262CA0;
} // Block from 82262C94h-82262CA0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82262CA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262CA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262CA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262CA0);
		  /* 82262CA0h */ case    0:  		/* li R9, 0 */
		/* 82262CA0h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82262CA0h case    0:*/		return 0x82262CA4;
		  /* 82262CA4h */ case    1:  		/* lwz R7, <#[R31 + 164]> */
		/* 82262CA4h case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x000000A4) );
		/* 82262CA4h case    1:*/		return 0x82262CA8;
		  /* 82262CA8h */ case    2:  		/* li R8, 1 */
		/* 82262CA8h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 82262CA8h case    2:*/		return 0x82262CAC;
		  /* 82262CACh */ case    3:  		/* lwz R6, <#[R1 + 148]> */
		/* 82262CACh case    3:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000094) );
		/* 82262CACh case    3:*/		return 0x82262CB0;
		  /* 82262CB0h */ case    4:  		/* mr R5, R29 */
		/* 82262CB0h case    4:*/		regs.R5 = regs.R29;
		/* 82262CB0h case    4:*/		return 0x82262CB4;
		  /* 82262CB4h */ case    5:  		/* mr R4, R28 */
		/* 82262CB4h case    5:*/		regs.R4 = regs.R28;
		/* 82262CB4h case    5:*/		return 0x82262CB8;
		  /* 82262CB8h */ case    6:  		/* mr R3, R31 */
		/* 82262CB8h case    6:*/		regs.R3 = regs.R31;
		/* 82262CB8h case    6:*/		return 0x82262CBC;
		  /* 82262CBCh */ case    7:  		/* bl -26204 */
		/* 82262CBCh case    7:*/		regs.LR = 0x82262CC0; return 0x8225C660;
		/* 82262CBCh case    7:*/		return 0x82262CC0;
		  /* 82262CC0h */ case    8:  		/* lwz R11, <#[R19 + 20]> */
		/* 82262CC0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82262CC0h case    8:*/		return 0x82262CC4;
		  /* 82262CC4h */ case    9:  		/* addi R11, R11, 4 */
		/* 82262CC4h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82262CC4h case    9:*/		return 0x82262CC8;
		  /* 82262CC8h */ case   10:  		/* stw R11, <#[R19 + 20]> */
		/* 82262CC8h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82262CC8h case   10:*/		return 0x82262CCC;
		  /* 82262CCCh */ case   11:  		/* lwz R30, <#[R1 + 696]> */
		/* 82262CCCh case   11:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x000002B8) );
		/* 82262CCCh case   11:*/		return 0x82262CD0;
		  /* 82262CD0h */ case   12:  		/* lwz R29, <#[R30 + 8]> */
		/* 82262CD0h case   12:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R30 + 0x00000008) );
		/* 82262CD0h case   12:*/		return 0x82262CD4;
		  /* 82262CD4h */ case   13:  		/* b 84 */
		/* 82262CD4h case   13:*/		return 0x82262D28;
		/* 82262CD4h case   13:*/		return 0x82262CD8;
		  /* 82262CD8h */ case   14:  		/* mr R3, R30 */
		/* 82262CD8h case   14:*/		regs.R3 = regs.R30;
		/* 82262CD8h case   14:*/		return 0x82262CDC;
		  /* 82262CDCh */ case   15:  		/* bl -62676 */
		/* 82262CDCh case   15:*/		regs.LR = 0x82262CE0; return 0x82253808;
		/* 82262CDCh case   15:*/		return 0x82262CE0;
		  /* 82262CE0h */ case   16:  		/* mr R4, R30 */
		/* 82262CE0h case   16:*/		regs.R4 = regs.R30;
		/* 82262CE0h case   16:*/		return 0x82262CE4;
		  /* 82262CE4h */ case   17:  		/* mr R3, R31 */
		/* 82262CE4h case   17:*/		regs.R3 = regs.R31;
		/* 82262CE4h case   17:*/		return 0x82262CE8;
		  /* 82262CE8h */ case   18:  		/* bl -182080 */
		/* 82262CE8h case   18:*/		regs.LR = 0x82262CEC; return 0x822365A8;
		/* 82262CE8h case   18:*/		return 0x82262CEC;
		  /* 82262CECh */ case   19:  		/* mr R4, R30 */
		/* 82262CECh case   19:*/		regs.R4 = regs.R30;
		/* 82262CECh case   19:*/		return 0x82262CF0;
		  /* 82262CF0h */ case   20:  		/* mr R3, R14 */
		/* 82262CF0h case   20:*/		regs.R3 = regs.R14;
		/* 82262CF0h case   20:*/		return 0x82262CF4;
		  /* 82262CF4h */ case   21:  		/* bl -40388 */
		/* 82262CF4h case   21:*/		regs.LR = 0x82262CF8; return 0x82258F30;
		/* 82262CF4h case   21:*/		return 0x82262CF8;
		  /* 82262CF8h */ case   22:  		/* mr R3, R30 */
		/* 82262CF8h case   22:*/		regs.R3 = regs.R30;
		/* 82262CF8h case   22:*/		return 0x82262CFC;
		  /* 82262CFCh */ case   23:  		/* bl -52540 */
		/* 82262CFCh case   23:*/		regs.LR = 0x82262D00; return 0x82255FC0;
		/* 82262CFCh case   23:*/		return 0x82262D00;
		  /* 82262D00h */ case   24:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82262D00h case   24:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82262D00h case   24:*/		return 0x82262D04;
		  /* 82262D04h */ case   25:  		/* bc 4, CR0_EQ, 28 */
		/* 82262D04h case   25:*/		if ( !regs.CR[0].eq ) { return 0x82262D20;  }
		/* 82262D04h case   25:*/		return 0x82262D08;
		  /* 82262D08h */ case   26:  		/* li R7, 1746 */
		/* 82262D08h case   26:*/		cpu::op::li<0>(regs,&regs.R7,0x6D2);
		/* 82262D08h case   26:*/		return 0x82262D0C;
		  /* 82262D0Ch */ case   27:  		/* lwz R6, <#[R1 + 128]> */
		/* 82262D0Ch case   27:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 82262D0Ch case   27:*/		return 0x82262D10;
		  /* 82262D10h */ case   28:  		/* li R3, 0 */
		/* 82262D10h case   28:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82262D10h case   28:*/		return 0x82262D14;
		  /* 82262D14h */ case   29:  		/* lwz R5, <#[R1 + 252]> */
		/* 82262D14h case   29:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000000FC) );
		/* 82262D14h case   29:*/		return 0x82262D18;
		  /* 82262D18h */ case   30:  		/* lwz R4, <#[R1 + 132]> */
		/* 82262D18h case   30:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 82262D18h case   30:*/		return 0x82262D1C;
		  /* 82262D1Ch */ case   31:  		/* bl -1093908 */
		/* 82262D1Ch case   31:*/		regs.LR = 0x82262D20; return 0x82157C08;
		/* 82262D1Ch case   31:*/		return 0x82262D20;
	}
	return 0x82262D20;
} // Block from 82262CA0h-82262D20h (32 instructions)

//////////////////////////////////////////////////////
// Block at 82262D20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262D20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262D20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262D20);
		  /* 82262D20h */ case    0:  		/* mr R30, R29 */
		/* 82262D20h case    0:*/		regs.R30 = regs.R29;
		/* 82262D20h case    0:*/		return 0x82262D24;
		  /* 82262D24h */ case    1:  		/* lwz R29, <#[R29 + 8]> */
		/* 82262D24h case    1:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R29 + 0x00000008) );
		/* 82262D24h case    1:*/		return 0x82262D28;
	}
	return 0x82262D28;
} // Block from 82262D20h-82262D28h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82262D28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262D28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262D28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262D28);
		  /* 82262D28h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 82262D28h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82262D28h case    0:*/		return 0x82262D2C;
		  /* 82262D2Ch */ case    1:  		/* bc 4, CR6_EQ, -84 */
		/* 82262D2Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82262CD8;  }
		/* 82262D2Ch case    1:*/		return 0x82262D30;
		  /* 82262D30h */ case    2:  		/* stw R18, <#[R1 + 700]> */
		/* 82262D30h case    2:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R1 + 0x000002BC) );
		/* 82262D30h case    2:*/		return 0x82262D34;
		  /* 82262D34h */ case    3:  		/* stw R18, <#[R1 + 688]> */
		/* 82262D34h case    3:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R1 + 0x000002B0) );
		/* 82262D34h case    3:*/		return 0x82262D38;
		  /* 82262D38h */ case    4:  		/* b 1388 */
		/* 82262D38h case    4:*/		return 0x822632A4;
		/* 82262D38h case    4:*/		return 0x82262D3C;
		  /* 82262D3Ch */ case    5:  		/* lwz R11, <#[R19 + 20]> */
		/* 82262D3Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82262D3Ch case    5:*/		return 0x82262D40;
		  /* 82262D40h */ case    6:  		/* addi R11, R11, 4 */
		/* 82262D40h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82262D40h case    6:*/		return 0x82262D44;
		  /* 82262D44h */ case    7:  		/* stw R11, <#[R19 + 20]> */
		/* 82262D44h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82262D44h case    7:*/		return 0x82262D48;
		  /* 82262D48h */ case    8:  		/* lwz R9, <#[R11]> */
		/* 82262D48h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82262D48h case    8:*/		return 0x82262D4C;
		  /* 82262D4Ch */ case    9:  		/* lwz R11, <#[R31 + 92]> */
		/* 82262D4Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 82262D4Ch case    9:*/		return 0x82262D50;
		  /* 82262D50h */ case   10:  		/* rlwinm R10, R9, 19, 23, 28 */
		/* 82262D50h case   10:*/		cpu::op::rlwinm<0,19,23,28>(regs,&regs.R10,regs.R9);
		/* 82262D50h case   10:*/		return 0x82262D54;
		  /* 82262D54h */ case   11:  		/* lwz R3, <#[R31 + 172]> */
		/* 82262D54h case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000AC) );
		/* 82262D54h case   11:*/		return 0x82262D58;
		  /* 82262D58h */ case   12:  		/* extsh R5, R9 */
		/* 82262D58h case   12:*/		cpu::op::extsh<0>(regs,&regs.R5,regs.R9);
		/* 82262D58h case   12:*/		return 0x82262D5C;
		  /* 82262D5Ch */ case   13:  		/* add R11, R10, R11 */
		/* 82262D5Ch case   13:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82262D5Ch case   13:*/		return 0x82262D60;
		  /* 82262D60h */ case   14:  		/* lwz R4, <#[R11 + 4]> */
		/* 82262D60h case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000004) );
		/* 82262D60h case   14:*/		return 0x82262D64;
		  /* 82262D64h */ case   15:  		/* bl -120148 */
		/* 82262D64h case   15:*/		regs.LR = 0x82262D68; return 0x82245810;
		/* 82262D64h case   15:*/		return 0x82262D68;
		  /* 82262D68h */ case   16:  		/* lwz R11, <#[R19 + 20]> */
		/* 82262D68h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82262D68h case   16:*/		return 0x82262D6C;
		  /* 82262D6Ch */ case   17:  		/* addi R11, R11, 4 */
		/* 82262D6Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82262D6Ch case   17:*/		return 0x82262D70;
		  /* 82262D70h */ case   18:  		/* stw R11, <#[R19 + 20]> */
		/* 82262D70h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82262D70h case   18:*/		return 0x82262D74;
		  /* 82262D74h */ case   19:  		/* lwz R3, <#[R3 + 40]> */
		/* 82262D74h case   19:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000028) );
		/* 82262D74h case   19:*/		return 0x82262D78;
		  /* 82262D78h */ case   20:  		/* lwz R11, <#[R3 + 4]> */
		/* 82262D78h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82262D78h case   20:*/		return 0x82262D7C;
		  /* 82262D7Ch */ case   21:  		/* cmplwi CR6, R11, 0 */
		/* 82262D7Ch case   21:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82262D7Ch case   21:*/		return 0x82262D80;
		  /* 82262D80h */ case   22:  		/* bc 4, CR6_GT, 12 */
		/* 82262D80h case   22:*/		if ( !regs.CR[6].gt ) { return 0x82262D8C;  }
		/* 82262D80h case   22:*/		return 0x82262D84;
		  /* 82262D84h */ case   23:  		/* lwz R3, <#[R3 + 8]> */
		/* 82262D84h case   23:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000008) );
		/* 82262D84h case   23:*/		return 0x82262D88;
		  /* 82262D88h */ case   24:  		/* b 12 */
		/* 82262D88h case   24:*/		return 0x82262D94;
		/* 82262D88h case   24:*/		return 0x82262D8C;
	}
	return 0x82262D8C;
} // Block from 82262D28h-82262D8Ch (25 instructions)

//////////////////////////////////////////////////////
// Block at 82262D8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262D8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262D8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262D8C);
		  /* 82262D8Ch */ case    0:  		/* li R4, 0 */
		/* 82262D8Ch case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82262D8Ch case    0:*/		return 0x82262D90;
		  /* 82262D90h */ case    1:  		/* bl -62160 */
		/* 82262D90h case    1:*/		regs.LR = 0x82262D94; return 0x82253AC0;
		/* 82262D90h case    1:*/		return 0x82262D94;
	}
	return 0x82262D94;
} // Block from 82262D8Ch-82262D94h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82262D94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262D94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262D94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262D94);
		  /* 82262D94h */ case    0:  		/* lwz R30, <#[R3]> */
		/* 82262D94h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 82262D94h case    0:*/		return 0x82262D98;
		  /* 82262D98h */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 82262D98h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82262D98h case    1:*/		return 0x82262D9C;
		  /* 82262D9Ch */ case    2:  		/* bc 4, CR6_EQ, 28 */
		/* 82262D9Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x82262DB8;  }
		/* 82262D9Ch case    2:*/		return 0x82262DA0;
		  /* 82262DA0h */ case    3:  		/* li R7, 1765 */
		/* 82262DA0h case    3:*/		cpu::op::li<0>(regs,&regs.R7,0x6E5);
		/* 82262DA0h case    3:*/		return 0x82262DA4;
		  /* 82262DA4h */ case    4:  		/* lwz R6, <#[R1 + 128]> */
		/* 82262DA4h case    4:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 82262DA4h case    4:*/		return 0x82262DA8;
		  /* 82262DA8h */ case    5:  		/* li R3, 0 */
		/* 82262DA8h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82262DA8h case    5:*/		return 0x82262DAC;
		  /* 82262DACh */ case    6:  		/* lwz R5, <#[R1 + 508]> */
		/* 82262DACh case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000001FC) );
		/* 82262DACh case    6:*/		return 0x82262DB0;
		  /* 82262DB0h */ case    7:  		/* lwz R4, <#[R1 + 132]> */
		/* 82262DB0h case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 82262DB0h case    7:*/		return 0x82262DB4;
		  /* 82262DB4h */ case    8:  		/* bl -1094060 */
		/* 82262DB4h case    8:*/		regs.LR = 0x82262DB8; return 0x82157C08;
		/* 82262DB4h case    8:*/		return 0x82262DB8;
	}
	return 0x82262DB8;
} // Block from 82262D94h-82262DB8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82262DB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262DB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262DB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262DB8);
		  /* 82262DB8h */ case    0:  		/* mr R3, R26 */
		/* 82262DB8h case    0:*/		regs.R3 = regs.R26;
		/* 82262DB8h case    0:*/		return 0x82262DBC;
		  /* 82262DBCh */ case    1:  		/* bl -35236 */
		/* 82262DBCh case    1:*/		regs.LR = 0x82262DC0; return 0x8225A418;
		/* 82262DBCh case    1:*/		return 0x82262DC0;
		  /* 82262DC0h */ case    2:  		/* cmpwi CR0, R3, 0 */
		/* 82262DC0h case    2:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82262DC0h case    2:*/		return 0x82262DC4;
		  /* 82262DC4h */ case    3:  		/* bc 4, CR0_GT, 1248 */
		/* 82262DC4h case    3:*/		if ( !regs.CR[0].gt ) { return 0x822632A4;  }
		/* 82262DC4h case    3:*/		return 0x82262DC8;
		  /* 82262DC8h */ case    4:  		/* addi R10, R30, 924 */
		/* 82262DC8h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0x39C);
		/* 82262DC8h case    4:*/		return 0x82262DCC;
		  /* 82262DCCh */ case    5:  		/* mtspr CTR, R3 */
		/* 82262DCCh case    5:*/		regs.CTR = regs.R3;
		/* 82262DCCh case    5:*/		return 0x82262DD0;
		  /* 82262DD0h */ case    6:  		/* addi R11, R30, 888 */
		/* 82262DD0h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x378);
		/* 82262DD0h case    6:*/		return 0x82262DD4;
		  /* 82262DD4h */ case    7:  		/* lwz R9, <#[R19 + 20]> */
		/* 82262DD4h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R19 + 0x00000014) );
		/* 82262DD4h case    7:*/		return 0x82262DD8;
		  /* 82262DD8h */ case    8:  		/* li R8, 0 */
		/* 82262DD8h case    8:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82262DD8h case    8:*/		return 0x82262DDC;
		  /* 82262DDCh */ case    9:  		/* li R7, 1 */
		/* 82262DDCh case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 82262DDCh case    9:*/		return 0x82262DE0;
		  /* 82262DE0h */ case   10:  		/* lfs FR0, <#[R9]> */
		/* 82262DE0h case   10:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R9 + 0x00000000) );
		/* 82262DE0h case   10:*/		return 0x82262DE4;
		  /* 82262DE4h */ case   11:  		/* stfs FR0, <#[R11 + 12]> */
		/* 82262DE4h case   11:*/		cpu::mem::store32f( regs, regs.FR0, (uint32)(regs.R11 + 0x0000000C) );
		/* 82262DE4h case   11:*/		return 0x82262DE8;
		  /* 82262DE8h */ case   12:  		/* stwu R8, <#[R11 + 8]> */
		/* 82262DE8h case   12:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000008) );
		regs.R11 = (uint32)(regs.R11 + 0x00000008);
		/* 82262DE8h case   12:*/		return 0x82262DEC;
		  /* 82262DECh */ case   13:  		/* stwu R7, <#[R10 + 4]> */
		/* 82262DECh case   13:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 82262DECh case   13:*/		return 0x82262DF0;
		  /* 82262DF0h */ case   14:  		/* lwz R9, <#[R19 + 20]> */
		/* 82262DF0h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R19 + 0x00000014) );
		/* 82262DF0h case   14:*/		return 0x82262DF4;
		  /* 82262DF4h */ case   15:  		/* addi R9, R9, 4 */
		/* 82262DF4h case   15:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 82262DF4h case   15:*/		return 0x82262DF8;
		  /* 82262DF8h */ case   16:  		/* stw R9, <#[R19 + 20]> */
		/* 82262DF8h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R19 + 0x00000014) );
		/* 82262DF8h case   16:*/		return 0x82262DFC;
		  /* 82262DFCh */ case   17:  		/* bc 16, CR0_LT, -40 */
		/* 82262DFCh case   17:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82262DD4;  }
		/* 82262DFCh case   17:*/		return 0x82262E00;
		  /* 82262E00h */ case   18:  		/* b 1188 */
		/* 82262E00h case   18:*/		return 0x822632A4;
		/* 82262E00h case   18:*/		return 0x82262E04;
		  /* 82262E04h */ case   19:  		/* li R7, 1906 */
		/* 82262E04h case   19:*/		cpu::op::li<0>(regs,&regs.R7,0x772);
		/* 82262E04h case   19:*/		return 0x82262E08;
	}
	return 0x82262E08;
} // Block from 82262DB8h-82262E08h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82262E08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262E08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262E08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262E08);
		  /* 82262E08h */ case    0:  		/* lwz R6, <#[R1 + 128]> */
		/* 82262E08h case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 82262E08h case    0:*/		return 0x82262E0C;
		  /* 82262E0Ch */ case    1:  		/* mr R5, R28 */
		/* 82262E0Ch case    1:*/		regs.R5 = regs.R28;
		/* 82262E0Ch case    1:*/		return 0x82262E10;
		  /* 82262E10h */ case    2:  		/* lwz R4, <#[R1 + 132]> */
		/* 82262E10h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 82262E10h case    2:*/		return 0x82262E14;
	}
	return 0x82262E14;
} // Block from 82262E08h-82262E14h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82262E14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262E14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262E14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262E14);
		  /* 82262E14h */ case    0:  		/* li R3, 0 */
		/* 82262E14h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82262E14h case    0:*/		return 0x82262E18;
		  /* 82262E18h */ case    1:  		/* bl -1094160 */
		/* 82262E18h case    1:*/		regs.LR = 0x82262E1C; return 0x82157C08;
		/* 82262E18h case    1:*/		return 0x82262E1C;
		  /* 82262E1Ch */ case    2:  		/* b 1160 */
		/* 82262E1Ch case    2:*/		return 0x822632A4;
		/* 82262E1Ch case    2:*/		return 0x82262E20;
	}
	return 0x82262E20;
} // Block from 82262E14h-82262E20h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82262E20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262E20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262E20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262E20);
		  /* 82262E20h */ case    0:  		/* lwz R11, <#[R24 + 7484]> */
		/* 82262E20h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00001D3C) );
		/* 82262E20h case    0:*/		return 0x82262E24;
		  /* 82262E24h */ case    1:  		/* li R3, 143 */
		/* 82262E24h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x8F);
		/* 82262E24h case    1:*/		return 0x82262E28;
		  /* 82262E28h */ case    2:  		/* lwz R4, <#[R31 + 12]> */
		/* 82262E28h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 82262E28h case    2:*/		return 0x82262E2C;
		  /* 82262E2Ch */ case    3:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 82262E2Ch case    3:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 82262E2Ch case    3:*/		return 0x82262E30;
		  /* 82262E30h */ case    4:  		/* lwzx R11, <#[R11 + R30]> */
		/* 82262E30h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 82262E30h case    4:*/		return 0x82262E34;
		  /* 82262E34h */ case    5:  		/* mtspr CTR, R11 */
		/* 82262E34h case    5:*/		regs.CTR = regs.R11;
		/* 82262E34h case    5:*/		return 0x82262E38;
		  /* 82262E38h */ case    6:  		/* bcctrl 20, CR0_LT */
		/* 82262E38h case    6:*/		if ( 1 ) { regs.LR = 0x82262E3C; return (uint32)regs.CTR; }
		/* 82262E38h case    6:*/		return 0x82262E3C;
		  /* 82262E3Ch */ case    7:  		/* mr R30, R3 */
		/* 82262E3Ch case    7:*/		regs.R30 = regs.R3;
		/* 82262E3Ch case    7:*/		return 0x82262E40;
		  /* 82262E40h */ case    8:  		/* lwz R3, <#[R31 + 172]> */
		/* 82262E40h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000AC) );
		/* 82262E40h case    8:*/		return 0x82262E44;
		  /* 82262E44h */ case    9:  		/* li R5, 0 */
		/* 82262E44h case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82262E44h case    9:*/		return 0x82262E48;
		  /* 82262E48h */ case   10:  		/* stw R30, <#[R31 + 104]> */
		/* 82262E48h case   10:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000068) );
		/* 82262E48h case   10:*/		return 0x82262E4C;
		  /* 82262E4Ch */ case   11:  		/* li R4, 47 */
		/* 82262E4Ch case   11:*/		cpu::op::li<0>(regs,&regs.R4,0x2F);
		/* 82262E4Ch case   11:*/		return 0x82262E50;
		  /* 82262E50h */ case   12:  		/* bl -120384 */
		/* 82262E50h case   12:*/		regs.LR = 0x82262E54; return 0x82245810;
		/* 82262E50h case   12:*/		return 0x82262E54;
		  /* 82262E54h */ case   13:  		/* mr R23, R3 */
		/* 82262E54h case   13:*/		regs.R23 = regs.R3;
		/* 82262E54h case   13:*/		return 0x82262E58;
		  /* 82262E58h */ case   14:  		/* mr R5, R3 */
		/* 82262E58h case   14:*/		regs.R5 = regs.R3;
		/* 82262E58h case   14:*/		return 0x82262E5C;
		  /* 82262E5Ch */ case   15:  		/* li R4, 0 */
		/* 82262E5Ch case   15:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82262E5Ch case   15:*/		return 0x82262E60;
		  /* 82262E60h */ case   16:  		/* mr R3, R30 */
		/* 82262E60h case   16:*/		regs.R3 = regs.R30;
		/* 82262E60h case   16:*/		return 0x82262E64;
		  /* 82262E64h */ case   17:  		/* bl -51916 */
		/* 82262E64h case   17:*/		regs.LR = 0x82262E68; return 0x82256398;
		/* 82262E64h case   17:*/		return 0x82262E68;
		  /* 82262E68h */ case   18:  		/* lbz R21, <#[R1 + 201]> */
		/* 82262E68h case   18:*/		cpu::mem::load8z( regs, &regs.R21, (uint32)(regs.R1 + 0x000000C9) );
		/* 82262E68h case   18:*/		return 0x82262E6C;
		  /* 82262E6Ch */ case   19:  		/* li R10, 0 */
		/* 82262E6Ch case   19:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82262E6Ch case   19:*/		return 0x82262E70;
		  /* 82262E70h */ case   20:  		/* cmplwi CR0, R21, 0 */
		/* 82262E70h case   20:*/		cpu::op::cmplwi<0>(regs,regs.R21,0x00000000);
		/* 82262E70h case   20:*/		return 0x82262E74;
		  /* 82262E74h */ case   21:  		/* stw R10, <#[R30 + 168]> */
		/* 82262E74h case   21:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x000000A8) );
		/* 82262E74h case   21:*/		return 0x82262E78;
		  /* 82262E78h */ case   22:  		/* bc 12, CR0_EQ, 16 */
		/* 82262E78h case   22:*/		if ( regs.CR[0].eq ) { return 0x82262E88;  }
		/* 82262E78h case   22:*/		return 0x82262E7C;
		  /* 82262E7Ch */ case   23:  		/* mr R4, R23 */
		/* 82262E7Ch case   23:*/		regs.R4 = regs.R23;
		/* 82262E7Ch case   23:*/		return 0x82262E80;
		  /* 82262E80h */ case   24:  		/* mr R3, R30 */
		/* 82262E80h case   24:*/		regs.R3 = regs.R30;
		/* 82262E80h case   24:*/		return 0x82262E84;
		  /* 82262E84h */ case   25:  		/* bl -35796 */
		/* 82262E84h case   25:*/		regs.LR = 0x82262E88; return 0x8225A2B0;
		/* 82262E84h case   25:*/		return 0x82262E88;
	}
	return 0x82262E88;
} // Block from 82262E20h-82262E88h (26 instructions)

//////////////////////////////////////////////////////
// Block at 82262E88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262E88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262E88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262E88);
		  /* 82262E88h */ case    0:  		/* mr R4, R30 */
		/* 82262E88h case    0:*/		regs.R4 = regs.R30;
		/* 82262E88h case    0:*/		return 0x82262E8C;
		  /* 82262E8Ch */ case    1:  		/* mr R3, R31 */
		/* 82262E8Ch case    1:*/		regs.R3 = regs.R31;
		/* 82262E8Ch case    1:*/		return 0x82262E90;
		  /* 82262E90h */ case    2:  		/* bl -182504 */
		/* 82262E90h case    2:*/		regs.LR = 0x82262E94; return 0x822365A8;
		/* 82262E90h case    2:*/		return 0x82262E94;
		  /* 82262E94h */ case    3:  		/* mr R4, R30 */
		/* 82262E94h case    3:*/		regs.R4 = regs.R30;
		/* 82262E94h case    3:*/		return 0x82262E98;
		  /* 82262E98h */ case    4:  		/* mr R3, R14 */
		/* 82262E98h case    4:*/		regs.R3 = regs.R14;
		/* 82262E98h case    4:*/		return 0x82262E9C;
		  /* 82262E9Ch */ case    5:  		/* bl -40812 */
		/* 82262E9Ch case    5:*/		regs.LR = 0x82262EA0; return 0x82258F30;
		/* 82262E9Ch case    5:*/		return 0x82262EA0;
		  /* 82262EA0h */ case    6:  		/* mr R3, R30 */
		/* 82262EA0h case    6:*/		regs.R3 = regs.R30;
		/* 82262EA0h case    6:*/		return 0x82262EA4;
		  /* 82262EA4h */ case    7:  		/* bl -52964 */
		/* 82262EA4h case    7:*/		regs.LR = 0x82262EA8; return 0x82255FC0;
		/* 82262EA4h case    7:*/		return 0x82262EA8;
		  /* 82262EA8h */ case    8:  		/* lwz R17, <#[R1 + 128]> */
		/* 82262EA8h case    8:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R1 + 0x00000080) );
		/* 82262EA8h case    8:*/		return 0x82262EAC;
		  /* 82262EACh */ case    9:  		/* lwz R18, <#[R1 + 132]> */
		/* 82262EACh case    9:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R1 + 0x00000084) );
		/* 82262EACh case    9:*/		return 0x82262EB0;
		  /* 82262EB0h */ case   10:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82262EB0h case   10:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82262EB0h case   10:*/		return 0x82262EB4;
		  /* 82262EB4h */ case   11:  		/* bc 4, CR0_EQ, 28 */
		/* 82262EB4h case   11:*/		if ( !regs.CR[0].eq ) { return 0x82262ED0;  }
		/* 82262EB4h case   11:*/		return 0x82262EB8;
		  /* 82262EB8h */ case   12:  		/* li R7, 1794 */
		/* 82262EB8h case   12:*/		cpu::op::li<0>(regs,&regs.R7,0x702);
		/* 82262EB8h case   12:*/		return 0x82262EBC;
		  /* 82262EBCh */ case   13:  		/* lwz R5, <#[R1 + 516]> */
		/* 82262EBCh case   13:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000204) );
		/* 82262EBCh case   13:*/		return 0x82262EC0;
		  /* 82262EC0h */ case   14:  		/* li R3, 0 */
		/* 82262EC0h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82262EC0h case   14:*/		return 0x82262EC4;
		  /* 82262EC4h */ case   15:  		/* mr R6, R17 */
		/* 82262EC4h case   15:*/		regs.R6 = regs.R17;
		/* 82262EC4h case   15:*/		return 0x82262EC8;
		  /* 82262EC8h */ case   16:  		/* mr R4, R18 */
		/* 82262EC8h case   16:*/		regs.R4 = regs.R18;
		/* 82262EC8h case   16:*/		return 0x82262ECC;
		  /* 82262ECCh */ case   17:  		/* bl -1094340 */
		/* 82262ECCh case   17:*/		regs.LR = 0x82262ED0; return 0x82157C08;
		/* 82262ECCh case   17:*/		return 0x82262ED0;
	}
	return 0x82262ED0;
} // Block from 82262E88h-82262ED0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82262ED0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262ED0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262ED0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262ED0);
		  /* 82262ED0h */ case    0:  		/* lwz R11, <#[R19 + 20]> */
		/* 82262ED0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82262ED0h case    0:*/		return 0x82262ED4;
		  /* 82262ED4h */ case    1:  		/* addi R11, R11, 4 */
		/* 82262ED4h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82262ED4h case    1:*/		return 0x82262ED8;
		  /* 82262ED8h */ case    2:  		/* stw R11, <#[R19 + 20]> */
		/* 82262ED8h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82262ED8h case    2:*/		return 0x82262EDC;
		  /* 82262EDCh */ case    3:  		/* lwz R11, <#[R15]> */
		/* 82262EDCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000000) );
		/* 82262EDCh case    3:*/		return 0x82262EE0;
		  /* 82262EE0h */ case    4:  		/* rlwinm. R30, R11, 9, 26, 31 */
		/* 82262EE0h case    4:*/		cpu::op::rlwinm<1,9,26,31>(regs,&regs.R30,regs.R11);
		/* 82262EE0h case    4:*/		return 0x82262EE4;
		  /* 82262EE4h */ case    5:  		/* rlwinm R22, R11, 16, 26, 31 */
		/* 82262EE4h case    5:*/		cpu::op::rlwinm<0,16,26,31>(regs,&regs.R22,regs.R11);
		/* 82262EE4h case    5:*/		return 0x82262EE8;
		  /* 82262EE8h */ case    6:  		/* bc 12, CR0_EQ, 28 */
		/* 82262EE8h case    6:*/		if ( regs.CR[0].eq ) { return 0x82262F04;  }
		/* 82262EE8h case    6:*/		return 0x82262EEC;
		  /* 82262EECh */ case    7:  		/* mr R6, R17 */
		/* 82262EECh case    7:*/		regs.R6 = regs.R17;
		/* 82262EECh case    7:*/		return 0x82262EF0;
		  /* 82262EF0h */ case    8:  		/* lwz R5, <#[R1 + 524]> */
		/* 82262EF0h case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x0000020C) );
		/* 82262EF0h case    8:*/		return 0x82262EF4;
		  /* 82262EF4h */ case    9:  		/* mr R4, R18 */
		/* 82262EF4h case    9:*/		regs.R4 = regs.R18;
		/* 82262EF4h case    9:*/		return 0x82262EF8;
		  /* 82262EF8h */ case   10:  		/* li R7, 1802 */
		/* 82262EF8h case   10:*/		cpu::op::li<0>(regs,&regs.R7,0x70A);
		/* 82262EF8h case   10:*/		return 0x82262EFC;
		  /* 82262EFCh */ case   11:  		/* li R3, 0 */
		/* 82262EFCh case   11:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82262EFCh case   11:*/		return 0x82262F00;
		  /* 82262F00h */ case   12:  		/* bl -1094392 */
		/* 82262F00h case   12:*/		regs.LR = 0x82262F04; return 0x82157C08;
		/* 82262F00h case   12:*/		return 0x82262F04;
	}
	return 0x82262F04;
} // Block from 82262ED0h-82262F04h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82262F04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262F04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262F04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262F04);
		  /* 82262F04h */ case    0:  		/* lwz R29, <#[R19 + 20]> */
		/* 82262F04h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R19 + 0x00000014) );
		/* 82262F04h case    0:*/		return 0x82262F08;
		  /* 82262F08h */ case    1:  		/* subf R10, R30, R27 */
		/* 82262F08h case    1:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R30,regs.R27);
		/* 82262F08h case    1:*/		return 0x82262F0C;
		  /* 82262F0Ch */ case    2:  		/* xoris R11, R30, 32768 */
		/* 82262F0Ch case    2:*/		cpu::op::xoris<0>(regs,&regs.R11,regs.R30,0x8000);
		/* 82262F0Ch case    2:*/		return 0x82262F10;
		  /* 82262F10h */ case    3:  		/* addc R11, R10, R11 */
		/* 82262F10h case    3:*/		cpu::op::addc<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82262F10h case    3:*/		return 0x82262F14;
		  /* 82262F14h */ case    4:  		/* lwz R10, <#[R29]> */
		/* 82262F14h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 82262F14h case    4:*/		return 0x82262F18;
		  /* 82262F18h */ case    5:  		/* subfe R11, R11, R11 */
		/* 82262F18h case    5:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82262F18h case    5:*/		return 0x82262F1C;
		  /* 82262F1Ch */ case    6:  		/* rlwinm. R10, R10, 10, 31, 31 */
		/* 82262F1Ch case    6:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R10,regs.R10);
		/* 82262F1Ch case    6:*/		return 0x82262F20;
		  /* 82262F20h */ case    7:  		/* and R20, R11, R30 */
		/* 82262F20h case    7:*/		cpu::op::and<0>(regs,&regs.R20,regs.R11,regs.R30);
		/* 82262F20h case    7:*/		return 0x82262F24;
		  /* 82262F24h */ case    8:  		/* bc 12, CR0_EQ, 12 */
		/* 82262F24h case    8:*/		if ( regs.CR[0].eq ) { return 0x82262F30;  }
		/* 82262F24h case    8:*/		return 0x82262F28;
		  /* 82262F28h */ case    9:  		/* addi R11, R29, 4 */
		/* 82262F28h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0x4);
		/* 82262F28h case    9:*/		return 0x82262F2C;
		  /* 82262F2Ch */ case   10:  		/* stw R11, <#[R19 + 20]> */
		/* 82262F2Ch case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82262F2Ch case   10:*/		return 0x82262F30;
	}
	return 0x82262F30;
} // Block from 82262F04h-82262F30h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82262F30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262F30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262F30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262F30);
		  /* 82262F30h */ case    0:  		/* lwz R11, <#[R19 + 20]> */
		/* 82262F30h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82262F30h case    0:*/		return 0x82262F34;
		  /* 82262F34h */ case    1:  		/* addi R11, R11, 4 */
		/* 82262F34h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82262F34h case    1:*/		return 0x82262F38;
		  /* 82262F38h */ case    2:  		/* stw R11, <#[R19 + 20]> */
		/* 82262F38h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82262F38h case    2:*/		return 0x82262F3C;
		  /* 82262F3Ch */ case    3:  		/* lwz R8, <#[R29]> */
		/* 82262F3Ch case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R29 + 0x00000000) );
		/* 82262F3Ch case    3:*/		return 0x82262F40;
		  /* 82262F40h */ case    4:  		/* lwz R10, <#[R31 + 92]> */
		/* 82262F40h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000005C) );
		/* 82262F40h case    4:*/		return 0x82262F44;
		  /* 82262F44h */ case    5:  		/* rlwinm R9, R8, 19, 23, 28 */
		/* 82262F44h case    5:*/		cpu::op::rlwinm<0,19,23,28>(regs,&regs.R9,regs.R8);
		/* 82262F44h case    5:*/		return 0x82262F48;
		  /* 82262F48h */ case    6:  		/* lwz R7, <#[R11]> */
		/* 82262F48h case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 82262F48h case    6:*/		return 0x82262F4C;
		  /* 82262F4Ch */ case    7:  		/* extsh R28, R8 */
		/* 82262F4Ch case    7:*/		cpu::op::extsh<0>(regs,&regs.R28,regs.R8);
		/* 82262F4Ch case    7:*/		return 0x82262F50;
		  /* 82262F50h */ case    8:  		/* add R10, R9, R10 */
		/* 82262F50h case    8:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82262F50h case    8:*/		return 0x82262F54;
		  /* 82262F54h */ case    9:  		/* rlwinm. R9, R7, 10, 31, 31 */
		/* 82262F54h case    9:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R9,regs.R7);
		/* 82262F54h case    9:*/		return 0x82262F58;
		  /* 82262F58h */ case   10:  		/* lwz R27, <#[R10 + 4]> */
		/* 82262F58h case   10:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R10 + 0x00000004) );
		/* 82262F58h case   10:*/		return 0x82262F5C;
		  /* 82262F5Ch */ case   11:  		/* bc 12, CR0_EQ, 12 */
		/* 82262F5Ch case   11:*/		if ( regs.CR[0].eq ) { return 0x82262F68;  }
		/* 82262F5Ch case   11:*/		return 0x82262F60;
		  /* 82262F60h */ case   12:  		/* addi R10, R11, 4 */
		/* 82262F60h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 82262F60h case   12:*/		return 0x82262F64;
		  /* 82262F64h */ case   13:  		/* stw R10, <#[R19 + 20]> */
		/* 82262F64h case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R19 + 0x00000014) );
		/* 82262F64h case   13:*/		return 0x82262F68;
	}
	return 0x82262F68;
} // Block from 82262F30h-82262F68h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82262F68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82262F68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82262F68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82262F68);
		  /* 82262F68h */ case    0:  		/* lwz R10, <#[R19 + 20]> */
		/* 82262F68h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R19 + 0x00000014) );
		/* 82262F68h case    0:*/		return 0x82262F6C;
		  /* 82262F6Ch */ case    1:  		/* li R5, 0 */
		/* 82262F6Ch case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82262F6Ch case    1:*/		return 0x82262F70;
		  /* 82262F70h */ case    2:  		/* li R4, 43 */
		/* 82262F70h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x2B);
		/* 82262F70h case    2:*/		return 0x82262F74;
		  /* 82262F74h */ case    3:  		/* addi R10, R10, 4 */
		/* 82262F74h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82262F74h case    3:*/		return 0x82262F78;
		  /* 82262F78h */ case    4:  		/* stw R10, <#[R19 + 20]> */
		/* 82262F78h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R19 + 0x00000014) );
		/* 82262F78h case    4:*/		return 0x82262F7C;
		  /* 82262F7Ch */ case    5:  		/* lwz R9, <#[R11]> */
		/* 82262F7Ch case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82262F7Ch case    5:*/		return 0x82262F80;
		  /* 82262F80h */ case    6:  		/* lwz R11, <#[R31 + 92]> */
		/* 82262F80h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000005C) );
		/* 82262F80h case    6:*/		return 0x82262F84;
		  /* 82262F84h */ case    7:  		/* rlwinm R10, R9, 19, 23, 28 */
		/* 82262F84h case    7:*/		cpu::op::rlwinm<0,19,23,28>(regs,&regs.R10,regs.R9);
		/* 82262F84h case    7:*/		return 0x82262F88;
		  /* 82262F88h */ case    8:  		/* lwz R3, <#[R31 + 172]> */
		/* 82262F88h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000000AC) );
		/* 82262F88h case    8:*/		return 0x82262F8C;
		  /* 82262F8Ch */ case    9:  		/* extsh R25, R9 */
		/* 82262F8Ch case    9:*/		cpu::op::extsh<0>(regs,&regs.R25,regs.R9);
		/* 82262F8Ch case    9:*/		return 0x82262F90;
		  /* 82262F90h */ case   10:  		/* add R11, R10, R11 */
		/* 82262F90h case   10:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82262F90h case   10:*/		return 0x82262F94;
		  /* 82262F94h */ case   11:  		/* lwz R24, <#[R11 + 4]> */
		/* 82262F94h case   11:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R11 + 0x00000004) );
		/* 82262F94h case   11:*/		return 0x82262F98;
		  /* 82262F98h */ case   12:  		/* bl -120712 */
		/* 82262F98h case   12:*/		regs.LR = 0x82262F9C; return 0x82245810;
		/* 82262F98h case   12:*/		return 0x82262F9C;
		  /* 82262F9Ch */ case   13:  		/* mr R26, R3 */
		/* 82262F9Ch case   13:*/		regs.R26 = regs.R3;
		/* 82262F9Ch case   13:*/		return 0x82262FA0;
		  /* 82262FA0h */ case   14:  		/* lwz R4, <#[R31 + 12]> */
		/* 82262FA0h case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 82262FA0h case   14:*/		return 0x82262FA4;
		  /* 82262FA4h */ case   15:  		/* li R3, 20 */
		/* 82262FA4h case   15:*/		cpu::op::li<0>(regs,&regs.R3,0x14);
		/* 82262FA4h case   15:*/		return 0x82262FA8;
		  /* 82262FA8h */ case   16:  		/* bl -53368 */
		/* 82262FA8h case   16:*/		regs.LR = 0x82262FAC; return 0x82255F30;
		/* 82262FA8h case   16:*/		return 0x82262FAC;
		  /* 82262FACh */ case   17:  		/* lwz R11, <#[R3]> */
		/* 82262FACh case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82262FACh case   17:*/		return 0x82262FB0;
		  /* 82262FB0h */ case   18:  		/* li R6, 0 */
		/* 82262FB0h case   18:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82262FB0h case   18:*/		return 0x82262FB4;
		  /* 82262FB4h */ case   19:  		/* li R5, 43 */
		/* 82262FB4h case   19:*/		cpu::op::li<0>(regs,&regs.R5,0x2B);
		/* 82262FB4h case   19:*/		return 0x82262FB8;
		  /* 82262FB8h */ case   20:  		/* mr R4, R31 */
		/* 82262FB8h case   20:*/		regs.R4 = regs.R31;
		/* 82262FB8h case   20:*/		return 0x82262FBC;
		  /* 82262FBCh */ case   21:  		/* mr R30, R3 */
		/* 82262FBCh case   21:*/		regs.R30 = regs.R3;
		/* 82262FBCh case   21:*/		return 0x82262FC0;
		  /* 82262FC0h */ case   22:  		/* lwz R11, <#[R11 + 100]> */
		/* 82262FC0h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000064) );
		/* 82262FC0h case   22:*/		return 0x82262FC4;
		  /* 82262FC4h */ case   23:  		/* mtspr CTR, R11 */
		/* 82262FC4h case   23:*/		regs.CTR = regs.R11;
		/* 82262FC4h case   23:*/		return 0x82262FC8;
		  /* 82262FC8h */ case   24:  		/* bcctrl 20, CR0_LT */
		/* 82262FC8h case   24:*/		if ( 1 ) { regs.LR = 0x82262FCC; return (uint32)regs.CTR; }
		/* 82262FC8h case   24:*/		return 0x82262FCC;
		  /* 82262FCCh */ case   25:  		/* mr R5, R29 */
		/* 82262FCCh case   25:*/		regs.R5 = regs.R29;
		/* 82262FCCh case   25:*/		return 0x82262FD0;
		  /* 82262FD0h */ case   26:  		/* lwz R29, <#[R1 + 136]> */
		/* 82262FD0h case   26:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000088) );
		/* 82262FD0h case   26:*/		return 0x82262FD4;
		  /* 82262FD4h */ case   27:  		/* li R19, 1 */
		/* 82262FD4h case   27:*/		cpu::op::li<0>(regs,&regs.R19,0x1);
		/* 82262FD4h case   27:*/		return 0x82262FD8;
		  /* 82262FD8h */ case   28:  		/* mr R7, R30 */
		/* 82262FD8h case   28:*/		regs.R7 = regs.R30;
		/* 82262FD8h case   28:*/		return 0x82262FDC;
		  /* 82262FDCh */ case   29:  		/* stw R19, <#[R30 + 16]> */
		/* 82262FDCh case   29:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R30 + 0x00000010) );
		/* 82262FDCh case   29:*/		return 0x82262FE0;
		  /* 82262FE0h */ case   30:  		/* li R6, 1 */
		/* 82262FE0h case   30:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 82262FE0h case   30:*/		return 0x82262FE4;
		  /* 82262FE4h */ case   31:  		/* stw R28, <#[R30 + 60]> */
		/* 82262FE4h case   31:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R30 + 0x0000003C) );
		/* 82262FE4h case   31:*/		return 0x82262FE8;
		  /* 82262FE8h */ case   32:  		/* addi R4, R1, 312 */
		/* 82262FE8h case   32:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x138);
		/* 82262FE8h case   32:*/		return 0x82262FEC;
		  /* 82262FECh */ case   33:  		/* lwz R11, <#[R29 - 1320]> */
		/* 82262FECh case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0xFFFFFAD8) );
		/* 82262FECh case   33:*/		return 0x82262FF0;
		  /* 82262FF0h */ case   34:  		/* mr R3, R31 */
		/* 82262FF0h case   34:*/		regs.R3 = regs.R31;
		/* 82262FF0h case   34:*/		return 0x82262FF4;
		  /* 82262FF4h */ case   35:  		/* stw R27, <#[R30 + 84]> */
		/* 82262FF4h case   35:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R30 + 0x00000054) );
		/* 82262FF4h case   35:*/		return 0x82262FF8;
		  /* 82262FF8h */ case   36:  		/* stw R11, <#[R1 + 312]> */
		/* 82262FF8h case   36:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000138) );
		/* 82262FF8h case   36:*/		return 0x82262FFC;
		  /* 82262FFCh */ case   37:  		/* bl -34812 */
		/* 82262FFCh case   37:*/		regs.LR = 0x82263000; return 0x8225A800;
		/* 82262FFCh case   37:*/		return 0x82263000;
		  /* 82263000h */ case   38:  		/* lwz R11, <#[R29 - 1284]> */
		/* 82263000h case   38:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0xFFFFFAFC) );
		/* 82263000h case   38:*/		return 0x82263004;
		  /* 82263004h */ case   39:  		/* mr R3, R30 */
		/* 82263004h case   39:*/		regs.R3 = regs.R30;
		/* 82263004h case   39:*/		return 0x82263008;
		  /* 82263008h */ case   40:  		/* fmr FR4, FR30 */
		/* 82263008h case   40:*/		cpu::op::fmr<0>(regs,&regs.FR4,regs.FR30);
		/* 82263008h case   40:*/		return 0x8226300C;
		  /* 8226300Ch */ case   41:  		/* li R5, 2 */
		/* 8226300Ch case   41:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 8226300Ch case   41:*/		return 0x82263010;
		  /* 82263010h */ case   42:  		/* fmr FR3, FR30 */
		/* 82263010h case   42:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR30);
		/* 82263010h case   42:*/		return 0x82263014;
		  /* 82263014h */ case   43:  		/* mr R4, R31 */
		/* 82263014h case   43:*/		regs.R4 = regs.R31;
		/* 82263014h case   43:*/		return 0x82263018;
		  /* 82263018h */ case   44:  		/* fmr FR2, FR31 */
		/* 82263018h case   44:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR31);
		/* 82263018h case   44:*/		return 0x8226301C;
		  /* 8226301Ch */ case   45:  		/* fmr FR1, FR30 */
		/* 8226301Ch case   45:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR30);
		/* 8226301Ch case   45:*/		return 0x82263020;
		  /* 82263020h */ case   46:  		/* stw R11, <#[R30 + 132]> */
		/* 82263020h case   46:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000084) );
		/* 82263020h case   46:*/		return 0x82263024;
		  /* 82263024h */ case   47:  		/* bl -49420 */
		/* 82263024h case   47:*/		regs.LR = 0x82263028; return 0x82256F18;
		/* 82263024h case   47:*/		return 0x82263028;
		  /* 82263028h */ case   48:  		/* extsh R11, R22 */
		/* 82263028h case   48:*/		cpu::op::extsh<0>(regs,&regs.R11,regs.R22);
		/* 82263028h case   48:*/		return 0x8226302C;
		  /* 8226302Ch */ case   49:  		/* li R10, 40 */
		/* 8226302Ch case   49:*/		cpu::op::li<0>(regs,&regs.R10,0x28);
		/* 8226302Ch case   49:*/		return 0x82263030;
		  /* 82263030h */ case   50:  		/* li R8, 41 */
		/* 82263030h case   50:*/		cpu::op::li<0>(regs,&regs.R8,0x29);
		/* 82263030h case   50:*/		return 0x82263034;
		  /* 82263034h */ case   51:  		/* sth R11, <#[R1 + 318]> */
		/* 82263034h case   51:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R1 + 0x0000013E) );
		/* 82263034h case   51:*/		return 0x82263038;
		  /* 82263038h */ case   52:  		/* sth R10, <#[R1 + 344]> */
		/* 82263038h case   52:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R1 + 0x00000158) );
		/* 82263038h case   52:*/		return 0x8226303C;
		  /* 8226303Ch */ case   53:  		/* li R9, 14 */
		/* 8226303Ch case   53:*/		cpu::op::li<0>(regs,&regs.R9,0xE);
		/* 8226303Ch case   53:*/		return 0x82263040;
		  /* 82263040h */ case   54:  		/* sth R8, <#[R1 + 316]> */
		/* 82263040h case   54:*/		cpu::mem::store16( regs, regs.R8, (uint32)(regs.R1 + 0x0000013C) );
		/* 82263040h case   54:*/		return 0x82263044;
		  /* 82263044h */ case   55:  		/* li R10, 39 */
		/* 82263044h case   55:*/		cpu::op::li<0>(regs,&regs.R10,0x27);
		/* 82263044h case   55:*/		return 0x82263048;
		  /* 82263048h */ case   56:  		/* sth R11, <#[R1 + 346]> */
		/* 82263048h case   56:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R1 + 0x0000015A) );
		/* 82263048h case   56:*/		return 0x8226304C;
		  /* 8226304Ch */ case   57:  		/* mr R3, R30 */
		/* 8226304Ch case   57:*/		regs.R3 = regs.R30;
		/* 8226304Ch case   57:*/		return 0x82263050;
		  /* 82263050h */ case   58:  		/* li R5, 3 */
		/* 82263050h case   58:*/		cpu::op::li<0>(regs,&regs.R5,0x3);
		/* 82263050h case   58:*/		return 0x82263054;
		  /* 82263054h */ case   59:  		/* sth R9, <#[R1 + 328]> */
		/* 82263054h case   59:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R1 + 0x00000148) );
		/* 82263054h case   59:*/		return 0x82263058;
		  /* 82263058h */ case   60:  		/* mr R4, R31 */
		/* 82263058h case   60:*/		regs.R4 = regs.R31;
		/* 82263058h case   60:*/		return 0x8226305C;
		  /* 8226305Ch */ case   61:  		/* sth R11, <#[R1 + 330]> */
		/* 8226305Ch case   61:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R1 + 0x0000014A) );
		/* 8226305Ch case   61:*/		return 0x82263060;
		  /* 82263060h */ case   62:  		/* sth R10, <#[R1 + 320]> */
		/* 82263060h case   62:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R1 + 0x00000140) );
		/* 82263060h case   62:*/		return 0x82263064;
		  /* 82263064h */ case   63:  		/* sth R11, <#[R1 + 322]> */
		/* 82263064h case   63:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R1 + 0x00000142) );
		/* 82263064h case   63:*/		return 0x82263068;
		  /* 82263068h */ case   64:  		/* lwz R7, <#[R1 + 320]> */
		/* 82263068h case   64:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000140) );
		/* 82263068h case   64:*/		return 0x8226306C;
		  /* 8226306Ch */ case   65:  		/* lwz R6, <#[R1 + 328]> */
		/* 8226306Ch case   65:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000148) );
		/* 8226306Ch case   65:*/		return 0x82263070;
		  /* 82263070h */ case   66:  		/* lwz R9, <#[R1 + 316]> */
		/* 82263070h case   66:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x0000013C) );
		/* 82263070h case   66:*/		return 0x82263074;
		  /* 82263074h */ case   67:  		/* lwz R8, <#[R1 + 344]> */
		/* 82263074h case   67:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000158) );
		/* 82263074h case   67:*/		return 0x82263078;
		  /* 82263078h */ case   68:  		/* bl -49416 */
		/* 82263078h case   68:*/		regs.LR = 0x8226307C; return 0x82256F70;
		/* 82263078h case   68:*/		return 0x8226307C;
		  /* 8226307Ch */ case   69:  		/* mr R4, R23 */
		/* 8226307Ch case   69:*/		regs.R4 = regs.R23;
		/* 8226307Ch case   69:*/		return 0x82263080;
		  /* 82263080h */ case   70:  		/* mr R3, R30 */
		/* 82263080h case   70:*/		regs.R3 = regs.R30;
		/* 82263080h case   70:*/		return 0x82263084;
		  /* 82263084h */ case   71:  		/* bl -36308 */
		/* 82263084h case   71:*/		regs.LR = 0x82263088; return 0x8225A2B0;
		/* 82263084h case   71:*/		return 0x82263088;
		  /* 82263088h */ case   72:  		/* cmplwi CR6, R21, 0 */
		/* 82263088h case   72:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 82263088h case   72:*/		return 0x8226308C;
		  /* 8226308Ch */ case   73:  		/* bc 12, CR6_EQ, 16 */
		/* 8226308Ch case   73:*/		if ( regs.CR[6].eq ) { return 0x8226309C;  }
		/* 8226308Ch case   73:*/		return 0x82263090;
		  /* 82263090h */ case   74:  		/* mr R4, R26 */
		/* 82263090h case   74:*/		regs.R4 = regs.R26;
		/* 82263090h case   74:*/		return 0x82263094;
		  /* 82263094h */ case   75:  		/* mr R3, R30 */
		/* 82263094h case   75:*/		regs.R3 = regs.R30;
		/* 82263094h case   75:*/		return 0x82263098;
		  /* 82263098h */ case   76:  		/* bl -36328 */
		/* 82263098h case   76:*/		regs.LR = 0x8226309C; return 0x8225A2B0;
		/* 82263098h case   76:*/		return 0x8226309C;
	}
	return 0x8226309C;
} // Block from 82262F68h-8226309Ch (77 instructions)

//////////////////////////////////////////////////////
// Block at 8226309Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226309C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226309C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226309C);
		  /* 8226309Ch */ case    0:  		/* mr R4, R30 */
		/* 8226309Ch case    0:*/		regs.R4 = regs.R30;
		/* 8226309Ch case    0:*/		return 0x822630A0;
		  /* 822630A0h */ case    1:  		/* mr R3, R31 */
		/* 822630A0h case    1:*/		regs.R3 = regs.R31;
		/* 822630A0h case    1:*/		return 0x822630A4;
		  /* 822630A4h */ case    2:  		/* bl -183036 */
		/* 822630A4h case    2:*/		regs.LR = 0x822630A8; return 0x822365A8;
		/* 822630A4h case    2:*/		return 0x822630A8;
		  /* 822630A8h */ case    3:  		/* mr R4, R30 */
		/* 822630A8h case    3:*/		regs.R4 = regs.R30;
		/* 822630A8h case    3:*/		return 0x822630AC;
		  /* 822630ACh */ case    4:  		/* mr R3, R14 */
		/* 822630ACh case    4:*/		regs.R3 = regs.R14;
		/* 822630ACh case    4:*/		return 0x822630B0;
		  /* 822630B0h */ case    5:  		/* bl -41344 */
		/* 822630B0h case    5:*/		regs.LR = 0x822630B4; return 0x82258F30;
		/* 822630B0h case    5:*/		return 0x822630B4;
		  /* 822630B4h */ case    6:  		/* mr R3, R30 */
		/* 822630B4h case    6:*/		regs.R3 = regs.R30;
		/* 822630B4h case    6:*/		return 0x822630B8;
		  /* 822630B8h */ case    7:  		/* bl -53496 */
		/* 822630B8h case    7:*/		regs.LR = 0x822630BC; return 0x82255FC0;
		/* 822630B8h case    7:*/		return 0x822630BC;
		  /* 822630BCh */ case    8:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822630BCh case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822630BCh case    8:*/		return 0x822630C0;
		  /* 822630C0h */ case    9:  		/* bc 4, CR0_EQ, 28 */
		/* 822630C0h case    9:*/		if ( !regs.CR[0].eq ) { return 0x822630DC;  }
		/* 822630C0h case    9:*/		return 0x822630C4;
		  /* 822630C4h */ case   10:  		/* mr R6, R17 */
		/* 822630C4h case   10:*/		regs.R6 = regs.R17;
		/* 822630C4h case   10:*/		return 0x822630C8;
		  /* 822630C8h */ case   11:  		/* lwz R5, <#[R1 + 244]> */
		/* 822630C8h case   11:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x000000F4) );
		/* 822630C8h case   11:*/		return 0x822630CC;
		  /* 822630CCh */ case   12:  		/* mr R4, R18 */
		/* 822630CCh case   12:*/		regs.R4 = regs.R18;
		/* 822630CCh case   12:*/		return 0x822630D0;
		  /* 822630D0h */ case   13:  		/* li R7, 1846 */
		/* 822630D0h case   13:*/		cpu::op::li<0>(regs,&regs.R7,0x736);
		/* 822630D0h case   13:*/		return 0x822630D4;
		  /* 822630D4h */ case   14:  		/* li R3, 0 */
		/* 822630D4h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822630D4h case   14:*/		return 0x822630D8;
		  /* 822630D8h */ case   15:  		/* bl -1094864 */
		/* 822630D8h case   15:*/		regs.LR = 0x822630DC; return 0x82157C08;
		/* 822630D8h case   15:*/		return 0x822630DC;
	}
	return 0x822630DC;
} // Block from 8226309Ch-822630DCh (16 instructions)

//////////////////////////////////////////////////////
// Block at 822630DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822630DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822630DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822630DC);
		  /* 822630DCh */ case    0:  		/* li R3, 49 */
		/* 822630DCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x31);
		/* 822630DCh case    0:*/		return 0x822630E0;
		  /* 822630E0h */ case    1:  		/* lwz R4, <#[R31 + 12]> */
		/* 822630E0h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 822630E0h case    1:*/		return 0x822630E4;
		  /* 822630E4h */ case    2:  		/* bl -45948 */
		/* 822630E4h case    2:*/		regs.LR = 0x822630E8; return 0x82257D68;
		/* 822630E4h case    2:*/		return 0x822630E8;
		  /* 822630E8h */ case    3:  		/* lwz R11, <#[R3]> */
		/* 822630E8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822630E8h case    3:*/		return 0x822630EC;
		  /* 822630ECh */ case    4:  		/* mr R6, R20 */
		/* 822630ECh case    4:*/		regs.R6 = regs.R20;
		/* 822630ECh case    4:*/		return 0x822630F0;
		  /* 822630F0h */ case    5:  		/* li R5, 44 */
		/* 822630F0h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x2C);
		/* 822630F0h case    5:*/		return 0x822630F4;
		  /* 822630F4h */ case    6:  		/* mr R4, R31 */
		/* 822630F4h case    6:*/		regs.R4 = regs.R31;
		/* 822630F4h case    6:*/		return 0x822630F8;
		  /* 822630F8h */ case    7:  		/* mr R30, R3 */
		/* 822630F8h case    7:*/		regs.R30 = regs.R3;
		/* 822630F8h case    7:*/		return 0x822630FC;
		  /* 822630FCh */ case    8:  		/* lwz R11, <#[R11 + 100]> */
		/* 822630FCh case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000064) );
		/* 822630FCh case    8:*/		return 0x82263100;
		  /* 82263100h */ case    9:  		/* mtspr CTR, R11 */
		/* 82263100h case    9:*/		regs.CTR = regs.R11;
		/* 82263100h case    9:*/		return 0x82263104;
		  /* 82263104h */ case   10:  		/* bcctrl 20, CR0_LT */
		/* 82263104h case   10:*/		if ( 1 ) { regs.LR = 0x82263108; return (uint32)regs.CTR; }
		/* 82263104h case   10:*/		return 0x82263108;
		  /* 82263108h */ case   11:  		/* stw R25, <#[R30 + 60]> */
		/* 82263108h case   11:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R30 + 0x0000003C) );
		/* 82263108h case   11:*/		return 0x8226310C;
		  /* 8226310Ch */ case   12:  		/* mr R3, R30 */
		/* 8226310Ch case   12:*/		regs.R3 = regs.R30;
		/* 8226310Ch case   12:*/		return 0x82263110;
		  /* 82263110h */ case   13:  		/* stw R24, <#[R30 + 84]> */
		/* 82263110h case   13:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R30 + 0x00000054) );
		/* 82263110h case   13:*/		return 0x82263114;
		  /* 82263114h */ case   14:  		/* mr R4, R26 */
		/* 82263114h case   14:*/		regs.R4 = regs.R26;
		/* 82263114h case   14:*/		return 0x82263118;
		  /* 82263118h */ case   15:  		/* bl -36456 */
		/* 82263118h case   15:*/		regs.LR = 0x8226311C; return 0x8225A2B0;
		/* 82263118h case   15:*/		return 0x8226311C;
		  /* 8226311Ch */ case   16:  		/* mr R4, R30 */
		/* 8226311Ch case   16:*/		regs.R4 = regs.R30;
		/* 8226311Ch case   16:*/		return 0x82263120;
		  /* 82263120h */ case   17:  		/* mr R3, R31 */
		/* 82263120h case   17:*/		regs.R3 = regs.R31;
		/* 82263120h case   17:*/		return 0x82263124;
		  /* 82263124h */ case   18:  		/* bl -183164 */
		/* 82263124h case   18:*/		regs.LR = 0x82263128; return 0x822365A8;
		/* 82263124h case   18:*/		return 0x82263128;
		  /* 82263128h */ case   19:  		/* mr R4, R30 */
		/* 82263128h case   19:*/		regs.R4 = regs.R30;
		/* 82263128h case   19:*/		return 0x8226312C;
		  /* 8226312Ch */ case   20:  		/* mr R3, R14 */
		/* 8226312Ch case   20:*/		regs.R3 = regs.R14;
		/* 8226312Ch case   20:*/		return 0x82263130;
		  /* 82263130h */ case   21:  		/* bl -41472 */
		/* 82263130h case   21:*/		regs.LR = 0x82263134; return 0x82258F30;
		/* 82263130h case   21:*/		return 0x82263134;
		  /* 82263134h */ case   22:  		/* mr R3, R30 */
		/* 82263134h case   22:*/		regs.R3 = regs.R30;
		/* 82263134h case   22:*/		return 0x82263138;
		  /* 82263138h */ case   23:  		/* bl -53624 */
		/* 82263138h case   23:*/		regs.LR = 0x8226313C; return 0x82255FC0;
		/* 82263138h case   23:*/		return 0x8226313C;
		  /* 8226313Ch */ case   24:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8226313Ch case   24:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8226313Ch case   24:*/		return 0x82263140;
		  /* 82263140h */ case   25:  		/* bc 4, CR0_EQ, 28 */
		/* 82263140h case   25:*/		if ( !regs.CR[0].eq ) { return 0x8226315C;  }
		/* 82263140h case   25:*/		return 0x82263144;
		  /* 82263144h */ case   26:  		/* mr R6, R17 */
		/* 82263144h case   26:*/		regs.R6 = regs.R17;
		/* 82263144h case   26:*/		return 0x82263148;
		  /* 82263148h */ case   27:  		/* lwz R5, <#[R1 + 292]> */
		/* 82263148h case   27:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000124) );
		/* 82263148h case   27:*/		return 0x8226314C;
		  /* 8226314Ch */ case   28:  		/* mr R4, R18 */
		/* 8226314Ch case   28:*/		regs.R4 = regs.R18;
		/* 8226314Ch case   28:*/		return 0x82263150;
		  /* 82263150h */ case   29:  		/* li R7, 1857 */
		/* 82263150h case   29:*/		cpu::op::li<0>(regs,&regs.R7,0x741);
		/* 82263150h case   29:*/		return 0x82263154;
		  /* 82263154h */ case   30:  		/* li R3, 0 */
		/* 82263154h case   30:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82263154h case   30:*/		return 0x82263158;
		  /* 82263158h */ case   31:  		/* bl -1094992 */
		/* 82263158h case   31:*/		regs.LR = 0x8226315C; return 0x82157C08;
		/* 82263158h case   31:*/		return 0x8226315C;
	}
	return 0x8226315C;
} // Block from 822630DCh-8226315Ch (32 instructions)

//////////////////////////////////////////////////////
// Block at 8226315Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226315C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226315C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226315C);
		  /* 8226315Ch */ case    0:  		/* stb R19, <#[R1 + 201]> */
		/* 8226315Ch case    0:*/		cpu::mem::store8( regs, regs.R19, (uint32)(regs.R1 + 0x000000C9) );
		/* 8226315Ch case    0:*/		return 0x82263160;
		  /* 82263160h */ case    1:  		/* b 324 */
		/* 82263160h case    1:*/		return 0x822632A4;
		/* 82263160h case    1:*/		return 0x82263164;
	}
	return 0x82263164;
} // Block from 8226315Ch-82263164h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82263164h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263164( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263164) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263164);
		  /* 82263164h */ case    0:  		/* cmpwi CR6, R26, 67 */
		/* 82263164h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R26,0x00000043);
		/* 82263164h case    0:*/		return 0x82263168;
		  /* 82263168h */ case    1:  		/* bc 4, CR6_EQ, 316 */
		/* 82263168h case    1:*/		if ( !regs.CR[6].eq ) { return 0x822632A4;  }
		/* 82263168h case    1:*/		return 0x8226316C;
		  /* 8226316Ch */ case    2:  		/* lwz R11, <#[R19 + 20]> */
		/* 8226316Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 8226316Ch case    2:*/		return 0x82263170;
		  /* 82263170h */ case    3:  		/* li R30, 0 */
		/* 82263170h case    3:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82263170h case    3:*/		return 0x82263174;
		  /* 82263174h */ case    4:  		/* lhz R10, <#[R15]> */
		/* 82263174h case    4:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R15 + 0x00000000) );
		/* 82263174h case    4:*/		return 0x82263178;
		  /* 82263178h */ case    5:  		/* addi R11, R11, 4 */
		/* 82263178h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82263178h case    5:*/		return 0x8226317C;
		  /* 8226317Ch */ case    6:  		/* lwz R26, <#[R1 + 136]> */
		/* 8226317Ch case    6:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x00000088) );
		/* 8226317Ch case    6:*/		return 0x82263180;
		  /* 82263180h */ case    7:  		/* rlwinm R28, R10, 0, 26, 31 */
		/* 82263180h case    7:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R28,regs.R10);
		/* 82263180h case    7:*/		return 0x82263184;
		  /* 82263184h */ case    8:  		/* stw R11, <#[R19 + 20]> */
		/* 82263184h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82263184h case    8:*/		return 0x82263188;
		  /* 82263188h */ case    9:  		/* mr R29, R11 */
		/* 82263188h case    9:*/		regs.R29 = regs.R11;
		/* 82263188h case    9:*/		return 0x8226318C;
		  /* 8226318Ch */ case   10:  		/* lwz R10, <#[R26 - 1316]> */
		/* 8226318Ch case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0xFFFFFADC) );
		/* 8226318Ch case   10:*/		return 0x82263190;
		  /* 82263190h */ case   11:  		/* lwz R11, <#[R11]> */
		/* 82263190h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82263190h case   11:*/		return 0x82263194;
		  /* 82263194h */ case   12:  		/* rlwinm. R11, R11, 10, 31, 31 */
		/* 82263194h case   12:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R11,regs.R11);
		/* 82263194h case   12:*/		return 0x82263198;
		  /* 82263198h */ case   13:  		/* bc 12, CR0_EQ, 196 */
		/* 82263198h case   13:*/		if ( regs.CR[0].eq ) { return 0x8226325C;  }
		/* 82263198h case   13:*/		return 0x8226319C;
		  /* 8226319Ch */ case   14:  		/* lwz R11, <#[R26 - 1308]> */
		/* 8226319Ch case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0xFFFFFAE4) );
		/* 8226319Ch case   14:*/		return 0x822631A0;
		  /* 822631A0h */ case   15:  		/* li R4, 0 */
		/* 822631A0h case   15:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 822631A0h case   15:*/		return 0x822631A4;
		  /* 822631A4h */ case   16:  		/* mr R3, R29 */
		/* 822631A4h case   16:*/		regs.R3 = regs.R29;
		/* 822631A4h case   16:*/		return 0x822631A8;
		  /* 822631A8h */ case   17:  		/* stw R11, <#[R1 + 156]> */
		/* 822631A8h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000009C) );
		/* 822631A8h case   17:*/		return 0x822631AC;
		  /* 822631ACh */ case   18:  		/* bl 15612 */
		/* 822631ACh case   18:*/		regs.LR = 0x822631B0; return 0x82266EA8;
		/* 822631ACh case   18:*/		return 0x822631B0;
		  /* 822631B0h */ case   19:  		/* addi R11, R26, 7964 */
		/* 822631B0h case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x1F1C);
		/* 822631B0h case   19:*/		return 0x822631B4;
		  /* 822631B4h */ case   20:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 822631B4h case   20:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 822631B4h case   20:*/		return 0x822631B8;
		  /* 822631B8h */ case   21:  		/* lwzx R11, <#[R10 + R11]> */
		/* 822631B8h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 822631B8h case   21:*/		return 0x822631BC;
		  /* 822631BCh */ case   22:  		/* cmpwi CR6, R11, 0 */
		/* 822631BCh case   22:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 822631BCh case   22:*/		return 0x822631C0;
		  /* 822631C0h */ case   23:  		/* bc 4, CR6_EQ, 12 */
		/* 822631C0h case   23:*/		if ( !regs.CR[6].eq ) { return 0x822631CC;  }
		/* 822631C0h case   23:*/		return 0x822631C4;
		  /* 822631C4h */ case   24:  		/* li R30, 1 */
		/* 822631C4h case   24:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 822631C4h case   24:*/		return 0x822631C8;
		  /* 822631C8h */ case   25:  		/* stb R27, <#[R1 + 156]> */
		/* 822631C8h case   25:*/		cpu::mem::store8( regs, regs.R27, (uint32)(regs.R1 + 0x0000009C) );
		/* 822631C8h case   25:*/		return 0x822631CC;
	}
	return 0x822631CC;
} // Block from 82263164h-822631CCh (26 instructions)

//////////////////////////////////////////////////////
// Block at 822631CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822631CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822631CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822631CC);
		  /* 822631CCh */ case    0:  		/* li R4, 1 */
		/* 822631CCh case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 822631CCh case    0:*/		return 0x822631D0;
		  /* 822631D0h */ case    1:  		/* mr R3, R29 */
		/* 822631D0h case    1:*/		regs.R3 = regs.R29;
		/* 822631D0h case    1:*/		return 0x822631D4;
		  /* 822631D4h */ case    2:  		/* bl 15572 */
		/* 822631D4h case    2:*/		regs.LR = 0x822631D8; return 0x82266EA8;
		/* 822631D4h case    2:*/		return 0x822631D8;
		  /* 822631D8h */ case    3:  		/* addi R11, R26, 7964 */
		/* 822631D8h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x1F1C);
		/* 822631D8h case    3:*/		return 0x822631DC;
		  /* 822631DCh */ case    4:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 822631DCh case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 822631DCh case    4:*/		return 0x822631E0;
		  /* 822631E0h */ case    5:  		/* lwzx R11, <#[R10 + R11]> */
		/* 822631E0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 822631E0h case    5:*/		return 0x822631E4;
		  /* 822631E4h */ case    6:  		/* cmpwi CR6, R11, 0 */
		/* 822631E4h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 822631E4h case    6:*/		return 0x822631E8;
		  /* 822631E8h */ case    7:  		/* bc 4, CR6_EQ, 16 */
		/* 822631E8h case    7:*/		if ( !regs.CR[6].eq ) { return 0x822631F8;  }
		/* 822631E8h case    7:*/		return 0x822631EC;
		  /* 822631ECh */ case    8:  		/* addi R11, R30, 4 */
		/* 822631ECh case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x4);
		/* 822631ECh case    8:*/		return 0x822631F0;
		  /* 822631F0h */ case    9:  		/* addi R30, R30, 1 */
		/* 822631F0h case    9:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 822631F0h case    9:*/		return 0x822631F4;
		  /* 822631F4h */ case   10:  		/* stb R11, <#[R1 + 157]> */
		/* 822631F4h case   10:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x0000009D) );
		/* 822631F4h case   10:*/		return 0x822631F8;
	}
	return 0x822631F8;
} // Block from 822631CCh-822631F8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 822631F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822631F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822631F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822631F8);
		  /* 822631F8h */ case    0:  		/* li R4, 2 */
		/* 822631F8h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 822631F8h case    0:*/		return 0x822631FC;
		  /* 822631FCh */ case    1:  		/* mr R3, R29 */
		/* 822631FCh case    1:*/		regs.R3 = regs.R29;
		/* 822631FCh case    1:*/		return 0x82263200;
		  /* 82263200h */ case    2:  		/* bl 15528 */
		/* 82263200h case    2:*/		regs.LR = 0x82263204; return 0x82266EA8;
		/* 82263200h case    2:*/		return 0x82263204;
		  /* 82263204h */ case    3:  		/* addi R11, R26, 7964 */
		/* 82263204h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x1F1C);
		/* 82263204h case    3:*/		return 0x82263208;
		  /* 82263208h */ case    4:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 82263208h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 82263208h case    4:*/		return 0x8226320C;
		  /* 8226320Ch */ case    5:  		/* lwzx R11, <#[R10 + R11]> */
		/* 8226320Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8226320Ch case    5:*/		return 0x82263210;
		  /* 82263210h */ case    6:  		/* cmpwi CR6, R11, 0 */
		/* 82263210h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82263210h case    6:*/		return 0x82263214;
		  /* 82263214h */ case    7:  		/* bc 4, CR6_EQ, 16 */
		/* 82263214h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82263224;  }
		/* 82263214h case    7:*/		return 0x82263218;
		  /* 82263218h */ case    8:  		/* addi R11, R30, 4 */
		/* 82263218h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x4);
		/* 82263218h case    8:*/		return 0x8226321C;
		  /* 8226321Ch */ case    9:  		/* addi R30, R30, 1 */
		/* 8226321Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8226321Ch case    9:*/		return 0x82263220;
		  /* 82263220h */ case   10:  		/* stb R11, <#[R1 + 158]> */
		/* 82263220h case   10:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x0000009E) );
		/* 82263220h case   10:*/		return 0x82263224;
	}
	return 0x82263224;
} // Block from 822631F8h-82263224h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82263224h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263224( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263224) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263224);
		  /* 82263224h */ case    0:  		/* li R4, 3 */
		/* 82263224h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x3);
		/* 82263224h case    0:*/		return 0x82263228;
		  /* 82263228h */ case    1:  		/* mr R3, R29 */
		/* 82263228h case    1:*/		regs.R3 = regs.R29;
		/* 82263228h case    1:*/		return 0x8226322C;
		  /* 8226322Ch */ case    2:  		/* bl 15484 */
		/* 8226322Ch case    2:*/		regs.LR = 0x82263230; return 0x82266EA8;
		/* 8226322Ch case    2:*/		return 0x82263230;
		  /* 82263230h */ case    3:  		/* addi R11, R26, 7964 */
		/* 82263230h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x1F1C);
		/* 82263230h case    3:*/		return 0x82263234;
		  /* 82263234h */ case    4:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 82263234h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 82263234h case    4:*/		return 0x82263238;
		  /* 82263238h */ case    5:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82263238h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82263238h case    5:*/		return 0x8226323C;
		  /* 8226323Ch */ case    6:  		/* cmpwi CR6, R11, 0 */
		/* 8226323Ch case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8226323Ch case    6:*/		return 0x82263240;
		  /* 82263240h */ case    7:  		/* bc 4, CR6_EQ, 12 */
		/* 82263240h case    7:*/		if ( !regs.CR[6].eq ) { return 0x8226324C;  }
		/* 82263240h case    7:*/		return 0x82263244;
		  /* 82263244h */ case    8:  		/* addi R11, R30, 4 */
		/* 82263244h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x4);
		/* 82263244h case    8:*/		return 0x82263248;
		  /* 82263248h */ case    9:  		/* stb R11, <#[R1 + 159]> */
		/* 82263248h case    9:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x0000009F) );
		/* 82263248h case    9:*/		return 0x8226324C;
	}
	return 0x8226324C;
} // Block from 82263224h-8226324Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8226324Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226324C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226324C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226324C);
		  /* 8226324Ch */ case    0:  		/* lwz R11, <#[R19 + 20]> */
		/* 8226324Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 8226324Ch case    0:*/		return 0x82263250;
		  /* 82263250h */ case    1:  		/* lwz R10, <#[R1 + 156]> */
		/* 82263250h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000009C) );
		/* 82263250h case    1:*/		return 0x82263254;
		  /* 82263254h */ case    2:  		/* addi R11, R11, 4 */
		/* 82263254h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82263254h case    2:*/		return 0x82263258;
		  /* 82263258h */ case    3:  		/* stw R11, <#[R19 + 20]> */
		/* 82263258h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82263258h case    3:*/		return 0x8226325C;
	}
	return 0x8226325C;
} // Block from 8226324Ch-8226325Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226325Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226325C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226325C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226325C);
		  /* 8226325Ch */ case    0:  		/* lwz R11, <#[R19 + 20]> */
		/* 8226325Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 8226325Ch case    0:*/		return 0x82263260;
		  /* 82263260h */ case    1:  		/* addi R9, R11, 4 */
		/* 82263260h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 82263260h case    1:*/		return 0x82263264;
		  /* 82263264h */ case    2:  		/* stw R9, <#[R19 + 20]> */
		/* 82263264h case    2:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R19 + 0x00000014) );
		/* 82263264h case    2:*/		return 0x82263268;
		  /* 82263268h */ case    3:  		/* lwz R11, <#[R11 + 4]> */
		/* 82263268h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82263268h case    3:*/		return 0x8226326C;
		  /* 8226326Ch */ case    4:  		/* rlwinm. R11, R11, 10, 31, 31 */
		/* 8226326Ch case    4:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R11,regs.R11);
		/* 8226326Ch case    4:*/		return 0x82263270;
		  /* 82263270h */ case    5:  		/* bc 12, CR0_EQ, 12 */
		/* 82263270h case    5:*/		if ( regs.CR[0].eq ) { return 0x8226327C;  }
		/* 82263270h case    5:*/		return 0x82263274;
		  /* 82263274h */ case    6:  		/* addi R11, R9, 4 */
		/* 82263274h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0x4);
		/* 82263274h case    6:*/		return 0x82263278;
		  /* 82263278h */ case    7:  		/* stw R11, <#[R19 + 20]> */
		/* 82263278h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82263278h case    7:*/		return 0x8226327C;
	}
	return 0x8226327C;
} // Block from 8226325Ch-8226327Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8226327Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226327C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226327C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226327C);
		  /* 8226327Ch */ case    0:  		/* lwz R11, <#[R19 + 20]> */
		/* 8226327Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 8226327Ch case    0:*/		return 0x82263280;
		  /* 82263280h */ case    1:  		/* li R8, 0 */
		/* 82263280h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82263280h case    1:*/		return 0x82263284;
		  /* 82263284h */ case    2:  		/* mr R7, R14 */
		/* 82263284h case    2:*/		regs.R7 = regs.R14;
		/* 82263284h case    2:*/		return 0x82263288;
		  /* 82263288h */ case    3:  		/* addi R11, R11, 4 */
		/* 82263288h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82263288h case    3:*/		return 0x8226328C;
		  /* 8226328Ch */ case    4:  		/* mr R6, R10 */
		/* 8226328Ch case    4:*/		regs.R6 = regs.R10;
		/* 8226328Ch case    4:*/		return 0x82263290;
		  /* 82263290h */ case    5:  		/* stw R11, <#[R19 + 20]> */
		/* 82263290h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x00000014) );
		/* 82263290h case    5:*/		return 0x82263294;
		  /* 82263294h */ case    6:  		/* mr R5, R29 */
		/* 82263294h case    6:*/		regs.R5 = regs.R29;
		/* 82263294h case    6:*/		return 0x82263298;
		  /* 82263298h */ case    7:  		/* mr R4, R28 */
		/* 82263298h case    7:*/		regs.R4 = regs.R28;
		/* 82263298h case    7:*/		return 0x8226329C;
		  /* 8226329Ch */ case    8:  		/* mr R3, R31 */
		/* 8226329Ch case    8:*/		regs.R3 = regs.R31;
		/* 8226329Ch case    8:*/		return 0x822632A0;
		  /* 822632A0h */ case    9:  		/* bl -27712 */
		/* 822632A0h case    9:*/		regs.LR = 0x822632A4; return 0x8225C660;
		/* 822632A0h case    9:*/		return 0x822632A4;
	}
	return 0x822632A4;
} // Block from 8226327Ch-822632A4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 822632A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822632A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822632A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822632A4);
		  /* 822632A4h */ case    0:  		/* lwz R19, <#[R1 + 940]> */
		/* 822632A4h case    0:*/		cpu::mem::load32z( regs, &regs.R19, (uint32)(regs.R1 + 0x000003AC) );
		/* 822632A4h case    0:*/		return 0x822632A8;
		  /* 822632A8h */ case    1:  		/* mr R3, R19 */
		/* 822632A8h case    1:*/		regs.R3 = regs.R19;
		/* 822632A8h case    1:*/		return 0x822632AC;
		  /* 822632ACh */ case    2:  		/* bl -155212 */
		/* 822632ACh case    2:*/		regs.LR = 0x822632B0; return 0x8223D460;
		/* 822632ACh case    2:*/		return 0x822632B0;
		  /* 822632B0h */ case    3:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822632B0h case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822632B0h case    3:*/		return 0x822632B4;
		  /* 822632B4h */ case    4:  		/* bc 4, CR0_EQ, -24052 */
		/* 822632B4h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8225D4C0;  }
		/* 822632B4h case    4:*/		return 0x822632B8;
		  /* 822632B8h */ case    5:  		/* lwz R25, <#[R1 + 164]> */
		/* 822632B8h case    5:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R1 + 0x000000A4) );
		/* 822632B8h case    5:*/		return 0x822632BC;
		  /* 822632BCh */ case    6:  		/* lwz R27, <#[R1 + 220]> */
		/* 822632BCh case    6:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x000000DC) );
		/* 822632BCh case    6:*/		return 0x822632C0;
		  /* 822632C0h */ case    7:  		/* lwz R26, <#[R1 + 260]> */
		/* 822632C0h case    7:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x00000104) );
		/* 822632C0h case    7:*/		return 0x822632C4;
	}
	return 0x822632C4;
} // Block from 822632A4h-822632C4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 822632C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822632C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822632C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822632C4);
		  /* 822632C4h */ case    0:  		/* mr R3, R31 */
		/* 822632C4h case    0:*/		regs.R3 = regs.R31;
		/* 822632C4h case    0:*/		return 0x822632C8;
		  /* 822632C8h */ case    1:  		/* bl -180000 */
		/* 822632C8h case    1:*/		regs.LR = 0x822632CC; return 0x822373A8;
		/* 822632C8h case    1:*/		return 0x822632CC;
		  /* 822632CCh */ case    2:  		/* mr R3, R14 */
		/* 822632CCh case    2:*/		regs.R3 = regs.R14;
		/* 822632CCh case    2:*/		return 0x822632D0;
		  /* 822632D0h */ case    3:  		/* lwz R4, <#[R31 + 168]> */
		/* 822632D0h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x000000A8) );
		/* 822632D0h case    3:*/		return 0x822632D4;
		  /* 822632D4h */ case    4:  		/* bl -39428 */
		/* 822632D4h case    4:*/		regs.LR = 0x822632D8; return 0x822598D0;
		/* 822632D4h case    4:*/		return 0x822632D8;
		  /* 822632D8h */ case    5:  		/* cmplwi CR6, R27, 0 */
		/* 822632D8h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 822632D8h case    5:*/		return 0x822632DC;
		  /* 822632DCh */ case    6:  		/* bc 12, CR6_EQ, 16 */
		/* 822632DCh case    6:*/		if ( regs.CR[6].eq ) { return 0x822632EC;  }
		/* 822632DCh case    6:*/		return 0x822632E0;
		  /* 822632E0h */ case    7:  		/* li R4, 1 */
		/* 822632E0h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 822632E0h case    7:*/		return 0x822632E4;
		  /* 822632E4h */ case    8:  		/* mr R3, R27 */
		/* 822632E4h case    8:*/		regs.R3 = regs.R27;
		/* 822632E4h case    8:*/		return 0x822632E8;
		  /* 822632E8h */ case    9:  		/* bl -145232 */
		/* 822632E8h case    9:*/		regs.LR = 0x822632EC; return 0x8223FB98;
		/* 822632E8h case    9:*/		return 0x822632EC;
	}
	return 0x822632EC;
} // Block from 822632C4h-822632ECh (10 instructions)

//////////////////////////////////////////////////////
// Block at 822632ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822632EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822632EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822632EC);
		  /* 822632ECh */ case    0:  		/* cmplwi CR6, R25, 0 */
		/* 822632ECh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 822632ECh case    0:*/		return 0x822632F0;
		  /* 822632F0h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 822632F0h case    1:*/		if ( regs.CR[6].eq ) { return 0x82263300;  }
		/* 822632F0h case    1:*/		return 0x822632F4;
		  /* 822632F4h */ case    2:  		/* li R4, 1 */
		/* 822632F4h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 822632F4h case    2:*/		return 0x822632F8;
		  /* 822632F8h */ case    3:  		/* mr R3, R25 */
		/* 822632F8h case    3:*/		regs.R3 = regs.R25;
		/* 822632F8h case    3:*/		return 0x822632FC;
		  /* 822632FCh */ case    4:  		/* bl -145252 */
		/* 822632FCh case    4:*/		regs.LR = 0x82263300; return 0x8223FB98;
		/* 822632FCh case    4:*/		return 0x82263300;
	}
	return 0x82263300;
} // Block from 822632ECh-82263300h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82263300h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263300( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263300) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263300);
		  /* 82263300h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 82263300h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82263300h case    0:*/		return 0x82263304;
		  /* 82263304h */ case    1:  		/* lwz R4, <#[R1 + 276]> */
		/* 82263304h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000114) );
		/* 82263304h case    1:*/		return 0x82263308;
		  /* 82263308h */ case    2:  		/* lwz R3, <#[R11 + 1456]> */
		/* 82263308h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 82263308h case    2:*/		return 0x8226330C;
		  /* 8226330Ch */ case    3:  		/* bl -289996 */
		/* 8226330Ch case    3:*/		regs.LR = 0x82263310; return 0x8221C640;
		/* 8226330Ch case    3:*/		return 0x82263310;
		  /* 82263310h */ case    4:  		/* lwz R11, <#[R31 + 12]> */
		/* 82263310h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82263310h case    4:*/		return 0x82263314;
		  /* 82263314h */ case    5:  		/* lwz R4, <#[R1 + 180]> */
		/* 82263314h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x000000B4) );
		/* 82263314h case    5:*/		return 0x82263318;
		  /* 82263318h */ case    6:  		/* lwz R3, <#[R11 + 1456]> */
		/* 82263318h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 82263318h case    6:*/		return 0x8226331C;
		  /* 8226331Ch */ case    7:  		/* bl -290012 */
		/* 8226331Ch case    7:*/		regs.LR = 0x82263320; return 0x8221C640;
		/* 8226331Ch case    7:*/		return 0x82263320;
		  /* 82263320h */ case    8:  		/* lwz R11, <#[R31 + 12]> */
		/* 82263320h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82263320h case    8:*/		return 0x82263324;
		  /* 82263324h */ case    9:  		/* lwz R4, <#[R1 + 308]> */
		/* 82263324h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000134) );
		/* 82263324h case    9:*/		return 0x82263328;
		  /* 82263328h */ case   10:  		/* lwz R3, <#[R11 + 1456]> */
		/* 82263328h case   10:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 82263328h case   10:*/		return 0x8226332C;
		  /* 8226332Ch */ case   11:  		/* bl -290028 */
		/* 8226332Ch case   11:*/		regs.LR = 0x82263330; return 0x8221C640;
		/* 8226332Ch case   11:*/		return 0x82263330;
		  /* 82263330h */ case   12:  		/* lwz R11, <#[R31 + 12]> */
		/* 82263330h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82263330h case   12:*/		return 0x82263334;
		  /* 82263334h */ case   13:  		/* lwz R4, <#[R1 + 224]> */
		/* 82263334h case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x000000E0) );
		/* 82263334h case   13:*/		return 0x82263338;
		  /* 82263338h */ case   14:  		/* lwz R3, <#[R11 + 1456]> */
		/* 82263338h case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 82263338h case   14:*/		return 0x8226333C;
		  /* 8226333Ch */ case   15:  		/* bl -290044 */
		/* 8226333Ch case   15:*/		regs.LR = 0x82263340; return 0x8221C640;
		/* 8226333Ch case   15:*/		return 0x82263340;
		  /* 82263340h */ case   16:  		/* lwz R11, <#[R31 + 12]> */
		/* 82263340h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82263340h case   16:*/		return 0x82263344;
		  /* 82263344h */ case   17:  		/* lwz R4, <#[R1 + 284]> */
		/* 82263344h case   17:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x0000011C) );
		/* 82263344h case   17:*/		return 0x82263348;
		  /* 82263348h */ case   18:  		/* lwz R3, <#[R11 + 1456]> */
		/* 82263348h case   18:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 82263348h case   18:*/		return 0x8226334C;
		  /* 8226334Ch */ case   19:  		/* bl -290060 */
		/* 8226334Ch case   19:*/		regs.LR = 0x82263350; return 0x8221C640;
		/* 8226334Ch case   19:*/		return 0x82263350;
		  /* 82263350h */ case   20:  		/* lwz R11, <#[R31 + 12]> */
		/* 82263350h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82263350h case   20:*/		return 0x82263354;
		  /* 82263354h */ case   21:  		/* lwz R4, <#[R1 + 228]> */
		/* 82263354h case   21:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x000000E4) );
		/* 82263354h case   21:*/		return 0x82263358;
		  /* 82263358h */ case   22:  		/* lwz R3, <#[R11 + 1456]> */
		/* 82263358h case   22:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 82263358h case   22:*/		return 0x8226335C;
		  /* 8226335Ch */ case   23:  		/* bl -290076 */
		/* 8226335Ch case   23:*/		regs.LR = 0x82263360; return 0x8221C640;
		/* 8226335Ch case   23:*/		return 0x82263360;
		  /* 82263360h */ case   24:  		/* cmplwi CR6, R26, 0 */
		/* 82263360h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 82263360h case   24:*/		return 0x82263364;
		  /* 82263364h */ case   25:  		/* bc 12, CR6_EQ, 16 */
		/* 82263364h case   25:*/		if ( regs.CR[6].eq ) { return 0x82263374;  }
		/* 82263364h case   25:*/		return 0x82263368;
		  /* 82263368h */ case   26:  		/* addi R4, R26, -4 */
		/* 82263368h case   26:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R26,0xFFFFFFFC);
		/* 82263368h case   26:*/		return 0x8226336C;
		  /* 8226336Ch */ case   27:  		/* lwz R3, <#[R26 - 4]> */
		/* 8226336Ch case   27:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R26 + 0xFFFFFFFC) );
		/* 8226336Ch case   27:*/		return 0x82263370;
		  /* 82263370h */ case   28:  		/* bl -290096 */
		/* 82263370h case   28:*/		regs.LR = 0x82263374; return 0x8221C640;
		/* 82263370h case   28:*/		return 0x82263374;
	}
	return 0x82263374;
} // Block from 82263300h-82263374h (29 instructions)

//////////////////////////////////////////////////////
// Block at 82263374h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263374( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263374) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263374);
		  /* 82263374h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 82263374h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82263374h case    0:*/		return 0x82263378;
		  /* 82263378h */ case    1:  		/* lwz R4, <#[R31 + 88]> */
		/* 82263378h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000058) );
		/* 82263378h case    1:*/		return 0x8226337C;
		  /* 8226337Ch */ case    2:  		/* lwz R3, <#[R11 + 1456]> */
		/* 8226337Ch case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 8226337Ch case    2:*/		return 0x82263380;
		  /* 82263380h */ case    3:  		/* bl -290112 */
		/* 82263380h case    3:*/		regs.LR = 0x82263384; return 0x8221C640;
		/* 82263380h case    3:*/		return 0x82263384;
		  /* 82263384h */ case    4:  		/* mr R3, R31 */
		/* 82263384h case    4:*/		regs.R3 = regs.R31;
		/* 82263384h case    4:*/		return 0x82263388;
		  /* 82263388h */ case    5:  		/* bl -106328 */
		/* 82263388h case    5:*/		regs.LR = 0x8226338C; return 0x82249430;
		/* 82263388h case    5:*/		return 0x8226338C;
		  /* 8226338Ch */ case    6:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8226338Ch case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8226338Ch case    6:*/		return 0x82263390;
		  /* 82263390h */ case    7:  		/* bc 4, CR0_EQ, 32 */
		/* 82263390h case    7:*/		if ( !regs.CR[0].eq ) { return 0x822633B0;  }
		/* 82263390h case    7:*/		return 0x82263394;
		  /* 82263394h */ case    8:  		/* lis R11, -32251 */
		/* 82263394h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82263394h case    8:*/		return 0x82263398;
		  /* 82263398h */ case    9:  		/* lwz R6, <#[R1 + 128]> */
		/* 82263398h case    9:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000080) );
		/* 82263398h case    9:*/		return 0x8226339C;
		  /* 8226339Ch */ case   10:  		/* li R7, 4297 */
		/* 8226339Ch case   10:*/		cpu::op::li<0>(regs,&regs.R7,0x10C9);
		/* 8226339Ch case   10:*/		return 0x822633A0;
		  /* 822633A0h */ case   11:  		/* lwz R4, <#[R1 + 132]> */
		/* 822633A0h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000084) );
		/* 822633A0h case   11:*/		return 0x822633A4;
		  /* 822633A4h */ case   12:  		/* addi R5, R11, -20220 */
		/* 822633A4h case   12:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFB104);
		/* 822633A4h case   12:*/		return 0x822633A8;
		  /* 822633A8h */ case   13:  		/* li R3, 0 */
		/* 822633A8h case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822633A8h case   13:*/		return 0x822633AC;
		  /* 822633ACh */ case   14:  		/* bl -1095588 */
		/* 822633ACh case   14:*/		regs.LR = 0x822633B0; return 0x82157C08;
		/* 822633ACh case   14:*/		return 0x822633B0;
	}
	return 0x822633B0;
} // Block from 82263374h-822633B0h (15 instructions)

//////////////////////////////////////////////////////
// Block at 822633B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822633B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822633B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822633B0);
		  /* 822633B0h */ case    0:  		/* addi R1, R1, 912 */
		/* 822633B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x390);
		/* 822633B0h case    0:*/		return 0x822633B4;
		  /* 822633B4h */ case    1:  		/* addi R12, R1, -152 */
		/* 822633B4h case    1:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R1,0xFFFFFF68);
		/* 822633B4h case    1:*/		return 0x822633B8;
		  /* 822633B8h */ case    2:  		/* bl -1908572 */
		/* 822633B8h case    2:*/		regs.LR = 0x822633BC; return 0x8209145C;
		/* 822633B8h case    2:*/		return 0x822633BC;
		  /* 822633BCh */ case    3:  		/* b -1909068 */
		/* 822633BCh case    3:*/		return 0x82091270;
		/* 822633BCh case    3:*/		return 0x822633C0;
	}
	return 0x822633C0;
} // Block from 822633B0h-822633C0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822633C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822633C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822633C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822633C0);
		  /* 822633C0h */ case    0:  		/* li R10, 26 */
		/* 822633C0h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x1A);
		/* 822633C0h case    0:*/		return 0x822633C4;
		  /* 822633C4h */ case    1:  		/* li R4, 1 */
		/* 822633C4h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 822633C4h case    1:*/		return 0x822633C8;
		  /* 822633C8h */ case    2:  		/* stw R10, <#[R11 + 1364]> */
		/* 822633C8h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000554) );
		/* 822633C8h case    2:*/		return 0x822633CC;
		  /* 822633CCh */ case    3:  		/* addi R3, R11, 16 */
		/* 822633CCh case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x10);
		/* 822633CCh case    3:*/		return 0x822633D0;
		  /* 822633D0h */ case    4:  		/* bl 23264 */
		/* 822633D0h case    4:*/		regs.LR = 0x822633D4; return 0x82268EB0;
		/* 822633D0h case    4:*/		return 0x822633D4;
	}
	return 0x822633D4;
} // Block from 822633C0h-822633D4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822633D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822633D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822633D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822633D4);
		  /* 822633D4h */ case    0:  		/* li R11, 25 */
		/* 822633D4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x19);
		/* 822633D4h case    0:*/		return 0x822633D8;
		  /* 822633D8h */ case    1:  		/* li R4, 1 */
		/* 822633D8h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 822633D8h case    1:*/		return 0x822633DC;
		  /* 822633DCh */ case    2:  		/* stw R11, <#[R10 + 1364]> */
		/* 822633DCh case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000554) );
		/* 822633DCh case    2:*/		return 0x822633E0;
		  /* 822633E0h */ case    3:  		/* addi R3, R10, 16 */
		/* 822633E0h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R10,0x10);
		/* 822633E0h case    3:*/		return 0x822633E4;
		  /* 822633E4h */ case    4:  		/* bl 23244 */
		/* 822633E4h case    4:*/		regs.LR = 0x822633E8; return 0x82268EB0;
		/* 822633E4h case    4:*/		return 0x822633E8;
		  /* 822633E8h */ case    5:  		/* lwz R11, <#[R3]> */
		/* 822633E8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822633E8h case    5:*/		return 0x822633EC;
		  /* 822633ECh */ case    6:  		/* mr R10, R3 */
		/* 822633ECh case    6:*/		regs.R10 = regs.R3;
		/* 822633ECh case    6:*/		return 0x822633F0;
		  /* 822633F0h */ case    7:  		/* li R3, 0 */
		/* 822633F0h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822633F0h case    7:*/		return 0x822633F4;
		  /* 822633F4h */ case    8:  		/* li R6, 0 */
		/* 822633F4h case    8:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 822633F4h case    8:*/		return 0x822633F8;
		  /* 822633F8h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 822633F8h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822633F8h case    9:*/		return 0x822633FC;
		  /* 822633FCh */ case   10:  		/* bclr 4, CR6_GT */
		/* 822633FCh case   10:*/		if ( !regs.CR[6].gt ) { return (uint32)regs.LR; }
		/* 822633FCh case   10:*/		return 0x82263400;
	}
	return 0x82263400;
} // Block from 822633D4h-82263400h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82263400h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263400( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263400) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263400);
		  /* 82263400h */ case    0:  		/* addi R11, R4, 8 */
		/* 82263400h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x8);
		/* 82263400h case    0:*/		return 0x82263404;
		  /* 82263404h */ case    1:  		/* subf R7, R10, R5 */
		/* 82263404h case    1:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R10,regs.R5);
		/* 82263404h case    1:*/		return 0x82263408;
		  /* 82263408h */ case    2:  		/* subf R8, R4, R10 */
		/* 82263408h case    2:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R4,regs.R10);
		/* 82263408h case    2:*/		return 0x8226340C;
		  /* 8226340Ch */ case    3:  		/* add R9, R8, R11 */
		/* 8226340Ch case    3:*/		cpu::op::add<0>(regs,&regs.R9,regs.R8,regs.R11);
		/* 8226340Ch case    3:*/		return 0x82263410;
		  /* 82263410h */ case    4:  		/* lwzx R5, <#[R8 + R11]> */
		/* 82263410h case    4:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 82263410h case    4:*/		return 0x82263414;
		  /* 82263414h */ case    5:  		/* lwz R4, <#[R11]> */
		/* 82263414h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000000) );
		/* 82263414h case    5:*/		return 0x82263418;
		  /* 82263418h */ case    6:  		/* lwzx R9, <#[R9 + R7]> */
		/* 82263418h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R7 + 0x00000000) );
		/* 82263418h case    6:*/		return 0x8226341C;
		  /* 8226341Ch */ case    7:  		/* andc R9, R5, R9 */
		/* 8226341Ch case    7:*/		cpu::op::andc<0>(regs,&regs.R9,regs.R5,regs.R9);
		/* 8226341Ch case    7:*/		return 0x82263420;
		  /* 82263420h */ case    8:  		/* or R9, R9, R4 */
		/* 82263420h case    8:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R4);
		/* 82263420h case    8:*/		return 0x82263424;
		  /* 82263424h */ case    9:  		/* cmplw CR6, R9, R4 */
		/* 82263424h case    9:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R4);
		/* 82263424h case    9:*/		return 0x82263428;
		  /* 82263428h */ case   10:  		/* bc 12, CR6_EQ, 12 */
		/* 82263428h case   10:*/		if ( regs.CR[6].eq ) { return 0x82263434;  }
		/* 82263428h case   10:*/		return 0x8226342C;
		  /* 8226342Ch */ case   11:  		/* stw R9, <#[R11]> */
		/* 8226342Ch case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8226342Ch case   11:*/		return 0x82263430;
		  /* 82263430h */ case   12:  		/* li R3, 1 */
		/* 82263430h case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82263430h case   12:*/		return 0x82263434;
	}
	return 0x82263434;
} // Block from 82263400h-82263434h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82263434h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263434( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263434) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263434);
		  /* 82263434h */ case    0:  		/* lwz R9, <#[R10]> */
		/* 82263434h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82263434h case    0:*/		return 0x82263438;
		  /* 82263438h */ case    1:  		/* addi R6, R6, 1 */
		/* 82263438h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 82263438h case    1:*/		return 0x8226343C;
		  /* 8226343Ch */ case    2:  		/* addi R11, R11, 4 */
		/* 8226343Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8226343Ch case    2:*/		return 0x82263440;
		  /* 82263440h */ case    3:  		/* cmplw CR6, R6, R9 */
		/* 82263440h case    3:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R9);
		/* 82263440h case    3:*/		return 0x82263444;
		  /* 82263444h */ case    4:  		/* bc 12, CR6_LT, -56 */
		/* 82263444h case    4:*/		if ( regs.CR[6].lt ) { return 0x8226340C;  }
		/* 82263444h case    4:*/		return 0x82263448;
		  /* 82263448h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82263448h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82263448h case    5:*/		return 0x8226344C;
	}
	return 0x8226344C;
} // Block from 82263434h-8226344Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8226344Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226344C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226344C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226344C);
		  /* 8226344Ch */ case    0:  		/* nop */
		/* 8226344Ch case    0:*/		cpu::op::nop();
		/* 8226344Ch case    0:*/		return 0x82263450;
	}
	return 0x82263450;
} // Block from 8226344Ch-82263450h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82263450h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263450( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263450) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263450);
		  /* 82263450h */ case    0:  		/* mfspr R12, LR */
		/* 82263450h case    0:*/		regs.R12 = regs.LR;
		/* 82263450h case    0:*/		return 0x82263454;
		  /* 82263454h */ case    1:  		/* bl -1909252 */
		/* 82263454h case    1:*/		regs.LR = 0x82263458; return 0x82091250;
		/* 82263454h case    1:*/		return 0x82263458;
		  /* 82263458h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82263458h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82263458h case    2:*/		return 0x8226345C;
		  /* 8226345Ch */ case    3:  		/* lwz R31, <#[R4 + 20]> */
		/* 8226345Ch case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R4 + 0x00000014) );
		/* 8226345Ch case    3:*/		return 0x82263460;
		  /* 82263460h */ case    4:  		/* mr R27, R3 */
		/* 82263460h case    4:*/		regs.R27 = regs.R3;
		/* 82263460h case    4:*/		return 0x82263464;
		  /* 82263464h */ case    5:  		/* mr R30, R4 */
		/* 82263464h case    5:*/		regs.R30 = regs.R4;
		/* 82263464h case    5:*/		return 0x82263468;
		  /* 82263468h */ case    6:  		/* mr R28, R5 */
		/* 82263468h case    6:*/		regs.R28 = regs.R5;
		/* 82263468h case    6:*/		return 0x8226346C;
		  /* 8226346Ch */ case    7:  		/* li R26, 1 */
		/* 8226346Ch case    7:*/		cpu::op::li<0>(regs,&regs.R26,0x1);
		/* 8226346Ch case    7:*/		return 0x82263470;
		  /* 82263470h */ case    8:  		/* cmpwi CR6, R31, 0 */
		/* 82263470h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 82263470h case    8:*/		return 0x82263474;
		  /* 82263474h */ case    9:  		/* bc 4, CR6_GT, 124 */
		/* 82263474h case    9:*/		if ( !regs.CR[6].gt ) { return 0x822634F0;  }
		/* 82263474h case    9:*/		return 0x82263478;
		  /* 82263478h */ case   10:  		/* addi R11, R31, 7 */
		/* 82263478h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x7);
		/* 82263478h case   10:*/		return 0x8226347C;
		  /* 8226347Ch */ case   11:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8226347Ch case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8226347Ch case   11:*/		return 0x82263480;
		  /* 82263480h */ case   12:  		/* add R29, R11, R4 */
		/* 82263480h case   12:*/		cpu::op::add<0>(regs,&regs.R29,regs.R11,regs.R4);
		/* 82263480h case   12:*/		return 0x82263484;
		  /* 82263484h */ case   13:  		/* mr R4, R31 */
		/* 82263484h case   13:*/		regs.R4 = regs.R31;
		/* 82263484h case   13:*/		return 0x82263488;
		  /* 82263488h */ case   14:  		/* mr R3, R30 */
		/* 82263488h case   14:*/		regs.R3 = regs.R30;
		/* 82263488h case   14:*/		return 0x8226348C;
		  /* 8226348Ch */ case   15:  		/* bl 15356 */
		/* 8226348Ch case   15:*/		regs.LR = 0x82263490; return 0x82267088;
		/* 8226348Ch case   15:*/		return 0x82263490;
		  /* 82263490h */ case   16:  		/* cmpwi CR0, R3, 0 */
		/* 82263490h case   16:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82263490h case   16:*/		return 0x82263494;
		  /* 82263494h */ case   17:  		/* bc 12, CR0_LT, 80 */
		/* 82263494h case   17:*/		if ( regs.CR[0].lt ) { return 0x822634E4;  }
		/* 82263494h case   17:*/		return 0x82263498;
		  /* 82263498h */ case   18:  		/* rlwinm R11, R3, 27, 5, 31 */
		/* 82263498h case   18:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R3);
		/* 82263498h case   18:*/		return 0x8226349C;
		  /* 8226349Ch */ case   19:  		/* rlwinm R10, R3, 0, 27, 31 */
		/* 8226349Ch case   19:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R3);
		/* 8226349Ch case   19:*/		return 0x822634A0;
		  /* 822634A0h */ case   20:  		/* addi R11, R11, 2 */
		/* 822634A0h case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 822634A0h case   20:*/		return 0x822634A4;
		  /* 822634A4h */ case   21:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 822634A4h case   21:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 822634A4h case   21:*/		return 0x822634A8;
		  /* 822634A8h */ case   22:  		/* lwzx R9, <#[R11 + R28]> */
		/* 822634A8h case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 822634A8h case   22:*/		return 0x822634AC;
		  /* 822634ACh */ case   23:  		/* srw R9, R9, R10 */
		/* 822634ACh case   23:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 822634ACh case   23:*/		return 0x822634B0;
		  /* 822634B0h */ case   24:  		/* rlwinm. R9, R9, 0, 31, 31 */
		/* 822634B0h case   24:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R9);
		/* 822634B0h case   24:*/		return 0x822634B4;
		  /* 822634B4h */ case   25:  		/* bc 4, CR0_EQ, 48 */
		/* 822634B4h case   25:*/		if ( !regs.CR[0].eq ) { return 0x822634E4;  }
		/* 822634B4h case   25:*/		return 0x822634B8;
		  /* 822634B8h */ case   26:  		/* lwz R9, <#[R27 + 176]> */
		/* 822634B8h case   26:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x000000B0) );
		/* 822634B8h case   26:*/		return 0x822634BC;
		  /* 822634BCh */ case   27:  		/* slw R10, R26, R10 */
		/* 822634BCh case   27:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R26,regs.R10);
		/* 822634BCh case   27:*/		return 0x822634C0;
		  /* 822634C0h */ case   28:  		/* lwzx R8, <#[R11 + R9]> */
		/* 822634C0h case   28:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 822634C0h case   28:*/		return 0x822634C4;
		  /* 822634C4h */ case   29:  		/* li R4, 1 */
		/* 822634C4h case   29:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 822634C4h case   29:*/		return 0x822634C8;
		  /* 822634C8h */ case   30:  		/* or R10, R10, R8 */
		/* 822634C8h case   30:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 822634C8h case   30:*/		return 0x822634CC;
		  /* 822634CCh */ case   31:  		/* stwx R10, <#[R11 + R9]> */
		/* 822634CCh case   31:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 822634CCh case   31:*/		return 0x822634D0;
		  /* 822634D0h */ case   32:  		/* lwz R3, <#[R29]> */
		/* 822634D0h case   32:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000000) );
		/* 822634D0h case   32:*/		return 0x822634D4;
		  /* 822634D4h */ case   33:  		/* lwz R11, <#[R3]> */
		/* 822634D4h case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822634D4h case   33:*/		return 0x822634D8;
		  /* 822634D8h */ case   34:  		/* lwz R11, <#[R11 + 4]> */
		/* 822634D8h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 822634D8h case   34:*/		return 0x822634DC;
		  /* 822634DCh */ case   35:  		/* mtspr CTR, R11 */
		/* 822634DCh case   35:*/		regs.CTR = regs.R11;
		/* 822634DCh case   35:*/		return 0x822634E0;
		  /* 822634E0h */ case   36:  		/* bcctrl 20, CR0_LT */
		/* 822634E0h case   36:*/		if ( 1 ) { regs.LR = 0x822634E4; return (uint32)regs.CTR; }
		/* 822634E0h case   36:*/		return 0x822634E4;
	}
	return 0x822634E4;
} // Block from 82263450h-822634E4h (37 instructions)

//////////////////////////////////////////////////////
// Block at 822634E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822634E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822634E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822634E4);
		  /* 822634E4h */ case    0:  		/* addic. R31, R31, -1 */
		/* 822634E4h case    0:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R31,0xFFFFFFFF);
		/* 822634E4h case    0:*/		return 0x822634E8;
		  /* 822634E8h */ case    1:  		/* addi R29, R29, -4 */
		/* 822634E8h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0xFFFFFFFC);
		/* 822634E8h case    1:*/		return 0x822634EC;
		  /* 822634ECh */ case    2:  		/* bc 12, CR0_GT, -104 */
		/* 822634ECh case    2:*/		if ( regs.CR[0].gt ) { return 0x82263484;  }
		/* 822634ECh case    2:*/		return 0x822634F0;
	}
	return 0x822634F0;
} // Block from 822634E4h-822634F0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822634F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822634F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822634F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822634F0);
		  /* 822634F0h */ case    0:  		/* lwz R11, <#[R30 + 16]> */
		/* 822634F0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 822634F0h case    0:*/		return 0x822634F4;
		  /* 822634F4h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 822634F4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 822634F4h case    1:*/		return 0x822634F8;
		  /* 822634F8h */ case    2:  		/* bc 4, CR6_GT, 68 */
		/* 822634F8h case    2:*/		if ( !regs.CR[6].gt ) { return 0x8226353C;  }
		/* 822634F8h case    2:*/		return 0x822634FC;
		  /* 822634FCh */ case    3:  		/* lwz R11, <#[R30 + 228]> */
		/* 822634FCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000E4) );
		/* 822634FCh case    3:*/		return 0x82263500;
		  /* 82263500h */ case    4:  		/* rlwinm. R11, R11, 31, 31, 31 */
		/* 82263500h case    4:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R11,regs.R11);
		/* 82263500h case    4:*/		return 0x82263504;
		  /* 82263504h */ case    5:  		/* bc 4, CR0_EQ, 56 */
		/* 82263504h case    5:*/		if ( !regs.CR[0].eq ) { return 0x8226353C;  }
		/* 82263504h case    5:*/		return 0x82263508;
		  /* 82263508h */ case    6:  		/* li R4, 0 */
		/* 82263508h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82263508h case    6:*/		return 0x8226350C;
		  /* 8226350Ch */ case    7:  		/* mr R3, R30 */
		/* 8226350Ch case    7:*/		regs.R3 = regs.R30;
		/* 8226350Ch case    7:*/		return 0x82263510;
		  /* 82263510h */ case    8:  		/* bl 15224 */
		/* 82263510h case    8:*/		regs.LR = 0x82263514; return 0x82267088;
		/* 82263510h case    8:*/		return 0x82263514;
		  /* 82263514h */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 82263514h case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82263514h case    9:*/		return 0x82263518;
		  /* 82263518h */ case   10:  		/* bc 12, CR0_LT, 36 */
		/* 82263518h case   10:*/		if ( regs.CR[0].lt ) { return 0x8226353C;  }
		/* 82263518h case   10:*/		return 0x8226351C;
		  /* 8226351Ch */ case   11:  		/* rlwinm R11, R3, 27, 5, 31 */
		/* 8226351Ch case   11:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R3);
		/* 8226351Ch case   11:*/		return 0x82263520;
		  /* 82263520h */ case   12:  		/* rlwinm R10, R3, 0, 27, 31 */
		/* 82263520h case   12:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R3);
		/* 82263520h case   12:*/		return 0x82263524;
		  /* 82263524h */ case   13:  		/* addi R11, R11, 2 */
		/* 82263524h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82263524h case   13:*/		return 0x82263528;
		  /* 82263528h */ case   14:  		/* slw R10, R26, R10 */
		/* 82263528h case   14:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R26,regs.R10);
		/* 82263528h case   14:*/		return 0x8226352C;
		  /* 8226352Ch */ case   15:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8226352Ch case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8226352Ch case   15:*/		return 0x82263530;
		  /* 82263530h */ case   16:  		/* lwzx R9, <#[R11 + R28]> */
		/* 82263530h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 82263530h case   16:*/		return 0x82263534;
		  /* 82263534h */ case   17:  		/* or R10, R10, R9 */
		/* 82263534h case   17:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82263534h case   17:*/		return 0x82263538;
		  /* 82263538h */ case   18:  		/* stwx R10, <#[R11 + R28]> */
		/* 82263538h case   18:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 82263538h case   18:*/		return 0x8226353C;
	}
	return 0x8226353C;
} // Block from 822634F0h-8226353Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 8226353Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226353C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226353C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226353C);
		  /* 8226353Ch */ case    0:  		/* addi R1, R1, 144 */
		/* 8226353Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8226353Ch case    0:*/		return 0x82263540;
		  /* 82263540h */ case    1:  		/* b -1909408 */
		/* 82263540h case    1:*/		return 0x820912A0;
		/* 82263540h case    1:*/		return 0x82263544;
		  /* 82263544h */ case    2:  		/* nop */
		/* 82263544h case    2:*/		cpu::op::nop();
		/* 82263544h case    2:*/		return 0x82263548;
	}
	return 0x82263548;
} // Block from 8226353Ch-82263548h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82263548h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263548( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263548) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263548);
		  /* 82263548h */ case    0:  		/* lwz R10, <#[R3 + 176]> */
		/* 82263548h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x000000B0) );
		/* 82263548h case    0:*/		return 0x8226354C;
		  /* 8226354Ch */ case    1:  		/* li R11, 0 */
		/* 8226354Ch case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8226354Ch case    1:*/		return 0x82263550;
		  /* 82263550h */ case    2:  		/* lwz R9, <#[R10]> */
		/* 82263550h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82263550h case    2:*/		return 0x82263554;
		  /* 82263554h */ case    3:  		/* cmplwi CR6, R9, 0 */
		/* 82263554h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82263554h case    3:*/		return 0x82263558;
		  /* 82263558h */ case    4:  		/* bclr 4, CR6_GT */
		/* 82263558h case    4:*/		if ( !regs.CR[6].gt ) { return (uint32)regs.LR; }
		/* 82263558h case    4:*/		return 0x8226355C;
	}
	return 0x8226355C;
} // Block from 82263548h-8226355Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8226355Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226355C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226355C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226355C);
		  /* 8226355Ch */ case    0:  		/* addi R9, R10, 4 */
		/* 8226355Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 8226355Ch case    0:*/		return 0x82263560;
		  /* 82263560h */ case    1:  		/* li R8, 0 */
		/* 82263560h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82263560h case    1:*/		return 0x82263564;
		  /* 82263564h */ case    2:  		/* addi R11, R11, 1 */
		/* 82263564h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82263564h case    2:*/		return 0x82263568;
		  /* 82263568h */ case    3:  		/* stwu R8, <#[R9 + 4]> */
		/* 82263568h case    3:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 82263568h case    3:*/		return 0x8226356C;
		  /* 8226356Ch */ case    4:  		/* lwz R8, <#[R10]> */
		/* 8226356Ch case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 8226356Ch case    4:*/		return 0x82263570;
		  /* 82263570h */ case    5:  		/* cmplw CR6, R11, R8 */
		/* 82263570h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 82263570h case    5:*/		return 0x82263574;
		  /* 82263574h */ case    6:  		/* bc 12, CR6_LT, -20 */
		/* 82263574h case    6:*/		if ( regs.CR[6].lt ) { return 0x82263560;  }
		/* 82263574h case    6:*/		return 0x82263578;
		  /* 82263578h */ case    7:  		/* bclr 20, CR0_LT */
		/* 82263578h case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82263578h case    7:*/		return 0x8226357C;
	}
	return 0x8226357C;
} // Block from 8226355Ch-8226357Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8226357Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226357C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226357C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226357C);
		  /* 8226357Ch */ case    0:  		/* nop */
		/* 8226357Ch case    0:*/		cpu::op::nop();
		/* 8226357Ch case    0:*/		return 0x82263580;
	}
	return 0x82263580;
} // Block from 8226357Ch-82263580h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82263580h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263580( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263580) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263580);
		  /* 82263580h */ case    0:  		/* mfspr R12, LR */
		/* 82263580h case    0:*/		regs.R12 = regs.LR;
		/* 82263580h case    0:*/		return 0x82263584;
		  /* 82263584h */ case    1:  		/* bl -1909552 */
		/* 82263584h case    1:*/		regs.LR = 0x82263588; return 0x82091254;
		/* 82263584h case    1:*/		return 0x82263588;
		  /* 82263588h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82263588h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82263588h case    2:*/		return 0x8226358C;
		  /* 8226358Ch */ case    3:  		/* mr R31, R3 */
		/* 8226358Ch case    3:*/		regs.R31 = regs.R3;
		/* 8226358Ch case    3:*/		return 0x82263590;
		  /* 82263590h */ case    4:  		/* bl -170960 */
		/* 82263590h case    4:*/		regs.LR = 0x82263594; return 0x822399C0;
		/* 82263590h case    4:*/		return 0x82263594;
		  /* 82263594h */ case    5:  		/* addi R27, R31, 128 */
		/* 82263594h case    5:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R31,0x80);
		/* 82263594h case    5:*/		return 0x82263598;
		  /* 82263598h */ case    6:  		/* mr R31, R3 */
		/* 82263598h case    6:*/		regs.R31 = regs.R3;
		/* 82263598h case    6:*/		return 0x8226359C;
		  /* 8226359Ch */ case    7:  		/* mr R3, R27 */
		/* 8226359Ch case    7:*/		regs.R3 = regs.R27;
		/* 8226359Ch case    7:*/		return 0x822635A0;
		  /* 822635A0h */ case    8:  		/* li R28, 1 */
		/* 822635A0h case    8:*/		cpu::op::li<0>(regs,&regs.R28,0x1);
		/* 822635A0h case    8:*/		return 0x822635A4;
		  /* 822635A4h */ case    9:  		/* bl -64836 */
		/* 822635A4h case    9:*/		regs.LR = 0x822635A8; return 0x82253860;
		/* 822635A4h case    9:*/		return 0x822635A8;
		  /* 822635A8h */ case   10:  		/* cmpwi CR6, R3, 1 */
		/* 822635A8h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 822635A8h case   10:*/		return 0x822635AC;
		  /* 822635ACh */ case   11:  		/* bc 12, CR6_LT, 124 */
		/* 822635ACh case   11:*/		if ( regs.CR[6].lt ) { return 0x82263628;  }
		/* 822635ACh case   11:*/		return 0x822635B0;
		  /* 822635B0h */ case   12:  		/* addi R30, R31, 4 */
		/* 822635B0h case   12:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x4);
		/* 822635B0h case   12:*/		return 0x822635B4;
		  /* 822635B4h */ case   13:  		/* li R29, 0 */
		/* 822635B4h case   13:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 822635B4h case   13:*/		return 0x822635B8;
		  /* 822635B8h */ case   14:  		/* lwz R31, <#[R30]> */
		/* 822635B8h case   14:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000000) );
		/* 822635B8h case   14:*/		return 0x822635BC;
		  /* 822635BCh */ case   15:  		/* lwz R11, <#[R31 + 108]> */
		/* 822635BCh case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000006C) );
		/* 822635BCh case   15:*/		return 0x822635C0;
		  /* 822635C0h */ case   16:  		/* cmplwi CR6, R11, 0 */
		/* 822635C0h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822635C0h case   16:*/		return 0x822635C4;
		  /* 822635C4h */ case   17:  		/* bc 12, CR6_EQ, 16 */
		/* 822635C4h case   17:*/		if ( regs.CR[6].eq ) { return 0x822635D4;  }
		/* 822635C4h case   17:*/		return 0x822635C8;
		  /* 822635C8h */ case   18:  		/* addi R4, R11, -4 */
		/* 822635C8h case   18:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFC);
		/* 822635C8h case   18:*/		return 0x822635CC;
		  /* 822635CCh */ case   19:  		/* lwz R3, <#[R11 - 4]> */
		/* 822635CCh case   19:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 822635CCh case   19:*/		return 0x822635D0;
		  /* 822635D0h */ case   20:  		/* bl -290704 */
		/* 822635D0h case   20:*/		regs.LR = 0x822635D4; return 0x8221C640;
		/* 822635D0h case   20:*/		return 0x822635D4;
	}
	return 0x822635D4;
} // Block from 82263580h-822635D4h (21 instructions)

//////////////////////////////////////////////////////
// Block at 822635D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822635D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822635D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822635D4);
		  /* 822635D4h */ case    0:  		/* lwz R11, <#[R31 + 100]> */
		/* 822635D4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000064) );
		/* 822635D4h case    0:*/		return 0x822635D8;
		  /* 822635D8h */ case    1:  		/* stw R29, <#[R31 + 108]> */
		/* 822635D8h case    1:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x0000006C) );
		/* 822635D8h case    1:*/		return 0x822635DC;
		  /* 822635DCh */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 822635DCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822635DCh case    2:*/		return 0x822635E0;
		  /* 822635E0h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 822635E0h case    3:*/		if ( regs.CR[6].eq ) { return 0x822635F0;  }
		/* 822635E0h case    3:*/		return 0x822635E4;
		  /* 822635E4h */ case    4:  		/* addi R4, R11, -4 */
		/* 822635E4h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFC);
		/* 822635E4h case    4:*/		return 0x822635E8;
		  /* 822635E8h */ case    5:  		/* lwz R3, <#[R11 - 4]> */
		/* 822635E8h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 822635E8h case    5:*/		return 0x822635EC;
		  /* 822635ECh */ case    6:  		/* bl -290732 */
		/* 822635ECh case    6:*/		regs.LR = 0x822635F0; return 0x8221C640;
		/* 822635ECh case    6:*/		return 0x822635F0;
	}
	return 0x822635F0;
} // Block from 822635D4h-822635F0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 822635F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822635F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822635F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822635F0);
		  /* 822635F0h */ case    0:  		/* lwz R11, <#[R31 + 104]> */
		/* 822635F0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000068) );
		/* 822635F0h case    0:*/		return 0x822635F4;
		  /* 822635F4h */ case    1:  		/* stw R29, <#[R31 + 100]> */
		/* 822635F4h case    1:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000064) );
		/* 822635F4h case    1:*/		return 0x822635F8;
		  /* 822635F8h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 822635F8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822635F8h case    2:*/		return 0x822635FC;
		  /* 822635FCh */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 822635FCh case    3:*/		if ( regs.CR[6].eq ) { return 0x8226360C;  }
		/* 822635FCh case    3:*/		return 0x82263600;
		  /* 82263600h */ case    4:  		/* addi R4, R11, -4 */
		/* 82263600h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFC);
		/* 82263600h case    4:*/		return 0x82263604;
		  /* 82263604h */ case    5:  		/* lwz R3, <#[R11 - 4]> */
		/* 82263604h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 82263604h case    5:*/		return 0x82263608;
		  /* 82263608h */ case    6:  		/* bl -290760 */
		/* 82263608h case    6:*/		regs.LR = 0x8226360C; return 0x8221C640;
		/* 82263608h case    6:*/		return 0x8226360C;
	}
	return 0x8226360C;
} // Block from 822635F0h-8226360Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8226360Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226360C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226360C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226360C);
		  /* 8226360Ch */ case    0:  		/* stw R29, <#[R31 + 104]> */
		/* 8226360Ch case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000068) );
		/* 8226360Ch case    0:*/		return 0x82263610;
		  /* 82263610h */ case    1:  		/* mr R3, R27 */
		/* 82263610h case    1:*/		regs.R3 = regs.R27;
		/* 82263610h case    1:*/		return 0x82263614;
		  /* 82263614h */ case    2:  		/* addi R28, R28, 1 */
		/* 82263614h case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 82263614h case    2:*/		return 0x82263618;
		  /* 82263618h */ case    3:  		/* addi R30, R30, 4 */
		/* 82263618h case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 82263618h case    3:*/		return 0x8226361C;
		  /* 8226361Ch */ case    4:  		/* bl -64956 */
		/* 8226361Ch case    4:*/		regs.LR = 0x82263620; return 0x82253860;
		/* 8226361Ch case    4:*/		return 0x82263620;
		  /* 82263620h */ case    5:  		/* cmpw CR6, R28, R3 */
		/* 82263620h case    5:*/		cpu::op::cmpw<6>(regs,regs.R28,regs.R3);
		/* 82263620h case    5:*/		return 0x82263624;
		  /* 82263624h */ case    6:  		/* bc 4, CR6_GT, -108 */
		/* 82263624h case    6:*/		if ( !regs.CR[6].gt ) { return 0x822635B8;  }
		/* 82263624h case    6:*/		return 0x82263628;
	}
	return 0x82263628;
} // Block from 8226360Ch-82263628h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82263628h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263628( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263628) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263628);
		  /* 82263628h */ case    0:  		/* addi R1, R1, 128 */
		/* 82263628h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82263628h case    0:*/		return 0x8226362C;
		  /* 8226362Ch */ case    1:  		/* b -1909640 */
		/* 8226362Ch case    1:*/		return 0x820912A4;
		/* 8226362Ch case    1:*/		return 0x82263630;
	}
	return 0x82263630;
} // Block from 82263628h-82263630h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82263630h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263630( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263630) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263630);
		  /* 82263630h */ case    0:  		/* mfspr R12, LR */
		/* 82263630h case    0:*/		regs.R12 = regs.LR;
		/* 82263630h case    0:*/		return 0x82263634;
		  /* 82263634h */ case    1:  		/* bl -1909724 */
		/* 82263634h case    1:*/		regs.LR = 0x82263638; return 0x82091258;
		/* 82263634h case    1:*/		return 0x82263638;
		  /* 82263638h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82263638h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82263638h case    2:*/		return 0x8226363C;
		  /* 8226363Ch */ case    3:  		/* lwz R11, <#[R3 + 12]> */
		/* 8226363Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 8226363Ch case    3:*/		return 0x82263640;
		  /* 82263640h */ case    4:  		/* mr R29, R3 */
		/* 82263640h case    4:*/		regs.R29 = regs.R3;
		/* 82263640h case    4:*/		return 0x82263644;
		  /* 82263644h */ case    5:  		/* li R3, 1024 */
		/* 82263644h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x400);
		/* 82263644h case    5:*/		return 0x82263648;
		  /* 82263648h */ case    6:  		/* lwz R4, <#[R11 + 1456]> */
		/* 82263648h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 82263648h case    6:*/		return 0x8226364C;
		  /* 8226364Ch */ case    7:  		/* bl -183564 */
		/* 8226364Ch case    7:*/		regs.LR = 0x82263650; return 0x82236940;
		/* 8226364Ch case    7:*/		return 0x82263650;
		  /* 82263650h */ case    8:  		/* lwz R28, <#[R29 + 136]> */
		/* 82263650h case    8:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R29 + 0x00000088) );
		/* 82263650h case    8:*/		return 0x82263654;
		  /* 82263654h */ case    9:  		/* mr R30, R3 */
		/* 82263654h case    9:*/		regs.R30 = regs.R3;
		/* 82263654h case    9:*/		return 0x82263658;
		  /* 82263658h */ case   10:  		/* b 104 */
		/* 82263658h case   10:*/		return 0x822636C0;
		/* 82263658h case   10:*/		return 0x8226365C;
		  /* 8226365Ch */ case   11:  		/* lwz R10, <#[R30]> */
		/* 8226365Ch case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 8226365Ch case   11:*/		return 0x82263660;
		  /* 82263660h */ case   12:  		/* li R11, 0 */
		/* 82263660h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82263660h case   12:*/		return 0x82263664;
		  /* 82263664h */ case   13:  		/* cmplwi CR6, R10, 0 */
		/* 82263664h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82263664h case   13:*/		return 0x82263668;
		  /* 82263668h */ case   14:  		/* bc 4, CR6_GT, 32 */
		/* 82263668h case   14:*/		if ( !regs.CR[6].gt ) { return 0x82263688;  }
		/* 82263668h case   14:*/		return 0x8226366C;
		  /* 8226366Ch */ case   15:  		/* addi R10, R30, 4 */
		/* 8226366Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0x4);
		/* 8226366Ch case   15:*/		return 0x82263670;
		  /* 82263670h */ case   16:  		/* li R9, 0 */
		/* 82263670h case   16:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82263670h case   16:*/		return 0x82263674;
		  /* 82263674h */ case   17:  		/* addi R11, R11, 1 */
		/* 82263674h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82263674h case   17:*/		return 0x82263678;
		  /* 82263678h */ case   18:  		/* stwu R9, <#[R10 + 4]> */
		/* 82263678h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 82263678h case   18:*/		return 0x8226367C;
		  /* 8226367Ch */ case   19:  		/* lwz R9, <#[R30]> */
		/* 8226367Ch case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000000) );
		/* 8226367Ch case   19:*/		return 0x82263680;
		  /* 82263680h */ case   20:  		/* cmplw CR6, R11, R9 */
		/* 82263680h case   20:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82263680h case   20:*/		return 0x82263684;
		  /* 82263684h */ case   21:  		/* bc 12, CR6_LT, -20 */
		/* 82263684h case   21:*/		if ( regs.CR[6].lt ) { return 0x82263670;  }
		/* 82263684h case   21:*/		return 0x82263688;
	}
	return 0x82263688;
} // Block from 82263630h-82263688h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82263688h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263688( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263688) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263688);
		  /* 82263688h */ case    0:  		/* lwz R31, <#[R28 + 28]> */
		/* 82263688h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R28 + 0x0000001C) );
		/* 82263688h case    0:*/		return 0x8226368C;
		  /* 8226368Ch */ case    1:  		/* b 36 */
		/* 8226368Ch case    1:*/		return 0x822636B0;
		/* 8226368Ch case    1:*/		return 0x82263690;
		  /* 82263690h */ case    2:  		/* lwz R11, <#[R31 + 228]> */
		/* 82263690h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 82263690h case    2:*/		return 0x82263694;
		  /* 82263694h */ case    3:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 82263694h case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 82263694h case    3:*/		return 0x82263698;
		  /* 82263698h */ case    4:  		/* bc 12, CR0_EQ, 20 */
		/* 82263698h case    4:*/		if ( regs.CR[0].eq ) { return 0x822636AC;  }
		/* 82263698h case    4:*/		return 0x8226369C;
		  /* 8226369Ch */ case    5:  		/* mr R5, R30 */
		/* 8226369Ch case    5:*/		regs.R5 = regs.R30;
		/* 8226369Ch case    5:*/		return 0x822636A0;
		  /* 822636A0h */ case    6:  		/* mr R4, R31 */
		/* 822636A0h case    6:*/		regs.R4 = regs.R31;
		/* 822636A0h case    6:*/		return 0x822636A4;
		  /* 822636A4h */ case    7:  		/* mr R3, R29 */
		/* 822636A4h case    7:*/		regs.R3 = regs.R29;
		/* 822636A4h case    7:*/		return 0x822636A8;
		  /* 822636A8h */ case    8:  		/* bl -600 */
		/* 822636A8h case    8:*/		regs.LR = 0x822636AC; return 0x82263450;
		/* 822636A8h case    8:*/		return 0x822636AC;
	}
	return 0x822636AC;
} // Block from 82263688h-822636ACh (9 instructions)

//////////////////////////////////////////////////////
// Block at 822636ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822636AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822636AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822636AC);
		  /* 822636ACh */ case    0:  		/* lwz R31, <#[R31 + 8]> */
		/* 822636ACh case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 822636ACh case    0:*/		return 0x822636B0;
	}
	return 0x822636B0;
} // Block from 822636ACh-822636B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822636B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822636B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822636B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822636B0);
		  /* 822636B0h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 822636B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 822636B0h case    0:*/		return 0x822636B4;
		  /* 822636B4h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 822636B4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 822636B4h case    1:*/		return 0x822636B8;
		  /* 822636B8h */ case    2:  		/* bc 4, CR6_EQ, -40 */
		/* 822636B8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82263690;  }
		/* 822636B8h case    2:*/		return 0x822636BC;
		  /* 822636BCh */ case    3:  		/* lwz R28, <#[R28 + 8]> */
		/* 822636BCh case    3:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R28 + 0x00000008) );
		/* 822636BCh case    3:*/		return 0x822636C0;
	}
	return 0x822636C0;
} // Block from 822636B0h-822636C0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822636C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822636C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822636C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822636C0);
		  /* 822636C0h */ case    0:  		/* lwz R11, <#[R28 + 8]> */
		/* 822636C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 822636C0h case    0:*/		return 0x822636C4;
		  /* 822636C4h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 822636C4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 822636C4h case    1:*/		return 0x822636C8;
		  /* 822636C8h */ case    2:  		/* bc 4, CR6_EQ, -108 */
		/* 822636C8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8226365C;  }
		/* 822636C8h case    2:*/		return 0x822636CC;
		  /* 822636CCh */ case    3:  		/* addi R1, R1, 128 */
		/* 822636CCh case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 822636CCh case    3:*/		return 0x822636D0;
		  /* 822636D0h */ case    4:  		/* b -1909800 */
		/* 822636D0h case    4:*/		return 0x820912A8;
		/* 822636D0h case    4:*/		return 0x822636D4;
		  /* 822636D4h */ case    5:  		/* nop */
		/* 822636D4h case    5:*/		cpu::op::nop();
		/* 822636D4h case    5:*/		return 0x822636D8;
	}
	return 0x822636D8;
} // Block from 822636C0h-822636D8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822636D8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822636D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822636D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822636D8);
		  /* 822636D8h */ case    0:  		/* mfspr R12, LR */
		/* 822636D8h case    0:*/		regs.R12 = regs.LR;
		/* 822636D8h case    0:*/		return 0x822636DC;
		  /* 822636DCh */ case    1:  		/* bl -1909932 */
		/* 822636DCh case    1:*/		regs.LR = 0x822636E0; return 0x82091230;
		/* 822636DCh case    1:*/		return 0x822636E0;
		  /* 822636E0h */ case    2:  		/* stwu R1, <#[R1 - 208]> */
		/* 822636E0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 822636E0h case    2:*/		return 0x822636E4;
		  /* 822636E4h */ case    3:  		/* lwz R11, <#[R3 + 12]> */
		/* 822636E4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 822636E4h case    3:*/		return 0x822636E8;
		  /* 822636E8h */ case    4:  		/* mr R27, R3 */
		/* 822636E8h case    4:*/		regs.R27 = regs.R3;
		/* 822636E8h case    4:*/		return 0x822636EC;
		  /* 822636ECh */ case    5:  		/* li R3, 1024 */
		/* 822636ECh case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x400);
		/* 822636ECh case    5:*/		return 0x822636F0;
		  /* 822636F0h */ case    6:  		/* mr R24, R4 */
		/* 822636F0h case    6:*/		regs.R24 = regs.R4;
		/* 822636F0h case    6:*/		return 0x822636F4;
		  /* 822636F4h */ case    7:  		/* lwz R4, <#[R11 + 1456]> */
		/* 822636F4h case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 822636F4h case    7:*/		return 0x822636F8;
		  /* 822636F8h */ case    8:  		/* bl -183736 */
		/* 822636F8h case    8:*/		regs.LR = 0x822636FC; return 0x82236940;
		/* 822636F8h case    8:*/		return 0x822636FC;
		  /* 822636FCh */ case    9:  		/* stw R3, <#[R27 + 180]> */
		/* 822636FCh case    9:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R27 + 0x000000B4) );
		/* 822636FCh case    9:*/		return 0x82263700;
		  /* 82263700h */ case   10:  		/* mr R3, R27 */
		/* 82263700h case   10:*/		regs.R3 = regs.R27;
		/* 82263700h case   10:*/		return 0x82263704;
		  /* 82263704h */ case   11:  		/* bl -171500 */
		/* 82263704h case   11:*/		regs.LR = 0x82263708; return 0x82239918;
		/* 82263704h case   11:*/		return 0x82263708;
		  /* 82263708h */ case   12:  		/* addi R18, R27, 128 */
		/* 82263708h case   12:*/		cpu::op::addi<0>(regs,&regs.R18,regs.R27,0x80);
		/* 82263708h case   12:*/		return 0x8226370C;
		  /* 8226370Ch */ case   13:  		/* mr R31, R3 */
		/* 8226370Ch case   13:*/		regs.R31 = regs.R3;
		/* 8226370Ch case   13:*/		return 0x82263710;
		  /* 82263710h */ case   14:  		/* li R19, 1 */
		/* 82263710h case   14:*/		cpu::op::li<0>(regs,&regs.R19,0x1);
		/* 82263710h case   14:*/		return 0x82263714;
		  /* 82263714h */ case   15:  		/* mr R3, R18 */
		/* 82263714h case   15:*/		regs.R3 = regs.R18;
		/* 82263714h case   15:*/		return 0x82263718;
		  /* 82263718h */ case   16:  		/* mr R21, R19 */
		/* 82263718h case   16:*/		regs.R21 = regs.R19;
		/* 82263718h case   16:*/		return 0x8226371C;
		  /* 8226371Ch */ case   17:  		/* bl -65212 */
		/* 8226371Ch case   17:*/		regs.LR = 0x82263720; return 0x82253860;
		/* 8226371Ch case   17:*/		return 0x82263720;
		  /* 82263720h */ case   18:  		/* cmpwi CR6, R3, 1 */
		/* 82263720h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 82263720h case   18:*/		return 0x82263724;
		  /* 82263724h */ case   19:  		/* bc 12, CR6_LT, 648 */
		/* 82263724h case   19:*/		if ( regs.CR[6].lt ) { return 0x822639AC;  }
		/* 82263724h case   19:*/		return 0x82263728;
		  /* 82263728h */ case   20:  		/* lis R11, -32251 */
		/* 82263728h case   20:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82263728h case   20:*/		return 0x8226372C;
		  /* 8226372Ch */ case   21:  		/* addi R22, R31, 4 */
		/* 8226372Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R31,0x4);
		/* 8226372Ch case   21:*/		return 0x82263730;
		  /* 82263730h */ case   22:  		/* addi R20, R11, -19064 */
		/* 82263730h case   22:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R11,0xFFFFB588);
		/* 82263730h case   22:*/		return 0x82263734;
		  /* 82263734h */ case   23:  		/* lwz R11, <#[R27 + 12]> */
		/* 82263734h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000000C) );
		/* 82263734h case   23:*/		return 0x82263738;
		  /* 82263738h */ case   24:  		/* mr R3, R24 */
		/* 82263738h case   24:*/		regs.R3 = regs.R24;
		/* 82263738h case   24:*/		return 0x8226373C;
		  /* 8226373Ch */ case   25:  		/* lwz R31, <#[R22]> */
		/* 8226373Ch case   25:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R22 + 0x00000000) );
		/* 8226373Ch case   25:*/		return 0x82263740;
		  /* 82263740h */ case   26:  		/* lwz R4, <#[R11 + 1456]> */
		/* 82263740h case   26:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 82263740h case   26:*/		return 0x82263744;
		  /* 82263744h */ case   27:  		/* bl -183812 */
		/* 82263744h case   27:*/		regs.LR = 0x82263748; return 0x82236940;
		/* 82263744h case   27:*/		return 0x82263748;
		  /* 82263748h */ case   28:  		/* stw R3, <#[R31 + 104]> */
		/* 82263748h case   28:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000068) );
		/* 82263748h case   28:*/		return 0x8226374C;
		  /* 8226374Ch */ case   29:  		/* mr R3, R24 */
		/* 8226374Ch case   29:*/		regs.R3 = regs.R24;
		/* 8226374Ch case   29:*/		return 0x82263750;
		  /* 82263750h */ case   30:  		/* lwz R11, <#[R27 + 12]> */
		/* 82263750h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000000C) );
		/* 82263750h case   30:*/		return 0x82263754;
		  /* 82263754h */ case   31:  		/* lwz R4, <#[R11 + 1456]> */
		/* 82263754h case   31:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 82263754h case   31:*/		return 0x82263758;
		  /* 82263758h */ case   32:  		/* bl -183832 */
		/* 82263758h case   32:*/		regs.LR = 0x8226375C; return 0x82236940;
		/* 82263758h case   32:*/		return 0x8226375C;
		  /* 8226375Ch */ case   33:  		/* stw R3, <#[R31 + 100]> */
		/* 8226375Ch case   33:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000064) );
		/* 8226375Ch case   33:*/		return 0x82263760;
		  /* 82263760h */ case   34:  		/* mr R3, R24 */
		/* 82263760h case   34:*/		regs.R3 = regs.R24;
		/* 82263760h case   34:*/		return 0x82263764;
		  /* 82263764h */ case   35:  		/* lwz R11, <#[R27 + 12]> */
		/* 82263764h case   35:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000000C) );
		/* 82263764h case   35:*/		return 0x82263768;
		  /* 82263768h */ case   36:  		/* lwz R4, <#[R11 + 1456]> */
		/* 82263768h case   36:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 82263768h case   36:*/		return 0x8226376C;
		  /* 8226376Ch */ case   37:  		/* bl -183852 */
		/* 8226376Ch case   37:*/		regs.LR = 0x82263770; return 0x82236940;
		/* 8226376Ch case   37:*/		return 0x82263770;
		  /* 82263770h */ case   38:  		/* lwz R26, <#[R31 + 28]> */
		/* 82263770h case   38:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R31 + 0x0000001C) );
		/* 82263770h case   38:*/		return 0x82263774;
		  /* 82263774h */ case   39:  		/* lwz R23, <#[R31 + 100]> */
		/* 82263774h case   39:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R31 + 0x00000064) );
		/* 82263774h case   39:*/		return 0x82263778;
		  /* 82263778h */ case   40:  		/* mr R25, R3 */
		/* 82263778h case   40:*/		regs.R25 = regs.R3;
		/* 82263778h case   40:*/		return 0x8226377C;
		  /* 8226377Ch */ case   41:  		/* mr R11, R19 */
		/* 8226377Ch case   41:*/		regs.R11 = regs.R19;
		/* 8226377Ch case   41:*/		return 0x82263780;
		  /* 82263780h */ case   42:  		/* stw R3, <#[R31 + 108]> */
		/* 82263780h case   42:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000006C) );
		/* 82263780h case   42:*/		return 0x82263784;
		  /* 82263784h */ case   43:  		/* b 516 */
		/* 82263784h case   43:*/		return 0x82263988;
		/* 82263784h case   43:*/		return 0x82263788;
		  /* 82263788h */ case   44:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82263788h case   44:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82263788h case   44:*/		return 0x8226378C;
		  /* 8226378Ch */ case   45:  		/* bc 12, CR0_EQ, 492 */
		/* 8226378Ch case   45:*/		if ( regs.CR[0].eq ) { return 0x82263978;  }
		/* 8226378Ch case   45:*/		return 0x82263790;
		  /* 82263790h */ case   46:  		/* lwz R11, <#[R26]> */
		/* 82263790h case   46:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 82263790h case   46:*/		return 0x82263794;
		  /* 82263794h */ case   47:  		/* mr R3, R26 */
		/* 82263794h case   47:*/		regs.R3 = regs.R26;
		/* 82263794h case   47:*/		return 0x82263798;
		  /* 82263798h */ case   48:  		/* lwz R11, <#[R11 + 44]> */
		/* 82263798h case   48:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000002C) );
		/* 82263798h case   48:*/		return 0x8226379C;
		  /* 8226379Ch */ case   49:  		/* mtspr CTR, R11 */
		/* 8226379Ch case   49:*/		regs.CTR = regs.R11;
		/* 8226379Ch case   49:*/		return 0x822637A0;
		  /* 822637A0h */ case   50:  		/* bcctrl 20, CR0_LT */
		/* 822637A0h case   50:*/		if ( 1 ) { regs.LR = 0x822637A4; return (uint32)regs.CTR; }
		/* 822637A0h case   50:*/		return 0x822637A4;
		  /* 822637A4h */ case   51:  		/* cmplwi CR0, R3, 0 */
		/* 822637A4h case   51:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 822637A4h case   51:*/		return 0x822637A8;
		  /* 822637A8h */ case   52:  		/* bc 4, CR0_EQ, 464 */
		/* 822637A8h case   52:*/		if ( !regs.CR[0].eq ) { return 0x82263978;  }
		/* 822637A8h case   52:*/		return 0x822637AC;
		  /* 822637ACh */ case   53:  		/* li R11, 0 */
		/* 822637ACh case   53:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822637ACh case   53:*/		return 0x822637B0;
		  /* 822637B0h */ case   54:  		/* mr R31, R26 */
		/* 822637B0h case   54:*/		regs.R31 = regs.R26;
		/* 822637B0h case   54:*/		return 0x822637B4;
		  /* 822637B4h */ case   55:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 822637B4h case   55:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 822637B4h case   55:*/		return 0x822637B8;
		  /* 822637B8h */ case   56:  		/* bc 4, CR0_EQ, 300 */
		/* 822637B8h case   56:*/		if ( !regs.CR[0].eq ) { return 0x822638E4;  }
		/* 822637B8h case   56:*/		return 0x822637BC;
		  /* 822637BCh */ case   57:  		/* lwz R11, <#[R31 + 228]> */
		/* 822637BCh case   57:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 822637BCh case   57:*/		return 0x822637C0;
		  /* 822637C0h */ case   58:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 822637C0h case   58:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 822637C0h case   58:*/		return 0x822637C4;
		  /* 822637C4h */ case   59:  		/* bc 12, CR0_EQ, 264 */
		/* 822637C4h case   59:*/		if ( regs.CR[0].eq ) { return 0x822638CC;  }
		/* 822637C4h case   59:*/		return 0x822637C8;
		  /* 822637C8h */ case   60:  		/* lwz R11, <#[R31 + 20]> */
		/* 822637C8h case   60:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 822637C8h case   60:*/		return 0x822637CC;
		  /* 822637CCh */ case   61:  		/* mr R29, R19 */
		/* 822637CCh case   61:*/		regs.R29 = regs.R19;
		/* 822637CCh case   61:*/		return 0x822637D0;
		  /* 822637D0h */ case   62:  		/* cmpwi CR6, R11, 1 */
		/* 822637D0h case   62:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 822637D0h case   62:*/		return 0x822637D4;
		  /* 822637D4h */ case   63:  		/* bc 12, CR6_LT, 172 */
		/* 822637D4h case   63:*/		if ( regs.CR[6].lt ) { return 0x82263880;  }
		/* 822637D4h case   63:*/		return 0x822637D8;
		  /* 822637D8h */ case   64:  		/* addi R28, R31, 236 */
		/* 822637D8h case   64:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R31,0xEC);
		/* 822637D8h case   64:*/		return 0x822637DC;
		  /* 822637DCh */ case   65:  		/* lwz R30, <#[R28]> */
		/* 822637DCh case   65:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R28 + 0x00000000) );
		/* 822637DCh case   65:*/		return 0x822637E0;
		  /* 822637E0h */ case   66:  		/* lwz R11, <#[R30 + 16]> */
		/* 822637E0h case   66:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000010) );
		/* 822637E0h case   66:*/		return 0x822637E4;
		  /* 822637E4h */ case   67:  		/* cmpwi CR6, R11, 0 */
		/* 822637E4h case   67:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 822637E4h case   67:*/		return 0x822637E8;
		  /* 822637E8h */ case   68:  		/* bc 12, CR6_EQ, 44 */
		/* 822637E8h case   68:*/		if ( regs.CR[6].eq ) { return 0x82263814;  }
		/* 822637E8h case   68:*/		return 0x822637EC;
		  /* 822637ECh */ case   69:  		/* lwz R11, <#[R30 + 228]> */
		/* 822637ECh case   69:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x000000E4) );
		/* 822637ECh case   69:*/		return 0x822637F0;
		  /* 822637F0h */ case   70:  		/* rlwinm. R11, R11, 31, 31, 31 */
		/* 822637F0h case   70:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R11,regs.R11);
		/* 822637F0h case   70:*/		return 0x822637F4;
		  /* 822637F4h */ case   71:  		/* bc 4, CR0_EQ, 32 */
		/* 822637F4h case   71:*/		if ( !regs.CR[0].eq ) { return 0x82263814;  }
		/* 822637F4h case   71:*/		return 0x822637F8;
		  /* 822637F8h */ case   72:  		/* lwz R11, <#[R30 + 80]> */
		/* 822637F8h case   72:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000050) );
		/* 822637F8h case   72:*/		return 0x822637FC;
		  /* 822637FCh */ case   73:  		/* addi R10, R20, 4 */
		/* 822637FCh case   73:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R20,0x4);
		/* 822637FCh case   73:*/		return 0x82263800;
		  /* 82263800h */ case   74:  		/* mulli R11, R11, 12 */
		/* 82263800h case   74:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 82263800h case   74:*/		return 0x82263804;
		  /* 82263804h */ case   75:  		/* lbzx R11, <#[R11 + R10]> */
		/* 82263804h case   75:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82263804h case   75:*/		return 0x82263808;
		  /* 82263808h */ case   76:  		/* cmplwi CR0, R11, 0 */
		/* 82263808h case   76:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82263808h case   76:*/		return 0x8226380C;
		  /* 8226380Ch */ case   77:  		/* mr R11, R19 */
		/* 8226380Ch case   77:*/		regs.R11 = regs.R19;
		/* 8226380Ch case   77:*/		return 0x82263810;
		  /* 82263810h */ case   78:  		/* bc 4, CR0_EQ, 8 */
		/* 82263810h case   78:*/		if ( !regs.CR[0].eq ) { return 0x82263818;  }
		/* 82263810h case   78:*/		return 0x82263814;
	}
	return 0x82263814;
} // Block from 822636D8h-82263814h (79 instructions)

//////////////////////////////////////////////////////
// Block at 82263814h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263814( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263814) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263814);
		  /* 82263814h */ case    0:  		/* li R11, 0 */
		/* 82263814h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82263814h case    0:*/		return 0x82263818;
	}
	return 0x82263818;
} // Block from 82263814h-82263818h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82263818h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263818( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263818) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263818);
		  /* 82263818h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82263818h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82263818h case    0:*/		return 0x8226381C;
		  /* 8226381Ch */ case    1:  		/* bc 12, CR0_EQ, 80 */
		/* 8226381Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8226386C;  }
		/* 8226381Ch case    1:*/		return 0x82263820;
		  /* 82263820h */ case    2:  		/* mr R5, R26 */
		/* 82263820h case    2:*/		regs.R5 = regs.R26;
		/* 82263820h case    2:*/		return 0x82263824;
		  /* 82263824h */ case    3:  		/* mr R4, R29 */
		/* 82263824h case    3:*/		regs.R4 = regs.R29;
		/* 82263824h case    3:*/		return 0x82263828;
		  /* 82263828h */ case    4:  		/* mr R3, R31 */
		/* 82263828h case    4:*/		regs.R3 = regs.R31;
		/* 82263828h case    4:*/		return 0x8226382C;
		  /* 8226382Ch */ case    5:  		/* bl -52804 */
		/* 8226382Ch case    5:*/		regs.LR = 0x82263830; return 0x822569E8;
		/* 8226382Ch case    5:*/		return 0x82263830;
		  /* 82263830h */ case    6:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82263830h case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82263830h case    6:*/		return 0x82263834;
		  /* 82263834h */ case    7:  		/* bc 4, CR0_EQ, 56 */
		/* 82263834h case    7:*/		if ( !regs.CR[0].eq ) { return 0x8226386C;  }
		/* 82263834h case    7:*/		return 0x82263838;
		  /* 82263838h */ case    8:  		/* lwz R10, <#[R30 + 56]> */
		/* 82263838h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000038) );
		/* 82263838h case    8:*/		return 0x8226383C;
		  /* 8226383Ch */ case    9:  		/* rlwinm R11, R10, 27, 5, 31 */
		/* 8226383Ch case    9:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R10);
		/* 8226383Ch case    9:*/		return 0x82263840;
		  /* 82263840h */ case   10:  		/* rlwinm R10, R10, 0, 27, 31 */
		/* 82263840h case   10:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R10);
		/* 82263840h case   10:*/		return 0x82263844;
		  /* 82263844h */ case   11:  		/* addi R11, R11, 2 */
		/* 82263844h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82263844h case   11:*/		return 0x82263848;
		  /* 82263848h */ case   12:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82263848h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82263848h case   12:*/		return 0x8226384C;
		  /* 8226384Ch */ case   13:  		/* lwzx R9, <#[R11 + R25]> */
		/* 8226384Ch case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R25 + 0x00000000) );
		/* 8226384Ch case   13:*/		return 0x82263850;
		  /* 82263850h */ case   14:  		/* srw R9, R9, R10 */
		/* 82263850h case   14:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R9,regs.R10);
		/* 82263850h case   14:*/		return 0x82263854;
		  /* 82263854h */ case   15:  		/* rlwinm. R9, R9, 0, 31, 31 */
		/* 82263854h case   15:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R9);
		/* 82263854h case   15:*/		return 0x82263858;
		  /* 82263858h */ case   16:  		/* bc 4, CR0_EQ, 20 */
		/* 82263858h case   16:*/		if ( !regs.CR[0].eq ) { return 0x8226386C;  }
		/* 82263858h case   16:*/		return 0x8226385C;
		  /* 8226385Ch */ case   17:  		/* lwzx R9, <#[R11 + R23]> */
		/* 8226385Ch case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R23 + 0x00000000) );
		/* 8226385Ch case   17:*/		return 0x82263860;
		  /* 82263860h */ case   18:  		/* slw R10, R19, R10 */
		/* 82263860h case   18:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R19,regs.R10);
		/* 82263860h case   18:*/		return 0x82263864;
		  /* 82263864h */ case   19:  		/* or R10, R10, R9 */
		/* 82263864h case   19:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82263864h case   19:*/		return 0x82263868;
		  /* 82263868h */ case   20:  		/* stwx R10, <#[R11 + R23]> */
		/* 82263868h case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R23 + 0x00000000) );
		/* 82263868h case   20:*/		return 0x8226386C;
	}
	return 0x8226386C;
} // Block from 82263818h-8226386Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 8226386Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226386C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226386C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226386C);
		  /* 8226386Ch */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 8226386Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 8226386Ch case    0:*/		return 0x82263870;
		  /* 82263870h */ case    1:  		/* addi R29, R29, 1 */
		/* 82263870h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 82263870h case    1:*/		return 0x82263874;
		  /* 82263874h */ case    2:  		/* addi R28, R28, 4 */
		/* 82263874h case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 82263874h case    2:*/		return 0x82263878;
		  /* 82263878h */ case    3:  		/* cmpw CR6, R29, R11 */
		/* 82263878h case    3:*/		cpu::op::cmpw<6>(regs,regs.R29,regs.R11);
		/* 82263878h case    3:*/		return 0x8226387C;
		  /* 8226387Ch */ case    4:  		/* bc 4, CR6_GT, -160 */
		/* 8226387Ch case    4:*/		if ( !regs.CR[6].gt ) { return 0x822637DC;  }
		/* 8226387Ch case    4:*/		return 0x82263880;
	}
	return 0x82263880;
} // Block from 8226386Ch-82263880h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82263880h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263880( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263880) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263880);
		  /* 82263880h */ case    0:  		/* lwz R11, <#[R31 + 228]> */
		/* 82263880h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 82263880h case    0:*/		return 0x82263884;
		  /* 82263884h */ case    1:  		/* rlwinm. R11, R11, 23, 31, 31 */
		/* 82263884h case    1:*/		cpu::op::rlwinm<1,23,31,31>(regs,&regs.R11,regs.R11);
		/* 82263884h case    1:*/		return 0x82263888;
		  /* 82263888h */ case    2:  		/* bc 12, CR0_EQ, 68 */
		/* 82263888h case    2:*/		if ( regs.CR[0].eq ) { return 0x822638CC;  }
		/* 82263888h case    2:*/		return 0x8226388C;
		  /* 8226388Ch */ case    3:  		/* mr R3, R31 */
		/* 8226388Ch case    3:*/		regs.R3 = regs.R31;
		/* 8226388Ch case    3:*/		return 0x82263890;
		  /* 82263890h */ case    4:  		/* bl -187096 */
		/* 82263890h case    4:*/		regs.LR = 0x82263894; return 0x82235DB8;
		/* 82263890h case    4:*/		return 0x82263894;
		  /* 82263894h */ case    5:  		/* lwz R9, <#[R3 + 56]> */
		/* 82263894h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000038) );
		/* 82263894h case    5:*/		return 0x82263898;
		  /* 82263898h */ case    6:  		/* lwz R11, <#[R27 + 180]> */
		/* 82263898h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x000000B4) );
		/* 82263898h case    6:*/		return 0x8226389C;
		  /* 8226389Ch */ case    7:  		/* rlwinm R10, R9, 27, 5, 31 */
		/* 8226389Ch case    7:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R9);
		/* 8226389Ch case    7:*/		return 0x822638A0;
		  /* 822638A0h */ case    8:  		/* rlwinm R9, R9, 0, 27, 31 */
		/* 822638A0h case    8:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R9);
		/* 822638A0h case    8:*/		return 0x822638A4;
		  /* 822638A4h */ case    9:  		/* addi R10, R10, 2 */
		/* 822638A4h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 822638A4h case    9:*/		return 0x822638A8;
		  /* 822638A8h */ case   10:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 822638A8h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 822638A8h case   10:*/		return 0x822638AC;
		  /* 822638ACh */ case   11:  		/* lwzx R8, <#[R11 + R10]> */
		/* 822638ACh case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 822638ACh case   11:*/		return 0x822638B0;
		  /* 822638B0h */ case   12:  		/* srw R8, R8, R9 */
		/* 822638B0h case   12:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R8,regs.R9);
		/* 822638B0h case   12:*/		return 0x822638B4;
		  /* 822638B4h */ case   13:  		/* rlwinm. R8, R8, 0, 31, 31 */
		/* 822638B4h case   13:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R8,regs.R8);
		/* 822638B4h case   13:*/		return 0x822638B8;
		  /* 822638B8h */ case   14:  		/* bc 4, CR0_EQ, 20 */
		/* 822638B8h case   14:*/		if ( !regs.CR[0].eq ) { return 0x822638CC;  }
		/* 822638B8h case   14:*/		return 0x822638BC;
		  /* 822638BCh */ case   15:  		/* lwzx R8, <#[R10 + R11]> */
		/* 822638BCh case   15:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 822638BCh case   15:*/		return 0x822638C0;
		  /* 822638C0h */ case   16:  		/* slw R9, R19, R9 */
		/* 822638C0h case   16:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R19,regs.R9);
		/* 822638C0h case   16:*/		return 0x822638C4;
		  /* 822638C4h */ case   17:  		/* or R9, R9, R8 */
		/* 822638C4h case   17:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 822638C4h case   17:*/		return 0x822638C8;
		  /* 822638C8h */ case   18:  		/* stwx R9, <#[R10 + R11]> */
		/* 822638C8h case   18:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 822638C8h case   18:*/		return 0x822638CC;
	}
	return 0x822638CC;
} // Block from 82263880h-822638CCh (19 instructions)

//////////////////////////////////////////////////////
// Block at 822638CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822638CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822638CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822638CC);
		  /* 822638CCh */ case    0:  		/* lwz R11, <#[R31 + 228]> */
		/* 822638CCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000E4) );
		/* 822638CCh case    0:*/		return 0x822638D0;
		  /* 822638D0h */ case    1:  		/* lwz R31, <#[R31 + 8]> */
		/* 822638D0h case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 822638D0h case    1:*/		return 0x822638D4;
		  /* 822638D4h */ case    2:  		/* nor R11, R11, R11 */
		/* 822638D4h case    2:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 822638D4h case    2:*/		return 0x822638D8;
		  /* 822638D8h */ case    3:  		/* cmplwi CR6, R31, 0 */
		/* 822638D8h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 822638D8h case    3:*/		return 0x822638DC;
		  /* 822638DCh */ case    4:  		/* rlwinm R11, R11, 30, 31, 31 */
		/* 822638DCh case    4:*/		cpu::op::rlwinm<0,30,31,31>(regs,&regs.R11,regs.R11);
		/* 822638DCh case    4:*/		return 0x822638E0;
		  /* 822638E0h */ case    5:  		/* bc 4, CR6_EQ, -300 */
		/* 822638E0h case    5:*/		if ( !regs.CR[6].eq ) { return 0x822637B4;  }
		/* 822638E0h case    5:*/		return 0x822638E4;
	}
	return 0x822638E4;
} // Block from 822638CCh-822638E4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822638E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822638E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822638E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822638E4);
		  /* 822638E4h */ case    0:  		/* li R10, 0 */
		/* 822638E4h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 822638E4h case    0:*/		return 0x822638E8;
		  /* 822638E8h */ case    1:  		/* mr R11, R26 */
		/* 822638E8h case    1:*/		regs.R11 = regs.R26;
		/* 822638E8h case    1:*/		return 0x822638EC;
		  /* 822638ECh */ case    2:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 822638ECh case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 822638ECh case    2:*/		return 0x822638F0;
		  /* 822638F0h */ case    3:  		/* bc 4, CR0_EQ, 136 */
		/* 822638F0h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82263978;  }
		/* 822638F0h case    3:*/		return 0x822638F4;
		  /* 822638F4h */ case    4:  		/* lwz R10, <#[R11 + 228]> */
		/* 822638F4h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x000000E4) );
		/* 822638F4h case    4:*/		return 0x822638F8;
		  /* 822638F8h */ case    5:  		/* rlwinm. R9, R10, 0, 31, 31 */
		/* 822638F8h case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R10);
		/* 822638F8h case    5:*/		return 0x822638FC;
		  /* 822638FCh */ case    6:  		/* bc 12, CR0_EQ, 100 */
		/* 822638FCh case    6:*/		if ( regs.CR[0].eq ) { return 0x82263960;  }
		/* 822638FCh case    6:*/		return 0x82263900;
		  /* 82263900h */ case    7:  		/* lwz R9, <#[R11 + 16]> */
		/* 82263900h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000010) );
		/* 82263900h case    7:*/		return 0x82263904;
		  /* 82263904h */ case    8:  		/* cmpwi CR6, R9, 0 */
		/* 82263904h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 82263904h case    8:*/		return 0x82263908;
		  /* 82263908h */ case    9:  		/* bc 12, CR6_EQ, 40 */
		/* 82263908h case    9:*/		if ( regs.CR[6].eq ) { return 0x82263930;  }
		/* 82263908h case    9:*/		return 0x8226390C;
		  /* 8226390Ch */ case   10:  		/* rlwinm. R10, R10, 31, 31, 31 */
		/* 8226390Ch case   10:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R10,regs.R10);
		/* 8226390Ch case   10:*/		return 0x82263910;
		  /* 82263910h */ case   11:  		/* bc 4, CR0_EQ, 32 */
		/* 82263910h case   11:*/		if ( !regs.CR[0].eq ) { return 0x82263930;  }
		/* 82263910h case   11:*/		return 0x82263914;
		  /* 82263914h */ case   12:  		/* lwz R10, <#[R11 + 80]> */
		/* 82263914h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000050) );
		/* 82263914h case   12:*/		return 0x82263918;
		  /* 82263918h */ case   13:  		/* addi R9, R20, 4 */
		/* 82263918h case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R20,0x4);
		/* 82263918h case   13:*/		return 0x8226391C;
		  /* 8226391Ch */ case   14:  		/* mulli R10, R10, 12 */
		/* 8226391Ch case   14:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0xC);
		/* 8226391Ch case   14:*/		return 0x82263920;
		  /* 82263920h */ case   15:  		/* lbzx R10, <#[R10 + R9]> */
		/* 82263920h case   15:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82263920h case   15:*/		return 0x82263924;
		  /* 82263924h */ case   16:  		/* cmplwi CR0, R10, 0 */
		/* 82263924h case   16:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 82263924h case   16:*/		return 0x82263928;
		  /* 82263928h */ case   17:  		/* mr R10, R19 */
		/* 82263928h case   17:*/		regs.R10 = regs.R19;
		/* 82263928h case   17:*/		return 0x8226392C;
		  /* 8226392Ch */ case   18:  		/* bc 4, CR0_EQ, 8 */
		/* 8226392Ch case   18:*/		if ( !regs.CR[0].eq ) { return 0x82263934;  }
		/* 8226392Ch case   18:*/		return 0x82263930;
	}
	return 0x82263930;
} // Block from 822638E4h-82263930h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82263930h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263930( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263930) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263930);
		  /* 82263930h */ case    0:  		/* li R10, 0 */
		/* 82263930h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82263930h case    0:*/		return 0x82263934;
	}
	return 0x82263934;
} // Block from 82263930h-82263934h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82263934h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263934( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263934) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263934);
		  /* 82263934h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 82263934h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 82263934h case    0:*/		return 0x82263938;
		  /* 82263938h */ case    1:  		/* bc 12, CR0_EQ, 40 */
		/* 82263938h case    1:*/		if ( regs.CR[0].eq ) { return 0x82263960;  }
		/* 82263938h case    1:*/		return 0x8226393C;
		  /* 8226393Ch */ case    2:  		/* lwz R9, <#[R11 + 56]> */
		/* 8226393Ch case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000038) );
		/* 8226393Ch case    2:*/		return 0x82263940;
		  /* 82263940h */ case    3:  		/* rlwinm R10, R9, 27, 5, 31 */
		/* 82263940h case    3:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R9);
		/* 82263940h case    3:*/		return 0x82263944;
		  /* 82263944h */ case    4:  		/* rlwinm R9, R9, 0, 27, 31 */
		/* 82263944h case    4:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R9);
		/* 82263944h case    4:*/		return 0x82263948;
		  /* 82263948h */ case    5:  		/* addi R10, R10, 2 */
		/* 82263948h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 82263948h case    5:*/		return 0x8226394C;
		  /* 8226394Ch */ case    6:  		/* slw R9, R19, R9 */
		/* 8226394Ch case    6:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R19,regs.R9);
		/* 8226394Ch case    6:*/		return 0x82263950;
		  /* 82263950h */ case    7:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82263950h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82263950h case    7:*/		return 0x82263954;
		  /* 82263954h */ case    8:  		/* lwzx R8, <#[R10 + R25]> */
		/* 82263954h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R25 + 0x00000000) );
		/* 82263954h case    8:*/		return 0x82263958;
		  /* 82263958h */ case    9:  		/* or R9, R9, R8 */
		/* 82263958h case    9:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 82263958h case    9:*/		return 0x8226395C;
		  /* 8226395Ch */ case   10:  		/* stwx R9, <#[R10 + R25]> */
		/* 8226395Ch case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R25 + 0x00000000) );
		/* 8226395Ch case   10:*/		return 0x82263960;
	}
	return 0x82263960;
} // Block from 82263934h-82263960h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82263960h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263960( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263960) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263960);
		  /* 82263960h */ case    0:  		/* lwz R10, <#[R11 + 228]> */
		/* 82263960h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x000000E4) );
		/* 82263960h case    0:*/		return 0x82263964;
		  /* 82263964h */ case    1:  		/* lwz R11, <#[R11 + 8]> */
		/* 82263964h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 82263964h case    1:*/		return 0x82263968;
		  /* 82263968h */ case    2:  		/* nor R10, R10, R10 */
		/* 82263968h case    2:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 82263968h case    2:*/		return 0x8226396C;
		  /* 8226396Ch */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 8226396Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8226396Ch case    3:*/		return 0x82263970;
		  /* 82263970h */ case    4:  		/* rlwinm R10, R10, 30, 31, 31 */
		/* 82263970h case    4:*/		cpu::op::rlwinm<0,30,31,31>(regs,&regs.R10,regs.R10);
		/* 82263970h case    4:*/		return 0x82263974;
		  /* 82263974h */ case    5:  		/* bc 4, CR6_EQ, -136 */
		/* 82263974h case    5:*/		if ( !regs.CR[6].eq ) { return 0x822638EC;  }
		/* 82263974h case    5:*/		return 0x82263978;
	}
	return 0x82263978;
} // Block from 82263960h-82263978h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82263978h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263978( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263978) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263978);
		  /* 82263978h */ case    0:  		/* lwz R11, <#[R26 + 228]> */
		/* 82263978h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x000000E4) );
		/* 82263978h case    0:*/		return 0x8226397C;
		  /* 8226397Ch */ case    1:  		/* lwz R26, <#[R26 + 8]> */
		/* 8226397Ch case    1:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R26 + 0x00000008) );
		/* 8226397Ch case    1:*/		return 0x82263980;
		  /* 82263980h */ case    2:  		/* nor R11, R11, R11 */
		/* 82263980h case    2:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82263980h case    2:*/		return 0x82263984;
		  /* 82263984h */ case    3:  		/* rlwinm R11, R11, 30, 31, 31 */
		/* 82263984h case    3:*/		cpu::op::rlwinm<0,30,31,31>(regs,&regs.R11,regs.R11);
		/* 82263984h case    3:*/		return 0x82263988;
	}
	return 0x82263988;
} // Block from 82263978h-82263988h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82263988h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263988( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263988) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263988);
		  /* 82263988h */ case    0:  		/* lwz R10, <#[R26 + 8]> */
		/* 82263988h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000008) );
		/* 82263988h case    0:*/		return 0x8226398C;
		  /* 8226398Ch */ case    1:  		/* cmpwi CR6, R10, 0 */
		/* 8226398Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 8226398Ch case    1:*/		return 0x82263990;
		  /* 82263990h */ case    2:  		/* bc 4, CR6_EQ, -520 */
		/* 82263990h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82263788;  }
		/* 82263990h case    2:*/		return 0x82263994;
		  /* 82263994h */ case    3:  		/* mr R3, R18 */
		/* 82263994h case    3:*/		regs.R3 = regs.R18;
		/* 82263994h case    3:*/		return 0x82263998;
		  /* 82263998h */ case    4:  		/* addi R21, R21, 1 */
		/* 82263998h case    4:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R21,0x1);
		/* 82263998h case    4:*/		return 0x8226399C;
		  /* 8226399Ch */ case    5:  		/* addi R22, R22, 4 */
		/* 8226399Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R22,0x4);
		/* 8226399Ch case    5:*/		return 0x822639A0;
		  /* 822639A0h */ case    6:  		/* bl -65856 */
		/* 822639A0h case    6:*/		regs.LR = 0x822639A4; return 0x82253860;
		/* 822639A0h case    6:*/		return 0x822639A4;
		  /* 822639A4h */ case    7:  		/* cmpw CR6, R21, R3 */
		/* 822639A4h case    7:*/		cpu::op::cmpw<6>(regs,regs.R21,regs.R3);
		/* 822639A4h case    7:*/		return 0x822639A8;
		  /* 822639A8h */ case    8:  		/* bc 4, CR6_GT, -628 */
		/* 822639A8h case    8:*/		if ( !regs.CR[6].gt ) { return 0x82263734;  }
		/* 822639A8h case    8:*/		return 0x822639AC;
	}
	return 0x822639AC;
} // Block from 82263988h-822639ACh (9 instructions)

//////////////////////////////////////////////////////
// Block at 822639ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822639AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822639AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822639AC);
		  /* 822639ACh */ case    0:  		/* mr R3, R27 */
		/* 822639ACh case    0:*/		regs.R3 = regs.R27;
		/* 822639ACh case    0:*/		return 0x822639B0;
		  /* 822639B0h */ case    1:  		/* bl -172016 */
		/* 822639B0h case    1:*/		regs.LR = 0x822639B4; return 0x822399C0;
		/* 822639B0h case    1:*/		return 0x822639B4;
		  /* 822639B4h */ case    2:  		/* mr R27, R3 */
		/* 822639B4h case    2:*/		regs.R27 = regs.R3;
		/* 822639B4h case    2:*/		return 0x822639B8;
		  /* 822639B8h */ case    3:  		/* mr R3, R18 */
		/* 822639B8h case    3:*/		regs.R3 = regs.R18;
		/* 822639B8h case    3:*/		return 0x822639BC;
		  /* 822639BCh */ case    4:  		/* li R28, 0 */
		/* 822639BCh case    4:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 822639BCh case    4:*/		return 0x822639C0;
		  /* 822639C0h */ case    5:  		/* mr R30, R19 */
		/* 822639C0h case    5:*/		regs.R30 = regs.R19;
		/* 822639C0h case    5:*/		return 0x822639C4;
		  /* 822639C4h */ case    6:  		/* bl -65892 */
		/* 822639C4h case    6:*/		regs.LR = 0x822639C8; return 0x82253860;
		/* 822639C4h case    6:*/		return 0x822639C8;
		  /* 822639C8h */ case    7:  		/* cmpwi CR6, R3, 1 */
		/* 822639C8h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 822639C8h case    7:*/		return 0x822639CC;
		  /* 822639CCh */ case    8:  		/* bc 12, CR6_LT, 348 */
		/* 822639CCh case    8:*/		if ( regs.CR[6].lt ) { return 0x82263B28;  }
		/* 822639CCh case    8:*/		return 0x822639D0;
		  /* 822639D0h */ case    9:  		/* addi R29, R27, 4 */
		/* 822639D0h case    9:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R27,0x4);
		/* 822639D0h case    9:*/		return 0x822639D4;
		  /* 822639D4h */ case   10:  		/* lwz R31, <#[R29]> */
		/* 822639D4h case   10:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R29 + 0x00000000) );
		/* 822639D4h case   10:*/		return 0x822639D8;
		  /* 822639D8h */ case   11:  		/* mr R3, R31 */
		/* 822639D8h case   11:*/		regs.R3 = regs.R31;
		/* 822639D8h case   11:*/		return 0x822639DC;
		  /* 822639DCh */ case   12:  		/* lwz R11, <#[R31]> */
		/* 822639DCh case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822639DCh case   12:*/		return 0x822639E0;
		  /* 822639E0h */ case   13:  		/* lwz R11, <#[R11 + 8]> */
		/* 822639E0h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 822639E0h case   13:*/		return 0x822639E4;
		  /* 822639E4h */ case   14:  		/* mtspr CTR, R11 */
		/* 822639E4h case   14:*/		regs.CTR = regs.R11;
		/* 822639E4h case   14:*/		return 0x822639E8;
		  /* 822639E8h */ case   15:  		/* bcctrl 20, CR0_LT */
		/* 822639E8h case   15:*/		if ( 1 ) { regs.LR = 0x822639EC; return (uint32)regs.CTR; }
		/* 822639E8h case   15:*/		return 0x822639EC;
		  /* 822639ECh */ case   16:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822639ECh case   16:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822639ECh case   16:*/		return 0x822639F0;
		  /* 822639F0h */ case   17:  		/* bc 4, CR0_EQ, 288 */
		/* 822639F0h case   17:*/		if ( !regs.CR[0].eq ) { return 0x82263B10;  }
		/* 822639F0h case   17:*/		return 0x822639F4;
		  /* 822639F4h */ case   18:  		/* lwz R10, <#[R31 + 104]> */
		/* 822639F4h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000068) );
		/* 822639F4h case   18:*/		return 0x822639F8;
		  /* 822639F8h */ case   19:  		/* li R11, 0 */
		/* 822639F8h case   19:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822639F8h case   19:*/		return 0x822639FC;
		  /* 822639FCh */ case   20:  		/* lwz R9, <#[R10]> */
		/* 822639FCh case   20:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 822639FCh case   20:*/		return 0x82263A00;
		  /* 82263A00h */ case   21:  		/* cmplwi CR6, R9, 0 */
		/* 82263A00h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82263A00h case   21:*/		return 0x82263A04;
		  /* 82263A04h */ case   22:  		/* bc 4, CR6_GT, 32 */
		/* 82263A04h case   22:*/		if ( !regs.CR[6].gt ) { return 0x82263A24;  }
		/* 82263A04h case   22:*/		return 0x82263A08;
		  /* 82263A08h */ case   23:  		/* addi R9, R10, 4 */
		/* 82263A08h case   23:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 82263A08h case   23:*/		return 0x82263A0C;
		  /* 82263A0Ch */ case   24:  		/* li R8, 0 */
		/* 82263A0Ch case   24:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82263A0Ch case   24:*/		return 0x82263A10;
		  /* 82263A10h */ case   25:  		/* addi R11, R11, 1 */
		/* 82263A10h case   25:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82263A10h case   25:*/		return 0x82263A14;
		  /* 82263A14h */ case   26:  		/* stwu R8, <#[R9 + 4]> */
		/* 82263A14h case   26:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 82263A14h case   26:*/		return 0x82263A18;
		  /* 82263A18h */ case   27:  		/* lwz R8, <#[R10]> */
		/* 82263A18h case   27:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 82263A18h case   27:*/		return 0x82263A1C;
		  /* 82263A1Ch */ case   28:  		/* cmplw CR6, R11, R8 */
		/* 82263A1Ch case   28:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 82263A1Ch case   28:*/		return 0x82263A20;
		  /* 82263A20h */ case   29:  		/* bc 12, CR6_LT, -20 */
		/* 82263A20h case   29:*/		if ( regs.CR[6].lt ) { return 0x82263A0C;  }
		/* 82263A20h case   29:*/		return 0x82263A24;
	}
	return 0x82263A24;
} // Block from 822639ACh-82263A24h (30 instructions)

//////////////////////////////////////////////////////
// Block at 82263A24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263A24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263A24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263A24);
		  /* 82263A24h */ case    0:  		/* mr R6, R19 */
		/* 82263A24h case    0:*/		regs.R6 = regs.R19;
		/* 82263A24h case    0:*/		return 0x82263A28;
		  /* 82263A28h */ case    1:  		/* li R7, 0 */
		/* 82263A28h case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 82263A28h case    1:*/		return 0x82263A2C;
		  /* 82263A2Ch */ case    2:  		/* li R5, 0 */
		/* 82263A2Ch case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82263A2Ch case    2:*/		return 0x82263A30;
		  /* 82263A30h */ case    3:  		/* mr R4, R19 */
		/* 82263A30h case    3:*/		regs.R4 = regs.R19;
		/* 82263A30h case    3:*/		return 0x82263A34;
		  /* 82263A34h */ case    4:  		/* lwz R11, <#[R31 + 56]> */
		/* 82263A34h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000038) );
		/* 82263A34h case    4:*/		return 0x82263A38;
		  /* 82263A38h */ case    5:  		/* lwz R10, <#[R11 + 4]> */
		/* 82263A38h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82263A38h case    5:*/		return 0x82263A3C;
		  /* 82263A3Ch */ case    6:  		/* cmplw CR6, R4, R10 */
		/* 82263A3Ch case    6:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R10);
		/* 82263A3Ch case    6:*/		return 0x82263A40;
		  /* 82263A40h */ case    7:  		/* bc 4, CR6_GT, 12 */
		/* 82263A40h case    7:*/		if ( !regs.CR[6].gt ) { return 0x82263A4C;  }
		/* 82263A40h case    7:*/		return 0x82263A44;
		  /* 82263A44h */ case    8:  		/* li R11, 0 */
		/* 82263A44h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82263A44h case    8:*/		return 0x82263A48;
		  /* 82263A48h */ case    9:  		/* b 16 */
		/* 82263A48h case    9:*/		return 0x82263A58;
		/* 82263A48h case    9:*/		return 0x82263A4C;
	}
	return 0x82263A4C;
} // Block from 82263A24h-82263A4Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 82263A4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263A4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263A4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263A4C);
		  /* 82263A4Ch */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 82263A4Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82263A4Ch case    0:*/		return 0x82263A50;
		  /* 82263A50h */ case    1:  		/* mr R11, R19 */
		/* 82263A50h case    1:*/		regs.R11 = regs.R19;
		/* 82263A50h case    1:*/		return 0x82263A54;
		  /* 82263A54h */ case    2:  		/* lwzx R7, <#[R10 + R5]> */
		/* 82263A54h case    2:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 82263A54h case    2:*/		return 0x82263A58;
	}
	return 0x82263A58;
} // Block from 82263A4Ch-82263A58h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82263A58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263A58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263A58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263A58);
		  /* 82263A58h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82263A58h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82263A58h case    0:*/		return 0x82263A5C;
		  /* 82263A5Ch */ case    1:  		/* bc 12, CR0_EQ, 152 */
		/* 82263A5Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82263AF4;  }
		/* 82263A5Ch case    1:*/		return 0x82263A60;
		  /* 82263A60h */ case    2:  		/* lwz R8, <#[R7 + 100]> */
		/* 82263A60h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R7 + 0x00000064) );
		/* 82263A60h case    2:*/		return 0x82263A64;
		  /* 82263A64h */ case    3:  		/* rlwinm. R11, R6, 0, 24, 31 */
		/* 82263A64h case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R6);
		/* 82263A64h case    3:*/		return 0x82263A68;
		  /* 82263A68h */ case    4:  		/* li R9, 0 */
		/* 82263A68h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 82263A68h case    4:*/		return 0x82263A6C;
		  /* 82263A6Ch */ case    5:  		/* bc 12, CR0_EQ, 64 */
		/* 82263A6Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x82263AAC;  }
		/* 82263A6Ch case    5:*/		return 0x82263A70;
		  /* 82263A70h */ case    6:  		/* lwz R11, <#[R31 + 104]> */
		/* 82263A70h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000068) );
		/* 82263A70h case    6:*/		return 0x82263A74;
		  /* 82263A74h */ case    7:  		/* lwz R10, <#[R11]> */
		/* 82263A74h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82263A74h case    7:*/		return 0x82263A78;
		  /* 82263A78h */ case    8:  		/* cmplwi CR6, R10, 0 */
		/* 82263A78h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82263A78h case    8:*/		return 0x82263A7C;
		  /* 82263A7Ch */ case    9:  		/* bc 4, CR6_GT, 40 */
		/* 82263A7Ch case    9:*/		if ( !regs.CR[6].gt ) { return 0x82263AA4;  }
		/* 82263A7Ch case    9:*/		return 0x82263A80;
		  /* 82263A80h */ case   10:  		/* addi R10, R11, 8 */
		/* 82263A80h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x8);
		/* 82263A80h case   10:*/		return 0x82263A84;
		  /* 82263A84h */ case   11:  		/* subf R8, R11, R8 */
		/* 82263A84h case   11:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R11,regs.R8);
		/* 82263A84h case   11:*/		return 0x82263A88;
		  /* 82263A88h */ case   12:  		/* lwzx R6, <#[R8 + R10]> */
		/* 82263A88h case   12:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R8 + regs.R10 + 0x00000000) );
		/* 82263A88h case   12:*/		return 0x82263A8C;
		  /* 82263A8Ch */ case   13:  		/* addi R9, R9, 1 */
		/* 82263A8Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82263A8Ch case   13:*/		return 0x82263A90;
		  /* 82263A90h */ case   14:  		/* stw R6, <#[R10]> */
		/* 82263A90h case   14:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + 0x00000000) );
		/* 82263A90h case   14:*/		return 0x82263A94;
		  /* 82263A94h */ case   15:  		/* addi R10, R10, 4 */
		/* 82263A94h case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 82263A94h case   15:*/		return 0x82263A98;
		  /* 82263A98h */ case   16:  		/* lwz R6, <#[R11]> */
		/* 82263A98h case   16:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 82263A98h case   16:*/		return 0x82263A9C;
		  /* 82263A9Ch */ case   17:  		/* cmplw CR6, R9, R6 */
		/* 82263A9Ch case   17:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R6);
		/* 82263A9Ch case   17:*/		return 0x82263AA0;
		  /* 82263AA0h */ case   18:  		/* bc 12, CR6_LT, -24 */
		/* 82263AA0h case   18:*/		if ( regs.CR[6].lt ) { return 0x82263A88;  }
		/* 82263AA0h case   18:*/		return 0x82263AA4;
	}
	return 0x82263AA4;
} // Block from 82263A58h-82263AA4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82263AA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263AA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263AA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263AA4);
		  /* 82263AA4h */ case    0:  		/* li R6, 0 */
		/* 82263AA4h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82263AA4h case    0:*/		return 0x82263AA8;
		  /* 82263AA8h */ case    1:  		/* b 64 */
		/* 82263AA8h case    1:*/		return 0x82263AE8;
		/* 82263AA8h case    1:*/		return 0x82263AAC;
	}
	return 0x82263AAC;
} // Block from 82263AA4h-82263AACh (2 instructions)

//////////////////////////////////////////////////////
// Block at 82263AACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263AAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263AAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263AAC);
		  /* 82263AACh */ case    0:  		/* lwz R10, <#[R31 + 104]> */
		/* 82263AACh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000068) );
		/* 82263AACh case    0:*/		return 0x82263AB0;
		  /* 82263AB0h */ case    1:  		/* lwz R11, <#[R10]> */
		/* 82263AB0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82263AB0h case    1:*/		return 0x82263AB4;
		  /* 82263AB4h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82263AB4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82263AB4h case    2:*/		return 0x82263AB8;
		  /* 82263AB8h */ case    3:  		/* bc 4, CR6_GT, 48 */
		/* 82263AB8h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82263AE8;  }
		/* 82263AB8h case    3:*/		return 0x82263ABC;
		  /* 82263ABCh */ case    4:  		/* addi R11, R10, 8 */
		/* 82263ABCh case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 82263ABCh case    4:*/		return 0x82263AC0;
		  /* 82263AC0h */ case    5:  		/* subf R8, R10, R8 */
		/* 82263AC0h case    5:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R10,regs.R8);
		/* 82263AC0h case    5:*/		return 0x82263AC4;
		  /* 82263AC4h */ case    6:  		/* lwzx R3, <#[R8 + R11]> */
		/* 82263AC4h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R8 + regs.R11 + 0x00000000) );
		/* 82263AC4h case    6:*/		return 0x82263AC8;
		  /* 82263AC8h */ case    7:  		/* addi R9, R9, 1 */
		/* 82263AC8h case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82263AC8h case    7:*/		return 0x82263ACC;
		  /* 82263ACCh */ case    8:  		/* lwz R26, <#[R11]> */
		/* 82263ACCh case    8:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R11 + 0x00000000) );
		/* 82263ACCh case    8:*/		return 0x82263AD0;
		  /* 82263AD0h */ case    9:  		/* or R3, R3, R26 */
		/* 82263AD0h case    9:*/		cpu::op::or<0>(regs,&regs.R3,regs.R3,regs.R26);
		/* 82263AD0h case    9:*/		return 0x82263AD4;
		  /* 82263AD4h */ case   10:  		/* stw R3, <#[R11]> */
		/* 82263AD4h case   10:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000000) );
		/* 82263AD4h case   10:*/		return 0x82263AD8;
		  /* 82263AD8h */ case   11:  		/* addi R11, R11, 4 */
		/* 82263AD8h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82263AD8h case   11:*/		return 0x82263ADC;
		  /* 82263ADCh */ case   12:  		/* lwz R3, <#[R10]> */
		/* 82263ADCh case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + 0x00000000) );
		/* 82263ADCh case   12:*/		return 0x82263AE0;
		  /* 82263AE0h */ case   13:  		/* cmplw CR6, R9, R3 */
		/* 82263AE0h case   13:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R3);
		/* 82263AE0h case   13:*/		return 0x82263AE4;
		  /* 82263AE4h */ case   14:  		/* bc 12, CR6_LT, -32 */
		/* 82263AE4h case   14:*/		if ( regs.CR[6].lt ) { return 0x82263AC4;  }
		/* 82263AE4h case   14:*/		return 0x82263AE8;
	}
	return 0x82263AE8;
} // Block from 82263AACh-82263AE8h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82263AE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263AE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263AE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263AE8);
		  /* 82263AE8h */ case    0:  		/* addi R4, R4, 1 */
		/* 82263AE8h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 82263AE8h case    0:*/		return 0x82263AEC;
		  /* 82263AECh */ case    1:  		/* addi R5, R5, 4 */
		/* 82263AECh case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x4);
		/* 82263AECh case    1:*/		return 0x82263AF0;
		  /* 82263AF0h */ case    2:  		/* b -188 */
		/* 82263AF0h case    2:*/		return 0x82263A34;
		/* 82263AF0h case    2:*/		return 0x82263AF4;
	}
	return 0x82263AF4;
} // Block from 82263AE8h-82263AF4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82263AF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263AF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263AF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263AF4);
		  /* 82263AF4h */ case    0:  		/* lwz R3, <#[R31 + 104]> */
		/* 82263AF4h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000068) );
		/* 82263AF4h case    0:*/		return 0x82263AF8;
		  /* 82263AF8h */ case    1:  		/* lwz R5, <#[R31 + 108]> */
		/* 82263AF8h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000006C) );
		/* 82263AF8h case    1:*/		return 0x82263AFC;
		  /* 82263AFCh */ case    2:  		/* lwz R4, <#[R31 + 100]> */
		/* 82263AFCh case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000064) );
		/* 82263AFCh case    2:*/		return 0x82263B00;
		  /* 82263B00h */ case    3:  		/* bl -1816 */
		/* 82263B00h case    3:*/		regs.LR = 0x82263B04; return 0x822633E8;
		/* 82263B00h case    3:*/		return 0x82263B04;
		  /* 82263B04h */ case    4:  		/* rlwinm R11, R3, 0, 24, 31 */
		/* 82263B04h case    4:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82263B04h case    4:*/		return 0x82263B08;
		  /* 82263B08h */ case    5:  		/* rlwinm R10, R28, 0, 24, 31 */
		/* 82263B08h case    5:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R28);
		/* 82263B08h case    5:*/		return 0x82263B0C;
		  /* 82263B0Ch */ case    6:  		/* or R28, R11, R10 */
		/* 82263B0Ch case    6:*/		cpu::op::or<0>(regs,&regs.R28,regs.R11,regs.R10);
		/* 82263B0Ch case    6:*/		return 0x82263B10;
	}
	return 0x82263B10;
} // Block from 82263AF4h-82263B10h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82263B10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263B10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263B10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263B10);
		  /* 82263B10h */ case    0:  		/* mr R3, R18 */
		/* 82263B10h case    0:*/		regs.R3 = regs.R18;
		/* 82263B10h case    0:*/		return 0x82263B14;
		  /* 82263B14h */ case    1:  		/* addi R30, R30, 1 */
		/* 82263B14h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82263B14h case    1:*/		return 0x82263B18;
		  /* 82263B18h */ case    2:  		/* addi R29, R29, 4 */
		/* 82263B18h case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 82263B18h case    2:*/		return 0x82263B1C;
		  /* 82263B1Ch */ case    3:  		/* bl -66236 */
		/* 82263B1Ch case    3:*/		regs.LR = 0x82263B20; return 0x82253860;
		/* 82263B1Ch case    3:*/		return 0x82263B20;
		  /* 82263B20h */ case    4:  		/* cmpw CR6, R30, R3 */
		/* 82263B20h case    4:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R3);
		/* 82263B20h case    4:*/		return 0x82263B24;
		  /* 82263B24h */ case    5:  		/* bc 4, CR6_GT, -336 */
		/* 82263B24h case    5:*/		if ( !regs.CR[6].gt ) { return 0x822639D4;  }
		/* 82263B24h case    5:*/		return 0x82263B28;
	}
	return 0x82263B28;
} // Block from 82263B10h-82263B28h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82263B28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263B28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263B28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263B28);
		  /* 82263B28h */ case    0:  		/* rlwinm. R11, R28, 0, 24, 31 */
		/* 82263B28h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R28);
		/* 82263B28h case    0:*/		return 0x82263B2C;
		  /* 82263B2Ch */ case    1:  		/* bc 4, CR0_EQ, -372 */
		/* 82263B2Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x822639B8;  }
		/* 82263B2Ch case    1:*/		return 0x82263B30;
		  /* 82263B30h */ case    2:  		/* addi R1, R1, 208 */
		/* 82263B30h case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 82263B30h case    2:*/		return 0x82263B34;
		  /* 82263B34h */ case    3:  		/* b -1910964 */
		/* 82263B34h case    3:*/		return 0x82091280;
		/* 82263B34h case    3:*/		return 0x82263B38;
	}
	return 0x82263B38;
} // Block from 82263B28h-82263B38h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82263B38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263B38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263B38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263B38);
		  /* 82263B38h */ case    0:  		/* mfspr R12, LR */
		/* 82263B38h case    0:*/		regs.R12 = regs.LR;
		/* 82263B38h case    0:*/		return 0x82263B3C;
		  /* 82263B3Ch */ case    1:  		/* bl -1911012 */
		/* 82263B3Ch case    1:*/		regs.LR = 0x82263B40; return 0x82091258;
		/* 82263B3Ch case    1:*/		return 0x82263B40;
		  /* 82263B40h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82263B40h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82263B40h case    2:*/		return 0x82263B44;
		  /* 82263B44h */ case    3:  		/* lwz R28, <#[R5 + 1452]> */
		/* 82263B44h case    3:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R5 + 0x000005AC) );
		/* 82263B44h case    3:*/		return 0x82263B48;
		  /* 82263B48h */ case    4:  		/* mr R30, R3 */
		/* 82263B48h case    4:*/		regs.R30 = regs.R3;
		/* 82263B48h case    4:*/		return 0x82263B4C;
		  /* 82263B4Ch */ case    5:  		/* mr R29, R4 */
		/* 82263B4Ch case    5:*/		regs.R29 = regs.R4;
		/* 82263B4Ch case    5:*/		return 0x82263B50;
		  /* 82263B50h */ case    6:  		/* li R4, 56 */
		/* 82263B50h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x38);
		/* 82263B50h case    6:*/		return 0x82263B54;
		  /* 82263B54h */ case    7:  		/* mr R3, R28 */
		/* 82263B54h case    7:*/		regs.R3 = regs.R28;
		/* 82263B54h case    7:*/		return 0x82263B58;
		  /* 82263B58h */ case    8:  		/* mr R31, R5 */
		/* 82263B58h case    8:*/		regs.R31 = regs.R5;
		/* 82263B58h case    8:*/		return 0x82263B5C;
		  /* 82263B5Ch */ case    9:  		/* bl -292516 */
		/* 82263B5Ch case    9:*/		regs.LR = 0x82263B60; return 0x8221C4B8;
		/* 82263B5Ch case    9:*/		return 0x82263B60;
		  /* 82263B60h */ case   10:  		/* mr R11, R3 */
		/* 82263B60h case   10:*/		regs.R11 = regs.R3;
		/* 82263B60h case   10:*/		return 0x82263B64;
		  /* 82263B64h */ case   11:  		/* addic. R3, R3, 4 */
		/* 82263B64h case   11:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82263B64h case   11:*/		return 0x82263B68;
		  /* 82263B68h */ case   12:  		/* stw R28, <#[R11]> */
		/* 82263B68h case   12:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000000) );
		/* 82263B68h case   12:*/		return 0x82263B6C;
		  /* 82263B6Ch */ case   13:  		/* bc 12, CR0_EQ, 24 */
		/* 82263B6Ch case   13:*/		if ( regs.CR[0].eq ) { return 0x82263B84;  }
		/* 82263B6Ch case   13:*/		return 0x82263B70;
		  /* 82263B70h */ case   14:  		/* mr R6, R31 */
		/* 82263B70h case   14:*/		regs.R6 = regs.R31;
		/* 82263B70h case   14:*/		return 0x82263B74;
		  /* 82263B74h */ case   15:  		/* mr R5, R29 */
		/* 82263B74h case   15:*/		regs.R5 = regs.R29;
		/* 82263B74h case   15:*/		return 0x82263B78;
		  /* 82263B78h */ case   16:  		/* mr R4, R30 */
		/* 82263B78h case   16:*/		regs.R4 = regs.R30;
		/* 82263B78h case   16:*/		return 0x82263B7C;
		  /* 82263B7Ch */ case   17:  		/* bl -60796 */
		/* 82263B7Ch case   17:*/		regs.LR = 0x82263B80; return 0x82254E00;
		/* 82263B7Ch case   17:*/		return 0x82263B80;
		  /* 82263B80h */ case   18:  		/* b 8 */
		/* 82263B80h case   18:*/		return 0x82263B88;
		/* 82263B80h case   18:*/		return 0x82263B84;
	}
	return 0x82263B84;
} // Block from 82263B38h-82263B84h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82263B84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263B84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263B84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263B84);
		  /* 82263B84h */ case    0:  		/* li R3, 0 */
		/* 82263B84h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82263B84h case    0:*/		return 0x82263B88;
	}
	return 0x82263B88;
} // Block from 82263B84h-82263B88h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82263B88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263B88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263B88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263B88);
		  /* 82263B88h */ case    0:  		/* addi R1, R1, 128 */
		/* 82263B88h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82263B88h case    0:*/		return 0x82263B8C;
		  /* 82263B8Ch */ case    1:  		/* b -1911012 */
		/* 82263B8Ch case    1:*/		return 0x820912A8;
		/* 82263B8Ch case    1:*/		return 0x82263B90;
	}
	return 0x82263B90;
} // Block from 82263B88h-82263B90h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82263B90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263B90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263B90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263B90);
		  /* 82263B90h */ case    0:  		/* mfspr R12, LR */
		/* 82263B90h case    0:*/		regs.R12 = regs.LR;
		/* 82263B90h case    0:*/		return 0x82263B94;
		  /* 82263B94h */ case    1:  		/* bl -1911100 */
		/* 82263B94h case    1:*/		regs.LR = 0x82263B98; return 0x82091258;
		/* 82263B94h case    1:*/		return 0x82263B98;
		  /* 82263B98h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82263B98h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82263B98h case    2:*/		return 0x82263B9C;
		  /* 82263B9Ch */ case    3:  		/* lwz R28, <#[R5 + 1452]> */
		/* 82263B9Ch case    3:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R5 + 0x000005AC) );
		/* 82263B9Ch case    3:*/		return 0x82263BA0;
		  /* 82263BA0h */ case    4:  		/* mr R30, R3 */
		/* 82263BA0h case    4:*/		regs.R30 = regs.R3;
		/* 82263BA0h case    4:*/		return 0x82263BA4;
		  /* 82263BA4h */ case    5:  		/* mr R29, R4 */
		/* 82263BA4h case    5:*/		regs.R29 = regs.R4;
		/* 82263BA4h case    5:*/		return 0x82263BA8;
		  /* 82263BA8h */ case    6:  		/* li R4, 52 */
		/* 82263BA8h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x34);
		/* 82263BA8h case    6:*/		return 0x82263BAC;
		  /* 82263BACh */ case    7:  		/* mr R3, R28 */
		/* 82263BACh case    7:*/		regs.R3 = regs.R28;
		/* 82263BACh case    7:*/		return 0x82263BB0;
		  /* 82263BB0h */ case    8:  		/* mr R31, R5 */
		/* 82263BB0h case    8:*/		regs.R31 = regs.R5;
		/* 82263BB0h case    8:*/		return 0x82263BB4;
		  /* 82263BB4h */ case    9:  		/* bl -292604 */
		/* 82263BB4h case    9:*/		regs.LR = 0x82263BB8; return 0x8221C4B8;
		/* 82263BB4h case    9:*/		return 0x82263BB8;
		  /* 82263BB8h */ case   10:  		/* mr R11, R3 */
		/* 82263BB8h case   10:*/		regs.R11 = regs.R3;
		/* 82263BB8h case   10:*/		return 0x82263BBC;
		  /* 82263BBCh */ case   11:  		/* addic. R3, R3, 4 */
		/* 82263BBCh case   11:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82263BBCh case   11:*/		return 0x82263BC0;
		  /* 82263BC0h */ case   12:  		/* stw R28, <#[R11]> */
		/* 82263BC0h case   12:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000000) );
		/* 82263BC0h case   12:*/		return 0x82263BC4;
		  /* 82263BC4h */ case   13:  		/* bc 12, CR0_EQ, 24 */
		/* 82263BC4h case   13:*/		if ( regs.CR[0].eq ) { return 0x82263BDC;  }
		/* 82263BC4h case   13:*/		return 0x82263BC8;
		  /* 82263BC8h */ case   14:  		/* mr R6, R31 */
		/* 82263BC8h case   14:*/		regs.R6 = regs.R31;
		/* 82263BC8h case   14:*/		return 0x82263BCC;
		  /* 82263BCCh */ case   15:  		/* mr R5, R29 */
		/* 82263BCCh case   15:*/		regs.R5 = regs.R29;
		/* 82263BCCh case   15:*/		return 0x82263BD0;
		  /* 82263BD0h */ case   16:  		/* mr R4, R30 */
		/* 82263BD0h case   16:*/		regs.R4 = regs.R30;
		/* 82263BD0h case   16:*/		return 0x82263BD4;
		  /* 82263BD4h */ case   17:  		/* bl -61204 */
		/* 82263BD4h case   17:*/		regs.LR = 0x82263BD8; return 0x82254CC0;
		/* 82263BD4h case   17:*/		return 0x82263BD8;
		  /* 82263BD8h */ case   18:  		/* b 8 */
		/* 82263BD8h case   18:*/		return 0x82263BE0;
		/* 82263BD8h case   18:*/		return 0x82263BDC;
	}
	return 0x82263BDC;
} // Block from 82263B90h-82263BDCh (19 instructions)

//////////////////////////////////////////////////////
// Block at 82263BDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263BDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263BDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263BDC);
		  /* 82263BDCh */ case    0:  		/* li R3, 0 */
		/* 82263BDCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82263BDCh case    0:*/		return 0x82263BE0;
	}
	return 0x82263BE0;
} // Block from 82263BDCh-82263BE0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82263BE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263BE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263BE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263BE0);
		  /* 82263BE0h */ case    0:  		/* addi R1, R1, 128 */
		/* 82263BE0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82263BE0h case    0:*/		return 0x82263BE4;
		  /* 82263BE4h */ case    1:  		/* b -1911100 */
		/* 82263BE4h case    1:*/		return 0x820912A8;
		/* 82263BE4h case    1:*/		return 0x82263BE8;
	}
	return 0x82263BE8;
} // Block from 82263BE0h-82263BE8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82263BE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263BE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263BE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263BE8);
		  /* 82263BE8h */ case    0:  		/* mfspr R12, LR */
		/* 82263BE8h case    0:*/		regs.R12 = regs.LR;
		/* 82263BE8h case    0:*/		return 0x82263BEC;
		  /* 82263BECh */ case    1:  		/* bl -1911188 */
		/* 82263BECh case    1:*/		regs.LR = 0x82263BF0; return 0x82091258;
		/* 82263BECh case    1:*/		return 0x82263BF0;
		  /* 82263BF0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82263BF0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82263BF0h case    2:*/		return 0x82263BF4;
		  /* 82263BF4h */ case    3:  		/* lwz R28, <#[R5 + 1452]> */
		/* 82263BF4h case    3:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R5 + 0x000005AC) );
		/* 82263BF4h case    3:*/		return 0x82263BF8;
		  /* 82263BF8h */ case    4:  		/* mr R30, R3 */
		/* 82263BF8h case    4:*/		regs.R30 = regs.R3;
		/* 82263BF8h case    4:*/		return 0x82263BFC;
		  /* 82263BFCh */ case    5:  		/* mr R29, R4 */
		/* 82263BFCh case    5:*/		regs.R29 = regs.R4;
		/* 82263BFCh case    5:*/		return 0x82263C00;
		  /* 82263C00h */ case    6:  		/* li R4, 68 */
		/* 82263C00h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x44);
		/* 82263C00h case    6:*/		return 0x82263C04;
		  /* 82263C04h */ case    7:  		/* mr R3, R28 */
		/* 82263C04h case    7:*/		regs.R3 = regs.R28;
		/* 82263C04h case    7:*/		return 0x82263C08;
		  /* 82263C08h */ case    8:  		/* mr R31, R5 */
		/* 82263C08h case    8:*/		regs.R31 = regs.R5;
		/* 82263C08h case    8:*/		return 0x82263C0C;
		  /* 82263C0Ch */ case    9:  		/* bl -292692 */
		/* 82263C0Ch case    9:*/		regs.LR = 0x82263C10; return 0x8221C4B8;
		/* 82263C0Ch case    9:*/		return 0x82263C10;
		  /* 82263C10h */ case   10:  		/* mr R11, R3 */
		/* 82263C10h case   10:*/		regs.R11 = regs.R3;
		/* 82263C10h case   10:*/		return 0x82263C14;
		  /* 82263C14h */ case   11:  		/* addic. R3, R3, 4 */
		/* 82263C14h case   11:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82263C14h case   11:*/		return 0x82263C18;
		  /* 82263C18h */ case   12:  		/* stw R28, <#[R11]> */
		/* 82263C18h case   12:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000000) );
		/* 82263C18h case   12:*/		return 0x82263C1C;
		  /* 82263C1Ch */ case   13:  		/* bc 12, CR0_EQ, 24 */
		/* 82263C1Ch case   13:*/		if ( regs.CR[0].eq ) { return 0x82263C34;  }
		/* 82263C1Ch case   13:*/		return 0x82263C20;
		  /* 82263C20h */ case   14:  		/* mr R6, R31 */
		/* 82263C20h case   14:*/		regs.R6 = regs.R31;
		/* 82263C20h case   14:*/		return 0x82263C24;
		  /* 82263C24h */ case   15:  		/* mr R5, R29 */
		/* 82263C24h case   15:*/		regs.R5 = regs.R29;
		/* 82263C24h case   15:*/		return 0x82263C28;
		  /* 82263C28h */ case   16:  		/* mr R4, R30 */
		/* 82263C28h case   16:*/		regs.R4 = regs.R30;
		/* 82263C28h case   16:*/		return 0x82263C2C;
		  /* 82263C2Ch */ case   17:  		/* bl -60804 */
		/* 82263C2Ch case   17:*/		regs.LR = 0x82263C30; return 0x82254EA8;
		/* 82263C2Ch case   17:*/		return 0x82263C30;
		  /* 82263C30h */ case   18:  		/* b 8 */
		/* 82263C30h case   18:*/		return 0x82263C38;
		/* 82263C30h case   18:*/		return 0x82263C34;
	}
	return 0x82263C34;
} // Block from 82263BE8h-82263C34h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82263C34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263C34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263C34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263C34);
		  /* 82263C34h */ case    0:  		/* li R3, 0 */
		/* 82263C34h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82263C34h case    0:*/		return 0x82263C38;
	}
	return 0x82263C38;
} // Block from 82263C34h-82263C38h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82263C38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263C38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263C38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263C38);
		  /* 82263C38h */ case    0:  		/* addi R1, R1, 128 */
		/* 82263C38h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82263C38h case    0:*/		return 0x82263C3C;
		  /* 82263C3Ch */ case    1:  		/* b -1911188 */
		/* 82263C3Ch case    1:*/		return 0x820912A8;
		/* 82263C3Ch case    1:*/		return 0x82263C40;
	}
	return 0x82263C40;
} // Block from 82263C38h-82263C40h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82263C40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263C40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263C40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263C40);
		  /* 82263C40h */ case    0:  		/* mfspr R12, LR */
		/* 82263C40h case    0:*/		regs.R12 = regs.LR;
		/* 82263C40h case    0:*/		return 0x82263C44;
		  /* 82263C44h */ case    1:  		/* bl -1911276 */
		/* 82263C44h case    1:*/		regs.LR = 0x82263C48; return 0x82091258;
		/* 82263C44h case    1:*/		return 0x82263C48;
		  /* 82263C48h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82263C48h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82263C48h case    2:*/		return 0x82263C4C;
		  /* 82263C4Ch */ case    3:  		/* lwz R28, <#[R5 + 1452]> */
		/* 82263C4Ch case    3:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R5 + 0x000005AC) );
		/* 82263C4Ch case    3:*/		return 0x82263C50;
		  /* 82263C50h */ case    4:  		/* mr R30, R3 */
		/* 82263C50h case    4:*/		regs.R30 = regs.R3;
		/* 82263C50h case    4:*/		return 0x82263C54;
		  /* 82263C54h */ case    5:  		/* mr R29, R4 */
		/* 82263C54h case    5:*/		regs.R29 = regs.R4;
		/* 82263C54h case    5:*/		return 0x82263C58;
		  /* 82263C58h */ case    6:  		/* li R4, 56 */
		/* 82263C58h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x38);
		/* 82263C58h case    6:*/		return 0x82263C5C;
		  /* 82263C5Ch */ case    7:  		/* mr R3, R28 */
		/* 82263C5Ch case    7:*/		regs.R3 = regs.R28;
		/* 82263C5Ch case    7:*/		return 0x82263C60;
		  /* 82263C60h */ case    8:  		/* mr R31, R5 */
		/* 82263C60h case    8:*/		regs.R31 = regs.R5;
		/* 82263C60h case    8:*/		return 0x82263C64;
		  /* 82263C64h */ case    9:  		/* bl -292780 */
		/* 82263C64h case    9:*/		regs.LR = 0x82263C68; return 0x8221C4B8;
		/* 82263C64h case    9:*/		return 0x82263C68;
		  /* 82263C68h */ case   10:  		/* mr R11, R3 */
		/* 82263C68h case   10:*/		regs.R11 = regs.R3;
		/* 82263C68h case   10:*/		return 0x82263C6C;
		  /* 82263C6Ch */ case   11:  		/* addic. R3, R3, 4 */
		/* 82263C6Ch case   11:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82263C6Ch case   11:*/		return 0x82263C70;
		  /* 82263C70h */ case   12:  		/* stw R28, <#[R11]> */
		/* 82263C70h case   12:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000000) );
		/* 82263C70h case   12:*/		return 0x82263C74;
		  /* 82263C74h */ case   13:  		/* bc 12, CR0_EQ, 24 */
		/* 82263C74h case   13:*/		if ( regs.CR[0].eq ) { return 0x82263C8C;  }
		/* 82263C74h case   13:*/		return 0x82263C78;
		  /* 82263C78h */ case   14:  		/* mr R6, R31 */
		/* 82263C78h case   14:*/		regs.R6 = regs.R31;
		/* 82263C78h case   14:*/		return 0x82263C7C;
		  /* 82263C7Ch */ case   15:  		/* mr R5, R29 */
		/* 82263C7Ch case   15:*/		regs.R5 = regs.R29;
		/* 82263C7Ch case   15:*/		return 0x82263C80;
		  /* 82263C80h */ case   16:  		/* mr R4, R30 */
		/* 82263C80h case   16:*/		regs.R4 = regs.R30;
		/* 82263C80h case   16:*/		return 0x82263C84;
		  /* 82263C84h */ case   17:  		/* bl -58244 */
		/* 82263C84h case   17:*/		regs.LR = 0x82263C88; return 0x82255900;
		/* 82263C84h case   17:*/		return 0x82263C88;
		  /* 82263C88h */ case   18:  		/* b 8 */
		/* 82263C88h case   18:*/		return 0x82263C90;
		/* 82263C88h case   18:*/		return 0x82263C8C;
	}
	return 0x82263C8C;
} // Block from 82263C40h-82263C8Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 82263C8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263C8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263C8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263C8C);
		  /* 82263C8Ch */ case    0:  		/* li R3, 0 */
		/* 82263C8Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82263C8Ch case    0:*/		return 0x82263C90;
	}
	return 0x82263C90;
} // Block from 82263C8Ch-82263C90h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82263C90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263C90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263C90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263C90);
		  /* 82263C90h */ case    0:  		/* addi R1, R1, 128 */
		/* 82263C90h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82263C90h case    0:*/		return 0x82263C94;
		  /* 82263C94h */ case    1:  		/* b -1911276 */
		/* 82263C94h case    1:*/		return 0x820912A8;
		/* 82263C94h case    1:*/		return 0x82263C98;
	}
	return 0x82263C98;
} // Block from 82263C90h-82263C98h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82263C98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263C98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263C98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263C98);
		  /* 82263C98h */ case    0:  		/* mfspr R12, LR */
		/* 82263C98h case    0:*/		regs.R12 = regs.LR;
		/* 82263C98h case    0:*/		return 0x82263C9C;
		  /* 82263C9Ch */ case    1:  		/* bl -1911364 */
		/* 82263C9Ch case    1:*/		regs.LR = 0x82263CA0; return 0x82091258;
		/* 82263C9Ch case    1:*/		return 0x82263CA0;
		  /* 82263CA0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82263CA0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82263CA0h case    2:*/		return 0x82263CA4;
		  /* 82263CA4h */ case    3:  		/* lwz R28, <#[R5 + 1452]> */
		/* 82263CA4h case    3:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R5 + 0x000005AC) );
		/* 82263CA4h case    3:*/		return 0x82263CA8;
		  /* 82263CA8h */ case    4:  		/* mr R30, R3 */
		/* 82263CA8h case    4:*/		regs.R30 = regs.R3;
		/* 82263CA8h case    4:*/		return 0x82263CAC;
		  /* 82263CACh */ case    5:  		/* mr R29, R4 */
		/* 82263CACh case    5:*/		regs.R29 = regs.R4;
		/* 82263CACh case    5:*/		return 0x82263CB0;
		  /* 82263CB0h */ case    6:  		/* li R4, 56 */
		/* 82263CB0h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x38);
		/* 82263CB0h case    6:*/		return 0x82263CB4;
		  /* 82263CB4h */ case    7:  		/* mr R3, R28 */
		/* 82263CB4h case    7:*/		regs.R3 = regs.R28;
		/* 82263CB4h case    7:*/		return 0x82263CB8;
		  /* 82263CB8h */ case    8:  		/* mr R31, R5 */
		/* 82263CB8h case    8:*/		regs.R31 = regs.R5;
		/* 82263CB8h case    8:*/		return 0x82263CBC;
		  /* 82263CBCh */ case    9:  		/* bl -292868 */
		/* 82263CBCh case    9:*/		regs.LR = 0x82263CC0; return 0x8221C4B8;
		/* 82263CBCh case    9:*/		return 0x82263CC0;
		  /* 82263CC0h */ case   10:  		/* mr R11, R3 */
		/* 82263CC0h case   10:*/		regs.R11 = regs.R3;
		/* 82263CC0h case   10:*/		return 0x82263CC4;
		  /* 82263CC4h */ case   11:  		/* addic. R3, R3, 4 */
		/* 82263CC4h case   11:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82263CC4h case   11:*/		return 0x82263CC8;
		  /* 82263CC8h */ case   12:  		/* stw R28, <#[R11]> */
		/* 82263CC8h case   12:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000000) );
		/* 82263CC8h case   12:*/		return 0x82263CCC;
		  /* 82263CCCh */ case   13:  		/* bc 12, CR0_EQ, 24 */
		/* 82263CCCh case   13:*/		if ( regs.CR[0].eq ) { return 0x82263CE4;  }
		/* 82263CCCh case   13:*/		return 0x82263CD0;
		  /* 82263CD0h */ case   14:  		/* mr R6, R31 */
		/* 82263CD0h case   14:*/		regs.R6 = regs.R31;
		/* 82263CD0h case   14:*/		return 0x82263CD4;
		  /* 82263CD4h */ case   15:  		/* mr R5, R29 */
		/* 82263CD4h case   15:*/		regs.R5 = regs.R29;
		/* 82263CD4h case   15:*/		return 0x82263CD8;
		  /* 82263CD8h */ case   16:  		/* mr R4, R30 */
		/* 82263CD8h case   16:*/		regs.R4 = regs.R30;
		/* 82263CD8h case   16:*/		return 0x82263CDC;
		  /* 82263CDCh */ case   17:  		/* bl -60236 */
		/* 82263CDCh case   17:*/		regs.LR = 0x82263CE0; return 0x82255190;
		/* 82263CDCh case   17:*/		return 0x82263CE0;
		  /* 82263CE0h */ case   18:  		/* b 8 */
		/* 82263CE0h case   18:*/		return 0x82263CE8;
		/* 82263CE0h case   18:*/		return 0x82263CE4;
	}
	return 0x82263CE4;
} // Block from 82263C98h-82263CE4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82263CE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263CE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263CE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263CE4);
		  /* 82263CE4h */ case    0:  		/* li R3, 0 */
		/* 82263CE4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82263CE4h case    0:*/		return 0x82263CE8;
	}
	return 0x82263CE8;
} // Block from 82263CE4h-82263CE8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82263CE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263CE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263CE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263CE8);
		  /* 82263CE8h */ case    0:  		/* addi R1, R1, 128 */
		/* 82263CE8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82263CE8h case    0:*/		return 0x82263CEC;
		  /* 82263CECh */ case    1:  		/* b -1911364 */
		/* 82263CECh case    1:*/		return 0x820912A8;
		/* 82263CECh case    1:*/		return 0x82263CF0;
	}
	return 0x82263CF0;
} // Block from 82263CE8h-82263CF0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82263CF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263CF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263CF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263CF0);
		  /* 82263CF0h */ case    0:  		/* mfspr R12, LR */
		/* 82263CF0h case    0:*/		regs.R12 = regs.LR;
		/* 82263CF0h case    0:*/		return 0x82263CF4;
		  /* 82263CF4h */ case    1:  		/* bl -1911452 */
		/* 82263CF4h case    1:*/		regs.LR = 0x82263CF8; return 0x82091258;
		/* 82263CF4h case    1:*/		return 0x82263CF8;
		  /* 82263CF8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82263CF8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82263CF8h case    2:*/		return 0x82263CFC;
		  /* 82263CFCh */ case    3:  		/* lwz R28, <#[R5 + 1452]> */
		/* 82263CFCh case    3:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R5 + 0x000005AC) );
		/* 82263CFCh case    3:*/		return 0x82263D00;
		  /* 82263D00h */ case    4:  		/* mr R30, R3 */
		/* 82263D00h case    4:*/		regs.R30 = regs.R3;
		/* 82263D00h case    4:*/		return 0x82263D04;
		  /* 82263D04h */ case    5:  		/* mr R29, R4 */
		/* 82263D04h case    5:*/		regs.R29 = regs.R4;
		/* 82263D04h case    5:*/		return 0x82263D08;
		  /* 82263D08h */ case    6:  		/* li R4, 52 */
		/* 82263D08h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x34);
		/* 82263D08h case    6:*/		return 0x82263D0C;
		  /* 82263D0Ch */ case    7:  		/* mr R3, R28 */
		/* 82263D0Ch case    7:*/		regs.R3 = regs.R28;
		/* 82263D0Ch case    7:*/		return 0x82263D10;
		  /* 82263D10h */ case    8:  		/* mr R31, R5 */
		/* 82263D10h case    8:*/		regs.R31 = regs.R5;
		/* 82263D10h case    8:*/		return 0x82263D14;
		  /* 82263D14h */ case    9:  		/* bl -292956 */
		/* 82263D14h case    9:*/		regs.LR = 0x82263D18; return 0x8221C4B8;
		/* 82263D14h case    9:*/		return 0x82263D18;
		  /* 82263D18h */ case   10:  		/* mr R11, R3 */
		/* 82263D18h case   10:*/		regs.R11 = regs.R3;
		/* 82263D18h case   10:*/		return 0x82263D1C;
		  /* 82263D1Ch */ case   11:  		/* addic. R3, R3, 4 */
		/* 82263D1Ch case   11:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82263D1Ch case   11:*/		return 0x82263D20;
		  /* 82263D20h */ case   12:  		/* stw R28, <#[R11]> */
		/* 82263D20h case   12:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000000) );
		/* 82263D20h case   12:*/		return 0x82263D24;
		  /* 82263D24h */ case   13:  		/* bc 12, CR0_EQ, 24 */
		/* 82263D24h case   13:*/		if ( regs.CR[0].eq ) { return 0x82263D3C;  }
		/* 82263D24h case   13:*/		return 0x82263D28;
		  /* 82263D28h */ case   14:  		/* mr R6, R31 */
		/* 82263D28h case   14:*/		regs.R6 = regs.R31;
		/* 82263D28h case   14:*/		return 0x82263D2C;
		  /* 82263D2Ch */ case   15:  		/* mr R5, R29 */
		/* 82263D2Ch case   15:*/		regs.R5 = regs.R29;
		/* 82263D2Ch case   15:*/		return 0x82263D30;
		  /* 82263D30h */ case   16:  		/* mr R4, R30 */
		/* 82263D30h case   16:*/		regs.R4 = regs.R30;
		/* 82263D30h case   16:*/		return 0x82263D34;
		  /* 82263D34h */ case   17:  		/* bl -60492 */
		/* 82263D34h case   17:*/		regs.LR = 0x82263D38; return 0x822550E8;
		/* 82263D34h case   17:*/		return 0x82263D38;
		  /* 82263D38h */ case   18:  		/* b 8 */
		/* 82263D38h case   18:*/		return 0x82263D40;
		/* 82263D38h case   18:*/		return 0x82263D3C;
	}
	return 0x82263D3C;
} // Block from 82263CF0h-82263D3Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 82263D3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263D3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263D3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263D3C);
		  /* 82263D3Ch */ case    0:  		/* li R3, 0 */
		/* 82263D3Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82263D3Ch case    0:*/		return 0x82263D40;
	}
	return 0x82263D40;
} // Block from 82263D3Ch-82263D40h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82263D40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263D40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263D40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263D40);
		  /* 82263D40h */ case    0:  		/* addi R1, R1, 128 */
		/* 82263D40h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82263D40h case    0:*/		return 0x82263D44;
		  /* 82263D44h */ case    1:  		/* b -1911452 */
		/* 82263D44h case    1:*/		return 0x820912A8;
		/* 82263D44h case    1:*/		return 0x82263D48;
	}
	return 0x82263D48;
} // Block from 82263D40h-82263D48h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82263D48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263D48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263D48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263D48);
		  /* 82263D48h */ case    0:  		/* mfspr R12, LR */
		/* 82263D48h case    0:*/		regs.R12 = regs.LR;
		/* 82263D48h case    0:*/		return 0x82263D4C;
		  /* 82263D4Ch */ case    1:  		/* bl -1911540 */
		/* 82263D4Ch case    1:*/		regs.LR = 0x82263D50; return 0x82091258;
		/* 82263D4Ch case    1:*/		return 0x82263D50;
		  /* 82263D50h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82263D50h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82263D50h case    2:*/		return 0x82263D54;
		  /* 82263D54h */ case    3:  		/* lwz R28, <#[R5 + 1452]> */
		/* 82263D54h case    3:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R5 + 0x000005AC) );
		/* 82263D54h case    3:*/		return 0x82263D58;
		  /* 82263D58h */ case    4:  		/* mr R30, R3 */
		/* 82263D58h case    4:*/		regs.R30 = regs.R3;
		/* 82263D58h case    4:*/		return 0x82263D5C;
		  /* 82263D5Ch */ case    5:  		/* mr R29, R4 */
		/* 82263D5Ch case    5:*/		regs.R29 = regs.R4;
		/* 82263D5Ch case    5:*/		return 0x82263D60;
		  /* 82263D60h */ case    6:  		/* li R4, 52 */
		/* 82263D60h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x34);
		/* 82263D60h case    6:*/		return 0x82263D64;
		  /* 82263D64h */ case    7:  		/* mr R3, R28 */
		/* 82263D64h case    7:*/		regs.R3 = regs.R28;
		/* 82263D64h case    7:*/		return 0x82263D68;
		  /* 82263D68h */ case    8:  		/* mr R31, R5 */
		/* 82263D68h case    8:*/		regs.R31 = regs.R5;
		/* 82263D68h case    8:*/		return 0x82263D6C;
		  /* 82263D6Ch */ case    9:  		/* bl -293044 */
		/* 82263D6Ch case    9:*/		regs.LR = 0x82263D70; return 0x8221C4B8;
		/* 82263D6Ch case    9:*/		return 0x82263D70;
		  /* 82263D70h */ case   10:  		/* mr R11, R3 */
		/* 82263D70h case   10:*/		regs.R11 = regs.R3;
		/* 82263D70h case   10:*/		return 0x82263D74;
		  /* 82263D74h */ case   11:  		/* addic. R3, R3, 4 */
		/* 82263D74h case   11:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82263D74h case   11:*/		return 0x82263D78;
		  /* 82263D78h */ case   12:  		/* stw R28, <#[R11]> */
		/* 82263D78h case   12:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000000) );
		/* 82263D78h case   12:*/		return 0x82263D7C;
		  /* 82263D7Ch */ case   13:  		/* bc 12, CR0_EQ, 24 */
		/* 82263D7Ch case   13:*/		if ( regs.CR[0].eq ) { return 0x82263D94;  }
		/* 82263D7Ch case   13:*/		return 0x82263D80;
		  /* 82263D80h */ case   14:  		/* mr R6, R31 */
		/* 82263D80h case   14:*/		regs.R6 = regs.R31;
		/* 82263D80h case   14:*/		return 0x82263D84;
		  /* 82263D84h */ case   15:  		/* mr R5, R29 */
		/* 82263D84h case   15:*/		regs.R5 = regs.R29;
		/* 82263D84h case   15:*/		return 0x82263D88;
		  /* 82263D88h */ case   16:  		/* mr R4, R30 */
		/* 82263D88h case   16:*/		regs.R4 = regs.R30;
		/* 82263D88h case   16:*/		return 0x82263D8C;
		  /* 82263D8Ch */ case   17:  		/* bl -58444 */
		/* 82263D8Ch case   17:*/		regs.LR = 0x82263D90; return 0x82255940;
		/* 82263D8Ch case   17:*/		return 0x82263D90;
		  /* 82263D90h */ case   18:  		/* b 8 */
		/* 82263D90h case   18:*/		return 0x82263D98;
		/* 82263D90h case   18:*/		return 0x82263D94;
	}
	return 0x82263D94;
} // Block from 82263D48h-82263D94h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82263D94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263D94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263D94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263D94);
		  /* 82263D94h */ case    0:  		/* li R3, 0 */
		/* 82263D94h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82263D94h case    0:*/		return 0x82263D98;
	}
	return 0x82263D98;
} // Block from 82263D94h-82263D98h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82263D98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263D98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263D98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263D98);
		  /* 82263D98h */ case    0:  		/* addi R1, R1, 128 */
		/* 82263D98h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82263D98h case    0:*/		return 0x82263D9C;
		  /* 82263D9Ch */ case    1:  		/* b -1911540 */
		/* 82263D9Ch case    1:*/		return 0x820912A8;
		/* 82263D9Ch case    1:*/		return 0x82263DA0;
	}
	return 0x82263DA0;
} // Block from 82263D98h-82263DA0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82263DA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263DA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263DA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263DA0);
		  /* 82263DA0h */ case    0:  		/* mfspr R12, LR */
		/* 82263DA0h case    0:*/		regs.R12 = regs.LR;
		/* 82263DA0h case    0:*/		return 0x82263DA4;
		  /* 82263DA4h */ case    1:  		/* bl -1911628 */
		/* 82263DA4h case    1:*/		regs.LR = 0x82263DA8; return 0x82091258;
		/* 82263DA4h case    1:*/		return 0x82263DA8;
		  /* 82263DA8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82263DA8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82263DA8h case    2:*/		return 0x82263DAC;
		  /* 82263DACh */ case    3:  		/* lwz R28, <#[R5 + 1452]> */
		/* 82263DACh case    3:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R5 + 0x000005AC) );
		/* 82263DACh case    3:*/		return 0x82263DB0;
		  /* 82263DB0h */ case    4:  		/* mr R30, R3 */
		/* 82263DB0h case    4:*/		regs.R30 = regs.R3;
		/* 82263DB0h case    4:*/		return 0x82263DB4;
		  /* 82263DB4h */ case    5:  		/* mr R29, R4 */
		/* 82263DB4h case    5:*/		regs.R29 = regs.R4;
		/* 82263DB4h case    5:*/		return 0x82263DB8;
		  /* 82263DB8h */ case    6:  		/* li R4, 56 */
		/* 82263DB8h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x38);
		/* 82263DB8h case    6:*/		return 0x82263DBC;
		  /* 82263DBCh */ case    7:  		/* mr R3, R28 */
		/* 82263DBCh case    7:*/		regs.R3 = regs.R28;
		/* 82263DBCh case    7:*/		return 0x82263DC0;
		  /* 82263DC0h */ case    8:  		/* mr R31, R5 */
		/* 82263DC0h case    8:*/		regs.R31 = regs.R5;
		/* 82263DC0h case    8:*/		return 0x82263DC4;
		  /* 82263DC4h */ case    9:  		/* bl -293132 */
		/* 82263DC4h case    9:*/		regs.LR = 0x82263DC8; return 0x8221C4B8;
		/* 82263DC4h case    9:*/		return 0x82263DC8;
		  /* 82263DC8h */ case   10:  		/* mr R11, R3 */
		/* 82263DC8h case   10:*/		regs.R11 = regs.R3;
		/* 82263DC8h case   10:*/		return 0x82263DCC;
		  /* 82263DCCh */ case   11:  		/* addic. R3, R3, 4 */
		/* 82263DCCh case   11:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82263DCCh case   11:*/		return 0x82263DD0;
		  /* 82263DD0h */ case   12:  		/* stw R28, <#[R11]> */
		/* 82263DD0h case   12:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000000) );
		/* 82263DD0h case   12:*/		return 0x82263DD4;
		  /* 82263DD4h */ case   13:  		/* bc 12, CR0_EQ, 24 */
		/* 82263DD4h case   13:*/		if ( regs.CR[0].eq ) { return 0x82263DEC;  }
		/* 82263DD4h case   13:*/		return 0x82263DD8;
		  /* 82263DD8h */ case   14:  		/* mr R6, R31 */
		/* 82263DD8h case   14:*/		regs.R6 = regs.R31;
		/* 82263DD8h case   14:*/		return 0x82263DDC;
		  /* 82263DDCh */ case   15:  		/* mr R5, R29 */
		/* 82263DDCh case   15:*/		regs.R5 = regs.R29;
		/* 82263DDCh case   15:*/		return 0x82263DE0;
		  /* 82263DE0h */ case   16:  		/* mr R4, R30 */
		/* 82263DE0h case   16:*/		regs.R4 = regs.R30;
		/* 82263DE0h case   16:*/		return 0x82263DE4;
		  /* 82263DE4h */ case   17:  		/* bl -57876 */
		/* 82263DE4h case   17:*/		regs.LR = 0x82263DE8; return 0x82255BD0;
		/* 82263DE4h case   17:*/		return 0x82263DE8;
		  /* 82263DE8h */ case   18:  		/* b 8 */
		/* 82263DE8h case   18:*/		return 0x82263DF0;
		/* 82263DE8h case   18:*/		return 0x82263DEC;
	}
	return 0x82263DEC;
} // Block from 82263DA0h-82263DECh (19 instructions)

//////////////////////////////////////////////////////
// Block at 82263DECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263DEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263DEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263DEC);
		  /* 82263DECh */ case    0:  		/* li R3, 0 */
		/* 82263DECh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82263DECh case    0:*/		return 0x82263DF0;
	}
	return 0x82263DF0;
} // Block from 82263DECh-82263DF0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82263DF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263DF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263DF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263DF0);
		  /* 82263DF0h */ case    0:  		/* addi R1, R1, 128 */
		/* 82263DF0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82263DF0h case    0:*/		return 0x82263DF4;
		  /* 82263DF4h */ case    1:  		/* b -1911628 */
		/* 82263DF4h case    1:*/		return 0x820912A8;
		/* 82263DF4h case    1:*/		return 0x82263DF8;
	}
	return 0x82263DF8;
} // Block from 82263DF0h-82263DF8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82263DF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263DF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263DF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263DF8);
		  /* 82263DF8h */ case    0:  		/* mfspr R12, LR */
		/* 82263DF8h case    0:*/		regs.R12 = regs.LR;
		/* 82263DF8h case    0:*/		return 0x82263DFC;
		  /* 82263DFCh */ case    1:  		/* bl -1911716 */
		/* 82263DFCh case    1:*/		regs.LR = 0x82263E00; return 0x82091258;
		/* 82263DFCh case    1:*/		return 0x82263E00;
	}
	return 0x82263E00;
} // Block from 82263DF8h-82263E00h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82263E00h
// Function '?diffCompUnion@bitset@XGRAPHICS@@QBA_NAAV12@ABV12@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263E00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263E00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263E00);
		  /* 82263E00h */ case    0:  		/* stwu R1, <#[R1 - 128]> */
		/* 82263E00h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82263E00h case    0:*/		return 0x82263E04;
		  /* 82263E04h */ case    1:  		/* lwz R28, <#[R5 + 1452]> */
		/* 82263E04h case    1:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R5 + 0x000005AC) );
		/* 82263E04h case    1:*/		return 0x82263E08;
		  /* 82263E08h */ case    2:  		/* mr R30, R3 */
		/* 82263E08h case    2:*/		regs.R30 = regs.R3;
		/* 82263E08h case    2:*/		return 0x82263E0C;
		  /* 82263E0Ch */ case    3:  		/* mr R29, R4 */
		/* 82263E0Ch case    3:*/		regs.R29 = regs.R4;
		/* 82263E0Ch case    3:*/		return 0x82263E10;
		  /* 82263E10h */ case    4:  		/* li R4, 56 */
		/* 82263E10h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x38);
		/* 82263E10h case    4:*/		return 0x82263E14;
		  /* 82263E14h */ case    5:  		/* mr R3, R28 */
		/* 82263E14h case    5:*/		regs.R3 = regs.R28;
		/* 82263E14h case    5:*/		return 0x82263E18;
		  /* 82263E18h */ case    6:  		/* mr R31, R5 */
		/* 82263E18h case    6:*/		regs.R31 = regs.R5;
		/* 82263E18h case    6:*/		return 0x82263E1C;
		  /* 82263E1Ch */ case    7:  		/* bl -293220 */
		/* 82263E1Ch case    7:*/		regs.LR = 0x82263E20; return 0x8221C4B8;
		/* 82263E1Ch case    7:*/		return 0x82263E20;
		  /* 82263E20h */ case    8:  		/* mr R11, R3 */
		/* 82263E20h case    8:*/		regs.R11 = regs.R3;
		/* 82263E20h case    8:*/		return 0x82263E24;
		  /* 82263E24h */ case    9:  		/* addic. R3, R3, 4 */
		/* 82263E24h case    9:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82263E24h case    9:*/		return 0x82263E28;
		  /* 82263E28h */ case   10:  		/* stw R28, <#[R11]> */
		/* 82263E28h case   10:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000000) );
		/* 82263E28h case   10:*/		return 0x82263E2C;
		  /* 82263E2Ch */ case   11:  		/* bc 12, CR0_EQ, 24 */
		/* 82263E2Ch case   11:*/		if ( regs.CR[0].eq ) { return 0x82263E44;  }
		/* 82263E2Ch case   11:*/		return 0x82263E30;
		  /* 82263E30h */ case   12:  		/* mr R6, R31 */
		/* 82263E30h case   12:*/		regs.R6 = regs.R31;
		/* 82263E30h case   12:*/		return 0x82263E34;
		  /* 82263E34h */ case   13:  		/* mr R5, R29 */
		/* 82263E34h case   13:*/		regs.R5 = regs.R29;
		/* 82263E34h case   13:*/		return 0x82263E38;
		  /* 82263E38h */ case   14:  		/* mr R4, R30 */
		/* 82263E38h case   14:*/		regs.R4 = regs.R30;
		/* 82263E38h case   14:*/		return 0x82263E3C;
		  /* 82263E3Ch */ case   15:  		/* bl -58068 */
		/* 82263E3Ch case   15:*/		regs.LR = 0x82263E40; return 0x82255B68;
		/* 82263E3Ch case   15:*/		return 0x82263E40;
		  /* 82263E40h */ case   16:  		/* b 8 */
		/* 82263E40h case   16:*/		return 0x82263E48;
		/* 82263E40h case   16:*/		return 0x82263E44;
	}
	return 0x82263E44;
} // Block from 82263E00h-82263E44h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82263E44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263E44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263E44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263E44);
		  /* 82263E44h */ case    0:  		/* li R3, 0 */
		/* 82263E44h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82263E44h case    0:*/		return 0x82263E48;
	}
	return 0x82263E48;
} // Block from 82263E44h-82263E48h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82263E48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263E48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263E48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263E48);
		  /* 82263E48h */ case    0:  		/* addi R1, R1, 128 */
		/* 82263E48h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82263E48h case    0:*/		return 0x82263E4C;
		  /* 82263E4Ch */ case    1:  		/* b -1911716 */
		/* 82263E4Ch case    1:*/		return 0x820912A8;
		/* 82263E4Ch case    1:*/		return 0x82263E50;
	}
	return 0x82263E50;
} // Block from 82263E48h-82263E50h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82263E50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263E50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263E50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263E50);
		  /* 82263E50h */ case    0:  		/* mfspr R12, LR */
		/* 82263E50h case    0:*/		regs.R12 = regs.LR;
		/* 82263E50h case    0:*/		return 0x82263E54;
		  /* 82263E54h */ case    1:  		/* bl -1911804 */
		/* 82263E54h case    1:*/		regs.LR = 0x82263E58; return 0x82091258;
		/* 82263E54h case    1:*/		return 0x82263E58;
		  /* 82263E58h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82263E58h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82263E58h case    2:*/		return 0x82263E5C;
		  /* 82263E5Ch */ case    3:  		/* lwz R28, <#[R5 + 1452]> */
		/* 82263E5Ch case    3:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R5 + 0x000005AC) );
		/* 82263E5Ch case    3:*/		return 0x82263E60;
		  /* 82263E60h */ case    4:  		/* mr R30, R3 */
		/* 82263E60h case    4:*/		regs.R30 = regs.R3;
		/* 82263E60h case    4:*/		return 0x82263E64;
		  /* 82263E64h */ case    5:  		/* mr R29, R4 */
		/* 82263E64h case    5:*/		regs.R29 = regs.R4;
		/* 82263E64h case    5:*/		return 0x82263E68;
	}
	return 0x82263E68;
} // Block from 82263E50h-82263E68h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82263E68h
// Function '?UpdateNonLocalSet@CFG@XGRAPHICS@@AAAXPAVIRInst@2@PAVLiveSet@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263E68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263E68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263E68);
		  /* 82263E68h */ case    0:  		/* li R4, 56 */
		/* 82263E68h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x38);
		/* 82263E68h case    0:*/		return 0x82263E6C;
		  /* 82263E6Ch */ case    1:  		/* mr R3, R28 */
		/* 82263E6Ch case    1:*/		regs.R3 = regs.R28;
		/* 82263E6Ch case    1:*/		return 0x82263E70;
		  /* 82263E70h */ case    2:  		/* mr R31, R5 */
		/* 82263E70h case    2:*/		regs.R31 = regs.R5;
		/* 82263E70h case    2:*/		return 0x82263E74;
		  /* 82263E74h */ case    3:  		/* bl -293308 */
		/* 82263E74h case    3:*/		regs.LR = 0x82263E78; return 0x8221C4B8;
		/* 82263E74h case    3:*/		return 0x82263E78;
		  /* 82263E78h */ case    4:  		/* mr R11, R3 */
		/* 82263E78h case    4:*/		regs.R11 = regs.R3;
		/* 82263E78h case    4:*/		return 0x82263E7C;
		  /* 82263E7Ch */ case    5:  		/* addic. R3, R3, 4 */
		/* 82263E7Ch case    5:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82263E7Ch case    5:*/		return 0x82263E80;
		  /* 82263E80h */ case    6:  		/* stw R28, <#[R11]> */
		/* 82263E80h case    6:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000000) );
		/* 82263E80h case    6:*/		return 0x82263E84;
		  /* 82263E84h */ case    7:  		/* bc 12, CR0_EQ, 24 */
		/* 82263E84h case    7:*/		if ( regs.CR[0].eq ) { return 0x82263E9C;  }
		/* 82263E84h case    7:*/		return 0x82263E88;
		  /* 82263E88h */ case    8:  		/* mr R6, R31 */
		/* 82263E88h case    8:*/		regs.R6 = regs.R31;
		/* 82263E88h case    8:*/		return 0x82263E8C;
		  /* 82263E8Ch */ case    9:  		/* mr R5, R29 */
		/* 82263E8Ch case    9:*/		regs.R5 = regs.R29;
		/* 82263E8Ch case    9:*/		return 0x82263E90;
		  /* 82263E90h */ case   10:  		/* mr R4, R30 */
		/* 82263E90h case   10:*/		regs.R4 = regs.R30;
		/* 82263E90h case   10:*/		return 0x82263E94;
		  /* 82263E94h */ case   11:  		/* bl -58260 */
		/* 82263E94h case   11:*/		regs.LR = 0x82263E98; return 0x82255B00;
		/* 82263E94h case   11:*/		return 0x82263E98;
		  /* 82263E98h */ case   12:  		/* b 8 */
		/* 82263E98h case   12:*/		return 0x82263EA0;
		/* 82263E98h case   12:*/		return 0x82263E9C;
	}
	return 0x82263E9C;
} // Block from 82263E68h-82263E9Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 82263E9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263E9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263E9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263E9C);
		  /* 82263E9Ch */ case    0:  		/* li R3, 0 */
		/* 82263E9Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82263E9Ch case    0:*/		return 0x82263EA0;
	}
	return 0x82263EA0;
} // Block from 82263E9Ch-82263EA0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82263EA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263EA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263EA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263EA0);
		  /* 82263EA0h */ case    0:  		/* addi R1, R1, 128 */
		/* 82263EA0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82263EA0h case    0:*/		return 0x82263EA4;
		  /* 82263EA4h */ case    1:  		/* b -1911804 */
		/* 82263EA4h case    1:*/		return 0x820912A8;
		/* 82263EA4h case    1:*/		return 0x82263EA8;
	}
	return 0x82263EA8;
} // Block from 82263EA0h-82263EA8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82263EA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263EA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263EA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263EA8);
		  /* 82263EA8h */ case    0:  		/* mfspr R12, LR */
		/* 82263EA8h case    0:*/		regs.R12 = regs.LR;
		/* 82263EA8h case    0:*/		return 0x82263EAC;
		  /* 82263EACh */ case    1:  		/* bl -1911892 */
		/* 82263EACh case    1:*/		regs.LR = 0x82263EB0; return 0x82091258;
		/* 82263EACh case    1:*/		return 0x82263EB0;
		  /* 82263EB0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82263EB0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82263EB0h case    2:*/		return 0x82263EB4;
		  /* 82263EB4h */ case    3:  		/* lwz R28, <#[R5 + 1452]> */
		/* 82263EB4h case    3:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R5 + 0x000005AC) );
		/* 82263EB4h case    3:*/		return 0x82263EB8;
		  /* 82263EB8h */ case    4:  		/* mr R30, R3 */
		/* 82263EB8h case    4:*/		regs.R30 = regs.R3;
		/* 82263EB8h case    4:*/		return 0x82263EBC;
		  /* 82263EBCh */ case    5:  		/* mr R29, R4 */
		/* 82263EBCh case    5:*/		regs.R29 = regs.R4;
		/* 82263EBCh case    5:*/		return 0x82263EC0;
		  /* 82263EC0h */ case    6:  		/* li R4, 56 */
		/* 82263EC0h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x38);
		/* 82263EC0h case    6:*/		return 0x82263EC4;
		  /* 82263EC4h */ case    7:  		/* mr R3, R28 */
		/* 82263EC4h case    7:*/		regs.R3 = regs.R28;
		/* 82263EC4h case    7:*/		return 0x82263EC8;
		  /* 82263EC8h */ case    8:  		/* mr R31, R5 */
		/* 82263EC8h case    8:*/		regs.R31 = regs.R5;
		/* 82263EC8h case    8:*/		return 0x82263ECC;
		  /* 82263ECCh */ case    9:  		/* bl -293396 */
		/* 82263ECCh case    9:*/		regs.LR = 0x82263ED0; return 0x8221C4B8;
		/* 82263ECCh case    9:*/		return 0x82263ED0;
		  /* 82263ED0h */ case   10:  		/* mr R11, R3 */
		/* 82263ED0h case   10:*/		regs.R11 = regs.R3;
		/* 82263ED0h case   10:*/		return 0x82263ED4;
		  /* 82263ED4h */ case   11:  		/* addic. R3, R3, 4 */
		/* 82263ED4h case   11:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82263ED4h case   11:*/		return 0x82263ED8;
		  /* 82263ED8h */ case   12:  		/* stw R28, <#[R11]> */
		/* 82263ED8h case   12:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000000) );
		/* 82263ED8h case   12:*/		return 0x82263EDC;
		  /* 82263EDCh */ case   13:  		/* bc 12, CR0_EQ, 24 */
		/* 82263EDCh case   13:*/		if ( regs.CR[0].eq ) { return 0x82263EF4;  }
		/* 82263EDCh case   13:*/		return 0x82263EE0;
		  /* 82263EE0h */ case   14:  		/* mr R6, R31 */
		/* 82263EE0h case   14:*/		regs.R6 = regs.R31;
		/* 82263EE0h case   14:*/		return 0x82263EE4;
		  /* 82263EE4h */ case   15:  		/* mr R5, R29 */
		/* 82263EE4h case   15:*/		regs.R5 = regs.R29;
		/* 82263EE4h case   15:*/		return 0x82263EE8;
		  /* 82263EE8h */ case   16:  		/* mr R4, R30 */
		/* 82263EE8h case   16:*/		regs.R4 = regs.R30;
		/* 82263EE8h case   16:*/		return 0x82263EEC;
		  /* 82263EECh */ case   17:  		/* bl -59380 */
		/* 82263EECh case   17:*/		regs.LR = 0x82263EF0; return 0x822556F8;
		/* 82263EECh case   17:*/		return 0x82263EF0;
		  /* 82263EF0h */ case   18:  		/* b 8 */
		/* 82263EF0h case   18:*/		return 0x82263EF8;
		/* 82263EF0h case   18:*/		return 0x82263EF4;
	}
	return 0x82263EF4;
} // Block from 82263EA8h-82263EF4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82263EF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263EF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263EF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263EF4);
		  /* 82263EF4h */ case    0:  		/* li R3, 0 */
		/* 82263EF4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82263EF4h case    0:*/		return 0x82263EF8;
	}
	return 0x82263EF8;
} // Block from 82263EF4h-82263EF8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82263EF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263EF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263EF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263EF8);
		  /* 82263EF8h */ case    0:  		/* addi R1, R1, 128 */
		/* 82263EF8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82263EF8h case    0:*/		return 0x82263EFC;
		  /* 82263EFCh */ case    1:  		/* b -1911892 */
		/* 82263EFCh case    1:*/		return 0x820912A8;
		/* 82263EFCh case    1:*/		return 0x82263F00;
	}
	return 0x82263F00;
} // Block from 82263EF8h-82263F00h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82263F00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263F00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263F00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263F00);
		  /* 82263F00h */ case    0:  		/* mfspr R12, LR */
		/* 82263F00h case    0:*/		regs.R12 = regs.LR;
		/* 82263F00h case    0:*/		return 0x82263F04;
		  /* 82263F04h */ case    1:  		/* bl -1911980 */
		/* 82263F04h case    1:*/		regs.LR = 0x82263F08; return 0x82091258;
		/* 82263F04h case    1:*/		return 0x82263F08;
		  /* 82263F08h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82263F08h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82263F08h case    2:*/		return 0x82263F0C;
		  /* 82263F0Ch */ case    3:  		/* lwz R28, <#[R5 + 1452]> */
		/* 82263F0Ch case    3:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R5 + 0x000005AC) );
		/* 82263F0Ch case    3:*/		return 0x82263F10;
		  /* 82263F10h */ case    4:  		/* mr R30, R3 */
		/* 82263F10h case    4:*/		regs.R30 = regs.R3;
		/* 82263F10h case    4:*/		return 0x82263F14;
		  /* 82263F14h */ case    5:  		/* mr R29, R4 */
		/* 82263F14h case    5:*/		regs.R29 = regs.R4;
		/* 82263F14h case    5:*/		return 0x82263F18;
		  /* 82263F18h */ case    6:  		/* li R4, 52 */
		/* 82263F18h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x34);
		/* 82263F18h case    6:*/		return 0x82263F1C;
		  /* 82263F1Ch */ case    7:  		/* mr R3, R28 */
		/* 82263F1Ch case    7:*/		regs.R3 = regs.R28;
		/* 82263F1Ch case    7:*/		return 0x82263F20;
		  /* 82263F20h */ case    8:  		/* mr R31, R5 */
		/* 82263F20h case    8:*/		regs.R31 = regs.R5;
		/* 82263F20h case    8:*/		return 0x82263F24;
		  /* 82263F24h */ case    9:  		/* bl -293484 */
		/* 82263F24h case    9:*/		regs.LR = 0x82263F28; return 0x8221C4B8;
		/* 82263F24h case    9:*/		return 0x82263F28;
		  /* 82263F28h */ case   10:  		/* mr R11, R3 */
		/* 82263F28h case   10:*/		regs.R11 = regs.R3;
		/* 82263F28h case   10:*/		return 0x82263F2C;
		  /* 82263F2Ch */ case   11:  		/* addic. R3, R3, 4 */
		/* 82263F2Ch case   11:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82263F2Ch case   11:*/		return 0x82263F30;
		  /* 82263F30h */ case   12:  		/* stw R28, <#[R11]> */
		/* 82263F30h case   12:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000000) );
		/* 82263F30h case   12:*/		return 0x82263F34;
		  /* 82263F34h */ case   13:  		/* bc 12, CR0_EQ, 24 */
		/* 82263F34h case   13:*/		if ( regs.CR[0].eq ) { return 0x82263F4C;  }
		/* 82263F34h case   13:*/		return 0x82263F38;
		  /* 82263F38h */ case   14:  		/* mr R6, R31 */
		/* 82263F38h case   14:*/		regs.R6 = regs.R31;
		/* 82263F38h case   14:*/		return 0x82263F3C;
		  /* 82263F3Ch */ case   15:  		/* mr R5, R29 */
		/* 82263F3Ch case   15:*/		regs.R5 = regs.R29;
		/* 82263F3Ch case   15:*/		return 0x82263F40;
		  /* 82263F40h */ case   16:  		/* mr R4, R30 */
		/* 82263F40h case   16:*/		regs.R4 = regs.R30;
		/* 82263F40h case   16:*/		return 0x82263F44;
		  /* 82263F44h */ case   17:  		/* bl -58804 */
		/* 82263F44h case   17:*/		regs.LR = 0x82263F48; return 0x82255990;
		/* 82263F44h case   17:*/		return 0x82263F48;
		  /* 82263F48h */ case   18:  		/* b 8 */
		/* 82263F48h case   18:*/		return 0x82263F50;
		/* 82263F48h case   18:*/		return 0x82263F4C;
	}
	return 0x82263F4C;
} // Block from 82263F00h-82263F4Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 82263F4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263F4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263F4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263F4C);
		  /* 82263F4Ch */ case    0:  		/* li R3, 0 */
		/* 82263F4Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82263F4Ch case    0:*/		return 0x82263F50;
	}
	return 0x82263F50;
} // Block from 82263F4Ch-82263F50h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82263F50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263F50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263F50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263F50);
		  /* 82263F50h */ case    0:  		/* addi R1, R1, 128 */
		/* 82263F50h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82263F50h case    0:*/		return 0x82263F54;
		  /* 82263F54h */ case    1:  		/* b -1911980 */
		/* 82263F54h case    1:*/		return 0x820912A8;
		/* 82263F54h case    1:*/		return 0x82263F58;
	}
	return 0x82263F58;
} // Block from 82263F50h-82263F58h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82263F58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263F58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263F58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263F58);
		  /* 82263F58h */ case    0:  		/* mfspr R12, LR */
		/* 82263F58h case    0:*/		regs.R12 = regs.LR;
		/* 82263F58h case    0:*/		return 0x82263F5C;
		  /* 82263F5Ch */ case    1:  		/* bl -1912068 */
		/* 82263F5Ch case    1:*/		regs.LR = 0x82263F60; return 0x82091258;
		/* 82263F5Ch case    1:*/		return 0x82263F60;
	}
	return 0x82263F60;
} // Block from 82263F58h-82263F60h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82263F60h
// Function '?ClearNonLocalSet@CFG@XGRAPHICS@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263F60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263F60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263F60);
		  /* 82263F60h */ case    0:  		/* stwu R1, <#[R1 - 128]> */
		/* 82263F60h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82263F60h case    0:*/		return 0x82263F64;
		  /* 82263F64h */ case    1:  		/* lwz R28, <#[R5 + 1452]> */
		/* 82263F64h case    1:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R5 + 0x000005AC) );
		/* 82263F64h case    1:*/		return 0x82263F68;
		  /* 82263F68h */ case    2:  		/* mr R30, R3 */
		/* 82263F68h case    2:*/		regs.R30 = regs.R3;
		/* 82263F68h case    2:*/		return 0x82263F6C;
		  /* 82263F6Ch */ case    3:  		/* mr R29, R4 */
		/* 82263F6Ch case    3:*/		regs.R29 = regs.R4;
		/* 82263F6Ch case    3:*/		return 0x82263F70;
		  /* 82263F70h */ case    4:  		/* li R4, 52 */
		/* 82263F70h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x34);
		/* 82263F70h case    4:*/		return 0x82263F74;
		  /* 82263F74h */ case    5:  		/* mr R3, R28 */
		/* 82263F74h case    5:*/		regs.R3 = regs.R28;
		/* 82263F74h case    5:*/		return 0x82263F78;
		  /* 82263F78h */ case    6:  		/* mr R31, R5 */
		/* 82263F78h case    6:*/		regs.R31 = regs.R5;
		/* 82263F78h case    6:*/		return 0x82263F7C;
		  /* 82263F7Ch */ case    7:  		/* bl -293572 */
		/* 82263F7Ch case    7:*/		regs.LR = 0x82263F80; return 0x8221C4B8;
		/* 82263F7Ch case    7:*/		return 0x82263F80;
		  /* 82263F80h */ case    8:  		/* mr R11, R3 */
		/* 82263F80h case    8:*/		regs.R11 = regs.R3;
		/* 82263F80h case    8:*/		return 0x82263F84;
		  /* 82263F84h */ case    9:  		/* addic. R3, R3, 4 */
		/* 82263F84h case    9:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82263F84h case    9:*/		return 0x82263F88;
		  /* 82263F88h */ case   10:  		/* stw R28, <#[R11]> */
		/* 82263F88h case   10:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000000) );
		/* 82263F88h case   10:*/		return 0x82263F8C;
		  /* 82263F8Ch */ case   11:  		/* bc 12, CR0_EQ, 24 */
		/* 82263F8Ch case   11:*/		if ( regs.CR[0].eq ) { return 0x82263FA4;  }
		/* 82263F8Ch case   11:*/		return 0x82263F90;
		  /* 82263F90h */ case   12:  		/* mr R6, R31 */
		/* 82263F90h case   12:*/		regs.R6 = regs.R31;
		/* 82263F90h case   12:*/		return 0x82263F94;
		  /* 82263F94h */ case   13:  		/* mr R5, R29 */
		/* 82263F94h case   13:*/		regs.R5 = regs.R29;
		/* 82263F94h case   13:*/		return 0x82263F98;
	}
	return 0x82263F98;
} // Block from 82263F60h-82263F98h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82263F98h
// Function '?ReleaseLiveSets@CFG@XGRAPHICS@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263F98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263F98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263F98);
		  /* 82263F98h */ case    0:  		/* mr R4, R30 */
		/* 82263F98h case    0:*/		regs.R4 = regs.R30;
		/* 82263F98h case    0:*/		return 0x82263F9C;
		  /* 82263F9Ch */ case    1:  		/* bl -58756 */
		/* 82263F9Ch case    1:*/		regs.LR = 0x82263FA0; return 0x82255A18;
		/* 82263F9Ch case    1:*/		return 0x82263FA0;
		  /* 82263FA0h */ case    2:  		/* b 8 */
		/* 82263FA0h case    2:*/		return 0x82263FA8;
		/* 82263FA0h case    2:*/		return 0x82263FA4;
	}
	return 0x82263FA4;
} // Block from 82263F98h-82263FA4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82263FA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263FA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263FA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263FA4);
		  /* 82263FA4h */ case    0:  		/* li R3, 0 */
		/* 82263FA4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82263FA4h case    0:*/		return 0x82263FA8;
	}
	return 0x82263FA8;
} // Block from 82263FA4h-82263FA8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82263FA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263FA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263FA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263FA8);
		  /* 82263FA8h */ case    0:  		/* addi R1, R1, 128 */
		/* 82263FA8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82263FA8h case    0:*/		return 0x82263FAC;
		  /* 82263FACh */ case    1:  		/* b -1912068 */
		/* 82263FACh case    1:*/		return 0x820912A8;
		/* 82263FACh case    1:*/		return 0x82263FB0;
	}
	return 0x82263FB0;
} // Block from 82263FA8h-82263FB0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82263FB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263FB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263FB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263FB0);
		  /* 82263FB0h */ case    0:  		/* mfspr R12, LR */
		/* 82263FB0h case    0:*/		regs.R12 = regs.LR;
		/* 82263FB0h case    0:*/		return 0x82263FB4;
		  /* 82263FB4h */ case    1:  		/* bl -1912156 */
		/* 82263FB4h case    1:*/		regs.LR = 0x82263FB8; return 0x82091258;
		/* 82263FB4h case    1:*/		return 0x82263FB8;
		  /* 82263FB8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82263FB8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82263FB8h case    2:*/		return 0x82263FBC;
		  /* 82263FBCh */ case    3:  		/* lwz R28, <#[R5 + 1452]> */
		/* 82263FBCh case    3:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R5 + 0x000005AC) );
		/* 82263FBCh case    3:*/		return 0x82263FC0;
		  /* 82263FC0h */ case    4:  		/* mr R30, R3 */
		/* 82263FC0h case    4:*/		regs.R30 = regs.R3;
		/* 82263FC0h case    4:*/		return 0x82263FC4;
		  /* 82263FC4h */ case    5:  		/* mr R29, R4 */
		/* 82263FC4h case    5:*/		regs.R29 = regs.R4;
		/* 82263FC4h case    5:*/		return 0x82263FC8;
		  /* 82263FC8h */ case    6:  		/* li R4, 52 */
		/* 82263FC8h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x34);
		/* 82263FC8h case    6:*/		return 0x82263FCC;
		  /* 82263FCCh */ case    7:  		/* mr R3, R28 */
		/* 82263FCCh case    7:*/		regs.R3 = regs.R28;
		/* 82263FCCh case    7:*/		return 0x82263FD0;
		  /* 82263FD0h */ case    8:  		/* mr R31, R5 */
		/* 82263FD0h case    8:*/		regs.R31 = regs.R5;
		/* 82263FD0h case    8:*/		return 0x82263FD4;
		  /* 82263FD4h */ case    9:  		/* bl -293660 */
		/* 82263FD4h case    9:*/		regs.LR = 0x82263FD8; return 0x8221C4B8;
		/* 82263FD4h case    9:*/		return 0x82263FD8;
		  /* 82263FD8h */ case   10:  		/* mr R11, R3 */
		/* 82263FD8h case   10:*/		regs.R11 = regs.R3;
		/* 82263FD8h case   10:*/		return 0x82263FDC;
		  /* 82263FDCh */ case   11:  		/* addic. R3, R3, 4 */
		/* 82263FDCh case   11:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82263FDCh case   11:*/		return 0x82263FE0;
		  /* 82263FE0h */ case   12:  		/* stw R28, <#[R11]> */
		/* 82263FE0h case   12:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000000) );
		/* 82263FE0h case   12:*/		return 0x82263FE4;
		  /* 82263FE4h */ case   13:  		/* bc 12, CR0_EQ, 24 */
		/* 82263FE4h case   13:*/		if ( regs.CR[0].eq ) { return 0x82263FFC;  }
		/* 82263FE4h case   13:*/		return 0x82263FE8;
		  /* 82263FE8h */ case   14:  		/* mr R6, R31 */
		/* 82263FE8h case   14:*/		regs.R6 = regs.R31;
		/* 82263FE8h case   14:*/		return 0x82263FEC;
		  /* 82263FECh */ case   15:  		/* mr R5, R29 */
		/* 82263FECh case   15:*/		regs.R5 = regs.R29;
		/* 82263FECh case   15:*/		return 0x82263FF0;
		  /* 82263FF0h */ case   16:  		/* mr R4, R30 */
		/* 82263FF0h case   16:*/		regs.R4 = regs.R30;
		/* 82263FF0h case   16:*/		return 0x82263FF4;
		  /* 82263FF4h */ case   17:  		/* bl -61284 */
		/* 82263FF4h case   17:*/		regs.LR = 0x82263FF8; return 0x82255090;
		/* 82263FF4h case   17:*/		return 0x82263FF8;
		  /* 82263FF8h */ case   18:  		/* b 8 */
		/* 82263FF8h case   18:*/		return 0x82264000;
		/* 82263FF8h case   18:*/		return 0x82263FFC;
	}
	return 0x82263FFC;
} // Block from 82263FB0h-82263FFCh (19 instructions)

//////////////////////////////////////////////////////
// Block at 82263FFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82263FFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82263FFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82263FFC);
		  /* 82263FFCh */ case    0:  		/* li R3, 0 */
		/* 82263FFCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82263FFCh case    0:*/		return 0x82264000;
	}
	return 0x82264000;
} // Block from 82263FFCh-82264000h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82264000h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264000( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264000) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264000);
		  /* 82264000h */ case    0:  		/* addi R1, R1, 128 */
		/* 82264000h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82264000h case    0:*/		return 0x82264004;
		  /* 82264004h */ case    1:  		/* b -1912156 */
		/* 82264004h case    1:*/		return 0x820912A8;
		/* 82264004h case    1:*/		return 0x82264008;
	}
	return 0x82264008;
} // Block from 82264000h-82264008h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82264008h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264008( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264008) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264008);
		  /* 82264008h */ case    0:  		/* mfspr R12, LR */
		/* 82264008h case    0:*/		regs.R12 = regs.LR;
		/* 82264008h case    0:*/		return 0x8226400C;
		  /* 8226400Ch */ case    1:  		/* bl -1912244 */
		/* 8226400Ch case    1:*/		regs.LR = 0x82264010; return 0x82091258;
		/* 8226400Ch case    1:*/		return 0x82264010;
		  /* 82264010h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82264010h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82264010h case    2:*/		return 0x82264014;
		  /* 82264014h */ case    3:  		/* lwz R28, <#[R5 + 1452]> */
		/* 82264014h case    3:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R5 + 0x000005AC) );
		/* 82264014h case    3:*/		return 0x82264018;
		  /* 82264018h */ case    4:  		/* mr R30, R3 */
		/* 82264018h case    4:*/		regs.R30 = regs.R3;
		/* 82264018h case    4:*/		return 0x8226401C;
		  /* 8226401Ch */ case    5:  		/* mr R29, R4 */
		/* 8226401Ch case    5:*/		regs.R29 = regs.R4;
		/* 8226401Ch case    5:*/		return 0x82264020;
		  /* 82264020h */ case    6:  		/* li R4, 60 */
		/* 82264020h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x3C);
		/* 82264020h case    6:*/		return 0x82264024;
		  /* 82264024h */ case    7:  		/* mr R3, R28 */
		/* 82264024h case    7:*/		regs.R3 = regs.R28;
		/* 82264024h case    7:*/		return 0x82264028;
		  /* 82264028h */ case    8:  		/* mr R31, R5 */
		/* 82264028h case    8:*/		regs.R31 = regs.R5;
		/* 82264028h case    8:*/		return 0x8226402C;
		  /* 8226402Ch */ case    9:  		/* bl -293748 */
		/* 8226402Ch case    9:*/		regs.LR = 0x82264030; return 0x8221C4B8;
		/* 8226402Ch case    9:*/		return 0x82264030;
		  /* 82264030h */ case   10:  		/* mr R11, R3 */
		/* 82264030h case   10:*/		regs.R11 = regs.R3;
		/* 82264030h case   10:*/		return 0x82264034;
		  /* 82264034h */ case   11:  		/* addic. R3, R3, 4 */
		/* 82264034h case   11:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82264034h case   11:*/		return 0x82264038;
		  /* 82264038h */ case   12:  		/* stw R28, <#[R11]> */
		/* 82264038h case   12:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000000) );
		/* 82264038h case   12:*/		return 0x8226403C;
		  /* 8226403Ch */ case   13:  		/* bc 12, CR0_EQ, 24 */
		/* 8226403Ch case   13:*/		if ( regs.CR[0].eq ) { return 0x82264054;  }
		/* 8226403Ch case   13:*/		return 0x82264040;
		  /* 82264040h */ case   14:  		/* mr R6, R31 */
		/* 82264040h case   14:*/		regs.R6 = regs.R31;
		/* 82264040h case   14:*/		return 0x82264044;
		  /* 82264044h */ case   15:  		/* mr R5, R29 */
		/* 82264044h case   15:*/		regs.R5 = regs.R29;
		/* 82264044h case   15:*/		return 0x82264048;
	}
	return 0x82264048;
} // Block from 82264008h-82264048h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82264048h
// Function '?FindGlobalResources@CFG@XGRAPHICS@@AAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264048( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264048) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264048);
		  /* 82264048h */ case    0:  		/* mr R4, R30 */
		/* 82264048h case    0:*/		regs.R4 = regs.R30;
		/* 82264048h case    0:*/		return 0x8226404C;
		  /* 8226404Ch */ case    1:  		/* bl -61932 */
		/* 8226404Ch case    1:*/		regs.LR = 0x82264050; return 0x82254E60;
		/* 8226404Ch case    1:*/		return 0x82264050;
		  /* 82264050h */ case    2:  		/* b 8 */
		/* 82264050h case    2:*/		return 0x82264058;
		/* 82264050h case    2:*/		return 0x82264054;
	}
	return 0x82264054;
} // Block from 82264048h-82264054h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82264054h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264054( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264054) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264054);
		  /* 82264054h */ case    0:  		/* li R3, 0 */
		/* 82264054h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82264054h case    0:*/		return 0x82264058;
	}
	return 0x82264058;
} // Block from 82264054h-82264058h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82264058h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264058( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264058) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264058);
		  /* 82264058h */ case    0:  		/* addi R1, R1, 128 */
		/* 82264058h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82264058h case    0:*/		return 0x8226405C;
		  /* 8226405Ch */ case    1:  		/* b -1912244 */
		/* 8226405Ch case    1:*/		return 0x820912A8;
		/* 8226405Ch case    1:*/		return 0x82264060;
	}
	return 0x82264060;
} // Block from 82264058h-82264060h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82264060h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264060( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264060) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264060);
		  /* 82264060h */ case    0:  		/* mfspr R12, LR */
		/* 82264060h case    0:*/		regs.R12 = regs.LR;
		/* 82264060h case    0:*/		return 0x82264064;
		  /* 82264064h */ case    1:  		/* bl -1912332 */
		/* 82264064h case    1:*/		regs.LR = 0x82264068; return 0x82091258;
		/* 82264064h case    1:*/		return 0x82264068;
		  /* 82264068h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82264068h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82264068h case    2:*/		return 0x8226406C;
		  /* 8226406Ch */ case    3:  		/* lwz R28, <#[R5 + 1452]> */
		/* 8226406Ch case    3:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R5 + 0x000005AC) );
		/* 8226406Ch case    3:*/		return 0x82264070;
		  /* 82264070h */ case    4:  		/* mr R30, R3 */
		/* 82264070h case    4:*/		regs.R30 = regs.R3;
		/* 82264070h case    4:*/		return 0x82264074;
		  /* 82264074h */ case    5:  		/* mr R29, R4 */
		/* 82264074h case    5:*/		regs.R29 = regs.R4;
		/* 82264074h case    5:*/		return 0x82264078;
		  /* 82264078h */ case    6:  		/* li R4, 56 */
		/* 82264078h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x38);
		/* 82264078h case    6:*/		return 0x8226407C;
		  /* 8226407Ch */ case    7:  		/* mr R3, R28 */
		/* 8226407Ch case    7:*/		regs.R3 = regs.R28;
		/* 8226407Ch case    7:*/		return 0x82264080;
		  /* 82264080h */ case    8:  		/* mr R31, R5 */
		/* 82264080h case    8:*/		regs.R31 = regs.R5;
		/* 82264080h case    8:*/		return 0x82264084;
		  /* 82264084h */ case    9:  		/* bl -293836 */
		/* 82264084h case    9:*/		regs.LR = 0x82264088; return 0x8221C4B8;
		/* 82264084h case    9:*/		return 0x82264088;
		  /* 82264088h */ case   10:  		/* mr R11, R3 */
		/* 82264088h case   10:*/		regs.R11 = regs.R3;
		/* 82264088h case   10:*/		return 0x8226408C;
		  /* 8226408Ch */ case   11:  		/* addic. R3, R3, 4 */
		/* 8226408Ch case   11:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 8226408Ch case   11:*/		return 0x82264090;
		  /* 82264090h */ case   12:  		/* stw R28, <#[R11]> */
		/* 82264090h case   12:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000000) );
		/* 82264090h case   12:*/		return 0x82264094;
		  /* 82264094h */ case   13:  		/* bc 12, CR0_EQ, 24 */
		/* 82264094h case   13:*/		if ( regs.CR[0].eq ) { return 0x822640AC;  }
		/* 82264094h case   13:*/		return 0x82264098;
		  /* 82264098h */ case   14:  		/* mr R6, R31 */
		/* 82264098h case   14:*/		regs.R6 = regs.R31;
		/* 82264098h case   14:*/		return 0x8226409C;
		  /* 8226409Ch */ case   15:  		/* mr R5, R29 */
		/* 8226409Ch case   15:*/		regs.R5 = regs.R29;
		/* 8226409Ch case   15:*/		return 0x822640A0;
		  /* 822640A0h */ case   16:  		/* mr R4, R30 */
		/* 822640A0h case   16:*/		regs.R4 = regs.R30;
		/* 822640A0h case   16:*/		return 0x822640A4;
		  /* 822640A4h */ case   17:  		/* bl -60100 */
		/* 822640A4h case   17:*/		regs.LR = 0x822640A8; return 0x822555E0;
		/* 822640A4h case   17:*/		return 0x822640A8;
		  /* 822640A8h */ case   18:  		/* b 8 */
		/* 822640A8h case   18:*/		return 0x822640B0;
		/* 822640A8h case   18:*/		return 0x822640AC;
	}
	return 0x822640AC;
} // Block from 82264060h-822640ACh (19 instructions)

//////////////////////////////////////////////////////
// Block at 822640ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822640AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822640AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822640AC);
		  /* 822640ACh */ case    0:  		/* li R3, 0 */
		/* 822640ACh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822640ACh case    0:*/		return 0x822640B0;
	}
	return 0x822640B0;
} // Block from 822640ACh-822640B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822640B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822640B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822640B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822640B0);
		  /* 822640B0h */ case    0:  		/* addi R1, R1, 128 */
		/* 822640B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 822640B0h case    0:*/		return 0x822640B4;
		  /* 822640B4h */ case    1:  		/* b -1912332 */
		/* 822640B4h case    1:*/		return 0x820912A8;
		/* 822640B4h case    1:*/		return 0x822640B8;
		  /* 822640B8h */ case    2:  		/* lwz R11, <#[R3 + 8]> */
		/* 822640B8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 822640B8h case    2:*/		return 0x822640BC;
		  /* 822640BCh */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 822640BCh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822640BCh case    3:*/		return 0x822640C0;
		  /* 822640C0h */ case    4:  		/* li R11, 0 */
		/* 822640C0h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822640C0h case    4:*/		return 0x822640C4;
		  /* 822640C4h */ case    5:  		/* bc 4, CR6_EQ, 20 */
		/* 822640C4h case    5:*/		if ( !regs.CR[6].eq ) { return 0x822640D8;  }
		/* 822640C4h case    5:*/		return 0x822640C8;
		  /* 822640C8h */ case    6:  		/* li R10, 6 */
		/* 822640C8h case    6:*/		cpu::op::li<0>(regs,&regs.R10,0x6);
		/* 822640C8h case    6:*/		return 0x822640CC;
		  /* 822640CCh */ case    7:  		/* stw R11, <#[R5]> */
		/* 822640CCh case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 822640CCh case    7:*/		return 0x822640D0;
		  /* 822640D0h */ case    8:  		/* stw R10, <#[R4]> */
		/* 822640D0h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 822640D0h case    8:*/		return 0x822640D4;
		  /* 822640D4h */ case    9:  		/* bclr 20, CR0_LT */
		/* 822640D4h case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822640D4h case    9:*/		return 0x822640D8;
	}
	return 0x822640D8;
} // Block from 822640B0h-822640D8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 822640D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822640D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822640D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822640D8);
		  /* 822640D8h */ case    0:  		/* stw R11, <#[R4]> */
		/* 822640D8h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 822640D8h case    0:*/		return 0x822640DC;
		  /* 822640DCh */ case    1:  		/* lwz R11, <#[R3 + 8]> */
		/* 822640DCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 822640DCh case    1:*/		return 0x822640E0;
		  /* 822640E0h */ case    2:  		/* b 24 */
		/* 822640E0h case    2:*/		return 0x822640F8;
		/* 822640E0h case    2:*/		return 0x822640E4;
		  /* 822640E4h */ case    3:  		/* lwz R11, <#[R4]> */
		/* 822640E4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 822640E4h case    3:*/		return 0x822640E8;
		  /* 822640E8h */ case    4:  		/* addi R11, R11, 7 */
		/* 822640E8h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x7);
		/* 822640E8h case    4:*/		return 0x822640EC;
		  /* 822640ECh */ case    5:  		/* stw R11, <#[R4]> */
		/* 822640ECh case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 822640ECh case    5:*/		return 0x822640F0;
	}
	return 0x822640F0;
} // Block from 822640D8h-822640F0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822640F0h
// Function '?BuildLiveSets@CFG@XGRAPHICS@@QAAXH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822640F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822640F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822640F0);
		  /* 822640F0h */ case    0:  		/* lwz R11, <#[R5]> */
		/* 822640F0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 822640F0h case    0:*/		return 0x822640F4;
		  /* 822640F4h */ case    1:  		/* lwz R11, <#[R11 + 28]> */
		/* 822640F4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 822640F4h case    1:*/		return 0x822640F8;
	}
	return 0x822640F8;
} // Block from 822640F0h-822640F8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822640F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822640F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822640F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822640F8);
		  /* 822640F8h */ case    0:  		/* stw R11, <#[R5]> */
		/* 822640F8h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 822640F8h case    0:*/		return 0x822640FC;
		  /* 822640FCh */ case    1:  		/* lwz R11, <#[R3 + 4]> */
		/* 822640FCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 822640FCh case    1:*/		return 0x82264100;
		  /* 82264100h */ case    2:  		/* lwz R10, <#[R4]> */
		/* 82264100h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 82264100h case    2:*/		return 0x82264104;
		  /* 82264104h */ case    3:  		/* addi R10, R10, 7 */
		/* 82264104h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x7);
		/* 82264104h case    3:*/		return 0x82264108;
		  /* 82264108h */ case    4:  		/* cmpw CR6, R10, R11 */
		/* 82264108h case    4:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R11);
		/* 82264108h case    4:*/		return 0x8226410C;
		  /* 8226410Ch */ case    5:  		/* bc 12, CR6_LT, -40 */
		/* 8226410Ch case    5:*/		if ( regs.CR[6].lt ) { return 0x822640E4;  }
		/* 8226410Ch case    5:*/		return 0x82264110;
		  /* 82264110h */ case    6:  		/* lwz R10, <#[R4]> */
		/* 82264110h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 82264110h case    6:*/		return 0x82264114;
		  /* 82264114h */ case    7:  		/* subf R11, R10, R11 */
		/* 82264114h case    7:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82264114h case    7:*/		return 0x82264118;
		  /* 82264118h */ case    8:  		/* addi R11, R11, -1 */
		/* 82264118h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82264118h case    8:*/		return 0x8226411C;
		  /* 8226411Ch */ case    9:  		/* stw R11, <#[R4]> */
		/* 8226411Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 8226411Ch case    9:*/		return 0x82264120;
		  /* 82264120h */ case   10:  		/* bclr 20, CR0_LT */
		/* 82264120h case   10:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82264120h case   10:*/		return 0x82264124;
	}
	return 0x82264124;
} // Block from 822640F8h-82264124h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82264124h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264124( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264124) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264124);
		  /* 82264124h */ case    0:  		/* nop */
		/* 82264124h case    0:*/		cpu::op::nop();
		/* 82264124h case    0:*/		return 0x82264128;
	}
	return 0x82264128;
} // Block from 82264124h-82264128h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82264128h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264128( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264128) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264128);
		  /* 82264128h */ case    0:  		/* mfspr R12, LR */
		/* 82264128h case    0:*/		regs.R12 = regs.LR;
		/* 82264128h case    0:*/		return 0x8226412C;
		  /* 8226412Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8226412Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8226412Ch case    1:*/		return 0x82264130;
		  /* 82264130h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82264130h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82264130h case    2:*/		return 0x82264134;
		  /* 82264134h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82264134h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82264134h case    3:*/		return 0x82264138;
		  /* 82264138h */ case    4:  		/* rlwinm. R11, R5, 0, 24, 31 */
		/* 82264138h case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R5);
		/* 82264138h case    4:*/		return 0x8226413C;
		  /* 8226413Ch */ case    5:  		/* mr R31, R3 */
		/* 8226413Ch case    5:*/		regs.R31 = regs.R3;
		/* 8226413Ch case    5:*/		return 0x82264140;
		  /* 82264140h */ case    6:  		/* lis R11, -32215 */
		/* 82264140h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 82264140h case    6:*/		return 0x82264144;
		  /* 82264144h */ case    7:  		/* bc 12, CR0_EQ, 76 */
		/* 82264144h case    7:*/		if ( regs.CR[0].eq ) { return 0x82264190;  }
		/* 82264144h case    7:*/		return 0x82264148;
		  /* 82264148h */ case    8:  		/* mr R3, R4 */
		/* 82264148h case    8:*/		regs.R3 = regs.R4;
		/* 82264148h case    8:*/		return 0x8226414C;
		  /* 8226414Ch */ case    9:  		/* lwz R4, <#[R11 - 25556]> */
		/* 8226414Ch case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0xFFFF9C2C) );
		/* 8226414Ch case    9:*/		return 0x82264150;
		  /* 82264150h */ case   10:  		/* bl 11496 */
		/* 82264150h case   10:*/		regs.LR = 0x82264154; return 0x82266E38;
		/* 82264150h case   10:*/		return 0x82264154;
		  /* 82264154h */ case   11:  		/* lwz R11, <#[R31 + 16]> */
		/* 82264154h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82264154h case   11:*/		return 0x82264158;
		  /* 82264158h */ case   12:  		/* mr R31, R3 */
		/* 82264158h case   12:*/		regs.R31 = regs.R3;
		/* 82264158h case   12:*/		return 0x8226415C;
		  /* 8226415Ch */ case   13:  		/* cmpw CR6, R3, R11 */
		/* 8226415Ch case   13:*/		cpu::op::cmpw<6>(regs,regs.R3,regs.R11);
		/* 8226415Ch case   13:*/		return 0x82264160;
		  /* 82264160h */ case   14:  		/* bc 12, CR6_LT, 40 */
		/* 82264160h case   14:*/		if ( regs.CR[6].lt ) { return 0x82264188;  }
		/* 82264160h case   14:*/		return 0x82264164;
		  /* 82264164h */ case   15:  		/* lis R11, -32251 */
		/* 82264164h case   15:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82264164h case   15:*/		return 0x82264168;
		  /* 82264168h */ case   16:  		/* lis R10, -32251 */
		/* 82264168h case   16:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 82264168h case   16:*/		return 0x8226416C;
		  /* 8226416Ch */ case   17:  		/* lis R9, -32253 */
		/* 8226416Ch case   17:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 8226416Ch case   17:*/		return 0x82264170;
		  /* 82264170h */ case   18:  		/* addi R6, R11, -18488 */
		/* 82264170h case   18:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFB7C8);
		/* 82264170h case   18:*/		return 0x82264174;
		  /* 82264174h */ case   19:  		/* addi R5, R10, -18388 */
		/* 82264174h case   19:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0xFFFFB82C);
		/* 82264174h case   19:*/		return 0x82264178;
		  /* 82264178h */ case   20:  		/* addi R4, R9, 27460 */
		/* 82264178h case   20:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 82264178h case   20:*/		return 0x8226417C;
		  /* 8226417Ch */ case   21:  		/* li R7, 638 */
		/* 8226417Ch case   21:*/		cpu::op::li<0>(regs,&regs.R7,0x27E);
		/* 8226417Ch case   21:*/		return 0x82264180;
		  /* 82264180h */ case   22:  		/* li R3, 0 */
		/* 82264180h case   22:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82264180h case   22:*/		return 0x82264184;
		  /* 82264184h */ case   23:  		/* bl -1099132 */
		/* 82264184h case   23:*/		regs.LR = 0x82264188; return 0x82157C08;
		/* 82264184h case   23:*/		return 0x82264188;
	}
	return 0x82264188;
} // Block from 82264128h-82264188h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82264188h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264188( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264188) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264188);
		  /* 82264188h */ case    0:  		/* mr R3, R31 */
		/* 82264188h case    0:*/		regs.R3 = regs.R31;
		/* 82264188h case    0:*/		return 0x8226418C;
		  /* 8226418Ch */ case    1:  		/* b 16 */
		/* 8226418Ch case    1:*/		return 0x8226419C;
		/* 8226418Ch case    1:*/		return 0x82264190;
	}
	return 0x82264190;
} // Block from 82264188h-82264190h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82264190h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264190( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264190) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264190);
		  /* 82264190h */ case    0:  		/* lwz R11, <#[R11 - 25556]> */
		/* 82264190h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFF9C2C) );
		/* 82264190h case    0:*/		return 0x82264194;
		  /* 82264194h */ case    1:  		/* rlwinm R10, R4, 2, 0, 29 */
		/* 82264194h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R4);
		/* 82264194h case    1:*/		return 0x82264198;
		  /* 82264198h */ case    2:  		/* lwzx R3, <#[R10 + R11]> */
		/* 82264198h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82264198h case    2:*/		return 0x8226419C;
	}
	return 0x8226419C;
} // Block from 82264190h-8226419Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8226419Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226419C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226419C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226419C);
		  /* 8226419Ch */ case    0:  		/* addi R1, R1, 96 */
		/* 8226419Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8226419Ch case    0:*/		return 0x822641A0;
		  /* 822641A0h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 822641A0h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822641A0h case    1:*/		return 0x822641A4;
		  /* 822641A4h */ case    2:  		/* mtspr LR, R12 */
		/* 822641A4h case    2:*/		regs.LR = regs.R12;
		/* 822641A4h case    2:*/		return 0x822641A8;
		  /* 822641A8h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 822641A8h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822641A8h case    3:*/		return 0x822641AC;
		  /* 822641ACh */ case    4:  		/* bclr 20, CR0_LT */
		/* 822641ACh case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822641ACh case    4:*/		return 0x822641B0;
	}
	return 0x822641B0;
} // Block from 8226419Ch-822641B0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822641B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822641B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822641B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822641B0);
		  /* 822641B0h */ case    0:  		/* mfspr R12, LR */
		/* 822641B0h case    0:*/		regs.R12 = regs.LR;
		/* 822641B0h case    0:*/		return 0x822641B4;
		  /* 822641B4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 822641B4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822641B4h case    1:*/		return 0x822641B8;
		  /* 822641B8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 822641B8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 822641B8h case    2:*/		return 0x822641BC;
		  /* 822641BCh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 822641BCh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822641BCh case    3:*/		return 0x822641C0;
		  /* 822641C0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 822641C0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 822641C0h case    4:*/		return 0x822641C4;
		  /* 822641C4h */ case    5:  		/* mr R31, R4 */
		/* 822641C4h case    5:*/		regs.R31 = regs.R4;
		/* 822641C4h case    5:*/		return 0x822641C8;
		  /* 822641C8h */ case    6:  		/* mr R30, R5 */
		/* 822641C8h case    6:*/		regs.R30 = regs.R5;
		/* 822641C8h case    6:*/		return 0x822641CC;
		  /* 822641CCh */ case    7:  		/* cmpw CR6, R4, R5 */
		/* 822641CCh case    7:*/		cpu::op::cmpw<6>(regs,regs.R4,regs.R5);
		/* 822641CCh case    7:*/		return 0x822641D0;
		  /* 822641D0h */ case    8:  		/* bc 4, CR6_EQ, 44 */
		/* 822641D0h case    8:*/		if ( !regs.CR[6].eq ) { return 0x822641FC;  }
		/* 822641D0h case    8:*/		return 0x822641D4;
		  /* 822641D4h */ case    9:  		/* lis R11, -32251 */
		/* 822641D4h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 822641D4h case    9:*/		return 0x822641D8;
		  /* 822641D8h */ case   10:  		/* lis R10, -32251 */
		/* 822641D8h case   10:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 822641D8h case   10:*/		return 0x822641DC;
		  /* 822641DCh */ case   11:  		/* lis R9, -32253 */
		/* 822641DCh case   11:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 822641DCh case   11:*/		return 0x822641E0;
		  /* 822641E0h */ case   12:  		/* addi R6, R11, -18488 */
		/* 822641E0h case   12:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFB7C8);
		/* 822641E0h case   12:*/		return 0x822641E4;
		  /* 822641E4h */ case   13:  		/* addi R5, R10, -18368 */
		/* 822641E4h case   13:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0xFFFFB840);
		/* 822641E4h case   13:*/		return 0x822641E8;
		  /* 822641E8h */ case   14:  		/* addi R4, R9, 27460 */
		/* 822641E8h case   14:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 822641E8h case   14:*/		return 0x822641EC;
		  /* 822641ECh */ case   15:  		/* li R7, 690 */
		/* 822641ECh case   15:*/		cpu::op::li<0>(regs,&regs.R7,0x2B2);
		/* 822641ECh case   15:*/		return 0x822641F0;
		  /* 822641F0h */ case   16:  		/* li R3, 0 */
		/* 822641F0h case   16:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822641F0h case   16:*/		return 0x822641F4;
		  /* 822641F4h */ case   17:  		/* bl -1099244 */
		/* 822641F4h case   17:*/		regs.LR = 0x822641F8; return 0x82157C08;
		/* 822641F4h case   17:*/		return 0x822641F8;
		  /* 822641F8h */ case   18:  		/* cmpw CR6, R31, R30 */
		/* 822641F8h case   18:*/		cpu::op::cmpw<6>(regs,regs.R31,regs.R30);
		/* 822641F8h case   18:*/		return 0x822641FC;
	}
	return 0x822641FC;
} // Block from 822641B0h-822641FCh (19 instructions)

//////////////////////////////////////////////////////
// Block at 822641FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822641FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822641FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822641FC);
		  /* 822641FCh */ case    0:  		/* mr R10, R31 */
		/* 822641FCh case    0:*/		regs.R10 = regs.R31;
		/* 822641FCh case    0:*/		return 0x82264200;
		  /* 82264200h */ case    1:  		/* bc 12, CR6_LT, 8 */
		/* 82264200h case    1:*/		if ( regs.CR[6].lt ) { return 0x82264208;  }
		/* 82264200h case    1:*/		return 0x82264204;
		  /* 82264204h */ case    2:  		/* mr R10, R30 */
		/* 82264204h case    2:*/		regs.R10 = regs.R30;
		/* 82264204h case    2:*/		return 0x82264208;
	}
	return 0x82264208;
} // Block from 822641FCh-82264208h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82264208h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264208( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264208) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264208);
		  /* 82264208h */ case    0:  		/* cmpw CR6, R31, R30 */
		/* 82264208h case    0:*/		cpu::op::cmpw<6>(regs,regs.R31,regs.R30);
		/* 82264208h case    0:*/		return 0x8226420C;
		  /* 8226420Ch */ case    1:  		/* mr R11, R31 */
		/* 8226420Ch case    1:*/		regs.R11 = regs.R31;
		/* 8226420Ch case    1:*/		return 0x82264210;
		  /* 82264210h */ case    2:  		/* bc 12, CR6_GT, 8 */
		/* 82264210h case    2:*/		if ( regs.CR[6].gt ) { return 0x82264218;  }
		/* 82264210h case    2:*/		return 0x82264214;
		  /* 82264214h */ case    3:  		/* mr R11, R30 */
		/* 82264214h case    3:*/		regs.R11 = regs.R30;
		/* 82264214h case    3:*/		return 0x82264218;
	}
	return 0x82264218;
} // Block from 82264208h-82264218h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82264218h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264218( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264218) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264218);
		  /* 82264218h */ case    0:  		/* addi R9, R11, -1 */
		/* 82264218h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFFF);
		/* 82264218h case    0:*/		return 0x8226421C;
		  /* 8226421Ch */ case    1:  		/* mullw R11, R9, R11 */
		/* 8226421Ch case    1:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 8226421Ch case    1:*/		return 0x82264220;
		  /* 82264220h */ case    2:  		/* srawi R11, R11, 1 */
		/* 82264220h case    2:*/		cpu::op::srawi<0,1>(regs,&regs.R11,regs.R11);
		/* 82264220h case    2:*/		return 0x82264224;
		  /* 82264224h */ case    3:  		/* addze R11, R11 */
		/* 82264224h case    3:*/		cpu::op::addze<0>(regs,&regs.R11,regs.R11);
		/* 82264224h case    3:*/		return 0x82264228;
		  /* 82264228h */ case    4:  		/* add R3, R11, R10 */
		/* 82264228h case    4:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 82264228h case    4:*/		return 0x8226422C;
		  /* 8226422Ch */ case    5:  		/* addi R1, R1, 112 */
		/* 8226422Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8226422Ch case    5:*/		return 0x82264230;
		  /* 82264230h */ case    6:  		/* lwz R12, <#[R1 - 8]> */
		/* 82264230h case    6:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82264230h case    6:*/		return 0x82264234;
		  /* 82264234h */ case    7:  		/* mtspr LR, R12 */
		/* 82264234h case    7:*/		regs.LR = regs.R12;
		/* 82264234h case    7:*/		return 0x82264238;
		  /* 82264238h */ case    8:  		/* ld R30, <#[R1 - 24]> */
		/* 82264238h case    8:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82264238h case    8:*/		return 0x8226423C;
		  /* 8226423Ch */ case    9:  		/* ld R31, <#[R1 - 16]> */
		/* 8226423Ch case    9:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8226423Ch case    9:*/		return 0x82264240;
		  /* 82264240h */ case   10:  		/* bclr 20, CR0_LT */
		/* 82264240h case   10:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82264240h case   10:*/		return 0x82264244;
	}
	return 0x82264244;
} // Block from 82264218h-82264244h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82264244h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264244( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264244) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264244);
		  /* 82264244h */ case    0:  		/* nop */
		/* 82264244h case    0:*/		cpu::op::nop();
		/* 82264244h case    0:*/		return 0x82264248;
	}
	return 0x82264248;
} // Block from 82264244h-82264248h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82264248h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264248( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264248) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264248);
		  /* 82264248h */ case    0:  		/* mfspr R12, LR */
		/* 82264248h case    0:*/		regs.R12 = regs.LR;
		/* 82264248h case    0:*/		return 0x8226424C;
		  /* 8226424Ch */ case    1:  		/* bl -1912820 */
		/* 8226424Ch case    1:*/		regs.LR = 0x82264250; return 0x82091258;
		/* 8226424Ch case    1:*/		return 0x82264250;
		  /* 82264250h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82264250h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82264250h case    2:*/		return 0x82264254;
		  /* 82264254h */ case    3:  		/* lwz R11, <#[R3 + 4]> */
		/* 82264254h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82264254h case    3:*/		return 0x82264258;
		  /* 82264258h */ case    4:  		/* mr R31, R3 */
		/* 82264258h case    4:*/		regs.R31 = regs.R3;
		/* 82264258h case    4:*/		return 0x8226425C;
		  /* 8226425Ch */ case    5:  		/* mr R30, R5 */
		/* 8226425Ch case    5:*/		regs.R30 = regs.R5;
		/* 8226425Ch case    5:*/		return 0x82264260;
		  /* 82264260h */ case    6:  		/* addi R11, R11, 1 */
		/* 82264260h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82264260h case    6:*/		return 0x82264264;
		  /* 82264264h */ case    7:  		/* stw R11, <#[R3 + 4]> */
		/* 82264264h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82264264h case    7:*/		return 0x82264268;
		  /* 82264268h */ case    8:  		/* lwz R11, <#[R4]> */
		/* 82264268h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 82264268h case    8:*/		return 0x8226426C;
		  /* 8226426Ch */ case    9:  		/* addi R11, R11, 1 */
		/* 8226426Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8226426Ch case    9:*/		return 0x82264270;
		  /* 82264270h */ case   10:  		/* stw R11, <#[R4]> */
		/* 82264270h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 82264270h case   10:*/		return 0x82264274;
		  /* 82264274h */ case   11:  		/* cmpwi CR6, R11, 7 */
		/* 82264274h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000007);
		/* 82264274h case   11:*/		return 0x82264278;
		  /* 82264278h */ case   12:  		/* bc 4, CR6_EQ, 132 */
		/* 82264278h case   12:*/		if ( !regs.CR[6].eq ) { return 0x822642FC;  }
		/* 82264278h case   12:*/		return 0x8226427C;
		  /* 8226427Ch */ case   13:  		/* li R29, 0 */
		/* 8226427Ch case   13:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 8226427Ch case   13:*/		return 0x82264280;
		  /* 82264280h */ case   14:  		/* stw R29, <#[R4]> */
		/* 82264280h case   14:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R4 + 0x00000000) );
		/* 82264280h case   14:*/		return 0x82264284;
		  /* 82264284h */ case   15:  		/* lwz R11, <#[R5]> */
		/* 82264284h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 82264284h case   15:*/		return 0x82264288;
		  /* 82264288h */ case   16:  		/* cmplwi CR6, R11, 0 */
		/* 82264288h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82264288h case   16:*/		return 0x8226428C;
		  /* 8226428Ch */ case   17:  		/* bc 4, CR6_EQ, 44 */
		/* 8226428Ch case   17:*/		if ( !regs.CR[6].eq ) { return 0x822642B8;  }
		/* 8226428Ch case   17:*/		return 0x82264290;
		  /* 82264290h */ case   18:  		/* lwz R28, <#[R6 + 1456]> */
		/* 82264290h case   18:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R6 + 0x000005B0) );
		/* 82264290h case   18:*/		return 0x82264294;
		  /* 82264294h */ case   19:  		/* li R4, 36 */
		/* 82264294h case   19:*/		cpu::op::li<0>(regs,&regs.R4,0x24);
		/* 82264294h case   19:*/		return 0x82264298;
		  /* 82264298h */ case   20:  		/* mr R3, R28 */
		/* 82264298h case   20:*/		regs.R3 = regs.R28;
		/* 82264298h case   20:*/		return 0x8226429C;
		  /* 8226429Ch */ case   21:  		/* bl -294372 */
		/* 8226429Ch case   21:*/		regs.LR = 0x822642A0; return 0x8221C4B8;
		/* 8226429Ch case   21:*/		return 0x822642A0;
		  /* 822642A0h */ case   22:  		/* addi R11, R3, 4 */
		/* 822642A0h case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x4);
		/* 822642A0h case   22:*/		return 0x822642A4;
		  /* 822642A4h */ case   23:  		/* stw R28, <#[R3]> */
		/* 822642A4h case   23:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R3 + 0x00000000) );
		/* 822642A4h case   23:*/		return 0x822642A8;
		  /* 822642A8h */ case   24:  		/* stw R11, <#[R31 + 8]> */
		/* 822642A8h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 822642A8h case   24:*/		return 0x822642AC;
		  /* 822642ACh */ case   25:  		/* stw R29, <#[R3 + 32]> */
		/* 822642ACh case   25:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000020) );
		/* 822642ACh case   25:*/		return 0x822642B0;
		  /* 822642B0h */ case   26:  		/* lwz R11, <#[R31 + 8]> */
		/* 822642B0h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 822642B0h case   26:*/		return 0x822642B4;
		  /* 822642B4h */ case   27:  		/* b 68 */
		/* 822642B4h case   27:*/		return 0x822642F8;
		/* 822642B4h case   27:*/		return 0x822642B8;
	}
	return 0x822642B8;
} // Block from 82264248h-822642B8h (28 instructions)

//////////////////////////////////////////////////////
// Block at 822642B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822642B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822642B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822642B8);
		  /* 822642B8h */ case    0:  		/* lwz R11, <#[R11 + 28]> */
		/* 822642B8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 822642B8h case    0:*/		return 0x822642BC;
		  /* 822642BCh */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 822642BCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822642BCh case    1:*/		return 0x822642C0;
		  /* 822642C0h */ case    2:  		/* bc 4, CR6_EQ, 48 */
		/* 822642C0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x822642F0;  }
		/* 822642C0h case    2:*/		return 0x822642C4;
		  /* 822642C4h */ case    3:  		/* lwz R31, <#[R6 + 1456]> */
		/* 822642C4h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R6 + 0x000005B0) );
		/* 822642C4h case    3:*/		return 0x822642C8;
		  /* 822642C8h */ case    4:  		/* li R4, 36 */
		/* 822642C8h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x24);
		/* 822642C8h case    4:*/		return 0x822642CC;
		  /* 822642CCh */ case    5:  		/* mr R3, R31 */
		/* 822642CCh case    5:*/		regs.R3 = regs.R31;
		/* 822642CCh case    5:*/		return 0x822642D0;
		  /* 822642D0h */ case    6:  		/* bl -294424 */
		/* 822642D0h case    6:*/		regs.LR = 0x822642D4; return 0x8221C4B8;
		/* 822642D0h case    6:*/		return 0x822642D4;
		  /* 822642D4h */ case    7:  		/* stw R31, <#[R3]> */
		/* 822642D4h case    7:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 822642D4h case    7:*/		return 0x822642D8;
		  /* 822642D8h */ case    8:  		/* lwz R10, <#[R30]> */
		/* 822642D8h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 822642D8h case    8:*/		return 0x822642DC;
		  /* 822642DCh */ case    9:  		/* addi R11, R3, 4 */
		/* 822642DCh case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R3,0x4);
		/* 822642DCh case    9:*/		return 0x822642E0;
		  /* 822642E0h */ case   10:  		/* stw R11, <#[R10 + 28]> */
		/* 822642E0h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x0000001C) );
		/* 822642E0h case   10:*/		return 0x822642E4;
		  /* 822642E4h */ case   11:  		/* lwz R11, <#[R30]> */
		/* 822642E4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 822642E4h case   11:*/		return 0x822642E8;
		  /* 822642E8h */ case   12:  		/* lwz R11, <#[R11 + 28]> */
		/* 822642E8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 822642E8h case   12:*/		return 0x822642EC;
		  /* 822642ECh */ case   13:  		/* stw R29, <#[R11 + 28]> */
		/* 822642ECh case   13:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x0000001C) );
		/* 822642ECh case   13:*/		return 0x822642F0;
	}
	return 0x822642F0;
} // Block from 822642B8h-822642F0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 822642F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822642F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822642F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822642F0);
		  /* 822642F0h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 822642F0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 822642F0h case    0:*/		return 0x822642F4;
		  /* 822642F4h */ case    1:  		/* lwz R11, <#[R11 + 28]> */
		/* 822642F4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 822642F4h case    1:*/		return 0x822642F8;
	}
	return 0x822642F8;
} // Block from 822642F0h-822642F8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822642F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822642F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822642F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822642F8);
		  /* 822642F8h */ case    0:  		/* stw R11, <#[R30]> */
		/* 822642F8h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 822642F8h case    0:*/		return 0x822642FC;
	}
	return 0x822642FC;
} // Block from 822642F8h-822642FCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 822642FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822642FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822642FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822642FC);
		  /* 822642FCh */ case    0:  		/* addi R1, R1, 128 */
		/* 822642FCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 822642FCh case    0:*/		return 0x82264300;
		  /* 82264300h */ case    1:  		/* b -1912920 */
		/* 82264300h case    1:*/		return 0x820912A8;
		/* 82264300h case    1:*/		return 0x82264304;
		  /* 82264304h */ case    2:  		/* nop */
		/* 82264304h case    2:*/		cpu::op::nop();
		/* 82264304h case    2:*/		return 0x82264308;
	}
	return 0x82264308;
} // Block from 822642FCh-82264308h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82264308h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264308( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264308) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264308);
		  /* 82264308h */ case    0:  		/* lwz R10, <#[R3]> */
		/* 82264308h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82264308h case    0:*/		return 0x8226430C;
		  /* 8226430Ch */ case    1:  		/* li R11, 0 */
		/* 8226430Ch case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8226430Ch case    1:*/		return 0x82264310;
		  /* 82264310h */ case    2:  		/* lwz R9, <#[R10]> */
		/* 82264310h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82264310h case    2:*/		return 0x82264314;
		  /* 82264314h */ case    3:  		/* cmplwi CR6, R9, 0 */
		/* 82264314h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82264314h case    3:*/		return 0x82264318;
		  /* 82264318h */ case    4:  		/* bclr 4, CR6_GT */
		/* 82264318h case    4:*/		if ( !regs.CR[6].gt ) { return (uint32)regs.LR; }
		/* 82264318h case    4:*/		return 0x8226431C;
	}
	return 0x8226431C;
} // Block from 82264308h-8226431Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8226431Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226431C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226431C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226431C);
		  /* 8226431Ch */ case    0:  		/* addi R9, R10, 4 */
		/* 8226431Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 8226431Ch case    0:*/		return 0x82264320;
		  /* 82264320h */ case    1:  		/* li R8, 0 */
		/* 82264320h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 82264320h case    1:*/		return 0x82264324;
		  /* 82264324h */ case    2:  		/* addi R11, R11, 1 */
		/* 82264324h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82264324h case    2:*/		return 0x82264328;
		  /* 82264328h */ case    3:  		/* stwu R8, <#[R9 + 4]> */
		/* 82264328h case    3:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 82264328h case    3:*/		return 0x8226432C;
		  /* 8226432Ch */ case    4:  		/* lwz R8, <#[R10]> */
		/* 8226432Ch case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 8226432Ch case    4:*/		return 0x82264330;
		  /* 82264330h */ case    5:  		/* cmplw CR6, R11, R8 */
		/* 82264330h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 82264330h case    5:*/		return 0x82264334;
		  /* 82264334h */ case    6:  		/* bc 12, CR6_LT, -20 */
		/* 82264334h case    6:*/		if ( regs.CR[6].lt ) { return 0x82264320;  }
		/* 82264334h case    6:*/		return 0x82264338;
		  /* 82264338h */ case    7:  		/* bclr 20, CR0_LT */
		/* 82264338h case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82264338h case    7:*/		return 0x8226433C;
	}
	return 0x8226433C;
} // Block from 8226431Ch-8226433Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8226433Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226433C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226433C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226433C);
		  /* 8226433Ch */ case    0:  		/* nop */
		/* 8226433Ch case    0:*/		cpu::op::nop();
		/* 8226433Ch case    0:*/		return 0x82264340;
	}
	return 0x82264340;
} // Block from 8226433Ch-82264340h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82264340h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264340( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264340) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264340);
		  /* 82264340h */ case    0:  		/* mfspr R12, LR */
		/* 82264340h case    0:*/		regs.R12 = regs.LR;
		/* 82264340h case    0:*/		return 0x82264344;
		  /* 82264344h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82264344h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82264344h case    1:*/		return 0x82264348;
		  /* 82264348h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82264348h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82264348h case    2:*/		return 0x8226434C;
		  /* 8226434Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8226434Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8226434Ch case    3:*/		return 0x82264350;
		  /* 82264350h */ case    4:  		/* mr R31, R3 */
		/* 82264350h case    4:*/		regs.R31 = regs.R3;
		/* 82264350h case    4:*/		return 0x82264354;
		  /* 82264354h */ case    5:  		/* bl -420 */
		/* 82264354h case    5:*/		regs.LR = 0x82264358; return 0x822641B0;
		/* 82264354h case    5:*/		return 0x82264358;
		  /* 82264358h */ case    6:  		/* rlwinm R11, R3, 27, 5, 31 */
		/* 82264358h case    6:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R3);
		/* 82264358h case    6:*/		return 0x8226435C;
		  /* 8226435Ch */ case    7:  		/* lwz R10, <#[R31]> */
		/* 8226435Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8226435Ch case    7:*/		return 0x82264360;
		  /* 82264360h */ case    8:  		/* rlwinm R9, R3, 0, 27, 31 */
		/* 82264360h case    8:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R3);
		/* 82264360h case    8:*/		return 0x82264364;
		  /* 82264364h */ case    9:  		/* addi R11, R11, 2 */
		/* 82264364h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82264364h case    9:*/		return 0x82264368;
		  /* 82264368h */ case   10:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82264368h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82264368h case   10:*/		return 0x8226436C;
		  /* 8226436Ch */ case   11:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8226436Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8226436Ch case   11:*/		return 0x82264370;
		  /* 82264370h */ case   12:  		/* srw R11, R11, R9 */
		/* 82264370h case   12:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 82264370h case   12:*/		return 0x82264374;
		  /* 82264374h */ case   13:  		/* rlwinm R3, R11, 0, 31, 31 */
		/* 82264374h case   13:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R3,regs.R11);
		/* 82264374h case   13:*/		return 0x82264378;
		  /* 82264378h */ case   14:  		/* addi R1, R1, 96 */
		/* 82264378h case   14:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82264378h case   14:*/		return 0x8226437C;
		  /* 8226437Ch */ case   15:  		/* lwz R12, <#[R1 - 8]> */
		/* 8226437Ch case   15:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8226437Ch case   15:*/		return 0x82264380;
		  /* 82264380h */ case   16:  		/* mtspr LR, R12 */
		/* 82264380h case   16:*/		regs.LR = regs.R12;
		/* 82264380h case   16:*/		return 0x82264384;
		  /* 82264384h */ case   17:  		/* ld R31, <#[R1 - 16]> */
		/* 82264384h case   17:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82264384h case   17:*/		return 0x82264388;
		  /* 82264388h */ case   18:  		/* bclr 20, CR0_LT */
		/* 82264388h case   18:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82264388h case   18:*/		return 0x8226438C;
	}
	return 0x8226438C;
} // Block from 82264340h-8226438Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 8226438Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226438C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226438C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226438C);
		  /* 8226438Ch */ case    0:  		/* nop */
		/* 8226438Ch case    0:*/		cpu::op::nop();
		/* 8226438Ch case    0:*/		return 0x82264390;
	}
	return 0x82264390;
} // Block from 8226438Ch-82264390h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82264390h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264390( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264390) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264390);
		  /* 82264390h */ case    0:  		/* mfspr R12, LR */
		/* 82264390h case    0:*/		regs.R12 = regs.LR;
		/* 82264390h case    0:*/		return 0x82264394;
		  /* 82264394h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82264394h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82264394h case    1:*/		return 0x82264398;
		  /* 82264398h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82264398h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82264398h case    2:*/		return 0x8226439C;
		  /* 8226439Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 8226439Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8226439Ch case    3:*/		return 0x822643A0;
		  /* 822643A0h */ case    4:  		/* mr R31, R3 */
		/* 822643A0h case    4:*/		regs.R31 = regs.R3;
		/* 822643A0h case    4:*/		return 0x822643A4;
		  /* 822643A4h */ case    5:  		/* bl -500 */
		/* 822643A4h case    5:*/		regs.LR = 0x822643A8; return 0x822641B0;
		/* 822643A4h case    5:*/		return 0x822643A8;
		  /* 822643A8h */ case    6:  		/* rlwinm R10, R3, 27, 5, 31 */
		/* 822643A8h case    6:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R3);
		/* 822643A8h case    6:*/		return 0x822643AC;
		  /* 822643ACh */ case    7:  		/* lwz R11, <#[R31]> */
		/* 822643ACh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822643ACh case    7:*/		return 0x822643B0;
		  /* 822643B0h */ case    8:  		/* rlwinm R8, R3, 0, 27, 31 */
		/* 822643B0h case    8:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R8,regs.R3);
		/* 822643B0h case    8:*/		return 0x822643B4;
		  /* 822643B4h */ case    9:  		/* addi R10, R10, 2 */
		/* 822643B4h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 822643B4h case    9:*/		return 0x822643B8;
		  /* 822643B8h */ case   10:  		/* li R9, 1 */
		/* 822643B8h case   10:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 822643B8h case   10:*/		return 0x822643BC;
		  /* 822643BCh */ case   11:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 822643BCh case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 822643BCh case   11:*/		return 0x822643C0;
		  /* 822643C0h */ case   12:  		/* slw R9, R9, R8 */
		/* 822643C0h case   12:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 822643C0h case   12:*/		return 0x822643C4;
		  /* 822643C4h */ case   13:  		/* lwzx R8, <#[R10 + R11]> */
		/* 822643C4h case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 822643C4h case   13:*/		return 0x822643C8;
		  /* 822643C8h */ case   14:  		/* or R9, R9, R8 */
		/* 822643C8h case   14:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 822643C8h case   14:*/		return 0x822643CC;
		  /* 822643CCh */ case   15:  		/* stwx R9, <#[R10 + R11]> */
		/* 822643CCh case   15:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 822643CCh case   15:*/		return 0x822643D0;
		  /* 822643D0h */ case   16:  		/* addi R1, R1, 96 */
		/* 822643D0h case   16:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 822643D0h case   16:*/		return 0x822643D4;
		  /* 822643D4h */ case   17:  		/* lwz R12, <#[R1 - 8]> */
		/* 822643D4h case   17:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822643D4h case   17:*/		return 0x822643D8;
		  /* 822643D8h */ case   18:  		/* mtspr LR, R12 */
		/* 822643D8h case   18:*/		regs.LR = regs.R12;
		/* 822643D8h case   18:*/		return 0x822643DC;
		  /* 822643DCh */ case   19:  		/* ld R31, <#[R1 - 16]> */
		/* 822643DCh case   19:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822643DCh case   19:*/		return 0x822643E0;
		  /* 822643E0h */ case   20:  		/* bclr 20, CR0_LT */
		/* 822643E0h case   20:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822643E0h case   20:*/		return 0x822643E4;
	}
	return 0x822643E4;
} // Block from 82264390h-822643E4h (21 instructions)

//////////////////////////////////////////////////////
// Block at 822643E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822643E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822643E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822643E4);
		  /* 822643E4h */ case    0:  		/* nop */
		/* 822643E4h case    0:*/		cpu::op::nop();
		/* 822643E4h case    0:*/		return 0x822643E8;
	}
	return 0x822643E8;
} // Block from 822643E4h-822643E8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822643E8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822643E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822643E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822643E8);
		  /* 822643E8h */ case    0:  		/* lwz R11, <#[R4 + 228]> */
		/* 822643E8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x000000E4) );
		/* 822643E8h case    0:*/		return 0x822643EC;
		  /* 822643ECh */ case    1:  		/* lwz R3, <#[R4 + 56]> */
		/* 822643ECh case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R4 + 0x00000038) );
		/* 822643ECh case    1:*/		return 0x822643F0;
		  /* 822643F0h */ case    2:  		/* rlwinm. R11, R11, 25, 31, 31 */
		/* 822643F0h case    2:*/		cpu::op::rlwinm<1,25,31,31>(regs,&regs.R11,regs.R11);
		/* 822643F0h case    2:*/		return 0x822643F4;
		  /* 822643F4h */ case    3:  		/* bclr 12, CR0_EQ */
		/* 822643F4h case    3:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 822643F4h case    3:*/		return 0x822643F8;
	}
	return 0x822643F8;
} // Block from 822643E8h-822643F8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822643F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822643F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822643F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822643F8);
		  /* 822643F8h */ case    0:  		/* lis R11, -32215 */
		/* 822643F8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 822643F8h case    0:*/		return 0x822643FC;
		  /* 822643FCh */ case    1:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 822643FCh case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 822643FCh case    1:*/		return 0x82264400;
		  /* 82264400h */ case    2:  		/* lwz R11, <#[R11 - 25560]> */
		/* 82264400h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFF9C28) );
		/* 82264400h case    2:*/		return 0x82264404;
		  /* 82264404h */ case    3:  		/* lwzx R3, <#[R10 + R11]> */
		/* 82264404h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82264404h case    3:*/		return 0x82264408;
		  /* 82264408h */ case    4:  		/* bclr 20, CR0_LT */
		/* 82264408h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82264408h case    4:*/		return 0x8226440C;
	}
	return 0x8226440C;
} // Block from 822643F8h-8226440Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8226440Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226440C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226440C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226440C);
		  /* 8226440Ch */ case    0:  		/* nop */
		/* 8226440Ch case    0:*/		cpu::op::nop();
		/* 8226440Ch case    0:*/		return 0x82264410;
	}
	return 0x82264410;
} // Block from 8226440Ch-82264410h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82264410h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264410( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264410) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264410);
		  /* 82264410h */ case    0:  		/* mfspr R12, LR */
		/* 82264410h case    0:*/		regs.R12 = regs.LR;
		/* 82264410h case    0:*/		return 0x82264414;
		  /* 82264414h */ case    1:  		/* bl -1913280 */
		/* 82264414h case    1:*/		regs.LR = 0x82264418; return 0x82091254;
		/* 82264414h case    1:*/		return 0x82264418;
		  /* 82264418h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82264418h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82264418h case    2:*/		return 0x8226441C;
		  /* 8226441Ch */ case    3:  		/* lis R11, -32215 */
		/* 8226441Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 8226441Ch case    3:*/		return 0x82264420;
		  /* 82264420h */ case    4:  		/* stw R4, <#[R3]> */
		/* 82264420h case    4:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000000) );
		/* 82264420h case    4:*/		return 0x82264424;
		  /* 82264424h */ case    5:  		/* li R28, 0 */
		/* 82264424h case    5:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 82264424h case    5:*/		return 0x82264428;
		  /* 82264428h */ case    6:  		/* stw R5, <#[R3 + 4]> */
		/* 82264428h case    6:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R3 + 0x00000004) );
		/* 82264428h case    6:*/		return 0x8226442C;
		  /* 8226442Ch */ case    7:  		/* mr R10, R4 */
		/* 8226442Ch case    7:*/		regs.R10 = regs.R4;
		/* 8226442Ch case    7:*/		return 0x82264430;
		  /* 82264430h */ case    8:  		/* stw R28, <#[R3 + 8]> */
		/* 82264430h case    8:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R3 + 0x00000008) );
		/* 82264430h case    8:*/		return 0x82264434;
		  /* 82264434h */ case    9:  		/* rlwinm R9, R4, 2, 0, 29 */
		/* 82264434h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R4);
		/* 82264434h case    9:*/		return 0x82264438;
		  /* 82264438h */ case   10:  		/* stw R28, <#[R3 + 12]> */
		/* 82264438h case   10:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R3 + 0x0000000C) );
		/* 82264438h case   10:*/		return 0x8226443C;
		  /* 8226443Ch */ case   11:  		/* mr R31, R3 */
		/* 8226443Ch case   11:*/		regs.R31 = regs.R3;
		/* 8226443Ch case   11:*/		return 0x82264440;
		  /* 82264440h */ case   12:  		/* lwz R11, <#[R11 - 25556]> */
		/* 82264440h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFF9C2C) );
		/* 82264440h case   12:*/		return 0x82264444;
		  /* 82264444h */ case   13:  		/* li R4, 20 */
		/* 82264444h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 82264444h case   13:*/		return 0x82264448;
		  /* 82264448h */ case   14:  		/* stwx R10, <#[R9 + R11]> */
		/* 82264448h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82264448h case   14:*/		return 0x8226444C;
		  /* 8226444Ch */ case   15:  		/* mr R29, R6 */
		/* 8226444Ch case   15:*/		regs.R29 = regs.R6;
		/* 8226444Ch case   15:*/		return 0x82264450;
		  /* 82264450h */ case   16:  		/* lwz R27, <#[R6 + 1456]> */
		/* 82264450h case   16:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R6 + 0x000005B0) );
		/* 82264450h case   16:*/		return 0x82264454;
		  /* 82264454h */ case   17:  		/* mr R3, R27 */
		/* 82264454h case   17:*/		regs.R3 = regs.R27;
		/* 82264454h case   17:*/		return 0x82264458;
		  /* 82264458h */ case   18:  		/* bl -294816 */
		/* 82264458h case   18:*/		regs.LR = 0x8226445C; return 0x8221C4B8;
		/* 82264458h case   18:*/		return 0x8226445C;
		  /* 8226445Ch */ case   19:  		/* addic. R30, R3, 4 */
		/* 8226445Ch case   19:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R3,0x4);
		/* 8226445Ch case   19:*/		return 0x82264460;
		  /* 82264460h */ case   20:  		/* stw R27, <#[R3]> */
		/* 82264460h case   20:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R3 + 0x00000000) );
		/* 82264460h case   20:*/		return 0x82264464;
		  /* 82264464h */ case   21:  		/* bc 12, CR0_EQ, 20 */
		/* 82264464h case   21:*/		if ( regs.CR[0].eq ) { return 0x82264478;  }
		/* 82264464h case   21:*/		return 0x82264468;
		  /* 82264468h */ case   22:  		/* mr R3, R30 */
		/* 82264468h case   22:*/		regs.R3 = regs.R30;
		/* 82264468h case   22:*/		return 0x8226446C;
		  /* 8226446Ch */ case   23:  		/* lwz R4, <#[R29 + 1456]> */
		/* 8226446Ch case   23:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R29 + 0x000005B0) );
		/* 8226446Ch case   23:*/		return 0x82264470;
		  /* 82264470h */ case   24:  		/* bl -190224 */
		/* 82264470h case   24:*/		regs.LR = 0x82264474; return 0x82235D60;
		/* 82264470h case   24:*/		return 0x82264474;
		  /* 82264474h */ case   25:  		/* b 8 */
		/* 82264474h case   25:*/		return 0x8226447C;
		/* 82264474h case   25:*/		return 0x82264478;
	}
	return 0x82264478;
} // Block from 82264410h-82264478h (26 instructions)

//////////////////////////////////////////////////////
// Block at 82264478h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264478( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264478) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264478);
		  /* 82264478h */ case    0:  		/* mr R30, R28 */
		/* 82264478h case    0:*/		regs.R30 = regs.R28;
		/* 82264478h case    0:*/		return 0x8226447C;
	}
	return 0x8226447C;
} // Block from 82264478h-8226447Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226447Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226447C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226447C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226447C);
		  /* 8226447Ch */ case    0:  		/* stw R30, <#[R31 + 16]> */
		/* 8226447Ch case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000010) );
		/* 8226447Ch case    0:*/		return 0x82264480;
		  /* 82264480h */ case    1:  		/* mr R3, R31 */
		/* 82264480h case    1:*/		regs.R3 = regs.R31;
		/* 82264480h case    1:*/		return 0x82264484;
		  /* 82264484h */ case    2:  		/* addi R1, R1, 128 */
		/* 82264484h case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82264484h case    2:*/		return 0x82264488;
		  /* 82264488h */ case    3:  		/* b -1913316 */
		/* 82264488h case    3:*/		return 0x820912A4;
		/* 82264488h case    3:*/		return 0x8226448C;
		  /* 8226448Ch */ case    4:  		/* nop */
		/* 8226448Ch case    4:*/		cpu::op::nop();
		/* 8226448Ch case    4:*/		return 0x82264490;
	}
	return 0x82264490;
} // Block from 8226447Ch-82264490h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82264490h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264490( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264490) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264490);
		  /* 82264490h */ case    0:  		/* mfspr R12, LR */
		/* 82264490h case    0:*/		regs.R12 = regs.LR;
		/* 82264490h case    0:*/		return 0x82264494;
		  /* 82264494h */ case    1:  		/* bl -1913428 */
		/* 82264494h case    1:*/		regs.LR = 0x82264498; return 0x82091240;
		/* 82264494h case    1:*/		return 0x82264498;
		  /* 82264498h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 82264498h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 82264498h case    2:*/		return 0x8226449C;
		  /* 8226449Ch */ case    3:  		/* mr R26, R3 */
		/* 8226449Ch case    3:*/		regs.R26 = regs.R3;
		/* 8226449Ch case    3:*/		return 0x822644A0;
		  /* 822644A0h */ case    4:  		/* lwz R3, <#[R5 + 4]> */
		/* 822644A0h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R5 + 0x00000004) );
		/* 822644A0h case    4:*/		return 0x822644A4;
		  /* 822644A4h */ case    5:  		/* mr R31, R4 */
		/* 822644A4h case    5:*/		regs.R31 = regs.R4;
		/* 822644A4h case    5:*/		return 0x822644A8;
		  /* 822644A8h */ case    6:  		/* mr R24, R5 */
		/* 822644A8h case    6:*/		regs.R24 = regs.R5;
		/* 822644A8h case    6:*/		return 0x822644AC;
		  /* 822644ACh */ case    7:  		/* lwz R11, <#[R3 + 4]> */
		/* 822644ACh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 822644ACh case    7:*/		return 0x822644B0;
		  /* 822644B0h */ case    8:  		/* cmplw CR6, R4, R11 */
		/* 822644B0h case    8:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 822644B0h case    8:*/		return 0x822644B4;
		  /* 822644B4h */ case    9:  		/* bc 4, CR6_LT, 20 */
		/* 822644B4h case    9:*/		if ( !regs.CR[6].lt ) { return 0x822644C8;  }
		/* 822644B4h case    9:*/		return 0x822644B8;
		  /* 822644B8h */ case   10:  		/* lwz R10, <#[R3 + 8]> */
		/* 822644B8h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 822644B8h case   10:*/		return 0x822644BC;
		  /* 822644BCh */ case   11:  		/* rlwinm R11, R4, 2, 0, 29 */
		/* 822644BCh case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R4);
		/* 822644BCh case   11:*/		return 0x822644C0;
		  /* 822644C0h */ case   12:  		/* add R3, R10, R11 */
		/* 822644C0h case   12:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 822644C0h case   12:*/		return 0x822644C4;
		  /* 822644C4h */ case   13:  		/* b 12 */
		/* 822644C4h case   13:*/		return 0x822644D0;
		/* 822644C4h case   13:*/		return 0x822644C8;
	}
	return 0x822644C8;
} // Block from 82264490h-822644C8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 822644C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822644C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822644C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822644C8);
		  /* 822644C8h */ case    0:  		/* mr R4, R31 */
		/* 822644C8h case    0:*/		regs.R4 = regs.R31;
		/* 822644C8h case    0:*/		return 0x822644CC;
		  /* 822644CCh */ case    1:  		/* bl -68108 */
		/* 822644CCh case    1:*/		regs.LR = 0x822644D0; return 0x82253AC0;
		/* 822644CCh case    1:*/		return 0x822644D0;
	}
	return 0x822644D0;
} // Block from 822644C8h-822644D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822644D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822644D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822644D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822644D0);
		  /* 822644D0h */ case    0:  		/* lwz R11, <#[R26 + 8]> */
		/* 822644D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 822644D0h case    0:*/		return 0x822644D4;
		  /* 822644D4h */ case    1:  		/* lwz R22, <#[R3]> */
		/* 822644D4h case    1:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R3 + 0x00000000) );
		/* 822644D4h case    1:*/		return 0x822644D8;
		  /* 822644D8h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 822644D8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822644D8h case    2:*/		return 0x822644DC;
		  /* 822644DCh */ case    3:  		/* bc 4, CR6_EQ, 20 */
		/* 822644DCh case    3:*/		if ( !regs.CR[6].eq ) { return 0x822644F0;  }
		/* 822644DCh case    3:*/		return 0x822644E0;
		  /* 822644E0h */ case    4:  		/* lwz R11, <#[R22 + 8]> */
		/* 822644E0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000008) );
		/* 822644E0h case    4:*/		return 0x822644E4;
		  /* 822644E4h */ case    5:  		/* stw R11, <#[R26 + 8]> */
		/* 822644E4h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 822644E4h case    5:*/		return 0x822644E8;
		  /* 822644E8h */ case    6:  		/* b 32 */
		/* 822644E8h case    6:*/		return 0x82264508;
		/* 822644E8h case    6:*/		return 0x822644EC;
		  /* 822644ECh */ case    7:  		/* lwz R11, <#[R11]> */
		/* 822644ECh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 822644ECh case    7:*/		return 0x822644F0;
	}
	return 0x822644F0;
} // Block from 822644D0h-822644F0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 822644F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822644F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822644F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822644F0);
		  /* 822644F0h */ case    0:  		/* addi R11, R11, 28 */
		/* 822644F0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1C);
		/* 822644F0h case    0:*/		return 0x822644F4;
		  /* 822644F4h */ case    1:  		/* lwz R10, <#[R11]> */
		/* 822644F4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 822644F4h case    1:*/		return 0x822644F8;
		  /* 822644F8h */ case    2:  		/* cmplwi CR6, R10, 0 */
		/* 822644F8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 822644F8h case    2:*/		return 0x822644FC;
		  /* 822644FCh */ case    3:  		/* bc 4, CR6_EQ, -16 */
		/* 822644FCh case    3:*/		if ( !regs.CR[6].eq ) { return 0x822644EC;  }
		/* 822644FCh case    3:*/		return 0x82264500;
		  /* 82264500h */ case    4:  		/* lwz R10, <#[R22 + 8]> */
		/* 82264500h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R22 + 0x00000008) );
		/* 82264500h case    4:*/		return 0x82264504;
		  /* 82264504h */ case    5:  		/* stw R10, <#[R11]> */
		/* 82264504h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82264504h case    5:*/		return 0x82264508;
	}
	return 0x82264508;
} // Block from 822644F0h-82264508h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82264508h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264508( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264508) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264508);
		  /* 82264508h */ case    0:  		/* addi R5, R1, 84 */
		/* 82264508h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 82264508h case    0:*/		return 0x8226450C;
		  /* 8226450Ch */ case    1:  		/* addi R4, R1, 80 */
		/* 8226450Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8226450Ch case    1:*/		return 0x82264510;
		  /* 82264510h */ case    2:  		/* mr R3, R26 */
		/* 82264510h case    2:*/		regs.R3 = regs.R26;
		/* 82264510h case    2:*/		return 0x82264514;
		  /* 82264514h */ case    3:  		/* bl -1116 */
		/* 82264514h case    3:*/		regs.LR = 0x82264518; return 0x822640B8;
		/* 82264514h case    3:*/		return 0x82264518;
		  /* 82264518h */ case    4:  		/* lwz R3, <#[R24 + 4]> */
		/* 82264518h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R24 + 0x00000004) );
		/* 82264518h case    4:*/		return 0x8226451C;
		  /* 8226451Ch */ case    5:  		/* lwz R11, <#[R3 + 4]> */
		/* 8226451Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8226451Ch case    5:*/		return 0x82264520;
		  /* 82264520h */ case    6:  		/* cmplw CR6, R31, R11 */
		/* 82264520h case    6:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82264520h case    6:*/		return 0x82264524;
		  /* 82264524h */ case    7:  		/* bc 4, CR6_LT, 20 */
		/* 82264524h case    7:*/		if ( !regs.CR[6].lt ) { return 0x82264538;  }
		/* 82264524h case    7:*/		return 0x82264528;
		  /* 82264528h */ case    8:  		/* lwz R11, <#[R3 + 8]> */
		/* 82264528h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82264528h case    8:*/		return 0x8226452C;
		  /* 8226452Ch */ case    9:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 8226452Ch case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 8226452Ch case    9:*/		return 0x82264530;
		  /* 82264530h */ case   10:  		/* add R3, R11, R10 */
		/* 82264530h case   10:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 82264530h case   10:*/		return 0x82264534;
		  /* 82264534h */ case   11:  		/* b 12 */
		/* 82264534h case   11:*/		return 0x82264540;
		/* 82264534h case   11:*/		return 0x82264538;
	}
	return 0x82264538;
} // Block from 82264508h-82264538h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82264538h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264538( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264538) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264538);
		  /* 82264538h */ case    0:  		/* mr R4, R31 */
		/* 82264538h case    0:*/		regs.R4 = regs.R31;
		/* 82264538h case    0:*/		return 0x8226453C;
		  /* 8226453Ch */ case    1:  		/* bl -68220 */
		/* 8226453Ch case    1:*/		regs.LR = 0x82264540; return 0x82253AC0;
		/* 8226453Ch case    1:*/		return 0x82264540;
	}
	return 0x82264540;
} // Block from 82264538h-82264540h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82264540h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264540( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264540) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264540);
		  /* 82264540h */ case    0:  		/* lwz R27, <#[R3]> */
		/* 82264540h case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R3 + 0x00000000) );
		/* 82264540h case    0:*/		return 0x82264544;
		  /* 82264544h */ case    1:  		/* li R23, 0 */
		/* 82264544h case    1:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 82264544h case    1:*/		return 0x82264548;
		  /* 82264548h */ case    2:  		/* li R30, -1 */
		/* 82264548h case    2:*/		cpu::op::li<0>(regs,&regs.R30,0xFFFFFFFF);
		/* 82264548h case    2:*/		return 0x8226454C;
		  /* 8226454Ch */ case    3:  		/* mr R25, R23 */
		/* 8226454Ch case    3:*/		regs.R25 = regs.R23;
		/* 8226454Ch case    3:*/		return 0x82264550;
	}
	return 0x82264550;
} // Block from 82264540h-82264550h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82264550h
// Function '?NewItem@TempValue@XGRAPHICS@@SAPAVVRegInfo@2@HW4RegType@R400Tables@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264550( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264550) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264550);
		  /* 82264550h */ case    0:  		/* lwz R11, <#[R27 + 4]> */
		/* 82264550h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 82264550h case    0:*/		return 0x82264554;
		  /* 82264554h */ case    1:  		/* lwz R29, <#[R27 + 8]> */
		/* 82264554h case    1:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R27 + 0x00000008) );
		/* 82264554h case    1:*/		return 0x82264558;
		  /* 82264558h */ case    2:  		/* cmpwi CR6, R11, 0 */
		/* 82264558h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82264558h case    2:*/		return 0x8226455C;
		  /* 8226455Ch */ case    3:  		/* bc 4, CR6_GT, 152 */
		/* 8226455Ch case    3:*/		if ( !regs.CR[6].gt ) { return 0x822645F4;  }
		/* 8226455Ch case    3:*/		return 0x82264560;
		  /* 82264560h */ case    4:  		/* lis R28, -32215 */
		/* 82264560h case    4:*/		cpu::op::lis<0>(regs,&regs.R28,0xFFFF8229);
		/* 82264560h case    4:*/		return 0x82264564;
		  /* 82264564h */ case    5:  		/* addi R30, R30, 1 */
		/* 82264564h case    5:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82264564h case    5:*/		return 0x82264568;
		  /* 82264568h */ case    6:  		/* cmpwi CR6, R30, 7 */
		/* 82264568h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000007);
		/* 82264568h case    6:*/		return 0x8226456C;
		  /* 8226456Ch */ case    7:  		/* bc 4, CR6_EQ, 12 */
		/* 8226456Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x82264578;  }
		/* 8226456Ch case    7:*/		return 0x82264570;
		  /* 82264570h */ case    8:  		/* lwz R29, <#[R29 + 28]> */
		/* 82264570h case    8:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R29 + 0x0000001C) );
		/* 82264570h case    8:*/		return 0x82264574;
		  /* 82264574h */ case    9:  		/* mr R30, R23 */
		/* 82264574h case    9:*/		regs.R30 = regs.R23;
		/* 82264574h case    9:*/		return 0x82264578;
	}
	return 0x82264578;
} // Block from 82264550h-82264578h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82264578h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264578( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264578) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264578);
		  /* 82264578h */ case    0:  		/* rlwinm R10, R30, 2, 0, 29 */
		/* 82264578h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R30);
		/* 82264578h case    0:*/		return 0x8226457C;
		  /* 8226457Ch */ case    1:  		/* lwz R9, <#[R26]> */
		/* 8226457Ch case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000000) );
		/* 8226457Ch case    1:*/		return 0x82264580;
		  /* 82264580h */ case    2:  		/* lwz R11, <#[R28 - 25556]> */
		/* 82264580h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0xFFFF9C2C) );
		/* 82264580h case    2:*/		return 0x82264584;
		  /* 82264584h */ case    3:  		/* mr R3, R24 */
		/* 82264584h case    3:*/		regs.R3 = regs.R24;
		/* 82264584h case    3:*/		return 0x82264588;
		  /* 82264588h */ case    4:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82264588h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82264588h case    4:*/		return 0x8226458C;
		  /* 8226458Ch */ case    5:  		/* lwzx R31, <#[R10 + R29]> */
		/* 8226458Ch case    5:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R29 + 0x00000000) );
		/* 8226458Ch case    5:*/		return 0x82264590;
		  /* 82264590h */ case    6:  		/* mr R5, R31 */
		/* 82264590h case    6:*/		regs.R5 = regs.R31;
		/* 82264590h case    6:*/		return 0x82264594;
		  /* 82264594h */ case    7:  		/* lwzx R4, <#[R9 + R11]> */
		/* 82264594h case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 82264594h case    7:*/		return 0x82264598;
		  /* 82264598h */ case    8:  		/* bl -600 */
		/* 82264598h case    8:*/		regs.LR = 0x8226459C; return 0x82264340;
		/* 82264598h case    8:*/		return 0x8226459C;
		  /* 8226459Ch */ case    9:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8226459Ch case    9:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8226459Ch case    9:*/		return 0x822645A0;
		  /* 822645A0h */ case   10:  		/* bc 4, CR0_EQ, 68 */
		/* 822645A0h case   10:*/		if ( !regs.CR[0].eq ) { return 0x822645E4;  }
		/* 822645A0h case   10:*/		return 0x822645A4;
		  /* 822645A4h */ case   11:  		/* addi R5, R1, 84 */
		/* 822645A4h case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 822645A4h case   11:*/		return 0x822645A8;
	}
	return 0x822645A8;
} // Block from 82264578h-822645A8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 822645A8h
// Function '?NewItem@FixedValue@XGRAPHICS@@SAPAVVRegInfo@2@HW4RegType@R400Tables@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822645A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822645A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822645A8);
		  /* 822645A8h */ case    0:  		/* lwz R6, <#[R24 + 8]> */
		/* 822645A8h case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R24 + 0x00000008) );
		/* 822645A8h case    0:*/		return 0x822645AC;
		  /* 822645ACh */ case    1:  		/* addi R4, R1, 80 */
		/* 822645ACh case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 822645ACh case    1:*/		return 0x822645B0;
		  /* 822645B0h */ case    2:  		/* mr R3, R26 */
		/* 822645B0h case    2:*/		regs.R3 = regs.R26;
		/* 822645B0h case    2:*/		return 0x822645B4;
		  /* 822645B4h */ case    3:  		/* bl -876 */
		/* 822645B4h case    3:*/		regs.LR = 0x822645B8; return 0x82264248;
		/* 822645B4h case    3:*/		return 0x822645B8;
		  /* 822645B8h */ case    4:  		/* lwz R11, <#[R1 + 80]> */
		/* 822645B8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 822645B8h case    4:*/		return 0x822645BC;
		  /* 822645BCh */ case    5:  		/* lwz R10, <#[R1 + 84]> */
		/* 822645BCh case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 822645BCh case    5:*/		return 0x822645C0;
		  /* 822645C0h */ case    6:  		/* mr R5, R31 */
		/* 822645C0h case    6:*/		regs.R5 = regs.R31;
		/* 822645C0h case    6:*/		return 0x822645C4;
		  /* 822645C4h */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 822645C4h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 822645C4h case    7:*/		return 0x822645C8;
		  /* 822645C8h */ case    8:  		/* mr R3, R24 */
		/* 822645C8h case    8:*/		regs.R3 = regs.R24;
		/* 822645C8h case    8:*/		return 0x822645CC;
		  /* 822645CCh */ case    9:  		/* stwx R31, <#[R11 + R10]> */
		/* 822645CCh case    9:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 822645CCh case    9:*/		return 0x822645D0;
		  /* 822645D0h */ case   10:  		/* lwz R11, <#[R28 - 25556]> */
		/* 822645D0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0xFFFF9C2C) );
		/* 822645D0h case   10:*/		return 0x822645D4;
		  /* 822645D4h */ case   11:  		/* lwz R10, <#[R26]> */
		/* 822645D4h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000000) );
		/* 822645D4h case   11:*/		return 0x822645D8;
		  /* 822645D8h */ case   12:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 822645D8h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 822645D8h case   12:*/		return 0x822645DC;
		  /* 822645DCh */ case   13:  		/* lwzx R4, <#[R10 + R11]> */
		/* 822645DCh case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 822645DCh case   13:*/		return 0x822645E0;
		  /* 822645E0h */ case   14:  		/* bl -592 */
		/* 822645E0h case   14:*/		regs.LR = 0x822645E4; return 0x82264390;
		/* 822645E0h case   14:*/		return 0x822645E4;
	}
	return 0x822645E4;
} // Block from 822645A8h-822645E4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 822645E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822645E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822645E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822645E4);
		  /* 822645E4h */ case    0:  		/* lwz R11, <#[R27 + 4]> */
		/* 822645E4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 822645E4h case    0:*/		return 0x822645E8;
		  /* 822645E8h */ case    1:  		/* addi R25, R25, 1 */
		/* 822645E8h case    1:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x1);
		/* 822645E8h case    1:*/		return 0x822645EC;
		  /* 822645ECh */ case    2:  		/* cmpw CR6, R25, R11 */
		/* 822645ECh case    2:*/		cpu::op::cmpw<6>(regs,regs.R25,regs.R11);
		/* 822645ECh case    2:*/		return 0x822645F0;
		  /* 822645F0h */ case    3:  		/* bc 12, CR6_LT, -140 */
		/* 822645F0h case    3:*/		if ( regs.CR[6].lt ) { return 0x82264564;  }
		/* 822645F0h case    3:*/		return 0x822645F4;
	}
	return 0x822645F4;
} // Block from 822645E4h-822645F4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822645F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822645F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822645F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822645F4);
		  /* 822645F4h */ case    0:  		/* stw R23, <#[R22 + 4]> */
		/* 822645F4h case    0:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R22 + 0x00000004) );
		/* 822645F4h case    0:*/		return 0x822645F8;
		  /* 822645F8h */ case    1:  		/* stw R23, <#[R22 + 8]> */
		/* 822645F8h case    1:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R22 + 0x00000008) );
		/* 822645F8h case    1:*/		return 0x822645FC;
		  /* 822645FCh */ case    2:  		/* addi R1, R1, 176 */
		/* 822645FCh case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 822645FCh case    2:*/		return 0x82264600;
	}
	return 0x82264600;
} // Block from 822645F4h-82264600h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82264600h
// Function '?NewItem@Interpolator@XGRAPHICS@@SAPAVVRegInfo@2@HW4RegType@R400Tables@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264600( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264600) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264600);
		  /* 82264600h */ case    0:  		/* b -1913712 */
		/* 82264600h case    0:*/		return 0x82091290;
		/* 82264600h case    0:*/		return 0x82264604;
		  /* 82264604h */ case    1:  		/* nop */
		/* 82264604h case    1:*/		cpu::op::nop();
		/* 82264604h case    1:*/		return 0x82264608;
	}
	return 0x82264608;
} // Block from 82264600h-82264608h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82264608h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264608( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264608) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264608);
		  /* 82264608h */ case    0:  		/* mfspr R12, LR */
		/* 82264608h case    0:*/		regs.R12 = regs.LR;
		/* 82264608h case    0:*/		return 0x8226460C;
		  /* 8226460Ch */ case    1:  		/* bl -1913776 */
		/* 8226460Ch case    1:*/		regs.LR = 0x82264610; return 0x8209125C;
		/* 8226460Ch case    1:*/		return 0x82264610;
		  /* 82264610h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82264610h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82264610h case    2:*/		return 0x82264614;
		  /* 82264614h */ case    3:  		/* li R11, 0 */
		/* 82264614h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82264614h case    3:*/		return 0x82264618;
		  /* 82264618h */ case    4:  		/* stw R4, <#[R3 + 12]> */
		/* 82264618h case    4:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x0000000C) );
		/* 82264618h case    4:*/		return 0x8226461C;
		  /* 8226461Ch */ case    5:  		/* mr R31, R3 */
		/* 8226461Ch case    5:*/		regs.R31 = regs.R3;
		/* 8226461Ch case    5:*/		return 0x82264620;
		  /* 82264620h */ case    6:  		/* stw R6, <#[R3 + 8]> */
		/* 82264620h case    6:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R3 + 0x00000008) );
		/* 82264620h case    6:*/		return 0x82264624;
		  /* 82264624h */ case    7:  		/* cmpwi CR6, R5, 0 */
		/* 82264624h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 82264624h case    7:*/		return 0x82264628;
		  /* 82264628h */ case    8:  		/* stw R5, <#[R3 + 16]> */
		/* 82264628h case    8:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R3 + 0x00000010) );
		/* 82264628h case    8:*/		return 0x8226462C;
		  /* 8226462Ch */ case    9:  		/* stw R11, <#[R3]> */
		/* 8226462Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8226462Ch case    9:*/		return 0x82264630;
		  /* 82264630h */ case   10:  		/* bc 12, CR6_EQ, 232 */
		/* 82264630h case   10:*/		if ( regs.CR[6].eq ) { return 0x82264718;  }
		/* 82264630h case   10:*/		return 0x82264634;
		  /* 82264634h */ case   11:  		/* rlwinm R4, R5, 2, 0, 29 */
		/* 82264634h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R5);
		/* 82264634h case   11:*/		return 0x82264638;
		  /* 82264638h */ case   12:  		/* lwz R3, <#[R6 + 1456]> */
		/* 82264638h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R6 + 0x000005B0) );
		/* 82264638h case   12:*/		return 0x8226463C;
		  /* 8226463Ch */ case   13:  		/* bl -295300 */
		/* 8226463Ch case   13:*/		regs.LR = 0x82264640; return 0x8221C4B8;
		/* 8226463Ch case   13:*/		return 0x82264640;
		  /* 82264640h */ case   14:  		/* lis R11, -32215 */
		/* 82264640h case   14:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 82264640h case   14:*/		return 0x82264644;
		  /* 82264644h */ case   15:  		/* li R4, 20 */
		/* 82264644h case   15:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 82264644h case   15:*/		return 0x82264648;
		  /* 82264648h */ case   16:  		/* stw R3, <#[R11 - 25556]> */
		/* 82264648h case   16:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0xFFFF9C2C) );
		/* 82264648h case   16:*/		return 0x8226464C;
		  /* 8226464Ch */ case   17:  		/* lwz R11, <#[R31 + 8]> */
		/* 8226464Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8226464Ch case   17:*/		return 0x82264650;
		  /* 82264650h */ case   18:  		/* lwz R29, <#[R11 + 1456]> */
		/* 82264650h case   18:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x000005B0) );
		/* 82264650h case   18:*/		return 0x82264654;
		  /* 82264654h */ case   19:  		/* mr R3, R29 */
		/* 82264654h case   19:*/		regs.R3 = regs.R29;
		/* 82264654h case   19:*/		return 0x82264658;
	}
	return 0x82264658;
} // Block from 82264608h-82264658h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82264658h
// Function '?NewItem@BaseAddr@XGRAPHICS@@SAPAVVRegInfo@2@HW4RegType@R400Tables@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264658( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264658) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264658);
		  /* 82264658h */ case    0:  		/* bl -295328 */
		/* 82264658h case    0:*/		regs.LR = 0x8226465C; return 0x8221C4B8;
		/* 82264658h case    0:*/		return 0x8226465C;
		  /* 8226465Ch */ case    1:  		/* addic. R30, R3, 4 */
		/* 8226465Ch case    1:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R3,0x4);
		/* 8226465Ch case    1:*/		return 0x82264660;
		  /* 82264660h */ case    2:  		/* stw R29, <#[R3]> */
		/* 82264660h case    2:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 82264660h case    2:*/		return 0x82264664;
		  /* 82264664h */ case    3:  		/* bc 12, CR0_EQ, 24 */
		/* 82264664h case    3:*/		if ( regs.CR[0].eq ) { return 0x8226467C;  }
		/* 82264664h case    3:*/		return 0x82264668;
		  /* 82264668h */ case    4:  		/* lwz R11, <#[R31 + 8]> */
		/* 82264668h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82264668h case    4:*/		return 0x8226466C;
		  /* 8226466Ch */ case    5:  		/* mr R3, R30 */
		/* 8226466Ch case    5:*/		regs.R3 = regs.R30;
		/* 8226466Ch case    5:*/		return 0x82264670;
		  /* 82264670h */ case    6:  		/* lwz R4, <#[R11 + 1456]> */
		/* 82264670h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 82264670h case    6:*/		return 0x82264674;
		  /* 82264674h */ case    7:  		/* bl -190740 */
		/* 82264674h case    7:*/		regs.LR = 0x82264678; return 0x82235D60;
		/* 82264674h case    7:*/		return 0x82264678;
		  /* 82264678h */ case    8:  		/* b 8 */
		/* 82264678h case    8:*/		return 0x82264680;
		/* 82264678h case    8:*/		return 0x8226467C;
	}
	return 0x8226467C;
} // Block from 82264658h-8226467Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 8226467Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226467C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226467C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226467C);
		  /* 8226467Ch */ case    0:  		/* li R30, 0 */
		/* 8226467Ch case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8226467Ch case    0:*/		return 0x82264680;
	}
	return 0x82264680;
} // Block from 8226467Ch-82264680h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82264680h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264680( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264680) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264680);
		  /* 82264680h */ case    0:  		/* lwz R11, <#[R31 + 16]> */
		/* 82264680h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82264680h case    0:*/		return 0x82264684;
		  /* 82264684h */ case    1:  		/* li R29, 0 */
		/* 82264684h case    1:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82264684h case    1:*/		return 0x82264688;
		  /* 82264688h */ case    2:  		/* stw R30, <#[R31 + 4]> */
		/* 82264688h case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000004) );
		/* 82264688h case    2:*/		return 0x8226468C;
		  /* 8226468Ch */ case    3:  		/* cmpwi CR6, R11, 0 */
		/* 8226468Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 8226468Ch case    3:*/		return 0x82264690;
		  /* 82264690h */ case    4:  		/* bc 4, CR6_GT, 100 */
		/* 82264690h case    4:*/		if ( !regs.CR[6].gt ) { return 0x822646F4;  }
		/* 82264690h case    4:*/		return 0x82264694;
		  /* 82264694h */ case    5:  		/* lwz R11, <#[R31 + 8]> */
		/* 82264694h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82264694h case    5:*/		return 0x82264698;
		  /* 82264698h */ case    6:  		/* li R4, 24 */
		/* 82264698h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x18);
		/* 82264698h case    6:*/		return 0x8226469C;
		  /* 8226469Ch */ case    7:  		/* lwz R30, <#[R11 + 1456]> */
		/* 8226469Ch case    7:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x000005B0) );
		/* 8226469Ch case    7:*/		return 0x822646A0;
		  /* 822646A0h */ case    8:  		/* mr R3, R30 */
		/* 822646A0h case    8:*/		regs.R3 = regs.R30;
		/* 822646A0h case    8:*/		return 0x822646A4;
		  /* 822646A4h */ case    9:  		/* bl -295404 */
		/* 822646A4h case    9:*/		regs.LR = 0x822646A8; return 0x8221C4B8;
		/* 822646A4h case    9:*/		return 0x822646A8;
		  /* 822646A8h */ case   10:  		/* mr R11, R3 */
		/* 822646A8h case   10:*/		regs.R11 = regs.R3;
		/* 822646A8h case   10:*/		return 0x822646AC;
		  /* 822646ACh */ case   11:  		/* addic. R3, R3, 4 */
		/* 822646ACh case   11:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 822646ACh case   11:*/		return 0x822646B0;
	}
	return 0x822646B0;
} // Block from 82264680h-822646B0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 822646B0h
// Function '?NewItem@StandardIndex@XGRAPHICS@@SAPAVVRegInfo@2@HW4RegType@R400Tables@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822646B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822646B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822646B0);
		  /* 822646B0h */ case    0:  		/* stw R30, <#[R11]> */
		/* 822646B0h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 822646B0h case    0:*/		return 0x822646B4;
		  /* 822646B4h */ case    1:  		/* bc 12, CR0_EQ, 28 */
		/* 822646B4h case    1:*/		if ( regs.CR[0].eq ) { return 0x822646D0;  }
		/* 822646B4h case    1:*/		return 0x822646B8;
		  /* 822646B8h */ case    2:  		/* li R5, 0 */
		/* 822646B8h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 822646B8h case    2:*/		return 0x822646BC;
		  /* 822646BCh */ case    3:  		/* lwz R6, <#[R31 + 8]> */
		/* 822646BCh case    3:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000008) );
		/* 822646BCh case    3:*/		return 0x822646C0;
		  /* 822646C0h */ case    4:  		/* mr R4, R29 */
		/* 822646C0h case    4:*/		regs.R4 = regs.R29;
		/* 822646C0h case    4:*/		return 0x822646C4;
		  /* 822646C4h */ case    5:  		/* bl -692 */
		/* 822646C4h case    5:*/		regs.LR = 0x822646C8; return 0x82264410;
		/* 822646C4h case    5:*/		return 0x822646C8;
		  /* 822646C8h */ case    6:  		/* mr R30, R3 */
		/* 822646C8h case    6:*/		regs.R30 = regs.R3;
		/* 822646C8h case    6:*/		return 0x822646CC;
		  /* 822646CCh */ case    7:  		/* b 8 */
		/* 822646CCh case    7:*/		return 0x822646D4;
		/* 822646CCh case    7:*/		return 0x822646D0;
	}
	return 0x822646D0;
} // Block from 822646B0h-822646D0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 822646D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822646D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822646D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822646D0);
		  /* 822646D0h */ case    0:  		/* li R30, 0 */
		/* 822646D0h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 822646D0h case    0:*/		return 0x822646D4;
	}
	return 0x822646D4;
} // Block from 822646D0h-822646D4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822646D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822646D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822646D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822646D4);
		  /* 822646D4h */ case    0:  		/* lwz R3, <#[R31 + 4]> */
		/* 822646D4h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 822646D4h case    0:*/		return 0x822646D8;
		  /* 822646D8h */ case    1:  		/* lwz R4, <#[R3 + 4]> */
		/* 822646D8h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 822646D8h case    1:*/		return 0x822646DC;
		  /* 822646DCh */ case    2:  		/* bl -68636 */
		/* 822646DCh case    2:*/		regs.LR = 0x822646E0; return 0x82253AC0;
		/* 822646DCh case    2:*/		return 0x822646E0;
		  /* 822646E0h */ case    3:  		/* addi R29, R29, 1 */
		/* 822646E0h case    3:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 822646E0h case    3:*/		return 0x822646E4;
		  /* 822646E4h */ case    4:  		/* stw R30, <#[R3]> */
		/* 822646E4h case    4:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 822646E4h case    4:*/		return 0x822646E8;
		  /* 822646E8h */ case    5:  		/* lwz R11, <#[R31 + 16]> */
		/* 822646E8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 822646E8h case    5:*/		return 0x822646EC;
		  /* 822646ECh */ case    6:  		/* cmpw CR6, R29, R11 */
		/* 822646ECh case    6:*/		cpu::op::cmpw<6>(regs,regs.R29,regs.R11);
		/* 822646ECh case    6:*/		return 0x822646F0;
		  /* 822646F0h */ case    7:  		/* bc 12, CR6_LT, -92 */
		/* 822646F0h case    7:*/		if ( regs.CR[6].lt ) { return 0x82264694;  }
		/* 822646F0h case    7:*/		return 0x822646F4;
	}
	return 0x822646F4;
} // Block from 822646D4h-822646F4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 822646F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822646F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822646F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822646F4);
		  /* 822646F4h */ case    0:  		/* lwz R11, <#[R31 + 16]> */
		/* 822646F4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 822646F4h case    0:*/		return 0x822646F8;
		  /* 822646F8h */ case    1:  		/* lwz R10, <#[R31 + 8]> */
		/* 822646F8h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 822646F8h case    1:*/		return 0x822646FC;
		  /* 822646FCh */ case    2:  		/* addi R9, R11, -1 */
		/* 822646FCh case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFFF);
		/* 822646FCh case    2:*/		return 0x82264700;
		  /* 82264700h */ case    3:  		/* mullw R11, R9, R11 */
		/* 82264700h case    3:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82264700h case    3:*/		return 0x82264704;
		  /* 82264704h */ case    4:  		/* lwz R4, <#[R10 + 1456]> */
		/* 82264704h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x000005B0) );
		/* 82264704h case    4:*/		return 0x82264708;
	}
	return 0x82264708;
} // Block from 822646F4h-82264708h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82264708h
// Function '?NewItem@Resource@XGRAPHICS@@SAPAVVRegInfo@2@HW4RegType@R400Tables@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264708( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264708) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264708);
		  /* 82264708h */ case    0:  		/* srawi R11, R11, 1 */
		/* 82264708h case    0:*/		cpu::op::srawi<0,1>(regs,&regs.R11,regs.R11);
		/* 82264708h case    0:*/		return 0x8226470C;
		  /* 8226470Ch */ case    1:  		/* addze R3, R11 */
		/* 8226470Ch case    1:*/		cpu::op::addze<0>(regs,&regs.R3,regs.R11);
		/* 8226470Ch case    1:*/		return 0x82264710;
		  /* 82264710h */ case    2:  		/* bl -187856 */
		/* 82264710h case    2:*/		regs.LR = 0x82264714; return 0x82236940;
		/* 82264710h case    2:*/		return 0x82264714;
		  /* 82264714h */ case    3:  		/* stw R3, <#[R31]> */
		/* 82264714h case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 82264714h case    3:*/		return 0x82264718;
	}
	return 0x82264718;
} // Block from 82264708h-82264718h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82264718h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264718( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264718) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264718);
		  /* 82264718h */ case    0:  		/* mr R3, R31 */
		/* 82264718h case    0:*/		regs.R3 = regs.R31;
		/* 82264718h case    0:*/		return 0x8226471C;
		  /* 8226471Ch */ case    1:  		/* addi R1, R1, 112 */
		/* 8226471Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8226471Ch case    1:*/		return 0x82264720;
		  /* 82264720h */ case    2:  		/* b -1913972 */
		/* 82264720h case    2:*/		return 0x820912AC;
		/* 82264720h case    2:*/		return 0x82264724;
		  /* 82264724h */ case    3:  		/* nop */
		/* 82264724h case    3:*/		cpu::op::nop();
		/* 82264724h case    3:*/		return 0x82264728;
	}
	return 0x82264728;
} // Block from 82264718h-82264728h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82264728h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264728( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264728) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264728);
		  /* 82264728h */ case    0:  		/* mfspr R12, LR */
		/* 82264728h case    0:*/		regs.R12 = regs.LR;
		/* 82264728h case    0:*/		return 0x8226472C;
		  /* 8226472Ch */ case    1:  		/* bl -1914064 */
		/* 8226472Ch case    1:*/		regs.LR = 0x82264730; return 0x8209125C;
		/* 8226472Ch case    1:*/		return 0x82264730;
		  /* 82264730h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82264730h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82264730h case    2:*/		return 0x82264734;
		  /* 82264734h */ case    3:  		/* mr R30, R3 */
		/* 82264734h case    3:*/		regs.R30 = regs.R3;
		/* 82264734h case    3:*/		return 0x82264738;
		  /* 82264738h */ case    4:  		/* lwz R3, <#[R3 + 4]> */
		/* 82264738h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000004) );
		/* 82264738h case    4:*/		return 0x8226473C;
		  /* 8226473Ch */ case    5:  		/* mr R31, R4 */
		/* 8226473Ch case    5:*/		regs.R31 = regs.R4;
		/* 8226473Ch case    5:*/		return 0x82264740;
		  /* 82264740h */ case    6:  		/* lwz R11, <#[R3 + 4]> */
		/* 82264740h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82264740h case    6:*/		return 0x82264744;
		  /* 82264744h */ case    7:  		/* cmplw CR6, R5, R11 */
		/* 82264744h case    7:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R11);
		/* 82264744h case    7:*/		return 0x82264748;
		  /* 82264748h */ case    8:  		/* bc 4, CR6_LT, 20 */
		/* 82264748h case    8:*/		if ( !regs.CR[6].lt ) { return 0x8226475C;  }
		/* 82264748h case    8:*/		return 0x8226474C;
		  /* 8226474Ch */ case    9:  		/* lwz R10, <#[R3 + 8]> */
		/* 8226474Ch case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 8226474Ch case    9:*/		return 0x82264750;
		  /* 82264750h */ case   10:  		/* rlwinm R11, R5, 2, 0, 29 */
		/* 82264750h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R5);
		/* 82264750h case   10:*/		return 0x82264754;
		  /* 82264754h */ case   11:  		/* add R29, R10, R11 */
		/* 82264754h case   11:*/		cpu::op::add<0>(regs,&regs.R29,regs.R10,regs.R11);
		/* 82264754h case   11:*/		return 0x82264758;
		  /* 82264758h */ case   12:  		/* b 16 */
		/* 82264758h case   12:*/		return 0x82264768;
		/* 82264758h case   12:*/		return 0x8226475C;
	}
	return 0x8226475C;
} // Block from 82264728h-8226475Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8226475Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226475C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226475C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226475C);
		  /* 8226475Ch */ case    0:  		/* mr R4, R5 */
		/* 8226475Ch case    0:*/		regs.R4 = regs.R5;
		/* 8226475Ch case    0:*/		return 0x82264760;
	}
	return 0x82264760;
} // Block from 8226475Ch-82264760h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82264760h
// Function '?NewItem@LoopRegister@XGRAPHICS@@SAPAVVRegInfo@2@HW4RegType@R400Tables@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264760( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264760) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264760);
		  /* 82264760h */ case    0:  		/* bl -68768 */
		/* 82264760h case    0:*/		regs.LR = 0x82264764; return 0x82253AC0;
		/* 82264760h case    0:*/		return 0x82264764;
		  /* 82264764h */ case    1:  		/* mr R29, R3 */
		/* 82264764h case    1:*/		regs.R29 = regs.R3;
		/* 82264764h case    1:*/		return 0x82264768;
	}
	return 0x82264768;
} // Block from 82264760h-82264768h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82264768h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264768( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264768) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264768);
		  /* 82264768h */ case    0:  		/* lwz R3, <#[R30 + 4]> */
		/* 82264768h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000004) );
		/* 82264768h case    0:*/		return 0x8226476C;
		  /* 8226476Ch */ case    1:  		/* lwz R11, <#[R3 + 4]> */
		/* 8226476Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8226476Ch case    1:*/		return 0x82264770;
		  /* 82264770h */ case    2:  		/* cmplw CR6, R31, R11 */
		/* 82264770h case    2:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82264770h case    2:*/		return 0x82264774;
		  /* 82264774h */ case    3:  		/* bc 4, CR6_LT, 20 */
		/* 82264774h case    3:*/		if ( !regs.CR[6].lt ) { return 0x82264788;  }
		/* 82264774h case    3:*/		return 0x82264778;
		  /* 82264778h */ case    4:  		/* lwz R11, <#[R3 + 8]> */
		/* 82264778h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82264778h case    4:*/		return 0x8226477C;
		  /* 8226477Ch */ case    5:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 8226477Ch case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 8226477Ch case    5:*/		return 0x82264780;
		  /* 82264780h */ case    6:  		/* add R3, R11, R10 */
		/* 82264780h case    6:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 82264780h case    6:*/		return 0x82264784;
		  /* 82264784h */ case    7:  		/* b 12 */
		/* 82264784h case    7:*/		return 0x82264790;
		/* 82264784h case    7:*/		return 0x82264788;
	}
	return 0x82264788;
} // Block from 82264768h-82264788h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82264788h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264788( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264788) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264788);
		  /* 82264788h */ case    0:  		/* mr R4, R31 */
		/* 82264788h case    0:*/		regs.R4 = regs.R31;
		/* 82264788h case    0:*/		return 0x8226478C;
		  /* 8226478Ch */ case    1:  		/* bl -68812 */
		/* 8226478Ch case    1:*/		regs.LR = 0x82264790; return 0x82253AC0;
		/* 8226478Ch case    1:*/		return 0x82264790;
	}
	return 0x82264790;
} // Block from 82264788h-82264790h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82264790h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264790( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264790) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264790);
		  /* 82264790h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82264790h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82264790h case    0:*/		return 0x82264794;
		  /* 82264794h */ case    1:  		/* lwz R3, <#[R11 + 16]> */
		/* 82264794h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000010) );
		/* 82264794h case    1:*/		return 0x82264798;
		  /* 82264798h */ case    2:  		/* lwz R4, <#[R3 + 4]> */
		/* 82264798h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 82264798h case    2:*/		return 0x8226479C;
		  /* 8226479Ch */ case    3:  		/* bl -68828 */
		/* 8226479Ch case    3:*/		regs.LR = 0x822647A0; return 0x82253AC0;
		/* 8226479Ch case    3:*/		return 0x822647A0;
		  /* 822647A0h */ case    4:  		/* lwz R11, <#[R29]> */
		/* 822647A0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 822647A0h case    4:*/		return 0x822647A4;
		  /* 822647A4h */ case    5:  		/* stw R11, <#[R3]> */
		/* 822647A4h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822647A4h case    5:*/		return 0x822647A8;
		  /* 822647A8h */ case    6:  		/* addi R1, R1, 112 */
		/* 822647A8h case    6:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 822647A8h case    6:*/		return 0x822647AC;
		  /* 822647ACh */ case    7:  		/* b -1914112 */
		/* 822647ACh case    7:*/		return 0x820912AC;
		/* 822647ACh case    7:*/		return 0x822647B0;
	}
	return 0x822647B0;
} // Block from 82264790h-822647B0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 822647B0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822647B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822647B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822647B0);
		  /* 822647B0h */ case    0:  		/* mfspr R12, LR */
		/* 822647B0h case    0:*/		regs.R12 = regs.LR;
		/* 822647B0h case    0:*/		return 0x822647B4;
		  /* 822647B4h */ case    1:  		/* bl -1914204 */
		/* 822647B4h case    1:*/		regs.LR = 0x822647B8; return 0x82091258;
		/* 822647B4h case    1:*/		return 0x822647B8;
	}
	return 0x822647B8;
} // Block from 822647B0h-822647B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822647B8h
// Function '?NewItem@LoopIndexedOutputSet@XGRAPHICS@@SAPAVVRegInfo@2@HW4RegType@R400Tables@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822647B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822647B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822647B8);
		  /* 822647B8h */ case    0:  		/* stwu R1, <#[R1 - 128]> */
		/* 822647B8h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 822647B8h case    0:*/		return 0x822647BC;
		  /* 822647BCh */ case    1:  		/* lwz R28, <#[R3 + 16]> */
		/* 822647BCh case    1:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R3 + 0x00000010) );
		/* 822647BCh case    1:*/		return 0x822647C0;
		  /* 822647C0h */ case    2:  		/* mr R31, R3 */
		/* 822647C0h case    2:*/		regs.R31 = regs.R3;
		/* 822647C0h case    2:*/		return 0x822647C4;
		  /* 822647C4h */ case    3:  		/* lwz R10, <#[R3 + 8]> */
		/* 822647C4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 822647C4h case    3:*/		return 0x822647C8;
		  /* 822647C8h */ case    4:  		/* addi R11, R28, 1 */
		/* 822647C8h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R28,0x1);
		/* 822647C8h case    4:*/		return 0x822647CC;
		  /* 822647CCh */ case    5:  		/* lwz R29, <#[R3]> */
		/* 822647CCh case    5:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 822647CCh case    5:*/		return 0x822647D0;
		  /* 822647D0h */ case    6:  		/* stw R11, <#[R3 + 16]> */
		/* 822647D0h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 822647D0h case    6:*/		return 0x822647D4;
		  /* 822647D4h */ case    7:  		/* addi R9, R11, -1 */
		/* 822647D4h case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFFF);
		/* 822647D4h case    7:*/		return 0x822647D8;
		  /* 822647D8h */ case    8:  		/* mullw R11, R9, R11 */
		/* 822647D8h case    8:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 822647D8h case    8:*/		return 0x822647DC;
		  /* 822647DCh */ case    9:  		/* lwz R4, <#[R10 + 1456]> */
		/* 822647DCh case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x000005B0) );
		/* 822647DCh case    9:*/		return 0x822647E0;
		  /* 822647E0h */ case   10:  		/* srawi R11, R11, 1 */
		/* 822647E0h case   10:*/		cpu::op::srawi<0,1>(regs,&regs.R11,regs.R11);
		/* 822647E0h case   10:*/		return 0x822647E4;
		  /* 822647E4h */ case   11:  		/* addze R30, R11 */
		/* 822647E4h case   11:*/		cpu::op::addze<0>(regs,&regs.R30,regs.R11);
		/* 822647E4h case   11:*/		return 0x822647E8;
		  /* 822647E8h */ case   12:  		/* mr R3, R30 */
		/* 822647E8h case   12:*/		regs.R3 = regs.R30;
		/* 822647E8h case   12:*/		return 0x822647EC;
		  /* 822647ECh */ case   13:  		/* bl -188076 */
		/* 822647ECh case   13:*/		regs.LR = 0x822647F0; return 0x82236940;
		/* 822647ECh case   13:*/		return 0x822647F0;
		  /* 822647F0h */ case   14:  		/* lwz R11, <#[R31 + 16]> */
		/* 822647F0h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 822647F0h case   14:*/		return 0x822647F4;
		  /* 822647F4h */ case   15:  		/* subf R10, R11, R30 */
		/* 822647F4h case   15:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R30);
		/* 822647F4h case   15:*/		return 0x822647F8;
		  /* 822647F8h */ case   16:  		/* stw R3, <#[R31]> */
		/* 822647F8h case   16:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 822647F8h case   16:*/		return 0x822647FC;
		  /* 822647FCh */ case   17:  		/* li R11, 0 */
		/* 822647FCh case   17:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822647FCh case   17:*/		return 0x82264800;
		  /* 82264800h */ case   18:  		/* addic. R10, R10, 1 */
		/* 82264800h case   18:*/		cpu::op::addic<1>(regs,&regs.R10,regs.R10,0x1);
		/* 82264800h case   18:*/		return 0x82264804;
		  /* 82264804h */ case   19:  		/* bc 4, CR0_GT, 84 */
		/* 82264804h case   19:*/		if ( !regs.CR[0].gt ) { return 0x82264858;  }
		/* 82264804h case   19:*/		return 0x82264808;
		  /* 82264808h */ case   20:  		/* rlwinm R10, R11, 27, 5, 31 */
		/* 82264808h case   20:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R11);
		/* 82264808h case   20:*/		return 0x8226480C;
		  /* 8226480Ch */ case   21:  		/* rlwinm R9, R11, 0, 27, 31 */
		/* 8226480Ch case   21:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R11);
		/* 8226480Ch case   21:*/		return 0x82264810;
	}
	return 0x82264810;
} // Block from 822647B8h-82264810h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82264810h
// Function '?NewItem@LoopIndexedInputSet@XGRAPHICS@@SAPAVVRegInfo@2@HW4RegType@R400Tables@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264810( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264810) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264810);
		  /* 82264810h */ case    0:  		/* addi R10, R10, 2 */
		/* 82264810h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 82264810h case    0:*/		return 0x82264814;
		  /* 82264814h */ case    1:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 82264814h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 82264814h case    1:*/		return 0x82264818;
		  /* 82264818h */ case    2:  		/* lwzx R8, <#[R10 + R29]> */
		/* 82264818h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R29 + 0x00000000) );
		/* 82264818h case    2:*/		return 0x8226481C;
		  /* 8226481Ch */ case    3:  		/* srw R8, R8, R9 */
		/* 8226481Ch case    3:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R8,regs.R9);
		/* 8226481Ch case    3:*/		return 0x82264820;
		  /* 82264820h */ case    4:  		/* rlwinm. R8, R8, 0, 31, 31 */
		/* 82264820h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R8,regs.R8);
		/* 82264820h case    4:*/		return 0x82264824;
		  /* 82264824h */ case    5:  		/* bc 12, CR0_EQ, 28 */
		/* 82264824h case    5:*/		if ( regs.CR[0].eq ) { return 0x82264840;  }
		/* 82264824h case    5:*/		return 0x82264828;
		  /* 82264828h */ case    6:  		/* lwz R8, <#[R31]> */
		/* 82264828h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 82264828h case    6:*/		return 0x8226482C;
		  /* 8226482Ch */ case    7:  		/* li R7, 1 */
		/* 8226482Ch case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 8226482Ch case    7:*/		return 0x82264830;
		  /* 82264830h */ case    8:  		/* slw R9, R7, R9 */
		/* 82264830h case    8:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 82264830h case    8:*/		return 0x82264834;
		  /* 82264834h */ case    9:  		/* lwzx R7, <#[R10 + R8]> */
		/* 82264834h case    9:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 82264834h case    9:*/		return 0x82264838;
		  /* 82264838h */ case   10:  		/* or R9, R9, R7 */
		/* 82264838h case   10:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 82264838h case   10:*/		return 0x8226483C;
		  /* 8226483Ch */ case   11:  		/* stwx R9, <#[R10 + R8]> */
		/* 8226483Ch case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 8226483Ch case   11:*/		return 0x82264840;
	}
	return 0x82264840;
} // Block from 82264810h-82264840h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82264840h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264840( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264840) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264840);
		  /* 82264840h */ case    0:  		/* lwz R10, <#[R31 + 16]> */
		/* 82264840h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 82264840h case    0:*/		return 0x82264844;
		  /* 82264844h */ case    1:  		/* addi R11, R11, 1 */
		/* 82264844h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82264844h case    1:*/		return 0x82264848;
		  /* 82264848h */ case    2:  		/* subf R10, R10, R30 */
		/* 82264848h case    2:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R10,regs.R30);
		/* 82264848h case    2:*/		return 0x8226484C;
		  /* 8226484Ch */ case    3:  		/* addi R10, R10, 1 */
		/* 8226484Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8226484Ch case    3:*/		return 0x82264850;
		  /* 82264850h */ case    4:  		/* cmpw CR6, R11, R10 */
		/* 82264850h case    4:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 82264850h case    4:*/		return 0x82264854;
		  /* 82264854h */ case    5:  		/* bc 12, CR6_LT, -76 */
		/* 82264854h case    5:*/		if ( regs.CR[6].lt ) { return 0x82264808;  }
		/* 82264854h case    5:*/		return 0x82264858;
	}
	return 0x82264858;
} // Block from 82264840h-82264858h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82264858h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264858( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264858) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264858);
		  /* 82264858h */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 82264858h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82264858h case    0:*/		return 0x8226485C;
		  /* 8226485Ch */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 8226485Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8226486C;  }
		/* 8226485Ch case    1:*/		return 0x82264860;
		  /* 82264860h */ case    2:  		/* addi R4, R29, -4 */
		/* 82264860h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R29,0xFFFFFFFC);
		/* 82264860h case    2:*/		return 0x82264864;
		  /* 82264864h */ case    3:  		/* lwz R3, <#[R29 - 4]> */
		/* 82264864h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0xFFFFFFFC) );
		/* 82264864h case    3:*/		return 0x82264868;
	}
	return 0x82264868;
} // Block from 82264858h-82264868h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82264868h
// Function '?NewItem@LoopIndexedConstSet@XGRAPHICS@@SAPAVVRegInfo@2@HW4RegType@R400Tables@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264868( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264868) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264868);
		  /* 82264868h */ case    0:  		/* bl -295464 */
		/* 82264868h case    0:*/		regs.LR = 0x8226486C; return 0x8221C640;
		/* 82264868h case    0:*/		return 0x8226486C;
	}
	return 0x8226486C;
} // Block from 82264868h-8226486Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226486Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226486C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226486C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226486C);
		  /* 8226486Ch */ case    0:  		/* lwz R10, <#[R31 + 8]> */
		/* 8226486Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8226486Ch case    0:*/		return 0x82264870;
		  /* 82264870h */ case    1:  		/* lis R30, -32215 */
		/* 82264870h case    1:*/		cpu::op::lis<0>(regs,&regs.R30,0xFFFF8229);
		/* 82264870h case    1:*/		return 0x82264874;
		  /* 82264874h */ case    2:  		/* lwz R11, <#[R31 + 16]> */
		/* 82264874h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 82264874h case    2:*/		return 0x82264878;
		  /* 82264878h */ case    3:  		/* rlwinm R4, R11, 2, 0, 29 */
		/* 82264878h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R11);
		/* 82264878h case    3:*/		return 0x8226487C;
		  /* 8226487Ch */ case    4:  		/* lwz R29, <#[R30 - 25556]> */
		/* 8226487Ch case    4:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R30 + 0xFFFF9C2C) );
		/* 8226487Ch case    4:*/		return 0x82264880;
		  /* 82264880h */ case    5:  		/* lwz R3, <#[R10 + 1456]> */
		/* 82264880h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + 0x000005B0) );
		/* 82264880h case    5:*/		return 0x82264884;
		  /* 82264884h */ case    6:  		/* bl -295884 */
		/* 82264884h case    6:*/		regs.LR = 0x82264888; return 0x8221C4B8;
		/* 82264884h case    6:*/		return 0x82264888;
		  /* 82264888h */ case    7:  		/* cmpwi CR6, R28, 0 */
		/* 82264888h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 82264888h case    7:*/		return 0x8226488C;
		  /* 8226488Ch */ case    8:  		/* stw R3, <#[R30 - 25556]> */
		/* 8226488Ch case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0xFFFF9C2C) );
		/* 8226488Ch case    8:*/		return 0x82264890;
		  /* 82264890h */ case    9:  		/* bc 4, CR6_GT, 36 */
		/* 82264890h case    9:*/		if ( !regs.CR[6].gt ) { return 0x822648B4;  }
		/* 82264890h case    9:*/		return 0x82264894;
		  /* 82264894h */ case   10:  		/* li R11, 0 */
		/* 82264894h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82264894h case   10:*/		return 0x82264898;
		  /* 82264898h */ case   11:  		/* mtspr CTR, R28 */
		/* 82264898h case   11:*/		regs.CTR = regs.R28;
		/* 82264898h case   11:*/		return 0x8226489C;
		  /* 8226489Ch */ case   12:  		/* b 8 */
		/* 8226489Ch case   12:*/		return 0x822648A4;
		/* 8226489Ch case   12:*/		return 0x822648A0;
		  /* 822648A0h */ case   13:  		/* lwz R3, <#[R30 - 25556]> */
		/* 822648A0h case   13:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0xFFFF9C2C) );
		/* 822648A0h case   13:*/		return 0x822648A4;
	}
	return 0x822648A4;
} // Block from 8226486Ch-822648A4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 822648A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822648A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822648A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822648A4);
		  /* 822648A4h */ case    0:  		/* lwzx R10, <#[R11 + R29]> */
		/* 822648A4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 822648A4h case    0:*/		return 0x822648A8;
		  /* 822648A8h */ case    1:  		/* stwx R10, <#[R11 + R3]> */
		/* 822648A8h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 822648A8h case    1:*/		return 0x822648AC;
		  /* 822648ACh */ case    2:  		/* addi R11, R11, 4 */
		/* 822648ACh case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 822648ACh case    2:*/		return 0x822648B0;
		  /* 822648B0h */ case    3:  		/* bc 16, CR0_LT, -16 */
		/* 822648B0h case    3:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x822648A0;  }
		/* 822648B0h case    3:*/		return 0x822648B4;
	}
	return 0x822648B4;
} // Block from 822648A4h-822648B4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822648B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822648B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822648B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822648B4);
		  /* 822648B4h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 822648B4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 822648B4h case    0:*/		return 0x822648B8;
		  /* 822648B8h */ case    1:  		/* mr R4, R29 */
		/* 822648B8h case    1:*/		regs.R4 = regs.R29;
		/* 822648B8h case    1:*/		return 0x822648BC;
		  /* 822648BCh */ case    2:  		/* lwz R3, <#[R11 + 1456]> */
		/* 822648BCh case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005B0) );
		/* 822648BCh case    2:*/		return 0x822648C0;
	}
	return 0x822648C0;
} // Block from 822648B4h-822648C0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822648C0h
// Function '?NewItem@HosCoord@XGRAPHICS@@SAPAVVRegInfo@2@HW4RegType@R400Tables@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822648C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822648C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822648C0);
		  /* 822648C0h */ case    0:  		/* bl -295552 */
		/* 822648C0h case    0:*/		regs.LR = 0x822648C4; return 0x8221C640;
		/* 822648C0h case    0:*/		return 0x822648C4;
		  /* 822648C4h */ case    1:  		/* lwz R11, <#[R31 + 8]> */
		/* 822648C4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 822648C4h case    1:*/		return 0x822648C8;
		  /* 822648C8h */ case    2:  		/* li R4, 24 */
		/* 822648C8h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x18);
		/* 822648C8h case    2:*/		return 0x822648CC;
		  /* 822648CCh */ case    3:  		/* lwz R30, <#[R11 + 1456]> */
		/* 822648CCh case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x000005B0) );
		/* 822648CCh case    3:*/		return 0x822648D0;
		  /* 822648D0h */ case    4:  		/* mr R3, R30 */
		/* 822648D0h case    4:*/		regs.R3 = regs.R30;
		/* 822648D0h case    4:*/		return 0x822648D4;
		  /* 822648D4h */ case    5:  		/* bl -295964 */
		/* 822648D4h case    5:*/		regs.LR = 0x822648D8; return 0x8221C4B8;
		/* 822648D4h case    5:*/		return 0x822648D8;
		  /* 822648D8h */ case    6:  		/* mr R11, R3 */
		/* 822648D8h case    6:*/		regs.R11 = regs.R3;
		/* 822648D8h case    6:*/		return 0x822648DC;
		  /* 822648DCh */ case    7:  		/* addic. R3, R3, 4 */
		/* 822648DCh case    7:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 822648DCh case    7:*/		return 0x822648E0;
		  /* 822648E0h */ case    8:  		/* stw R30, <#[R11]> */
		/* 822648E0h case    8:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 822648E0h case    8:*/		return 0x822648E4;
		  /* 822648E4h */ case    9:  		/* bc 12, CR0_EQ, 28 */
		/* 822648E4h case    9:*/		if ( regs.CR[0].eq ) { return 0x82264900;  }
		/* 822648E4h case    9:*/		return 0x822648E8;
		  /* 822648E8h */ case   10:  		/* li R5, 0 */
		/* 822648E8h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 822648E8h case   10:*/		return 0x822648EC;
		  /* 822648ECh */ case   11:  		/* lwz R6, <#[R31 + 8]> */
		/* 822648ECh case   11:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000008) );
		/* 822648ECh case   11:*/		return 0x822648F0;
		  /* 822648F0h */ case   12:  		/* mr R4, R28 */
		/* 822648F0h case   12:*/		regs.R4 = regs.R28;
		/* 822648F0h case   12:*/		return 0x822648F4;
		  /* 822648F4h */ case   13:  		/* bl -1252 */
		/* 822648F4h case   13:*/		regs.LR = 0x822648F8; return 0x82264410;
		/* 822648F4h case   13:*/		return 0x822648F8;
		  /* 822648F8h */ case   14:  		/* mr R30, R3 */
		/* 822648F8h case   14:*/		regs.R30 = regs.R3;
		/* 822648F8h case   14:*/		return 0x822648FC;
		  /* 822648FCh */ case   15:  		/* b 8 */
		/* 822648FCh case   15:*/		return 0x82264904;
		/* 822648FCh case   15:*/		return 0x82264900;
	}
	return 0x82264900;
} // Block from 822648C0h-82264900h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82264900h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264900( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264900) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264900);
		  /* 82264900h */ case    0:  		/* li R30, 0 */
		/* 82264900h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82264900h case    0:*/		return 0x82264904;
	}
	return 0x82264904;
} // Block from 82264900h-82264904h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82264904h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264904( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264904) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264904);
		  /* 82264904h */ case    0:  		/* lwz R3, <#[R31 + 4]> */
		/* 82264904h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 82264904h case    0:*/		return 0x82264908;
		  /* 82264908h */ case    1:  		/* lwz R4, <#[R3 + 4]> */
		/* 82264908h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 82264908h case    1:*/		return 0x8226490C;
		  /* 8226490Ch */ case    2:  		/* bl -69196 */
		/* 8226490Ch case    2:*/		regs.LR = 0x82264910; return 0x82253AC0;
		/* 8226490Ch case    2:*/		return 0x82264910;
		  /* 82264910h */ case    3:  		/* stw R30, <#[R3]> */
		/* 82264910h case    3:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 82264910h case    3:*/		return 0x82264914;
		  /* 82264914h */ case    4:  		/* addi R1, R1, 128 */
		/* 82264914h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82264914h case    4:*/		return 0x82264918;
	}
	return 0x82264918;
} // Block from 82264904h-82264918h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82264918h
// Function '?NewItem@ExportAddress@XGRAPHICS@@SAPAVVRegInfo@2@HW4RegType@R400Tables@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264918( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264918) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264918);
		  /* 82264918h */ case    0:  		/* b -1914480 */
		/* 82264918h case    0:*/		return 0x820912A8;
		/* 82264918h case    0:*/		return 0x8226491C;
		  /* 8226491Ch */ case    1:  		/* nop */
		/* 8226491Ch case    1:*/		cpu::op::nop();
		/* 8226491Ch case    1:*/		return 0x82264920;
	}
	return 0x82264920;
} // Block from 82264918h-82264920h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82264920h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264920( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264920) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264920);
		  /* 82264920h */ case    0:  		/* mfspr R12, LR */
		/* 82264920h case    0:*/		regs.R12 = regs.LR;
		/* 82264920h case    0:*/		return 0x82264924;
		  /* 82264924h */ case    1:  		/* bl -1914568 */
		/* 82264924h case    1:*/		regs.LR = 0x82264928; return 0x8209125C;
		/* 82264924h case    1:*/		return 0x82264928;
		  /* 82264928h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82264928h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82264928h case    2:*/		return 0x8226492C;
		  /* 8226492Ch */ case    3:  		/* mr R29, R3 */
		/* 8226492Ch case    3:*/		regs.R29 = regs.R3;
		/* 8226492Ch case    3:*/		return 0x82264930;
		  /* 82264930h */ case    4:  		/* mr R30, R4 */
		/* 82264930h case    4:*/		regs.R30 = regs.R4;
		/* 82264930h case    4:*/		return 0x82264934;
		  /* 82264934h */ case    5:  		/* mr R31, R5 */
		/* 82264934h case    5:*/		regs.R31 = regs.R5;
		/* 82264934h case    5:*/		return 0x82264938;
		  /* 82264938h */ case    6:  		/* cmpw CR6, R4, R5 */
		/* 82264938h case    6:*/		cpu::op::cmpw<6>(regs,regs.R4,regs.R5);
		/* 82264938h case    6:*/		return 0x8226493C;
		  /* 8226493Ch */ case    7:  		/* bc 12, CR6_EQ, 296 */
		/* 8226493Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x82264A64;  }
		/* 8226493Ch case    7:*/		return 0x82264940;
		  /* 82264940h */ case    8:  		/* bl -1536 */
		/* 82264940h case    8:*/		regs.LR = 0x82264944; return 0x82264340;
		/* 82264940h case    8:*/		return 0x82264944;
		  /* 82264944h */ case    9:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82264944h case    9:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82264944h case    9:*/		return 0x82264948;
		  /* 82264948h */ case   10:  		/* bc 4, CR0_EQ, 284 */
		/* 82264948h case   10:*/		if ( !regs.CR[0].eq ) { return 0x82264A64;  }
		/* 82264948h case   10:*/		return 0x8226494C;
		  /* 8226494Ch */ case   11:  		/* mr R5, R31 */
		/* 8226494Ch case   11:*/		regs.R5 = regs.R31;
		/* 8226494Ch case   11:*/		return 0x82264950;
		  /* 82264950h */ case   12:  		/* mr R4, R30 */
		/* 82264950h case   12:*/		regs.R4 = regs.R30;
		/* 82264950h case   12:*/		return 0x82264954;
		  /* 82264954h */ case   13:  		/* mr R3, R29 */
		/* 82264954h case   13:*/		regs.R3 = regs.R29;
		/* 82264954h case   13:*/		return 0x82264958;
		  /* 82264958h */ case   14:  		/* bl -1480 */
		/* 82264958h case   14:*/		regs.LR = 0x8226495C; return 0x82264390;
		/* 82264958h case   14:*/		return 0x8226495C;
		  /* 8226495Ch */ case   15:  		/* lwz R3, <#[R29 + 4]> */
		/* 8226495Ch case   15:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000004) );
		/* 8226495Ch case   15:*/		return 0x82264960;
		  /* 82264960h */ case   16:  		/* lwz R11, <#[R3 + 4]> */
		/* 82264960h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82264960h case   16:*/		return 0x82264964;
		  /* 82264964h */ case   17:  		/* cmplw CR6, R30, R11 */
		/* 82264964h case   17:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 82264964h case   17:*/		return 0x82264968;
		  /* 82264968h */ case   18:  		/* bc 4, CR6_LT, 20 */
		/* 82264968h case   18:*/		if ( !regs.CR[6].lt ) { return 0x8226497C;  }
		/* 82264968h case   18:*/		return 0x8226496C;
		  /* 8226496Ch */ case   19:  		/* lwz R11, <#[R3 + 8]> */
		/* 8226496Ch case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8226496Ch case   19:*/		return 0x82264970;
	}
	return 0x82264970;
} // Block from 82264920h-82264970h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82264970h
// Function '?NewItem@ExportSlot@XGRAPHICS@@SAPAVVRegInfo@2@HW4RegType@R400Tables@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264970( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264970) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264970);
		  /* 82264970h */ case    0:  		/* rlwinm R10, R30, 2, 0, 29 */
		/* 82264970h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R30);
		/* 82264970h case    0:*/		return 0x82264974;
		  /* 82264974h */ case    1:  		/* add R3, R11, R10 */
		/* 82264974h case    1:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 82264974h case    1:*/		return 0x82264978;
		  /* 82264978h */ case    2:  		/* b 12 */
		/* 82264978h case    2:*/		return 0x82264984;
		/* 82264978h case    2:*/		return 0x8226497C;
	}
	return 0x8226497C;
} // Block from 82264970h-8226497Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8226497Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226497C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226497C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226497C);
		  /* 8226497Ch */ case    0:  		/* mr R4, R30 */
		/* 8226497Ch case    0:*/		regs.R4 = regs.R30;
		/* 8226497Ch case    0:*/		return 0x82264980;
		  /* 82264980h */ case    1:  		/* bl -69312 */
		/* 82264980h case    1:*/		regs.LR = 0x82264984; return 0x82253AC0;
		/* 82264980h case    1:*/		return 0x82264984;
	}
	return 0x82264984;
} // Block from 8226497Ch-82264984h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82264984h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264984( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264984) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264984);
		  /* 82264984h */ case    0:  		/* addi R5, R1, 84 */
		/* 82264984h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 82264984h case    0:*/		return 0x82264988;
		  /* 82264988h */ case    1:  		/* lwz R3, <#[R3]> */
		/* 82264988h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 82264988h case    1:*/		return 0x8226498C;
		  /* 8226498Ch */ case    2:  		/* addi R4, R1, 80 */
		/* 8226498Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8226498Ch case    2:*/		return 0x82264990;
		  /* 82264990h */ case    3:  		/* bl -2264 */
		/* 82264990h case    3:*/		regs.LR = 0x82264994; return 0x822640B8;
		/* 82264990h case    3:*/		return 0x82264994;
		  /* 82264994h */ case    4:  		/* lwz R3, <#[R29 + 4]> */
		/* 82264994h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000004) );
		/* 82264994h case    4:*/		return 0x82264998;
		  /* 82264998h */ case    5:  		/* lwz R11, <#[R3 + 4]> */
		/* 82264998h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82264998h case    5:*/		return 0x8226499C;
		  /* 8226499Ch */ case    6:  		/* cmplw CR6, R30, R11 */
		/* 8226499Ch case    6:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 8226499Ch case    6:*/		return 0x822649A0;
		  /* 822649A0h */ case    7:  		/* bc 4, CR6_LT, 20 */
		/* 822649A0h case    7:*/		if ( !regs.CR[6].lt ) { return 0x822649B4;  }
		/* 822649A0h case    7:*/		return 0x822649A4;
		  /* 822649A4h */ case    8:  		/* lwz R11, <#[R3 + 8]> */
		/* 822649A4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 822649A4h case    8:*/		return 0x822649A8;
		  /* 822649A8h */ case    9:  		/* rlwinm R10, R30, 2, 0, 29 */
		/* 822649A8h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R30);
		/* 822649A8h case    9:*/		return 0x822649AC;
		  /* 822649ACh */ case   10:  		/* add R3, R11, R10 */
		/* 822649ACh case   10:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 822649ACh case   10:*/		return 0x822649B0;
		  /* 822649B0h */ case   11:  		/* b 12 */
		/* 822649B0h case   11:*/		return 0x822649BC;
		/* 822649B0h case   11:*/		return 0x822649B4;
	}
	return 0x822649B4;
} // Block from 82264984h-822649B4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 822649B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822649B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822649B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822649B4);
		  /* 822649B4h */ case    0:  		/* mr R4, R30 */
		/* 822649B4h case    0:*/		regs.R4 = regs.R30;
		/* 822649B4h case    0:*/		return 0x822649B8;
		  /* 822649B8h */ case    1:  		/* bl -69368 */
		/* 822649B8h case    1:*/		regs.LR = 0x822649BC; return 0x82253AC0;
		/* 822649B8h case    1:*/		return 0x822649BC;
	}
	return 0x822649BC;
} // Block from 822649B4h-822649BCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 822649BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822649BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822649BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822649BC);
		  /* 822649BCh */ case    0:  		/* addi R5, R1, 84 */
		/* 822649BCh case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 822649BCh case    0:*/		return 0x822649C0;
		  /* 822649C0h */ case    1:  		/* lwz R3, <#[R3]> */
		/* 822649C0h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 822649C0h case    1:*/		return 0x822649C4;
		  /* 822649C4h */ case    2:  		/* addi R4, R1, 80 */
		/* 822649C4h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 822649C4h case    2:*/		return 0x822649C8;
	}
	return 0x822649C8;
} // Block from 822649BCh-822649C8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822649C8h
// Function '?NewItem@Physical@XGRAPHICS@@SAPAVVRegInfo@2@HW4RegType@R400Tables@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822649C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822649C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822649C8);
		  /* 822649C8h */ case    0:  		/* lwz R6, <#[R29 + 8]> */
		/* 822649C8h case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R29 + 0x00000008) );
		/* 822649C8h case    0:*/		return 0x822649CC;
		  /* 822649CCh */ case    1:  		/* bl -1924 */
		/* 822649CCh case    1:*/		regs.LR = 0x822649D0; return 0x82264248;
		/* 822649CCh case    1:*/		return 0x822649D0;
		  /* 822649D0h */ case    2:  		/* lwz R11, <#[R1 + 80]> */
		/* 822649D0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 822649D0h case    2:*/		return 0x822649D4;
		  /* 822649D4h */ case    3:  		/* lwz R10, <#[R1 + 84]> */
		/* 822649D4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 822649D4h case    3:*/		return 0x822649D8;
		  /* 822649D8h */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 822649D8h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 822649D8h case    4:*/		return 0x822649DC;
		  /* 822649DCh */ case    5:  		/* stwx R31, <#[R11 + R10]> */
		/* 822649DCh case    5:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 822649DCh case    5:*/		return 0x822649E0;
		  /* 822649E0h */ case    6:  		/* lwz R3, <#[R29 + 4]> */
		/* 822649E0h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000004) );
		/* 822649E0h case    6:*/		return 0x822649E4;
		  /* 822649E4h */ case    7:  		/* lwz R11, <#[R3 + 4]> */
		/* 822649E4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 822649E4h case    7:*/		return 0x822649E8;
		  /* 822649E8h */ case    8:  		/* cmplw CR6, R31, R11 */
		/* 822649E8h case    8:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 822649E8h case    8:*/		return 0x822649EC;
		  /* 822649ECh */ case    9:  		/* bc 4, CR6_LT, 20 */
		/* 822649ECh case    9:*/		if ( !regs.CR[6].lt ) { return 0x82264A00;  }
		/* 822649ECh case    9:*/		return 0x822649F0;
		  /* 822649F0h */ case   10:  		/* lwz R11, <#[R3 + 8]> */
		/* 822649F0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 822649F0h case   10:*/		return 0x822649F4;
		  /* 822649F4h */ case   11:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 822649F4h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 822649F4h case   11:*/		return 0x822649F8;
		  /* 822649F8h */ case   12:  		/* add R3, R11, R10 */
		/* 822649F8h case   12:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 822649F8h case   12:*/		return 0x822649FC;
		  /* 822649FCh */ case   13:  		/* b 12 */
		/* 822649FCh case   13:*/		return 0x82264A08;
		/* 822649FCh case   13:*/		return 0x82264A00;
	}
	return 0x82264A00;
} // Block from 822649C8h-82264A00h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82264A00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264A00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264A00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264A00);
		  /* 82264A00h */ case    0:  		/* mr R4, R31 */
		/* 82264A00h case    0:*/		regs.R4 = regs.R31;
		/* 82264A00h case    0:*/		return 0x82264A04;
		  /* 82264A04h */ case    1:  		/* bl -69444 */
		/* 82264A04h case    1:*/		regs.LR = 0x82264A08; return 0x82253AC0;
		/* 82264A04h case    1:*/		return 0x82264A08;
	}
	return 0x82264A08;
} // Block from 82264A00h-82264A08h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82264A08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264A08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264A08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264A08);
		  /* 82264A08h */ case    0:  		/* addi R5, R1, 84 */
		/* 82264A08h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 82264A08h case    0:*/		return 0x82264A0C;
		  /* 82264A0Ch */ case    1:  		/* lwz R3, <#[R3]> */
		/* 82264A0Ch case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 82264A0Ch case    1:*/		return 0x82264A10;
		  /* 82264A10h */ case    2:  		/* addi R4, R1, 80 */
		/* 82264A10h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 82264A10h case    2:*/		return 0x82264A14;
		  /* 82264A14h */ case    3:  		/* bl -2396 */
		/* 82264A14h case    3:*/		regs.LR = 0x82264A18; return 0x822640B8;
		/* 82264A14h case    3:*/		return 0x82264A18;
		  /* 82264A18h */ case    4:  		/* lwz R3, <#[R29 + 4]> */
		/* 82264A18h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000004) );
		/* 82264A18h case    4:*/		return 0x82264A1C;
		  /* 82264A1Ch */ case    5:  		/* lwz R11, <#[R3 + 4]> */
		/* 82264A1Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82264A1Ch case    5:*/		return 0x82264A20;
	}
	return 0x82264A20;
} // Block from 82264A08h-82264A20h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82264A20h
// Function '?NewItem@ExportValue@XGRAPHICS@@SAPAVVRegInfo@2@HW4RegType@R400Tables@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264A20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264A20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264A20);
		  /* 82264A20h */ case    0:  		/* cmplw CR6, R31, R11 */
		/* 82264A20h case    0:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82264A20h case    0:*/		return 0x82264A24;
		  /* 82264A24h */ case    1:  		/* bc 4, CR6_LT, 20 */
		/* 82264A24h case    1:*/		if ( !regs.CR[6].lt ) { return 0x82264A38;  }
		/* 82264A24h case    1:*/		return 0x82264A28;
		  /* 82264A28h */ case    2:  		/* lwz R11, <#[R3 + 8]> */
		/* 82264A28h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82264A28h case    2:*/		return 0x82264A2C;
		  /* 82264A2Ch */ case    3:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 82264A2Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 82264A2Ch case    3:*/		return 0x82264A30;
		  /* 82264A30h */ case    4:  		/* add R3, R11, R10 */
		/* 82264A30h case    4:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 82264A30h case    4:*/		return 0x82264A34;
		  /* 82264A34h */ case    5:  		/* b 12 */
		/* 82264A34h case    5:*/		return 0x82264A40;
		/* 82264A34h case    5:*/		return 0x82264A38;
	}
	return 0x82264A38;
} // Block from 82264A20h-82264A38h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82264A38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264A38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264A38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264A38);
		  /* 82264A38h */ case    0:  		/* mr R4, R31 */
		/* 82264A38h case    0:*/		regs.R4 = regs.R31;
		/* 82264A38h case    0:*/		return 0x82264A3C;
		  /* 82264A3Ch */ case    1:  		/* bl -69500 */
		/* 82264A3Ch case    1:*/		regs.LR = 0x82264A40; return 0x82253AC0;
		/* 82264A3Ch case    1:*/		return 0x82264A40;
	}
	return 0x82264A40;
} // Block from 82264A38h-82264A40h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82264A40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264A40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264A40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264A40);
		  /* 82264A40h */ case    0:  		/* addi R5, R1, 84 */
		/* 82264A40h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 82264A40h case    0:*/		return 0x82264A44;
		  /* 82264A44h */ case    1:  		/* lwz R6, <#[R29 + 8]> */
		/* 82264A44h case    1:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R29 + 0x00000008) );
		/* 82264A44h case    1:*/		return 0x82264A48;
		  /* 82264A48h */ case    2:  		/* addi R4, R1, 80 */
		/* 82264A48h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 82264A48h case    2:*/		return 0x82264A4C;
		  /* 82264A4Ch */ case    3:  		/* lwz R3, <#[R3]> */
		/* 82264A4Ch case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 82264A4Ch case    3:*/		return 0x82264A50;
		  /* 82264A50h */ case    4:  		/* bl -2056 */
		/* 82264A50h case    4:*/		regs.LR = 0x82264A54; return 0x82264248;
		/* 82264A50h case    4:*/		return 0x82264A54;
		  /* 82264A54h */ case    5:  		/* lwz R11, <#[R1 + 80]> */
		/* 82264A54h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82264A54h case    5:*/		return 0x82264A58;
		  /* 82264A58h */ case    6:  		/* lwz R10, <#[R1 + 84]> */
		/* 82264A58h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000054) );
		/* 82264A58h case    6:*/		return 0x82264A5C;
		  /* 82264A5Ch */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82264A5Ch case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82264A5Ch case    7:*/		return 0x82264A60;
		  /* 82264A60h */ case    8:  		/* stwx R30, <#[R11 + R10]> */
		/* 82264A60h case    8:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82264A60h case    8:*/		return 0x82264A64;
	}
	return 0x82264A64;
} // Block from 82264A40h-82264A64h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82264A64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264A64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264A64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264A64);
		  /* 82264A64h */ case    0:  		/* addi R1, R1, 128 */
		/* 82264A64h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82264A64h case    0:*/		return 0x82264A68;
		  /* 82264A68h */ case    1:  		/* b -1914812 */
		/* 82264A68h case    1:*/		return 0x820912AC;
		/* 82264A68h case    1:*/		return 0x82264A6C;
		  /* 82264A6Ch */ case    2:  		/* nop */
		/* 82264A6Ch case    2:*/		cpu::op::nop();
		/* 82264A6Ch case    2:*/		return 0x82264A70;
	}
	return 0x82264A70;
} // Block from 82264A64h-82264A70h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82264A70h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264A70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264A70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264A70);
		  /* 82264A70h */ case    0:  		/* mfspr R12, LR */
		/* 82264A70h case    0:*/		regs.R12 = regs.LR;
		/* 82264A70h case    0:*/		return 0x82264A74;
		  /* 82264A74h */ case    1:  		/* bl -1914904 */
		/* 82264A74h case    1:*/		regs.LR = 0x82264A78; return 0x8209125C;
		/* 82264A74h case    1:*/		return 0x82264A78;
	}
	return 0x82264A78;
} // Block from 82264A70h-82264A78h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82264A78h
// Function '?NewItem@AutoIndexVtx@XGRAPHICS@@SAPAVVRegInfo@2@HW4RegType@R400Tables@@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264A78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264A78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264A78);
		  /* 82264A78h */ case    0:  		/* stwu R1, <#[R1 - 112]> */
		/* 82264A78h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82264A78h case    0:*/		return 0x82264A7C;
		  /* 82264A7Ch */ case    1:  		/* lwz R11, <#[R3 + 16]> */
		/* 82264A7Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82264A7Ch case    1:*/		return 0x82264A80;
		  /* 82264A80h */ case    2:  		/* mr R29, R3 */
		/* 82264A80h case    2:*/		regs.R29 = regs.R3;
		/* 82264A80h case    2:*/		return 0x82264A84;
		  /* 82264A84h */ case    3:  		/* li R31, 0 */
		/* 82264A84h case    3:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82264A84h case    3:*/		return 0x82264A88;
		  /* 82264A88h */ case    4:  		/* cmpwi CR6, R11, 0 */
		/* 82264A88h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82264A88h case    4:*/		return 0x82264A8C;
		  /* 82264A8Ch */ case    5:  		/* bc 4, CR6_GT, 76 */
		/* 82264A8Ch case    5:*/		if ( !regs.CR[6].gt ) { return 0x82264AD8;  }
		/* 82264A8Ch case    5:*/		return 0x82264A90;
		  /* 82264A90h */ case    6:  		/* li R30, 0 */
		/* 82264A90h case    6:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82264A90h case    6:*/		return 0x82264A94;
		  /* 82264A94h */ case    7:  		/* lwz R3, <#[R29 + 4]> */
		/* 82264A94h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x00000004) );
		/* 82264A94h case    7:*/		return 0x82264A98;
		  /* 82264A98h */ case    8:  		/* lwz R11, <#[R3 + 4]> */
		/* 82264A98h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82264A98h case    8:*/		return 0x82264A9C;
		  /* 82264A9Ch */ case    9:  		/* cmplw CR6, R31, R11 */
		/* 82264A9Ch case    9:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82264A9Ch case    9:*/		return 0x82264AA0;
		  /* 82264AA0h */ case   10:  		/* bc 4, CR6_LT, 16 */
		/* 82264AA0h case   10:*/		if ( !regs.CR[6].lt ) { return 0x82264AB0;  }
		/* 82264AA0h case   10:*/		return 0x82264AA4;
		  /* 82264AA4h */ case   11:  		/* lwz R11, <#[R3 + 8]> */
		/* 82264AA4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82264AA4h case   11:*/		return 0x82264AA8;
		  /* 82264AA8h */ case   12:  		/* add R3, R11, R30 */
		/* 82264AA8h case   12:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R30);
		/* 82264AA8h case   12:*/		return 0x82264AAC;
		  /* 82264AACh */ case   13:  		/* b 12 */
		/* 82264AACh case   13:*/		return 0x82264AB8;
		/* 82264AACh case   13:*/		return 0x82264AB0;
	}
	return 0x82264AB0;
} // Block from 82264A78h-82264AB0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82264AB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264AB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264AB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264AB0);
		  /* 82264AB0h */ case    0:  		/* mr R4, R31 */
		/* 82264AB0h case    0:*/		regs.R4 = regs.R31;
		/* 82264AB0h case    0:*/		return 0x82264AB4;
		  /* 82264AB4h */ case    1:  		/* bl -69620 */
		/* 82264AB4h case    1:*/		regs.LR = 0x82264AB8; return 0x82253AC0;
		/* 82264AB4h case    1:*/		return 0x82264AB8;
	}
	return 0x82264AB8;
} // Block from 82264AB0h-82264AB8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82264AB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264AB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264AB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264AB8);
		  /* 82264AB8h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82264AB8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82264AB8h case    0:*/		return 0x82264ABC;
		  /* 82264ABCh */ case    1:  		/* li R10, 0 */
		/* 82264ABCh case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82264ABCh case    1:*/		return 0x82264AC0;
		  /* 82264AC0h */ case    2:  		/* addi R31, R31, 1 */
		/* 82264AC0h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82264AC0h case    2:*/		return 0x82264AC4;
		  /* 82264AC4h */ case    3:  		/* addi R30, R30, 4 */
		/* 82264AC4h case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 82264AC4h case    3:*/		return 0x82264AC8;
		  /* 82264AC8h */ case    4:  		/* stw R10, <#[R11 + 4]> */
		/* 82264AC8h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82264AC8h case    4:*/		return 0x82264ACC;
		  /* 82264ACCh */ case    5:  		/* lwz R11, <#[R29 + 16]> */
		/* 82264ACCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 82264ACCh case    5:*/		return 0x82264AD0;
	}
	return 0x82264AD0;
} // Block from 82264AB8h-82264AD0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82264AD0h
// Function '?LastUsedSlot@Range@XGRAPHICS@@QAAXAAHAAPAUAdjacencyList@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264AD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264AD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264AD0);
		  /* 82264AD0h */ case    0:  		/* cmpw CR6, R31, R11 */
		/* 82264AD0h case    0:*/		cpu::op::cmpw<6>(regs,regs.R31,regs.R11);
		/* 82264AD0h case    0:*/		return 0x82264AD4;
		  /* 82264AD4h */ case    1:  		/* bc 12, CR6_LT, -64 */
		/* 82264AD4h case    1:*/		if ( regs.CR[6].lt ) { return 0x82264A94;  }
		/* 82264AD4h case    1:*/		return 0x82264AD8;
	}
	return 0x82264AD8;
} // Block from 82264AD0h-82264AD8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82264AD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264AD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264AD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264AD8);
		  /* 82264AD8h */ case    0:  		/* addi R1, R1, 112 */
		/* 82264AD8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82264AD8h case    0:*/		return 0x82264ADC;
		  /* 82264ADCh */ case    1:  		/* b -1914928 */
		/* 82264ADCh case    1:*/		return 0x820912AC;
		/* 82264ADCh case    1:*/		return 0x82264AE0;
	}
	return 0x82264AE0;
} // Block from 82264AD8h-82264AE0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82264AE0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264AE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264AE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264AE0);
		  /* 82264AE0h */ case    0:  		/* mfspr R12, LR */
		/* 82264AE0h case    0:*/		regs.R12 = regs.LR;
		/* 82264AE0h case    0:*/		return 0x82264AE4;
		  /* 82264AE4h */ case    1:  		/* bl -1915020 */
		/* 82264AE4h case    1:*/		regs.LR = 0x82264AE8; return 0x82091258;
		/* 82264AE4h case    1:*/		return 0x82264AE8;
		  /* 82264AE8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82264AE8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82264AE8h case    2:*/		return 0x82264AEC;
		  /* 82264AECh */ case    3:  		/* mr R28, R3 */
		/* 82264AECh case    3:*/		regs.R28 = regs.R3;
		/* 82264AECh case    3:*/		return 0x82264AF0;
		  /* 82264AF0h */ case    4:  		/* mr R30, R4 */
		/* 82264AF0h case    4:*/		regs.R30 = regs.R4;
		/* 82264AF0h case    4:*/		return 0x82264AF4;
		  /* 82264AF4h */ case    5:  		/* mr R29, R5 */
		/* 82264AF4h case    5:*/		regs.R29 = regs.R5;
		/* 82264AF4h case    5:*/		return 0x82264AF8;
		  /* 82264AF8h */ case    6:  		/* cmpw CR6, R4, R5 */
		/* 82264AF8h case    6:*/		cpu::op::cmpw<6>(regs,regs.R4,regs.R5);
		/* 82264AF8h case    6:*/		return 0x82264AFC;
		  /* 82264AFCh */ case    7:  		/* bc 4, CR6_EQ, 12 */
		/* 82264AFCh case    7:*/		if ( !regs.CR[6].eq ) { return 0x82264B08;  }
		/* 82264AFCh case    7:*/		return 0x82264B00;
		  /* 82264B00h */ case    8:  		/* li R3, 1 */
		/* 82264B00h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82264B00h case    8:*/		return 0x82264B04;
		  /* 82264B04h */ case    9:  		/* b 136 */
		/* 82264B04h case    9:*/		return 0x82264B8C;
		/* 82264B04h case    9:*/		return 0x82264B08;
	}
	return 0x82264B08;
} // Block from 82264AE0h-82264B08h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82264B08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264B08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264B08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264B08);
		  /* 82264B08h */ case    0:  		/* mr R5, R30 */
		/* 82264B08h case    0:*/		regs.R5 = regs.R30;
		/* 82264B08h case    0:*/		return 0x82264B0C;
		  /* 82264B0Ch */ case    1:  		/* mr R4, R29 */
		/* 82264B0Ch case    1:*/		regs.R4 = regs.R29;
		/* 82264B0Ch case    1:*/		return 0x82264B10;
		  /* 82264B10h */ case    2:  		/* mr R3, R28 */
		/* 82264B10h case    2:*/		regs.R3 = regs.R28;
		/* 82264B10h case    2:*/		return 0x82264B14;
		  /* 82264B14h */ case    3:  		/* bl -2004 */
		/* 82264B14h case    3:*/		regs.LR = 0x82264B18; return 0x82264340;
		/* 82264B14h case    3:*/		return 0x82264B18;
		  /* 82264B18h */ case    4:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82264B18h case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82264B18h case    4:*/		return 0x82264B1C;
		  /* 82264B1Ch */ case    5:  		/* bc 4, CR0_EQ, 108 */
		/* 82264B1Ch case    5:*/		if ( !regs.CR[0].eq ) { return 0x82264B88;  }
		/* 82264B1Ch case    5:*/		return 0x82264B20;
		  /* 82264B20h */ case    6:  		/* cmpw CR6, R29, R30 */
		/* 82264B20h case    6:*/		cpu::op::cmpw<6>(regs,regs.R29,regs.R30);
		/* 82264B20h case    6:*/		return 0x82264B24;
		  /* 82264B24h */ case    7:  		/* mr R31, R29 */
		/* 82264B24h case    7:*/		regs.R31 = regs.R29;
		/* 82264B24h case    7:*/		return 0x82264B28;
		  /* 82264B28h */ case    8:  		/* bc 12, CR6_LT, 16 */
		/* 82264B28h case    8:*/		if ( regs.CR[6].lt ) { return 0x82264B38;  }
		/* 82264B28h case    8:*/		return 0x82264B2C;
		  /* 82264B2Ch */ case    9:  		/* mr R31, R30 */
		/* 82264B2Ch case    9:*/		regs.R31 = regs.R30;
		/* 82264B2Ch case    9:*/		return 0x82264B30;
		  /* 82264B30h */ case   10:  		/* bc 4, CR6_GT, 8 */
		/* 82264B30h case   10:*/		if ( !regs.CR[6].gt ) { return 0x82264B38;  }
		/* 82264B30h case   10:*/		return 0x82264B34;
		  /* 82264B34h */ case   11:  		/* mr R30, R29 */
		/* 82264B34h case   11:*/		regs.R30 = regs.R29;
		/* 82264B34h case   11:*/		return 0x82264B38;
	}
	return 0x82264B38;
} // Block from 82264B08h-82264B38h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82264B38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264B38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264B38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264B38);
		  /* 82264B38h */ case    0:  		/* lis R11, -32215 */
		/* 82264B38h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 82264B38h case    0:*/		return 0x82264B3C;
		  /* 82264B3Ch */ case    1:  		/* mr R4, R30 */
		/* 82264B3Ch case    1:*/		regs.R4 = regs.R30;
		/* 82264B3Ch case    1:*/		return 0x82264B40;
	}
	return 0x82264B40;
} // Block from 82264B38h-82264B40h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82264B40h
// Function '?Find@Interference@XGRAPHICS@@QBAHH_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264B40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264B40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264B40);
		  /* 82264B40h */ case    0:  		/* mr R3, R31 */
		/* 82264B40h case    0:*/		regs.R3 = regs.R31;
		/* 82264B40h case    0:*/		return 0x82264B44;
		  /* 82264B44h */ case    1:  		/* lwz R5, <#[R11 - 25556]> */
		/* 82264B44h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + 0xFFFF9C2C) );
		/* 82264B44h case    1:*/		return 0x82264B48;
		  /* 82264B48h */ case    2:  		/* bl 9040 */
		/* 82264B48h case    2:*/		regs.LR = 0x82264B4C; return 0x82266E98;
		/* 82264B48h case    2:*/		return 0x82264B4C;
		  /* 82264B4Ch */ case    3:  		/* lwz R3, <#[R28 + 4]> */
		/* 82264B4Ch case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000004) );
		/* 82264B4Ch case    3:*/		return 0x82264B50;
		  /* 82264B50h */ case    4:  		/* lwz R11, <#[R3 + 4]> */
		/* 82264B50h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82264B50h case    4:*/		return 0x82264B54;
		  /* 82264B54h */ case    5:  		/* cmplw CR6, R31, R11 */
		/* 82264B54h case    5:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82264B54h case    5:*/		return 0x82264B58;
		  /* 82264B58h */ case    6:  		/* bc 4, CR6_LT, 20 */
		/* 82264B58h case    6:*/		if ( !regs.CR[6].lt ) { return 0x82264B6C;  }
		/* 82264B58h case    6:*/		return 0x82264B5C;
		  /* 82264B5Ch */ case    7:  		/* lwz R11, <#[R3 + 8]> */
		/* 82264B5Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82264B5Ch case    7:*/		return 0x82264B60;
		  /* 82264B60h */ case    8:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 82264B60h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 82264B60h case    8:*/		return 0x82264B64;
		  /* 82264B64h */ case    9:  		/* add R3, R11, R10 */
		/* 82264B64h case    9:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 82264B64h case    9:*/		return 0x82264B68;
		  /* 82264B68h */ case   10:  		/* b 12 */
		/* 82264B68h case   10:*/		return 0x82264B74;
		/* 82264B68h case   10:*/		return 0x82264B6C;
	}
	return 0x82264B6C;
} // Block from 82264B40h-82264B6Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 82264B6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264B6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264B6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264B6C);
		  /* 82264B6Ch */ case    0:  		/* mr R4, R31 */
		/* 82264B6Ch case    0:*/		regs.R4 = regs.R31;
		/* 82264B6Ch case    0:*/		return 0x82264B70;
		  /* 82264B70h */ case    1:  		/* bl -69808 */
		/* 82264B70h case    1:*/		regs.LR = 0x82264B74; return 0x82253AC0;
		/* 82264B70h case    1:*/		return 0x82264B74;
	}
	return 0x82264B74;
} // Block from 82264B6Ch-82264B74h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82264B74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264B74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264B74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264B74);
		  /* 82264B74h */ case    0:  		/* mr R5, R28 */
		/* 82264B74h case    0:*/		regs.R5 = regs.R28;
		/* 82264B74h case    0:*/		return 0x82264B78;
		  /* 82264B78h */ case    1:  		/* lwz R3, <#[R3]> */
		/* 82264B78h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 82264B78h case    1:*/		return 0x82264B7C;
		  /* 82264B7Ch */ case    2:  		/* mr R4, R30 */
		/* 82264B7Ch case    2:*/		regs.R4 = regs.R30;
		/* 82264B7Ch case    2:*/		return 0x82264B80;
		  /* 82264B80h */ case    3:  		/* bl -1776 */
		/* 82264B80h case    3:*/		regs.LR = 0x82264B84; return 0x82264490;
		/* 82264B80h case    3:*/		return 0x82264B84;
		  /* 82264B84h */ case    4:  		/* b -132 */
		/* 82264B84h case    4:*/		return 0x82264B00;
		/* 82264B84h case    4:*/		return 0x82264B88;
	}
	return 0x82264B88;
} // Block from 82264B74h-82264B88h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82264B88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264B88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264B88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264B88);
		  /* 82264B88h */ case    0:  		/* li R3, 0 */
		/* 82264B88h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82264B88h case    0:*/		return 0x82264B8C;
	}
	return 0x82264B8C;
} // Block from 82264B88h-82264B8Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82264B8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264B8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264B8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264B8C);
		  /* 82264B8Ch */ case    0:  		/* addi R1, R1, 128 */
		/* 82264B8Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82264B8Ch case    0:*/		return 0x82264B90;
		  /* 82264B90h */ case    1:  		/* b -1915112 */
		/* 82264B90h case    1:*/		return 0x820912A8;
		/* 82264B90h case    1:*/		return 0x82264B94;
		  /* 82264B94h */ case    2:  		/* nop */
		/* 82264B94h case    2:*/		cpu::op::nop();
		/* 82264B94h case    2:*/		return 0x82264B98;
	}
	return 0x82264B98;
} // Block from 82264B8Ch-82264B98h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82264B98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264B98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264B98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264B98);
		  /* 82264B98h */ case    0:  		/* mfspr R12, LR */
		/* 82264B98h case    0:*/		regs.R12 = regs.LR;
		/* 82264B98h case    0:*/		return 0x82264B9C;
		  /* 82264B9Ch */ case    1:  		/* bl -1915220 */
		/* 82264B9Ch case    1:*/		regs.LR = 0x82264BA0; return 0x82091248;
		/* 82264B9Ch case    1:*/		return 0x82264BA0;
		  /* 82264BA0h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 82264BA0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82264BA0h case    2:*/		return 0x82264BA4;
		  /* 82264BA4h */ case    3:  		/* mr R28, R3 */
		/* 82264BA4h case    3:*/		regs.R28 = regs.R3;
		/* 82264BA4h case    3:*/		return 0x82264BA8;
		  /* 82264BA8h */ case    4:  		/* lwz R3, <#[R3 + 4]> */
		/* 82264BA8h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000004) );
		/* 82264BA8h case    4:*/		return 0x82264BAC;
		  /* 82264BACh */ case    5:  		/* mr R25, R5 */
		/* 82264BACh case    5:*/		regs.R25 = regs.R5;
		/* 82264BACh case    5:*/		return 0x82264BB0;
		  /* 82264BB0h */ case    6:  		/* mr R24, R6 */
		/* 82264BB0h case    6:*/		regs.R24 = regs.R6;
		/* 82264BB0h case    6:*/		return 0x82264BB4;
		  /* 82264BB4h */ case    7:  		/* lwz R11, <#[R3 + 4]> */
		/* 82264BB4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82264BB4h case    7:*/		return 0x82264BB8;
		  /* 82264BB8h */ case    8:  		/* cmplw CR6, R4, R11 */
		/* 82264BB8h case    8:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 82264BB8h case    8:*/		return 0x82264BBC;
		  /* 82264BBCh */ case    9:  		/* bc 4, CR6_LT, 20 */
		/* 82264BBCh case    9:*/		if ( !regs.CR[6].lt ) { return 0x82264BD0;  }
		/* 82264BBCh case    9:*/		return 0x82264BC0;
		  /* 82264BC0h */ case   10:  		/* lwz R10, <#[R3 + 8]> */
		/* 82264BC0h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 82264BC0h case   10:*/		return 0x82264BC4;
		  /* 82264BC4h */ case   11:  		/* rlwinm R11, R4, 2, 0, 29 */
		/* 82264BC4h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R4);
		/* 82264BC4h case   11:*/		return 0x82264BC8;
	}
	return 0x82264BC8;
} // Block from 82264B98h-82264BC8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82264BC8h
// Function '?Index@Interference@XGRAPHICS@@ABAHHH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264BC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264BC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264BC8);
		  /* 82264BC8h */ case    0:  		/* add R3, R10, R11 */
		/* 82264BC8h case    0:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 82264BC8h case    0:*/		return 0x82264BCC;
		  /* 82264BCCh */ case    1:  		/* b 8 */
		/* 82264BCCh case    1:*/		return 0x82264BD4;
		/* 82264BCCh case    1:*/		return 0x82264BD0;
	}
	return 0x82264BD0;
} // Block from 82264BC8h-82264BD0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82264BD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264BD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264BD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264BD0);
		  /* 82264BD0h */ case    0:  		/* bl -69904 */
		/* 82264BD0h case    0:*/		regs.LR = 0x82264BD4; return 0x82253AC0;
		/* 82264BD0h case    0:*/		return 0x82264BD4;
	}
	return 0x82264BD4;
} // Block from 82264BD0h-82264BD4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82264BD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264BD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264BD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264BD4);
		  /* 82264BD4h */ case    0:  		/* lwz R27, <#[R3]> */
		/* 82264BD4h case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R3 + 0x00000000) );
		/* 82264BD4h case    0:*/		return 0x82264BD8;
		  /* 82264BD8h */ case    1:  		/* li R30, -1 */
		/* 82264BD8h case    1:*/		cpu::op::li<0>(regs,&regs.R30,0xFFFFFFFF);
		/* 82264BD8h case    1:*/		return 0x82264BDC;
		  /* 82264BDCh */ case    2:  		/* li R26, 0 */
		/* 82264BDCh case    2:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82264BDCh case    2:*/		return 0x82264BE0;
		  /* 82264BE0h */ case    3:  		/* lwz R11, <#[R27 + 4]> */
		/* 82264BE0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 82264BE0h case    3:*/		return 0x82264BE4;
		  /* 82264BE4h */ case    4:  		/* lwz R29, <#[R27 + 8]> */
		/* 82264BE4h case    4:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R27 + 0x00000008) );
		/* 82264BE4h case    4:*/		return 0x82264BE8;
		  /* 82264BE8h */ case    5:  		/* cmpwi CR6, R11, 0 */
		/* 82264BE8h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82264BE8h case    5:*/		return 0x82264BEC;
		  /* 82264BECh */ case    6:  		/* bc 4, CR6_GT, 236 */
		/* 82264BECh case    6:*/		if ( !regs.CR[6].gt ) { return 0x82264CD8;  }
		/* 82264BECh case    6:*/		return 0x82264BF0;
		  /* 82264BF0h */ case    7:  		/* addi R30, R30, 1 */
		/* 82264BF0h case    7:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82264BF0h case    7:*/		return 0x82264BF4;
		  /* 82264BF4h */ case    8:  		/* cmpwi CR6, R30, 7 */
		/* 82264BF4h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000007);
		/* 82264BF4h case    8:*/		return 0x82264BF8;
		  /* 82264BF8h */ case    9:  		/* bc 4, CR6_EQ, 12 */
		/* 82264BF8h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82264C04;  }
		/* 82264BF8h case    9:*/		return 0x82264BFC;
		  /* 82264BFCh */ case   10:  		/* lwz R29, <#[R29 + 28]> */
		/* 82264BFCh case   10:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R29 + 0x0000001C) );
		/* 82264BFCh case   10:*/		return 0x82264C00;
		  /* 82264C00h */ case   11:  		/* li R30, 0 */
		/* 82264C00h case   11:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82264C00h case   11:*/		return 0x82264C04;
	}
	return 0x82264C04;
} // Block from 82264BD4h-82264C04h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82264C04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264C04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264C04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264C04);
		  /* 82264C04h */ case    0:  		/* rlwinm R11, R30, 2, 0, 29 */
		/* 82264C04h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R30);
		/* 82264C04h case    0:*/		return 0x82264C08;
		  /* 82264C08h */ case    1:  		/* lwz R3, <#[R28 + 4]> */
		/* 82264C08h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000004) );
		/* 82264C08h case    1:*/		return 0x82264C0C;
		  /* 82264C0Ch */ case    2:  		/* lwzx R31, <#[R11 + R29]> */
		/* 82264C0Ch case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 82264C0Ch case    2:*/		return 0x82264C10;
		  /* 82264C10h */ case    3:  		/* lwz R11, <#[R3 + 4]> */
		/* 82264C10h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82264C10h case    3:*/		return 0x82264C14;
		  /* 82264C14h */ case    4:  		/* cmplw CR6, R31, R11 */
		/* 82264C14h case    4:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82264C14h case    4:*/		return 0x82264C18;
		  /* 82264C18h */ case    5:  		/* bc 4, CR6_LT, 20 */
		/* 82264C18h case    5:*/		if ( !regs.CR[6].lt ) { return 0x82264C2C;  }
		/* 82264C18h case    5:*/		return 0x82264C1C;
		  /* 82264C1Ch */ case    6:  		/* lwz R11, <#[R3 + 8]> */
		/* 82264C1Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82264C1Ch case    6:*/		return 0x82264C20;
		  /* 82264C20h */ case    7:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 82264C20h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 82264C20h case    7:*/		return 0x82264C24;
		  /* 82264C24h */ case    8:  		/* add R3, R11, R10 */
		/* 82264C24h case    8:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 82264C24h case    8:*/		return 0x82264C28;
		  /* 82264C28h */ case    9:  		/* b 12 */
		/* 82264C28h case    9:*/		return 0x82264C34;
		/* 82264C28h case    9:*/		return 0x82264C2C;
	}
	return 0x82264C2C;
} // Block from 82264C04h-82264C2Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 82264C2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264C2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264C2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264C2C);
		  /* 82264C2Ch */ case    0:  		/* mr R4, R31 */
		/* 82264C2Ch case    0:*/		regs.R4 = regs.R31;
		/* 82264C2Ch case    0:*/		return 0x82264C30;
		  /* 82264C30h */ case    1:  		/* bl -70000 */
		/* 82264C30h case    1:*/		regs.LR = 0x82264C34; return 0x82253AC0;
		/* 82264C30h case    1:*/		return 0x82264C34;
	}
	return 0x82264C34;
} // Block from 82264C2Ch-82264C34h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82264C34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264C34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264C34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264C34);
		  /* 82264C34h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82264C34h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82264C34h case    0:*/		return 0x82264C38;
		  /* 82264C38h */ case    1:  		/* lwz R11, <#[R11 + 12]> */
		/* 82264C38h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 82264C38h case    1:*/		return 0x82264C3C;
		  /* 82264C3Ch */ case    2:  		/* cmpwi CR6, R11, 0 */
		/* 82264C3Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82264C3Ch case    2:*/		return 0x82264C40;
		  /* 82264C40h */ case    3:  		/* bc 4, CR6_GT, 136 */
		/* 82264C40h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82264CC8;  }
		/* 82264C40h case    3:*/		return 0x82264C44;
		  /* 82264C44h */ case    4:  		/* lwz R3, <#[R28 + 4]> */
		/* 82264C44h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000004) );
		/* 82264C44h case    4:*/		return 0x82264C48;
		  /* 82264C48h */ case    5:  		/* lwz R11, <#[R3 + 4]> */
		/* 82264C48h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82264C48h case    5:*/		return 0x82264C4C;
		  /* 82264C4Ch */ case    6:  		/* cmplw CR6, R31, R11 */
		/* 82264C4Ch case    6:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82264C4Ch case    6:*/		return 0x82264C50;
		  /* 82264C50h */ case    7:  		/* bc 4, CR6_LT, 20 */
		/* 82264C50h case    7:*/		if ( !regs.CR[6].lt ) { return 0x82264C64;  }
		/* 82264C50h case    7:*/		return 0x82264C54;
		  /* 82264C54h */ case    8:  		/* lwz R11, <#[R3 + 8]> */
		/* 82264C54h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82264C54h case    8:*/		return 0x82264C58;
		  /* 82264C58h */ case    9:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 82264C58h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 82264C58h case    9:*/		return 0x82264C5C;
		  /* 82264C5Ch */ case   10:  		/* add R3, R11, R10 */
		/* 82264C5Ch case   10:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 82264C5Ch case   10:*/		return 0x82264C60;
	}
	return 0x82264C60;
} // Block from 82264C34h-82264C60h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82264C60h
// Function '?AdvanceSlot@Range@XGRAPHICS@@AAAXAAHAAPAUAdjacencyList@2@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264C60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264C60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264C60);
		  /* 82264C60h */ case    0:  		/* b 12 */
		/* 82264C60h case    0:*/		return 0x82264C6C;
		/* 82264C60h case    0:*/		return 0x82264C64;
	}
	return 0x82264C64;
} // Block from 82264C60h-82264C64h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82264C64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264C64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264C64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264C64);
		  /* 82264C64h */ case    0:  		/* mr R4, R31 */
		/* 82264C64h case    0:*/		regs.R4 = regs.R31;
		/* 82264C64h case    0:*/		return 0x82264C68;
		  /* 82264C68h */ case    1:  		/* bl -70056 */
		/* 82264C68h case    1:*/		regs.LR = 0x82264C6C; return 0x82253AC0;
		/* 82264C68h case    1:*/		return 0x82264C6C;
	}
	return 0x82264C6C;
} // Block from 82264C64h-82264C6Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82264C6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264C6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264C6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264C6C);
		  /* 82264C6Ch */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82264C6Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82264C6Ch case    0:*/		return 0x82264C70;
		  /* 82264C70h */ case    1:  		/* lwz R10, <#[R11 + 12]> */
		/* 82264C70h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 82264C70h case    1:*/		return 0x82264C74;
		  /* 82264C74h */ case    2:  		/* addi R10, R10, -1 */
		/* 82264C74h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 82264C74h case    2:*/		return 0x82264C78;
		  /* 82264C78h */ case    3:  		/* stw R10, <#[R11 + 12]> */
		/* 82264C78h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 82264C78h case    3:*/		return 0x82264C7C;
		  /* 82264C7Ch */ case    4:  		/* lwz R3, <#[R28 + 4]> */
		/* 82264C7Ch case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000004) );
		/* 82264C7Ch case    4:*/		return 0x82264C80;
		  /* 82264C80h */ case    5:  		/* lwz R11, <#[R3 + 4]> */
		/* 82264C80h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82264C80h case    5:*/		return 0x82264C84;
		  /* 82264C84h */ case    6:  		/* cmplw CR6, R31, R11 */
		/* 82264C84h case    6:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82264C84h case    6:*/		return 0x82264C88;
		  /* 82264C88h */ case    7:  		/* bc 4, CR6_LT, 20 */
		/* 82264C88h case    7:*/		if ( !regs.CR[6].lt ) { return 0x82264C9C;  }
		/* 82264C88h case    7:*/		return 0x82264C8C;
		  /* 82264C8Ch */ case    8:  		/* lwz R11, <#[R3 + 8]> */
		/* 82264C8Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82264C8Ch case    8:*/		return 0x82264C90;
		  /* 82264C90h */ case    9:  		/* rlwinm R10, R31, 2, 0, 29 */
		/* 82264C90h case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R31);
		/* 82264C90h case    9:*/		return 0x82264C94;
		  /* 82264C94h */ case   10:  		/* add R3, R11, R10 */
		/* 82264C94h case   10:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 82264C94h case   10:*/		return 0x82264C98;
		  /* 82264C98h */ case   11:  		/* b 12 */
		/* 82264C98h case   11:*/		return 0x82264CA4;
		/* 82264C98h case   11:*/		return 0x82264C9C;
	}
	return 0x82264C9C;
} // Block from 82264C6Ch-82264C9Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 82264C9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264C9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264C9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264C9C);
		  /* 82264C9Ch */ case    0:  		/* mr R4, R31 */
		/* 82264C9Ch case    0:*/		regs.R4 = regs.R31;
		/* 82264C9Ch case    0:*/		return 0x82264CA0;
		  /* 82264CA0h */ case    1:  		/* bl -70112 */
		/* 82264CA0h case    1:*/		regs.LR = 0x82264CA4; return 0x82253AC0;
		/* 82264CA0h case    1:*/		return 0x82264CA4;
	}
	return 0x82264CA4;
} // Block from 82264C9Ch-82264CA4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82264CA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264CA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264CA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264CA4);
		  /* 82264CA4h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82264CA4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82264CA4h case    0:*/		return 0x82264CA8;
		  /* 82264CA8h */ case    1:  		/* addi R10, R24, -1 */
		/* 82264CA8h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R24,0xFFFFFFFF);
		/* 82264CA8h case    1:*/		return 0x82264CAC;
		  /* 82264CACh */ case    2:  		/* lwz R11, <#[R11 + 12]> */
		/* 82264CACh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 82264CACh case    2:*/		return 0x82264CB0;
		  /* 82264CB0h */ case    3:  		/* cmpw CR6, R11, R10 */
		/* 82264CB0h case    3:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 82264CB0h case    3:*/		return 0x82264CB4;
		  /* 82264CB4h */ case    4:  		/* bc 4, CR6_EQ, 20 */
		/* 82264CB4h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82264CC8;  }
		/* 82264CB4h case    4:*/		return 0x82264CB8;
		  /* 82264CB8h */ case    5:  		/* mr R3, R25 */
		/* 82264CB8h case    5:*/		regs.R3 = regs.R25;
		/* 82264CB8h case    5:*/		return 0x82264CBC;
		  /* 82264CBCh */ case    6:  		/* lwz R4, <#[R25 + 4]> */
		/* 82264CBCh case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R25 + 0x00000004) );
		/* 82264CBCh case    6:*/		return 0x82264CC0;
		  /* 82264CC0h */ case    7:  		/* bl -70144 */
		/* 82264CC0h case    7:*/		regs.LR = 0x82264CC4; return 0x82253AC0;
		/* 82264CC0h case    7:*/		return 0x82264CC4;
		  /* 82264CC4h */ case    8:  		/* stw R31, <#[R3]> */
		/* 82264CC4h case    8:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 82264CC4h case    8:*/		return 0x82264CC8;
	}
	return 0x82264CC8;
} // Block from 82264CA4h-82264CC8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82264CC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264CC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264CC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264CC8);
		  /* 82264CC8h */ case    0:  		/* lwz R11, <#[R27 + 4]> */
		/* 82264CC8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 82264CC8h case    0:*/		return 0x82264CCC;
		  /* 82264CCCh */ case    1:  		/* addi R26, R26, 1 */
		/* 82264CCCh case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 82264CCCh case    1:*/		return 0x82264CD0;
		  /* 82264CD0h */ case    2:  		/* cmpw CR6, R26, R11 */
		/* 82264CD0h case    2:*/		cpu::op::cmpw<6>(regs,regs.R26,regs.R11);
		/* 82264CD0h case    2:*/		return 0x82264CD4;
		  /* 82264CD4h */ case    3:  		/* bc 12, CR6_LT, -228 */
		/* 82264CD4h case    3:*/		if ( regs.CR[6].lt ) { return 0x82264BF0;  }
		/* 82264CD4h case    3:*/		return 0x82264CD8;
	}
	return 0x82264CD8;
} // Block from 82264CC8h-82264CD8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82264CD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264CD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264CD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264CD8);
		  /* 82264CD8h */ case    0:  		/* addi R1, R1, 160 */
		/* 82264CD8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 82264CD8h case    0:*/		return 0x82264CDC;
		  /* 82264CDCh */ case    1:  		/* b -1915460 */
		/* 82264CDCh case    1:*/		return 0x82091298;
		/* 82264CDCh case    1:*/		return 0x82264CE0;
	}
	return 0x82264CE0;
} // Block from 82264CD8h-82264CE0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82264CE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264CE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264CE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264CE0);
		  /* 82264CE0h */ case    0:  		/* mfspr R12, LR */
		/* 82264CE0h case    0:*/		regs.R12 = regs.LR;
		/* 82264CE0h case    0:*/		return 0x82264CE4;
		  /* 82264CE4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82264CE4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82264CE4h case    1:*/		return 0x82264CE8;
		  /* 82264CE8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82264CE8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82264CE8h case    2:*/		return 0x82264CEC;
		  /* 82264CECh */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82264CECh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82264CECh case    3:*/		return 0x82264CF0;
		  /* 82264CF0h */ case    4:  		/* mr R31, R3 */
		/* 82264CF0h case    4:*/		regs.R31 = regs.R3;
		/* 82264CF0h case    4:*/		return 0x82264CF4;
		  /* 82264CF4h */ case    5:  		/* b 36 */
		/* 82264CF4h case    5:*/		return 0x82264D18;
		/* 82264CF4h case    5:*/		return 0x82264CF8;
		  /* 82264CF8h */ case    6:  		/* lwz R11, <#[R31 + 8]> */
		/* 82264CF8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82264CF8h case    6:*/		return 0x82264CFC;
		  /* 82264CFCh */ case    7:  		/* cmplwi CR0, R11, 0 */
		/* 82264CFCh case    7:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82264CFCh case    7:*/		return 0x82264D00;
		  /* 82264D00h */ case    8:  		/* lwz R10, <#[R11 + 28]> */
		/* 82264D00h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000001C) );
		/* 82264D00h case    8:*/		return 0x82264D04;
		  /* 82264D04h */ case    9:  		/* stw R10, <#[R31 + 8]> */
		/* 82264D04h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82264D04h case    9:*/		return 0x82264D08;
		  /* 82264D08h */ case   10:  		/* bc 12, CR0_EQ, 16 */
		/* 82264D08h case   10:*/		if ( regs.CR[0].eq ) { return 0x82264D18;  }
		/* 82264D08h case   10:*/		return 0x82264D0C;
		  /* 82264D0Ch */ case   11:  		/* addi R4, R11, -4 */
		/* 82264D0Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFC);
		/* 82264D0Ch case   11:*/		return 0x82264D10;
		  /* 82264D10h */ case   12:  		/* lwz R3, <#[R11 - 4]> */
		/* 82264D10h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 82264D10h case   12:*/		return 0x82264D14;
		  /* 82264D14h */ case   13:  		/* bl -296660 */
		/* 82264D14h case   13:*/		regs.LR = 0x82264D18; return 0x8221C640;
		/* 82264D14h case   13:*/		return 0x82264D18;
	}
	return 0x82264D18;
} // Block from 82264CE0h-82264D18h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82264D18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264D18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264D18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264D18);
		  /* 82264D18h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 82264D18h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82264D18h case    0:*/		return 0x82264D1C;
		  /* 82264D1Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82264D1Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82264D1Ch case    1:*/		return 0x82264D20;
	}
	return 0x82264D20;
} // Block from 82264D18h-82264D20h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82264D20h
// Function '?ClearMatrix@Interference@XGRAPHICS@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264D20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264D20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264D20);
		  /* 82264D20h */ case    0:  		/* bc 4, CR6_EQ, -40 */
		/* 82264D20h case    0:*/		if ( !regs.CR[6].eq ) { return 0x82264CF8;  }
		/* 82264D20h case    0:*/		return 0x82264D24;
		  /* 82264D24h */ case    1:  		/* lwz R3, <#[R31 + 16]> */
		/* 82264D24h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 82264D24h case    1:*/		return 0x82264D28;
		  /* 82264D28h */ case    2:  		/* cmplwi CR6, R3, 0 */
		/* 82264D28h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82264D28h case    2:*/		return 0x82264D2C;
		  /* 82264D2Ch */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 82264D2Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x82264D38;  }
		/* 82264D2Ch case    3:*/		return 0x82264D30;
		  /* 82264D30h */ case    4:  		/* li R4, 1 */
		/* 82264D30h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82264D30h case    4:*/		return 0x82264D34;
		  /* 82264D34h */ case    5:  		/* bl -151964 */
		/* 82264D34h case    5:*/		regs.LR = 0x82264D38; return 0x8223FB98;
		/* 82264D34h case    5:*/		return 0x82264D38;
	}
	return 0x82264D38;
} // Block from 82264D20h-82264D38h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82264D38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264D38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264D38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264D38);
		  /* 82264D38h */ case    0:  		/* addi R1, R1, 96 */
		/* 82264D38h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82264D38h case    0:*/		return 0x82264D3C;
		  /* 82264D3Ch */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82264D3Ch case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82264D3Ch case    1:*/		return 0x82264D40;
		  /* 82264D40h */ case    2:  		/* mtspr LR, R12 */
		/* 82264D40h case    2:*/		regs.LR = regs.R12;
		/* 82264D40h case    2:*/		return 0x82264D44;
		  /* 82264D44h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 82264D44h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82264D44h case    3:*/		return 0x82264D48;
		  /* 82264D48h */ case    4:  		/* bclr 20, CR0_LT */
		/* 82264D48h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82264D48h case    4:*/		return 0x82264D4C;
	}
	return 0x82264D4C;
} // Block from 82264D38h-82264D4Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82264D4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264D4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264D4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264D4C);
		  /* 82264D4Ch */ case    0:  		/* nop */
		/* 82264D4Ch case    0:*/		cpu::op::nop();
		/* 82264D4Ch case    0:*/		return 0x82264D50;
	}
	return 0x82264D50;
} // Block from 82264D4Ch-82264D50h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82264D50h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264D50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264D50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264D50);
		  /* 82264D50h */ case    0:  		/* mfspr R12, LR */
		/* 82264D50h case    0:*/		regs.R12 = regs.LR;
		/* 82264D50h case    0:*/		return 0x82264D54;
		  /* 82264D54h */ case    1:  		/* bl -1915696 */
		/* 82264D54h case    1:*/		regs.LR = 0x82264D58; return 0x82091224;
		/* 82264D54h case    1:*/		return 0x82264D58;
	}
	return 0x82264D58;
} // Block from 82264D50h-82264D58h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82264D58h
// Function '?Interfere@Interference@XGRAPHICS@@QBA_NHH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264D58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264D58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264D58);
		  /* 82264D58h */ case    0:  		/* stwu R1, <#[R1 - 240]> */
		/* 82264D58h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF10) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF10);
		/* 82264D58h case    0:*/		return 0x82264D5C;
		  /* 82264D5Ch */ case    1:  		/* lwz R11, <#[R3 + 12]> */
		/* 82264D5Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 82264D5Ch case    1:*/		return 0x82264D60;
		  /* 82264D60h */ case    2:  		/* mr R25, R3 */
		/* 82264D60h case    2:*/		regs.R25 = regs.R3;
		/* 82264D60h case    2:*/		return 0x82264D64;
		  /* 82264D64h */ case    3:  		/* li R15, 1 */
		/* 82264D64h case    3:*/		cpu::op::li<0>(regs,&regs.R15,0x1);
		/* 82264D64h case    3:*/		return 0x82264D68;
		  /* 82264D68h */ case    4:  		/* cmpwi CR6, R11, 0 */
		/* 82264D68h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82264D68h case    4:*/		return 0x82264D6C;
		  /* 82264D6Ch */ case    5:  		/* mr R26, R11 */
		/* 82264D6Ch case    5:*/		regs.R26 = regs.R11;
		/* 82264D6Ch case    5:*/		return 0x82264D70;
		  /* 82264D70h */ case    6:  		/* bc 12, CR6_GT, 8 */
		/* 82264D70h case    6:*/		if ( regs.CR[6].gt ) { return 0x82264D78;  }
		/* 82264D70h case    6:*/		return 0x82264D74;
		  /* 82264D74h */ case    7:  		/* mr R26, R15 */
		/* 82264D74h case    7:*/		regs.R26 = regs.R15;
		/* 82264D74h case    7:*/		return 0x82264D78;
	}
	return 0x82264D78;
} // Block from 82264D58h-82264D78h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82264D78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264D78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264D78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264D78);
		  /* 82264D78h */ case    0:  		/* lwz R11, <#[R25 + 8]> */
		/* 82264D78h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 82264D78h case    0:*/		return 0x82264D7C;
		  /* 82264D7Ch */ case    1:  		/* li R4, 20 */
		/* 82264D7Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 82264D7Ch case    1:*/		return 0x82264D80;
		  /* 82264D80h */ case    2:  		/* lwz R30, <#[R11 + 1456]> */
		/* 82264D80h case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x000005B0) );
		/* 82264D80h case    2:*/		return 0x82264D84;
		  /* 82264D84h */ case    3:  		/* mr R3, R30 */
		/* 82264D84h case    3:*/		regs.R3 = regs.R30;
		/* 82264D84h case    3:*/		return 0x82264D88;
		  /* 82264D88h */ case    4:  		/* bl -297168 */
		/* 82264D88h case    4:*/		regs.LR = 0x82264D8C; return 0x8221C4B8;
		/* 82264D88h case    4:*/		return 0x82264D8C;
		  /* 82264D8Ch */ case    5:  		/* li R18, 0 */
		/* 82264D8Ch case    5:*/		cpu::op::li<0>(regs,&regs.R18,0x0);
		/* 82264D8Ch case    5:*/		return 0x82264D90;
		  /* 82264D90h */ case    6:  		/* addic. R31, R3, 4 */
		/* 82264D90h case    6:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R3,0x4);
		/* 82264D90h case    6:*/		return 0x82264D94;
		  /* 82264D94h */ case    7:  		/* stw R30, <#[R3]> */
		/* 82264D94h case    7:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 82264D94h case    7:*/		return 0x82264D98;
		  /* 82264D98h */ case    8:  		/* bc 12, CR0_EQ, 28 */
		/* 82264D98h case    8:*/		if ( regs.CR[0].eq ) { return 0x82264DB4;  }
		/* 82264D98h case    8:*/		return 0x82264D9C;
		  /* 82264D9Ch */ case    9:  		/* lwz R11, <#[R25 + 8]> */
		/* 82264D9Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 82264D9Ch case    9:*/		return 0x82264DA0;
		  /* 82264DA0h */ case   10:  		/* mr R3, R31 */
		/* 82264DA0h case   10:*/		regs.R3 = regs.R31;
		/* 82264DA0h case   10:*/		return 0x82264DA4;
		  /* 82264DA4h */ case   11:  		/* lwz R4, <#[R11 + 1456]> */
		/* 82264DA4h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 82264DA4h case   11:*/		return 0x82264DA8;
	}
	return 0x82264DA8;
} // Block from 82264D78h-82264DA8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82264DA8h
// Function '?AddAdjMatrix@Interference@XGRAPHICS@@QAAXHH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264DA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264DA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264DA8);
		  /* 82264DA8h */ case    0:  		/* bl -192584 */
		/* 82264DA8h case    0:*/		regs.LR = 0x82264DAC; return 0x82235D60;
		/* 82264DA8h case    0:*/		return 0x82264DAC;
		  /* 82264DACh */ case    1:  		/* mr R27, R31 */
		/* 82264DACh case    1:*/		regs.R27 = regs.R31;
		/* 82264DACh case    1:*/		return 0x82264DB0;
		  /* 82264DB0h */ case    2:  		/* b 8 */
		/* 82264DB0h case    2:*/		return 0x82264DB8;
		/* 82264DB0h case    2:*/		return 0x82264DB4;
	}
	return 0x82264DB4;
} // Block from 82264DA8h-82264DB4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82264DB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264DB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264DB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264DB4);
		  /* 82264DB4h */ case    0:  		/* mr R27, R18 */
		/* 82264DB4h case    0:*/		regs.R27 = regs.R18;
		/* 82264DB4h case    0:*/		return 0x82264DB8;
	}
	return 0x82264DB8;
} // Block from 82264DB4h-82264DB8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82264DB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264DB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264DB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264DB8);
		  /* 82264DB8h */ case    0:  		/* lwz R11, <#[R25 + 8]> */
		/* 82264DB8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 82264DB8h case    0:*/		return 0x82264DBC;
		  /* 82264DBCh */ case    1:  		/* li R4, 20 */
		/* 82264DBCh case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 82264DBCh case    1:*/		return 0x82264DC0;
		  /* 82264DC0h */ case    2:  		/* lwz R30, <#[R11 + 1456]> */
		/* 82264DC0h case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x000005B0) );
		/* 82264DC0h case    2:*/		return 0x82264DC4;
		  /* 82264DC4h */ case    3:  		/* mr R3, R30 */
		/* 82264DC4h case    3:*/		regs.R3 = regs.R30;
		/* 82264DC4h case    3:*/		return 0x82264DC8;
		  /* 82264DC8h */ case    4:  		/* bl -297232 */
		/* 82264DC8h case    4:*/		regs.LR = 0x82264DCC; return 0x8221C4B8;
		/* 82264DC8h case    4:*/		return 0x82264DCC;
		  /* 82264DCCh */ case    5:  		/* addic. R31, R3, 4 */
		/* 82264DCCh case    5:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R3,0x4);
		/* 82264DCCh case    5:*/		return 0x82264DD0;
		  /* 82264DD0h */ case    6:  		/* stw R30, <#[R3]> */
		/* 82264DD0h case    6:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 82264DD0h case    6:*/		return 0x82264DD4;
		  /* 82264DD4h */ case    7:  		/* bc 12, CR0_EQ, 28 */
		/* 82264DD4h case    7:*/		if ( regs.CR[0].eq ) { return 0x82264DF0;  }
		/* 82264DD4h case    7:*/		return 0x82264DD8;
		  /* 82264DD8h */ case    8:  		/* lwz R11, <#[R25 + 8]> */
		/* 82264DD8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 82264DD8h case    8:*/		return 0x82264DDC;
		  /* 82264DDCh */ case    9:  		/* mr R3, R31 */
		/* 82264DDCh case    9:*/		regs.R3 = regs.R31;
		/* 82264DDCh case    9:*/		return 0x82264DE0;
		  /* 82264DE0h */ case   10:  		/* lwz R4, <#[R11 + 1456]> */
		/* 82264DE0h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 82264DE0h case   10:*/		return 0x82264DE4;
		  /* 82264DE4h */ case   11:  		/* bl -192644 */
		/* 82264DE4h case   11:*/		regs.LR = 0x82264DE8; return 0x82235D60;
		/* 82264DE4h case   11:*/		return 0x82264DE8;
		  /* 82264DE8h */ case   12:  		/* mr R19, R31 */
		/* 82264DE8h case   12:*/		regs.R19 = regs.R31;
		/* 82264DE8h case   12:*/		return 0x82264DEC;
		  /* 82264DECh */ case   13:  		/* b 8 */
		/* 82264DECh case   13:*/		return 0x82264DF4;
		/* 82264DECh case   13:*/		return 0x82264DF0;
	}
	return 0x82264DF0;
} // Block from 82264DB8h-82264DF0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82264DF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264DF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264DF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264DF0);
		  /* 82264DF0h */ case    0:  		/* mr R19, R18 */
		/* 82264DF0h case    0:*/		regs.R19 = regs.R18;
		/* 82264DF0h case    0:*/		return 0x82264DF4;
	}
	return 0x82264DF4;
} // Block from 82264DF0h-82264DF4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82264DF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264DF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264DF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264DF4);
		  /* 82264DF4h */ case    0:  		/* lwz R11, <#[R25 + 8]> */
		/* 82264DF4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 82264DF4h case    0:*/		return 0x82264DF8;
		  /* 82264DF8h */ case    1:  		/* mr R28, R18 */
		/* 82264DF8h case    1:*/		regs.R28 = regs.R18;
		/* 82264DF8h case    1:*/		return 0x82264DFC;
		  /* 82264DFCh */ case    2:  		/* lwz R10, <#[R25 + 16]> */
		/* 82264DFCh case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x00000010) );
		/* 82264DFCh case    2:*/		return 0x82264E00;
	}
	return 0x82264E00;
} // Block from 82264DF4h-82264E00h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82264E00h
// Function '?Number@CFG@XGRAPHICS@@QBAHPAVIRInst@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264E00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264E00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264E00);
		  /* 82264E00h */ case    0:  		/* rlwinm R4, R10, 2, 0, 29 */
		/* 82264E00h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R4,regs.R10);
		/* 82264E00h case    0:*/		return 0x82264E04;
		  /* 82264E04h */ case    1:  		/* lwz R3, <#[R11 + 1452]> */
		/* 82264E04h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x000005AC) );
		/* 82264E04h case    1:*/		return 0x82264E08;
		  /* 82264E08h */ case    2:  		/* bl -297296 */
		/* 82264E08h case    2:*/		regs.LR = 0x82264E0C; return 0x8221C4B8;
		/* 82264E08h case    2:*/		return 0x82264E0C;
		  /* 82264E0Ch */ case    3:  		/* lis R17, -32215 */
		/* 82264E0Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R17,0xFFFF8229);
		/* 82264E0Ch case    3:*/		return 0x82264E10;
		  /* 82264E10h */ case    4:  		/* mr R10, R18 */
		/* 82264E10h case    4:*/		regs.R10 = regs.R18;
		/* 82264E10h case    4:*/		return 0x82264E14;
		  /* 82264E14h */ case    5:  		/* stw R3, <#[R17 - 25560]> */
		/* 82264E14h case    5:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R17 + 0xFFFF9C28) );
		/* 82264E14h case    5:*/		return 0x82264E18;
		  /* 82264E18h */ case    6:  		/* lwz R11, <#[R25 + 16]> */
		/* 82264E18h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000010) );
		/* 82264E18h case    6:*/		return 0x82264E1C;
		  /* 82264E1Ch */ case    7:  		/* cmpwi CR6, R11, 0 */
		/* 82264E1Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82264E1Ch case    7:*/		return 0x82264E20;
		  /* 82264E20h */ case    8:  		/* bc 4, CR6_GT, 60 */
		/* 82264E20h case    8:*/		if ( !regs.CR[6].gt ) { return 0x82264E5C;  }
		/* 82264E20h case    8:*/		return 0x82264E24;
		  /* 82264E24h */ case    9:  		/* mr R9, R18 */
		/* 82264E24h case    9:*/		regs.R9 = regs.R18;
		/* 82264E24h case    9:*/		return 0x82264E28;
	}
	return 0x82264E28;
} // Block from 82264E00h-82264E28h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82264E28h
// Function '??0Range@XGRAPHICS@@QAA@HHPAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264E28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264E28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264E28);
		  /* 82264E28h */ case    0:  		/* b 8 */
		/* 82264E28h case    0:*/		return 0x82264E30;
		/* 82264E28h case    0:*/		return 0x82264E2C;
		  /* 82264E2Ch */ case    1:  		/* lwz R3, <#[R17 - 25560]> */
		/* 82264E2Ch case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R17 + 0xFFFF9C28) );
		/* 82264E2Ch case    1:*/		return 0x82264E30;
	}
	return 0x82264E30;
} // Block from 82264E28h-82264E30h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82264E30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264E30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264E30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264E30);
		  /* 82264E30h */ case    0:  		/* lwz R11, <#[R25 + 12]> */
		/* 82264E30h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x0000000C) );
		/* 82264E30h case    0:*/		return 0x82264E34;
		  /* 82264E34h */ case    1:  		/* cmpw CR6, R10, R11 */
		/* 82264E34h case    1:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R11);
		/* 82264E34h case    1:*/		return 0x82264E38;
		  /* 82264E38h */ case    2:  		/* mr R11, R10 */
		/* 82264E38h case    2:*/		regs.R11 = regs.R10;
		/* 82264E38h case    2:*/		return 0x82264E3C;
		  /* 82264E3Ch */ case    3:  		/* bc 12, CR6_LT, 8 */
		/* 82264E3Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x82264E44;  }
		/* 82264E3Ch case    3:*/		return 0x82264E40;
		  /* 82264E40h */ case    4:  		/* li R11, -1 */
		/* 82264E40h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 82264E40h case    4:*/		return 0x82264E44;
	}
	return 0x82264E44;
} // Block from 82264E30h-82264E44h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82264E44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264E44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264E44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264E44);
		  /* 82264E44h */ case    0:  		/* addi R10, R10, 1 */
		/* 82264E44h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82264E44h case    0:*/		return 0x82264E48;
		  /* 82264E48h */ case    1:  		/* stwx R11, <#[R9 + R3]> */
		/* 82264E48h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + regs.R3 + 0x00000000) );
		/* 82264E48h case    1:*/		return 0x82264E4C;
		  /* 82264E4Ch */ case    2:  		/* lwz R11, <#[R25 + 16]> */
		/* 82264E4Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000010) );
		/* 82264E4Ch case    2:*/		return 0x82264E50;
		  /* 82264E50h */ case    3:  		/* addi R9, R9, 4 */
		/* 82264E50h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 82264E50h case    3:*/		return 0x82264E54;
		  /* 82264E54h */ case    4:  		/* cmpw CR6, R10, R11 */
		/* 82264E54h case    4:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R11);
		/* 82264E54h case    4:*/		return 0x82264E58;
		  /* 82264E58h */ case    5:  		/* bc 12, CR6_LT, -44 */
		/* 82264E58h case    5:*/		if ( regs.CR[6].lt ) { return 0x82264E2C;  }
		/* 82264E58h case    5:*/		return 0x82264E5C;
	}
	return 0x82264E5C;
} // Block from 82264E44h-82264E5Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 82264E5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264E5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264E5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264E5C);
		  /* 82264E5Ch */ case    0:  		/* lwz R31, <#[R25 + 12]> */
		/* 82264E5Ch case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R25 + 0x0000000C) );
		/* 82264E5Ch case    0:*/		return 0x82264E60;
		  /* 82264E60h */ case    1:  		/* lis R16, -32215 */
		/* 82264E60h case    1:*/		cpu::op::lis<0>(regs,&regs.R16,0xFFFF8229);
		/* 82264E60h case    1:*/		return 0x82264E64;
		  /* 82264E64h */ case    2:  		/* cmpw CR6, R31, R11 */
		/* 82264E64h case    2:*/		cpu::op::cmpw<6>(regs,regs.R31,regs.R11);
		/* 82264E64h case    2:*/		return 0x82264E68;
		  /* 82264E68h */ case    3:  		/* bc 4, CR6_LT, 272 */
		/* 82264E68h case    3:*/		if ( !regs.CR[6].lt ) { return 0x82264F78;  }
		/* 82264E68h case    3:*/		return 0x82264E6C;
		  /* 82264E6Ch */ case    4:  		/* rlwinm R29, R31, 2, 0, 29 */
		/* 82264E6Ch case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R29,regs.R31);
		/* 82264E6Ch case    4:*/		return 0x82264E70;
		  /* 82264E70h */ case    5:  		/* lwz R11, <#[R16 - 25556]> */
		/* 82264E70h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0xFFFF9C2C) );
		/* 82264E70h case    5:*/		return 0x82264E74;
		  /* 82264E74h */ case    6:  		/* lwzx R11, <#[R29 + R11]> */
		/* 82264E74h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + regs.R11 + 0x00000000) );
		/* 82264E74h case    6:*/		return 0x82264E78;
		  /* 82264E78h */ case    7:  		/* cmpw CR6, R31, R11 */
		/* 82264E78h case    7:*/		cpu::op::cmpw<6>(regs,regs.R31,regs.R11);
		/* 82264E78h case    7:*/		return 0x82264E7C;
		  /* 82264E7Ch */ case    8:  		/* bc 4, CR6_EQ, 232 */
		/* 82264E7Ch case    8:*/		if ( !regs.CR[6].eq ) { return 0x82264F64;  }
		/* 82264E7Ch case    8:*/		return 0x82264E80;
		  /* 82264E80h */ case    9:  		/* lwz R3, <#[R25 + 4]> */
		/* 82264E80h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R25 + 0x00000004) );
		/* 82264E80h case    9:*/		return 0x82264E84;
		  /* 82264E84h */ case   10:  		/* addi R28, R28, 1 */
		/* 82264E84h case   10:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 82264E84h case   10:*/		return 0x82264E88;
		  /* 82264E88h */ case   11:  		/* lwz R11, <#[R3 + 4]> */
		/* 82264E88h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82264E88h case   11:*/		return 0x82264E8C;
		  /* 82264E8Ch */ case   12:  		/* cmplw CR6, R31, R11 */
		/* 82264E8Ch case   12:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82264E8Ch case   12:*/		return 0x82264E90;
		  /* 82264E90h */ case   13:  		/* bc 4, CR6_LT, 16 */
		/* 82264E90h case   13:*/		if ( !regs.CR[6].lt ) { return 0x82264EA0;  }
		/* 82264E90h case   13:*/		return 0x82264E94;
		  /* 82264E94h */ case   14:  		/* lwz R11, <#[R3 + 8]> */
		/* 82264E94h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82264E94h case   14:*/		return 0x82264E98;
		  /* 82264E98h */ case   15:  		/* add R30, R11, R29 */
		/* 82264E98h case   15:*/		cpu::op::add<0>(regs,&regs.R30,regs.R11,regs.R29);
		/* 82264E98h case   15:*/		return 0x82264E9C;
		  /* 82264E9Ch */ case   16:  		/* b 16 */
		/* 82264E9Ch case   16:*/		return 0x82264EAC;
		/* 82264E9Ch case   16:*/		return 0x82264EA0;
	}
	return 0x82264EA0;
} // Block from 82264E5Ch-82264EA0h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82264EA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264EA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264EA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264EA0);
		  /* 82264EA0h */ case    0:  		/* mr R4, R31 */
		/* 82264EA0h case    0:*/		regs.R4 = regs.R31;
		/* 82264EA0h case    0:*/		return 0x82264EA4;
		  /* 82264EA4h */ case    1:  		/* bl -70628 */
		/* 82264EA4h case    1:*/		regs.LR = 0x82264EA8; return 0x82253AC0;
		/* 82264EA4h case    1:*/		return 0x82264EA8;
	}
	return 0x82264EA8;
} // Block from 82264EA0h-82264EA8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82264EA8h
// Function '?MergeEdges@Range@XGRAPHICS@@QAAXHPAVInterference@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264EA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264EA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264EA8);
		  /* 82264EA8h */ case    0:  		/* mr R30, R3 */
		/* 82264EA8h case    0:*/		regs.R30 = regs.R3;
		/* 82264EA8h case    0:*/		return 0x82264EAC;
	}
	return 0x82264EAC;
} // Block from 82264EA8h-82264EACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82264EACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264EAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264EAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264EAC);
		  /* 82264EACh */ case    0:  		/* lwz R3, <#[R25 + 4]> */
		/* 82264EACh case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R25 + 0x00000004) );
		/* 82264EACh case    0:*/		return 0x82264EB0;
		  /* 82264EB0h */ case    1:  		/* lwz R11, <#[R3 + 4]> */
		/* 82264EB0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82264EB0h case    1:*/		return 0x82264EB4;
		  /* 82264EB4h */ case    2:  		/* cmplw CR6, R31, R11 */
		/* 82264EB4h case    2:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82264EB4h case    2:*/		return 0x82264EB8;
		  /* 82264EB8h */ case    3:  		/* bc 4, CR6_LT, 16 */
		/* 82264EB8h case    3:*/		if ( !regs.CR[6].lt ) { return 0x82264EC8;  }
		/* 82264EB8h case    3:*/		return 0x82264EBC;
		  /* 82264EBCh */ case    4:  		/* lwz R11, <#[R3 + 8]> */
		/* 82264EBCh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82264EBCh case    4:*/		return 0x82264EC0;
		  /* 82264EC0h */ case    5:  		/* add R3, R11, R29 */
		/* 82264EC0h case    5:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R29);
		/* 82264EC0h case    5:*/		return 0x82264EC4;
		  /* 82264EC4h */ case    6:  		/* b 12 */
		/* 82264EC4h case    6:*/		return 0x82264ED0;
		/* 82264EC4h case    6:*/		return 0x82264EC8;
	}
	return 0x82264EC8;
} // Block from 82264EACh-82264EC8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82264EC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264EC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264EC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264EC8);
		  /* 82264EC8h */ case    0:  		/* mr R4, R31 */
		/* 82264EC8h case    0:*/		regs.R4 = regs.R31;
		/* 82264EC8h case    0:*/		return 0x82264ECC;
		  /* 82264ECCh */ case    1:  		/* bl -70668 */
		/* 82264ECCh case    1:*/		regs.LR = 0x82264ED0; return 0x82253AC0;
		/* 82264ECCh case    1:*/		return 0x82264ED0;
	}
	return 0x82264ED0;
} // Block from 82264EC8h-82264ED0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82264ED0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264ED0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264ED0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264ED0);
		  /* 82264ED0h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 82264ED0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82264ED0h case    0:*/		return 0x82264ED4;
		  /* 82264ED4h */ case    1:  		/* lwz R10, <#[R3]> */
		/* 82264ED4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82264ED4h case    1:*/		return 0x82264ED8;
		  /* 82264ED8h */ case    2:  		/* lwz R11, <#[R11 + 4]> */
		/* 82264ED8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82264ED8h case    2:*/		return 0x82264EDC;
		  /* 82264EDCh */ case    3:  		/* stw R11, <#[R10 + 12]> */
		/* 82264EDCh case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		/* 82264EDCh case    3:*/		return 0x82264EE0;
		  /* 82264EE0h */ case    4:  		/* lwz R3, <#[R25 + 4]> */
		/* 82264EE0h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R25 + 0x00000004) );
		/* 82264EE0h case    4:*/		return 0x82264EE4;
		  /* 82264EE4h */ case    5:  		/* lwz R11, <#[R3 + 4]> */
		/* 82264EE4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82264EE4h case    5:*/		return 0x82264EE8;
		  /* 82264EE8h */ case    6:  		/* cmplw CR6, R31, R11 */
		/* 82264EE8h case    6:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82264EE8h case    6:*/		return 0x82264EEC;
		  /* 82264EECh */ case    7:  		/* bc 4, CR6_LT, 16 */
		/* 82264EECh case    7:*/		if ( !regs.CR[6].lt ) { return 0x82264EFC;  }
		/* 82264EECh case    7:*/		return 0x82264EF0;
		  /* 82264EF0h */ case    8:  		/* lwz R11, <#[R3 + 8]> */
		/* 82264EF0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82264EF0h case    8:*/		return 0x82264EF4;
		  /* 82264EF4h */ case    9:  		/* add R3, R11, R29 */
		/* 82264EF4h case    9:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R29);
		/* 82264EF4h case    9:*/		return 0x82264EF8;
		  /* 82264EF8h */ case   10:  		/* b 12 */
		/* 82264EF8h case   10:*/		return 0x82264F04;
		/* 82264EF8h case   10:*/		return 0x82264EFC;
	}
	return 0x82264EFC;
} // Block from 82264ED0h-82264EFCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 82264EFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264EFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264EFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264EFC);
		  /* 82264EFCh */ case    0:  		/* mr R4, R31 */
		/* 82264EFCh case    0:*/		regs.R4 = regs.R31;
		/* 82264EFCh case    0:*/		return 0x82264F00;
		  /* 82264F00h */ case    1:  		/* bl -70720 */
		/* 82264F00h case    1:*/		regs.LR = 0x82264F04; return 0x82253AC0;
		/* 82264F00h case    1:*/		return 0x82264F04;
	}
	return 0x82264F04;
} // Block from 82264EFCh-82264F04h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82264F04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264F04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264F04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264F04);
		  /* 82264F04h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82264F04h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82264F04h case    0:*/		return 0x82264F08;
		  /* 82264F08h */ case    1:  		/* lwz R11, <#[R11 + 12]> */
		/* 82264F08h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 82264F08h case    1:*/		return 0x82264F0C;
		  /* 82264F0Ch */ case    2:  		/* cmpwi CR6, R11, 0 */
		/* 82264F0Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82264F0Ch case    2:*/		return 0x82264F10;
		  /* 82264F10h */ case    3:  		/* bc 4, CR6_EQ, 16 */
		/* 82264F10h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82264F20;  }
		/* 82264F10h case    3:*/		return 0x82264F14;
		  /* 82264F14h */ case    4:  		/* lwz R4, <#[R19 + 4]> */
		/* 82264F14h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R19 + 0x00000004) );
		/* 82264F14h case    4:*/		return 0x82264F18;
		  /* 82264F18h */ case    5:  		/* mr R3, R19 */
		/* 82264F18h case    5:*/		regs.R3 = regs.R19;
		/* 82264F18h case    5:*/		return 0x82264F1C;
		  /* 82264F1Ch */ case    6:  		/* b 64 */
		/* 82264F1Ch case    6:*/		return 0x82264F5C;
		/* 82264F1Ch case    6:*/		return 0x82264F20;
	}
	return 0x82264F20;
} // Block from 82264F04h-82264F20h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82264F20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264F20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264F20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264F20);
		  /* 82264F20h */ case    0:  		/* lwz R3, <#[R25 + 4]> */
		/* 82264F20h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R25 + 0x00000004) );
		/* 82264F20h case    0:*/		return 0x82264F24;
		  /* 82264F24h */ case    1:  		/* lwz R11, <#[R3 + 4]> */
		/* 82264F24h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82264F24h case    1:*/		return 0x82264F28;
		  /* 82264F28h */ case    2:  		/* cmplw CR6, R31, R11 */
		/* 82264F28h case    2:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82264F28h case    2:*/		return 0x82264F2C;
		  /* 82264F2Ch */ case    3:  		/* bc 4, CR6_LT, 16 */
		/* 82264F2Ch case    3:*/		if ( !regs.CR[6].lt ) { return 0x82264F3C;  }
		/* 82264F2Ch case    3:*/		return 0x82264F30;
		  /* 82264F30h */ case    4:  		/* lwz R11, <#[R3 + 8]> */
		/* 82264F30h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82264F30h case    4:*/		return 0x82264F34;
		  /* 82264F34h */ case    5:  		/* add R3, R11, R29 */
		/* 82264F34h case    5:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R29);
		/* 82264F34h case    5:*/		return 0x82264F38;
		  /* 82264F38h */ case    6:  		/* b 12 */
		/* 82264F38h case    6:*/		return 0x82264F44;
		/* 82264F38h case    6:*/		return 0x82264F3C;
	}
	return 0x82264F3C;
} // Block from 82264F20h-82264F3Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 82264F3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264F3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264F3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264F3C);
		  /* 82264F3Ch */ case    0:  		/* mr R4, R31 */
		/* 82264F3Ch case    0:*/		regs.R4 = regs.R31;
		/* 82264F3Ch case    0:*/		return 0x82264F40;
		  /* 82264F40h */ case    1:  		/* bl -70784 */
		/* 82264F40h case    1:*/		regs.LR = 0x82264F44; return 0x82253AC0;
		/* 82264F40h case    1:*/		return 0x82264F44;
	}
	return 0x82264F44;
} // Block from 82264F3Ch-82264F44h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82264F44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264F44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264F44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264F44);
		  /* 82264F44h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82264F44h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82264F44h case    0:*/		return 0x82264F48;
		  /* 82264F48h */ case    1:  		/* lwz R11, <#[R11 + 12]> */
		/* 82264F48h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 82264F48h case    1:*/		return 0x82264F4C;
		  /* 82264F4Ch */ case    2:  		/* cmpw CR6, R11, R26 */
		/* 82264F4Ch case    2:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R26);
		/* 82264F4Ch case    2:*/		return 0x82264F50;
		  /* 82264F50h */ case    3:  		/* bc 4, CR6_LT, 20 */
		/* 82264F50h case    3:*/		if ( !regs.CR[6].lt ) { return 0x82264F64;  }
		/* 82264F50h case    3:*/		return 0x82264F54;
		  /* 82264F54h */ case    4:  		/* lwz R4, <#[R27 + 4]> */
		/* 82264F54h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R27 + 0x00000004) );
		/* 82264F54h case    4:*/		return 0x82264F58;
		  /* 82264F58h */ case    5:  		/* mr R3, R27 */
		/* 82264F58h case    5:*/		regs.R3 = regs.R27;
		/* 82264F58h case    5:*/		return 0x82264F5C;
	}
	return 0x82264F5C;
} // Block from 82264F44h-82264F5Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 82264F5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264F5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264F5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264F5C);
		  /* 82264F5Ch */ case    0:  		/* bl -70812 */
		/* 82264F5Ch case    0:*/		regs.LR = 0x82264F60; return 0x82253AC0;
		/* 82264F5Ch case    0:*/		return 0x82264F60;
		  /* 82264F60h */ case    1:  		/* stw R31, <#[R3]> */
		/* 82264F60h case    1:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 82264F60h case    1:*/		return 0x82264F64;
	}
	return 0x82264F64;
} // Block from 82264F5Ch-82264F64h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82264F64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264F64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264F64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264F64);
		  /* 82264F64h */ case    0:  		/* lwz R11, <#[R25 + 16]> */
		/* 82264F64h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000010) );
		/* 82264F64h case    0:*/		return 0x82264F68;
		  /* 82264F68h */ case    1:  		/* addi R31, R31, 1 */
		/* 82264F68h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82264F68h case    1:*/		return 0x82264F6C;
		  /* 82264F6Ch */ case    2:  		/* addi R29, R29, 4 */
		/* 82264F6Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 82264F6Ch case    2:*/		return 0x82264F70;
		  /* 82264F70h */ case    3:  		/* cmpw CR6, R31, R11 */
		/* 82264F70h case    3:*/		cpu::op::cmpw<6>(regs,regs.R31,regs.R11);
		/* 82264F70h case    3:*/		return 0x82264F74;
		  /* 82264F74h */ case    4:  		/* bc 12, CR6_LT, -260 */
		/* 82264F74h case    4:*/		if ( regs.CR[6].lt ) { return 0x82264E70;  }
		/* 82264F74h case    4:*/		return 0x82264F78;
	}
	return 0x82264F78;
} // Block from 82264F64h-82264F78h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82264F78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264F78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264F78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264F78);
		  /* 82264F78h */ case    0:  		/* mr R20, R18 */
		/* 82264F78h case    0:*/		regs.R20 = regs.R18;
		/* 82264F78h case    0:*/		return 0x82264F7C;
		  /* 82264F7Ch */ case    1:  		/* b 264 */
		/* 82264F7Ch case    1:*/		return 0x82265084;
		/* 82264F7Ch case    1:*/		return 0x82264F80;
		  /* 82264F80h */ case    2:  		/* addi R20, R20, 1 */
		/* 82264F80h case    2:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R20,0x1);
		/* 82264F80h case    2:*/		return 0x82264F84;
		  /* 82264F84h */ case    3:  		/* b 100 */
		/* 82264F84h case    3:*/		return 0x82264FE8;
		/* 82264F84h case    3:*/		return 0x82264F88;
		  /* 82264F88h */ case    4:  		/* mr R3, R27 */
		/* 82264F88h case    4:*/		regs.R3 = regs.R27;
		/* 82264F88h case    4:*/		return 0x82264F8C;
		  /* 82264F8Ch */ case    5:  		/* bl -41532 */
		/* 82264F8Ch case    5:*/		regs.LR = 0x82264F90; return 0x8225AD50;
		/* 82264F8Ch case    5:*/		return 0x82264F90;
		  /* 82264F90h */ case    6:  		/* mr R31, R3 */
		/* 82264F90h case    6:*/		regs.R31 = regs.R3;
		/* 82264F90h case    6:*/		return 0x82264F94;
		  /* 82264F94h */ case    7:  		/* mr R3, R19 */
		/* 82264F94h case    7:*/		regs.R3 = regs.R19;
		/* 82264F94h case    7:*/		return 0x82264F98;
		  /* 82264F98h */ case    8:  		/* lwz R4, <#[R19 + 4]> */
		/* 82264F98h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R19 + 0x00000004) );
		/* 82264F98h case    8:*/		return 0x82264F9C;
		  /* 82264F9Ch */ case    9:  		/* bl -70876 */
		/* 82264F9Ch case    9:*/		regs.LR = 0x82264FA0; return 0x82253AC0;
		/* 82264F9Ch case    9:*/		return 0x82264FA0;
		  /* 82264FA0h */ case   10:  		/* stw R31, <#[R3]> */
		/* 82264FA0h case   10:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 82264FA0h case   10:*/		return 0x82264FA4;
		  /* 82264FA4h */ case   11:  		/* lwz R3, <#[R25 + 4]> */
		/* 82264FA4h case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R25 + 0x00000004) );
		/* 82264FA4h case   11:*/		return 0x82264FA8;
		  /* 82264FA8h */ case   12:  		/* lwz R11, <#[R3 + 4]> */
		/* 82264FA8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82264FA8h case   12:*/		return 0x82264FAC;
		  /* 82264FACh */ case   13:  		/* cmplw CR6, R31, R11 */
		/* 82264FACh case   13:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82264FACh case   13:*/		return 0x82264FB0;
		  /* 82264FB0h */ case   14:  		/* bc 4, CR6_LT, 20 */
		/* 82264FB0h case   14:*/		if ( !regs.CR[6].lt ) { return 0x82264FC4;  }
		/* 82264FB0h case   14:*/		return 0x82264FB4;
		  /* 82264FB4h */ case   15:  		/* lwz R10, <#[R3 + 8]> */
		/* 82264FB4h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 82264FB4h case   15:*/		return 0x82264FB8;
		  /* 82264FB8h */ case   16:  		/* rlwinm R11, R31, 2, 0, 29 */
		/* 82264FB8h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R31);
		/* 82264FB8h case   16:*/		return 0x82264FBC;
		  /* 82264FBCh */ case   17:  		/* add R3, R10, R11 */
		/* 82264FBCh case   17:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 82264FBCh case   17:*/		return 0x82264FC0;
		  /* 82264FC0h */ case   18:  		/* b 12 */
		/* 82264FC0h case   18:*/		return 0x82264FCC;
		/* 82264FC0h case   18:*/		return 0x82264FC4;
	}
	return 0x82264FC4;
} // Block from 82264F78h-82264FC4h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82264FC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264FC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264FC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264FC4);
		  /* 82264FC4h */ case    0:  		/* mr R4, R31 */
		/* 82264FC4h case    0:*/		regs.R4 = regs.R31;
		/* 82264FC4h case    0:*/		return 0x82264FC8;
		  /* 82264FC8h */ case    1:  		/* bl -70920 */
		/* 82264FC8h case    1:*/		regs.LR = 0x82264FCC; return 0x82253AC0;
		/* 82264FC8h case    1:*/		return 0x82264FCC;
	}
	return 0x82264FCC;
} // Block from 82264FC4h-82264FCCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 82264FCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264FCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264FCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264FCC);
		  /* 82264FCCh */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82264FCCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82264FCCh case    0:*/		return 0x82264FD0;
		  /* 82264FD0h */ case    1:  		/* mr R6, R26 */
		/* 82264FD0h case    1:*/		regs.R6 = regs.R26;
		/* 82264FD0h case    1:*/		return 0x82264FD4;
		  /* 82264FD4h */ case    2:  		/* mr R5, R27 */
		/* 82264FD4h case    2:*/		regs.R5 = regs.R27;
		/* 82264FD4h case    2:*/		return 0x82264FD8;
		  /* 82264FD8h */ case    3:  		/* mr R4, R31 */
		/* 82264FD8h case    3:*/		regs.R4 = regs.R31;
		/* 82264FD8h case    3:*/		return 0x82264FDC;
		  /* 82264FDCh */ case    4:  		/* mr R3, R25 */
		/* 82264FDCh case    4:*/		regs.R3 = regs.R25;
		/* 82264FDCh case    4:*/		return 0x82264FE0;
		  /* 82264FE0h */ case    5:  		/* stw R18, <#[R11 + 12]> */
		/* 82264FE0h case    5:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R11 + 0x0000000C) );
		/* 82264FE0h case    5:*/		return 0x82264FE4;
		  /* 82264FE4h */ case    6:  		/* bl -1100 */
		/* 82264FE4h case    6:*/		regs.LR = 0x82264FE8; return 0x82264B98;
		/* 82264FE4h case    6:*/		return 0x82264FE8;
	}
	return 0x82264FE8;
} // Block from 82264FCCh-82264FE8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82264FE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82264FE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82264FE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82264FE8);
		  /* 82264FE8h */ case    0:  		/* lwz R11, <#[R27 + 4]> */
		/* 82264FE8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 82264FE8h case    0:*/		return 0x82264FEC;
		  /* 82264FECh */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82264FECh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82264FECh case    1:*/		return 0x82264FF0;
		  /* 82264FF0h */ case    2:  		/* bc 4, CR6_EQ, -104 */
		/* 82264FF0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82264F88;  }
		/* 82264FF0h case    2:*/		return 0x82264FF4;
		  /* 82264FF4h */ case    3:  		/* lwz R11, <#[R19 + 4]> */
		/* 82264FF4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000004) );
		/* 82264FF4h case    3:*/		return 0x82264FF8;
		  /* 82264FF8h */ case    4:  		/* cmpw CR6, R11, R28 */
		/* 82264FF8h case    4:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R28);
		/* 82264FF8h case    4:*/		return 0x82264FFC;
		  /* 82264FFCh */ case    5:  		/* bc 12, CR6_EQ, 148 */
		/* 82264FFCh case    5:*/		if ( regs.CR[6].eq ) { return 0x82265090;  }
		/* 82264FFCh case    5:*/		return 0x82265000;
		  /* 82265000h */ case    6:  		/* lwz R31, <#[R25 + 12]> */
		/* 82265000h case    6:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R25 + 0x0000000C) );
		/* 82265000h case    6:*/		return 0x82265004;
		  /* 82265004h */ case    7:  		/* addi R26, R26, 1 */
		/* 82265004h case    7:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 82265004h case    7:*/		return 0x82265008;
		  /* 82265008h */ case    8:  		/* lwz R11, <#[R25 + 16]> */
		/* 82265008h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000010) );
		/* 82265008h case    8:*/		return 0x8226500C;
		  /* 8226500Ch */ case    9:  		/* cmpw CR6, R31, R11 */
		/* 8226500Ch case    9:*/		cpu::op::cmpw<6>(regs,regs.R31,regs.R11);
		/* 8226500Ch case    9:*/		return 0x82265010;
		  /* 82265010h */ case   10:  		/* bc 4, CR6_LT, 116 */
		/* 82265010h case   10:*/		if ( !regs.CR[6].lt ) { return 0x82265084;  }
		/* 82265010h case   10:*/		return 0x82265014;
		  /* 82265014h */ case   11:  		/* rlwinm R30, R31, 2, 0, 29 */
		/* 82265014h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R30,regs.R31);
		/* 82265014h case   11:*/		return 0x82265018;
		  /* 82265018h */ case   12:  		/* lwz R11, <#[R16 - 25556]> */
		/* 82265018h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0xFFFF9C2C) );
		/* 82265018h case   12:*/		return 0x8226501C;
		  /* 8226501Ch */ case   13:  		/* lwzx R11, <#[R30 + R11]> */
		/* 8226501Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + regs.R11 + 0x00000000) );
		/* 8226501Ch case   13:*/		return 0x82265020;
	}
	return 0x82265020;
} // Block from 82264FE8h-82265020h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82265020h
// Function '??0Interference@XGRAPHICS@@QAA@HHPAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265020( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265020) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265020);
		  /* 82265020h */ case    0:  		/* cmpw CR6, R31, R11 */
		/* 82265020h case    0:*/		cpu::op::cmpw<6>(regs,regs.R31,regs.R11);
		/* 82265020h case    0:*/		return 0x82265024;
		  /* 82265024h */ case    1:  		/* bc 4, CR6_EQ, 76 */
		/* 82265024h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82265070;  }
		/* 82265024h case    1:*/		return 0x82265028;
		  /* 82265028h */ case    2:  		/* lwz R3, <#[R25 + 4]> */
		/* 82265028h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R25 + 0x00000004) );
		/* 82265028h case    2:*/		return 0x8226502C;
		  /* 8226502Ch */ case    3:  		/* lwz R11, <#[R3 + 4]> */
		/* 8226502Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8226502Ch case    3:*/		return 0x82265030;
		  /* 82265030h */ case    4:  		/* cmplw CR6, R31, R11 */
		/* 82265030h case    4:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82265030h case    4:*/		return 0x82265034;
		  /* 82265034h */ case    5:  		/* bc 4, CR6_LT, 16 */
		/* 82265034h case    5:*/		if ( !regs.CR[6].lt ) { return 0x82265044;  }
		/* 82265034h case    5:*/		return 0x82265038;
		  /* 82265038h */ case    6:  		/* lwz R11, <#[R3 + 8]> */
		/* 82265038h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82265038h case    6:*/		return 0x8226503C;
		  /* 8226503Ch */ case    7:  		/* add R3, R11, R30 */
		/* 8226503Ch case    7:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R30);
		/* 8226503Ch case    7:*/		return 0x82265040;
		  /* 82265040h */ case    8:  		/* b 12 */
		/* 82265040h case    8:*/		return 0x8226504C;
		/* 82265040h case    8:*/		return 0x82265044;
	}
	return 0x82265044;
} // Block from 82265020h-82265044h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82265044h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265044( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265044) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265044);
		  /* 82265044h */ case    0:  		/* mr R4, R31 */
		/* 82265044h case    0:*/		regs.R4 = regs.R31;
		/* 82265044h case    0:*/		return 0x82265048;
		  /* 82265048h */ case    1:  		/* bl -71048 */
		/* 82265048h case    1:*/		regs.LR = 0x8226504C; return 0x82253AC0;
		/* 82265048h case    1:*/		return 0x8226504C;
	}
	return 0x8226504C;
} // Block from 82265044h-8226504Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226504Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226504C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226504C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226504C);
		  /* 8226504Ch */ case    0:  		/* lwz R11, <#[R3]> */
		/* 8226504Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8226504Ch case    0:*/		return 0x82265050;
		  /* 82265050h */ case    1:  		/* addi R10, R26, -1 */
		/* 82265050h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R26,0xFFFFFFFF);
		/* 82265050h case    1:*/		return 0x82265054;
		  /* 82265054h */ case    2:  		/* lwz R11, <#[R11 + 12]> */
		/* 82265054h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 82265054h case    2:*/		return 0x82265058;
		  /* 82265058h */ case    3:  		/* cmpw CR6, R11, R10 */
		/* 82265058h case    3:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 82265058h case    3:*/		return 0x8226505C;
		  /* 8226505Ch */ case    4:  		/* bc 4, CR6_EQ, 20 */
		/* 8226505Ch case    4:*/		if ( !regs.CR[6].eq ) { return 0x82265070;  }
		/* 8226505Ch case    4:*/		return 0x82265060;
		  /* 82265060h */ case    5:  		/* mr R3, R27 */
		/* 82265060h case    5:*/		regs.R3 = regs.R27;
		/* 82265060h case    5:*/		return 0x82265064;
		  /* 82265064h */ case    6:  		/* lwz R4, <#[R27 + 4]> */
		/* 82265064h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R27 + 0x00000004) );
		/* 82265064h case    6:*/		return 0x82265068;
		  /* 82265068h */ case    7:  		/* bl -71080 */
		/* 82265068h case    7:*/		regs.LR = 0x8226506C; return 0x82253AC0;
		/* 82265068h case    7:*/		return 0x8226506C;
		  /* 8226506Ch */ case    8:  		/* stw R31, <#[R3]> */
		/* 8226506Ch case    8:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 8226506Ch case    8:*/		return 0x82265070;
	}
	return 0x82265070;
} // Block from 8226504Ch-82265070h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82265070h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265070( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265070) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265070);
		  /* 82265070h */ case    0:  		/* lwz R11, <#[R25 + 16]> */
		/* 82265070h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000010) );
		/* 82265070h case    0:*/		return 0x82265074;
		  /* 82265074h */ case    1:  		/* addi R31, R31, 1 */
		/* 82265074h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82265074h case    1:*/		return 0x82265078;
		  /* 82265078h */ case    2:  		/* addi R30, R30, 4 */
		/* 82265078h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 82265078h case    2:*/		return 0x8226507C;
		  /* 8226507Ch */ case    3:  		/* cmpw CR6, R31, R11 */
		/* 8226507Ch case    3:*/		cpu::op::cmpw<6>(regs,regs.R31,regs.R11);
		/* 8226507Ch case    3:*/		return 0x82265080;
		  /* 82265080h */ case    4:  		/* bc 12, CR6_LT, -104 */
		/* 82265080h case    4:*/		if ( regs.CR[6].lt ) { return 0x82265018;  }
		/* 82265080h case    4:*/		return 0x82265084;
	}
	return 0x82265084;
} // Block from 82265070h-82265084h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82265084h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265084( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265084) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265084);
		  /* 82265084h */ case    0:  		/* lwz R11, <#[R19 + 4]> */
		/* 82265084h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000004) );
		/* 82265084h case    0:*/		return 0x82265088;
		  /* 82265088h */ case    1:  		/* cmpw CR6, R11, R28 */
		/* 82265088h case    1:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R28);
		/* 82265088h case    1:*/		return 0x8226508C;
		  /* 8226508Ch */ case    2:  		/* bc 4, CR6_EQ, -268 */
		/* 8226508Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x82264F80;  }
		/* 8226508Ch case    2:*/		return 0x82265090;
	}
	return 0x82265090;
} // Block from 82265084h-82265090h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82265090h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265090( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265090) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265090);
		  /* 82265090h */ case    0:  		/* lwz R11, <#[R25 + 8]> */
		/* 82265090h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 82265090h case    0:*/		return 0x82265094;
		  /* 82265094h */ case    1:  		/* mr R22, R18 */
		/* 82265094h case    1:*/		regs.R22 = regs.R18;
		/* 82265094h case    1:*/		return 0x82265098;
		  /* 82265098h */ case    2:  		/* lwz R10, <#[R11 + 1360]> */
		/* 82265098h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000550) );
		/* 82265098h case    2:*/		return 0x8226509C;
		  /* 8226509Ch */ case    3:  		/* lwz R4, <#[R11 + 1456]> */
		/* 8226509Ch case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x000005B0) );
		/* 8226509Ch case    3:*/		return 0x822650A0;
		  /* 822650A0h */ case    4:  		/* lwz R23, <#[R11 + 2736]> */
		/* 822650A0h case    4:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R11 + 0x00000AB0) );
		/* 822650A0h case    4:*/		return 0x822650A4;
		  /* 822650A4h */ case    5:  		/* lwz R21, <#[R10 + 4]> */
		/* 822650A4h case    5:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R10 + 0x00000004) );
		/* 822650A4h case    5:*/		return 0x822650A8;
		  /* 822650A8h */ case    6:  		/* mr R3, R21 */
		/* 822650A8h case    6:*/		regs.R3 = regs.R21;
		/* 822650A8h case    6:*/		return 0x822650AC;
		  /* 822650ACh */ case    7:  		/* bl -190316 */
		/* 822650ACh case    7:*/		regs.LR = 0x822650B0; return 0x82236940;
		/* 822650ACh case    7:*/		return 0x822650B0;
		  /* 822650B0h */ case    8:  		/* lwz R11, <#[R19 + 4]> */
		/* 822650B0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000004) );
		/* 822650B0h case    8:*/		return 0x822650B4;
		  /* 822650B4h */ case    9:  		/* mr R26, R3 */
		/* 822650B4h case    9:*/		regs.R26 = regs.R3;
		/* 822650B4h case    9:*/		return 0x822650B8;
		  /* 822650B8h */ case   10:  		/* cmplwi CR6, R11, 0 */
		/* 822650B8h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822650B8h case   10:*/		return 0x822650BC;
		  /* 822650BCh */ case   11:  		/* bc 12, CR6_EQ, 612 */
		/* 822650BCh case   11:*/		if ( regs.CR[6].eq ) { return 0x82265320;  }
		/* 822650BCh case   11:*/		return 0x822650C0;
		  /* 822650C0h */ case   12:  		/* lwz R24, <#[R1 + 80]> */
		/* 822650C0h case   12:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R1 + 0x00000050) );
		/* 822650C0h case   12:*/		return 0x822650C4;
		  /* 822650C4h */ case   13:  		/* lwz R10, <#[R26]> */
		/* 822650C4h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000000) );
		/* 822650C4h case   13:*/		return 0x822650C8;
		  /* 822650C8h */ case   14:  		/* mr R11, R18 */
		/* 822650C8h case   14:*/		regs.R11 = regs.R18;
		/* 822650C8h case   14:*/		return 0x822650CC;
		  /* 822650CCh */ case   15:  		/* cmplwi CR6, R10, 0 */
		/* 822650CCh case   15:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 822650CCh case   15:*/		return 0x822650D0;
		  /* 822650D0h */ case   16:  		/* bc 4, CR6_GT, 28 */
		/* 822650D0h case   16:*/		if ( !regs.CR[6].gt ) { return 0x822650EC;  }
		/* 822650D0h case   16:*/		return 0x822650D4;
		  /* 822650D4h */ case   17:  		/* addi R10, R26, 4 */
		/* 822650D4h case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R26,0x4);
		/* 822650D4h case   17:*/		return 0x822650D8;
		  /* 822650D8h */ case   18:  		/* stwu R18, <#[R10 + 4]> */
		/* 822650D8h case   18:*/		cpu::mem::store32( regs, regs.R18, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 822650D8h case   18:*/		return 0x822650DC;
		  /* 822650DCh */ case   19:  		/* addi R11, R11, 1 */
		/* 822650DCh case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 822650DCh case   19:*/		return 0x822650E0;
		  /* 822650E0h */ case   20:  		/* lwz R9, <#[R26]> */
		/* 822650E0h case   20:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000000) );
		/* 822650E0h case   20:*/		return 0x822650E4;
		  /* 822650E4h */ case   21:  		/* cmplw CR6, R11, R9 */
		/* 822650E4h case   21:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 822650E4h case   21:*/		return 0x822650E8;
		  /* 822650E8h */ case   22:  		/* bc 12, CR6_LT, -16 */
		/* 822650E8h case   22:*/		if ( regs.CR[6].lt ) { return 0x822650D8;  }
		/* 822650E8h case   22:*/		return 0x822650EC;
	}
	return 0x822650EC;
} // Block from 82265090h-822650ECh (23 instructions)

//////////////////////////////////////////////////////
// Block at 822650ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822650EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822650EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822650EC);
		  /* 822650ECh */ case    0:  		/* mr R31, R18 */
		/* 822650ECh case    0:*/		regs.R31 = regs.R18;
		/* 822650ECh case    0:*/		return 0x822650F0;
		  /* 822650F0h */ case    1:  		/* cmpwi CR6, R21, 0 */
		/* 822650F0h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R21,0x00000000);
		/* 822650F0h case    1:*/		return 0x822650F4;
		  /* 822650F4h */ case    2:  		/* bc 4, CR6_GT, 68 */
		/* 822650F4h case    2:*/		if ( !regs.CR[6].gt ) { return 0x82265138;  }
		/* 822650F4h case    2:*/		return 0x822650F8;
		  /* 822650F8h */ case    3:  		/* mr R4, R31 */
		/* 822650F8h case    3:*/		regs.R4 = regs.R31;
		/* 822650F8h case    3:*/		return 0x822650FC;
		  /* 822650FCh */ case    4:  		/* mr R3, R23 */
		/* 822650FCh case    4:*/		regs.R3 = regs.R23;
		/* 822650FCh case    4:*/		return 0x82265100;
		  /* 82265100h */ case    5:  		/* bl -121728 */
		/* 82265100h case    5:*/		regs.LR = 0x82265104; return 0x82247580;
		/* 82265100h case    5:*/		return 0x82265104;
		  /* 82265104h */ case    6:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82265104h case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82265104h case    6:*/		return 0x82265108;
		  /* 82265108h */ case    7:  		/* bc 4, CR0_EQ, 36 */
		/* 82265108h case    7:*/		if ( !regs.CR[0].eq ) { return 0x8226512C;  }
		/* 82265108h case    7:*/		return 0x8226510C;
		  /* 8226510Ch */ case    8:  		/* rlwinm R11, R31, 27, 5, 31 */
		/* 8226510Ch case    8:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R31);
		/* 8226510Ch case    8:*/		return 0x82265110;
		  /* 82265110h */ case    9:  		/* rlwinm R10, R31, 0, 27, 31 */
		/* 82265110h case    9:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R31);
		/* 82265110h case    9:*/		return 0x82265114;
		  /* 82265114h */ case   10:  		/* addi R11, R11, 2 */
		/* 82265114h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82265114h case   10:*/		return 0x82265118;
		  /* 82265118h */ case   11:  		/* slw R10, R15, R10 */
		/* 82265118h case   11:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R15,regs.R10);
		/* 82265118h case   11:*/		return 0x8226511C;
		  /* 8226511Ch */ case   12:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8226511Ch case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8226511Ch case   12:*/		return 0x82265120;
		  /* 82265120h */ case   13:  		/* lwzx R9, <#[R11 + R26]> */
		/* 82265120h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + regs.R26 + 0x00000000) );
		/* 82265120h case   13:*/		return 0x82265124;
		  /* 82265124h */ case   14:  		/* or R10, R10, R9 */
		/* 82265124h case   14:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82265124h case   14:*/		return 0x82265128;
		  /* 82265128h */ case   15:  		/* stwx R10, <#[R11 + R26]> */
		/* 82265128h case   15:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R26 + 0x00000000) );
		/* 82265128h case   15:*/		return 0x8226512C;
	}
	return 0x8226512C;
} // Block from 822650ECh-8226512Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 8226512Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226512C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226512C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226512C);
		  /* 8226512Ch */ case    0:  		/* addi R31, R31, 1 */
		/* 8226512Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 8226512Ch case    0:*/		return 0x82265130;
		  /* 82265130h */ case    1:  		/* cmpw CR6, R31, R21 */
		/* 82265130h case    1:*/		cpu::op::cmpw<6>(regs,regs.R31,regs.R21);
		/* 82265130h case    1:*/		return 0x82265134;
		  /* 82265134h */ case    2:  		/* bc 12, CR6_LT, -60 */
		/* 82265134h case    2:*/		if ( regs.CR[6].lt ) { return 0x822650F8;  }
		/* 82265134h case    2:*/		return 0x82265138;
	}
	return 0x82265138;
} // Block from 8226512Ch-82265138h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82265138h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265138( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265138) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265138);
		  /* 82265138h */ case    0:  		/* mr R3, R19 */
		/* 82265138h case    0:*/		regs.R3 = regs.R19;
		/* 82265138h case    0:*/		return 0x8226513C;
		  /* 8226513Ch */ case    1:  		/* bl -41964 */
		/* 8226513Ch case    1:*/		regs.LR = 0x82265140; return 0x8225AD50;
		/* 8226513Ch case    1:*/		return 0x82265140;
	}
	return 0x82265140;
} // Block from 82265138h-82265140h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82265140h
// Function '?AddPreference@Interference@XGRAPHICS@@QAAXHH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265140( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265140) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265140);
		  /* 82265140h */ case    0:  		/* lwz R11, <#[R25 + 4]> */
		/* 82265140h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 82265140h case    0:*/		return 0x82265144;
		  /* 82265144h */ case    1:  		/* mr R30, R3 */
		/* 82265144h case    1:*/		regs.R30 = regs.R3;
		/* 82265144h case    1:*/		return 0x82265148;
		  /* 82265148h */ case    2:  		/* lwz R10, <#[R11 + 4]> */
		/* 82265148h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 82265148h case    2:*/		return 0x8226514C;
		  /* 8226514Ch */ case    3:  		/* cmplw CR6, R3, R10 */
		/* 8226514Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R10);
		/* 8226514Ch case    3:*/		return 0x82265150;
		  /* 82265150h */ case    4:  		/* bc 4, CR6_LT, 20 */
		/* 82265150h case    4:*/		if ( !regs.CR[6].lt ) { return 0x82265164;  }
		/* 82265150h case    4:*/		return 0x82265154;
		  /* 82265154h */ case    5:  		/* lwz R10, <#[R11 + 8]> */
		/* 82265154h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 82265154h case    5:*/		return 0x82265158;
		  /* 82265158h */ case    6:  		/* rlwinm R11, R3, 2, 0, 29 */
		/* 82265158h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R3);
		/* 82265158h case    6:*/		return 0x8226515C;
		  /* 8226515Ch */ case    7:  		/* add R3, R10, R11 */
		/* 8226515Ch case    7:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 8226515Ch case    7:*/		return 0x82265160;
		  /* 82265160h */ case    8:  		/* b 16 */
		/* 82265160h case    8:*/		return 0x82265170;
		/* 82265160h case    8:*/		return 0x82265164;
	}
	return 0x82265164;
} // Block from 82265140h-82265164h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82265164h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265164( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265164) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265164);
		  /* 82265164h */ case    0:  		/* mr R4, R30 */
		/* 82265164h case    0:*/		regs.R4 = regs.R30;
		/* 82265164h case    0:*/		return 0x82265168;
		  /* 82265168h */ case    1:  		/* mr R3, R11 */
		/* 82265168h case    1:*/		regs.R3 = regs.R11;
		/* 82265168h case    1:*/		return 0x8226516C;
		  /* 8226516Ch */ case    2:  		/* bl -71340 */
		/* 8226516Ch case    2:*/		regs.LR = 0x82265170; return 0x82253AC0;
		/* 8226516Ch case    2:*/		return 0x82265170;
	}
	return 0x82265170;
} // Block from 82265164h-82265170h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82265170h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265170( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265170) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265170);
		  /* 82265170h */ case    0:  		/* lwz R9, <#[R3]> */
		/* 82265170h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 82265170h case    0:*/		return 0x82265174;
		  /* 82265174h */ case    1:  		/* li R10, -1 */
		/* 82265174h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFF);
		/* 82265174h case    1:*/		return 0x82265178;
		  /* 82265178h */ case    2:  		/* mr R6, R18 */
		/* 82265178h case    2:*/		regs.R6 = regs.R18;
		/* 82265178h case    2:*/		return 0x8226517C;
		  /* 8226517Ch */ case    3:  		/* lwz R11, <#[R9 + 4]> */
		/* 8226517Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 8226517Ch case    3:*/		return 0x82265180;
		  /* 82265180h */ case    4:  		/* lwz R7, <#[R9 + 8]> */
		/* 82265180h case    4:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + 0x00000008) );
		/* 82265180h case    4:*/		return 0x82265184;
		  /* 82265184h */ case    5:  		/* cmpwi CR6, R11, 0 */
		/* 82265184h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82265184h case    5:*/		return 0x82265188;
		  /* 82265188h */ case    6:  		/* bc 4, CR6_GT, 100 */
		/* 82265188h case    6:*/		if ( !regs.CR[6].gt ) { return 0x822651EC;  }
		/* 82265188h case    6:*/		return 0x8226518C;
		  /* 8226518Ch */ case    7:  		/* addi R10, R10, 1 */
		/* 8226518Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 8226518Ch case    7:*/		return 0x82265190;
		  /* 82265190h */ case    8:  		/* cmpwi CR6, R10, 7 */
		/* 82265190h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000007);
		/* 82265190h case    8:*/		return 0x82265194;
		  /* 82265194h */ case    9:  		/* bc 4, CR6_EQ, 12 */
		/* 82265194h case    9:*/		if ( !regs.CR[6].eq ) { return 0x822651A0;  }
		/* 82265194h case    9:*/		return 0x82265198;
		  /* 82265198h */ case   10:  		/* lwz R7, <#[R7 + 28]> */
		/* 82265198h case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x0000001C) );
		/* 82265198h case   10:*/		return 0x8226519C;
		  /* 8226519Ch */ case   11:  		/* mr R10, R18 */
		/* 8226519Ch case   11:*/		regs.R10 = regs.R18;
		/* 8226519Ch case   11:*/		return 0x822651A0;
	}
	return 0x822651A0;
} // Block from 82265170h-822651A0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 822651A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822651A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822651A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822651A0);
		  /* 822651A0h */ case    0:  		/* rlwinm R11, R10, 2, 0, 29 */
		/* 822651A0h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 822651A0h case    0:*/		return 0x822651A4;
		  /* 822651A4h */ case    1:  		/* lwz R8, <#[R17 - 25560]> */
		/* 822651A4h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R17 + 0xFFFF9C28) );
		/* 822651A4h case    1:*/		return 0x822651A8;
		  /* 822651A8h */ case    2:  		/* lwzx R11, <#[R11 + R7]> */
		/* 822651A8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 822651A8h case    2:*/		return 0x822651AC;
		  /* 822651ACh */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 822651ACh case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 822651ACh case    3:*/		return 0x822651B0;
		  /* 822651B0h */ case    4:  		/* lwzx R11, <#[R11 + R8]> */
		/* 822651B0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 822651B0h case    4:*/		return 0x822651B4;
		  /* 822651B4h */ case    5:  		/* cmpwi CR6, R11, 0 */
		/* 822651B4h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 822651B4h case    5:*/		return 0x822651B8;
		  /* 822651B8h */ case    6:  		/* bc 12, CR6_LT, 36 */
		/* 822651B8h case    6:*/		if ( regs.CR[6].lt ) { return 0x822651DC;  }
		/* 822651B8h case    6:*/		return 0x822651BC;
		  /* 822651BCh */ case    7:  		/* rlwinm R8, R11, 27, 5, 31 */
		/* 822651BCh case    7:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R8,regs.R11);
		/* 822651BCh case    7:*/		return 0x822651C0;
		  /* 822651C0h */ case    8:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 822651C0h case    8:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 822651C0h case    8:*/		return 0x822651C4;
		  /* 822651C4h */ case    9:  		/* addi R8, R8, 2 */
		/* 822651C4h case    9:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x2);
		/* 822651C4h case    9:*/		return 0x822651C8;
	}
	return 0x822651C8;
} // Block from 822651A0h-822651C8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 822651C8h
// Function '?AddNode@Interference@XGRAPHICS@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822651C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822651C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822651C8);
		  /* 822651C8h */ case    0:  		/* slw R5, R15, R11 */
		/* 822651C8h case    0:*/		cpu::op::slw<0>(regs,&regs.R5,regs.R15,regs.R11);
		/* 822651C8h case    0:*/		return 0x822651CC;
		  /* 822651CCh */ case    1:  		/* rlwinm R11, R8, 2, 0, 29 */
		/* 822651CCh case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R8);
		/* 822651CCh case    1:*/		return 0x822651D0;
		  /* 822651D0h */ case    2:  		/* lwzx R8, <#[R11 + R26]> */
		/* 822651D0h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R26 + 0x00000000) );
		/* 822651D0h case    2:*/		return 0x822651D4;
		  /* 822651D4h */ case    3:  		/* or R8, R5, R8 */
		/* 822651D4h case    3:*/		cpu::op::or<0>(regs,&regs.R8,regs.R5,regs.R8);
		/* 822651D4h case    3:*/		return 0x822651D8;
		  /* 822651D8h */ case    4:  		/* stwx R8, <#[R11 + R26]> */
		/* 822651D8h case    4:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + regs.R26 + 0x00000000) );
		/* 822651D8h case    4:*/		return 0x822651DC;
	}
	return 0x822651DC;
} // Block from 822651C8h-822651DCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 822651DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822651DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822651DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822651DC);
		  /* 822651DCh */ case    0:  		/* lwz R11, <#[R9 + 4]> */
		/* 822651DCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 822651DCh case    0:*/		return 0x822651E0;
		  /* 822651E0h */ case    1:  		/* addi R6, R6, 1 */
		/* 822651E0h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 822651E0h case    1:*/		return 0x822651E4;
		  /* 822651E4h */ case    2:  		/* cmpw CR6, R6, R11 */
		/* 822651E4h case    2:*/		cpu::op::cmpw<6>(regs,regs.R6,regs.R11);
		/* 822651E4h case    2:*/		return 0x822651E8;
		  /* 822651E8h */ case    3:  		/* bc 12, CR6_LT, -92 */
		/* 822651E8h case    3:*/		if ( regs.CR[6].lt ) { return 0x8226518C;  }
		/* 822651E8h case    3:*/		return 0x822651EC;
	}
	return 0x822651EC;
} // Block from 822651DCh-822651ECh (4 instructions)

//////////////////////////////////////////////////////
// Block at 822651ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822651EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822651EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822651EC);
		  /* 822651ECh */ case    0:  		/* lwz R3, <#[R25 + 4]> */
		/* 822651ECh case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R25 + 0x00000004) );
		/* 822651ECh case    0:*/		return 0x822651F0;
		  /* 822651F0h */ case    1:  		/* mr R27, R18 */
		/* 822651F0h case    1:*/		regs.R27 = regs.R18;
		/* 822651F0h case    1:*/		return 0x822651F4;
		  /* 822651F4h */ case    2:  		/* lwz R11, <#[R3 + 4]> */
		/* 822651F4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 822651F4h case    2:*/		return 0x822651F8;
		  /* 822651F8h */ case    3:  		/* cmplw CR6, R30, R11 */
		/* 822651F8h case    3:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 822651F8h case    3:*/		return 0x822651FC;
		  /* 822651FCh */ case    4:  		/* bc 4, CR6_LT, 20 */
		/* 822651FCh case    4:*/		if ( !regs.CR[6].lt ) { return 0x82265210;  }
		/* 822651FCh case    4:*/		return 0x82265200;
		  /* 82265200h */ case    5:  		/* lwz R10, <#[R3 + 8]> */
		/* 82265200h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 82265200h case    5:*/		return 0x82265204;
		  /* 82265204h */ case    6:  		/* rlwinm R11, R30, 2, 0, 29 */
		/* 82265204h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R30);
		/* 82265204h case    6:*/		return 0x82265208;
		  /* 82265208h */ case    7:  		/* add R3, R10, R11 */
		/* 82265208h case    7:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 82265208h case    7:*/		return 0x8226520C;
		  /* 8226520Ch */ case    8:  		/* b 12 */
		/* 8226520Ch case    8:*/		return 0x82265218;
		/* 8226520Ch case    8:*/		return 0x82265210;
	}
	return 0x82265210;
} // Block from 822651ECh-82265210h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82265210h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265210( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265210) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265210);
		  /* 82265210h */ case    0:  		/* mr R4, R30 */
		/* 82265210h case    0:*/		regs.R4 = regs.R30;
		/* 82265210h case    0:*/		return 0x82265214;
		  /* 82265214h */ case    1:  		/* bl -71508 */
		/* 82265214h case    1:*/		regs.LR = 0x82265218; return 0x82253AC0;
		/* 82265214h case    1:*/		return 0x82265218;
	}
	return 0x82265218;
} // Block from 82265210h-82265218h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82265218h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265218( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265218) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265218);
		  /* 82265218h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82265218h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82265218h case    0:*/		return 0x8226521C;
		  /* 8226521Ch */ case    1:  		/* mr R31, R18 */
		/* 8226521Ch case    1:*/		regs.R31 = regs.R18;
		/* 8226521Ch case    1:*/		return 0x82265220;
		  /* 82265220h */ case    2:  		/* lwz R11, <#[R11 + 16]> */
		/* 82265220h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 82265220h case    2:*/		return 0x82265224;
		  /* 82265224h */ case    3:  		/* lwz R28, <#[R11 + 4]> */
		/* 82265224h case    3:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R11 + 0x00000004) );
		/* 82265224h case    3:*/		return 0x82265228;
		  /* 82265228h */ case    4:  		/* cmpwi CR6, R28, 0 */
		/* 82265228h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 82265228h case    4:*/		return 0x8226522C;
		  /* 8226522Ch */ case    5:  		/* bc 4, CR6_GT, 180 */
		/* 8226522Ch case    5:*/		if ( !regs.CR[6].gt ) { return 0x822652E0;  }
		/* 8226522Ch case    5:*/		return 0x82265230;
		  /* 82265230h */ case    6:  		/* mr R29, R18 */
		/* 82265230h case    6:*/		regs.R29 = regs.R18;
		/* 82265230h case    6:*/		return 0x82265234;
		  /* 82265234h */ case    7:  		/* lwz R3, <#[R25 + 4]> */
		/* 82265234h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R25 + 0x00000004) );
		/* 82265234h case    7:*/		return 0x82265238;
		  /* 82265238h */ case    8:  		/* lwz R11, <#[R3 + 4]> */
		/* 82265238h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82265238h case    8:*/		return 0x8226523C;
		  /* 8226523Ch */ case    9:  		/* cmplw CR6, R30, R11 */
		/* 8226523Ch case    9:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 8226523Ch case    9:*/		return 0x82265240;
		  /* 82265240h */ case   10:  		/* bc 4, CR6_LT, 20 */
		/* 82265240h case   10:*/		if ( !regs.CR[6].lt ) { return 0x82265254;  }
		/* 82265240h case   10:*/		return 0x82265244;
		  /* 82265244h */ case   11:  		/* lwz R10, <#[R3 + 8]> */
		/* 82265244h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 82265244h case   11:*/		return 0x82265248;
		  /* 82265248h */ case   12:  		/* rlwinm R11, R30, 2, 0, 29 */
		/* 82265248h case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R30);
		/* 82265248h case   12:*/		return 0x8226524C;
		  /* 8226524Ch */ case   13:  		/* add R3, R10, R11 */
		/* 8226524Ch case   13:*/		cpu::op::add<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 8226524Ch case   13:*/		return 0x82265250;
		  /* 82265250h */ case   14:  		/* b 12 */
		/* 82265250h case   14:*/		return 0x8226525C;
		/* 82265250h case   14:*/		return 0x82265254;
	}
	return 0x82265254;
} // Block from 82265218h-82265254h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82265254h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265254( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265254) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265254);
		  /* 82265254h */ case    0:  		/* mr R4, R30 */
		/* 82265254h case    0:*/		regs.R4 = regs.R30;
		/* 82265254h case    0:*/		return 0x82265258;
		  /* 82265258h */ case    1:  		/* bl -71576 */
		/* 82265258h case    1:*/		regs.LR = 0x8226525C; return 0x82253AC0;
		/* 82265258h case    1:*/		return 0x8226525C;
	}
	return 0x8226525C;
} // Block from 82265254h-8226525Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226525Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226525C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226525C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226525C);
		  /* 8226525Ch */ case    0:  		/* lwz R11, <#[R3]> */
		/* 8226525Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8226525Ch case    0:*/		return 0x82265260;
		  /* 82265260h */ case    1:  		/* lwz R3, <#[R11 + 16]> */
		/* 82265260h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00000010) );
		/* 82265260h case    1:*/		return 0x82265264;
		  /* 82265264h */ case    2:  		/* lwz R11, <#[R3 + 4]> */
		/* 82265264h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82265264h case    2:*/		return 0x82265268;
		  /* 82265268h */ case    3:  		/* cmplw CR6, R31, R11 */
		/* 82265268h case    3:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82265268h case    3:*/		return 0x8226526C;
		  /* 8226526Ch */ case    4:  		/* bc 4, CR6_LT, 16 */
		/* 8226526Ch case    4:*/		if ( !regs.CR[6].lt ) { return 0x8226527C;  }
		/* 8226526Ch case    4:*/		return 0x82265270;
		  /* 82265270h */ case    5:  		/* lwz R11, <#[R3 + 8]> */
		/* 82265270h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82265270h case    5:*/		return 0x82265274;
		  /* 82265274h */ case    6:  		/* add R3, R11, R29 */
		/* 82265274h case    6:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R29);
		/* 82265274h case    6:*/		return 0x82265278;
		  /* 82265278h */ case    7:  		/* b 12 */
		/* 82265278h case    7:*/		return 0x82265284;
		/* 82265278h case    7:*/		return 0x8226527C;
	}
	return 0x8226527C;
} // Block from 8226525Ch-8226527Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8226527Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226527C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226527C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226527C);
		  /* 8226527Ch */ case    0:  		/* mr R4, R31 */
		/* 8226527Ch case    0:*/		regs.R4 = regs.R31;
		/* 8226527Ch case    0:*/		return 0x82265280;
		  /* 82265280h */ case    1:  		/* bl -71616 */
		/* 82265280h case    1:*/		regs.LR = 0x82265284; return 0x82253AC0;
		/* 82265280h case    1:*/		return 0x82265284;
	}
	return 0x82265284;
} // Block from 8226527Ch-82265284h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82265284h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265284( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265284) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265284);
		  /* 82265284h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82265284h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82265284h case    0:*/		return 0x82265288;
		  /* 82265288h */ case    1:  		/* lwz R10, <#[R17 - 25560]> */
		/* 82265288h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R17 + 0xFFFF9C28) );
		/* 82265288h case    1:*/		return 0x8226528C;
		  /* 8226528Ch */ case    2:  		/* lwz R11, <#[R11]> */
		/* 8226528Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 8226528Ch case    2:*/		return 0x82265290;
		  /* 82265290h */ case    3:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82265290h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82265290h case    3:*/		return 0x82265294;
		  /* 82265294h */ case    4:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82265294h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82265294h case    4:*/		return 0x82265298;
		  /* 82265298h */ case    5:  		/* cmpwi CR6, R11, 0 */
		/* 82265298h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82265298h case    5:*/		return 0x8226529C;
		  /* 8226529Ch */ case    6:  		/* bc 12, CR6_LT, 36 */
		/* 8226529Ch case    6:*/		if ( regs.CR[6].lt ) { return 0x822652C0;  }
		/* 8226529Ch case    6:*/		return 0x822652A0;
		  /* 822652A0h */ case    7:  		/* rlwinm R10, R11, 27, 5, 31 */
		/* 822652A0h case    7:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R11);
		/* 822652A0h case    7:*/		return 0x822652A4;
		  /* 822652A4h */ case    8:  		/* rlwinm R9, R11, 0, 27, 31 */
		/* 822652A4h case    8:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R11);
		/* 822652A4h case    8:*/		return 0x822652A8;
		  /* 822652A8h */ case    9:  		/* addi R10, R10, 2 */
		/* 822652A8h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 822652A8h case    9:*/		return 0x822652AC;
		  /* 822652ACh */ case   10:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 822652ACh case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 822652ACh case   10:*/		return 0x822652B0;
		  /* 822652B0h */ case   11:  		/* lwzx R10, <#[R10 + R26]> */
		/* 822652B0h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R26 + 0x00000000) );
		/* 822652B0h case   11:*/		return 0x822652B4;
		  /* 822652B4h */ case   12:  		/* srw R10, R10, R9 */
		/* 822652B4h case   12:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 822652B4h case   12:*/		return 0x822652B8;
		  /* 822652B8h */ case   13:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 822652B8h case   13:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 822652B8h case   13:*/		return 0x822652BC;
		  /* 822652BCh */ case   14:  		/* bc 12, CR0_EQ, 24 */
		/* 822652BCh case   14:*/		if ( regs.CR[0].eq ) { return 0x822652D4;  }
		/* 822652BCh case   14:*/		return 0x822652C0;
	}
	return 0x822652C0;
} // Block from 82265284h-822652C0h (15 instructions)

//////////////////////////////////////////////////////
// Block at 822652C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822652C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822652C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822652C0);
		  /* 822652C0h */ case    0:  		/* addi R31, R31, 1 */
		/* 822652C0h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 822652C0h case    0:*/		return 0x822652C4;
		  /* 822652C4h */ case    1:  		/* addi R29, R29, 4 */
		/* 822652C4h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 822652C4h case    1:*/		return 0x822652C8;
		  /* 822652C8h */ case    2:  		/* cmpw CR6, R31, R28 */
		/* 822652C8h case    2:*/		cpu::op::cmpw<6>(regs,regs.R31,regs.R28);
		/* 822652C8h case    2:*/		return 0x822652CC;
		  /* 822652CCh */ case    3:  		/* bc 12, CR6_LT, -152 */
		/* 822652CCh case    3:*/		if ( regs.CR[6].lt ) { return 0x82265234;  }
		/* 822652CCh case    3:*/		return 0x822652D0;
		  /* 822652D0h */ case    4:  		/* b 16 */
		/* 822652D0h case    4:*/		return 0x822652E0;
		/* 822652D0h case    4:*/		return 0x822652D4;
	}
	return 0x822652D4;
} // Block from 822652C0h-822652D4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822652D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822652D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822652D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822652D4);
		  /* 822652D4h */ case    0:  		/* mr R24, R11 */
		/* 822652D4h case    0:*/		regs.R24 = regs.R11;
		/* 822652D4h case    0:*/		return 0x822652D8;
		  /* 822652D8h */ case    1:  		/* mr R27, R15 */
		/* 822652D8h case    1:*/		regs.R27 = regs.R15;
		/* 822652D8h case    1:*/		return 0x822652DC;
		  /* 822652DCh */ case    2:  		/* addi R22, R22, 1 */
		/* 822652DCh case    2:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R22,0x1);
		/* 822652DCh case    2:*/		return 0x822652E0;
	}
	return 0x822652E0;
} // Block from 822652D4h-822652E0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822652E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822652E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822652E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822652E0);
		  /* 822652E0h */ case    0:  		/* rlwinm. R11, R27, 0, 24, 31 */
		/* 822652E0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R27);
		/* 822652E0h case    0:*/		return 0x822652E4;
		  /* 822652E4h */ case    1:  		/* bc 4, CR0_EQ, 24 */
		/* 822652E4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x822652FC;  }
		/* 822652E4h case    1:*/		return 0x822652E8;
		  /* 822652E8h */ case    2:  		/* mr R3, R26 */
		/* 822652E8h case    2:*/		regs.R3 = regs.R26;
		/* 822652E8h case    2:*/		return 0x822652EC;
		  /* 822652ECh */ case    3:  		/* bl -107876 */
		/* 822652ECh case    3:*/		regs.LR = 0x822652F0; return 0x8224AD88;
		/* 822652ECh case    3:*/		return 0x822652F0;
		  /* 822652F0h */ case    4:  		/* mr R24, R3 */
		/* 822652F0h case    4:*/		regs.R24 = regs.R3;
		/* 822652F0h case    4:*/		return 0x822652F4;
		  /* 822652F4h */ case    5:  		/* cmpwi CR6, R3, -1 */
		/* 822652F4h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 822652F4h case    5:*/		return 0x822652F8;
		  /* 822652F8h */ case    6:  		/* bc 12, CR6_EQ, 220 */
		/* 822652F8h case    6:*/		if ( regs.CR[6].eq ) { return 0x822653D4;  }
		/* 822652F8h case    6:*/		return 0x822652FC;
	}
	return 0x822652FC;
} // Block from 822652E0h-822652FCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 822652FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822652FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822652FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822652FC);
		  /* 822652FCh */ case    0:  		/* lwz R11, <#[R17 - 25560]> */
		/* 822652FCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0xFFFF9C28) );
		/* 822652FCh case    0:*/		return 0x82265300;
		  /* 82265300h */ case    1:  		/* rlwinm R10, R30, 2, 0, 29 */
		/* 82265300h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R30);
		/* 82265300h case    1:*/		return 0x82265304;
		  /* 82265304h */ case    2:  		/* mr R4, R24 */
		/* 82265304h case    2:*/		regs.R4 = regs.R24;
		/* 82265304h case    2:*/		return 0x82265308;
		  /* 82265308h */ case    3:  		/* mr R3, R23 */
		/* 82265308h case    3:*/		regs.R3 = regs.R23;
		/* 82265308h case    3:*/		return 0x8226530C;
		  /* 8226530Ch */ case    4:  		/* stwx R24, <#[R10 + R11]> */
		/* 8226530Ch case    4:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8226530Ch case    4:*/		return 0x82265310;
		  /* 82265310h */ case    5:  		/* bl -122208 */
		/* 82265310h case    5:*/		regs.LR = 0x82265314; return 0x822475B0;
		/* 82265310h case    5:*/		return 0x82265314;
		  /* 82265314h */ case    6:  		/* lwz R11, <#[R19 + 4]> */
		/* 82265314h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000004) );
		/* 82265314h case    6:*/		return 0x82265318;
		  /* 82265318h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 82265318h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82265318h case    7:*/		return 0x8226531C;
		  /* 8226531Ch */ case    8:  		/* bc 4, CR6_EQ, -600 */
		/* 8226531Ch case    8:*/		if ( !regs.CR[6].eq ) { return 0x822650C4;  }
		/* 8226531Ch case    8:*/		return 0x82265320;
	}
	return 0x82265320;
} // Block from 822652FCh-82265320h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82265320h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265320( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265320) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265320);
		  /* 82265320h */ case    0:  		/* cmplwi CR6, R26, 0 */
		/* 82265320h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 82265320h case    0:*/		return 0x82265324;
		  /* 82265324h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 82265324h case    1:*/		if ( regs.CR[6].eq ) { return 0x82265334;  }
		/* 82265324h case    1:*/		return 0x82265328;
		  /* 82265328h */ case    2:  		/* addi R4, R26, -4 */
		/* 82265328h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R26,0xFFFFFFFC);
		/* 82265328h case    2:*/		return 0x8226532C;
		  /* 8226532Ch */ case    3:  		/* lwz R3, <#[R26 - 4]> */
		/* 8226532Ch case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R26 + 0xFFFFFFFC) );
		/* 8226532Ch case    3:*/		return 0x82265330;
		  /* 82265330h */ case    4:  		/* bl -298224 */
		/* 82265330h case    4:*/		regs.LR = 0x82265334; return 0x8221C640;
		/* 82265330h case    4:*/		return 0x82265334;
	}
	return 0x82265334;
} // Block from 82265320h-82265334h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82265334h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265334( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265334) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265334);
		  /* 82265334h */ case    0:  		/* mr R3, R23 */
		/* 82265334h case    0:*/		regs.R3 = regs.R23;
		/* 82265334h case    0:*/		return 0x82265338;
	}
	return 0x82265338;
} // Block from 82265334h-82265338h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82265338h
// Function '?AddEdge@Interference@XGRAPHICS@@QAAXHH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265338( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265338) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265338);
		  /* 82265338h */ case    0:  		/* bl -121912 */
		/* 82265338h case    0:*/		regs.LR = 0x8226533C; return 0x82247700;
		/* 82265338h case    0:*/		return 0x8226533C;
		  /* 8226533Ch */ case    1:  		/* lis R11, -32251 */
		/* 8226533Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8226533Ch case    1:*/		return 0x82265340;
		  /* 82265340h */ case    2:  		/* lwz R10, <#[R25 + 12]> */
		/* 82265340h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x0000000C) );
		/* 82265340h case    2:*/		return 0x82265344;
		  /* 82265344h */ case    3:  		/* addi R4, R11, -18216 */
		/* 82265344h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFB8D8);
		/* 82265344h case    3:*/		return 0x82265348;
		  /* 82265348h */ case    4:  		/* lwz R3, <#[R25 + 8]> */
		/* 82265348h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R25 + 0x00000008) );
		/* 82265348h case    4:*/		return 0x8226534C;
		  /* 8226534Ch */ case    5:  		/* lwz R11, <#[R23 + 2080]> */
		/* 8226534Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000820) );
		/* 8226534Ch case    5:*/		return 0x82265350;
		  /* 82265350h */ case    6:  		/* subf R11, R10, R11 */
		/* 82265350h case    6:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82265350h case    6:*/		return 0x82265354;
		  /* 82265354h */ case    7:  		/* addi R5, R11, 1 */
		/* 82265354h case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x1);
		/* 82265354h case    7:*/		return 0x82265358;
		  /* 82265358h */ case    8:  		/* bl -294808 */
		/* 82265358h case    8:*/		regs.LR = 0x8226535C; return 0x8221D3C0;
		/* 82265358h case    8:*/		return 0x8226535C;
		  /* 8226535Ch */ case    9:  		/* cmpwi CR6, R22, 0 */
		/* 8226535Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R22,0x00000000);
		/* 8226535Ch case    9:*/		return 0x82265360;
		  /* 82265360h */ case   10:  		/* bc 4, CR6_GT, 24 */
		/* 82265360h case   10:*/		if ( !regs.CR[6].gt ) { return 0x82265378;  }
		/* 82265360h case   10:*/		return 0x82265364;
		  /* 82265364h */ case   11:  		/* lis R11, -32251 */
		/* 82265364h case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82265364h case   11:*/		return 0x82265368;
		  /* 82265368h */ case   12:  		/* lwz R3, <#[R25 + 8]> */
		/* 82265368h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R25 + 0x00000008) );
		/* 82265368h case   12:*/		return 0x8226536C;
		  /* 8226536Ch */ case   13:  		/* mr R5, R22 */
		/* 8226536Ch case   13:*/		regs.R5 = regs.R22;
		/* 8226536Ch case   13:*/		return 0x82265370;
		  /* 82265370h */ case   14:  		/* addi R4, R11, -18284 */
		/* 82265370h case   14:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFB894);
		/* 82265370h case   14:*/		return 0x82265374;
		  /* 82265374h */ case   15:  		/* bl -294836 */
		/* 82265374h case   15:*/		regs.LR = 0x82265378; return 0x8221D3C0;
		/* 82265374h case   15:*/		return 0x82265378;
	}
	return 0x82265378;
} // Block from 82265338h-82265378h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82265378h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265378( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265378) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265378);
		  /* 82265378h */ case    0:  		/* lis R11, -32251 */
		/* 82265378h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82265378h case    0:*/		return 0x8226537C;
		  /* 8226537Ch */ case    1:  		/* lwz R3, <#[R25 + 8]> */
		/* 8226537Ch case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R25 + 0x00000008) );
		/* 8226537Ch case    1:*/		return 0x82265380;
		  /* 82265380h */ case    2:  		/* mr R5, R20 */
		/* 82265380h case    2:*/		regs.R5 = regs.R20;
		/* 82265380h case    2:*/		return 0x82265384;
		  /* 82265384h */ case    3:  		/* addi R4, R11, -18352 */
		/* 82265384h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFB850);
		/* 82265384h case    3:*/		return 0x82265388;
		  /* 82265388h */ case    4:  		/* bl -294856 */
		/* 82265388h case    4:*/		regs.LR = 0x8226538C; return 0x8221D3C0;
		/* 82265388h case    4:*/		return 0x8226538C;
		  /* 8226538Ch */ case    5:  		/* lwz R10, <#[R25 + 12]> */
		/* 8226538Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x0000000C) );
		/* 8226538Ch case    5:*/		return 0x82265390;
		  /* 82265390h */ case    6:  		/* lwz R11, <#[R25 + 16]> */
		/* 82265390h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000010) );
		/* 82265390h case    6:*/		return 0x82265394;
		  /* 82265394h */ case    7:  		/* cmpw CR6, R10, R11 */
		/* 82265394h case    7:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R11);
		/* 82265394h case    7:*/		return 0x82265398;
		  /* 82265398h */ case    8:  		/* bc 4, CR6_LT, 52 */
		/* 82265398h case    8:*/		if ( !regs.CR[6].lt ) { return 0x822653CC;  }
		/* 82265398h case    8:*/		return 0x8226539C;
		  /* 8226539Ch */ case    9:  		/* rlwinm R11, R10, 2, 0, 29 */
		/* 8226539Ch case    9:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 8226539Ch case    9:*/		return 0x822653A0;
		  /* 822653A0h */ case   10:  		/* lwz R8, <#[R16 - 25556]> */
		/* 822653A0h case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R16 + 0xFFFF9C2C) );
		/* 822653A0h case   10:*/		return 0x822653A4;
		  /* 822653A4h */ case   11:  		/* addi R10, R10, 1 */
		/* 822653A4h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 822653A4h case   11:*/		return 0x822653A8;
		  /* 822653A8h */ case   12:  		/* lwz R9, <#[R17 - 25560]> */
		/* 822653A8h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R17 + 0xFFFF9C28) );
		/* 822653A8h case   12:*/		return 0x822653AC;
		  /* 822653ACh */ case   13:  		/* lwzx R8, <#[R11 + R8]> */
		/* 822653ACh case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 822653ACh case   13:*/		return 0x822653B0;
		  /* 822653B0h */ case   14:  		/* rlwinm R8, R8, 2, 0, 29 */
		/* 822653B0h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R8);
		/* 822653B0h case   14:*/		return 0x822653B4;
		  /* 822653B4h */ case   15:  		/* lwzx R8, <#[R8 + R9]> */
		/* 822653B4h case   15:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R9 + 0x00000000) );
		/* 822653B4h case   15:*/		return 0x822653B8;
		  /* 822653B8h */ case   16:  		/* stwx R8, <#[R11 + R9]> */
		/* 822653B8h case   16:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 822653B8h case   16:*/		return 0x822653BC;
		  /* 822653BCh */ case   17:  		/* addi R11, R11, 4 */
		/* 822653BCh case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 822653BCh case   17:*/		return 0x822653C0;
		  /* 822653C0h */ case   18:  		/* lwz R9, <#[R25 + 16]> */
		/* 822653C0h case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + 0x00000010) );
		/* 822653C0h case   18:*/		return 0x822653C4;
		  /* 822653C4h */ case   19:  		/* cmpw CR6, R10, R9 */
		/* 822653C4h case   19:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R9);
		/* 822653C4h case   19:*/		return 0x822653C8;
		  /* 822653C8h */ case   20:  		/* bc 12, CR6_LT, -40 */
		/* 822653C8h case   20:*/		if ( regs.CR[6].lt ) { return 0x822653A0;  }
		/* 822653C8h case   20:*/		return 0x822653CC;
	}
	return 0x822653CC;
} // Block from 82265378h-822653CCh (21 instructions)

//////////////////////////////////////////////////////
// Block at 822653CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822653CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822653CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822653CC);
		  /* 822653CCh */ case    0:  		/* addi R1, R1, 240 */
		/* 822653CCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xF0);
		/* 822653CCh case    0:*/		return 0x822653D0;
		  /* 822653D0h */ case    1:  		/* b -1917276 */
		/* 822653D0h case    1:*/		return 0x82091274;
		/* 822653D0h case    1:*/		return 0x822653D4;
	}
	return 0x822653D4;
} // Block from 822653CCh-822653D4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822653D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822653D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822653D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822653D4);
		  /* 822653D4h */ case    0:  		/* lwz R11, <#[R25 + 8]> */
		/* 822653D4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 822653D4h case    0:*/		return 0x822653D8;
		  /* 822653D8h */ case    1:  		/* li R10, 22 */
		/* 822653D8h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x16);
		/* 822653D8h case    1:*/		return 0x822653DC;
		  /* 822653DCh */ case    2:  		/* li R4, 1 */
		/* 822653DCh case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 822653DCh case    2:*/		return 0x822653E0;
		  /* 822653E0h */ case    3:  		/* addi R3, R11, 16 */
		/* 822653E0h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x10);
		/* 822653E0h case    3:*/		return 0x822653E4;
		  /* 822653E4h */ case    4:  		/* stw R10, <#[R11 + 1364]> */
		/* 822653E4h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000554) );
		/* 822653E4h case    4:*/		return 0x822653E8;
		  /* 822653E8h */ case    5:  		/* bl 15048 */
		/* 822653E8h case    5:*/		regs.LR = 0x822653EC; return 0x82268EB0;
		/* 822653E8h case    5:*/		return 0x822653EC;
		  /* 822653ECh */ case    6:  		/* nop */
		/* 822653ECh case    6:*/		cpu::op::nop();
		/* 822653ECh case    6:*/		return 0x822653F0;
	}
	return 0x822653F0;
} // Block from 822653D4h-822653F0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 822653F0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822653F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822653F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822653F0);
		  /* 822653F0h */ case    0:  		/* mfspr R12, LR */
		/* 822653F0h case    0:*/		regs.R12 = regs.LR;
		/* 822653F0h case    0:*/		return 0x822653F4;
		  /* 822653F4h */ case    1:  		/* bl -1917340 */
		/* 822653F4h case    1:*/		regs.LR = 0x822653F8; return 0x82091258;
		/* 822653F4h case    1:*/		return 0x822653F8;
		  /* 822653F8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 822653F8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 822653F8h case    2:*/		return 0x822653FC;
		  /* 822653FCh */ case    3:  		/* lwz R11, <#[R3 + 16]> */
		/* 822653FCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 822653FCh case    3:*/		return 0x82265400;
		  /* 82265400h */ case    4:  		/* mr R28, R3 */
		/* 82265400h case    4:*/		regs.R28 = regs.R3;
		/* 82265400h case    4:*/		return 0x82265404;
		  /* 82265404h */ case    5:  		/* li R30, 0 */
		/* 82265404h case    5:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82265404h case    5:*/		return 0x82265408;
		  /* 82265408h */ case    6:  		/* cmpwi CR6, R11, 0 */
		/* 82265408h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82265408h case    6:*/		return 0x8226540C;
		  /* 8226540Ch */ case    7:  		/* bc 4, CR6_GT, 96 */
		/* 8226540Ch case    7:*/		if ( !regs.CR[6].gt ) { return 0x8226546C;  }
		/* 8226540Ch case    7:*/		return 0x82265410;
		  /* 82265410h */ case    8:  		/* li R29, 0 */
		/* 82265410h case    8:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82265410h case    8:*/		return 0x82265414;
		  /* 82265414h */ case    9:  		/* lwz R3, <#[R28 + 4]> */
		/* 82265414h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000004) );
		/* 82265414h case    9:*/		return 0x82265418;
		  /* 82265418h */ case   10:  		/* lwz R11, <#[R3 + 4]> */
		/* 82265418h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82265418h case   10:*/		return 0x8226541C;
		  /* 8226541Ch */ case   11:  		/* cmplw CR6, R30, R11 */
		/* 8226541Ch case   11:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 8226541Ch case   11:*/		return 0x82265420;
		  /* 82265420h */ case   12:  		/* bc 4, CR6_LT, 16 */
		/* 82265420h case   12:*/		if ( !regs.CR[6].lt ) { return 0x82265430;  }
		/* 82265420h case   12:*/		return 0x82265424;
		  /* 82265424h */ case   13:  		/* lwz R11, <#[R3 + 8]> */
		/* 82265424h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82265424h case   13:*/		return 0x82265428;
		  /* 82265428h */ case   14:  		/* add R3, R11, R29 */
		/* 82265428h case   14:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R29);
		/* 82265428h case   14:*/		return 0x8226542C;
		  /* 8226542Ch */ case   15:  		/* b 12 */
		/* 8226542Ch case   15:*/		return 0x82265438;
		/* 8226542Ch case   15:*/		return 0x82265430;
	}
	return 0x82265430;
} // Block from 822653F0h-82265430h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82265430h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265430( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265430) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265430);
		  /* 82265430h */ case    0:  		/* mr R4, R30 */
		/* 82265430h case    0:*/		regs.R4 = regs.R30;
		/* 82265430h case    0:*/		return 0x82265434;
		  /* 82265434h */ case    1:  		/* bl -72052 */
		/* 82265434h case    1:*/		regs.LR = 0x82265438; return 0x82253AC0;
		/* 82265434h case    1:*/		return 0x82265438;
	}
	return 0x82265438;
} // Block from 82265430h-82265438h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82265438h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265438( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265438) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265438);
		  /* 82265438h */ case    0:  		/* lwz R31, <#[R3]> */
		/* 82265438h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x00000000) );
		/* 82265438h case    0:*/		return 0x8226543C;
		  /* 8226543Ch */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 8226543Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8226543Ch case    1:*/		return 0x82265440;
		  /* 82265440h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 82265440h case    2:*/		if ( regs.CR[6].eq ) { return 0x82265458;  }
		/* 82265440h case    2:*/		return 0x82265444;
		  /* 82265444h */ case    3:  		/* mr R3, R31 */
		/* 82265444h case    3:*/		regs.R3 = regs.R31;
		/* 82265444h case    3:*/		return 0x82265448;
		  /* 82265448h */ case    4:  		/* bl -1896 */
		/* 82265448h case    4:*/		regs.LR = 0x8226544C; return 0x82264CE0;
		/* 82265448h case    4:*/		return 0x8226544C;
		  /* 8226544Ch */ case    5:  		/* addi R4, R31, -4 */
		/* 8226544Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R31,0xFFFFFFFC);
		/* 8226544Ch case    5:*/		return 0x82265450;
		  /* 82265450h */ case    6:  		/* lwz R3, <#[R31 - 4]> */
		/* 82265450h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0xFFFFFFFC) );
		/* 82265450h case    6:*/		return 0x82265454;
		  /* 82265454h */ case    7:  		/* bl -298516 */
		/* 82265454h case    7:*/		regs.LR = 0x82265458; return 0x8221C640;
		/* 82265454h case    7:*/		return 0x82265458;
	}
	return 0x82265458;
} // Block from 82265438h-82265458h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82265458h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265458( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265458) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265458);
		  /* 82265458h */ case    0:  		/* lwz R11, <#[R28 + 16]> */
		/* 82265458h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 82265458h case    0:*/		return 0x8226545C;
		  /* 8226545Ch */ case    1:  		/* addi R30, R30, 1 */
		/* 8226545Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 8226545Ch case    1:*/		return 0x82265460;
		  /* 82265460h */ case    2:  		/* addi R29, R29, 4 */
		/* 82265460h case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 82265460h case    2:*/		return 0x82265464;
		  /* 82265464h */ case    3:  		/* cmpw CR6, R30, R11 */
		/* 82265464h case    3:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R11);
		/* 82265464h case    3:*/		return 0x82265468;
		  /* 82265468h */ case    4:  		/* bc 12, CR6_LT, -84 */
		/* 82265468h case    4:*/		if ( regs.CR[6].lt ) { return 0x82265414;  }
		/* 82265468h case    4:*/		return 0x8226546C;
	}
	return 0x8226546C;
} // Block from 82265458h-8226546Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8226546Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226546C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226546C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226546C);
		  /* 8226546Ch */ case    0:  		/* lwz R3, <#[R28 + 4]> */
		/* 8226546Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R28 + 0x00000004) );
		/* 8226546Ch case    0:*/		return 0x82265470;
		  /* 82265470h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 82265470h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82265470h case    1:*/		return 0x82265474;
		  /* 82265474h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 82265474h case    2:*/		if ( regs.CR[6].eq ) { return 0x82265480;  }
		/* 82265474h case    2:*/		return 0x82265478;
		  /* 82265478h */ case    3:  		/* li R4, 1 */
		/* 82265478h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 82265478h case    3:*/		return 0x8226547C;
		  /* 8226547Ch */ case    4:  		/* bl -153828 */
		/* 8226547Ch case    4:*/		regs.LR = 0x82265480; return 0x8223FB98;
		/* 8226547Ch case    4:*/		return 0x82265480;
	}
	return 0x82265480;
} // Block from 8226546Ch-82265480h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82265480h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265480( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265480) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265480);
		  /* 82265480h */ case    0:  		/* lwz R10, <#[R28 + 8]> */
		/* 82265480h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000008) );
		/* 82265480h case    0:*/		return 0x82265484;
		  /* 82265484h */ case    1:  		/* lis R11, -32215 */
		/* 82265484h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8229);
		/* 82265484h case    1:*/		return 0x82265488;
	}
	return 0x82265488;
} // Block from 82265480h-82265488h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82265488h
// Function '?ClearDegree@Interference@XGRAPHICS@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265488( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265488) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265488);
		  /* 82265488h */ case    0:  		/* lwz R4, <#[R11 - 25556]> */
		/* 82265488h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0xFFFF9C2C) );
		/* 82265488h case    0:*/		return 0x8226548C;
		  /* 8226548Ch */ case    1:  		/* lwz R3, <#[R10 + 1456]> */
		/* 8226548Ch case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + 0x000005B0) );
		/* 8226548Ch case    1:*/		return 0x82265490;
		  /* 82265490h */ case    2:  		/* bl -298576 */
		/* 82265490h case    2:*/		regs.LR = 0x82265494; return 0x8221C640;
		/* 82265490h case    2:*/		return 0x82265494;
		  /* 82265494h */ case    3:  		/* addi R1, R1, 128 */
		/* 82265494h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82265494h case    3:*/		return 0x82265498;
		  /* 82265498h */ case    4:  		/* b -1917424 */
		/* 82265498h case    4:*/		return 0x820912A8;
		/* 82265498h case    4:*/		return 0x8226549C;
		  /* 8226549Ch */ case    5:  		/* nop */
		/* 8226549Ch case    5:*/		cpu::op::nop();
		/* 8226549Ch case    5:*/		return 0x822654A0;
		  /* 822654A0h */ case    6:  		/* lwz R11, <#[R3 + 20]> */
		/* 822654A0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 822654A0h case    6:*/		return 0x822654A4;
		  /* 822654A4h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 822654A4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822654A4h case    7:*/		return 0x822654A8;
		  /* 822654A8h */ case    8:  		/* bc 12, CR6_EQ, 84 */
		/* 822654A8h case    8:*/		if ( regs.CR[6].eq ) { return 0x822654FC;  }
		/* 822654A8h case    8:*/		return 0x822654AC;
		  /* 822654ACh */ case    9:  		/* mr R3, R11 */
		/* 822654ACh case    9:*/		regs.R3 = regs.R11;
		/* 822654ACh case    9:*/		return 0x822654B0;
		  /* 822654B0h */ case   10:  		/* lwz R11, <#[R3]> */
		/* 822654B0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822654B0h case   10:*/		return 0x822654B4;
		  /* 822654B4h */ case   11:  		/* li R10, 0 */
		/* 822654B4h case   11:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 822654B4h case   11:*/		return 0x822654B8;
		  /* 822654B8h */ case   12:  		/* mulli R11, R11, 12 */
		/* 822654B8h case   12:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 822654B8h case   12:*/		return 0x822654BC;
		  /* 822654BCh */ case   13:  		/* add R11, R11, R5 */
		/* 822654BCh case   13:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R5);
		/* 822654BCh case   13:*/		return 0x822654C0;
		  /* 822654C0h */ case   14:  		/* subf R9, R11, R4 */
		/* 822654C0h case   14:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R11,regs.R4);
		/* 822654C0h case   14:*/		return 0x822654C4;
		  /* 822654C4h */ case   15:  		/* lbzx R8, <#[R9 + R11]> */
		/* 822654C4h case   15:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 822654C4h case   15:*/		return 0x822654C8;
		  /* 822654C8h */ case   16:  		/* lbz R7, <#[R11]> */
		/* 822654C8h case   16:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 822654C8h case   16:*/		return 0x822654CC;
		  /* 822654CCh */ case   17:  		/* cmplw CR6, R7, R8 */
		/* 822654CCh case   17:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R8);
		/* 822654CCh case   17:*/		return 0x822654D0;
		  /* 822654D0h */ case   18:  		/* bc 4, CR6_EQ, 52 */
		/* 822654D0h case   18:*/		if ( !regs.CR[6].eq ) { return 0x82265504;  }
		/* 822654D0h case   18:*/		return 0x822654D4;
		  /* 822654D4h */ case   19:  		/* addi R10, R10, 1 */
		/* 822654D4h case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 822654D4h case   19:*/		return 0x822654D8;
		  /* 822654D8h */ case   20:  		/* addi R11, R11, 1 */
		/* 822654D8h case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 822654D8h case   20:*/		return 0x822654DC;
		  /* 822654DCh */ case   21:  		/* cmpwi CR6, R10, 12 */
		/* 822654DCh case   21:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000000C);
		/* 822654DCh case   21:*/		return 0x822654E0;
		  /* 822654E0h */ case   22:  		/* bc 12, CR6_LT, -28 */
		/* 822654E0h case   22:*/		if ( regs.CR[6].lt ) { return 0x822654C4;  }
		/* 822654E0h case   22:*/		return 0x822654E4;
		  /* 822654E4h */ case   23:  		/* li R11, 1 */
		/* 822654E4h case   23:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 822654E4h case   23:*/		return 0x822654E8;
		  /* 822654E8h */ case   24:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 822654E8h case   24:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 822654E8h case   24:*/		return 0x822654EC;
		  /* 822654ECh */ case   25:  		/* bclr 4, CR0_EQ */
		/* 822654ECh case   25:*/		if ( !regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 822654ECh case   25:*/		return 0x822654F0;
	}
	return 0x822654F0;
} // Block from 82265488h-822654F0h (26 instructions)

//////////////////////////////////////////////////////
// Block at 822654F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822654F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822654F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822654F0);
		  /* 822654F0h */ case    0:  		/* lwz R3, <#[R3 + 16]> */
		/* 822654F0h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000010) );
		/* 822654F0h case    0:*/		return 0x822654F4;
		  /* 822654F4h */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 822654F4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 822654F4h case    1:*/		return 0x822654F8;
	}
	return 0x822654F8;
} // Block from 822654F0h-822654F8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822654F8h
// Function '?Coalesce@Interference@XGRAPHICS@@QAA_NHH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822654F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822654F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822654F8);
		  /* 822654F8h */ case    0:  		/* bc 4, CR6_EQ, -72 */
		/* 822654F8h case    0:*/		if ( !regs.CR[6].eq ) { return 0x822654B0;  }
		/* 822654F8h case    0:*/		return 0x822654FC;
	}
	return 0x822654FC;
} // Block from 822654F8h-822654FCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 822654FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822654FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822654FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822654FC);
		  /* 822654FCh */ case    0:  		/* li R3, 0 */
		/* 822654FCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822654FCh case    0:*/		return 0x82265500;
		  /* 82265500h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82265500h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82265500h case    1:*/		return 0x82265504;
	}
	return 0x82265504;
} // Block from 822654FCh-82265504h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82265504h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265504( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265504) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265504);
		  /* 82265504h */ case    0:  		/* li R11, 0 */
		/* 82265504h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82265504h case    0:*/		return 0x82265508;
		  /* 82265508h */ case    1:  		/* b -32 */
		/* 82265508h case    1:*/		return 0x822654E8;
		/* 82265508h case    1:*/		return 0x8226550C;
		  /* 8226550Ch */ case    2:  		/* nop */
		/* 8226550Ch case    2:*/		cpu::op::nop();
		/* 8226550Ch case    2:*/		return 0x82265510;
	}
	return 0x82265510;
} // Block from 82265504h-82265510h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82265510h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265510( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265510) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265510);
		  /* 82265510h */ case    0:  		/* mfspr R12, LR */
		/* 82265510h case    0:*/		regs.R12 = regs.LR;
		/* 82265510h case    0:*/		return 0x82265514;
		  /* 82265514h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82265514h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82265514h case    1:*/		return 0x82265518;
		  /* 82265518h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82265518h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82265518h case    2:*/		return 0x8226551C;
		  /* 8226551Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8226551Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8226551Ch case    3:*/		return 0x82265520;
		  /* 82265520h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82265520h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82265520h case    4:*/		return 0x82265524;
		  /* 82265524h */ case    5:  		/* mr R11, R3 */
		/* 82265524h case    5:*/		regs.R11 = regs.R3;
		/* 82265524h case    5:*/		return 0x82265528;
		  /* 82265528h */ case    6:  		/* lwz R3, <#[R3]> */
		/* 82265528h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 82265528h case    6:*/		return 0x8226552C;
		  /* 8226552Ch */ case    7:  		/* mr R31, R4 */
		/* 8226552Ch case    7:*/		regs.R31 = regs.R4;
		/* 8226552Ch case    7:*/		return 0x82265530;
		  /* 82265530h */ case    8:  		/* cmplwi CR6, R3, 0 */
		/* 82265530h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82265530h case    8:*/		return 0x82265534;
		  /* 82265534h */ case    9:  		/* bc 4, CR6_EQ, 12 */
		/* 82265534h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82265540;  }
		/* 82265534h case    9:*/		return 0x82265538;
		  /* 82265538h */ case   10:  		/* li R3, 1 */
		/* 82265538h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82265538h case   10:*/		return 0x8226553C;
		  /* 8226553Ch */ case   11:  		/* b 132 */
		/* 8226553Ch case   11:*/		return 0x822655C0;
		/* 8226553Ch case   11:*/		return 0x82265540;
	}
	return 0x82265540;
} // Block from 82265510h-82265540h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82265540h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265540( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265540) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265540);
		  /* 82265540h */ case    0:  		/* lwz R6, <#[R11 + 4]> */
		/* 82265540h case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 82265540h case    0:*/		return 0x82265544;
		  /* 82265544h */ case    1:  		/* lwz R30, <#[R11 + 8]> */
		/* 82265544h case    1:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000008) );
		/* 82265544h case    1:*/		return 0x82265548;
		  /* 82265548h */ case    2:  		/* mulli R11, R6, 12 */
		/* 82265548h case    2:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R6,0xC);
		/* 82265548h case    2:*/		return 0x8226554C;
		  /* 8226554Ch */ case    3:  		/* cmpw CR6, R6, R30 */
		/* 8226554Ch case    3:*/		cpu::op::cmpw<6>(regs,regs.R6,regs.R30);
		/* 8226554Ch case    3:*/		return 0x82265550;
		  /* 82265550h */ case    4:  		/* bc 4, CR6_GT, 8 */
		/* 82265550h case    4:*/		if ( !regs.CR[6].gt ) { return 0x82265558;  }
		/* 82265550h case    4:*/		return 0x82265554;
		  /* 82265554h */ case    5:  		/* mulli R11, R31, 12 */
		/* 82265554h case    5:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R31,0xC);
		/* 82265554h case    5:*/		return 0x82265558;
	}
	return 0x82265558;
} // Block from 82265540h-82265558h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82265558h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265558( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265558) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265558);
		  /* 82265558h */ case    0:  		/* add R4, R11, R5 */
		/* 82265558h case    0:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R5);
		/* 82265558h case    0:*/		return 0x8226555C;
		  /* 8226555Ch */ case    1:  		/* bl -188 */
		/* 8226555Ch case    1:*/		regs.LR = 0x82265560; return 0x822654A0;
		/* 8226555Ch case    1:*/		return 0x82265560;
		  /* 82265560h */ case    2:  		/* cmplwi CR0, R3, 0 */
		/* 82265560h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 82265560h case    2:*/		return 0x82265564;
		  /* 82265564h */ case    3:  		/* bc 12, CR0_EQ, 92 */
		/* 82265564h case    3:*/		if ( regs.CR[0].eq ) { return 0x822655C0;  }
		/* 82265564h case    3:*/		return 0x82265568;
		  /* 82265568h */ case    4:  		/* lwz R11, <#[R3]> */
		/* 82265568h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82265568h case    4:*/		return 0x8226556C;
		  /* 8226556Ch */ case    5:  		/* mulli R10, R31, 12 */
		/* 8226556Ch case    5:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R31,0xC);
		/* 8226556Ch case    5:*/		return 0x82265570;
		  /* 82265570h */ case    6:  		/* subf R11, R6, R11 */
		/* 82265570h case    6:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R6,regs.R11);
		/* 82265570h case    6:*/		return 0x82265574;
		  /* 82265574h */ case    7:  		/* add R10, R10, R5 */
		/* 82265574h case    7:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R5);
		/* 82265574h case    7:*/		return 0x82265578;
		  /* 82265578h */ case    8:  		/* add R11, R11, R30 */
		/* 82265578h case    8:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 82265578h case    8:*/		return 0x8226557C;
		  /* 8226557Ch */ case    9:  		/* li R9, 0 */
		/* 8226557Ch case    9:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8226557Ch case    9:*/		return 0x82265580;
		  /* 82265580h */ case   10:  		/* addi R11, R11, 1 */
		/* 82265580h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82265580h case   10:*/		return 0x82265584;
		  /* 82265584h */ case   11:  		/* mulli R11, R11, 12 */
		/* 82265584h case   11:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 82265584h case   11:*/		return 0x82265588;
		  /* 82265588h */ case   12:  		/* add R11, R11, R5 */
		/* 82265588h case   12:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R5);
		/* 82265588h case   12:*/		return 0x8226558C;
		  /* 8226558Ch */ case   13:  		/* subf R10, R11, R10 */
		/* 8226558Ch case   13:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 8226558Ch case   13:*/		return 0x82265590;
		  /* 82265590h */ case   14:  		/* lbzx R8, <#[R10 + R11]> */
		/* 82265590h case   14:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82265590h case   14:*/		return 0x82265594;
		  /* 82265594h */ case   15:  		/* lbz R7, <#[R11]> */
		/* 82265594h case   15:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 82265594h case   15:*/		return 0x82265598;
		  /* 82265598h */ case   16:  		/* cmplw CR6, R7, R8 */
		/* 82265598h case   16:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R8);
		/* 82265598h case   16:*/		return 0x8226559C;
		  /* 8226559Ch */ case   17:  		/* bc 4, CR6_EQ, 60 */
		/* 8226559Ch case   17:*/		if ( !regs.CR[6].eq ) { return 0x822655D8;  }
		/* 8226559Ch case   17:*/		return 0x822655A0;
		  /* 822655A0h */ case   18:  		/* addi R9, R9, 1 */
		/* 822655A0h case   18:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 822655A0h case   18:*/		return 0x822655A4;
		  /* 822655A4h */ case   19:  		/* addi R11, R11, 1 */
		/* 822655A4h case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 822655A4h case   19:*/		return 0x822655A8;
		  /* 822655A8h */ case   20:  		/* cmpwi CR6, R9, 12 */
		/* 822655A8h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x0000000C);
		/* 822655A8h case   20:*/		return 0x822655AC;
		  /* 822655ACh */ case   21:  		/* bc 12, CR6_LT, -28 */
		/* 822655ACh case   21:*/		if ( regs.CR[6].lt ) { return 0x82265590;  }
		/* 822655ACh case   21:*/		return 0x822655B0;
	}
	return 0x822655B0;
} // Block from 82265558h-822655B0h (22 instructions)

//////////////////////////////////////////////////////
// Block at 822655B0h
// Function '?Remove@Interference@XGRAPHICS@@AAAXHPAV?$Set@H@2@H@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822655B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822655B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822655B0);
		  /* 822655B0h */ case    0:  		/* li R11, 1 */
		/* 822655B0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 822655B0h case    0:*/		return 0x822655B4;
		  /* 822655B4h */ case    1:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 822655B4h case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 822655B4h case    1:*/		return 0x822655B8;
		  /* 822655B8h */ case    2:  		/* addic R10, R11, -1 */
		/* 822655B8h case    2:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R11,0xFFFFFFFF);
		/* 822655B8h case    2:*/		return 0x822655BC;
		  /* 822655BCh */ case    3:  		/* subfe R3, R10, R11 */
		/* 822655BCh case    3:*/		cpu::op::subfe<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 822655BCh case    3:*/		return 0x822655C0;
	}
	return 0x822655C0;
} // Block from 822655B0h-822655C0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822655C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822655C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822655C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822655C0);
		  /* 822655C0h */ case    0:  		/* addi R1, R1, 112 */
		/* 822655C0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 822655C0h case    0:*/		return 0x822655C4;
		  /* 822655C4h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 822655C4h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822655C4h case    1:*/		return 0x822655C8;
		  /* 822655C8h */ case    2:  		/* mtspr LR, R12 */
		/* 822655C8h case    2:*/		regs.LR = regs.R12;
		/* 822655C8h case    2:*/		return 0x822655CC;
		  /* 822655CCh */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 822655CCh case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 822655CCh case    3:*/		return 0x822655D0;
		  /* 822655D0h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 822655D0h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822655D0h case    4:*/		return 0x822655D4;
		  /* 822655D4h */ case    5:  		/* bclr 20, CR0_LT */
		/* 822655D4h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822655D4h case    5:*/		return 0x822655D8;
	}
	return 0x822655D8;
} // Block from 822655C0h-822655D8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822655D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822655D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822655D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822655D8);
		  /* 822655D8h */ case    0:  		/* li R11, 0 */
		/* 822655D8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822655D8h case    0:*/		return 0x822655DC;
		  /* 822655DCh */ case    1:  		/* b -40 */
		/* 822655DCh case    1:*/		return 0x822655B4;
		/* 822655DCh case    1:*/		return 0x822655E0;
	}
	return 0x822655E0;
} // Block from 822655D8h-822655E0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822655E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822655E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822655E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822655E0);
		  /* 822655E0h */ case    0:  		/* mfspr R12, LR */
		/* 822655E0h case    0:*/		regs.R12 = regs.LR;
		/* 822655E0h case    0:*/		return 0x822655E4;
		  /* 822655E4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 822655E4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822655E4h case    1:*/		return 0x822655E8;
		  /* 822655E8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 822655E8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 822655E8h case    2:*/		return 0x822655EC;
		  /* 822655ECh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 822655ECh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822655ECh case    3:*/		return 0x822655F0;
		  /* 822655F0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 822655F0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 822655F0h case    4:*/		return 0x822655F4;
		  /* 822655F4h */ case    5:  		/* lwz R30, <#[R3 + 8]> */
		/* 822655F4h case    5:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x00000008) );
		/* 822655F4h case    5:*/		return 0x822655F8;
		  /* 822655F8h */ case    6:  		/* mr R31, R3 */
		/* 822655F8h case    6:*/		regs.R31 = regs.R3;
		/* 822655F8h case    6:*/		return 0x822655FC;
		  /* 822655FCh */ case    7:  		/* lwz R6, <#[R3 + 4]> */
		/* 822655FCh case    7:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R3 + 0x00000004) );
		/* 822655FCh case    7:*/		return 0x82265600;
		  /* 82265600h */ case    8:  		/* mr R5, R4 */
		/* 82265600h case    8:*/		regs.R5 = regs.R4;
		/* 82265600h case    8:*/		return 0x82265604;
		  /* 82265604h */ case    9:  		/* cmpw CR6, R6, R30 */
		/* 82265604h case    9:*/		cpu::op::cmpw<6>(regs,regs.R6,regs.R30);
		/* 82265604h case    9:*/		return 0x82265608;
		  /* 82265608h */ case   10:  		/* bc 12, CR6_GT, 120 */
		/* 82265608h case   10:*/		if ( regs.CR[6].gt ) { return 0x82265680;  }
		/* 82265608h case   10:*/		return 0x8226560C;
		  /* 8226560Ch */ case   11:  		/* mulli R11, R6, 12 */
		/* 8226560Ch case   11:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R6,0xC);
		/* 8226560Ch case   11:*/		return 0x82265610;
		  /* 82265610h */ case   12:  		/* lwz R3, <#[R3]> */
		/* 82265610h case   12:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 82265610h case   12:*/		return 0x82265614;
		  /* 82265614h */ case   13:  		/* add R4, R11, R4 */
		/* 82265614h case   13:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R4);
		/* 82265614h case   13:*/		return 0x82265618;
		  /* 82265618h */ case   14:  		/* bl -376 */
		/* 82265618h case   14:*/		regs.LR = 0x8226561C; return 0x822654A0;
		/* 82265618h case   14:*/		return 0x8226561C;
		  /* 8226561Ch */ case   15:  		/* lwz R11, <#[R3 + 4]> */
		/* 8226561Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8226561Ch case   15:*/		return 0x82265620;
		  /* 82265620h */ case   16:  		/* lwz R10, <#[R3]> */
		/* 82265620h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82265620h case   16:*/		return 0x82265624;
		  /* 82265624h */ case   17:  		/* subf R9, R6, R30 */
		/* 82265624h case   17:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R6,regs.R30);
		/* 82265624h case   17:*/		return 0x82265628;
		  /* 82265628h */ case   18:  		/* subf R8, R10, R11 */
		/* 82265628h case   18:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R10,regs.R11);
		/* 82265628h case   18:*/		return 0x8226562C;
		  /* 8226562Ch */ case   19:  		/* cmpw CR6, R8, R9 */
		/* 8226562Ch case   19:*/		cpu::op::cmpw<6>(regs,regs.R8,regs.R9);
		/* 8226562Ch case   19:*/		return 0x82265630;
		  /* 82265630h */ case   20:  		/* bc 12, CR6_GT, 80 */
		/* 82265630h case   20:*/		if ( regs.CR[6].gt ) { return 0x82265680;  }
		/* 82265630h case   20:*/		return 0x82265634;
		  /* 82265634h */ case   21:  		/* subf R11, R10, R11 */
		/* 82265634h case   21:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82265634h case   21:*/		return 0x82265638;
		  /* 82265638h */ case   22:  		/* stw R3, <#[R31]> */
		/* 82265638h case   22:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 82265638h case   22:*/		return 0x8226563C;
		  /* 8226563Ch */ case   23:  		/* add R11, R11, R6 */
		/* 8226563Ch case   23:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R6);
		/* 8226563Ch case   23:*/		return 0x82265640;
		  /* 82265640h */ case   24:  		/* addi R11, R11, 1 */
		/* 82265640h case   24:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82265640h case   24:*/		return 0x82265644;
		  /* 82265644h */ case   25:  		/* rlwinm R6, R11, 0, 0, 31 */
		/* 82265644h case   25:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R6,regs.R11);
		/* 82265644h case   25:*/		return 0x82265648;
		  /* 82265648h */ case   26:  		/* stw R11, <#[R31 + 4]> */
		/* 82265648h case   26:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82265648h case   26:*/		return 0x8226564C;
		  /* 8226564Ch */ case   27:  		/* cmpw CR6, R6, R30 */
		/* 8226564Ch case   27:*/		cpu::op::cmpw<6>(regs,regs.R6,regs.R30);
		/* 8226564Ch case   27:*/		return 0x82265650;
		  /* 82265650h */ case   28:  		/* bc 12, CR6_GT, 16 */
		/* 82265650h case   28:*/		if ( regs.CR[6].gt ) { return 0x82265660;  }
		/* 82265650h case   28:*/		return 0x82265654;
		  /* 82265654h */ case   29:  		/* mulli R11, R6, 12 */
		/* 82265654h case   29:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R6,0xC);
		/* 82265654h case   29:*/		return 0x82265658;
		  /* 82265658h */ case   30:  		/* add R4, R11, R5 */
		/* 82265658h case   30:*/		cpu::op::add<0>(regs,&regs.R4,regs.R11,regs.R5);
		/* 82265658h case   30:*/		return 0x8226565C;
		  /* 8226565Ch */ case   31:  		/* bl -444 */
		/* 8226565Ch case   31:*/		regs.LR = 0x82265660; return 0x822654A0;
		/* 8226565Ch case   31:*/		return 0x82265660;
	}
	return 0x82265660;
} // Block from 822655E0h-82265660h (32 instructions)

//////////////////////////////////////////////////////
// Block at 82265660h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265660( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265660) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265660);
		  /* 82265660h */ case    0:  		/* lwz R11, <#[R3 + 4]> */
		/* 82265660h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82265660h case    0:*/		return 0x82265664;
		  /* 82265664h */ case    1:  		/* lwz R10, <#[R3]> */
		/* 82265664h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 82265664h case    1:*/		return 0x82265668;
		  /* 82265668h */ case    2:  		/* lwz R9, <#[R31 + 8]> */
		/* 82265668h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 82265668h case    2:*/		return 0x8226566C;
		  /* 8226566Ch */ case    3:  		/* lwz R8, <#[R31 + 4]> */
		/* 8226566Ch case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000004) );
		/* 8226566Ch case    3:*/		return 0x82265670;
		  /* 82265670h */ case    4:  		/* subf R7, R10, R11 */
		/* 82265670h case    4:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R10,regs.R11);
		/* 82265670h case    4:*/		return 0x82265674;
		  /* 82265674h */ case    5:  		/* subf R9, R8, R9 */
		/* 82265674h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 82265674h case    5:*/		return 0x82265678;
		  /* 82265678h */ case    6:  		/* cmpw CR6, R7, R9 */
		/* 82265678h case    6:*/		cpu::op::cmpw<6>(regs,regs.R7,regs.R9);
		/* 82265678h case    6:*/		return 0x8226567C;
		  /* 8226567Ch */ case    7:  		/* bc 4, CR6_GT, -72 */
		/* 8226567Ch case    7:*/		if ( !regs.CR[6].gt ) { return 0x82265634;  }
		/* 8226567Ch case    7:*/		return 0x82265680;
	}
	return 0x82265680;
} // Block from 82265660h-82265680h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82265680h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265680( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265680) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265680);
		  /* 82265680h */ case    0:  		/* addi R1, R1, 112 */
		/* 82265680h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82265680h case    0:*/		return 0x82265684;
		  /* 82265684h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82265684h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82265684h case    1:*/		return 0x82265688;
		  /* 82265688h */ case    2:  		/* mtspr LR, R12 */
		/* 82265688h case    2:*/		regs.LR = regs.R12;
		/* 82265688h case    2:*/		return 0x8226568C;
		  /* 8226568Ch */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 8226568Ch case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8226568Ch case    3:*/		return 0x82265690;
		  /* 82265690h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 82265690h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82265690h case    4:*/		return 0x82265694;
		  /* 82265694h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82265694h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82265694h case    5:*/		return 0x82265698;
	}
	return 0x82265698;
} // Block from 82265680h-82265698h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82265698h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265698( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265698) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265698);
		  /* 82265698h */ case    0:  		/* mfspr R12, LR */
		/* 82265698h case    0:*/		regs.R12 = regs.LR;
		/* 82265698h case    0:*/		return 0x8226569C;
		  /* 8226569Ch */ case    1:  		/* bl -1918028 */
		/* 8226569Ch case    1:*/		regs.LR = 0x822656A0; return 0x82091250;
		/* 8226569Ch case    1:*/		return 0x822656A0;
		  /* 822656A0h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 822656A0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 822656A0h case    2:*/		return 0x822656A4;
		  /* 822656A4h */ case    3:  		/* lwz R10, <#[R3 + 8]> */
		/* 822656A4h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 822656A4h case    3:*/		return 0x822656A8;
		  /* 822656A8h */ case    4:  		/* mr R28, R3 */
		/* 822656A8h case    4:*/		regs.R28 = regs.R3;
		/* 822656A8h case    4:*/		return 0x822656AC;
		  /* 822656ACh */ case    5:  		/* lwz R11, <#[R3 + 4]> */
		/* 822656ACh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 822656ACh case    5:*/		return 0x822656B0;
		  /* 822656B0h */ case    6:  		/* cmpw CR6, R11, R10 */
		/* 822656B0h case    6:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 822656B0h case    6:*/		return 0x822656B4;
		  /* 822656B4h */ case    7:  		/* bc 4, CR6_GT, 12 */
		/* 822656B4h case    7:*/		if ( !regs.CR[6].gt ) { return 0x822656C0;  }
		/* 822656B4h case    7:*/		return 0x822656B8;
		  /* 822656B8h */ case    8:  		/* lwz R3, <#[R3]> */
		/* 822656B8h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000000) );
		/* 822656B8h case    8:*/		return 0x822656BC;
		  /* 822656BCh */ case    9:  		/* b 256 */
		/* 822656BCh case    9:*/		return 0x822657BC;
		/* 822656BCh case    9:*/		return 0x822656C0;
	}
	return 0x822656C0;
} // Block from 82265698h-822656C0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 822656C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822656C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822656C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822656C0);
		  /* 822656C0h */ case    0:  		/* lwz R10, <#[R28]> */
		/* 822656C0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000000) );
		/* 822656C0h case    0:*/		return 0x822656C4;
		  /* 822656C4h */ case    1:  		/* mulli R11, R11, 12 */
		/* 822656C4h case    1:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 822656C4h case    1:*/		return 0x822656C8;
		  /* 822656C8h */ case    2:  		/* lwz R31, <#[R10 + 20]> */
		/* 822656C8h case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + 0x00000014) );
		/* 822656C8h case    2:*/		return 0x822656CC;
		  /* 822656CCh */ case    3:  		/* li R29, 0 */
		/* 822656CCh case    3:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 822656CCh case    3:*/		return 0x822656D0;
		  /* 822656D0h */ case    4:  		/* add R8, R11, R4 */
		/* 822656D0h case    4:*/		cpu::op::add<0>(regs,&regs.R8,regs.R11,regs.R4);
		/* 822656D0h case    4:*/		return 0x822656D4;
		  /* 822656D4h */ case    5:  		/* mr R27, R29 */
		/* 822656D4h case    5:*/		regs.R27 = regs.R29;
		/* 822656D4h case    5:*/		return 0x822656D8;
		  /* 822656D8h */ case    6:  		/* lwz R30, <#[R31]> */
		/* 822656D8h case    6:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000000) );
		/* 822656D8h case    6:*/		return 0x822656DC;
		  /* 822656DCh */ case    7:  		/* mr R10, R29 */
		/* 822656DCh case    7:*/		regs.R10 = regs.R29;
		/* 822656DCh case    7:*/		return 0x822656E0;
		  /* 822656E0h */ case    8:  		/* mulli R11, R30, 12 */
		/* 822656E0h case    8:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R30,0xC);
		/* 822656E0h case    8:*/		return 0x822656E4;
		  /* 822656E4h */ case    9:  		/* add R11, R11, R4 */
		/* 822656E4h case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R4);
		/* 822656E4h case    9:*/		return 0x822656E8;
		  /* 822656E8h */ case   10:  		/* subf R9, R11, R8 */
		/* 822656E8h case   10:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R11,regs.R8);
		/* 822656E8h case   10:*/		return 0x822656EC;
		  /* 822656ECh */ case   11:  		/* lbzx R7, <#[R9 + R11]> */
		/* 822656ECh case   11:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 822656ECh case   11:*/		return 0x822656F0;
		  /* 822656F0h */ case   12:  		/* lbz R6, <#[R11]> */
		/* 822656F0h case   12:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 822656F0h case   12:*/		return 0x822656F4;
		  /* 822656F4h */ case   13:  		/* cmplw CR6, R6, R7 */
		/* 822656F4h case   13:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R7);
		/* 822656F4h case   13:*/		return 0x822656F8;
	}
	return 0x822656F8;
} // Block from 822656C0h-822656F8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 822656F8h
// Function '??1Range@XGRAPHICS@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822656F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822656F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822656F8);
		  /* 822656F8h */ case    0:  		/* bc 4, CR6_EQ, 44 */
		/* 822656F8h case    0:*/		if ( !regs.CR[6].eq ) { return 0x82265724;  }
		/* 822656F8h case    0:*/		return 0x822656FC;
		  /* 822656FCh */ case    1:  		/* addi R10, R10, 1 */
		/* 822656FCh case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 822656FCh case    1:*/		return 0x82265700;
		  /* 82265700h */ case    2:  		/* addi R11, R11, 1 */
		/* 82265700h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82265700h case    2:*/		return 0x82265704;
		  /* 82265704h */ case    3:  		/* cmpwi CR6, R10, 12 */
		/* 82265704h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000000C);
		/* 82265704h case    3:*/		return 0x82265708;
		  /* 82265708h */ case    4:  		/* bc 12, CR6_LT, -28 */
		/* 82265708h case    4:*/		if ( regs.CR[6].lt ) { return 0x822656EC;  }
		/* 82265708h case    4:*/		return 0x8226570C;
		  /* 8226570Ch */ case    5:  		/* li R11, 1 */
		/* 8226570Ch case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8226570Ch case    5:*/		return 0x82265710;
		  /* 82265710h */ case    6:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82265710h case    6:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82265710h case    6:*/		return 0x82265714;
		  /* 82265714h */ case    7:  		/* bc 4, CR0_EQ, 24 */
		/* 82265714h case    7:*/		if ( !regs.CR[0].eq ) { return 0x8226572C;  }
		/* 82265714h case    7:*/		return 0x82265718;
		  /* 82265718h */ case    8:  		/* mr R27, R31 */
		/* 82265718h case    8:*/		regs.R27 = regs.R31;
		/* 82265718h case    8:*/		return 0x8226571C;
		  /* 8226571Ch */ case    9:  		/* lwz R31, <#[R31 + 16]> */
		/* 8226571Ch case    9:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000010) );
		/* 8226571Ch case    9:*/		return 0x82265720;
		  /* 82265720h */ case   10:  		/* b -72 */
		/* 82265720h case   10:*/		return 0x822656D8;
		/* 82265720h case   10:*/		return 0x82265724;
	}
	return 0x82265724;
} // Block from 822656F8h-82265724h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82265724h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265724( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265724) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265724);
		  /* 82265724h */ case    0:  		/* mr R11, R29 */
		/* 82265724h case    0:*/		regs.R11 = regs.R29;
		/* 82265724h case    0:*/		return 0x82265728;
		  /* 82265728h */ case    1:  		/* b -24 */
		/* 82265728h case    1:*/		return 0x82265710;
		/* 82265728h case    1:*/		return 0x8226572C;
	}
	return 0x8226572C;
} // Block from 82265724h-8226572Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226572Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226572C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226572C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226572C);
		  /* 8226572Ch */ case    0:  		/* lwz R11, <#[R28 + 12]> */
		/* 8226572Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x0000000C) );
		/* 8226572Ch case    0:*/		return 0x82265730;
		  /* 82265730h */ case    1:  		/* li R4, 40 */
		/* 82265730h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x28);
		/* 82265730h case    1:*/		return 0x82265734;
		  /* 82265734h */ case    2:  		/* lwz R26, <#[R11 + 1456]> */
		/* 82265734h case    2:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R11 + 0x000005B0) );
		/* 82265734h case    2:*/		return 0x82265738;
		  /* 82265738h */ case    3:  		/* mr R3, R26 */
		/* 82265738h case    3:*/		regs.R3 = regs.R26;
		/* 82265738h case    3:*/		return 0x8226573C;
		  /* 8226573Ch */ case    4:  		/* bl -299652 */
		/* 8226573Ch case    4:*/		regs.LR = 0x82265740; return 0x8221C4B8;
		/* 8226573Ch case    4:*/		return 0x82265740;
		  /* 82265740h */ case    5:  		/* mr R11, R3 */
		/* 82265740h case    5:*/		regs.R11 = regs.R3;
		/* 82265740h case    5:*/		return 0x82265744;
		  /* 82265744h */ case    6:  		/* addic. R3, R3, 4 */
		/* 82265744h case    6:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82265744h case    6:*/		return 0x82265748;
		  /* 82265748h */ case    7:  		/* stw R26, <#[R11]> */
		/* 82265748h case    7:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + 0x00000000) );
		/* 82265748h case    7:*/		return 0x8226574C;
		  /* 8226574Ch */ case    8:  		/* bc 12, CR0_EQ, 28 */
		/* 8226574Ch case    8:*/		if ( regs.CR[0].eq ) { return 0x82265768;  }
		/* 8226574Ch case    8:*/		return 0x82265750;
		  /* 82265750h */ case    9:  		/* lis R11, 16384 */
		/* 82265750h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0x4000);
		/* 82265750h case    9:*/		return 0x82265754;
		  /* 82265754h */ case   10:  		/* stw R29, <#[R3 + 8]> */
		/* 82265754h case   10:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000008) );
		/* 82265754h case   10:*/		return 0x82265758;
		  /* 82265758h */ case   11:  		/* stw R29, <#[R3 + 24]> */
		/* 82265758h case   11:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000018) );
		/* 82265758h case   11:*/		return 0x8226575C;
		  /* 8226575Ch */ case   12:  		/* stw R11, <#[R3 + 4]> */
		/* 8226575Ch case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 8226575Ch case   12:*/		return 0x82265760;
		  /* 82265760h */ case   13:  		/* stw R29, <#[R3 + 28]> */
		/* 82265760h case   13:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x0000001C) );
		/* 82265760h case   13:*/		return 0x82265764;
		  /* 82265764h */ case   14:  		/* b 8 */
		/* 82265764h case   14:*/		return 0x8226576C;
		/* 82265764h case   14:*/		return 0x82265768;
	}
	return 0x82265768;
} // Block from 8226572Ch-82265768h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82265768h
// Function '?ColorGraph@Interference@XGRAPHICS@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265768( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265768) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265768);
		  /* 82265768h */ case    0:  		/* mr R3, R29 */
		/* 82265768h case    0:*/		regs.R3 = regs.R29;
		/* 82265768h case    0:*/		return 0x8226576C;
	}
	return 0x8226576C;
} // Block from 82265768h-8226576Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226576Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226576C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226576C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226576C);
		  /* 8226576Ch */ case    0:  		/* stw R30, <#[R3]> */
		/* 8226576Ch case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 8226576Ch case    0:*/		return 0x82265770;
		  /* 82265770h */ case    1:  		/* cmplwi CR6, R27, 0 */
		/* 82265770h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 82265770h case    1:*/		return 0x82265774;
		  /* 82265774h */ case    2:  		/* lwz R10, <#[R28 + 8]> */
		/* 82265774h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000008) );
		/* 82265774h case    2:*/		return 0x82265778;
		  /* 82265778h */ case    3:  		/* lwz R11, <#[R28 + 4]> */
		/* 82265778h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 82265778h case    3:*/		return 0x8226577C;
		  /* 8226577Ch */ case    4:  		/* subf R11, R11, R30 */
		/* 8226577Ch case    4:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 8226577Ch case    4:*/		return 0x82265780;
		  /* 82265780h */ case    5:  		/* add R11, R11, R10 */
		/* 82265780h case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82265780h case    5:*/		return 0x82265784;
		  /* 82265784h */ case    6:  		/* stw R11, <#[R3 + 4]> */
		/* 82265784h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82265784h case    6:*/		return 0x82265788;
		  /* 82265788h */ case    7:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 82265788h case    7:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 82265788h case    7:*/		return 0x8226578C;
		  /* 8226578Ch */ case    8:  		/* lwz R10, <#[R31 + 16]> */
		/* 8226578Ch case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 8226578Ch case    8:*/		return 0x82265790;
		  /* 82265790h */ case    9:  		/* addi R11, R11, 1 */
		/* 82265790h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82265790h case    9:*/		return 0x82265794;
		  /* 82265794h */ case   10:  		/* stw R10, <#[R3 + 16]> */
		/* 82265794h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000010) );
		/* 82265794h case   10:*/		return 0x82265798;
		  /* 82265798h */ case   11:  		/* stw R29, <#[R3 + 32]> */
		/* 82265798h case   11:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000020) );
		/* 82265798h case   11:*/		return 0x8226579C;
		  /* 8226579Ch */ case   12:  		/* stw R31, <#[R3 + 20]> */
		/* 8226579Ch case   12:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000014) );
		/* 8226579Ch case   12:*/		return 0x822657A0;
		  /* 822657A0h */ case   13:  		/* stw R11, <#[R31]> */
		/* 822657A0h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822657A0h case   13:*/		return 0x822657A4;
		  /* 822657A4h */ case   14:  		/* stw R29, <#[R31 + 16]> */
		/* 822657A4h case   14:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000010) );
		/* 822657A4h case   14:*/		return 0x822657A8;
		  /* 822657A8h */ case   15:  		/* bc 4, CR6_EQ, 16 */
		/* 822657A8h case   15:*/		if ( !regs.CR[6].eq ) { return 0x822657B8;  }
		/* 822657A8h case   15:*/		return 0x822657AC;
		  /* 822657ACh */ case   16:  		/* lwz R11, <#[R28]> */
		/* 822657ACh case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 822657ACh case   16:*/		return 0x822657B0;
		  /* 822657B0h */ case   17:  		/* stw R3, <#[R11 + 20]> */
		/* 822657B0h case   17:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000014) );
		/* 822657B0h case   17:*/		return 0x822657B4;
		  /* 822657B4h */ case   18:  		/* b 8 */
		/* 822657B4h case   18:*/		return 0x822657BC;
		/* 822657B4h case   18:*/		return 0x822657B8;
	}
	return 0x822657B8;
} // Block from 8226576Ch-822657B8h (19 instructions)

//////////////////////////////////////////////////////
// Block at 822657B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822657B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822657B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822657B8);
		  /* 822657B8h */ case    0:  		/* stw R3, <#[R27 + 16]> */
		/* 822657B8h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R27 + 0x00000010) );
		/* 822657B8h case    0:*/		return 0x822657BC;
	}
	return 0x822657BC;
} // Block from 822657B8h-822657BCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 822657BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822657BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822657BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822657BC);
		  /* 822657BCh */ case    0:  		/* addi R1, R1, 144 */
		/* 822657BCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 822657BCh case    0:*/		return 0x822657C0;
		  /* 822657C0h */ case    1:  		/* b -1918240 */
		/* 822657C0h case    1:*/		return 0x820912A0;
		/* 822657C0h case    1:*/		return 0x822657C4;
		  /* 822657C4h */ case    2:  		/* nop */
		/* 822657C4h case    2:*/		cpu::op::nop();
		/* 822657C4h case    2:*/		return 0x822657C8;
	}
	return 0x822657C8;
} // Block from 822657BCh-822657C8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822657C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822657C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822657C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822657C8);
		  /* 822657C8h */ case    0:  		/* mfspr R12, LR */
		/* 822657C8h case    0:*/		regs.R12 = regs.LR;
		/* 822657C8h case    0:*/		return 0x822657CC;
		  /* 822657CCh */ case    1:  		/* bl -1918340 */
		/* 822657CCh case    1:*/		regs.LR = 0x822657D0; return 0x82091248;
		/* 822657CCh case    1:*/		return 0x822657D0;
		  /* 822657D0h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 822657D0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 822657D0h case    2:*/		return 0x822657D4;
		  /* 822657D4h */ case    3:  		/* mr R27, R5 */
		/* 822657D4h case    3:*/		regs.R27 = regs.R5;
		/* 822657D4h case    3:*/		return 0x822657D8;
		  /* 822657D8h */ case    4:  		/* mr R25, R4 */
		/* 822657D8h case    4:*/		regs.R25 = regs.R4;
		/* 822657D8h case    4:*/		return 0x822657DC;
		  /* 822657DCh */ case    5:  		/* li R28, 0 */
		/* 822657DCh case    5:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 822657DCh case    5:*/		return 0x822657E0;
		  /* 822657E0h */ case    6:  		/* mr R5, R6 */
		/* 822657E0h case    6:*/		regs.R5 = regs.R6;
		/* 822657E0h case    6:*/		return 0x822657E4;
		  /* 822657E4h */ case    7:  		/* mr R4, R27 */
		/* 822657E4h case    7:*/		regs.R4 = regs.R27;
		/* 822657E4h case    7:*/		return 0x822657E8;
		  /* 822657E8h */ case    8:  		/* mr R31, R3 */
		/* 822657E8h case    8:*/		regs.R31 = regs.R3;
		/* 822657E8h case    8:*/		return 0x822657EC;
		  /* 822657ECh */ case    9:  		/* mr R29, R6 */
		/* 822657ECh case    9:*/		regs.R29 = regs.R6;
		/* 822657ECh case    9:*/		return 0x822657F0;
		  /* 822657F0h */ case   10:  		/* mr R26, R28 */
		/* 822657F0h case   10:*/		regs.R26 = regs.R28;
		/* 822657F0h case   10:*/		return 0x822657F4;
		  /* 822657F4h */ case   11:  		/* bl -740 */
		/* 822657F4h case   11:*/		regs.LR = 0x822657F8; return 0x82265510;
		/* 822657F4h case   11:*/		return 0x822657F8;
		  /* 822657F8h */ case   12:  		/* cmpwi CR0, R3, 0 */
		/* 822657F8h case   12:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 822657F8h case   12:*/		return 0x822657FC;
		  /* 822657FCh */ case   13:  		/* bc 4, CR0_EQ, 212 */
		/* 822657FCh case   13:*/		if ( !regs.CR[0].eq ) { return 0x822658D0;  }
		/* 822657FCh case   13:*/		return 0x82265800;
		  /* 82265800h */ case   14:  		/* mr R4, R29 */
		/* 82265800h case   14:*/		regs.R4 = regs.R29;
		/* 82265800h case   14:*/		return 0x82265804;
		  /* 82265804h */ case   15:  		/* mr R3, R31 */
		/* 82265804h case   15:*/		regs.R3 = regs.R31;
		/* 82265804h case   15:*/		return 0x82265808;
		  /* 82265808h */ case   16:  		/* bl -368 */
		/* 82265808h case   16:*/		regs.LR = 0x8226580C; return 0x82265698;
		/* 82265808h case   16:*/		return 0x8226580C;
		  /* 8226580Ch */ case   17:  		/* lwz R11, <#[R31 + 12]> */
		/* 8226580Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 8226580Ch case   17:*/		return 0x82265810;
		  /* 82265810h */ case   18:  		/* mr R30, R3 */
		/* 82265810h case   18:*/		regs.R30 = regs.R3;
		/* 82265810h case   18:*/		return 0x82265814;
		  /* 82265814h */ case   19:  		/* li R4, 40 */
		/* 82265814h case   19:*/		cpu::op::li<0>(regs,&regs.R4,0x28);
		/* 82265814h case   19:*/		return 0x82265818;
		  /* 82265818h */ case   20:  		/* lwz R24, <#[R11 + 1456]> */
		/* 82265818h case   20:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R11 + 0x000005B0) );
		/* 82265818h case   20:*/		return 0x8226581C;
		  /* 8226581Ch */ case   21:  		/* mr R3, R24 */
		/* 8226581Ch case   21:*/		regs.R3 = regs.R24;
		/* 8226581Ch case   21:*/		return 0x82265820;
		  /* 82265820h */ case   22:  		/* bl -299880 */
		/* 82265820h case   22:*/		regs.LR = 0x82265824; return 0x8221C4B8;
		/* 82265820h case   22:*/		return 0x82265824;
		  /* 82265824h */ case   23:  		/* addic. R11, R3, 4 */
		/* 82265824h case   23:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R3,0x4);
		/* 82265824h case   23:*/		return 0x82265828;
		  /* 82265828h */ case   24:  		/* stw R24, <#[R3]> */
		/* 82265828h case   24:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R3 + 0x00000000) );
		/* 82265828h case   24:*/		return 0x8226582C;
		  /* 8226582Ch */ case   25:  		/* bc 12, CR0_EQ, 28 */
		/* 8226582Ch case   25:*/		if ( regs.CR[0].eq ) { return 0x82265848;  }
		/* 8226582Ch case   25:*/		return 0x82265830;
		  /* 82265830h */ case   26:  		/* lis R10, 16384 */
		/* 82265830h case   26:*/		cpu::op::lis<0>(regs,&regs.R10,0x4000);
		/* 82265830h case   26:*/		return 0x82265834;
		  /* 82265834h */ case   27:  		/* stw R28, <#[R11 + 8]> */
		/* 82265834h case   27:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000008) );
		/* 82265834h case   27:*/		return 0x82265838;
		  /* 82265838h */ case   28:  		/* stw R28, <#[R11 + 24]> */
		/* 82265838h case   28:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000018) );
		/* 82265838h case   28:*/		return 0x8226583C;
		  /* 8226583Ch */ case   29:  		/* stw R10, <#[R11 + 4]> */
		/* 8226583Ch case   29:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 8226583Ch case   29:*/		return 0x82265840;
		  /* 82265840h */ case   30:  		/* stw R28, <#[R11 + 28]> */
		/* 82265840h case   30:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x0000001C) );
		/* 82265840h case   30:*/		return 0x82265844;
		  /* 82265844h */ case   31:  		/* b 8 */
		/* 82265844h case   31:*/		return 0x8226584C;
		/* 82265844h case   31:*/		return 0x82265848;
	}
	return 0x82265848;
} // Block from 822657C8h-82265848h (32 instructions)

//////////////////////////////////////////////////////
// Block at 82265848h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265848( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265848) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265848);
		  /* 82265848h */ case    0:  		/* mr R11, R28 */
		/* 82265848h case    0:*/		regs.R11 = regs.R28;
		/* 82265848h case    0:*/		return 0x8226584C;
	}
	return 0x8226584C;
} // Block from 82265848h-8226584Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226584Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226584C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226584C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226584C);
		  /* 8226584Ch */ case    0:  		/* stw R27, <#[R11]> */
		/* 8226584Ch case    0:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R11 + 0x00000000) );
		/* 8226584Ch case    0:*/		return 0x82265850;
		  /* 82265850h */ case    1:  		/* cmplwi CR6, R26, 0 */
		/* 82265850h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 82265850h case    1:*/		return 0x82265854;
		  /* 82265854h */ case    2:  		/* stw R28, <#[R11 + 20]> */
		/* 82265854h case    2:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000014) );
		/* 82265854h case    2:*/		return 0x82265858;
		  /* 82265858h */ case    3:  		/* lwz R10, <#[R30 + 20]> */
		/* 82265858h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000014) );
		/* 82265858h case    3:*/		return 0x8226585C;
		  /* 8226585Ch */ case    4:  		/* stw R10, <#[R11 + 16]> */
		/* 8226585Ch case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 8226585Ch case    4:*/		return 0x82265860;
		  /* 82265860h */ case    5:  		/* stw R28, <#[R11 + 32]> */
		/* 82265860h case    5:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R11 + 0x00000020) );
		/* 82265860h case    5:*/		return 0x82265864;
		  /* 82265864h */ case    6:  		/* stw R11, <#[R30 + 20]> */
		/* 82265864h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 82265864h case    6:*/		return 0x82265868;
		  /* 82265868h */ case    7:  		/* bc 12, CR6_EQ, 8 */
		/* 82265868h case    7:*/		if ( regs.CR[6].eq ) { return 0x82265870;  }
		/* 82265868h case    7:*/		return 0x8226586C;
		  /* 8226586Ch */ case    8:  		/* stw R30, <#[R26 + 32]> */
		/* 8226586Ch case    8:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R26 + 0x00000020) );
		/* 8226586Ch case    8:*/		return 0x82265870;
	}
	return 0x82265870;
} // Block from 8226584Ch-82265870h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82265870h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265870( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265870) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265870);
		  /* 82265870h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 82265870h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82265870h case    0:*/		return 0x82265874;
		  /* 82265874h */ case    1:  		/* mr R26, R30 */
		/* 82265874h case    1:*/		regs.R26 = regs.R30;
		/* 82265874h case    1:*/		return 0x82265878;
		  /* 82265878h */ case    2:  		/* lwz R11, <#[R11 + 32]> */
		/* 82265878h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000020) );
		/* 82265878h case    2:*/		return 0x8226587C;
		  /* 8226587Ch */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 8226587Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8226587Ch case    3:*/		return 0x82265880;
		  /* 82265880h */ case    4:  		/* stw R11, <#[R31]> */
		/* 82265880h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82265880h case    4:*/		return 0x82265884;
		  /* 82265884h */ case    5:  		/* bc 4, CR6_EQ, 32 */
		/* 82265884h case    5:*/		if ( !regs.CR[6].eq ) { return 0x822658A4;  }
		/* 82265884h case    5:*/		return 0x82265888;
		  /* 82265888h */ case    6:  		/* lwz R10, <#[R31 + 8]> */
		/* 82265888h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 82265888h case    6:*/		return 0x8226588C;
		  /* 8226588Ch */ case    7:  		/* lwz R11, <#[R31 + 4]> */
		/* 8226588Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8226588Ch case    7:*/		return 0x82265890;
		  /* 82265890h */ case    8:  		/* cmpw CR6, R11, R10 */
		/* 82265890h case    8:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 82265890h case    8:*/		return 0x82265894;
		  /* 82265894h */ case    9:  		/* bc 12, CR6_GT, 16 */
		/* 82265894h case    9:*/		if ( regs.CR[6].gt ) { return 0x822658A4;  }
		/* 82265894h case    9:*/		return 0x82265898;
		  /* 82265898h */ case   10:  		/* addi R11, R11, 1 */
		/* 82265898h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82265898h case   10:*/		return 0x8226589C;
		  /* 8226589Ch */ case   11:  		/* stw R25, <#[R31]> */
		/* 8226589Ch case   11:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R31 + 0x00000000) );
		/* 8226589Ch case   11:*/		return 0x822658A0;
		  /* 822658A0h */ case   12:  		/* stw R11, <#[R31 + 4]> */
		/* 822658A0h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 822658A0h case   12:*/		return 0x822658A4;
	}
	return 0x822658A4;
} // Block from 82265870h-822658A4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 822658A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822658A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822658A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822658A4);
		  /* 822658A4h */ case    0:  		/* mr R4, R29 */
		/* 822658A4h case    0:*/		regs.R4 = regs.R29;
		/* 822658A4h case    0:*/		return 0x822658A8;
		  /* 822658A8h */ case    1:  		/* mr R3, R31 */
		/* 822658A8h case    1:*/		regs.R3 = regs.R31;
		/* 822658A8h case    1:*/		return 0x822658AC;
		  /* 822658ACh */ case    2:  		/* bl -716 */
		/* 822658ACh case    2:*/		regs.LR = 0x822658B0; return 0x822655E0;
		/* 822658ACh case    2:*/		return 0x822658B0;
		  /* 822658B0h */ case    3:  		/* mr R5, R29 */
		/* 822658B0h case    3:*/		regs.R5 = regs.R29;
		/* 822658B0h case    3:*/		return 0x822658B4;
		  /* 822658B4h */ case    4:  		/* mr R4, R27 */
		/* 822658B4h case    4:*/		regs.R4 = regs.R27;
		/* 822658B4h case    4:*/		return 0x822658B8;
		  /* 822658B8h */ case    5:  		/* mr R3, R31 */
		/* 822658B8h case    5:*/		regs.R3 = regs.R31;
		/* 822658B8h case    5:*/		return 0x822658BC;
		  /* 822658BCh */ case    6:  		/* bl -940 */
		/* 822658BCh case    6:*/		regs.LR = 0x822658C0; return 0x82265510;
		/* 822658BCh case    6:*/		return 0x822658C0;
		  /* 822658C0h */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 822658C0h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 822658C0h case    7:*/		return 0x822658C4;
		  /* 822658C4h */ case    8:  		/* bc 12, CR0_EQ, -196 */
		/* 822658C4h case    8:*/		if ( regs.CR[0].eq ) { return 0x82265800;  }
		/* 822658C4h case    8:*/		return 0x822658C8;
		  /* 822658C8h */ case    9:  		/* lwz R11, <#[R31]> */
		/* 822658C8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822658C8h case    9:*/		return 0x822658CC;
		  /* 822658CCh */ case   10:  		/* stw R11, <#[R30 + 32]> */
		/* 822658CCh case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000020) );
		/* 822658CCh case   10:*/		return 0x822658D0;
	}
	return 0x822658D0;
} // Block from 822658A4h-822658D0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 822658D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822658D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822658D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822658D0);
		  /* 822658D0h */ case    0:  		/* addi R1, R1, 160 */
		/* 822658D0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 822658D0h case    0:*/		return 0x822658D4;
		  /* 822658D4h */ case    1:  		/* b -1918524 */
		/* 822658D4h case    1:*/		return 0x82091298;
		/* 822658D4h case    1:*/		return 0x822658D8;
	}
	return 0x822658D8;
} // Block from 822658D0h-822658D8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822658D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822658D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822658D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822658D8);
		  /* 822658D8h */ case    0:  		/* mfspr R12, LR */
		/* 822658D8h case    0:*/		regs.R12 = regs.LR;
		/* 822658D8h case    0:*/		return 0x822658DC;
		  /* 822658DCh */ case    1:  		/* bl -1918604 */
		/* 822658DCh case    1:*/		regs.LR = 0x822658E0; return 0x82091250;
		/* 822658DCh case    1:*/		return 0x822658E0;
		  /* 822658E0h */ case    2:  		/* stwu R1, <#[R1 - 544]> */
		/* 822658E0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFDE0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFDE0);
		/* 822658E0h case    2:*/		return 0x822658E4;
		  /* 822658E4h */ case    3:  		/* mr R29, R3 */
		/* 822658E4h case    3:*/		regs.R29 = regs.R3;
		/* 822658E4h case    3:*/		return 0x822658E8;
		  /* 822658E8h */ case    4:  		/* mr R27, R4 */
		/* 822658E8h case    4:*/		regs.R27 = regs.R4;
		/* 822658E8h case    4:*/		return 0x822658EC;
		  /* 822658ECh */ case    5:  		/* mr R28, R5 */
		/* 822658ECh case    5:*/		regs.R28 = regs.R5;
		/* 822658ECh case    5:*/		return 0x822658F0;
		  /* 822658F0h */ case    6:  		/* li R30, 0 */
		/* 822658F0h case    6:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 822658F0h case    6:*/		return 0x822658F4;
		  /* 822658F4h */ case    7:  		/* li R5, 380 */
		/* 822658F4h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x17C);
		/* 822658F4h case    7:*/		return 0x822658F8;
		  /* 822658F8h */ case    8:  		/* li R4, 0 */
		/* 822658F8h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 822658F8h case    8:*/		return 0x822658FC;
		  /* 822658FCh */ case    9:  		/* stw R30, <#[R1 + 96]> */
		/* 822658FCh case    9:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000060) );
		/* 822658FCh case    9:*/		return 0x82265900;
		  /* 82265900h */ case   10:  		/* addi R3, R1, 100 */
		/* 82265900h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x64);
		/* 82265900h case   10:*/		return 0x82265904;
		  /* 82265904h */ case   11:  		/* bl -1918404 */
		/* 82265904h case   11:*/		regs.LR = 0x82265908; return 0x82091340;
		/* 82265904h case   11:*/		return 0x82265908;
		  /* 82265908h */ case   12:  		/* mulli R11, R29, 12 */
		/* 82265908h case   12:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R29,0xC);
		/* 82265908h case   12:*/		return 0x8226590C;
		  /* 8226590Ch */ case   13:  		/* add R3, R11, R27 */
		/* 8226590Ch case   13:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R27);
		/* 8226590Ch case   13:*/		return 0x82265910;
		  /* 82265910h */ case   14:  		/* addi R4, R1, 96 */
		/* 82265910h case   14:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 82265910h case   14:*/		return 0x82265914;
		  /* 82265914h */ case   15:  		/* li R5, 12 */
		/* 82265914h case   15:*/		cpu::op::li<0>(regs,&regs.R5,0xC);
		/* 82265914h case   15:*/		return 0x82265918;
		  /* 82265918h */ case   16:  		/* bl -1916776 */
		/* 82265918h case   16:*/		regs.LR = 0x8226591C; return 0x820919B0;
		/* 82265918h case   16:*/		return 0x8226591C;
		  /* 8226591Ch */ case   17:  		/* li R4, 40 */
		/* 8226591Ch case   17:*/		cpu::op::li<0>(regs,&regs.R4,0x28);
		/* 8226591Ch case   17:*/		return 0x82265920;
		  /* 82265920h */ case   18:  		/* lwz R26, <#[R28 + 1456]> */
		/* 82265920h case   18:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R28 + 0x000005B0) );
		/* 82265920h case   18:*/		return 0x82265924;
		  /* 82265924h */ case   19:  		/* mr R3, R26 */
		/* 82265924h case   19:*/		regs.R3 = regs.R26;
		/* 82265924h case   19:*/		return 0x82265928;
		  /* 82265928h */ case   20:  		/* bl -300144 */
		/* 82265928h case   20:*/		regs.LR = 0x8226592C; return 0x8221C4B8;
		/* 82265928h case   20:*/		return 0x8226592C;
		  /* 8226592Ch */ case   21:  		/* addic. R31, R3, 4 */
		/* 8226592Ch case   21:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R3,0x4);
		/* 8226592Ch case   21:*/		return 0x82265930;
		  /* 82265930h */ case   22:  		/* stw R26, <#[R3]> */
		/* 82265930h case   22:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R3 + 0x00000000) );
		/* 82265930h case   22:*/		return 0x82265934;
		  /* 82265934h */ case   23:  		/* bc 12, CR0_EQ, 28 */
		/* 82265934h case   23:*/		if ( regs.CR[0].eq ) { return 0x82265950;  }
		/* 82265934h case   23:*/		return 0x82265938;
		  /* 82265938h */ case   24:  		/* lis R11, 16384 */
		/* 82265938h case   24:*/		cpu::op::lis<0>(regs,&regs.R11,0x4000);
		/* 82265938h case   24:*/		return 0x8226593C;
		  /* 8226593Ch */ case   25:  		/* stw R30, <#[R31 + 8]> */
		/* 8226593Ch case   25:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000008) );
		/* 8226593Ch case   25:*/		return 0x82265940;
		  /* 82265940h */ case   26:  		/* stw R30, <#[R31 + 24]> */
		/* 82265940h case   26:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000018) );
		/* 82265940h case   26:*/		return 0x82265944;
		  /* 82265944h */ case   27:  		/* stw R11, <#[R31 + 4]> */
		/* 82265944h case   27:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82265944h case   27:*/		return 0x82265948;
		  /* 82265948h */ case   28:  		/* stw R30, <#[R31 + 28]> */
		/* 82265948h case   28:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000001C) );
		/* 82265948h case   28:*/		return 0x8226594C;
		  /* 8226594Ch */ case   29:  		/* b 8 */
		/* 8226594Ch case   29:*/		return 0x82265954;
		/* 8226594Ch case   29:*/		return 0x82265950;
	}
	return 0x82265950;
} // Block from 822658D8h-82265950h (30 instructions)

//////////////////////////////////////////////////////
// Block at 82265950h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265950( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265950) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265950);
		  /* 82265950h */ case    0:  		/* mr R31, R30 */
		/* 82265950h case    0:*/		regs.R31 = regs.R30;
		/* 82265950h case    0:*/		return 0x82265954;
	}
	return 0x82265954;
} // Block from 82265950h-82265954h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82265954h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265954( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265954) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265954);
		  /* 82265954h */ case    0:  		/* li R11, -1 */
		/* 82265954h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFF);
		/* 82265954h case    0:*/		return 0x82265958;
		  /* 82265958h */ case    1:  		/* stw R30, <#[R31 + 20]> */
		/* 82265958h case    1:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000014) );
		/* 82265958h case    1:*/		return 0x8226595C;
		  /* 8226595Ch */ case    2:  		/* li R10, -2 */
		/* 8226595Ch case    2:*/		cpu::op::li<0>(regs,&regs.R10,0xFFFFFFFE);
		/* 8226595Ch case    2:*/		return 0x82265960;
		  /* 82265960h */ case    3:  		/* stw R30, <#[R31 + 16]> */
		/* 82265960h case    3:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000010) );
		/* 82265960h case    3:*/		return 0x82265964;
		  /* 82265964h */ case    4:  		/* addic. R29, R29, 1 */
		/* 82265964h case    4:*/		cpu::op::addic<1>(regs,&regs.R29,regs.R29,0x1);
		/* 82265964h case    4:*/		return 0x82265968;
		  /* 82265968h */ case    5:  		/* stw R30, <#[R31 + 32]> */
		/* 82265968h case    5:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000020) );
		/* 82265968h case    5:*/		return 0x8226596C;
		  /* 8226596Ch */ case    6:  		/* stw R30, <#[R1 + 84]> */
		/* 8226596Ch case    6:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000054) );
		/* 8226596Ch case    6:*/		return 0x82265970;
		  /* 82265970h */ case    7:  		/* stw R28, <#[R1 + 92]> */
		/* 82265970h case    7:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x0000005C) );
		/* 82265970h case    7:*/		return 0x82265974;
		  /* 82265974h */ case    8:  		/* stw R11, <#[R31]> */
		/* 82265974h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82265974h case    8:*/		return 0x82265978;
		  /* 82265978h */ case    9:  		/* stw R10, <#[R31 + 4]> */
		/* 82265978h case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82265978h case    9:*/		return 0x8226597C;
		  /* 8226597Ch */ case   10:  		/* stw R31, <#[R1 + 80]> */
		/* 8226597Ch case   10:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000050) );
		/* 8226597Ch case   10:*/		return 0x82265980;
		  /* 82265980h */ case   11:  		/* stw R11, <#[R1 + 88]> */
		/* 82265980h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 82265980h case   11:*/		return 0x82265984;
		  /* 82265984h */ case   12:  		/* bc 4, CR0_GT, 84 */
		/* 82265984h case   12:*/		if ( !regs.CR[0].gt ) { return 0x822659D8;  }
		/* 82265984h case   12:*/		return 0x82265988;
		  /* 82265988h */ case   13:  		/* lwz R11, <#[R1 + 80]> */
		/* 82265988h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82265988h case   13:*/		return 0x8226598C;
		  /* 8226598Ch */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 8226598Ch case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8226598Ch case   14:*/		return 0x82265990;
		  /* 82265990h */ case   15:  		/* bc 4, CR6_EQ, 20 */
		/* 82265990h case   15:*/		if ( !regs.CR[6].eq ) { return 0x822659A4;  }
		/* 82265990h case   15:*/		return 0x82265994;
		  /* 82265994h */ case   16:  		/* lwz R11, <#[R1 + 84]> */
		/* 82265994h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82265994h case   16:*/		return 0x82265998;
		  /* 82265998h */ case   17:  		/* stw R31, <#[R1 + 80]> */
		/* 82265998h case   17:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000050) );
		/* 82265998h case   17:*/		return 0x8226599C;
		  /* 8226599Ch */ case   18:  		/* addi R11, R11, 1 */
		/* 8226599Ch case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8226599Ch case   18:*/		return 0x822659A0;
		  /* 822659A0h */ case   19:  		/* stw R11, <#[R1 + 84]> */
		/* 822659A0h case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 822659A0h case   19:*/		return 0x822659A4;
	}
	return 0x822659A4;
} // Block from 82265954h-822659A4h (20 instructions)

//////////////////////////////////////////////////////
// Block at 822659A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822659A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822659A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822659A4);
		  /* 822659A4h */ case    0:  		/* addi R11, R30, -1 */
		/* 822659A4h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xFFFFFFFF);
		/* 822659A4h case    0:*/		return 0x822659A8;
		  /* 822659A8h */ case    1:  		/* mr R4, R27 */
		/* 822659A8h case    1:*/		regs.R4 = regs.R27;
		/* 822659A8h case    1:*/		return 0x822659AC;
		  /* 822659ACh */ case    2:  		/* stw R11, <#[R1 + 88]> */
		/* 822659ACh case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 822659ACh case    2:*/		return 0x822659B0;
		  /* 822659B0h */ case    3:  		/* addi R3, R1, 80 */
		/* 822659B0h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 822659B0h case    3:*/		return 0x822659B4;
		  /* 822659B4h */ case    4:  		/* bl -980 */
		/* 822659B4h case    4:*/		regs.LR = 0x822659B8; return 0x822655E0;
		/* 822659B4h case    4:*/		return 0x822659B8;
		  /* 822659B8h */ case    5:  		/* mr R6, R27 */
		/* 822659B8h case    5:*/		regs.R6 = regs.R27;
		/* 822659B8h case    5:*/		return 0x822659BC;
		  /* 822659BCh */ case    6:  		/* mr R5, R30 */
		/* 822659BCh case    6:*/		regs.R5 = regs.R30;
		/* 822659BCh case    6:*/		return 0x822659C0;
		  /* 822659C0h */ case    7:  		/* mr R4, R31 */
		/* 822659C0h case    7:*/		regs.R4 = regs.R31;
		/* 822659C0h case    7:*/		return 0x822659C4;
		  /* 822659C4h */ case    8:  		/* addi R3, R1, 80 */
		/* 822659C4h case    8:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 822659C4h case    8:*/		return 0x822659C8;
		  /* 822659C8h */ case    9:  		/* bl -512 */
		/* 822659C8h case    9:*/		regs.LR = 0x822659CC; return 0x822657C8;
		/* 822659C8h case    9:*/		return 0x822659CC;
		  /* 822659CCh */ case   10:  		/* addi R30, R30, 1 */
		/* 822659CCh case   10:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 822659CCh case   10:*/		return 0x822659D0;
		  /* 822659D0h */ case   11:  		/* cmpw CR6, R30, R29 */
		/* 822659D0h case   11:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R29);
		/* 822659D0h case   11:*/		return 0x822659D4;
		  /* 822659D4h */ case   12:  		/* bc 12, CR6_LT, -76 */
		/* 822659D4h case   12:*/		if ( regs.CR[6].lt ) { return 0x82265988;  }
		/* 822659D4h case   12:*/		return 0x822659D8;
	}
	return 0x822659D8;
} // Block from 822659A4h-822659D8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 822659D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822659D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822659D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822659D8);
		  /* 822659D8h */ case    0:  		/* mr R3, R31 */
		/* 822659D8h case    0:*/		regs.R3 = regs.R31;
		/* 822659D8h case    0:*/		return 0x822659DC;
		  /* 822659DCh */ case    1:  		/* addi R1, R1, 544 */
		/* 822659DCh case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x220);
		/* 822659DCh case    1:*/		return 0x822659E0;
		  /* 822659E0h */ case    2:  		/* b -1918784 */
		/* 822659E0h case    2:*/		return 0x820912A0;
		/* 822659E0h case    2:*/		return 0x822659E4;
		  /* 822659E4h */ case    3:  		/* nop */
		/* 822659E4h case    3:*/		cpu::op::nop();
		/* 822659E4h case    3:*/		return 0x822659E8;
	}
	return 0x822659E8;
} // Block from 822659D8h-822659E8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822659E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822659E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822659E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822659E8);
		  /* 822659E8h */ case    0:  		/* mfspr R12, LR */
		/* 822659E8h case    0:*/		regs.R12 = regs.LR;
		/* 822659E8h case    0:*/		return 0x822659EC;
		  /* 822659ECh */ case    1:  		/* bl -1918868 */
		/* 822659ECh case    1:*/		regs.LR = 0x822659F0; return 0x82091258;
		/* 822659ECh case    1:*/		return 0x822659F0;
		  /* 822659F0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 822659F0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 822659F0h case    2:*/		return 0x822659F4;
		  /* 822659F4h */ case    3:  		/* li R11, 0 */
		/* 822659F4h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822659F4h case    3:*/		return 0x822659F8;
		  /* 822659F8h */ case    4:  		/* mr R30, R4 */
		/* 822659F8h case    4:*/		regs.R30 = regs.R4;
		/* 822659F8h case    4:*/		return 0x822659FC;
		  /* 822659FCh */ case    5:  		/* stw R11, <#[R3]> */
		/* 822659FCh case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 822659FCh case    5:*/		return 0x82265A00;
		  /* 82265A00h */ case    6:  		/* mr R29, R3 */
		/* 82265A00h case    6:*/		regs.R29 = regs.R3;
		/* 82265A00h case    6:*/		return 0x82265A04;
		  /* 82265A04h */ case    7:  		/* li R4, 20 */
		/* 82265A04h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 82265A04h case    7:*/		return 0x82265A08;
		  /* 82265A08h */ case    8:  		/* lwz R28, <#[R30 + 1456]> */
		/* 82265A08h case    8:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R30 + 0x000005B0) );
		/* 82265A08h case    8:*/		return 0x82265A0C;
		  /* 82265A0Ch */ case    9:  		/* mr R3, R28 */
		/* 82265A0Ch case    9:*/		regs.R3 = regs.R28;
		/* 82265A0Ch case    9:*/		return 0x82265A10;
		  /* 82265A10h */ case   10:  		/* bl -300376 */
		/* 82265A10h case   10:*/		regs.LR = 0x82265A14; return 0x8221C4B8;
		/* 82265A10h case   10:*/		return 0x82265A14;
		  /* 82265A14h */ case   11:  		/* addic. R31, R3, 4 */
		/* 82265A14h case   11:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R3,0x4);
		/* 82265A14h case   11:*/		return 0x82265A18;
		  /* 82265A18h */ case   12:  		/* stw R28, <#[R3]> */
		/* 82265A18h case   12:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R3 + 0x00000000) );
		/* 82265A18h case   12:*/		return 0x82265A1C;
		  /* 82265A1Ch */ case   13:  		/* bc 12, CR0_EQ, 20 */
		/* 82265A1Ch case   13:*/		if ( regs.CR[0].eq ) { return 0x82265A30;  }
		/* 82265A1Ch case   13:*/		return 0x82265A20;
		  /* 82265A20h */ case   14:  		/* mr R3, R31 */
		/* 82265A20h case   14:*/		regs.R3 = regs.R31;
		/* 82265A20h case   14:*/		return 0x82265A24;
		  /* 82265A24h */ case   15:  		/* lwz R4, <#[R30 + 1456]> */
		/* 82265A24h case   15:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x000005B0) );
		/* 82265A24h case   15:*/		return 0x82265A28;
		  /* 82265A28h */ case   16:  		/* bl -195784 */
		/* 82265A28h case   16:*/		regs.LR = 0x82265A2C; return 0x82235D60;
		/* 82265A28h case   16:*/		return 0x82265A2C;
		  /* 82265A2Ch */ case   17:  		/* b 8 */
		/* 82265A2Ch case   17:*/		return 0x82265A34;
		/* 82265A2Ch case   17:*/		return 0x82265A30;
	}
	return 0x82265A30;
} // Block from 822659E8h-82265A30h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82265A30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265A30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265A30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265A30);
		  /* 82265A30h */ case    0:  		/* li R31, 0 */
		/* 82265A30h case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82265A30h case    0:*/		return 0x82265A34;
	}
	return 0x82265A34;
} // Block from 82265A30h-82265A34h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82265A34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265A34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265A34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265A34);
		  /* 82265A34h */ case    0:  		/* stw R31, <#[R29 + 4]> */
		/* 82265A34h case    0:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R29 + 0x00000004) );
		/* 82265A34h case    0:*/		return 0x82265A38;
		  /* 82265A38h */ case    1:  		/* mr R3, R29 */
		/* 82265A38h case    1:*/		regs.R3 = regs.R29;
		/* 82265A38h case    1:*/		return 0x82265A3C;
		  /* 82265A3Ch */ case    2:  		/* addi R1, R1, 128 */
		/* 82265A3Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82265A3Ch case    2:*/		return 0x82265A40;
		  /* 82265A40h */ case    3:  		/* b -1918872 */
		/* 82265A40h case    3:*/		return 0x820912A8;
		/* 82265A40h case    3:*/		return 0x82265A44;
		  /* 82265A44h */ case    4:  		/* nop */
		/* 82265A44h case    4:*/		cpu::op::nop();
		/* 82265A44h case    4:*/		return 0x82265A48;
	}
	return 0x82265A48;
} // Block from 82265A34h-82265A48h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82265A48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265A48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265A48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265A48);
		  /* 82265A48h */ case    0:  		/* mfspr R12, LR */
		/* 82265A48h case    0:*/		regs.R12 = regs.LR;
		/* 82265A48h case    0:*/		return 0x82265A4C;
		  /* 82265A4Ch */ case    1:  		/* bl -1918984 */
		/* 82265A4Ch case    1:*/		regs.LR = 0x82265A50; return 0x82091244;
		/* 82265A4Ch case    1:*/		return 0x82265A50;
		  /* 82265A50h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 82265A50h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82265A50h case    2:*/		return 0x82265A54;
		  /* 82265A54h */ case    3:  		/* lwz R31, <#[R3 + 96]> */
		/* 82265A54h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x00000060) );
		/* 82265A54h case    3:*/		return 0x82265A58;
		  /* 82265A58h */ case    4:  		/* li R27, 0 */
		/* 82265A58h case    4:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 82265A58h case    4:*/		return 0x82265A5C;
		  /* 82265A5Ch */ case    5:  		/* lwz R11, <#[R31 + 4]> */
		/* 82265A5Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82265A5Ch case    5:*/		return 0x82265A60;
		  /* 82265A60h */ case    6:  		/* mr R23, R11 */
		/* 82265A60h case    6:*/		regs.R23 = regs.R11;
		/* 82265A60h case    6:*/		return 0x82265A64;
		  /* 82265A64h */ case    7:  		/* cmpwi CR0, R11, 0 */
		/* 82265A64h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 82265A64h case    7:*/		return 0x82265A68;
		  /* 82265A68h */ case    8:  		/* bc 4, CR0_GT, 432 */
		/* 82265A68h case    8:*/		if ( !regs.CR[0].gt ) { return 0x82265C18;  }
		/* 82265A68h case    8:*/		return 0x82265A6C;
		  /* 82265A6Ch */ case    9:  		/* li R25, 0 */
		/* 82265A6Ch case    9:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 82265A6Ch case    9:*/		return 0x82265A70;
		  /* 82265A70h */ case   10:  		/* addi R24, R27, 1 */
		/* 82265A70h case   10:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R27,0x1);
		/* 82265A70h case   10:*/		return 0x82265A74;
		  /* 82265A74h */ case   11:  		/* mr R28, R24 */
		/* 82265A74h case   11:*/		regs.R28 = regs.R24;
		/* 82265A74h case   11:*/		return 0x82265A78;
		  /* 82265A78h */ case   12:  		/* cmplw CR6, R24, R11 */
		/* 82265A78h case   12:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R11);
		/* 82265A78h case   12:*/		return 0x82265A7C;
		  /* 82265A7Ch */ case   13:  		/* bc 4, CR6_LT, 396 */
		/* 82265A7Ch case   13:*/		if ( !regs.CR[6].lt ) { return 0x82265C08;  }
		/* 82265A7Ch case   13:*/		return 0x82265A80;
		  /* 82265A80h */ case   14:  		/* addi R26, R25, 4 */
		/* 82265A80h case   14:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R25,0x4);
		/* 82265A80h case   14:*/		return 0x82265A84;
		  /* 82265A84h */ case   15:  		/* cmplw CR6, R27, R11 */
		/* 82265A84h case   15:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 82265A84h case   15:*/		return 0x82265A88;
		  /* 82265A88h */ case   16:  		/* bc 4, CR6_LT, 16 */
		/* 82265A88h case   16:*/		if ( !regs.CR[6].lt ) { return 0x82265A98;  }
		/* 82265A88h case   16:*/		return 0x82265A8C;
		  /* 82265A8Ch */ case   17:  		/* lwz R11, <#[R31 + 8]> */
		/* 82265A8Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82265A8Ch case   17:*/		return 0x82265A90;
		  /* 82265A90h */ case   18:  		/* add R3, R11, R25 */
		/* 82265A90h case   18:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R25);
		/* 82265A90h case   18:*/		return 0x82265A94;
		  /* 82265A94h */ case   19:  		/* b 16 */
		/* 82265A94h case   19:*/		return 0x82265AA4;
		/* 82265A94h case   19:*/		return 0x82265A98;
	}
	return 0x82265A98;
} // Block from 82265A48h-82265A98h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82265A98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265A98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265A98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265A98);
		  /* 82265A98h */ case    0:  		/* mr R4, R27 */
		/* 82265A98h case    0:*/		regs.R4 = regs.R27;
		/* 82265A98h case    0:*/		return 0x82265A9C;
		  /* 82265A9Ch */ case    1:  		/* mr R3, R31 */
		/* 82265A9Ch case    1:*/		regs.R3 = regs.R31;
		/* 82265A9Ch case    1:*/		return 0x82265AA0;
		  /* 82265AA0h */ case    2:  		/* bl -73696 */
		/* 82265AA0h case    2:*/		regs.LR = 0x82265AA4; return 0x82253AC0;
		/* 82265AA0h case    2:*/		return 0x82265AA4;
	}
	return 0x82265AA4;
} // Block from 82265A98h-82265AA4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82265AA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265AA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265AA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265AA4);
		  /* 82265AA4h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82265AA4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82265AA4h case    0:*/		return 0x82265AA8;
		  /* 82265AA8h */ case    1:  		/* lwz R10, <#[R31 + 4]> */
		/* 82265AA8h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82265AA8h case    1:*/		return 0x82265AAC;
		  /* 82265AACh */ case    2:  		/* cmplw CR6, R27, R10 */
		/* 82265AACh case    2:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R10);
		/* 82265AACh case    2:*/		return 0x82265AB0;
		  /* 82265AB0h */ case    3:  		/* lwz R11, <#[R11 + 4]> */
		/* 82265AB0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82265AB0h case    3:*/		return 0x82265AB4;
		  /* 82265AB4h */ case    4:  		/* lwz R30, <#[R11 + 4]> */
		/* 82265AB4h case    4:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000004) );
		/* 82265AB4h case    4:*/		return 0x82265AB8;
		  /* 82265AB8h */ case    5:  		/* bc 4, CR6_LT, 16 */
		/* 82265AB8h case    5:*/		if ( !regs.CR[6].lt ) { return 0x82265AC8;  }
		/* 82265AB8h case    5:*/		return 0x82265ABC;
		  /* 82265ABCh */ case    6:  		/* lwz R11, <#[R31 + 8]> */
		/* 82265ABCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82265ABCh case    6:*/		return 0x82265AC0;
		  /* 82265AC0h */ case    7:  		/* add R3, R11, R25 */
		/* 82265AC0h case    7:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R25);
		/* 82265AC0h case    7:*/		return 0x82265AC4;
		  /* 82265AC4h */ case    8:  		/* b 16 */
		/* 82265AC4h case    8:*/		return 0x82265AD4;
		/* 82265AC4h case    8:*/		return 0x82265AC8;
	}
	return 0x82265AC8;
} // Block from 82265AA4h-82265AC8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82265AC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265AC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265AC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265AC8);
		  /* 82265AC8h */ case    0:  		/* mr R4, R27 */
		/* 82265AC8h case    0:*/		regs.R4 = regs.R27;
		/* 82265AC8h case    0:*/		return 0x82265ACC;
		  /* 82265ACCh */ case    1:  		/* mr R3, R31 */
		/* 82265ACCh case    1:*/		regs.R3 = regs.R31;
		/* 82265ACCh case    1:*/		return 0x82265AD0;
		  /* 82265AD0h */ case    2:  		/* bl -73744 */
		/* 82265AD0h case    2:*/		regs.LR = 0x82265AD4; return 0x82253AC0;
		/* 82265AD0h case    2:*/		return 0x82265AD4;
	}
	return 0x82265AD4;
} // Block from 82265AC8h-82265AD4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82265AD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265AD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265AD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265AD4);
		  /* 82265AD4h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82265AD4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82265AD4h case    0:*/		return 0x82265AD8;
		  /* 82265AD8h */ case    1:  		/* lwz R10, <#[R31 + 4]> */
		/* 82265AD8h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82265AD8h case    1:*/		return 0x82265ADC;
		  /* 82265ADCh */ case    2:  		/* cmplw CR6, R28, R10 */
		/* 82265ADCh case    2:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R10);
		/* 82265ADCh case    2:*/		return 0x82265AE0;
		  /* 82265AE0h */ case    3:  		/* lwz R11, <#[R11]> */
		/* 82265AE0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82265AE0h case    3:*/		return 0x82265AE4;
		  /* 82265AE4h */ case    4:  		/* addi R11, R11, -1 */
		/* 82265AE4h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82265AE4h case    4:*/		return 0x82265AE8;
		  /* 82265AE8h */ case    5:  		/* mullw R29, R11, R30 */
		/* 82265AE8h case    5:*/		cpu::op::mullw<0>(regs,&regs.R29,regs.R11,regs.R30);
		/* 82265AE8h case    5:*/		return 0x82265AEC;
		  /* 82265AECh */ case    6:  		/* bc 4, CR6_LT, 16 */
		/* 82265AECh case    6:*/		if ( !regs.CR[6].lt ) { return 0x82265AFC;  }
		/* 82265AECh case    6:*/		return 0x82265AF0;
		  /* 82265AF0h */ case    7:  		/* lwz R11, <#[R31 + 8]> */
		/* 82265AF0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82265AF0h case    7:*/		return 0x82265AF4;
		  /* 82265AF4h */ case    8:  		/* add R3, R11, R26 */
		/* 82265AF4h case    8:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R26);
		/* 82265AF4h case    8:*/		return 0x82265AF8;
		  /* 82265AF8h */ case    9:  		/* b 16 */
		/* 82265AF8h case    9:*/		return 0x82265B08;
		/* 82265AF8h case    9:*/		return 0x82265AFC;
	}
	return 0x82265AFC;
} // Block from 82265AD4h-82265AFCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 82265AFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265AFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265AFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265AFC);
		  /* 82265AFCh */ case    0:  		/* mr R4, R28 */
		/* 82265AFCh case    0:*/		regs.R4 = regs.R28;
		/* 82265AFCh case    0:*/		return 0x82265B00;
		  /* 82265B00h */ case    1:  		/* mr R3, R31 */
		/* 82265B00h case    1:*/		regs.R3 = regs.R31;
		/* 82265B00h case    1:*/		return 0x82265B04;
		  /* 82265B04h */ case    2:  		/* bl -73796 */
		/* 82265B04h case    2:*/		regs.LR = 0x82265B08; return 0x82253AC0;
		/* 82265B04h case    2:*/		return 0x82265B08;
	}
	return 0x82265B08;
} // Block from 82265AFCh-82265B08h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82265B08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265B08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265B08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265B08);
		  /* 82265B08h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82265B08h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82265B08h case    0:*/		return 0x82265B0C;
		  /* 82265B0Ch */ case    1:  		/* lwz R10, <#[R31 + 4]> */
		/* 82265B0Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 82265B0Ch case    1:*/		return 0x82265B10;
		  /* 82265B10h */ case    2:  		/* cmplw CR6, R28, R10 */
		/* 82265B10h case    2:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R10);
		/* 82265B10h case    2:*/		return 0x82265B14;
		  /* 82265B14h */ case    3:  		/* lwz R11, <#[R11 + 4]> */
		/* 82265B14h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82265B14h case    3:*/		return 0x82265B18;
		  /* 82265B18h */ case    4:  		/* lwz R30, <#[R11 + 4]> */
		/* 82265B18h case    4:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000004) );
		/* 82265B18h case    4:*/		return 0x82265B1C;
		  /* 82265B1Ch */ case    5:  		/* bc 4, CR6_LT, 16 */
		/* 82265B1Ch case    5:*/		if ( !regs.CR[6].lt ) { return 0x82265B2C;  }
		/* 82265B1Ch case    5:*/		return 0x82265B20;
		  /* 82265B20h */ case    6:  		/* lwz R11, <#[R31 + 8]> */
		/* 82265B20h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82265B20h case    6:*/		return 0x82265B24;
		  /* 82265B24h */ case    7:  		/* add R3, R11, R26 */
		/* 82265B24h case    7:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R26);
		/* 82265B24h case    7:*/		return 0x82265B28;
		  /* 82265B28h */ case    8:  		/* b 16 */
		/* 82265B28h case    8:*/		return 0x82265B38;
		/* 82265B28h case    8:*/		return 0x82265B2C;
	}
	return 0x82265B2C;
} // Block from 82265B08h-82265B2Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 82265B2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265B2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265B2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265B2C);
		  /* 82265B2Ch */ case    0:  		/* mr R4, R28 */
		/* 82265B2Ch case    0:*/		regs.R4 = regs.R28;
		/* 82265B2Ch case    0:*/		return 0x82265B30;
		  /* 82265B30h */ case    1:  		/* mr R3, R31 */
		/* 82265B30h case    1:*/		regs.R3 = regs.R31;
		/* 82265B30h case    1:*/		return 0x82265B34;
		  /* 82265B34h */ case    2:  		/* bl -73844 */
		/* 82265B34h case    2:*/		regs.LR = 0x82265B38; return 0x82253AC0;
		/* 82265B34h case    2:*/		return 0x82265B38;
	}
	return 0x82265B38;
} // Block from 82265B2Ch-82265B38h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82265B38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265B38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265B38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265B38);
		  /* 82265B38h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82265B38h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82265B38h case    0:*/		return 0x82265B3C;
		  /* 82265B3Ch */ case    1:  		/* lwz R11, <#[R11]> */
		/* 82265B3Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 82265B3Ch case    1:*/		return 0x82265B40;
		  /* 82265B40h */ case    2:  		/* addi R11, R11, -1 */
		/* 82265B40h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82265B40h case    2:*/		return 0x82265B44;
		  /* 82265B44h */ case    3:  		/* mullw R11, R11, R30 */
		/* 82265B44h case    3:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 82265B44h case    3:*/		return 0x82265B48;
		  /* 82265B48h */ case    4:  		/* cmpw CR6, R29, R11 */
		/* 82265B48h case    4:*/		cpu::op::cmpw<6>(regs,regs.R29,regs.R11);
		/* 82265B48h case    4:*/		return 0x82265B4C;
		  /* 82265B4Ch */ case    5:  		/* bc 4, CR6_LT, 168 */
		/* 82265B4Ch case    5:*/		if ( !regs.CR[6].lt ) { return 0x82265BF4;  }
		/* 82265B4Ch case    5:*/		return 0x82265B50;
		  /* 82265B50h */ case    6:  		/* lwz R11, <#[R31 + 4]> */
		/* 82265B50h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82265B50h case    6:*/		return 0x82265B54;
		  /* 82265B54h */ case    7:  		/* cmplw CR6, R27, R11 */
		/* 82265B54h case    7:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 82265B54h case    7:*/		return 0x82265B58;
		  /* 82265B58h */ case    8:  		/* bc 4, CR6_LT, 16 */
		/* 82265B58h case    8:*/		if ( !regs.CR[6].lt ) { return 0x82265B68;  }
		/* 82265B58h case    8:*/		return 0x82265B5C;
		  /* 82265B5Ch */ case    9:  		/* lwz R11, <#[R31 + 8]> */
		/* 82265B5Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82265B5Ch case    9:*/		return 0x82265B60;
		  /* 82265B60h */ case   10:  		/* add R3, R11, R25 */
		/* 82265B60h case   10:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R25);
		/* 82265B60h case   10:*/		return 0x82265B64;
		  /* 82265B64h */ case   11:  		/* b 16 */
		/* 82265B64h case   11:*/		return 0x82265B74;
		/* 82265B64h case   11:*/		return 0x82265B68;
	}
	return 0x82265B68;
} // Block from 82265B38h-82265B68h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82265B68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265B68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265B68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265B68);
		  /* 82265B68h */ case    0:  		/* mr R4, R27 */
		/* 82265B68h case    0:*/		regs.R4 = regs.R27;
		/* 82265B68h case    0:*/		return 0x82265B6C;
		  /* 82265B6Ch */ case    1:  		/* mr R3, R31 */
		/* 82265B6Ch case    1:*/		regs.R3 = regs.R31;
		/* 82265B6Ch case    1:*/		return 0x82265B70;
		  /* 82265B70h */ case    2:  		/* bl -73904 */
		/* 82265B70h case    2:*/		regs.LR = 0x82265B74; return 0x82253AC0;
		/* 82265B70h case    2:*/		return 0x82265B74;
	}
	return 0x82265B74;
} // Block from 82265B68h-82265B74h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82265B74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265B74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265B74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265B74);
		  /* 82265B74h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 82265B74h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82265B74h case    0:*/		return 0x82265B78;
		  /* 82265B78h */ case    1:  		/* lwz R29, <#[R3]> */
		/* 82265B78h case    1:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 82265B78h case    1:*/		return 0x82265B7C;
		  /* 82265B7Ch */ case    2:  		/* cmplw CR6, R28, R11 */
		/* 82265B7Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 82265B7Ch case    2:*/		return 0x82265B80;
		  /* 82265B80h */ case    3:  		/* bc 4, CR6_LT, 16 */
		/* 82265B80h case    3:*/		if ( !regs.CR[6].lt ) { return 0x82265B90;  }
		/* 82265B80h case    3:*/		return 0x82265B84;
		  /* 82265B84h */ case    4:  		/* lwz R11, <#[R31 + 8]> */
		/* 82265B84h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82265B84h case    4:*/		return 0x82265B88;
		  /* 82265B88h */ case    5:  		/* add R30, R11, R26 */
		/* 82265B88h case    5:*/		cpu::op::add<0>(regs,&regs.R30,regs.R11,regs.R26);
		/* 82265B88h case    5:*/		return 0x82265B8C;
		  /* 82265B8Ch */ case    6:  		/* b 20 */
		/* 82265B8Ch case    6:*/		return 0x82265BA0;
		/* 82265B8Ch case    6:*/		return 0x82265B90;
	}
	return 0x82265B90;
} // Block from 82265B74h-82265B90h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82265B90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265B90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265B90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265B90);
		  /* 82265B90h */ case    0:  		/* mr R4, R28 */
		/* 82265B90h case    0:*/		regs.R4 = regs.R28;
		/* 82265B90h case    0:*/		return 0x82265B94;
		  /* 82265B94h */ case    1:  		/* mr R3, R31 */
		/* 82265B94h case    1:*/		regs.R3 = regs.R31;
		/* 82265B94h case    1:*/		return 0x82265B98;
		  /* 82265B98h */ case    2:  		/* bl -73944 */
		/* 82265B98h case    2:*/		regs.LR = 0x82265B9C; return 0x82253AC0;
		/* 82265B98h case    2:*/		return 0x82265B9C;
		  /* 82265B9Ch */ case    3:  		/* mr R30, R3 */
		/* 82265B9Ch case    3:*/		regs.R30 = regs.R3;
		/* 82265B9Ch case    3:*/		return 0x82265BA0;
	}
	return 0x82265BA0;
} // Block from 82265B90h-82265BA0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82265BA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265BA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265BA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265BA0);
		  /* 82265BA0h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 82265BA0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82265BA0h case    0:*/		return 0x82265BA4;
		  /* 82265BA4h */ case    1:  		/* cmplw CR6, R27, R11 */
		/* 82265BA4h case    1:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 82265BA4h case    1:*/		return 0x82265BA8;
		  /* 82265BA8h */ case    2:  		/* bc 4, CR6_LT, 16 */
		/* 82265BA8h case    2:*/		if ( !regs.CR[6].lt ) { return 0x82265BB8;  }
		/* 82265BA8h case    2:*/		return 0x82265BAC;
		  /* 82265BACh */ case    3:  		/* lwz R11, <#[R31 + 8]> */
		/* 82265BACh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82265BACh case    3:*/		return 0x82265BB0;
		  /* 82265BB0h */ case    4:  		/* add R3, R11, R25 */
		/* 82265BB0h case    4:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R25);
		/* 82265BB0h case    4:*/		return 0x82265BB4;
		  /* 82265BB4h */ case    5:  		/* b 16 */
		/* 82265BB4h case    5:*/		return 0x82265BC4;
		/* 82265BB4h case    5:*/		return 0x82265BB8;
	}
	return 0x82265BB8;
} // Block from 82265BA0h-82265BB8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82265BB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265BB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265BB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265BB8);
		  /* 82265BB8h */ case    0:  		/* mr R4, R27 */
		/* 82265BB8h case    0:*/		regs.R4 = regs.R27;
		/* 82265BB8h case    0:*/		return 0x82265BBC;
		  /* 82265BBCh */ case    1:  		/* mr R3, R31 */
		/* 82265BBCh case    1:*/		regs.R3 = regs.R31;
		/* 82265BBCh case    1:*/		return 0x82265BC0;
		  /* 82265BC0h */ case    2:  		/* bl -73984 */
		/* 82265BC0h case    2:*/		regs.LR = 0x82265BC4; return 0x82253AC0;
		/* 82265BC0h case    2:*/		return 0x82265BC4;
	}
	return 0x82265BC4;
} // Block from 82265BB8h-82265BC4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82265BC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265BC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265BC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265BC4);
		  /* 82265BC4h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 82265BC4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82265BC4h case    0:*/		return 0x82265BC8;
		  /* 82265BC8h */ case    1:  		/* stw R11, <#[R3]> */
		/* 82265BC8h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82265BC8h case    1:*/		return 0x82265BCC;
		  /* 82265BCCh */ case    2:  		/* lwz R11, <#[R31 + 4]> */
		/* 82265BCCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82265BCCh case    2:*/		return 0x82265BD0;
		  /* 82265BD0h */ case    3:  		/* cmplw CR6, R28, R11 */
		/* 82265BD0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 82265BD0h case    3:*/		return 0x82265BD4;
		  /* 82265BD4h */ case    4:  		/* bc 4, CR6_LT, 16 */
		/* 82265BD4h case    4:*/		if ( !regs.CR[6].lt ) { return 0x82265BE4;  }
		/* 82265BD4h case    4:*/		return 0x82265BD8;
		  /* 82265BD8h */ case    5:  		/* lwz R11, <#[R31 + 8]> */
		/* 82265BD8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82265BD8h case    5:*/		return 0x82265BDC;
		  /* 82265BDCh */ case    6:  		/* add R3, R11, R26 */
		/* 82265BDCh case    6:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R26);
		/* 82265BDCh case    6:*/		return 0x82265BE0;
		  /* 82265BE0h */ case    7:  		/* b 16 */
		/* 82265BE0h case    7:*/		return 0x82265BF0;
		/* 82265BE0h case    7:*/		return 0x82265BE4;
	}
	return 0x82265BE4;
} // Block from 82265BC4h-82265BE4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82265BE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265BE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265BE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265BE4);
		  /* 82265BE4h */ case    0:  		/* mr R4, R28 */
		/* 82265BE4h case    0:*/		regs.R4 = regs.R28;
		/* 82265BE4h case    0:*/		return 0x82265BE8;
		  /* 82265BE8h */ case    1:  		/* mr R3, R31 */
		/* 82265BE8h case    1:*/		regs.R3 = regs.R31;
		/* 82265BE8h case    1:*/		return 0x82265BEC;
		  /* 82265BECh */ case    2:  		/* bl -74028 */
		/* 82265BECh case    2:*/		regs.LR = 0x82265BF0; return 0x82253AC0;
		/* 82265BECh case    2:*/		return 0x82265BF0;
	}
	return 0x82265BF0;
} // Block from 82265BE4h-82265BF0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82265BF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265BF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265BF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265BF0);
		  /* 82265BF0h */ case    0:  		/* stw R29, <#[R3]> */
		/* 82265BF0h case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 82265BF0h case    0:*/		return 0x82265BF4;
	}
	return 0x82265BF4;
} // Block from 82265BF0h-82265BF4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82265BF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265BF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265BF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265BF4);
		  /* 82265BF4h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 82265BF4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82265BF4h case    0:*/		return 0x82265BF8;
		  /* 82265BF8h */ case    1:  		/* addi R28, R28, 1 */
		/* 82265BF8h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 82265BF8h case    1:*/		return 0x82265BFC;
		  /* 82265BFCh */ case    2:  		/* addi R26, R26, 4 */
		/* 82265BFCh case    2:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x4);
		/* 82265BFCh case    2:*/		return 0x82265C00;
		  /* 82265C00h */ case    3:  		/* cmplw CR6, R28, R11 */
		/* 82265C00h case    3:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 82265C00h case    3:*/		return 0x82265C04;
		  /* 82265C04h */ case    4:  		/* bc 12, CR6_LT, -384 */
		/* 82265C04h case    4:*/		if ( regs.CR[6].lt ) { return 0x82265A84;  }
		/* 82265C04h case    4:*/		return 0x82265C08;
	}
	return 0x82265C08;
} // Block from 82265BF4h-82265C08h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82265C08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265C08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265C08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265C08);
		  /* 82265C08h */ case    0:  		/* mr R27, R24 */
		/* 82265C08h case    0:*/		regs.R27 = regs.R24;
		/* 82265C08h case    0:*/		return 0x82265C0C;
		  /* 82265C0Ch */ case    1:  		/* addi R25, R25, 4 */
		/* 82265C0Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x4);
		/* 82265C0Ch case    1:*/		return 0x82265C10;
		  /* 82265C10h */ case    2:  		/* cmpw CR6, R24, R23 */
		/* 82265C10h case    2:*/		cpu::op::cmpw<6>(regs,regs.R24,regs.R23);
		/* 82265C10h case    2:*/		return 0x82265C14;
		  /* 82265C14h */ case    3:  		/* bc 12, CR6_LT, -420 */
		/* 82265C14h case    3:*/		if ( regs.CR[6].lt ) { return 0x82265A70;  }
		/* 82265C14h case    3:*/		return 0x82265C18;
	}
	return 0x82265C18;
} // Block from 82265C08h-82265C18h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82265C18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265C18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265C18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265C18);
		  /* 82265C18h */ case    0:  		/* addi R1, R1, 160 */
		/* 82265C18h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 82265C18h case    0:*/		return 0x82265C1C;
		  /* 82265C1Ch */ case    1:  		/* b -1919368 */
		/* 82265C1Ch case    1:*/		return 0x82091294;
		/* 82265C1Ch case    1:*/		return 0x82265C20;
	}
	return 0x82265C20;
} // Block from 82265C18h-82265C20h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82265C20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265C20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265C20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265C20);
		  /* 82265C20h */ case    0:  		/* mfspr R12, LR */
		/* 82265C20h case    0:*/		regs.R12 = regs.LR;
		/* 82265C20h case    0:*/		return 0x82265C24;
		  /* 82265C24h */ case    1:  		/* bl -1919456 */
		/* 82265C24h case    1:*/		regs.LR = 0x82265C28; return 0x82091244;
		/* 82265C24h case    1:*/		return 0x82265C28;
		  /* 82265C28h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 82265C28h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82265C28h case    2:*/		return 0x82265C2C;
		  /* 82265C2Ch */ case    3:  		/* lwz R29, <#[R7 + 1456]> */
		/* 82265C2Ch case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R7 + 0x000005B0) );
		/* 82265C2Ch case    3:*/		return 0x82265C30;
		  /* 82265C30h */ case    4:  		/* mr R30, R3 */
		/* 82265C30h case    4:*/		regs.R30 = regs.R3;
		/* 82265C30h case    4:*/		return 0x82265C34;
		  /* 82265C34h */ case    5:  		/* mr R23, R4 */
		/* 82265C34h case    5:*/		regs.R23 = regs.R4;
		/* 82265C34h case    5:*/		return 0x82265C38;
		  /* 82265C38h */ case    6:  		/* li R4, 20 */
		/* 82265C38h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 82265C38h case    6:*/		return 0x82265C3C;
		  /* 82265C3Ch */ case    7:  		/* mr R3, R29 */
		/* 82265C3Ch case    7:*/		regs.R3 = regs.R29;
		/* 82265C3Ch case    7:*/		return 0x82265C40;
		  /* 82265C40h */ case    8:  		/* mr R25, R7 */
		/* 82265C40h case    8:*/		regs.R25 = regs.R7;
		/* 82265C40h case    8:*/		return 0x82265C44;
		  /* 82265C44h */ case    9:  		/* bl -300940 */
		/* 82265C44h case    9:*/		regs.LR = 0x82265C48; return 0x8221C4B8;
		/* 82265C44h case    9:*/		return 0x82265C48;
		  /* 82265C48h */ case   10:  		/* li R24, 0 */
		/* 82265C48h case   10:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 82265C48h case   10:*/		return 0x82265C4C;
		  /* 82265C4Ch */ case   11:  		/* addic. R31, R3, 4 */
		/* 82265C4Ch case   11:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R3,0x4);
		/* 82265C4Ch case   11:*/		return 0x82265C50;
		  /* 82265C50h */ case   12:  		/* stw R29, <#[R3]> */
		/* 82265C50h case   12:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 82265C50h case   12:*/		return 0x82265C54;
		  /* 82265C54h */ case   13:  		/* bc 12, CR0_EQ, 24 */
		/* 82265C54h case   13:*/		if ( regs.CR[0].eq ) { return 0x82265C6C;  }
		/* 82265C54h case   13:*/		return 0x82265C58;
		  /* 82265C58h */ case   14:  		/* mr R3, R31 */
		/* 82265C58h case   14:*/		regs.R3 = regs.R31;
		/* 82265C58h case   14:*/		return 0x82265C5C;
		  /* 82265C5Ch */ case   15:  		/* lwz R4, <#[R25 + 1456]> */
		/* 82265C5Ch case   15:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R25 + 0x000005B0) );
		/* 82265C5Ch case   15:*/		return 0x82265C60;
		  /* 82265C60h */ case   16:  		/* bl -196352 */
		/* 82265C60h case   16:*/		regs.LR = 0x82265C64; return 0x82235D60;
		/* 82265C60h case   16:*/		return 0x82265C64;
		  /* 82265C64h */ case   17:  		/* mr R26, R31 */
		/* 82265C64h case   17:*/		regs.R26 = regs.R31;
		/* 82265C64h case   17:*/		return 0x82265C68;
		  /* 82265C68h */ case   18:  		/* b 8 */
		/* 82265C68h case   18:*/		return 0x82265C70;
		/* 82265C68h case   18:*/		return 0x82265C6C;
	}
	return 0x82265C6C;
} // Block from 82265C20h-82265C6Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 82265C6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265C6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265C6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265C6C);
		  /* 82265C6Ch */ case    0:  		/* mr R26, R24 */
		/* 82265C6Ch case    0:*/		regs.R26 = regs.R24;
		/* 82265C6Ch case    0:*/		return 0x82265C70;
	}
	return 0x82265C70;
} // Block from 82265C6Ch-82265C70h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82265C70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265C70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265C70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265C70);
		  /* 82265C70h */ case    0:  		/* stw R24, <#[R30 + 8]> */
		/* 82265C70h case    0:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R30 + 0x00000008) );
		/* 82265C70h case    0:*/		return 0x82265C74;
		  /* 82265C74h */ case    1:  		/* li R4, 20 */
		/* 82265C74h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 82265C74h case    1:*/		return 0x82265C78;
		  /* 82265C78h */ case    2:  		/* lwz R29, <#[R25 + 1456]> */
		/* 82265C78h case    2:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R25 + 0x000005B0) );
		/* 82265C78h case    2:*/		return 0x82265C7C;
		  /* 82265C7Ch */ case    3:  		/* mr R3, R29 */
		/* 82265C7Ch case    3:*/		regs.R3 = regs.R29;
		/* 82265C7Ch case    3:*/		return 0x82265C80;
		  /* 82265C80h */ case    4:  		/* mr R27, R24 */
		/* 82265C80h case    4:*/		regs.R27 = regs.R24;
		/* 82265C80h case    4:*/		return 0x82265C84;
		  /* 82265C84h */ case    5:  		/* bl -301004 */
		/* 82265C84h case    5:*/		regs.LR = 0x82265C88; return 0x8221C4B8;
		/* 82265C84h case    5:*/		return 0x82265C88;
		  /* 82265C88h */ case    6:  		/* addic. R31, R3, 4 */
		/* 82265C88h case    6:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R3,0x4);
		/* 82265C88h case    6:*/		return 0x82265C8C;
		  /* 82265C8Ch */ case    7:  		/* stw R29, <#[R3]> */
		/* 82265C8Ch case    7:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 82265C8Ch case    7:*/		return 0x82265C90;
		  /* 82265C90h */ case    8:  		/* bc 12, CR0_EQ, 24 */
		/* 82265C90h case    8:*/		if ( regs.CR[0].eq ) { return 0x82265CA8;  }
		/* 82265C90h case    8:*/		return 0x82265C94;
		  /* 82265C94h */ case    9:  		/* mr R3, R31 */
		/* 82265C94h case    9:*/		regs.R3 = regs.R31;
		/* 82265C94h case    9:*/		return 0x82265C98;
		  /* 82265C98h */ case   10:  		/* lwz R4, <#[R25 + 1456]> */
		/* 82265C98h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R25 + 0x000005B0) );
		/* 82265C98h case   10:*/		return 0x82265C9C;
		  /* 82265C9Ch */ case   11:  		/* bl -196412 */
		/* 82265C9Ch case   11:*/		regs.LR = 0x82265CA0; return 0x82235D60;
		/* 82265C9Ch case   11:*/		return 0x82265CA0;
		  /* 82265CA0h */ case   12:  		/* mr R28, R31 */
		/* 82265CA0h case   12:*/		regs.R28 = regs.R31;
		/* 82265CA0h case   12:*/		return 0x82265CA4;
		  /* 82265CA4h */ case   13:  		/* b 8 */
		/* 82265CA4h case   13:*/		return 0x82265CAC;
		/* 82265CA4h case   13:*/		return 0x82265CA8;
	}
	return 0x82265CA8;
} // Block from 82265C70h-82265CA8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82265CA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265CA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265CA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265CA8);
		  /* 82265CA8h */ case    0:  		/* mr R28, R24 */
		/* 82265CA8h case    0:*/		regs.R28 = regs.R24;
		/* 82265CA8h case    0:*/		return 0x82265CAC;
	}
	return 0x82265CAC;
} // Block from 82265CA8h-82265CACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82265CACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265CAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265CAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265CAC);
		  /* 82265CACh */ case    0:  		/* lwz R31, <#[R30 + 20]> */
		/* 82265CACh case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000014) );
		/* 82265CACh case    0:*/		return 0x82265CB0;
		  /* 82265CB0h */ case    1:  		/* mr R29, R24 */
		/* 82265CB0h case    1:*/		regs.R29 = regs.R24;
		/* 82265CB0h case    1:*/		return 0x82265CB4;
		  /* 82265CB4h */ case    2:  		/* rlwinm. R11, R29, 0, 24, 31 */
		/* 82265CB4h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R29);
		/* 82265CB4h case    2:*/		return 0x82265CB8;
		  /* 82265CB8h */ case    3:  		/* bc 4, CR0_EQ, 152 */
		/* 82265CB8h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82265D50;  }
		/* 82265CB8h case    3:*/		return 0x82265CBC;
		  /* 82265CBCh */ case    4:  		/* lwz R11, <#[R31 + 20]> */
		/* 82265CBCh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82265CBCh case    4:*/		return 0x82265CC0;
		  /* 82265CC0h */ case    5:  		/* lwz R10, <#[R31]> */
		/* 82265CC0h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 82265CC0h case    5:*/		return 0x82265CC4;
		  /* 82265CC4h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 82265CC4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82265CC4h case    6:*/		return 0x82265CC8;
		  /* 82265CC8h */ case    7:  		/* bc 12, CR6_EQ, 92 */
		/* 82265CC8h case    7:*/		if ( regs.CR[6].eq ) { return 0x82265D24;  }
		/* 82265CC8h case    7:*/		return 0x82265CCC;
		  /* 82265CCCh */ case    8:  		/* lwz R11, <#[R31 + 4]> */
		/* 82265CCCh case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82265CCCh case    8:*/		return 0x82265CD0;
		  /* 82265CD0h */ case    9:  		/* subf R11, R10, R11 */
		/* 82265CD0h case    9:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82265CD0h case    9:*/		return 0x82265CD4;
		  /* 82265CD4h */ case   10:  		/* addic. R11, R11, 1 */
		/* 82265CD4h case   10:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0x1);
		/* 82265CD4h case   10:*/		return 0x82265CD8;
		  /* 82265CD8h */ case   11:  		/* stw R11, <#[R31 + 8]> */
		/* 82265CD8h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82265CD8h case   11:*/		return 0x82265CDC;
		  /* 82265CDCh */ case   12:  		/* bc 4, CR0_LT, 8 */
		/* 82265CDCh case   12:*/		if ( !regs.CR[0].lt ) { return 0x82265CE4;  }
		/* 82265CDCh case   12:*/		return 0x82265CE0;
		  /* 82265CE0h */ case   13:  		/* stw R24, <#[R31 + 8]> */
		/* 82265CE0h case   13:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00000008) );
		/* 82265CE0h case   13:*/		return 0x82265CE4;
	}
	return 0x82265CE4;
} // Block from 82265CACh-82265CE4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82265CE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265CE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265CE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265CE4);
		  /* 82265CE4h */ case    0:  		/* lwz R10, <#[R30 + 8]> */
		/* 82265CE4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 82265CE4h case    0:*/		return 0x82265CE8;
		  /* 82265CE8h */ case    1:  		/* mr R3, R26 */
		/* 82265CE8h case    1:*/		regs.R3 = regs.R26;
		/* 82265CE8h case    1:*/		return 0x82265CEC;
		  /* 82265CECh */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 82265CECh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82265CECh case    2:*/		return 0x82265CF0;
		  /* 82265CF0h */ case    3:  		/* add R11, R10, R11 */
		/* 82265CF0h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82265CF0h case    3:*/		return 0x82265CF4;
		  /* 82265CF4h */ case    4:  		/* stw R11, <#[R31 + 8]> */
		/* 82265CF4h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82265CF4h case    4:*/		return 0x82265CF8;
		  /* 82265CF8h */ case    5:  		/* lwz R4, <#[R26 + 4]> */
		/* 82265CF8h case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R26 + 0x00000004) );
		/* 82265CF8h case    5:*/		return 0x82265CFC;
		  /* 82265CFCh */ case    6:  		/* bl -74300 */
		/* 82265CFCh case    6:*/		regs.LR = 0x82265D00; return 0x82253AC0;
		/* 82265CFCh case    6:*/		return 0x82265D00;
		  /* 82265D00h */ case    7:  		/* mr R11, R3 */
		/* 82265D00h case    7:*/		regs.R11 = regs.R3;
		/* 82265D00h case    7:*/		return 0x82265D04;
		  /* 82265D04h */ case    8:  		/* stw R31, <#[R11]> */
		/* 82265D04h case    8:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000000) );
		/* 82265D04h case    8:*/		return 0x82265D08;
		  /* 82265D08h */ case    9:  		/* mr R3, R28 */
		/* 82265D08h case    9:*/		regs.R3 = regs.R28;
		/* 82265D08h case    9:*/		return 0x82265D0C;
		  /* 82265D0Ch */ case   10:  		/* lwz R4, <#[R28 + 4]> */
		/* 82265D0Ch case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x00000004) );
		/* 82265D0Ch case   10:*/		return 0x82265D10;
		  /* 82265D10h */ case   11:  		/* bl -74320 */
		/* 82265D10h case   11:*/		regs.LR = 0x82265D14; return 0x82253AC0;
		/* 82265D10h case   11:*/		return 0x82265D14;
		  /* 82265D14h */ case   12:  		/* stw R30, <#[R3]> */
		/* 82265D14h case   12:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 82265D14h case   12:*/		return 0x82265D18;
		  /* 82265D18h */ case   13:  		/* mr R30, R31 */
		/* 82265D18h case   13:*/		regs.R30 = regs.R31;
		/* 82265D18h case   13:*/		return 0x82265D1C;
		  /* 82265D1Ch */ case   14:  		/* lwz R31, <#[R31 + 20]> */
		/* 82265D1Ch case   14:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000014) );
		/* 82265D1Ch case   14:*/		return 0x82265D20;
		  /* 82265D20h */ case   15:  		/* b -108 */
		/* 82265D20h case   15:*/		return 0x82265CB4;
		/* 82265D20h case   15:*/		return 0x82265D24;
	}
	return 0x82265D24;
} // Block from 82265CE4h-82265D24h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82265D24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265D24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265D24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265D24);
		  /* 82265D24h */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 82265D24h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 82265D24h case    0:*/		return 0x82265D28;
		  /* 82265D28h */ case    1:  		/* subf R11, R11, R10 */
		/* 82265D28h case    1:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82265D28h case    1:*/		return 0x82265D2C;
		  /* 82265D2Ch */ case    2:  		/* stw R11, <#[R31 + 12]> */
		/* 82265D2Ch case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82265D2Ch case    2:*/		return 0x82265D30;
		  /* 82265D30h */ case    3:  		/* lwz R11, <#[R30 + 24]> */
		/* 82265D30h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 82265D30h case    3:*/		return 0x82265D34;
		  /* 82265D34h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82265D34h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82265D34h case    4:*/		return 0x82265D38;
		  /* 82265D38h */ case    5:  		/* bc 4, CR6_EQ, 8 */
		/* 82265D38h case    5:*/		if ( !regs.CR[6].eq ) { return 0x82265D40;  }
		/* 82265D38h case    5:*/		return 0x82265D3C;
		  /* 82265D3Ch */ case    6:  		/* stw R31, <#[R30 + 24]> */
		/* 82265D3Ch case    6:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000018) );
		/* 82265D3Ch case    6:*/		return 0x82265D40;
	}
	return 0x82265D40;
} // Block from 82265D24h-82265D40h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82265D40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265D40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265D40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265D40);
		  /* 82265D40h */ case    0:  		/* cmplwi CR6, R27, 0 */
		/* 82265D40h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 82265D40h case    0:*/		return 0x82265D44;
		  /* 82265D44h */ case    1:  		/* bc 12, CR6_EQ, 8 */
		/* 82265D44h case    1:*/		if ( regs.CR[6].eq ) { return 0x82265D4C;  }
		/* 82265D44h case    1:*/		return 0x82265D48;
		  /* 82265D48h */ case    2:  		/* stw R31, <#[R27 + 32]> */
		/* 82265D48h case    2:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R27 + 0x00000020) );
		/* 82265D48h case    2:*/		return 0x82265D4C;
	}
	return 0x82265D4C;
} // Block from 82265D40h-82265D4Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82265D4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265D4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265D4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265D4C);
		  /* 82265D4Ch */ case    0:  		/* mr R27, R31 */
		/* 82265D4Ch case    0:*/		regs.R27 = regs.R31;
		/* 82265D4Ch case    0:*/		return 0x82265D50;
	}
	return 0x82265D50;
} // Block from 82265D4Ch-82265D50h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82265D50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265D50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265D50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265D50);
		  /* 82265D50h */ case    0:  		/* mr R11, R31 */
		/* 82265D50h case    0:*/		regs.R11 = regs.R31;
		/* 82265D50h case    0:*/		return 0x82265D54;
		  /* 82265D54h */ case    1:  		/* lwz R31, <#[R31 + 16]> */
		/* 82265D54h case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000010) );
		/* 82265D54h case    1:*/		return 0x82265D58;
		  /* 82265D58h */ case    2:  		/* mr R29, R24 */
		/* 82265D58h case    2:*/		regs.R29 = regs.R24;
		/* 82265D58h case    2:*/		return 0x82265D5C;
		  /* 82265D5Ch */ case    3:  		/* cmplwi CR6, R31, 0 */
		/* 82265D5Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82265D5Ch case    3:*/		return 0x82265D60;
		  /* 82265D60h */ case    4:  		/* bc 4, CR6_EQ, -172 */
		/* 82265D60h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82265CB4;  }
		/* 82265D60h case    4:*/		return 0x82265D64;
		  /* 82265D64h */ case    5:  		/* lwz R10, <#[R30 + 28]> */
		/* 82265D64h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000001C) );
		/* 82265D64h case    5:*/		return 0x82265D68;
		  /* 82265D68h */ case    6:  		/* cmplwi CR6, R10, 0 */
		/* 82265D68h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82265D68h case    6:*/		return 0x82265D6C;
		  /* 82265D6Ch */ case    7:  		/* bc 4, CR6_EQ, 24 */
		/* 82265D6Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x82265D84;  }
		/* 82265D6Ch case    7:*/		return 0x82265D70;
		  /* 82265D70h */ case    8:  		/* lwz R10, <#[R11 + 20]> */
		/* 82265D70h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000014) );
		/* 82265D70h case    8:*/		return 0x82265D74;
		  /* 82265D74h */ case    9:  		/* cmplwi CR6, R10, 0 */
		/* 82265D74h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82265D74h case    9:*/		return 0x82265D78;
		  /* 82265D78h */ case   10:  		/* bc 12, CR6_EQ, 8 */
		/* 82265D78h case   10:*/		if ( regs.CR[6].eq ) { return 0x82265D80;  }
		/* 82265D78h case   10:*/		return 0x82265D7C;
		  /* 82265D7Ch */ case   11:  		/* lwz R11, <#[R11 + 28]> */
		/* 82265D7Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 82265D7Ch case   11:*/		return 0x82265D80;
	}
	return 0x82265D80;
} // Block from 82265D50h-82265D80h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82265D80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265D80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265D80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265D80);
		  /* 82265D80h */ case    0:  		/* stw R11, <#[R30 + 28]> */
		/* 82265D80h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 82265D80h case    0:*/		return 0x82265D84;
	}
	return 0x82265D84;
} // Block from 82265D80h-82265D84h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82265D84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265D84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265D84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265D84);
		  /* 82265D84h */ case    0:  		/* lwz R11, <#[R28 + 4]> */
		/* 82265D84h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 82265D84h case    0:*/		return 0x82265D88;
		  /* 82265D88h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82265D88h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82265D88h case    1:*/		return 0x82265D8C;
		  /* 82265D8Ch */ case    2:  		/* bc 12, CR6_EQ, 68 */
		/* 82265D8Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x82265DD0;  }
		/* 82265D8Ch case    2:*/		return 0x82265D90;
		  /* 82265D90h */ case    3:  		/* mr R3, R28 */
		/* 82265D90h case    3:*/		regs.R3 = regs.R28;
		/* 82265D90h case    3:*/		return 0x82265D94;
		  /* 82265D94h */ case    4:  		/* mr R31, R30 */
		/* 82265D94h case    4:*/		regs.R31 = regs.R30;
		/* 82265D94h case    4:*/		return 0x82265D98;
		  /* 82265D98h */ case    5:  		/* bl -45128 */
		/* 82265D98h case    5:*/		regs.LR = 0x82265D9C; return 0x8225AD50;
		/* 82265D98h case    5:*/		return 0x82265D9C;
		  /* 82265D9Ch */ case    6:  		/* lwz R11, <#[R3 + 24]> */
		/* 82265D9Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82265D9Ch case    6:*/		return 0x82265DA0;
		  /* 82265DA0h */ case    7:  		/* mr R30, R3 */
		/* 82265DA0h case    7:*/		regs.R30 = regs.R3;
		/* 82265DA0h case    7:*/		return 0x82265DA4;
		  /* 82265DA4h */ case    8:  		/* li R29, 1 */
		/* 82265DA4h case    8:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 82265DA4h case    8:*/		return 0x82265DA8;
		  /* 82265DA8h */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 82265DA8h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82265DA8h case    9:*/		return 0x82265DAC;
		  /* 82265DACh */ case   10:  		/* bc 4, CR6_EQ, -248 */
		/* 82265DACh case   10:*/		if ( !regs.CR[6].eq ) { return 0x82265CB4;  }
		/* 82265DACh case   10:*/		return 0x82265DB0;
		  /* 82265DB0h */ case   11:  		/* lwz R11, <#[R31 + 20]> */
		/* 82265DB0h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 82265DB0h case   11:*/		return 0x82265DB4;
		  /* 82265DB4h */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 82265DB4h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82265DB4h case   12:*/		return 0x82265DB8;
		  /* 82265DB8h */ case   13:  		/* bc 12, CR6_EQ, 12 */
		/* 82265DB8h case   13:*/		if ( regs.CR[6].eq ) { return 0x82265DC4;  }
		/* 82265DB8h case   13:*/		return 0x82265DBC;
		  /* 82265DBCh */ case   14:  		/* lwz R11, <#[R31 + 24]> */
		/* 82265DBCh case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 82265DBCh case   14:*/		return 0x82265DC0;
		  /* 82265DC0h */ case   15:  		/* b 8 */
		/* 82265DC0h case   15:*/		return 0x82265DC8;
		/* 82265DC0h case   15:*/		return 0x82265DC4;
	}
	return 0x82265DC4;
} // Block from 82265D84h-82265DC4h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82265DC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265DC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265DC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265DC4);
		  /* 82265DC4h */ case    0:  		/* mr R11, R31 */
		/* 82265DC4h case    0:*/		regs.R11 = regs.R31;
		/* 82265DC4h case    0:*/		return 0x82265DC8;
	}
	return 0x82265DC8;
} // Block from 82265DC4h-82265DC8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82265DC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265DC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265DC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265DC8);
		  /* 82265DC8h */ case    0:  		/* stw R11, <#[R30 + 24]> */
		/* 82265DC8h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 82265DC8h case    0:*/		return 0x82265DCC;
		  /* 82265DCCh */ case    1:  		/* b -280 */
		/* 82265DCCh case    1:*/		return 0x82265CB4;
		/* 82265DCCh case    1:*/		return 0x82265DD0;
	}
	return 0x82265DD0;
} // Block from 82265DC8h-82265DD0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82265DD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265DD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265DD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265DD0);
		  /* 82265DD0h */ case    0:  		/* lwz R11, <#[R26 + 4]> */
		/* 82265DD0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000004) );
		/* 82265DD0h case    0:*/		return 0x82265DD4;
		  /* 82265DD4h */ case    1:  		/* mr R28, R24 */
		/* 82265DD4h case    1:*/		regs.R28 = regs.R24;
		/* 82265DD4h case    1:*/		return 0x82265DD8;
		  /* 82265DD8h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 82265DD8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82265DD8h case    2:*/		return 0x82265DDC;
		  /* 82265DDCh */ case    3:  		/* bc 12, CR6_EQ, 204 */
		/* 82265DDCh case    3:*/		if ( regs.CR[6].eq ) { return 0x82265EA8;  }
		/* 82265DDCh case    3:*/		return 0x82265DE0;
		  /* 82265DE0h */ case    4:  		/* mr R27, R24 */
		/* 82265DE0h case    4:*/		regs.R27 = regs.R24;
		/* 82265DE0h case    4:*/		return 0x82265DE4;
		  /* 82265DE4h */ case    5:  		/* cmplw CR6, R24, R11 */
		/* 82265DE4h case    5:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R11);
		/* 82265DE4h case    5:*/		return 0x82265DE8;
		  /* 82265DE8h */ case    6:  		/* bc 4, CR6_LT, 16 */
		/* 82265DE8h case    6:*/		if ( !regs.CR[6].lt ) { return 0x82265DF8;  }
		/* 82265DE8h case    6:*/		return 0x82265DEC;
		  /* 82265DECh */ case    7:  		/* lwz R11, <#[R26 + 8]> */
		/* 82265DECh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 82265DECh case    7:*/		return 0x82265DF0;
		  /* 82265DF0h */ case    8:  		/* add R3, R11, R27 */
		/* 82265DF0h case    8:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R27);
		/* 82265DF0h case    8:*/		return 0x82265DF4;
		  /* 82265DF4h */ case    9:  		/* b 16 */
		/* 82265DF4h case    9:*/		return 0x82265E04;
		/* 82265DF4h case    9:*/		return 0x82265DF8;
	}
	return 0x82265DF8;
} // Block from 82265DD0h-82265DF8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82265DF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265DF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265DF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265DF8);
		  /* 82265DF8h */ case    0:  		/* mr R4, R28 */
		/* 82265DF8h case    0:*/		regs.R4 = regs.R28;
		/* 82265DF8h case    0:*/		return 0x82265DFC;
		  /* 82265DFCh */ case    1:  		/* mr R3, R26 */
		/* 82265DFCh case    1:*/		regs.R3 = regs.R26;
		/* 82265DFCh case    1:*/		return 0x82265E00;
		  /* 82265E00h */ case    2:  		/* bl -74560 */
		/* 82265E00h case    2:*/		regs.LR = 0x82265E04; return 0x82253AC0;
		/* 82265E00h case    2:*/		return 0x82265E04;
	}
	return 0x82265E04;
} // Block from 82265DF8h-82265E04h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82265E04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265E04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265E04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265E04);
		  /* 82265E04h */ case    0:  		/* lwz R29, <#[R3]> */
		/* 82265E04h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R3 + 0x00000000) );
		/* 82265E04h case    0:*/		return 0x82265E08;
	}
	return 0x82265E08;
} // Block from 82265E04h-82265E08h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82265E08h
// Function '??1Interference@XGRAPHICS@@QAA@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265E08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265E08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265E08);
		  /* 82265E08h */ case    0:  		/* lwz R11, <#[R29 + 8]> */
		/* 82265E08h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 82265E08h case    0:*/		return 0x82265E0C;
		  /* 82265E0Ch */ case    1:  		/* cmpwi CR6, R11, 1 */
		/* 82265E0Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 82265E0Ch case    1:*/		return 0x82265E10;
		  /* 82265E10h */ case    2:  		/* bc 4, CR6_GT, 132 */
		/* 82265E10h case    2:*/		if ( !regs.CR[6].gt ) { return 0x82265E94;  }
		/* 82265E10h case    2:*/		return 0x82265E14;
		  /* 82265E14h */ case    3:  		/* lwz R31, <#[R25 + 1456]> */
		/* 82265E14h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R25 + 0x000005B0) );
		/* 82265E14h case    3:*/		return 0x82265E18;
		  /* 82265E18h */ case    4:  		/* li R4, 12 */
		/* 82265E18h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0xC);
		/* 82265E18h case    4:*/		return 0x82265E1C;
		  /* 82265E1Ch */ case    5:  		/* mr R3, R31 */
		/* 82265E1Ch case    5:*/		regs.R3 = regs.R31;
		/* 82265E1Ch case    5:*/		return 0x82265E20;
		  /* 82265E20h */ case    6:  		/* bl -301416 */
		/* 82265E20h case    6:*/		regs.LR = 0x82265E24; return 0x8221C4B8;
		/* 82265E20h case    6:*/		return 0x82265E24;
		  /* 82265E24h */ case    7:  		/* mr R11, R3 */
		/* 82265E24h case    7:*/		regs.R11 = regs.R3;
		/* 82265E24h case    7:*/		return 0x82265E28;
		  /* 82265E28h */ case    8:  		/* addic. R3, R3, 4 */
		/* 82265E28h case    8:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 82265E28h case    8:*/		return 0x82265E2C;
		  /* 82265E2Ch */ case    9:  		/* stw R31, <#[R11]> */
		/* 82265E2Ch case    9:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000000) );
		/* 82265E2Ch case    9:*/		return 0x82265E30;
		  /* 82265E30h */ case   10:  		/* bc 12, CR0_EQ, 20 */
		/* 82265E30h case   10:*/		if ( regs.CR[0].eq ) { return 0x82265E44;  }
		/* 82265E30h case   10:*/		return 0x82265E34;
		  /* 82265E34h */ case   11:  		/* mr R4, R25 */
		/* 82265E34h case   11:*/		regs.R4 = regs.R25;
		/* 82265E34h case   11:*/		return 0x82265E38;
		  /* 82265E38h */ case   12:  		/* bl -1104 */
		/* 82265E38h case   12:*/		regs.LR = 0x82265E3C; return 0x822659E8;
		/* 82265E38h case   12:*/		return 0x82265E3C;
		  /* 82265E3Ch */ case   13:  		/* mr R30, R3 */
		/* 82265E3Ch case   13:*/		regs.R30 = regs.R3;
		/* 82265E3Ch case   13:*/		return 0x82265E40;
		  /* 82265E40h */ case   14:  		/* b 8 */
		/* 82265E40h case   14:*/		return 0x82265E48;
		/* 82265E40h case   14:*/		return 0x82265E44;
	}
	return 0x82265E44;
} // Block from 82265E08h-82265E44h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82265E44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265E44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265E44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265E44);
		  /* 82265E44h */ case    0:  		/* mr R30, R24 */
		/* 82265E44h case    0:*/		regs.R30 = regs.R24;
		/* 82265E44h case    0:*/		return 0x82265E48;
	}
	return 0x82265E48;
} // Block from 82265E44h-82265E48h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82265E48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265E48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265E48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265E48);
		  /* 82265E48h */ case    0:  		/* lwz R3, <#[R23 + 96]> */
		/* 82265E48h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R23 + 0x00000060) );
		/* 82265E48h case    0:*/		return 0x82265E4C;
		  /* 82265E4Ch */ case    1:  		/* lwz R4, <#[R3 + 4]> */
		/* 82265E4Ch case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 82265E4Ch case    1:*/		return 0x82265E50;
		  /* 82265E50h */ case    2:  		/* bl -74640 */
		/* 82265E50h case    2:*/		regs.LR = 0x82265E54; return 0x82253AC0;
		/* 82265E50h case    2:*/		return 0x82265E54;
		  /* 82265E54h */ case    3:  		/* stw R30, <#[R3]> */
		/* 82265E54h case    3:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000000) );
		/* 82265E54h case    3:*/		return 0x82265E58;
		  /* 82265E58h */ case    4:  		/* lwz R11, <#[R29 + 8]> */
		/* 82265E58h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 82265E58h case    4:*/		return 0x82265E5C;
		  /* 82265E5Ch */ case    5:  		/* stw R11, <#[R30]> */
		/* 82265E5Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82265E5Ch case    5:*/		return 0x82265E60;
		  /* 82265E60h */ case    6:  		/* lwz R31, <#[R29 + 24]> */
		/* 82265E60h case    6:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R29 + 0x00000018) );
		/* 82265E60h case    6:*/		return 0x82265E64;
		  /* 82265E64h */ case    7:  		/* cmplwi CR6, R31, 0 */
		/* 82265E64h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82265E64h case    7:*/		return 0x82265E68;
		  /* 82265E68h */ case    8:  		/* bc 12, CR6_EQ, 24 */
		/* 82265E68h case    8:*/		if ( regs.CR[6].eq ) { return 0x82265E80;  }
		/* 82265E68h case    8:*/		return 0x82265E6C;
		  /* 82265E6Ch */ case    9:  		/* lwz R3, <#[R30 + 4]> */
		/* 82265E6Ch case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000004) );
		/* 82265E6Ch case    9:*/		return 0x82265E70;
		  /* 82265E70h */ case   10:  		/* lwz R4, <#[R3 + 4]> */
		/* 82265E70h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R3 + 0x00000004) );
		/* 82265E70h case   10:*/		return 0x82265E74;
		  /* 82265E74h */ case   11:  		/* bl -74676 */
		/* 82265E74h case   11:*/		regs.LR = 0x82265E78; return 0x82253AC0;
		/* 82265E74h case   11:*/		return 0x82265E78;
		  /* 82265E78h */ case   12:  		/* lwz R11, <#[R31 + 12]> */
		/* 82265E78h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 82265E78h case   12:*/		return 0x82265E7C;
		  /* 82265E7Ch */ case   13:  		/* stw R11, <#[R3]> */
		/* 82265E7Ch case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82265E7Ch case   13:*/		return 0x82265E80;
	}
	return 0x82265E80;
} // Block from 82265E48h-82265E80h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82265E80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265E80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265E80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265E80);
		  /* 82265E80h */ case    0:  		/* lwz R11, <#[R29 + 28]> */
		/* 82265E80h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000001C) );
		/* 82265E80h case    0:*/		return 0x82265E84;
		  /* 82265E84h */ case    1:  		/* cmplw CR6, R31, R11 */
		/* 82265E84h case    1:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82265E84h case    1:*/		return 0x82265E88;
		  /* 82265E88h */ case    2:  		/* bc 12, CR6_EQ, 12 */
		/* 82265E88h case    2:*/		if ( regs.CR[6].eq ) { return 0x82265E94;  }
		/* 82265E88h case    2:*/		return 0x82265E8C;
		  /* 82265E8Ch */ case    3:  		/* lwz R31, <#[R31 + 32]> */
		/* 82265E8Ch case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000020) );
		/* 82265E8Ch case    3:*/		return 0x82265E90;
		  /* 82265E90h */ case    4:  		/* b -44 */
		/* 82265E90h case    4:*/		return 0x82265E64;
		/* 82265E90h case    4:*/		return 0x82265E94;
	}
	return 0x82265E94;
} // Block from 82265E80h-82265E94h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82265E94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265E94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265E94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265E94);
		  /* 82265E94h */ case    0:  		/* lwz R11, <#[R26 + 4]> */
		/* 82265E94h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000004) );
		/* 82265E94h case    0:*/		return 0x82265E98;
		  /* 82265E98h */ case    1:  		/* addi R28, R28, 1 */
		/* 82265E98h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 82265E98h case    1:*/		return 0x82265E9C;
		  /* 82265E9Ch */ case    2:  		/* addi R27, R27, 4 */
		/* 82265E9Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x4);
		/* 82265E9Ch case    2:*/		return 0x82265EA0;
		  /* 82265EA0h */ case    3:  		/* cmplw CR6, R28, R11 */
		/* 82265EA0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 82265EA0h case    3:*/		return 0x82265EA4;
		  /* 82265EA4h */ case    4:  		/* bc 12, CR6_LT, -184 */
		/* 82265EA4h case    4:*/		if ( regs.CR[6].lt ) { return 0x82265DEC;  }
		/* 82265EA4h case    4:*/		return 0x82265EA8;
	}
	return 0x82265EA8;
} // Block from 82265E94h-82265EA8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82265EA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265EA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265EA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265EA8);
		  /* 82265EA8h */ case    0:  		/* addi R1, R1, 160 */
		/* 82265EA8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 82265EA8h case    0:*/		return 0x82265EAC;
		  /* 82265EACh */ case    1:  		/* b -1920024 */
		/* 82265EACh case    1:*/		return 0x82091294;
		/* 82265EACh case    1:*/		return 0x82265EB0;
	}
	return 0x82265EB0;
} // Block from 82265EA8h-82265EB0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82265EB0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265EB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265EB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265EB0);
		  /* 82265EB0h */ case    0:  		/* mfspr R12, LR */
		/* 82265EB0h case    0:*/		regs.R12 = regs.LR;
		/* 82265EB0h case    0:*/		return 0x82265EB4;
		  /* 82265EB4h */ case    1:  		/* bl -1920144 */
		/* 82265EB4h case    1:*/		regs.LR = 0x82265EB8; return 0x82091224;
		/* 82265EB4h case    1:*/		return 0x82265EB8;
	}
	return 0x82265EB8;
} // Block from 82265EB0h-82265EB8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82265EB8h
// Function '?HasEdge@TNode@XGRAPHICS@@AAAPAV12@PAPAX0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265EB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265EB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265EB8);
		  /* 82265EB8h */ case    0:  		/* stwu R1, <#[R1 - 224]> */
		/* 82265EB8h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF20) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF20);
		/* 82265EB8h case    0:*/		return 0x82265EBC;
		  /* 82265EBCh */ case    1:  		/* mr R31, R4 */
		/* 82265EBCh case    1:*/		regs.R31 = regs.R4;
		/* 82265EBCh case    1:*/		return 0x82265EC0;
		  /* 82265EC0h */ case    2:  		/* mr R29, R5 */
		/* 82265EC0h case    2:*/		regs.R29 = regs.R5;
		/* 82265EC0h case    2:*/		return 0x82265EC4;
		  /* 82265EC4h */ case    3:  		/* mr R20, R3 */
		/* 82265EC4h case    3:*/		regs.R20 = regs.R3;
		/* 82265EC4h case    3:*/		return 0x82265EC8;
		  /* 82265EC8h */ case    4:  		/* mr R5, R6 */
		/* 82265EC8h case    4:*/		regs.R5 = regs.R6;
		/* 82265EC8h case    4:*/		return 0x82265ECC;
		  /* 82265ECCh */ case    5:  		/* mr R4, R29 */
		/* 82265ECCh case    5:*/		regs.R4 = regs.R29;
		/* 82265ECCh case    5:*/		return 0x82265ED0;
		  /* 82265ED0h */ case    6:  		/* mr R3, R31 */
		/* 82265ED0h case    6:*/		regs.R3 = regs.R31;
		/* 82265ED0h case    6:*/		return 0x82265ED4;
		  /* 82265ED4h */ case    7:  		/* mr R21, R6 */
		/* 82265ED4h case    7:*/		regs.R21 = regs.R6;
		/* 82265ED4h case    7:*/		return 0x82265ED8;
		  /* 82265ED8h */ case    8:  		/* bl -1536 */
		/* 82265ED8h case    8:*/		regs.LR = 0x82265EDC; return 0x822658D8;
		/* 82265ED8h case    8:*/		return 0x82265EDC;
		  /* 82265EDCh */ case    9:  		/* lwz R27, <#[R21 + 1456]> */
		/* 82265EDCh case    9:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R21 + 0x000005B0) );
		/* 82265EDCh case    9:*/		return 0x82265EE0;
		  /* 82265EE0h */ case   10:  		/* mr R28, R3 */
		/* 82265EE0h case   10:*/		regs.R28 = regs.R3;
		/* 82265EE0h case   10:*/		return 0x82265EE4;
		  /* 82265EE4h */ case   11:  		/* li R4, 20 */
		/* 82265EE4h case   11:*/		cpu::op::li<0>(regs,&regs.R4,0x14);
		/* 82265EE4h case   11:*/		return 0x82265EE8;
		  /* 82265EE8h */ case   12:  		/* mr R3, R27 */
		/* 82265EE8h case   12:*/		regs.R3 = regs.R27;
		/* 82265EE8h case   12:*/		return 0x82265EEC;
		  /* 82265EECh */ case   13:  		/* bl -301620 */
		/* 82265EECh case   13:*/		regs.LR = 0x82265EF0; return 0x8221C4B8;
		/* 82265EECh case   13:*/		return 0x82265EF0;
		  /* 82265EF0h */ case   14:  		/* li R19, 0 */
		/* 82265EF0h case   14:*/		cpu::op::li<0>(regs,&regs.R19,0x0);
		/* 82265EF0h case   14:*/		return 0x82265EF4;
		  /* 82265EF4h */ case   15:  		/* addic. R30, R3, 4 */
		/* 82265EF4h case   15:*/		cpu::op::addic<1>(regs,&regs.R30,regs.R3,0x4);
		/* 82265EF4h case   15:*/		return 0x82265EF8;
		  /* 82265EF8h */ case   16:  		/* stw R27, <#[R3]> */
		/* 82265EF8h case   16:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R3 + 0x00000000) );
		/* 82265EF8h case   16:*/		return 0x82265EFC;
		  /* 82265EFCh */ case   17:  		/* bc 12, CR0_EQ, 20 */
		/* 82265EFCh case   17:*/		if ( regs.CR[0].eq ) { return 0x82265F10;  }
		/* 82265EFCh case   17:*/		return 0x82265F00;
		  /* 82265F00h */ case   18:  		/* mr R3, R30 */
		/* 82265F00h case   18:*/		regs.R3 = regs.R30;
		/* 82265F00h case   18:*/		return 0x82265F04;
		  /* 82265F04h */ case   19:  		/* lwz R4, <#[R21 + 1456]> */
		/* 82265F04h case   19:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R21 + 0x000005B0) );
		/* 82265F04h case   19:*/		return 0x82265F08;
		  /* 82265F08h */ case   20:  		/* bl -197032 */
		/* 82265F08h case   20:*/		regs.LR = 0x82265F0C; return 0x82235D60;
		/* 82265F08h case   20:*/		return 0x82265F0C;
		  /* 82265F0Ch */ case   21:  		/* b 8 */
		/* 82265F0Ch case   21:*/		return 0x82265F14;
		/* 82265F0Ch case   21:*/		return 0x82265F10;
	}
	return 0x82265F10;
} // Block from 82265EB8h-82265F10h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82265F10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265F10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265F10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265F10);
		  /* 82265F10h */ case    0:  		/* mr R30, R19 */
		/* 82265F10h case    0:*/		regs.R30 = regs.R19;
		/* 82265F10h case    0:*/		return 0x82265F14;
	}
	return 0x82265F14;
} // Block from 82265F10h-82265F14h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82265F14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265F14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265F14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265F14);
		  /* 82265F14h */ case    0:  		/* stw R30, <#[R20 + 96]> */
		/* 82265F14h case    0:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R20 + 0x00000060) );
		/* 82265F14h case    0:*/		return 0x82265F18;
		  /* 82265F18h */ case    1:  		/* mr R7, R21 */
		/* 82265F18h case    1:*/		regs.R7 = regs.R21;
		/* 82265F18h case    1:*/		return 0x82265F1C;
		  /* 82265F1Ch */ case    2:  		/* mr R6, R29 */
		/* 82265F1Ch case    2:*/		regs.R6 = regs.R29;
		/* 82265F1Ch case    2:*/		return 0x82265F20;
		  /* 82265F20h */ case    3:  		/* mr R5, R31 */
		/* 82265F20h case    3:*/		regs.R5 = regs.R31;
		/* 82265F20h case    3:*/		return 0x82265F24;
		  /* 82265F24h */ case    4:  		/* mr R4, R20 */
		/* 82265F24h case    4:*/		regs.R4 = regs.R20;
		/* 82265F24h case    4:*/		return 0x82265F28;
	}
	return 0x82265F28;
} // Block from 82265F14h-82265F28h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82265F28h
// Function '?IsEndPoint@Reference@XGRAPHICS@@QAAHHPAPAX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265F28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265F28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265F28);
		  /* 82265F28h */ case    0:  		/* mr R3, R28 */
		/* 82265F28h case    0:*/		regs.R3 = regs.R28;
		/* 82265F28h case    0:*/		return 0x82265F2C;
		  /* 82265F2Ch */ case    1:  		/* bl -780 */
		/* 82265F2Ch case    1:*/		regs.LR = 0x82265F30; return 0x82265C20;
		/* 82265F2Ch case    1:*/		return 0x82265F30;
		  /* 82265F30h */ case    2:  		/* mr R3, R20 */
		/* 82265F30h case    2:*/		regs.R3 = regs.R20;
		/* 82265F30h case    2:*/		return 0x82265F34;
		  /* 82265F34h */ case    3:  		/* bl -1260 */
		/* 82265F34h case    3:*/		regs.LR = 0x82265F38; return 0x82265A48;
		/* 82265F34h case    3:*/		return 0x82265F38;
		  /* 82265F38h */ case    4:  		/* rlwinm R4, R31, 3, 0, 28 */
		/* 82265F38h case    4:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R4,regs.R31);
		/* 82265F38h case    4:*/		return 0x82265F3C;
		  /* 82265F3Ch */ case    5:  		/* mr R3, R21 */
		/* 82265F3Ch case    5:*/		regs.R3 = regs.R21;
		/* 82265F3Ch case    5:*/		return 0x82265F40;
		  /* 82265F40h */ case    6:  		/* bl -299888 */
		/* 82265F40h case    6:*/		regs.LR = 0x82265F44; return 0x8221CBD0;
		/* 82265F40h case    6:*/		return 0x82265F44;
		  /* 82265F44h */ case    7:  		/* mr R18, R3 */
		/* 82265F44h case    7:*/		regs.R18 = regs.R3;
		/* 82265F44h case    7:*/		return 0x82265F48;
		  /* 82265F48h */ case    8:  		/* mr R11, R19 */
		/* 82265F48h case    8:*/		regs.R11 = regs.R19;
		/* 82265F48h case    8:*/		return 0x82265F4C;
		  /* 82265F4Ch */ case    9:  		/* cmpwi CR6, R31, 0 */
		/* 82265F4Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 82265F4Ch case    9:*/		return 0x82265F50;
		  /* 82265F50h */ case   10:  		/* bc 4, CR6_GT, 28 */
		/* 82265F50h case   10:*/		if ( !regs.CR[6].gt ) { return 0x82265F6C;  }
		/* 82265F50h case   10:*/		return 0x82265F54;
		  /* 82265F54h */ case   11:  		/* addi R10, R3, -4 */
		/* 82265F54h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R3,0xFFFFFFFC);
		/* 82265F54h case   11:*/		return 0x82265F58;
		  /* 82265F58h */ case   12:  		/* mtspr CTR, R31 */
		/* 82265F58h case   12:*/		regs.CTR = regs.R31;
		/* 82265F58h case   12:*/		return 0x82265F5C;
		  /* 82265F5Ch */ case   13:  		/* stw R11, <#[R10 + 4]> */
		/* 82265F5Ch case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 82265F5Ch case   13:*/		return 0x82265F60;
		  /* 82265F60h */ case   14:  		/* addi R11, R11, 1 */
		/* 82265F60h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82265F60h case   14:*/		return 0x82265F64;
		  /* 82265F64h */ case   15:  		/* stwu R19, <#[R10 + 8]> */
		/* 82265F64h case   15:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R10 + 0x00000008) );
		regs.R10 = (uint32)(regs.R10 + 0x00000008);
		/* 82265F64h case   15:*/		return 0x82265F68;
		  /* 82265F68h */ case   16:  		/* bc 16, CR0_LT, -12 */
		/* 82265F68h case   16:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82265F5C;  }
		/* 82265F68h case   16:*/		return 0x82265F6C;
	}
	return 0x82265F6C;
} // Block from 82265F28h-82265F6Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 82265F6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265F6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265F6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265F6C);
		  /* 82265F6Ch */ case    0:  		/* lwz R11, <#[R20 + 96]> */
		/* 82265F6Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000060) );
		/* 82265F6Ch case    0:*/		return 0x82265F70;
		  /* 82265F70h */ case    1:  		/* li R17, -1 */
		/* 82265F70h case    1:*/		cpu::op::li<0>(regs,&regs.R17,0xFFFFFFFF);
		/* 82265F70h case    1:*/		return 0x82265F74;
		  /* 82265F74h */ case    2:  		/* mr R16, R19 */
		/* 82265F74h case    2:*/		regs.R16 = regs.R19;
		/* 82265F74h case    2:*/		return 0x82265F78;
		  /* 82265F78h */ case    3:  		/* lwz R11, <#[R11 + 4]> */
		/* 82265F78h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82265F78h case    3:*/		return 0x82265F7C;
		  /* 82265F7Ch */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 82265F7Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82265F7Ch case    4:*/		return 0x82265F80;
		  /* 82265F80h */ case    5:  		/* bc 4, CR6_GT, 980 */
		/* 82265F80h case    5:*/		if ( !regs.CR[6].gt ) { return 0x82266354;  }
		/* 82265F80h case    5:*/		return 0x82265F84;
		  /* 82265F84h */ case    6:  		/* mr R15, R19 */
		/* 82265F84h case    6:*/		regs.R15 = regs.R19;
		/* 82265F84h case    6:*/		return 0x82265F88;
		  /* 82265F88h */ case    7:  		/* lwz R3, <#[R20 + 96]> */
		/* 82265F88h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R20 + 0x00000060) );
		/* 82265F88h case    7:*/		return 0x82265F8C;
		  /* 82265F8Ch */ case    8:  		/* lwz R11, <#[R3 + 4]> */
		/* 82265F8Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82265F8Ch case    8:*/		return 0x82265F90;
		  /* 82265F90h */ case    9:  		/* cmplw CR6, R16, R11 */
		/* 82265F90h case    9:*/		cpu::op::cmplw<6>(regs,regs.R16,regs.R11);
		/* 82265F90h case    9:*/		return 0x82265F94;
		  /* 82265F94h */ case   10:  		/* bc 4, CR6_LT, 16 */
		/* 82265F94h case   10:*/		if ( !regs.CR[6].lt ) { return 0x82265FA4;  }
		/* 82265F94h case   10:*/		return 0x82265F98;
		  /* 82265F98h */ case   11:  		/* lwz R11, <#[R3 + 8]> */
		/* 82265F98h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82265F98h case   11:*/		return 0x82265F9C;
		  /* 82265F9Ch */ case   12:  		/* add R3, R11, R15 */
		/* 82265F9Ch case   12:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R15);
		/* 82265F9Ch case   12:*/		return 0x82265FA0;
		  /* 82265FA0h */ case   13:  		/* b 12 */
		/* 82265FA0h case   13:*/		return 0x82265FAC;
		/* 82265FA0h case   13:*/		return 0x82265FA4;
	}
	return 0x82265FA4;
} // Block from 82265F6Ch-82265FA4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82265FA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265FA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265FA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265FA4);
		  /* 82265FA4h */ case    0:  		/* mr R4, R16 */
		/* 82265FA4h case    0:*/		regs.R4 = regs.R16;
		/* 82265FA4h case    0:*/		return 0x82265FA8;
		  /* 82265FA8h */ case    1:  		/* bl -74984 */
		/* 82265FA8h case    1:*/		regs.LR = 0x82265FAC; return 0x82253AC0;
		/* 82265FA8h case    1:*/		return 0x82265FAC;
	}
	return 0x82265FAC;
} // Block from 82265FA4h-82265FACh (2 instructions)

//////////////////////////////////////////////////////
// Block at 82265FACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265FAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265FAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265FAC);
		  /* 82265FACh */ case    0:  		/* lwz R22, <#[R3]> */
		/* 82265FACh case    0:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R3 + 0x00000000) );
		/* 82265FACh case    0:*/		return 0x82265FB0;
		  /* 82265FB0h */ case    1:  		/* li R29, 1 */
		/* 82265FB0h case    1:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 82265FB0h case    1:*/		return 0x82265FB4;
		  /* 82265FB4h */ case    2:  		/* mr R31, R19 */
		/* 82265FB4h case    2:*/		regs.R31 = regs.R19;
		/* 82265FB4h case    2:*/		return 0x82265FB8;
		  /* 82265FB8h */ case    3:  		/* lwz R3, <#[R22 + 4]> */
		/* 82265FB8h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R22 + 0x00000004) );
		/* 82265FB8h case    3:*/		return 0x82265FBC;
		  /* 82265FBCh */ case    4:  		/* lwz R24, <#[R22]> */
		/* 82265FBCh case    4:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R22 + 0x00000000) );
		/* 82265FBCh case    4:*/		return 0x82265FC0;
		  /* 82265FC0h */ case    5:  		/* lwz R11, <#[R3 + 4]> */
		/* 82265FC0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82265FC0h case    5:*/		return 0x82265FC4;
		  /* 82265FC4h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 82265FC4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82265FC4h case    6:*/		return 0x82265FC8;
		  /* 82265FC8h */ case    7:  		/* bc 12, CR6_EQ, 132 */
		/* 82265FC8h case    7:*/		if ( regs.CR[6].eq ) { return 0x8226604C;  }
		/* 82265FC8h case    7:*/		return 0x82265FCC;
		  /* 82265FCCh */ case    8:  		/* mr R30, R19 */
		/* 82265FCCh case    8:*/		regs.R30 = regs.R19;
		/* 82265FCCh case    8:*/		return 0x82265FD0;
		  /* 82265FD0h */ case    9:  		/* lwz R11, <#[R3 + 4]> */
		/* 82265FD0h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82265FD0h case    9:*/		return 0x82265FD4;
		  /* 82265FD4h */ case   10:  		/* cmplw CR6, R31, R11 */
		/* 82265FD4h case   10:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82265FD4h case   10:*/		return 0x82265FD8;
		  /* 82265FD8h */ case   11:  		/* bc 4, CR6_LT, 16 */
		/* 82265FD8h case   11:*/		if ( !regs.CR[6].lt ) { return 0x82265FE8;  }
		/* 82265FD8h case   11:*/		return 0x82265FDC;
		  /* 82265FDCh */ case   12:  		/* lwz R11, <#[R3 + 8]> */
		/* 82265FDCh case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82265FDCh case   12:*/		return 0x82265FE0;
		  /* 82265FE0h */ case   13:  		/* add R3, R11, R30 */
		/* 82265FE0h case   13:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R30);
		/* 82265FE0h case   13:*/		return 0x82265FE4;
		  /* 82265FE4h */ case   14:  		/* b 12 */
		/* 82265FE4h case   14:*/		return 0x82265FF0;
		/* 82265FE4h case   14:*/		return 0x82265FE8;
	}
	return 0x82265FE8;
} // Block from 82265FACh-82265FE8h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82265FE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265FE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265FE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265FE8);
		  /* 82265FE8h */ case    0:  		/* mr R4, R31 */
		/* 82265FE8h case    0:*/		regs.R4 = regs.R31;
		/* 82265FE8h case    0:*/		return 0x82265FEC;
		  /* 82265FECh */ case    1:  		/* bl -75052 */
		/* 82265FECh case    1:*/		regs.LR = 0x82265FF0; return 0x82253AC0;
		/* 82265FECh case    1:*/		return 0x82265FF0;
	}
	return 0x82265FF0;
} // Block from 82265FE8h-82265FF0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82265FF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265FF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265FF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265FF0);
		  /* 82265FF0h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82265FF0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82265FF0h case    0:*/		return 0x82265FF4;
		  /* 82265FF4h */ case    1:  		/* mr R10, R19 */
		/* 82265FF4h case    1:*/		regs.R10 = regs.R19;
		/* 82265FF4h case    1:*/		return 0x82265FF8;
	}
	return 0x82265FF8;
} // Block from 82265FF0h-82265FF8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82265FF8h
// Function '?Canonize@Reference@XGRAPHICS@@QAAXPAPAX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82265FF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82265FF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82265FF8);
		  /* 82265FF8h */ case    0:  		/* cmpwi CR6, R24, 0 */
		/* 82265FF8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 82265FF8h case    0:*/		return 0x82265FFC;
		  /* 82265FFCh */ case    1:  		/* bc 4, CR6_GT, 56 */
		/* 82265FFCh case    1:*/		if ( !regs.CR[6].gt ) { return 0x82266034;  }
		/* 82265FFCh case    1:*/		return 0x82266000;
		  /* 82266000h */ case    2:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 82266000h case    2:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 82266000h case    2:*/		return 0x82266004;
		  /* 82266004h */ case    3:  		/* add R11, R11, R18 */
		/* 82266004h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R18);
		/* 82266004h case    3:*/		return 0x82266008;
		  /* 82266008h */ case    4:  		/* addi R11, R11, -4 */
		/* 82266008h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 82266008h case    4:*/		return 0x8226600C;
		  /* 8226600Ch */ case    5:  		/* lwz R9, <#[R11 + 8]> */
		/* 8226600Ch case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 8226600Ch case    5:*/		return 0x82266010;
		  /* 82266010h */ case    6:  		/* cmpwi CR6, R9, 0 */
		/* 82266010h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 82266010h case    6:*/		return 0x82266014;
		  /* 82266014h */ case    7:  		/* bc 4, CR6_EQ, 28 */
		/* 82266014h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82266030;  }
		/* 82266014h case    7:*/		return 0x82266018;
		  /* 82266018h */ case    8:  		/* addi R10, R10, 1 */
		/* 82266018h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82266018h case    8:*/		return 0x8226601C;
		  /* 8226601Ch */ case    9:  		/* li R9, 1 */
		/* 8226601Ch case    9:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 8226601Ch case    9:*/		return 0x82266020;
		  /* 82266020h */ case   10:  		/* cmpw CR6, R10, R24 */
		/* 82266020h case   10:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R24);
		/* 82266020h case   10:*/		return 0x82266024;
		  /* 82266024h */ case   11:  		/* stwu R9, <#[R11 + 8]> */
		/* 82266024h case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000008) );
		regs.R11 = (uint32)(regs.R11 + 0x00000008);
		/* 82266024h case   11:*/		return 0x82266028;
		  /* 82266028h */ case   12:  		/* bc 12, CR6_LT, -28 */
		/* 82266028h case   12:*/		if ( regs.CR[6].lt ) { return 0x8226600C;  }
		/* 82266028h case   12:*/		return 0x8226602C;
		  /* 8226602Ch */ case   13:  		/* b 8 */
		/* 8226602Ch case   13:*/		return 0x82266034;
		/* 8226602Ch case   13:*/		return 0x82266030;
	}
	return 0x82266030;
} // Block from 82265FF8h-82266030h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82266030h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266030( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266030) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266030);
		  /* 82266030h */ case    0:  		/* mr R29, R19 */
		/* 82266030h case    0:*/		regs.R29 = regs.R19;
		/* 82266030h case    0:*/		return 0x82266034;
	}
	return 0x82266034;
} // Block from 82266030h-82266034h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82266034h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266034( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266034) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266034);
		  /* 82266034h */ case    0:  		/* lwz R3, <#[R22 + 4]> */
		/* 82266034h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R22 + 0x00000004) );
		/* 82266034h case    0:*/		return 0x82266038;
		  /* 82266038h */ case    1:  		/* addi R31, R31, 1 */
		/* 82266038h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82266038h case    1:*/		return 0x8226603C;
		  /* 8226603Ch */ case    2:  		/* addi R30, R30, 4 */
		/* 8226603Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 8226603Ch case    2:*/		return 0x82266040;
		  /* 82266040h */ case    3:  		/* lwz R11, <#[R3 + 4]> */
		/* 82266040h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82266040h case    3:*/		return 0x82266044;
		  /* 82266044h */ case    4:  		/* cmplw CR6, R31, R11 */
		/* 82266044h case    4:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82266044h case    4:*/		return 0x82266048;
		  /* 82266048h */ case    5:  		/* bc 12, CR6_LT, -120 */
		/* 82266048h case    5:*/		if ( regs.CR[6].lt ) { return 0x82265FD0;  }
		/* 82266048h case    5:*/		return 0x8226604C;
	}
	return 0x8226604C;
} // Block from 82266034h-8226604Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8226604Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226604C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226604C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226604C);
		  /* 8226604Ch */ case    0:  		/* rlwinm. R10, R29, 0, 24, 31 */
		/* 8226604Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R29);
		/* 8226604Ch case    0:*/		return 0x82266050;
		  /* 82266050h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82266050h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82266050h case    1:*/		return 0x82266054;
		  /* 82266054h */ case    2:  		/* bc 4, CR0_EQ, 132 */
		/* 82266054h case    2:*/		if ( !regs.CR[0].eq ) { return 0x822660D8;  }
		/* 82266054h case    2:*/		return 0x82266058;
		  /* 82266058h */ case    3:  		/* mr R31, R19 */
		/* 82266058h case    3:*/		regs.R31 = regs.R19;
		/* 82266058h case    3:*/		return 0x8226605C;
		  /* 8226605Ch */ case    4:  		/* bc 12, CR6_EQ, 736 */
		/* 8226605Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x8226633C;  }
		/* 8226605Ch case    4:*/		return 0x82266060;
		  /* 82266060h */ case    5:  		/* mr R30, R19 */
		/* 82266060h case    5:*/		regs.R30 = regs.R19;
		/* 82266060h case    5:*/		return 0x82266064;
		  /* 82266064h */ case    6:  		/* lwz R11, <#[R3 + 4]> */
		/* 82266064h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82266064h case    6:*/		return 0x82266068;
		  /* 82266068h */ case    7:  		/* cmplw CR6, R31, R11 */
		/* 82266068h case    7:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 82266068h case    7:*/		return 0x8226606C;
		  /* 8226606Ch */ case    8:  		/* bc 4, CR6_LT, 16 */
		/* 8226606Ch case    8:*/		if ( !regs.CR[6].lt ) { return 0x8226607C;  }
		/* 8226606Ch case    8:*/		return 0x82266070;
		  /* 82266070h */ case    9:  		/* lwz R11, <#[R3 + 8]> */
		/* 82266070h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82266070h case    9:*/		return 0x82266074;
		  /* 82266074h */ case   10:  		/* add R3, R11, R30 */
		/* 82266074h case   10:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R30);
		/* 82266074h case   10:*/		return 0x82266078;
		  /* 82266078h */ case   11:  		/* b 12 */
		/* 82266078h case   11:*/		return 0x82266084;
		/* 82266078h case   11:*/		return 0x8226607C;
	}
	return 0x8226607C;
} // Block from 8226604Ch-8226607Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8226607Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226607C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226607C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226607C);
		  /* 8226607Ch */ case    0:  		/* mr R4, R31 */
		/* 8226607Ch case    0:*/		regs.R4 = regs.R31;
		/* 8226607Ch case    0:*/		return 0x82266080;
		  /* 82266080h */ case    1:  		/* bl -75200 */
		/* 82266080h case    1:*/		regs.LR = 0x82266084; return 0x82253AC0;
		/* 82266080h case    1:*/		return 0x82266084;
	}
	return 0x82266084;
} // Block from 8226607Ch-82266084h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82266084h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266084( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266084) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266084);
		  /* 82266084h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82266084h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82266084h case    0:*/		return 0x82266088;
		  /* 82266088h */ case    1:  		/* mr R10, R19 */
		/* 82266088h case    1:*/		regs.R10 = regs.R19;
		/* 82266088h case    1:*/		return 0x8226608C;
		  /* 8226608Ch */ case    2:  		/* cmpwi CR6, R24, 0 */
		/* 8226608Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 8226608Ch case    2:*/		return 0x82266090;
		  /* 82266090h */ case    3:  		/* bc 4, CR6_GT, 44 */
		/* 82266090h case    3:*/		if ( !regs.CR[6].gt ) { return 0x822660BC;  }
		/* 82266090h case    3:*/		return 0x82266094;
		  /* 82266094h */ case    4:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 82266094h case    4:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 82266094h case    4:*/		return 0x82266098;
		  /* 82266098h */ case    5:  		/* add R11, R11, R18 */
		/* 82266098h case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R18);
		/* 82266098h case    5:*/		return 0x8226609C;
		  /* 8226609Ch */ case    6:  		/* addi R11, R11, -4 */
		/* 8226609Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 8226609Ch case    6:*/		return 0x822660A0;
		  /* 822660A0h */ case    7:  		/* lwz R9, <#[R11 + 8]> */
		/* 822660A0h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 822660A0h case    7:*/		return 0x822660A4;
		  /* 822660A4h */ case    8:  		/* cmpwi CR6, R9, 1 */
		/* 822660A4h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000001);
		/* 822660A4h case    8:*/		return 0x822660A8;
		  /* 822660A8h */ case    9:  		/* bc 4, CR6_EQ, 20 */
		/* 822660A8h case    9:*/		if ( !regs.CR[6].eq ) { return 0x822660BC;  }
		/* 822660A8h case    9:*/		return 0x822660AC;
		  /* 822660ACh */ case   10:  		/* addi R10, R10, 1 */
		/* 822660ACh case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 822660ACh case   10:*/		return 0x822660B0;
	}
	return 0x822660B0;
} // Block from 82266084h-822660B0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 822660B0h
// Function '?MakeNodeExplicit@Reference@XGRAPHICS@@QAAPAVTNode@2@PAPAX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822660B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822660B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822660B0);
		  /* 822660B0h */ case    0:  		/* stwu R19, <#[R11 + 8]> */
		/* 822660B0h case    0:*/		cpu::mem::store32( regs, regs.R19, (uint32)(regs.R11 + 0x00000008) );
		regs.R11 = (uint32)(regs.R11 + 0x00000008);
		/* 822660B0h case    0:*/		return 0x822660B4;
		  /* 822660B4h */ case    1:  		/* cmpw CR6, R10, R24 */
		/* 822660B4h case    1:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R24);
		/* 822660B4h case    1:*/		return 0x822660B8;
		  /* 822660B8h */ case    2:  		/* bc 12, CR6_LT, -24 */
		/* 822660B8h case    2:*/		if ( regs.CR[6].lt ) { return 0x822660A0;  }
		/* 822660B8h case    2:*/		return 0x822660BC;
	}
	return 0x822660BC;
} // Block from 822660B0h-822660BCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 822660BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822660BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822660BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822660BC);
		  /* 822660BCh */ case    0:  		/* lwz R3, <#[R22 + 4]> */
		/* 822660BCh case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R22 + 0x00000004) );
		/* 822660BCh case    0:*/		return 0x822660C0;
		  /* 822660C0h */ case    1:  		/* addi R31, R31, 1 */
		/* 822660C0h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 822660C0h case    1:*/		return 0x822660C4;
		  /* 822660C4h */ case    2:  		/* addi R30, R30, 4 */
		/* 822660C4h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x4);
		/* 822660C4h case    2:*/		return 0x822660C8;
		  /* 822660C8h */ case    3:  		/* lwz R11, <#[R3 + 4]> */
		/* 822660C8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 822660C8h case    3:*/		return 0x822660CC;
		  /* 822660CCh */ case    4:  		/* cmplw CR6, R31, R11 */
		/* 822660CCh case    4:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 822660CCh case    4:*/		return 0x822660D0;
		  /* 822660D0h */ case    5:  		/* bc 12, CR6_LT, -108 */
		/* 822660D0h case    5:*/		if ( regs.CR[6].lt ) { return 0x82266064;  }
		/* 822660D0h case    5:*/		return 0x822660D4;
		  /* 822660D4h */ case    6:  		/* b 616 */
		/* 822660D4h case    6:*/		return 0x8226633C;
		/* 822660D4h case    6:*/		return 0x822660D8;
	}
	return 0x822660D8;
} // Block from 822660BCh-822660D8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 822660D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822660D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822660D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822660D8);
		  /* 822660D8h */ case    0:  		/* addi R17, R17, 1 */
		/* 822660D8h case    0:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R17,0x1);
		/* 822660D8h case    0:*/		return 0x822660DC;
		  /* 822660DCh */ case    1:  		/* mr R26, R19 */
		/* 822660DCh case    1:*/		regs.R26 = regs.R19;
		/* 822660DCh case    1:*/		return 0x822660E0;
		  /* 822660E0h */ case    2:  		/* bc 12, CR6_EQ, 604 */
		/* 822660E0h case    2:*/		if ( regs.CR[6].eq ) { return 0x8226633C;  }
		/* 822660E0h case    2:*/		return 0x822660E4;
		  /* 822660E4h */ case    3:  		/* mr R23, R19 */
		/* 822660E4h case    3:*/		regs.R23 = regs.R19;
		/* 822660E4h case    3:*/		return 0x822660E8;
		  /* 822660E8h */ case    4:  		/* lwz R11, <#[R3 + 4]> */
		/* 822660E8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 822660E8h case    4:*/		return 0x822660EC;
		  /* 822660ECh */ case    5:  		/* cmplw CR6, R26, R11 */
		/* 822660ECh case    5:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R11);
		/* 822660ECh case    5:*/		return 0x822660F0;
		  /* 822660F0h */ case    6:  		/* bc 4, CR6_LT, 16 */
		/* 822660F0h case    6:*/		if ( !regs.CR[6].lt ) { return 0x82266100;  }
		/* 822660F0h case    6:*/		return 0x822660F4;
		  /* 822660F4h */ case    7:  		/* lwz R11, <#[R3 + 8]> */
		/* 822660F4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 822660F4h case    7:*/		return 0x822660F8;
		  /* 822660F8h */ case    8:  		/* add R3, R11, R23 */
		/* 822660F8h case    8:*/		cpu::op::add<0>(regs,&regs.R3,regs.R11,regs.R23);
		/* 822660F8h case    8:*/		return 0x822660FC;
		  /* 822660FCh */ case    9:  		/* b 12 */
		/* 822660FCh case    9:*/		return 0x82266108;
		/* 822660FCh case    9:*/		return 0x82266100;
	}
	return 0x82266100;
} // Block from 822660D8h-82266100h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82266100h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266100( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266100) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266100);
		  /* 82266100h */ case    0:  		/* mr R4, R26 */
		/* 82266100h case    0:*/		regs.R4 = regs.R26;
		/* 82266100h case    0:*/		return 0x82266104;
		  /* 82266104h */ case    1:  		/* bl -75332 */
		/* 82266104h case    1:*/		regs.LR = 0x82266108; return 0x82253AC0;
		/* 82266104h case    1:*/		return 0x82266108;
	}
	return 0x82266108;
} // Block from 82266100h-82266108h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82266108h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266108( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266108) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266108);
		  /* 82266108h */ case    0:  		/* lwz R27, <#[R3]> */
		/* 82266108h case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R3 + 0x00000000) );
		/* 82266108h case    0:*/		return 0x8226610C;
		  /* 8226610Ch */ case    1:  		/* mr R28, R19 */
		/* 8226610Ch case    1:*/		regs.R28 = regs.R19;
		/* 8226610Ch case    1:*/		return 0x82266110;
		  /* 82266110h */ case    2:  		/* cmpwi CR6, R24, 0 */
		/* 82266110h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 82266110h case    2:*/		return 0x82266114;
		  /* 82266114h */ case    3:  		/* bc 4, CR6_GT, 528 */
		/* 82266114h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82266324;  }
		/* 82266114h case    3:*/		return 0x82266118;
		  /* 82266118h */ case    4:  		/* addi R25, R24, -1 */
		/* 82266118h case    4:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R24,0xFFFFFFFF);
		/* 82266118h case    4:*/		return 0x8226611C;
		  /* 8226611Ch */ case    5:  		/* cmpwi CR6, R28, 0 */
		/* 8226611Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 8226611Ch case    5:*/		return 0x82266120;
		  /* 82266120h */ case    6:  		/* bc 4, CR6_EQ, 232 */
		/* 82266120h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82266208;  }
		/* 82266120h case    6:*/		return 0x82266124;
		  /* 82266124h */ case    7:  		/* lwz R11, <#[R20 + 52]> */
		/* 82266124h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000034) );
		/* 82266124h case    7:*/		return 0x82266128;
		  /* 82266128h */ case    8:  		/* rlwinm R10, R27, 3, 0, 28 */
		/* 82266128h case    8:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R27);
		/* 82266128h case    8:*/		return 0x8226612C;
		  /* 8226612Ch */ case    9:  		/* add R11, R10, R11 */
		/* 8226612Ch case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8226612Ch case    9:*/		return 0x82266130;
		  /* 82266130h */ case   10:  		/* lwz R30, <#[R11]> */
		/* 82266130h case   10:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 82266130h case   10:*/		return 0x82266134;
		  /* 82266134h */ case   11:  		/* lwz R31, <#[R11 + 4]> */
		/* 82266134h case   11:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000004) );
		/* 82266134h case   11:*/		return 0x82266138;
		  /* 82266138h */ case   12:  		/* cmplwi CR6, R30, 0 */
		/* 82266138h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82266138h case   12:*/		return 0x8226613C;
		  /* 8226613Ch */ case   13:  		/* bc 12, CR6_EQ, 72 */
		/* 8226613Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x82266184;  }
		/* 8226613Ch case   13:*/		return 0x82266140;
		  /* 82266140h */ case   14:  		/* cmplwi CR6, R31, 0 */
		/* 82266140h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82266140h case   14:*/		return 0x82266144;
		  /* 82266144h */ case   15:  		/* bc 12, CR6_EQ, 60 */
		/* 82266144h case   15:*/		if ( regs.CR[6].eq ) { return 0x82266180;  }
		/* 82266144h case   15:*/		return 0x82266148;
		  /* 82266148h */ case   16:  		/* cmplw CR6, R31, R30 */
		/* 82266148h case   16:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R30);
		/* 82266148h case   16:*/		return 0x8226614C;
		  /* 8226614Ch */ case   17:  		/* bc 12, CR6_EQ, 56 */
		/* 8226614Ch case   17:*/		if ( regs.CR[6].eq ) { return 0x82266184;  }
		/* 8226614Ch case   17:*/		return 0x82266150;
		  /* 82266150h */ case   18:  		/* lwz R29, <#[R30 + 8]> */
		/* 82266150h case   18:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R30 + 0x00000008) );
		/* 82266150h case   18:*/		return 0x82266154;
		  /* 82266154h */ case   19:  		/* b 36 */
		/* 82266154h case   19:*/		return 0x82266178;
		/* 82266154h case   19:*/		return 0x82266158;
		  /* 82266158h */ case   20:  		/* lwz R29, <#[R29 + 8]> */
		/* 82266158h case   20:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R29 + 0x00000008) );
		/* 82266158h case   20:*/		return 0x8226615C;
		  /* 8226615Ch */ case   21:  		/* mr R3, R29 */
		/* 8226615Ch case   21:*/		regs.R3 = regs.R29;
		/* 8226615Ch case   21:*/		return 0x82266160;
		  /* 82266160h */ case   22:  		/* lwz R11, <#[R29]> */
		/* 82266160h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82266160h case   22:*/		return 0x82266164;
		  /* 82266164h */ case   23:  		/* lwz R11, <#[R11 + 40]> */
		/* 82266164h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 82266164h case   23:*/		return 0x82266168;
		  /* 82266168h */ case   24:  		/* mtspr CTR, R11 */
		/* 82266168h case   24:*/		regs.CTR = regs.R11;
		/* 82266168h case   24:*/		return 0x8226616C;
		  /* 8226616Ch */ case   25:  		/* bcctrl 20, CR0_LT */
		/* 8226616Ch case   25:*/		if ( 1 ) { regs.LR = 0x82266170; return (uint32)regs.CTR; }
		/* 8226616Ch case   25:*/		return 0x82266170;
		  /* 82266170h */ case   26:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82266170h case   26:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82266170h case   26:*/		return 0x82266174;
		  /* 82266174h */ case   27:  		/* bc 4, CR0_EQ, 16 */
		/* 82266174h case   27:*/		if ( !regs.CR[0].eq ) { return 0x82266184;  }
		/* 82266174h case   27:*/		return 0x82266178;
	}
	return 0x82266178;
} // Block from 82266108h-82266178h (28 instructions)

//////////////////////////////////////////////////////
// Block at 82266178h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266178( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266178) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266178);
		  /* 82266178h */ case    0:  		/* cmplw CR6, R29, R31 */
		/* 82266178h case    0:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R31);
		/* 82266178h case    0:*/		return 0x8226617C;
		  /* 8226617Ch */ case    1:  		/* bc 4, CR6_EQ, -36 */
		/* 8226617Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82266158;  }
		/* 8226617Ch case    1:*/		return 0x82266180;
	}
	return 0x82266180;
} // Block from 82266178h-82266180h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82266180h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266180( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266180) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266180);
		  /* 82266180h */ case    0:  		/* mr R31, R30 */
		/* 82266180h case    0:*/		regs.R31 = regs.R30;
		/* 82266180h case    0:*/		return 0x82266184;
	}
	return 0x82266184;
} // Block from 82266180h-82266184h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82266184h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266184( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266184) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266184);
		  /* 82266184h */ case    0:  		/* lwz R11, <#[R22 + 4]> */
		/* 82266184h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000004) );
		/* 82266184h case    0:*/		return 0x82266188;
		  /* 82266188h */ case    1:  		/* li R4, 964 */
		/* 82266188h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 82266188h case    1:*/		return 0x8226618C;
		  /* 8226618Ch */ case    2:  		/* lwz R30, <#[R21 + 1452]> */
		/* 8226618Ch case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R21 + 0x000005AC) );
		/* 8226618Ch case    2:*/		return 0x82266190;
		  /* 82266190h */ case    3:  		/* mr R3, R30 */
		/* 82266190h case    3:*/		regs.R3 = regs.R30;
		/* 82266190h case    3:*/		return 0x82266194;
		  /* 82266194h */ case    4:  		/* lwz R11, <#[R11 + 4]> */
		/* 82266194h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82266194h case    4:*/		return 0x82266198;
		  /* 82266198h */ case    5:  		/* addi R11, R11, -1 */
		/* 82266198h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82266198h case    5:*/		return 0x8226619C;
		  /* 8226619Ch */ case    6:  		/* cmplw CR6, R26, R11 */
		/* 8226619Ch case    6:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R11);
		/* 8226619Ch case    6:*/		return 0x822661A0;
		  /* 822661A0h */ case    7:  		/* bc 4, CR6_EQ, 44 */
		/* 822661A0h case    7:*/		if ( !regs.CR[6].eq ) { return 0x822661CC;  }
		/* 822661A0h case    7:*/		return 0x822661A4;
		  /* 822661A4h */ case    8:  		/* bl -302316 */
		/* 822661A4h case    8:*/		regs.LR = 0x822661A8; return 0x8221C4B8;
		/* 822661A4h case    8:*/		return 0x822661A8;
		  /* 822661A8h */ case    9:  		/* mr R11, R3 */
		/* 822661A8h case    9:*/		regs.R11 = regs.R3;
		/* 822661A8h case    9:*/		return 0x822661AC;
		  /* 822661ACh */ case   10:  		/* addic. R3, R3, 4 */
		/* 822661ACh case   10:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 822661ACh case   10:*/		return 0x822661B0;
		  /* 822661B0h */ case   11:  		/* stw R30, <#[R11]> */
		/* 822661B0h case   11:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 822661B0h case   11:*/		return 0x822661B4;
		  /* 822661B4h */ case   12:  		/* bc 12, CR0_EQ, 64 */
		/* 822661B4h case   12:*/		if ( regs.CR[0].eq ) { return 0x822661F4;  }
		/* 822661B4h case   12:*/		return 0x822661B8;
		  /* 822661B8h */ case   13:  		/* mr R6, R21 */
		/* 822661B8h case   13:*/		regs.R6 = regs.R21;
		/* 822661B8h case   13:*/		return 0x822661BC;
		  /* 822661BCh */ case   14:  		/* mr R5, R24 */
		/* 822661BCh case   14:*/		regs.R5 = regs.R24;
		/* 822661BCh case   14:*/		return 0x822661C0;
		  /* 822661C0h */ case   15:  		/* mr R4, R17 */
		/* 822661C0h case   15:*/		regs.R4 = regs.R17;
		/* 822661C0h case   15:*/		return 0x822661C4;
		  /* 822661C4h */ case   16:  		/* bl -58724 */
		/* 822661C4h case   16:*/		regs.LR = 0x822661C8; return 0x82257C60;
		/* 822661C4h case   16:*/		return 0x822661C8;
		  /* 822661C8h */ case   17:  		/* b 48 */
		/* 822661C8h case   17:*/		return 0x822661F8;
		/* 822661C8h case   17:*/		return 0x822661CC;
	}
	return 0x822661CC;
} // Block from 82266184h-822661CCh (18 instructions)

//////////////////////////////////////////////////////
// Block at 822661CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822661CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822661CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822661CC);
		  /* 822661CCh */ case    0:  		/* bl -302356 */
		/* 822661CCh case    0:*/		regs.LR = 0x822661D0; return 0x8221C4B8;
		/* 822661CCh case    0:*/		return 0x822661D0;
		  /* 822661D0h */ case    1:  		/* mr R11, R3 */
		/* 822661D0h case    1:*/		regs.R11 = regs.R3;
		/* 822661D0h case    1:*/		return 0x822661D4;
		  /* 822661D4h */ case    2:  		/* addic. R3, R3, 4 */
		/* 822661D4h case    2:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 822661D4h case    2:*/		return 0x822661D8;
		  /* 822661D8h */ case    3:  		/* stw R30, <#[R11]> */
		/* 822661D8h case    3:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 822661D8h case    3:*/		return 0x822661DC;
		  /* 822661DCh */ case    4:  		/* bc 12, CR0_EQ, 24 */
		/* 822661DCh case    4:*/		if ( regs.CR[0].eq ) { return 0x822661F4;  }
		/* 822661DCh case    4:*/		return 0x822661E0;
	}
	return 0x822661E0;
} // Block from 822661CCh-822661E0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822661E0h
// Function '?Update@Reference@XGRAPHICS@@QAAXPAVTNode@2@HPAPAX@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822661E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822661E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822661E0);
		  /* 822661E0h */ case    0:  		/* mr R6, R21 */
		/* 822661E0h case    0:*/		regs.R6 = regs.R21;
		/* 822661E0h case    0:*/		return 0x822661E4;
		  /* 822661E4h */ case    1:  		/* mr R5, R24 */
		/* 822661E4h case    1:*/		regs.R5 = regs.R24;
		/* 822661E4h case    1:*/		return 0x822661E8;
		  /* 822661E8h */ case    2:  		/* mr R4, R17 */
		/* 822661E8h case    2:*/		regs.R4 = regs.R17;
		/* 822661E8h case    2:*/		return 0x822661EC;
		  /* 822661ECh */ case    3:  		/* bl -58852 */
		/* 822661ECh case    3:*/		regs.LR = 0x822661F0; return 0x82257C08;
		/* 822661ECh case    3:*/		return 0x822661F0;
		  /* 822661F0h */ case    4:  		/* b 8 */
		/* 822661F0h case    4:*/		return 0x822661F8;
		/* 822661F0h case    4:*/		return 0x822661F4;
	}
	return 0x822661F4;
} // Block from 822661E0h-822661F4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822661F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822661F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822661F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822661F4);
		  /* 822661F4h */ case    0:  		/* mr R3, R19 */
		/* 822661F4h case    0:*/		regs.R3 = regs.R19;
		/* 822661F4h case    0:*/		return 0x822661F8;
	}
	return 0x822661F8;
} // Block from 822661F4h-822661F8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822661F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822661F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822661F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822661F8);
		  /* 822661F8h */ case    0:  		/* mr R5, R3 */
		/* 822661F8h case    0:*/		regs.R5 = regs.R3;
		/* 822661F8h case    0:*/		return 0x822661FC;
		  /* 822661FCh */ case    1:  		/* lwz R3, <#[R31 + 948]> */
		/* 822661FCh case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000003B4) );
		/* 822661FCh case    1:*/		return 0x82266200;
		  /* 82266200h */ case    2:  		/* mr R4, R31 */
		/* 82266200h case    2:*/		regs.R4 = regs.R31;
		/* 82266200h case    2:*/		return 0x82266204;
		  /* 82266204h */ case    3:  		/* bl -53732 */
		/* 82266204h case    3:*/		regs.LR = 0x82266208; return 0x82259020;
		/* 82266204h case    3:*/		return 0x82266208;
	}
	return 0x82266208;
} // Block from 822661F8h-82266208h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82266208h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266208( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266208) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266208);
		  /* 82266208h */ case    0:  		/* cmpw CR6, R28, R25 */
		/* 82266208h case    0:*/		cpu::op::cmpw<6>(regs,regs.R28,regs.R25);
		/* 82266208h case    0:*/		return 0x8226620C;
		  /* 8226620Ch */ case    1:  		/* bc 4, CR6_EQ, 220 */
		/* 8226620Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x822662E8;  }
		/* 8226620Ch case    1:*/		return 0x82266210;
		  /* 82266210h */ case    2:  		/* add R10, R28, R27 */
		/* 82266210h case    2:*/		cpu::op::add<0>(regs,&regs.R10,regs.R28,regs.R27);
		/* 82266210h case    2:*/		return 0x82266214;
		  /* 82266214h */ case    3:  		/* lwz R11, <#[R20 + 52]> */
		/* 82266214h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000034) );
		/* 82266214h case    3:*/		return 0x82266218;
		  /* 82266218h */ case    4:  		/* rlwinm R10, R10, 3, 0, 28 */
		/* 82266218h case    4:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R10);
		/* 82266218h case    4:*/		return 0x8226621C;
		  /* 8226621Ch */ case    5:  		/* add R11, R10, R11 */
		/* 8226621Ch case    5:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8226621Ch case    5:*/		return 0x82266220;
		  /* 82266220h */ case    6:  		/* lwz R31, <#[R11]> */
		/* 82266220h case    6:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000000) );
		/* 82266220h case    6:*/		return 0x82266224;
		  /* 82266224h */ case    7:  		/* lwz R30, <#[R11 + 4]> */
		/* 82266224h case    7:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000004) );
		/* 82266224h case    7:*/		return 0x82266228;
		  /* 82266228h */ case    8:  		/* cmplwi CR6, R31, 0 */
		/* 82266228h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82266228h case    8:*/		return 0x8226622C;
		  /* 8226622Ch */ case    9:  		/* bc 12, CR6_EQ, 68 */
		/* 8226622Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x82266270;  }
		/* 8226622Ch case    9:*/		return 0x82266230;
		  /* 82266230h */ case   10:  		/* cmplwi CR6, R30, 0 */
		/* 82266230h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82266230h case   10:*/		return 0x82266234;
		  /* 82266234h */ case   11:  		/* bc 12, CR6_EQ, 64 */
		/* 82266234h case   11:*/		if ( regs.CR[6].eq ) { return 0x82266274;  }
		/* 82266234h case   11:*/		return 0x82266238;
		  /* 82266238h */ case   12:  		/* cmplw CR6, R30, R31 */
		/* 82266238h case   12:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R31);
		/* 82266238h case   12:*/		return 0x8226623C;
		  /* 8226623Ch */ case   13:  		/* bc 12, CR6_EQ, 52 */
		/* 8226623Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x82266270;  }
		/* 8226623Ch case   13:*/		return 0x82266240;
		  /* 82266240h */ case   14:  		/* lwz R29, <#[R30 + 4]> */
		/* 82266240h case   14:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R30 + 0x00000004) );
		/* 82266240h case   14:*/		return 0x82266244;
		  /* 82266244h */ case   15:  		/* b 36 */
		/* 82266244h case   15:*/		return 0x82266268;
		/* 82266244h case   15:*/		return 0x82266248;
		  /* 82266248h */ case   16:  		/* lwz R29, <#[R29 + 4]> */
		/* 82266248h case   16:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R29 + 0x00000004) );
		/* 82266248h case   16:*/		return 0x8226624C;
		  /* 8226624Ch */ case   17:  		/* mr R3, R29 */
		/* 8226624Ch case   17:*/		regs.R3 = regs.R29;
		/* 8226624Ch case   17:*/		return 0x82266250;
		  /* 82266250h */ case   18:  		/* lwz R11, <#[R29]> */
		/* 82266250h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82266250h case   18:*/		return 0x82266254;
		  /* 82266254h */ case   19:  		/* lwz R11, <#[R11 + 36]> */
		/* 82266254h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 82266254h case   19:*/		return 0x82266258;
		  /* 82266258h */ case   20:  		/* mtspr CTR, R11 */
		/* 82266258h case   20:*/		regs.CTR = regs.R11;
		/* 82266258h case   20:*/		return 0x8226625C;
		  /* 8226625Ch */ case   21:  		/* bcctrl 20, CR0_LT */
		/* 8226625Ch case   21:*/		if ( 1 ) { regs.LR = 0x82266260; return (uint32)regs.CTR; }
		/* 8226625Ch case   21:*/		return 0x82266260;
		  /* 82266260h */ case   22:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82266260h case   22:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82266260h case   22:*/		return 0x82266264;
		  /* 82266264h */ case   23:  		/* bc 4, CR0_EQ, 16 */
		/* 82266264h case   23:*/		if ( !regs.CR[0].eq ) { return 0x82266274;  }
		/* 82266264h case   23:*/		return 0x82266268;
	}
	return 0x82266268;
} // Block from 82266208h-82266268h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82266268h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266268( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266268) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266268);
		  /* 82266268h */ case    0:  		/* cmplw CR6, R29, R31 */
		/* 82266268h case    0:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R31);
		/* 82266268h case    0:*/		return 0x8226626C;
		  /* 8226626Ch */ case    1:  		/* bc 4, CR6_EQ, -36 */
		/* 8226626Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82266248;  }
		/* 8226626Ch case    1:*/		return 0x82266270;
	}
	return 0x82266270;
} // Block from 82266268h-82266270h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82266270h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266270( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266270) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266270);
		  /* 82266270h */ case    0:  		/* mr R31, R30 */
		/* 82266270h case    0:*/		regs.R31 = regs.R30;
		/* 82266270h case    0:*/		return 0x82266274;
	}
	return 0x82266274;
} // Block from 82266270h-82266274h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82266274h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266274( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266274) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266274);
		  /* 82266274h */ case    0:  		/* lwz R11, <#[R22 + 4]> */
		/* 82266274h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000004) );
		/* 82266274h case    0:*/		return 0x82266278;
		  /* 82266278h */ case    1:  		/* li R4, 964 */
		/* 82266278h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x3C4);
		/* 82266278h case    1:*/		return 0x8226627C;
		  /* 8226627Ch */ case    2:  		/* lwz R30, <#[R21 + 1452]> */
		/* 8226627Ch case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R21 + 0x000005AC) );
		/* 8226627Ch case    2:*/		return 0x82266280;
		  /* 82266280h */ case    3:  		/* mr R3, R30 */
		/* 82266280h case    3:*/		regs.R3 = regs.R30;
		/* 82266280h case    3:*/		return 0x82266284;
		  /* 82266284h */ case    4:  		/* lwz R11, <#[R11 + 4]> */
		/* 82266284h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82266284h case    4:*/		return 0x82266288;
		  /* 82266288h */ case    5:  		/* addi R11, R11, -1 */
		/* 82266288h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82266288h case    5:*/		return 0x8226628C;
		  /* 8226628Ch */ case    6:  		/* cmplw CR6, R26, R11 */
		/* 8226628Ch case    6:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R11);
		/* 8226628Ch case    6:*/		return 0x82266290;
		  /* 82266290h */ case    7:  		/* bc 4, CR6_EQ, 36 */
		/* 82266290h case    7:*/		if ( !regs.CR[6].eq ) { return 0x822662B4;  }
		/* 82266290h case    7:*/		return 0x82266294;
		  /* 82266294h */ case    8:  		/* bl -302556 */
		/* 82266294h case    8:*/		regs.LR = 0x82266298; return 0x8221C4B8;
		/* 82266294h case    8:*/		return 0x82266298;
		  /* 82266298h */ case    9:  		/* mr R11, R3 */
		/* 82266298h case    9:*/		regs.R11 = regs.R3;
		/* 82266298h case    9:*/		return 0x8226629C;
		  /* 8226629Ch */ case   10:  		/* addic. R3, R3, 4 */
		/* 8226629Ch case   10:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 8226629Ch case   10:*/		return 0x822662A0;
		  /* 822662A0h */ case   11:  		/* stw R30, <#[R11]> */
		/* 822662A0h case   11:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 822662A0h case   11:*/		return 0x822662A4;
		  /* 822662A4h */ case   12:  		/* bc 12, CR0_EQ, 48 */
		/* 822662A4h case   12:*/		if ( regs.CR[0].eq ) { return 0x822662D4;  }
		/* 822662A4h case   12:*/		return 0x822662A8;
		  /* 822662A8h */ case   13:  		/* mr R4, R21 */
		/* 822662A8h case   13:*/		regs.R4 = regs.R21;
		/* 822662A8h case   13:*/		return 0x822662AC;
		  /* 822662ACh */ case   14:  		/* bl -58780 */
		/* 822662ACh case   14:*/		regs.LR = 0x822662B0; return 0x82257D10;
		/* 822662ACh case   14:*/		return 0x822662B0;
		  /* 822662B0h */ case   15:  		/* b 40 */
		/* 822662B0h case   15:*/		return 0x822662D8;
		/* 822662B0h case   15:*/		return 0x822662B4;
	}
	return 0x822662B4;
} // Block from 82266274h-822662B4h (16 instructions)

//////////////////////////////////////////////////////
// Block at 822662B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822662B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822662B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822662B4);
		  /* 822662B4h */ case    0:  		/* bl -302588 */
		/* 822662B4h case    0:*/		regs.LR = 0x822662B8; return 0x8221C4B8;
		/* 822662B4h case    0:*/		return 0x822662B8;
		  /* 822662B8h */ case    1:  		/* mr R11, R3 */
		/* 822662B8h case    1:*/		regs.R11 = regs.R3;
		/* 822662B8h case    1:*/		return 0x822662BC;
		  /* 822662BCh */ case    2:  		/* addic. R3, R3, 4 */
		/* 822662BCh case    2:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R3,0x4);
		/* 822662BCh case    2:*/		return 0x822662C0;
		  /* 822662C0h */ case    3:  		/* stw R30, <#[R11]> */
		/* 822662C0h case    3:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000000) );
		/* 822662C0h case    3:*/		return 0x822662C4;
		  /* 822662C4h */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 822662C4h case    4:*/		if ( regs.CR[0].eq ) { return 0x822662D4;  }
		/* 822662C4h case    4:*/		return 0x822662C8;
		  /* 822662C8h */ case    5:  		/* mr R4, R21 */
		/* 822662C8h case    5:*/		regs.R4 = regs.R21;
		/* 822662C8h case    5:*/		return 0x822662CC;
		  /* 822662CCh */ case    6:  		/* bl -58900 */
		/* 822662CCh case    6:*/		regs.LR = 0x822662D0; return 0x82257CB8;
		/* 822662CCh case    6:*/		return 0x822662D0;
		  /* 822662D0h */ case    7:  		/* b 8 */
		/* 822662D0h case    7:*/		return 0x822662D8;
		/* 822662D0h case    7:*/		return 0x822662D4;
	}
	return 0x822662D4;
} // Block from 822662B4h-822662D4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 822662D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822662D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822662D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822662D4);
		  /* 822662D4h */ case    0:  		/* mr R3, R19 */
		/* 822662D4h case    0:*/		regs.R3 = regs.R19;
		/* 822662D4h case    0:*/		return 0x822662D8;
	}
	return 0x822662D8;
} // Block from 822662D4h-822662D8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822662D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822662D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822662D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822662D8);
		  /* 822662D8h */ case    0:  		/* mr R5, R3 */
		/* 822662D8h case    0:*/		regs.R5 = regs.R3;
		/* 822662D8h case    0:*/		return 0x822662DC;
		  /* 822662DCh */ case    1:  		/* lwz R3, <#[R31 + 948]> */
		/* 822662DCh case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x000003B4) );
		/* 822662DCh case    1:*/		return 0x822662E0;
		  /* 822662E0h */ case    2:  		/* mr R4, R31 */
		/* 822662E0h case    2:*/		regs.R4 = regs.R31;
		/* 822662E0h case    2:*/		return 0x822662E4;
		  /* 822662E4h */ case    3:  		/* bl -54052 */
		/* 822662E4h case    3:*/		regs.LR = 0x822662E8; return 0x82258FC0;
		/* 822662E4h case    3:*/		return 0x822662E8;
	}
	return 0x822662E8;
} // Block from 822662D8h-822662E8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822662E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822662E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822662E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822662E8);
		  /* 822662E8h */ case    0:  		/* add R11, R28, R27 */
		/* 822662E8h case    0:*/		cpu::op::add<0>(regs,&regs.R11,regs.R28,regs.R27);
		/* 822662E8h case    0:*/		return 0x822662EC;
		  /* 822662ECh */ case    1:  		/* lwz R10, <#[R22 + 4]> */
		/* 822662ECh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R22 + 0x00000004) );
		/* 822662ECh case    1:*/		return 0x822662F0;
	}
	return 0x822662F0;
} // Block from 822662E8h-822662F0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822662F0h
// Function '?BuildSuffixTree@TNode@XGRAPHICS@@SAPAV12@HPAPAXPAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822662F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822662F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822662F0);
		  /* 822662F0h */ case    0:  		/* addi R28, R28, 1 */
		/* 822662F0h case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 822662F0h case    0:*/		return 0x822662F4;
		  /* 822662F4h */ case    1:  		/* rlwinm R11, R11, 3, 0, 28 */
		/* 822662F4h case    1:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R11,regs.R11);
		/* 822662F4h case    1:*/		return 0x822662F8;
		  /* 822662F8h */ case    2:  		/* cmpw CR6, R28, R24 */
		/* 822662F8h case    2:*/		cpu::op::cmpw<6>(regs,regs.R28,regs.R24);
		/* 822662F8h case    2:*/		return 0x822662FC;
		  /* 822662FCh */ case    3:  		/* add R9, R11, R18 */
		/* 822662FCh case    3:*/		cpu::op::add<0>(regs,&regs.R9,regs.R11,regs.R18);
		/* 822662FCh case    3:*/		return 0x82266300;
		  /* 82266300h */ case    4:  		/* lwz R11, <#[R10 + 4]> */
		/* 82266300h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 82266300h case    4:*/		return 0x82266304;
		  /* 82266304h */ case    5:  		/* addi R11, R11, -1 */
		/* 82266304h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82266304h case    5:*/		return 0x82266308;
		  /* 82266308h */ case    6:  		/* subf R11, R26, R11 */
		/* 82266308h case    6:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R26,regs.R11);
		/* 82266308h case    6:*/		return 0x8226630C;
		  /* 8226630Ch */ case    7:  		/* cntlzw R11, R11 */
		/* 8226630Ch case    7:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 8226630Ch case    7:*/		return 0x82266310;
		  /* 82266310h */ case    8:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 82266310h case    8:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 82266310h case    8:*/		return 0x82266314;
		  /* 82266314h */ case    9:  		/* xori R11, R11, 1 */
		/* 82266314h case    9:*/		cpu::op::xori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82266314h case    9:*/		return 0x82266318;
		  /* 82266318h */ case   10:  		/* addi R11, R11, 2 */
		/* 82266318h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 82266318h case   10:*/		return 0x8226631C;
		  /* 8226631Ch */ case   11:  		/* stw R11, <#[R9 + 4]> */
		/* 8226631Ch case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 8226631Ch case   11:*/		return 0x82266320;
		  /* 82266320h */ case   12:  		/* bc 12, CR6_LT, -516 */
		/* 82266320h case   12:*/		if ( regs.CR[6].lt ) { return 0x8226611C;  }
		/* 82266320h case   12:*/		return 0x82266324;
	}
	return 0x82266324;
} // Block from 822662F0h-82266324h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82266324h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266324( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266324) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266324);
		  /* 82266324h */ case    0:  		/* lwz R3, <#[R22 + 4]> */
		/* 82266324h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R22 + 0x00000004) );
		/* 82266324h case    0:*/		return 0x82266328;
		  /* 82266328h */ case    1:  		/* addi R26, R26, 1 */
		/* 82266328h case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 82266328h case    1:*/		return 0x8226632C;
		  /* 8226632Ch */ case    2:  		/* addi R23, R23, 4 */
		/* 8226632Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0x4);
		/* 8226632Ch case    2:*/		return 0x82266330;
		  /* 82266330h */ case    3:  		/* lwz R11, <#[R3 + 4]> */
		/* 82266330h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82266330h case    3:*/		return 0x82266334;
		  /* 82266334h */ case    4:  		/* cmplw CR6, R26, R11 */
		/* 82266334h case    4:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R11);
		/* 82266334h case    4:*/		return 0x82266338;
		  /* 82266338h */ case    5:  		/* bc 12, CR6_LT, -592 */
		/* 82266338h case    5:*/		if ( regs.CR[6].lt ) { return 0x822660E8;  }
		/* 82266338h case    5:*/		return 0x8226633C;
	}
	return 0x8226633C;
} // Block from 82266324h-8226633Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8226633Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226633C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226633C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226633C);
		  /* 8226633Ch */ case    0:  		/* lwz R11, <#[R20 + 96]> */
		/* 8226633Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000060) );
		/* 8226633Ch case    0:*/		return 0x82266340;
		  /* 82266340h */ case    1:  		/* addi R16, R16, 1 */
		/* 82266340h case    1:*/		cpu::op::addi<0>(regs,&regs.R16,regs.R16,0x1);
		/* 82266340h case    1:*/		return 0x82266344;
		  /* 82266344h */ case    2:  		/* addi R15, R15, 4 */
		/* 82266344h case    2:*/		cpu::op::addi<0>(regs,&regs.R15,regs.R15,0x4);
		/* 82266344h case    2:*/		return 0x82266348;
		  /* 82266348h */ case    3:  		/* lwz R11, <#[R11 + 4]> */
		/* 82266348h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82266348h case    3:*/		return 0x8226634C;
		  /* 8226634Ch */ case    4:  		/* cmplw CR6, R16, R11 */
		/* 8226634Ch case    4:*/		cpu::op::cmplw<6>(regs,regs.R16,regs.R11);
		/* 8226634Ch case    4:*/		return 0x82266350;
		  /* 82266350h */ case    5:  		/* bc 12, CR6_LT, -968 */
		/* 82266350h case    5:*/		if ( regs.CR[6].lt ) { return 0x82265F88;  }
		/* 82266350h case    5:*/		return 0x82266354;
	}
	return 0x82266354;
} // Block from 8226633Ch-82266354h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82266354h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266354( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266354) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266354);
		  /* 82266354h */ case    0:  		/* addi R5, R17, 1 */
		/* 82266354h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R17,0x1);
		/* 82266354h case    0:*/		return 0x82266358;
		  /* 82266358h */ case    1:  		/* lis R11, -32251 */
		/* 82266358h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82266358h case    1:*/		return 0x8226635C;
		  /* 8226635Ch */ case    2:  		/* stw R5, <#[R21 + 1532]> */
		/* 8226635Ch case    2:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R21 + 0x000005FC) );
		/* 8226635Ch case    2:*/		return 0x82266360;
		  /* 82266360h */ case    3:  		/* mr R3, R21 */
		/* 82266360h case    3:*/		regs.R3 = regs.R21;
		/* 82266360h case    3:*/		return 0x82266364;
		  /* 82266364h */ case    4:  		/* addi R4, R11, -18148 */
		/* 82266364h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFB91C);
		/* 82266364h case    4:*/		return 0x82266368;
		  /* 82266368h */ case    5:  		/* bl -298920 */
		/* 82266368h case    5:*/		regs.LR = 0x8226636C; return 0x8221D3C0;
		/* 82266368h case    5:*/		return 0x8226636C;
		  /* 8226636Ch */ case    6:  		/* lwz R11, <#[R21 + 1436]> */
		/* 8226636Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x0000059C) );
		/* 8226636Ch case    6:*/		return 0x82266370;
		  /* 82266370h */ case    7:  		/* mr R4, R18 */
		/* 82266370h case    7:*/		regs.R4 = regs.R18;
		/* 82266370h case    7:*/		return 0x82266374;
		  /* 82266374h */ case    8:  		/* lwz R3, <#[R21 + 1444]> */
		/* 82266374h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R21 + 0x000005A4) );
		/* 82266374h case    8:*/		return 0x82266378;
		  /* 82266378h */ case    9:  		/* mtspr CTR, R11 */
		/* 82266378h case    9:*/		regs.CTR = regs.R11;
		/* 82266378h case    9:*/		return 0x8226637C;
		  /* 8226637Ch */ case   10:  		/* bcctrl 20, CR0_LT */
		/* 8226637Ch case   10:*/		if ( 1 ) { regs.LR = 0x82266380; return (uint32)regs.CTR; }
		/* 8226637Ch case   10:*/		return 0x82266380;
		  /* 82266380h */ case   11:  		/* addi R1, R1, 224 */
		/* 82266380h case   11:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xE0);
		/* 82266380h case   11:*/		return 0x82266384;
		  /* 82266384h */ case   12:  		/* b -1921296 */
		/* 82266384h case   12:*/		return 0x82091274;
		/* 82266384h case   12:*/		return 0x82266388;
	}
	return 0x82266388;
} // Block from 82266354h-82266388h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82266388h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266388( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266388) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266388);
		  /* 82266388h */ case    0:  		/* mfspr R12, LR */
		/* 82266388h case    0:*/		regs.R12 = regs.LR;
		/* 82266388h case    0:*/		return 0x8226638C;
		  /* 8226638Ch */ case    1:  		/* bl -1921340 */
		/* 8226638Ch case    1:*/		regs.LR = 0x82266390; return 0x82091250;
		/* 8226638Ch case    1:*/		return 0x82266390;
		  /* 82266390h */ case    2:  		/* stfd FR30, <#[R1 - 72]> */
		/* 82266390h case    2:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R1 + 0xFFFFFFB8) );
		/* 82266390h case    2:*/		return 0x82266394;
		  /* 82266394h */ case    3:  		/* stfd FR31, <#[R1 - 64]> */
		/* 82266394h case    3:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFC0) );
		/* 82266394h case    3:*/		return 0x82266398;
		  /* 82266398h */ case    4:  		/* stwu R1, <#[R1 - 192]> */
		/* 82266398h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 82266398h case    4:*/		return 0x8226639C;
		  /* 8226639Ch */ case    5:  		/* lis R11, -32256 */
		/* 8226639Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8226639Ch case    5:*/		return 0x822663A0;
		  /* 822663A0h */ case    6:  		/* mr R26, R4 */
		/* 822663A0h case    6:*/		regs.R26 = regs.R4;
		/* 822663A0h case    6:*/		return 0x822663A4;
		  /* 822663A4h */ case    7:  		/* lfs FR0, <#[R11 + 1816]> */
		/* 822663A4h case    7:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000718) );
		/* 822663A4h case    7:*/		return 0x822663A8;
		  /* 822663A8h */ case    8:  		/* fcmpu CR6, FR1, FR0 */
		/* 822663A8h case    8:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 822663A8h case    8:*/		return 0x822663AC;
		  /* 822663ACh */ case    9:  		/* bc 12, CR6_LT, 12 */
		/* 822663ACh case    9:*/		if ( regs.CR[6].lt ) { return 0x822663B8;  }
		/* 822663ACh case    9:*/		return 0x822663B0;
		  /* 822663B0h */ case   10:  		/* li R27, 43 */
		/* 822663B0h case   10:*/		cpu::op::li<0>(regs,&regs.R27,0x2B);
		/* 822663B0h case   10:*/		return 0x822663B4;
		  /* 822663B4h */ case   11:  		/* b 12 */
		/* 822663B4h case   11:*/		return 0x822663C0;
		/* 822663B4h case   11:*/		return 0x822663B8;
	}
	return 0x822663B8;
} // Block from 82266388h-822663B8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 822663B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822663B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822663B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822663B8);
		  /* 822663B8h */ case    0:  		/* li R27, 45 */
		/* 822663B8h case    0:*/		cpu::op::li<0>(regs,&regs.R27,0x2D);
		/* 822663B8h case    0:*/		return 0x822663BC;
		  /* 822663BCh */ case    1:  		/* fneg FR1, FR1 */
		/* 822663BCh case    1:*/		cpu::op::fneg<0>(regs,&regs.FR1,regs.FR1);
		/* 822663BCh case    1:*/		return 0x822663C0;
	}
	return 0x822663C0;
} // Block from 822663B8h-822663C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822663C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822663C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822663C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822663C0);
		  /* 822663C0h */ case    0:  		/* fctiwz FR0, FR1 */
		/* 822663C0h case    0:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR1);
		/* 822663C0h case    0:*/		return 0x822663C4;
		  /* 822663C4h */ case    1:  		/* stfd FR0, <#[R1 + 80]> */
		/* 822663C4h case    1:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 822663C4h case    1:*/		return 0x822663C8;
		  /* 822663C8h */ case    2:  		/* lwz R28, <#[R1 + 84]> */
		/* 822663C8h case    2:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000054) );
		/* 822663C8h case    2:*/		return 0x822663CC;
		  /* 822663CCh */ case    3:  		/* extsw R11, R28 */
		/* 822663CCh case    3:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R28);
		/* 822663CCh case    3:*/		return 0x822663D0;
		  /* 822663D0h */ case    4:  		/* std R11, <#[R1 + 80]> */
		/* 822663D0h case    4:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 822663D0h case    4:*/		return 0x822663D4;
		  /* 822663D4h */ case    5:  		/* lfd FR0, <#[R1 + 80]> */
		/* 822663D4h case    5:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 822663D4h case    5:*/		return 0x822663D8;
		  /* 822663D8h */ case    6:  		/* fcfid FR0, FR0 */
		/* 822663D8h case    6:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 822663D8h case    6:*/		return 0x822663DC;
		  /* 822663DCh */ case    7:  		/* lis R10, -32256 */
		/* 822663DCh case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 822663DCh case    7:*/		return 0x822663E0;
		  /* 822663E0h */ case    8:  		/* frsp FR0, FR0 */
		/* 822663E0h case    8:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 822663E0h case    8:*/		return 0x822663E4;
		  /* 822663E4h */ case    9:  		/* lis R11, -32253 */
		/* 822663E4h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 822663E4h case    9:*/		return 0x822663E8;
		  /* 822663E8h */ case   10:  		/* lfs FR30, <#[R10 + 2736]> */
		/* 822663E8h case   10:*/		cpu::mem::load32f( regs, &regs.FR30, (uint32)(regs.R10 + 0x00000AB0) );
		/* 822663E8h case   10:*/		return 0x822663EC;
		  /* 822663ECh */ case   11:  		/* li R31, 0 */
		/* 822663ECh case   11:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 822663ECh case   11:*/		return 0x822663F0;
		  /* 822663F0h */ case   12:  		/* addi R29, R11, 26668 */
		/* 822663F0h case   12:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x682C);
		/* 822663F0h case   12:*/		return 0x822663F4;
		  /* 822663F4h */ case   13:  		/* fsubs FR31, FR1, FR0 */
		/* 822663F4h case   13:*/		cpu::op::fsubs<0>(regs,&regs.FR31,regs.FR1,regs.FR0);
		/* 822663F4h case   13:*/		return 0x822663F8;
		  /* 822663F8h */ case   14:  		/* fctiwz FR0, FR31 */
		/* 822663F8h case   14:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR31);
		/* 822663F8h case   14:*/		return 0x822663FC;
		  /* 822663FCh */ case   15:  		/* stfd FR0, <#[R1 + 80]> */
		/* 822663FCh case   15:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 822663FCh case   15:*/		return 0x82266400;
	}
	return 0x82266400;
} // Block from 822663C0h-82266400h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82266400h
// Function '??0Fragment@XGRAPHICS@@QAA@PAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266400( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266400) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266400);
		  /* 82266400h */ case    0:  		/* lwz R30, <#[R1 + 84]> */
		/* 82266400h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000054) );
		/* 82266400h case    0:*/		return 0x82266404;
		  /* 82266404h */ case    1:  		/* extsw R10, R30 */
		/* 82266404h case    1:*/		cpu::op::extsw<0>(regs,&regs.R10,regs.R30);
		/* 82266404h case    1:*/		return 0x82266408;
		  /* 82266408h */ case    2:  		/* addi R11, R1, 96 */
		/* 82266408h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 82266408h case    2:*/		return 0x8226640C;
		  /* 8226640Ch */ case    3:  		/* std R10, <#[R1 + 80]> */
		/* 8226640Ch case    3:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 8226640Ch case    3:*/		return 0x82266410;
		  /* 82266410h */ case    4:  		/* lfd FR0, <#[R1 + 80]> */
		/* 82266410h case    4:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 82266410h case    4:*/		return 0x82266414;
		  /* 82266414h */ case    5:  		/* fcfid FR0, FR0 */
		/* 82266414h case    5:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 82266414h case    5:*/		return 0x82266418;
		  /* 82266418h */ case    6:  		/* mr R4, R29 */
		/* 82266418h case    6:*/		regs.R4 = regs.R29;
		/* 82266418h case    6:*/		return 0x8226641C;
		  /* 8226641Ch */ case    7:  		/* frsp FR0, FR0 */
		/* 8226641Ch case    7:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 8226641Ch case    7:*/		return 0x82266420;
		  /* 82266420h */ case    8:  		/* add R3, R31, R11 */
		/* 82266420h case    8:*/		cpu::op::add<0>(regs,&regs.R3,regs.R31,regs.R11);
		/* 82266420h case    8:*/		return 0x82266424;
		  /* 82266424h */ case    9:  		/* fsubs FR0, FR31, FR0 */
		/* 82266424h case    9:*/		cpu::op::fsubs<0>(regs,&regs.FR0,regs.FR31,regs.FR0);
		/* 82266424h case    9:*/		return 0x82266428;
		  /* 82266428h */ case   10:  		/* fmuls FR31, FR0, FR30 */
		/* 82266428h case   10:*/		cpu::op::fmuls<0>(regs,&regs.FR31,regs.FR0,regs.FR30);
		/* 82266428h case   10:*/		return 0x8226642C;
		  /* 8226642Ch */ case   11:  		/* fctiwz FR0, FR31 */
		/* 8226642Ch case   11:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR31);
		/* 8226642Ch case   11:*/		return 0x82266430;
		  /* 82266430h */ case   12:  		/* stfd FR0, <#[R1 + 88]> */
		/* 82266430h case   12:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000058) );
		/* 82266430h case   12:*/		return 0x82266434;
		  /* 82266434h */ case   13:  		/* lwz R30, <#[R1 + 92]> */
		/* 82266434h case   13:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x0000005C) );
		/* 82266434h case   13:*/		return 0x82266438;
		  /* 82266438h */ case   14:  		/* mr R5, R30 */
		/* 82266438h case   14:*/		regs.R5 = regs.R30;
		/* 82266438h case   14:*/		return 0x8226643C;
		  /* 8226643Ch */ case   15:  		/* bl 10372 */
		/* 8226643Ch case   15:*/		regs.LR = 0x82266440; return 0x82268CC0;
		/* 8226643Ch case   15:*/		return 0x82266440;
		  /* 82266440h */ case   16:  		/* addi R31, R31, 1 */
		/* 82266440h case   16:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82266440h case   16:*/		return 0x82266444;
		  /* 82266444h */ case   17:  		/* cmpwi CR6, R31, 9 */
		/* 82266444h case   17:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000009);
		/* 82266444h case   17:*/		return 0x82266448;
		  /* 82266448h */ case   18:  		/* bc 12, CR6_LT, -68 */
		/* 82266448h case   18:*/		if ( regs.CR[6].lt ) { return 0x82266404;  }
		/* 82266448h case   18:*/		return 0x8226644C;
		  /* 8226644Ch */ case   19:  		/* li R11, 0 */
		/* 8226644Ch case   19:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8226644Ch case   19:*/		return 0x82266450;
		  /* 82266450h */ case   20:  		/* lis R10, -32251 */
		/* 82266450h case   20:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 82266450h case   20:*/		return 0x82266454;
		  /* 82266454h */ case   21:  		/* stb R11, <#[R1 + 105]> */
		/* 82266454h case   21:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000069) );
		/* 82266454h case   21:*/		return 0x82266458;
		  /* 82266458h */ case   22:  		/* addi R7, R1, 96 */
		/* 82266458h case   22:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x60);
		/* 82266458h case   22:*/		return 0x8226645C;
		  /* 8226645Ch */ case   23:  		/* addi R4, R10, -18108 */
		/* 8226645Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0xFFFFB944);
		/* 8226645Ch case   23:*/		return 0x82266460;
	}
	return 0x82266460;
} // Block from 82266400h-82266460h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82266460h
// Function '?SortFragments@Assembler@XGRAPHICS@@QAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266460( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266460) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266460);
		  /* 82266460h */ case    0:  		/* mr R6, R28 */
		/* 82266460h case    0:*/		regs.R6 = regs.R28;
		/* 82266460h case    0:*/		return 0x82266464;
		  /* 82266464h */ case    1:  		/* extsb R5, R27 */
		/* 82266464h case    1:*/		cpu::op::extsb<0>(regs,&regs.R5,regs.R27);
		/* 82266464h case    1:*/		return 0x82266468;
		  /* 82266468h */ case    2:  		/* mr R3, R26 */
		/* 82266468h case    2:*/		regs.R3 = regs.R26;
		/* 82266468h case    2:*/		return 0x8226646C;
		  /* 8226646Ch */ case    3:  		/* bl 10324 */
		/* 8226646Ch case    3:*/		regs.LR = 0x82266470; return 0x82268CC0;
		/* 8226646Ch case    3:*/		return 0x82266470;
		  /* 82266470h */ case    4:  		/* addi R1, R1, 192 */
		/* 82266470h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 82266470h case    4:*/		return 0x82266474;
		  /* 82266474h */ case    5:  		/* lfd FR30, <#[R1 - 72]> */
		/* 82266474h case    5:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R1 + 0xFFFFFFB8) );
		/* 82266474h case    5:*/		return 0x82266478;
		  /* 82266478h */ case    6:  		/* lfd FR31, <#[R1 - 64]> */
		/* 82266478h case    6:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFC0) );
		/* 82266478h case    6:*/		return 0x8226647C;
		  /* 8226647Ch */ case    7:  		/* b -1921500 */
		/* 8226647Ch case    7:*/		return 0x820912A0;
		/* 8226647Ch case    7:*/		return 0x82266480;
	}
	return 0x82266480;
} // Block from 82266460h-82266480h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82266480h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266480( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266480) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266480);
		  /* 82266480h */ case    0:  		/* mfspr R12, LR */
		/* 82266480h case    0:*/		regs.R12 = regs.LR;
		/* 82266480h case    0:*/		return 0x82266484;
		  /* 82266484h */ case    1:  		/* bl -1921580 */
		/* 82266484h case    1:*/		regs.LR = 0x82266488; return 0x82091258;
		/* 82266484h case    1:*/		return 0x82266488;
		  /* 82266488h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82266488h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82266488h case    2:*/		return 0x8226648C;
		  /* 8226648Ch */ case    3:  		/* lwz R10, <#[R4 + 228]> */
		/* 8226648Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x000000E4) );
		/* 8226648Ch case    3:*/		return 0x82266490;
		  /* 82266490h */ case    4:  		/* lis R11, -32216 */
		/* 82266490h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 82266490h case    4:*/		return 0x82266494;
		  /* 82266494h */ case    5:  		/* mr R28, R3 */
		/* 82266494h case    5:*/		regs.R28 = regs.R3;
		/* 82266494h case    5:*/		return 0x82266498;
		  /* 82266498h */ case    6:  		/* mr R31, R4 */
		/* 82266498h case    6:*/		regs.R31 = regs.R4;
		/* 82266498h case    6:*/		return 0x8226649C;
		  /* 8226649Ch */ case    7:  		/* li R30, 0 */
		/* 8226649Ch case    7:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 8226649Ch case    7:*/		return 0x822664A0;
		  /* 822664A0h */ case    8:  		/* rlwinm. R10, R10, 31, 31, 31 */
		/* 822664A0h case    8:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R10,regs.R10);
		/* 822664A0h case    8:*/		return 0x822664A4;
		  /* 822664A4h */ case    9:  		/* addi R29, R11, 17992 */
		/* 822664A4h case    9:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x4648);
		/* 822664A4h case    9:*/		return 0x822664A8;
		  /* 822664A8h */ case   10:  		/* bc 12, CR0_EQ, 12 */
		/* 822664A8h case   10:*/		if ( regs.CR[0].eq ) { return 0x822664B4;  }
		/* 822664A8h case   10:*/		return 0x822664AC;
		  /* 822664ACh */ case   11:  		/* li R11, 0 */
		/* 822664ACh case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 822664ACh case   11:*/		return 0x822664B0;
		  /* 822664B0h */ case   12:  		/* b 20 */
		/* 822664B0h case   12:*/		return 0x822664C4;
		/* 822664B0h case   12:*/		return 0x822664B4;
	}
	return 0x822664B4;
} // Block from 82266480h-822664B4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 822664B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822664B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822664B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822664B4);
		  /* 822664B4h */ case    0:  		/* lwz R11, <#[R31 + 24]> */
		/* 822664B4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 822664B4h case    0:*/		return 0x822664B8;
		  /* 822664B8h */ case    1:  		/* mulli R11, R11, 52 */
		/* 822664B8h case    1:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x34);
		/* 822664B8h case    1:*/		return 0x822664BC;
		  /* 822664BCh */ case    2:  		/* lwzx R11, <#[R11 + R29]> */
		/* 822664BCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 822664BCh case    2:*/		return 0x822664C0;
		  /* 822664C0h */ case    3:  		/* rlwinm R11, R11, 29, 31, 31 */
		/* 822664C0h case    3:*/		cpu::op::rlwinm<0,29,31,31>(regs,&regs.R11,regs.R11);
		/* 822664C0h case    3:*/		return 0x822664C4;
	}
	return 0x822664C4;
} // Block from 822664B4h-822664C4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822664C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822664C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822664C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822664C4);
		  /* 822664C4h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 822664C4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 822664C4h case    0:*/		return 0x822664C8;
		  /* 822664C8h */ case    1:  		/* bc 4, CR0_EQ, 20 */
		/* 822664C8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x822664DC;  }
		/* 822664C8h case    1:*/		return 0x822664CC;
		  /* 822664CCh */ case    2:  		/* lis R11, -32251 */
		/* 822664CCh case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 822664CCh case    2:*/		return 0x822664D0;
		  /* 822664D0h */ case    3:  		/* addi R11, R11, -18088 */
		/* 822664D0h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFB958);
		/* 822664D0h case    3:*/		return 0x822664D4;
		  /* 822664D4h */ case    4:  		/* addi R11, R11, 12 */
		/* 822664D4h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xC);
		/* 822664D4h case    4:*/		return 0x822664D8;
		  /* 822664D8h */ case    5:  		/* b 72 */
		/* 822664D8h case    5:*/		return 0x82266520;
		/* 822664D8h case    5:*/		return 0x822664DC;
	}
	return 0x822664DC;
} // Block from 822664C4h-822664DCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 822664DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822664DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822664DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822664DC);
		  /* 822664DCh */ case    0:  		/* lwz R11, <#[R31]> */
		/* 822664DCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822664DCh case    0:*/		return 0x822664E0;
		  /* 822664E0h */ case    1:  		/* mr R3, R31 */
		/* 822664E0h case    1:*/		regs.R3 = regs.R31;
		/* 822664E0h case    1:*/		return 0x822664E4;
		  /* 822664E4h */ case    2:  		/* lwz R11, <#[R11 + 52]> */
		/* 822664E4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000034) );
		/* 822664E4h case    2:*/		return 0x822664E8;
		  /* 822664E8h */ case    3:  		/* mtspr CTR, R11 */
		/* 822664E8h case    3:*/		regs.CTR = regs.R11;
		/* 822664E8h case    3:*/		return 0x822664EC;
		  /* 822664ECh */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 822664ECh case    4:*/		if ( 1 ) { regs.LR = 0x822664F0; return (uint32)regs.CTR; }
		/* 822664ECh case    4:*/		return 0x822664F0;
		  /* 822664F0h */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822664F0h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822664F0h case    5:*/		return 0x822664F4;
		  /* 822664F4h */ case    6:  		/* bc 4, CR0_EQ, 56 */
		/* 822664F4h case    6:*/		if ( !regs.CR[0].eq ) { return 0x8226652C;  }
		/* 822664F4h case    6:*/		return 0x822664F8;
		  /* 822664F8h */ case    7:  		/* lwz R11, <#[R31 + 24]> */
		/* 822664F8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 822664F8h case    7:*/		return 0x822664FC;
		  /* 822664FCh */ case    8:  		/* mulli R11, R11, 52 */
		/* 822664FCh case    8:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x34);
		/* 822664FCh case    8:*/		return 0x82266500;
		  /* 82266500h */ case    9:  		/* lwzx R11, <#[R11 + R29]> */
		/* 82266500h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 82266500h case    9:*/		return 0x82266504;
		  /* 82266504h */ case   10:  		/* rlwinm. R11, R11, 31, 31, 31 */
		/* 82266504h case   10:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R11,regs.R11);
		/* 82266504h case   10:*/		return 0x82266508;
		  /* 82266508h */ case   11:  		/* lis R11, -32251 */
		/* 82266508h case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82266508h case   11:*/		return 0x8226650C;
		  /* 8226650Ch */ case   12:  		/* addi R11, R11, -18088 */
		/* 8226650Ch case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFB958);
		/* 8226650Ch case   12:*/		return 0x82266510;
		  /* 82266510h */ case   13:  		/* bc 12, CR0_EQ, 12 */
		/* 82266510h case   13:*/		if ( regs.CR[0].eq ) { return 0x8226651C;  }
		/* 82266510h case   13:*/		return 0x82266514;
		  /* 82266514h */ case   14:  		/* addi R11, R11, 4 */
		/* 82266514h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 82266514h case   14:*/		return 0x82266518;
		  /* 82266518h */ case   15:  		/* b 8 */
		/* 82266518h case   15:*/		return 0x82266520;
		/* 82266518h case   15:*/		return 0x8226651C;
	}
	return 0x8226651C;
} // Block from 822664DCh-8226651Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 8226651Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226651C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226651C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226651C);
		  /* 8226651Ch */ case    0:  		/* addi R11, R11, 8 */
		/* 8226651Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x8);
		/* 8226651Ch case    0:*/		return 0x82266520;
	}
	return 0x82266520;
} // Block from 8226651Ch-82266520h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82266520h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266520( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266520) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266520);
		  /* 82266520h */ case    0:  		/* lwz R10, <#[R28 + 4]> */
		/* 82266520h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000004) );
		/* 82266520h case    0:*/		return 0x82266524;
		  /* 82266524h */ case    1:  		/* rlwinm R10, R10, 4, 0, 27 */
		/* 82266524h case    1:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R10,regs.R10);
		/* 82266524h case    1:*/		return 0x82266528;
		  /* 82266528h */ case    2:  		/* lwzx R30, <#[R10 + R11]> */
		/* 82266528h case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82266528h case    2:*/		return 0x8226652C;
	}
	return 0x8226652C;
} // Block from 82266520h-8226652Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8226652Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226652C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226652C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226652C);
		  /* 8226652Ch */ case    0:  		/* addi R11, R30, 1 */
		/* 8226652Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x1);
		/* 8226652Ch case    0:*/		return 0x82266530;
		  /* 82266530h */ case    1:  		/* addic R10, R11, -1 */
		/* 82266530h case    1:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R11,0xFFFFFFFF);
		/* 82266530h case    1:*/		return 0x82266534;
		  /* 82266534h */ case    2:  		/* subfe R3, R10, R11 */
		/* 82266534h case    2:*/		cpu::op::subfe<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 82266534h case    2:*/		return 0x82266538;
		  /* 82266538h */ case    3:  		/* addi R1, R1, 128 */
		/* 82266538h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82266538h case    3:*/		return 0x8226653C;
		  /* 8226653Ch */ case    4:  		/* b -1921684 */
		/* 8226653Ch case    4:*/		return 0x820912A8;
		/* 8226653Ch case    4:*/		return 0x82266540;
	}
	return 0x82266540;
} // Block from 8226652Ch-82266540h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82266540h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266540( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266540) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266540);
		  /* 82266540h */ case    0:  		/* mfspr R12, LR */
		/* 82266540h case    0:*/		regs.R12 = regs.LR;
		/* 82266540h case    0:*/		return 0x82266544;
		  /* 82266544h */ case    1:  		/* bl -1921768 */
		/* 82266544h case    1:*/		regs.LR = 0x82266548; return 0x8209125C;
		/* 82266544h case    1:*/		return 0x82266548;
		  /* 82266548h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 82266548h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82266548h case    2:*/		return 0x8226654C;
		  /* 8226654Ch */ case    3:  		/* lwz R10, <#[R4 + 228]> */
		/* 8226654Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x000000E4) );
		/* 8226654Ch case    3:*/		return 0x82266550;
		  /* 82266550h */ case    4:  		/* lis R11, -32216 */
		/* 82266550h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 82266550h case    4:*/		return 0x82266554;
		  /* 82266554h */ case    5:  		/* mr R30, R3 */
		/* 82266554h case    5:*/		regs.R30 = regs.R3;
		/* 82266554h case    5:*/		return 0x82266558;
		  /* 82266558h */ case    6:  		/* mr R31, R4 */
		/* 82266558h case    6:*/		regs.R31 = regs.R4;
		/* 82266558h case    6:*/		return 0x8226655C;
		  /* 8226655Ch */ case    7:  		/* rlwinm. R10, R10, 31, 31, 31 */
		/* 8226655Ch case    7:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R10,regs.R10);
		/* 8226655Ch case    7:*/		return 0x82266560;
		  /* 82266560h */ case    8:  		/* addi R29, R11, 17992 */
		/* 82266560h case    8:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x4648);
		/* 82266560h case    8:*/		return 0x82266564;
		  /* 82266564h */ case    9:  		/* bc 12, CR0_EQ, 12 */
		/* 82266564h case    9:*/		if ( regs.CR[0].eq ) { return 0x82266570;  }
		/* 82266564h case    9:*/		return 0x82266568;
		  /* 82266568h */ case   10:  		/* li R11, 0 */
		/* 82266568h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82266568h case   10:*/		return 0x8226656C;
		  /* 8226656Ch */ case   11:  		/* b 20 */
		/* 8226656Ch case   11:*/		return 0x82266580;
		/* 8226656Ch case   11:*/		return 0x82266570;
	}
	return 0x82266570;
} // Block from 82266540h-82266570h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82266570h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266570( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266570) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266570);
		  /* 82266570h */ case    0:  		/* lwz R11, <#[R31 + 24]> */
		/* 82266570h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 82266570h case    0:*/		return 0x82266574;
		  /* 82266574h */ case    1:  		/* mulli R11, R11, 52 */
		/* 82266574h case    1:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x34);
		/* 82266574h case    1:*/		return 0x82266578;
		  /* 82266578h */ case    2:  		/* lwzx R11, <#[R11 + R29]> */
		/* 82266578h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 82266578h case    2:*/		return 0x8226657C;
		  /* 8226657Ch */ case    3:  		/* rlwinm R11, R11, 29, 31, 31 */
		/* 8226657Ch case    3:*/		cpu::op::rlwinm<0,29,31,31>(regs,&regs.R11,regs.R11);
		/* 8226657Ch case    3:*/		return 0x82266580;
	}
	return 0x82266580;
} // Block from 82266570h-82266580h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82266580h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266580( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266580) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266580);
		  /* 82266580h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82266580h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82266580h case    0:*/		return 0x82266584;
		  /* 82266584h */ case    1:  		/* bc 4, CR0_EQ, 20 */
		/* 82266584h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82266598;  }
		/* 82266584h case    1:*/		return 0x82266588;
		  /* 82266588h */ case    2:  		/* lis R11, -32251 */
		/* 82266588h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82266588h case    2:*/		return 0x8226658C;
		  /* 8226658Ch */ case    3:  		/* addi R11, R11, -18088 */
		/* 8226658Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFB958);
		/* 8226658Ch case    3:*/		return 0x82266590;
		  /* 82266590h */ case    4:  		/* addi R11, R11, 12 */
		/* 82266590h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xC);
		/* 82266590h case    4:*/		return 0x82266594;
		  /* 82266594h */ case    5:  		/* b 72 */
		/* 82266594h case    5:*/		return 0x822665DC;
		/* 82266594h case    5:*/		return 0x82266598;
	}
	return 0x82266598;
} // Block from 82266580h-82266598h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82266598h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266598( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266598) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266598);
		  /* 82266598h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 82266598h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82266598h case    0:*/		return 0x8226659C;
		  /* 8226659Ch */ case    1:  		/* mr R3, R31 */
		/* 8226659Ch case    1:*/		regs.R3 = regs.R31;
		/* 8226659Ch case    1:*/		return 0x822665A0;
		  /* 822665A0h */ case    2:  		/* lwz R11, <#[R11 + 52]> */
		/* 822665A0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000034) );
		/* 822665A0h case    2:*/		return 0x822665A4;
		  /* 822665A4h */ case    3:  		/* mtspr CTR, R11 */
		/* 822665A4h case    3:*/		regs.CTR = regs.R11;
		/* 822665A4h case    3:*/		return 0x822665A8;
		  /* 822665A8h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 822665A8h case    4:*/		if ( 1 ) { regs.LR = 0x822665AC; return (uint32)regs.CTR; }
		/* 822665A8h case    4:*/		return 0x822665AC;
		  /* 822665ACh */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822665ACh case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822665ACh case    5:*/		return 0x822665B0;
		  /* 822665B0h */ case    6:  		/* bc 4, CR0_EQ, 60 */
		/* 822665B0h case    6:*/		if ( !regs.CR[0].eq ) { return 0x822665EC;  }
		/* 822665B0h case    6:*/		return 0x822665B4;
		  /* 822665B4h */ case    7:  		/* lwz R11, <#[R31 + 24]> */
		/* 822665B4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 822665B4h case    7:*/		return 0x822665B8;
		  /* 822665B8h */ case    8:  		/* mulli R11, R11, 52 */
		/* 822665B8h case    8:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x34);
		/* 822665B8h case    8:*/		return 0x822665BC;
		  /* 822665BCh */ case    9:  		/* lwzx R11, <#[R11 + R29]> */
		/* 822665BCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 822665BCh case    9:*/		return 0x822665C0;
		  /* 822665C0h */ case   10:  		/* rlwinm. R11, R11, 31, 31, 31 */
		/* 822665C0h case   10:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R11,regs.R11);
		/* 822665C0h case   10:*/		return 0x822665C4;
		  /* 822665C4h */ case   11:  		/* lis R11, -32251 */
		/* 822665C4h case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 822665C4h case   11:*/		return 0x822665C8;
		  /* 822665C8h */ case   12:  		/* addi R11, R11, -18088 */
		/* 822665C8h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFB958);
		/* 822665C8h case   12:*/		return 0x822665CC;
		  /* 822665CCh */ case   13:  		/* bc 12, CR0_EQ, 12 */
		/* 822665CCh case   13:*/		if ( regs.CR[0].eq ) { return 0x822665D8;  }
		/* 822665CCh case   13:*/		return 0x822665D0;
		  /* 822665D0h */ case   14:  		/* addi R11, R11, 4 */
		/* 822665D0h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 822665D0h case   14:*/		return 0x822665D4;
		  /* 822665D4h */ case   15:  		/* b 8 */
		/* 822665D4h case   15:*/		return 0x822665DC;
		/* 822665D4h case   15:*/		return 0x822665D8;
	}
	return 0x822665D8;
} // Block from 82266598h-822665D8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 822665D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822665D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822665D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822665D8);
		  /* 822665D8h */ case    0:  		/* addi R11, R11, 8 */
		/* 822665D8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x8);
		/* 822665D8h case    0:*/		return 0x822665DC;
	}
	return 0x822665DC;
} // Block from 822665D8h-822665DCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 822665DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822665DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822665DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822665DC);
		  /* 822665DCh */ case    0:  		/* lwz R10, <#[R30 + 4]> */
		/* 822665DCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000004) );
		/* 822665DCh case    0:*/		return 0x822665E0;
		  /* 822665E0h */ case    1:  		/* rlwinm R10, R10, 4, 0, 27 */
		/* 822665E0h case    1:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R10,regs.R10);
		/* 822665E0h case    1:*/		return 0x822665E4;
		  /* 822665E4h */ case    2:  		/* lwzx R11, <#[R10 + R11]> */
		/* 822665E4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 822665E4h case    2:*/		return 0x822665E8;
		  /* 822665E8h */ case    3:  		/* stw R11, <#[R30 + 4]> */
		/* 822665E8h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 822665E8h case    3:*/		return 0x822665EC;
	}
	return 0x822665EC;
} // Block from 822665DCh-822665ECh (4 instructions)

//////////////////////////////////////////////////////
// Block at 822665ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822665EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822665EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822665EC);
		  /* 822665ECh */ case    0:  		/* lwz R11, <#[R30 + 4]> */
		/* 822665ECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 822665ECh case    0:*/		return 0x822665F0;
		  /* 822665F0h */ case    1:  		/* cmpwi CR6, R11, -1 */
		/* 822665F0h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 822665F0h case    1:*/		return 0x822665F4;
		  /* 822665F4h */ case    2:  		/* bc 4, CR6_EQ, 40 */
		/* 822665F4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8226661C;  }
		/* 822665F4h case    2:*/		return 0x822665F8;
		  /* 822665F8h */ case    3:  		/* lis R11, -32251 */
		/* 822665F8h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 822665F8h case    3:*/		return 0x822665FC;
		  /* 822665FCh */ case    4:  		/* lis R10, -32251 */
		/* 822665FCh case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 822665FCh case    4:*/		return 0x82266600;
		  /* 82266600h */ case    5:  		/* lis R9, -32253 */
		/* 82266600h case    5:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 82266600h case    5:*/		return 0x82266604;
		  /* 82266604h */ case    6:  		/* addi R6, R11, -17768 */
		/* 82266604h case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFBA98);
		/* 82266604h case    6:*/		return 0x82266608;
		  /* 82266608h */ case    7:  		/* addi R5, R10, -17784 */
		/* 82266608h case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0xFFFFBA88);
		/* 82266608h case    7:*/		return 0x8226660C;
		  /* 8226660Ch */ case    8:  		/* addi R4, R9, 27460 */
		/* 8226660Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0x6B44);
		/* 8226660Ch case    8:*/		return 0x82266610;
		  /* 82266610h */ case    9:  		/* li R7, 80 */
		/* 82266610h case    9:*/		cpu::op::li<0>(regs,&regs.R7,0x50);
		/* 82266610h case    9:*/		return 0x82266614;
		  /* 82266614h */ case   10:  		/* li R3, 0 */
		/* 82266614h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82266614h case   10:*/		return 0x82266618;
		  /* 82266618h */ case   11:  		/* bl -1108496 */
		/* 82266618h case   11:*/		regs.LR = 0x8226661C; return 0x82157C08;
		/* 82266618h case   11:*/		return 0x8226661C;
	}
	return 0x8226661C;
} // Block from 822665ECh-8226661Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8226661Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226661C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226661C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226661C);
		  /* 8226661Ch */ case    0:  		/* addi R1, R1, 112 */
		/* 8226661Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8226661Ch case    0:*/		return 0x82266620;
		  /* 82266620h */ case    1:  		/* b -1921908 */
		/* 82266620h case    1:*/		return 0x820912AC;
		/* 82266620h case    1:*/		return 0x82266624;
		  /* 82266624h */ case    2:  		/* nop */
		/* 82266624h case    2:*/		cpu::op::nop();
		/* 82266624h case    2:*/		return 0x82266628;
	}
	return 0x82266628;
} // Block from 8226661Ch-82266628h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82266628h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266628( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266628) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266628);
		  /* 82266628h */ case    0:  		/* mfspr R12, LR */
		/* 82266628h case    0:*/		regs.R12 = regs.LR;
		/* 82266628h case    0:*/		return 0x8226662C;
		  /* 8226662Ch */ case    1:  		/* bl -1922020 */
		/* 8226662Ch case    1:*/		regs.LR = 0x82266630; return 0x82091248;
		/* 8226662Ch case    1:*/		return 0x82266630;
		  /* 82266630h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 82266630h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82266630h case    2:*/		return 0x82266634;
		  /* 82266634h */ case    3:  		/* lwz R11, <#[R3]> */
		/* 82266634h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82266634h case    3:*/		return 0x82266638;
	}
	return 0x82266638;
} // Block from 82266628h-82266638h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82266638h
// Function '?FindRepeatedFragments@TNode@XGRAPHICS@@QAAXPAVAssembler@2@HPAPAXPAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266638( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266638) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266638);
		  /* 82266638h */ case    0:  		/* mr R31, R3 */
		/* 82266638h case    0:*/		regs.R31 = regs.R3;
		/* 82266638h case    0:*/		return 0x8226663C;
		  /* 8226663Ch */ case    1:  		/* mr R24, R4 */
		/* 8226663Ch case    1:*/		regs.R24 = regs.R4;
		/* 8226663Ch case    1:*/		return 0x82266640;
		  /* 82266640h */ case    2:  		/* li R30, 0 */
		/* 82266640h case    2:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82266640h case    2:*/		return 0x82266644;
		  /* 82266644h */ case    3:  		/* li R25, 0 */
		/* 82266644h case    3:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 82266644h case    3:*/		return 0x82266648;
		  /* 82266648h */ case    4:  		/* li R26, 0 */
		/* 82266648h case    4:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 82266648h case    4:*/		return 0x8226664C;
		  /* 8226664Ch */ case    5:  		/* lwz R11, <#[R11 + 4]> */
		/* 8226664Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 8226664Ch case    5:*/		return 0x82266650;
		  /* 82266650h */ case    6:  		/* mtspr CTR, R11 */
		/* 82266650h case    6:*/		regs.CTR = regs.R11;
		/* 82266650h case    6:*/		return 0x82266654;
		  /* 82266654h */ case    7:  		/* bcctrl 20, CR0_LT */
		/* 82266654h case    7:*/		if ( 1 ) { regs.LR = 0x82266658; return (uint32)regs.CTR; }
		/* 82266654h case    7:*/		return 0x82266658;
		  /* 82266658h */ case    8:  		/* lis R11, -32251 */
		/* 82266658h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82266658h case    8:*/		return 0x8226665C;
		  /* 8226665Ch */ case    9:  		/* lis R10, -32251 */
		/* 8226665Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 8226665Ch case    9:*/		return 0x82266660;
		  /* 82266660h */ case   10:  		/* cmpwi CR0, R3, 0 */
		/* 82266660h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82266660h case   10:*/		return 0x82266664;
		  /* 82266664h */ case   11:  		/* addi R27, R11, -18024 */
		/* 82266664h case   11:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R11,0xFFFFB998);
		/* 82266664h case   11:*/		return 0x82266668;
		  /* 82266668h */ case   12:  		/* addi R29, R10, -19064 */
		/* 82266668h case   12:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R10,0xFFFFB588);
		/* 82266668h case   12:*/		return 0x8226666C;
		  /* 8226666Ch */ case   13:  		/* bc 4, CR0_GT, 68 */
		/* 8226666Ch case   13:*/		if ( !regs.CR[0].gt ) { return 0x822666B0;  }
		/* 8226666Ch case   13:*/		return 0x82266670;
		  /* 82266670h */ case   14:  		/* lwz R11, <#[R31 + 236]> */
		/* 82266670h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000EC) );
		/* 82266670h case   14:*/		return 0x82266674;
		  /* 82266674h */ case   15:  		/* addi R10, R29, 6 */
		/* 82266674h case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R29,0x6);
		/* 82266674h case   15:*/		return 0x82266678;
		  /* 82266678h */ case   16:  		/* lwz R11, <#[R11 + 80]> */
		/* 82266678h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 82266678h case   16:*/		return 0x8226667C;
		  /* 8226667Ch */ case   17:  		/* mulli R11, R11, 12 */
		/* 8226667Ch case   17:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 8226667Ch case   17:*/		return 0x82266680;
		  /* 82266680h */ case   18:  		/* lbzx R11, <#[R11 + R10]> */
		/* 82266680h case   18:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82266680h case   18:*/		return 0x82266684;
		  /* 82266684h */ case   19:  		/* cmplwi CR0, R11, 0 */
		/* 82266684h case   19:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82266684h case   19:*/		return 0x82266688;
		  /* 82266688h */ case   20:  		/* bc 12, CR0_EQ, 24 */
		/* 82266688h case   20:*/		if ( regs.CR[0].eq ) { return 0x822666A0;  }
		/* 82266688h case   20:*/		return 0x8226668C;
		  /* 8226668Ch */ case   21:  		/* lbz R10, <#[R31 + 159]> */
		/* 8226668Ch case   21:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000009F) );
		/* 8226668Ch case   21:*/		return 0x82266690;
		  /* 82266690h */ case   22:  		/* li R26, 1 */
		/* 82266690h case   22:*/		cpu::op::li<0>(regs,&regs.R26,0x1);
		/* 82266690h case   22:*/		return 0x82266694;
		  /* 82266694h */ case   23:  		/* cmplwi CR0, R10, 0 */
		/* 82266694h case   23:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 82266694h case   23:*/		return 0x82266698;
		  /* 82266698h */ case   24:  		/* bc 12, CR0_EQ, 8 */
		/* 82266698h case   24:*/		if ( regs.CR[0].eq ) { return 0x822666A0;  }
		/* 82266698h case   24:*/		return 0x8226669C;
		  /* 8226669Ch */ case   25:  		/* li R25, 1 */
		/* 8226669Ch case   25:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 8226669Ch case   25:*/		return 0x822666A0;
	}
	return 0x822666A0;
} // Block from 82266638h-822666A0h (26 instructions)

//////////////////////////////////////////////////////
// Block at 822666A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822666A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822666A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822666A0);
		  /* 822666A0h */ case    0:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 822666A0h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 822666A0h case    0:*/		return 0x822666A4;
		  /* 822666A4h */ case    1:  		/* lwzx R30, <#[R11 + R27]> */
		/* 822666A4h case    1:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 822666A4h case    1:*/		return 0x822666A8;
		  /* 822666A8h */ case    2:  		/* cmpwi CR6, R30, -1 */
		/* 822666A8h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R30,0xFFFFFFFF);
		/* 822666A8h case    2:*/		return 0x822666AC;
		  /* 822666ACh */ case    3:  		/* bc 12, CR6_EQ, 320 */
		/* 822666ACh case    3:*/		if ( regs.CR[6].eq ) { return 0x822667EC;  }
		/* 822666ACh case    3:*/		return 0x822666B0;
	}
	return 0x822666B0;
} // Block from 822666A0h-822666B0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822666B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822666B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822666B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822666B0);
		  /* 822666B0h */ case    0:  		/* lis R11, -32216 */
		/* 822666B0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 822666B0h case    0:*/		return 0x822666B4;
		  /* 822666B4h */ case    1:  		/* lwz R10, <#[R31 + 24]> */
		/* 822666B4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000018) );
		/* 822666B4h case    1:*/		return 0x822666B8;
		  /* 822666B8h */ case    2:  		/* addi R28, R11, 17992 */
		/* 822666B8h case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R11,0x4648);
		/* 822666B8h case    2:*/		return 0x822666BC;
		  /* 822666BCh */ case    3:  		/* mulli R11, R10, 52 */
		/* 822666BCh case    3:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R10,0x34);
		/* 822666BCh case    3:*/		return 0x822666C0;
		  /* 822666C0h */ case    4:  		/* lwzx R11, <#[R11 + R28]> */
		/* 822666C0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 822666C0h case    4:*/		return 0x822666C4;
		  /* 822666C4h */ case    5:  		/* rlwinm. R11, R11, 31, 31, 31 */
		/* 822666C4h case    5:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R11,regs.R11);
		/* 822666C4h case    5:*/		return 0x822666C8;
		  /* 822666C8h */ case    6:  		/* bc 12, CR0_EQ, 172 */
		/* 822666C8h case    6:*/		if ( regs.CR[0].eq ) { return 0x82266774;  }
		/* 822666C8h case    6:*/		return 0x822666CC;
		  /* 822666CCh */ case    7:  		/* lwz R11, <#[R31]> */
		/* 822666CCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822666CCh case    7:*/		return 0x822666D0;
		  /* 822666D0h */ case    8:  		/* mr R3, R31 */
		/* 822666D0h case    8:*/		regs.R3 = regs.R31;
		/* 822666D0h case    8:*/		return 0x822666D4;
		  /* 822666D4h */ case    9:  		/* lwz R11, <#[R11 + 4]> */
		/* 822666D4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 822666D4h case    9:*/		return 0x822666D8;
		  /* 822666D8h */ case   10:  		/* mtspr CTR, R11 */
		/* 822666D8h case   10:*/		regs.CTR = regs.R11;
		/* 822666D8h case   10:*/		return 0x822666DC;
		  /* 822666DCh */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 822666DCh case   11:*/		if ( 1 ) { regs.LR = 0x822666E0; return (uint32)regs.CTR; }
		/* 822666DCh case   11:*/		return 0x822666E0;
		  /* 822666E0h */ case   12:  		/* cmpwi CR6, R3, 1 */
		/* 822666E0h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 822666E0h case   12:*/		return 0x822666E4;
		  /* 822666E4h */ case   13:  		/* bc 12, CR6_GT, 32 */
		/* 822666E4h case   13:*/		if ( regs.CR[6].gt ) { return 0x82266704;  }
		/* 822666E4h case   13:*/		return 0x822666E8;
		  /* 822666E8h */ case   14:  		/* lwz R11, <#[R31]> */
		/* 822666E8h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822666E8h case   14:*/		return 0x822666EC;
		  /* 822666ECh */ case   15:  		/* mr R3, R31 */
		/* 822666ECh case   15:*/		regs.R3 = regs.R31;
		/* 822666ECh case   15:*/		return 0x822666F0;
		  /* 822666F0h */ case   16:  		/* lwz R11, <#[R11 + 76]> */
		/* 822666F0h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000004C) );
		/* 822666F0h case   16:*/		return 0x822666F4;
		  /* 822666F4h */ case   17:  		/* mtspr CTR, R11 */
		/* 822666F4h case   17:*/		regs.CTR = regs.R11;
		/* 822666F4h case   17:*/		return 0x822666F8;
		  /* 822666F8h */ case   18:  		/* bcctrl 20, CR0_LT */
		/* 822666F8h case   18:*/		if ( 1 ) { regs.LR = 0x822666FC; return (uint32)regs.CTR; }
		/* 822666F8h case   18:*/		return 0x822666FC;
		  /* 822666FCh */ case   19:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822666FCh case   19:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822666FCh case   19:*/		return 0x82266700;
		  /* 82266700h */ case   20:  		/* bc 12, CR0_EQ, 116 */
		/* 82266700h case   20:*/		if ( regs.CR[0].eq ) { return 0x82266774;  }
		/* 82266700h case   20:*/		return 0x82266704;
	}
	return 0x82266704;
} // Block from 822666B0h-82266704h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82266704h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266704( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266704) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266704);
		  /* 82266704h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 82266704h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82266704h case    0:*/		return 0x82266708;
		  /* 82266708h */ case    1:  		/* mr R3, R31 */
		/* 82266708h case    1:*/		regs.R3 = regs.R31;
		/* 82266708h case    1:*/		return 0x8226670C;
		  /* 8226670Ch */ case    2:  		/* lwz R11, <#[R11 + 76]> */
		/* 8226670Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000004C) );
		/* 8226670Ch case    2:*/		return 0x82266710;
		  /* 82266710h */ case    3:  		/* mtspr CTR, R11 */
		/* 82266710h case    3:*/		regs.CTR = regs.R11;
		/* 82266710h case    3:*/		return 0x82266714;
		  /* 82266714h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 82266714h case    4:*/		if ( 1 ) { regs.LR = 0x82266718; return (uint32)regs.CTR; }
		/* 82266714h case    4:*/		return 0x82266718;
		  /* 82266718h */ case    5:  		/* rlwinm R11, R3, 0, 24, 31 */
		/* 82266718h case    5:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82266718h case    5:*/		return 0x8226671C;
		  /* 8226671Ch */ case    6:  		/* addi R10, R29, 6 */
		/* 8226671Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R29,0x6);
		/* 8226671Ch case    6:*/		return 0x82266720;
		  /* 82266720h */ case    7:  		/* cntlzw R11, R11 */
		/* 82266720h case    7:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 82266720h case    7:*/		return 0x82266724;
		  /* 82266724h */ case    8:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 82266724h case    8:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 82266724h case    8:*/		return 0x82266728;
		  /* 82266728h */ case    9:  		/* addi R11, R11, 1 */
		/* 82266728h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82266728h case    9:*/		return 0x8226672C;
		  /* 8226672Ch */ case   10:  		/* addi R9, R11, 58 */
		/* 8226672Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x3A);
		/* 8226672Ch case   10:*/		return 0x82266730;
		  /* 82266730h */ case   11:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82266730h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82266730h case   11:*/		return 0x82266734;
		  /* 82266734h */ case   12:  		/* lwzx R9, <#[R9 + R31]> */
		/* 82266734h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R31 + 0x00000000) );
		/* 82266734h case   12:*/		return 0x82266738;
		  /* 82266738h */ case   13:  		/* lwz R9, <#[R9 + 80]> */
		/* 82266738h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000050) );
		/* 82266738h case   13:*/		return 0x8226673C;
		  /* 8226673Ch */ case   14:  		/* mulli R9, R9, 12 */
		/* 8226673Ch case   14:*/		cpu::op::mulli<0>(regs,&regs.R9,regs.R9,0xC);
		/* 8226673Ch case   14:*/		return 0x82266740;
		  /* 82266740h */ case   15:  		/* lbzx R10, <#[R9 + R10]> */
		/* 82266740h case   15:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 82266740h case   15:*/		return 0x82266744;
		  /* 82266744h */ case   16:  		/* cmplwi CR0, R10, 0 */
		/* 82266744h case   16:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 82266744h case   16:*/		return 0x82266748;
		  /* 82266748h */ case   17:  		/* bc 12, CR0_EQ, 28 */
		/* 82266748h case   17:*/		if ( regs.CR[0].eq ) { return 0x82266764;  }
		/* 82266748h case   17:*/		return 0x8226674C;
		  /* 8226674Ch */ case   18:  		/* add R11, R11, R31 */
		/* 8226674Ch case   18:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 8226674Ch case   18:*/		return 0x82266750;
		  /* 82266750h */ case   19:  		/* addi R26, R26, 1 */
		/* 82266750h case   19:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 82266750h case   19:*/		return 0x82266754;
		  /* 82266754h */ case   20:  		/* lbz R11, <#[R11 + 158]> */
		/* 82266754h case   20:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000009E) );
		/* 82266754h case   20:*/		return 0x82266758;
		  /* 82266758h */ case   21:  		/* cmplwi CR0, R11, 0 */
		/* 82266758h case   21:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82266758h case   21:*/		return 0x8226675C;
		  /* 8226675Ch */ case   22:  		/* bc 12, CR0_EQ, 8 */
		/* 8226675Ch case   22:*/		if ( regs.CR[0].eq ) { return 0x82266764;  }
		/* 8226675Ch case   22:*/		return 0x82266760;
		  /* 82266760h */ case   23:  		/* addi R25, R25, 1 */
		/* 82266760h case   23:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x1);
		/* 82266760h case   23:*/		return 0x82266764;
	}
	return 0x82266764;
} // Block from 82266704h-82266764h (24 instructions)

//////////////////////////////////////////////////////
// Block at 82266764h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266764( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266764) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266764);
		  /* 82266764h */ case    0:  		/* mulli R11, R30, 5 */
		/* 82266764h case    0:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R30,0x5);
		/* 82266764h case    0:*/		return 0x82266768;
		  /* 82266768h */ case    1:  		/* add R11, R11, R10 */
		/* 82266768h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82266768h case    1:*/		return 0x8226676C;
		  /* 8226676Ch */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8226676Ch case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8226676Ch case    2:*/		return 0x82266770;
		  /* 82266770h */ case    3:  		/* lwzx R30, <#[R11 + R27]> */
		/* 82266770h case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 82266770h case    3:*/		return 0x82266774;
	}
	return 0x82266774;
} // Block from 82266764h-82266774h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82266774h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266774( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266774) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266774);
		  /* 82266774h */ case    0:  		/* cmpwi CR6, R30, -1 */
		/* 82266774h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R30,0xFFFFFFFF);
		/* 82266774h case    0:*/		return 0x82266778;
		  /* 82266778h */ case    1:  		/* bc 12, CR6_EQ, 116 */
		/* 82266778h case    1:*/		if ( regs.CR[6].eq ) { return 0x822667EC;  }
		/* 82266778h case    1:*/		return 0x8226677C;
		  /* 8226677Ch */ case    2:  		/* lwz R11, <#[R31 + 24]> */
		/* 8226677Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000018) );
		/* 8226677Ch case    2:*/		return 0x82266780;
		  /* 82266780h */ case    3:  		/* mulli R11, R11, 52 */
		/* 82266780h case    3:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x34);
		/* 82266780h case    3:*/		return 0x82266784;
		  /* 82266784h */ case    4:  		/* lwzx R11, <#[R11 + R28]> */
		/* 82266784h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 82266784h case    4:*/		return 0x82266788;
		  /* 82266788h */ case    5:  		/* rlwinm. R11, R11, 31, 31, 31 */
		/* 82266788h case    5:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R11,regs.R11);
		/* 82266788h case    5:*/		return 0x8226678C;
		  /* 8226678Ch */ case    6:  		/* bc 12, CR0_EQ, 96 */
		/* 8226678Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x822667EC;  }
		/* 8226678Ch case    6:*/		return 0x82266790;
		  /* 82266790h */ case    7:  		/* lwz R11, <#[R31]> */
		/* 82266790h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82266790h case    7:*/		return 0x82266794;
		  /* 82266794h */ case    8:  		/* mr R3, R31 */
		/* 82266794h case    8:*/		regs.R3 = regs.R31;
		/* 82266794h case    8:*/		return 0x82266798;
		  /* 82266798h */ case    9:  		/* lwz R11, <#[R11 + 4]> */
		/* 82266798h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 82266798h case    9:*/		return 0x8226679C;
		  /* 8226679Ch */ case   10:  		/* mtspr CTR, R11 */
		/* 8226679Ch case   10:*/		regs.CTR = regs.R11;
		/* 8226679Ch case   10:*/		return 0x822667A0;
		  /* 822667A0h */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 822667A0h case   11:*/		if ( 1 ) { regs.LR = 0x822667A4; return (uint32)regs.CTR; }
		/* 822667A0h case   11:*/		return 0x822667A4;
		  /* 822667A4h */ case   12:  		/* cmpwi CR6, R3, 2 */
		/* 822667A4h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000002);
		/* 822667A4h case   12:*/		return 0x822667A8;
		  /* 822667A8h */ case   13:  		/* bc 4, CR6_GT, 68 */
		/* 822667A8h case   13:*/		if ( !regs.CR[6].gt ) { return 0x822667EC;  }
		/* 822667A8h case   13:*/		return 0x822667AC;
		  /* 822667ACh */ case   14:  		/* lwz R11, <#[R31 + 244]> */
		/* 822667ACh case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000F4) );
		/* 822667ACh case   14:*/		return 0x822667B0;
		  /* 822667B0h */ case   15:  		/* addi R10, R29, 6 */
		/* 822667B0h case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R29,0x6);
		/* 822667B0h case   15:*/		return 0x822667B4;
		  /* 822667B4h */ case   16:  		/* lwz R11, <#[R11 + 80]> */
		/* 822667B4h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000050) );
		/* 822667B4h case   16:*/		return 0x822667B8;
		  /* 822667B8h */ case   17:  		/* mulli R11, R11, 12 */
		/* 822667B8h case   17:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0xC);
		/* 822667B8h case   17:*/		return 0x822667BC;
		  /* 822667BCh */ case   18:  		/* lbzx R10, <#[R11 + R10]> */
		/* 822667BCh case   18:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 822667BCh case   18:*/		return 0x822667C0;
		  /* 822667C0h */ case   19:  		/* cmplwi CR0, R10, 0 */
		/* 822667C0h case   19:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 822667C0h case   19:*/		return 0x822667C4;
		  /* 822667C4h */ case   20:  		/* bc 12, CR0_EQ, 24 */
		/* 822667C4h case   20:*/		if ( regs.CR[0].eq ) { return 0x822667DC;  }
		/* 822667C4h case   20:*/		return 0x822667C8;
		  /* 822667C8h */ case   21:  		/* lbz R11, <#[R31 + 161]> */
		/* 822667C8h case   21:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000A1) );
		/* 822667C8h case   21:*/		return 0x822667CC;
		  /* 822667CCh */ case   22:  		/* addi R26, R26, 1 */
		/* 822667CCh case   22:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 822667CCh case   22:*/		return 0x822667D0;
		  /* 822667D0h */ case   23:  		/* cmplwi CR0, R11, 0 */
		/* 822667D0h case   23:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 822667D0h case   23:*/		return 0x822667D4;
		  /* 822667D4h */ case   24:  		/* bc 12, CR0_EQ, 8 */
		/* 822667D4h case   24:*/		if ( regs.CR[0].eq ) { return 0x822667DC;  }
		/* 822667D4h case   24:*/		return 0x822667D8;
		  /* 822667D8h */ case   25:  		/* addi R25, R25, 1 */
		/* 822667D8h case   25:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x1);
		/* 822667D8h case   25:*/		return 0x822667DC;
	}
	return 0x822667DC;
} // Block from 82266774h-822667DCh (26 instructions)

//////////////////////////////////////////////////////
// Block at 822667DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822667DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822667DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822667DC);
		  /* 822667DCh */ case    0:  		/* mulli R11, R30, 5 */
		/* 822667DCh case    0:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R30,0x5);
		/* 822667DCh case    0:*/		return 0x822667E0;
		  /* 822667E0h */ case    1:  		/* add R11, R11, R10 */
		/* 822667E0h case    1:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 822667E0h case    1:*/		return 0x822667E4;
		  /* 822667E4h */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 822667E4h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 822667E4h case    2:*/		return 0x822667E8;
		  /* 822667E8h */ case    3:  		/* lwzx R30, <#[R11 + R27]> */
		/* 822667E8h case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 822667E8h case    3:*/		return 0x822667EC;
	}
	return 0x822667EC;
} // Block from 822667DCh-822667ECh (4 instructions)

//////////////////////////////////////////////////////
// Block at 822667ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822667EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822667EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822667EC);
		  /* 822667ECh */ case    0:  		/* neg R11, R25 */
		/* 822667ECh case    0:*/		cpu::op::neg<0>(regs,&regs.R11,regs.R25);
		/* 822667ECh case    0:*/		return 0x822667F0;
		  /* 822667F0h */ case    1:  		/* mr R3, R31 */
		/* 822667F0h case    1:*/		regs.R3 = regs.R31;
		/* 822667F0h case    1:*/		return 0x822667F4;
		  /* 822667F4h */ case    2:  		/* andc R11, R11, R25 */
		/* 822667F4h case    2:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R11,regs.R25);
		/* 822667F4h case    2:*/		return 0x822667F8;
		  /* 822667F8h */ case    3:  		/* rlwinm R11, R11, 1, 31, 31 */
		/* 822667F8h case    3:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R11,regs.R11);
		/* 822667F8h case    3:*/		return 0x822667FC;
		  /* 822667FCh */ case    4:  		/* stb R11, <#[R24]> */
		/* 822667FCh case    4:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 822667FCh case    4:*/		return 0x82266800;
		  /* 82266800h */ case    5:  		/* lwz R11, <#[R31]> */
		/* 82266800h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82266800h case    5:*/		return 0x82266804;
		  /* 82266804h */ case    6:  		/* lwz R11, <#[R11 + 24]> */
		/* 82266804h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 82266804h case    6:*/		return 0x82266808;
		  /* 82266808h */ case    7:  		/* mtspr CTR, R11 */
		/* 82266808h case    7:*/		regs.CTR = regs.R11;
		/* 82266808h case    7:*/		return 0x8226680C;
		  /* 8226680Ch */ case    8:  		/* bcctrl 20, CR0_LT */
		/* 8226680Ch case    8:*/		if ( 1 ) { regs.LR = 0x82266810; return (uint32)regs.CTR; }
		/* 8226680Ch case    8:*/		return 0x82266810;
		  /* 82266810h */ case    9:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82266810h case    9:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82266810h case    9:*/		return 0x82266814;
		  /* 82266814h */ case   10:  		/* bc 12, CR0_EQ, 12 */
		/* 82266814h case   10:*/		if ( regs.CR[0].eq ) { return 0x82266820;  }
		/* 82266814h case   10:*/		return 0x82266818;
		  /* 82266818h */ case   11:  		/* cmpwi CR6, R26, 0 */
		/* 82266818h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R26,0x00000000);
		/* 82266818h case   11:*/		return 0x8226681C;
		  /* 8226681Ch */ case   12:  		/* bc 12, CR6_GT, 24 */
		/* 8226681Ch case   12:*/		if ( regs.CR[6].gt ) { return 0x82266834;  }
		/* 8226681Ch case   12:*/		return 0x82266820;
	}
	return 0x82266820;
} // Block from 822667ECh-82266820h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82266820h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266820( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266820) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266820);
		  /* 82266820h */ case    0:  		/* lbz R11, <#[R24]> */
		/* 82266820h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 82266820h case    0:*/		return 0x82266824;
		  /* 82266824h */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 82266824h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82266824h case    1:*/		return 0x82266828;
		  /* 82266828h */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 82266828h case    2:*/		if ( regs.CR[0].eq ) { return 0x82266838;  }
		/* 82266828h case    2:*/		return 0x8226682C;
		  /* 8226682Ch */ case    3:  		/* cmpw CR6, R25, R26 */
		/* 8226682Ch case    3:*/		cpu::op::cmpw<6>(regs,regs.R25,regs.R26);
		/* 8226682Ch case    3:*/		return 0x82266830;
		  /* 82266830h */ case    4:  		/* bc 4, CR6_LT, 8 */
		/* 82266830h case    4:*/		if ( !regs.CR[6].lt ) { return 0x82266838;  }
		/* 82266830h case    4:*/		return 0x82266834;
	}
	return 0x82266834;
} // Block from 82266820h-82266834h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82266834h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266834( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266834) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266834);
		  /* 82266834h */ case    0:  		/* li R30, -1 */
		/* 82266834h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0xFFFFFFFF);
		/* 82266834h case    0:*/		return 0x82266838;
	}
	return 0x82266838;
} // Block from 82266834h-82266838h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82266838h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266838( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266838) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266838);
		  /* 82266838h */ case    0:  		/* mr R3, R30 */
		/* 82266838h case    0:*/		regs.R3 = regs.R30;
		/* 82266838h case    0:*/		return 0x8226683C;
		  /* 8226683Ch */ case    1:  		/* addi R1, R1, 160 */
		/* 8226683Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 8226683Ch case    1:*/		return 0x82266840;
		  /* 82266840h */ case    2:  		/* b -1922472 */
		/* 82266840h case    2:*/		return 0x82091298;
		/* 82266840h case    2:*/		return 0x82266844;
		  /* 82266844h */ case    3:  		/* nop */
		/* 82266844h case    3:*/		cpu::op::nop();
		/* 82266844h case    3:*/		return 0x82266848;
	}
	return 0x82266848;
} // Block from 82266838h-82266848h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82266848h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266848( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266848) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266848);
		  /* 82266848h */ case    0:  		/* mfspr R12, LR */
		/* 82266848h case    0:*/		regs.R12 = regs.LR;
		/* 82266848h case    0:*/		return 0x8226684C;
		  /* 8226684Ch */ case    1:  		/* bl -1922552 */
		/* 8226684Ch case    1:*/		regs.LR = 0x82266850; return 0x82091254;
		/* 8226684Ch case    1:*/		return 0x82266850;
		  /* 82266850h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82266850h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82266850h case    2:*/		return 0x82266854;
		  /* 82266854h */ case    3:  		/* lwz R11, <#[R4]> */
		/* 82266854h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 82266854h case    3:*/		return 0x82266858;
		  /* 82266858h */ case    4:  		/* mr R27, R3 */
		/* 82266858h case    4:*/		regs.R27 = regs.R3;
		/* 82266858h case    4:*/		return 0x8226685C;
		  /* 8226685Ch */ case    5:  		/* mr R3, R4 */
		/* 8226685Ch case    5:*/		regs.R3 = regs.R4;
		/* 8226685Ch case    5:*/		return 0x82266860;
		  /* 82266860h */ case    6:  		/* mr R30, R4 */
		/* 82266860h case    6:*/		regs.R30 = regs.R4;
		/* 82266860h case    6:*/		return 0x82266864;
		  /* 82266864h */ case    7:  		/* lwz R11, <#[R11 + 52]> */
		/* 82266864h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000034) );
		/* 82266864h case    7:*/		return 0x82266868;
		  /* 82266868h */ case    8:  		/* mtspr CTR, R11 */
		/* 82266868h case    8:*/		regs.CTR = regs.R11;
		/* 82266868h case    8:*/		return 0x8226686C;
		  /* 8226686Ch */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 8226686Ch case    9:*/		if ( 1 ) { regs.LR = 0x82266870; return (uint32)regs.CTR; }
		/* 8226686Ch case    9:*/		return 0x82266870;
		  /* 82266870h */ case   10:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82266870h case   10:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82266870h case   10:*/		return 0x82266874;
		  /* 82266874h */ case   11:  		/* bc 12, CR0_EQ, 12 */
		/* 82266874h case   11:*/		if ( regs.CR[0].eq ) { return 0x82266880;  }
		/* 82266874h case   11:*/		return 0x82266878;
		  /* 82266878h */ case   12:  		/* li R3, 1 */
		/* 82266878h case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82266878h case   12:*/		return 0x8226687C;
		  /* 8226687Ch */ case   13:  		/* b 272 */
		/* 8226687Ch case   13:*/		return 0x8226698C;
		/* 8226687Ch case   13:*/		return 0x82266880;
	}
	return 0x82266880;
} // Block from 82266848h-82266880h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82266880h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266880( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266880) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266880);
		  /* 82266880h */ case    0:  		/* addi R4, R1, 80 */
		/* 82266880h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 82266880h case    0:*/		return 0x82266884;
		  /* 82266884h */ case    1:  		/* mr R3, R30 */
		/* 82266884h case    1:*/		regs.R3 = regs.R30;
		/* 82266884h case    1:*/		return 0x82266888;
		  /* 82266888h */ case    2:  		/* bl -608 */
		/* 82266888h case    2:*/		regs.LR = 0x8226688C; return 0x82266628;
		/* 82266888h case    2:*/		return 0x8226688C;
		  /* 8226688Ch */ case    3:  		/* lis R11, -32253 */
		/* 8226688Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 8226688Ch case    3:*/		return 0x82266890;
		  /* 82266890h */ case    4:  		/* lis R10, -32251 */
		/* 82266890h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 82266890h case    4:*/		return 0x82266894;
		  /* 82266894h */ case    5:  		/* mr R31, R3 */
		/* 82266894h case    5:*/		regs.R31 = regs.R3;
		/* 82266894h case    5:*/		return 0x82266898;
		  /* 82266898h */ case    6:  		/* cmpwi CR6, R3, -1 */
		/* 82266898h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 82266898h case    6:*/		return 0x8226689C;
		  /* 8226689Ch */ case    7:  		/* addi R29, R11, 27460 */
		/* 8226689Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x6B44);
		/* 8226689Ch case    7:*/		return 0x822668A0;
		  /* 822668A0h */ case    8:  		/* addi R28, R10, -17768 */
		/* 822668A0h case    8:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R10,0xFFFFBA98);
		/* 822668A0h case    8:*/		return 0x822668A4;
		  /* 822668A4h */ case    9:  		/* bc 4, CR6_EQ, 32 */
		/* 822668A4h case    9:*/		if ( !regs.CR[6].eq ) { return 0x822668C4;  }
		/* 822668A4h case    9:*/		return 0x822668A8;
		  /* 822668A8h */ case   10:  		/* lis R11, -32251 */
		/* 822668A8h case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 822668A8h case   10:*/		return 0x822668AC;
		  /* 822668ACh */ case   11:  		/* mr R6, R28 */
		/* 822668ACh case   11:*/		regs.R6 = regs.R28;
		/* 822668ACh case   11:*/		return 0x822668B0;
		  /* 822668B0h */ case   12:  		/* addi R5, R11, -17628 */
		/* 822668B0h case   12:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFBB24);
		/* 822668B0h case   12:*/		return 0x822668B4;
		  /* 822668B4h */ case   13:  		/* mr R4, R29 */
		/* 822668B4h case   13:*/		regs.R4 = regs.R29;
		/* 822668B4h case   13:*/		return 0x822668B8;
		  /* 822668B8h */ case   14:  		/* li R7, 169 */
		/* 822668B8h case   14:*/		cpu::op::li<0>(regs,&regs.R7,0xA9);
		/* 822668B8h case   14:*/		return 0x822668BC;
		  /* 822668BCh */ case   15:  		/* li R3, 0 */
		/* 822668BCh case   15:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822668BCh case   15:*/		return 0x822668C0;
		  /* 822668C0h */ case   16:  		/* bl -1109176 */
		/* 822668C0h case   16:*/		regs.LR = 0x822668C4; return 0x82157C08;
		/* 822668C0h case   16:*/		return 0x822668C4;
	}
	return 0x822668C4;
} // Block from 82266880h-822668C4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 822668C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822668C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822668C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822668C4);
		  /* 822668C4h */ case    0:  		/* lwz R11, <#[R27 + 4]> */
		/* 822668C4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 822668C4h case    0:*/		return 0x822668C8;
	}
	return 0x822668C8;
} // Block from 822668C4h-822668C8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822668C8h
// Function '?CompressCode@XGRAPHICS@@YAXPAVAssembler@1@HPADPAVCompiler@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822668C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822668C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822668C8);
		  /* 822668C8h */ case    0:  		/* cmpwi CR6, R11, 0 */
		/* 822668C8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 822668C8h case    0:*/		return 0x822668CC;
		  /* 822668CCh */ case    1:  		/* bc 12, CR6_EQ, 36 */
		/* 822668CCh case    1:*/		if ( regs.CR[6].eq ) { return 0x822668F0;  }
		/* 822668CCh case    1:*/		return 0x822668D0;
		  /* 822668D0h */ case    2:  		/* cmpwi CR6, R31, 0 */
		/* 822668D0h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 822668D0h case    2:*/		return 0x822668D4;
		  /* 822668D4h */ case    3:  		/* bc 12, CR6_EQ, 28 */
		/* 822668D4h case    3:*/		if ( regs.CR[6].eq ) { return 0x822668F0;  }
		/* 822668D4h case    3:*/		return 0x822668D8;
		  /* 822668D8h */ case    4:  		/* lbz R10, <#[R1 + 80]> */
		/* 822668D8h case    4:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 822668D8h case    4:*/		return 0x822668DC;
		  /* 822668DCh */ case    5:  		/* lbz R9, <#[R27 + 8]> */
		/* 822668DCh case    5:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000008) );
		/* 822668DCh case    5:*/		return 0x822668E0;
		  /* 822668E0h */ case    6:  		/* cmplw CR6, R9, R10 */
		/* 822668E0h case    6:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 822668E0h case    6:*/		return 0x822668E4;
		  /* 822668E4h */ case    7:  		/* bc 12, CR6_EQ, 12 */
		/* 822668E4h case    7:*/		if ( regs.CR[6].eq ) { return 0x822668F0;  }
		/* 822668E4h case    7:*/		return 0x822668E8;
		  /* 822668E8h */ case    8:  		/* li R3, 0 */
		/* 822668E8h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822668E8h case    8:*/		return 0x822668EC;
		  /* 822668ECh */ case    9:  		/* b 160 */
		/* 822668ECh case    9:*/		return 0x8226698C;
		/* 822668ECh case    9:*/		return 0x822668F0;
	}
	return 0x822668F0;
} // Block from 822668C8h-822668F0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 822668F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822668F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822668F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822668F0);
		  /* 822668F0h */ case    0:  		/* lwz R10, <#[R30 + 24]> */
		/* 822668F0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000018) );
		/* 822668F0h case    0:*/		return 0x822668F4;
		  /* 822668F4h */ case    1:  		/* lis R9, -32216 */
		/* 822668F4h case    1:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8228);
		/* 822668F4h case    1:*/		return 0x822668F8;
		  /* 822668F8h */ case    2:  		/* mulli R10, R10, 52 */
		/* 822668F8h case    2:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x34);
		/* 822668F8h case    2:*/		return 0x822668FC;
		  /* 822668FCh */ case    3:  		/* addi R9, R9, 17992 */
		/* 822668FCh case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4648);
		/* 822668FCh case    3:*/		return 0x82266900;
		  /* 82266900h */ case    4:  		/* lwzx R10, <#[R10 + R9]> */
		/* 82266900h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82266900h case    4:*/		return 0x82266904;
		  /* 82266904h */ case    5:  		/* rlwinm. R10, R10, 30, 31, 31 */
		/* 82266904h case    5:*/		cpu::op::rlwinm<1,30,31,31>(regs,&regs.R10,regs.R10);
		/* 82266904h case    5:*/		return 0x82266908;
		  /* 82266908h */ case    6:  		/* bc 12, CR0_EQ, 56 */
		/* 82266908h case    6:*/		if ( regs.CR[0].eq ) { return 0x82266940;  }
		/* 82266908h case    6:*/		return 0x8226690C;
		  /* 8226690Ch */ case    7:  		/* cmpwi CR6, R31, 4 */
		/* 8226690Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000004);
		/* 8226690Ch case    7:*/		return 0x82266910;
		  /* 82266910h */ case    8:  		/* bc 4, CR6_GT, 32 */
		/* 82266910h case    8:*/		if ( !regs.CR[6].gt ) { return 0x82266930;  }
		/* 82266910h case    8:*/		return 0x82266914;
		  /* 82266914h */ case    9:  		/* lis R11, -32251 */
		/* 82266914h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82266914h case    9:*/		return 0x82266918;
		  /* 82266918h */ case   10:  		/* mr R6, R28 */
		/* 82266918h case   10:*/		regs.R6 = regs.R28;
		/* 82266918h case   10:*/		return 0x8226691C;
		  /* 8226691Ch */ case   11:  		/* addi R5, R11, -17648 */
		/* 8226691Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFBB10);
		/* 8226691Ch case   11:*/		return 0x82266920;
		  /* 82266920h */ case   12:  		/* mr R4, R29 */
		/* 82266920h case   12:*/		regs.R4 = regs.R29;
		/* 82266920h case   12:*/		return 0x82266924;
		  /* 82266924h */ case   13:  		/* li R7, 182 */
		/* 82266924h case   13:*/		cpu::op::li<0>(regs,&regs.R7,0xB6);
		/* 82266924h case   13:*/		return 0x82266928;
		  /* 82266928h */ case   14:  		/* li R3, 0 */
		/* 82266928h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82266928h case   14:*/		return 0x8226692C;
		  /* 8226692Ch */ case   15:  		/* bl -1109284 */
		/* 8226692Ch case   15:*/		regs.LR = 0x82266930; return 0x82157C08;
		/* 8226692Ch case   15:*/		return 0x82266930;
	}
	return 0x82266930;
} // Block from 822668F0h-82266930h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82266930h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266930( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266930) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266930);
		  /* 82266930h */ case    0:  		/* lwz R11, <#[R27 + 4]> */
		/* 82266930h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 82266930h case    0:*/		return 0x82266934;
		  /* 82266934h */ case    1:  		/* mulli R11, R11, 5 */
		/* 82266934h case    1:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x5);
		/* 82266934h case    1:*/		return 0x82266938;
		  /* 82266938h */ case    2:  		/* add R11, R11, R31 */
		/* 82266938h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 82266938h case    2:*/		return 0x8226693C;
		  /* 8226693Ch */ case    3:  		/* b 52 */
		/* 8226693Ch case    3:*/		return 0x82266970;
		/* 8226693Ch case    3:*/		return 0x82266940;
	}
	return 0x82266940;
} // Block from 82266930h-82266940h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82266940h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266940( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266940) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266940);
		  /* 82266940h */ case    0:  		/* cmpwi CR6, R11, 4 */
		/* 82266940h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000004);
		/* 82266940h case    0:*/		return 0x82266944;
		  /* 82266944h */ case    1:  		/* bc 4, CR6_GT, 32 */
		/* 82266944h case    1:*/		if ( !regs.CR[6].gt ) { return 0x82266964;  }
		/* 82266944h case    1:*/		return 0x82266948;
		  /* 82266948h */ case    2:  		/* lis R11, -32251 */
		/* 82266948h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82266948h case    2:*/		return 0x8226694C;
		  /* 8226694Ch */ case    3:  		/* mr R6, R28 */
		/* 8226694Ch case    3:*/		regs.R6 = regs.R28;
		/* 8226694Ch case    3:*/		return 0x82266950;
		  /* 82266950h */ case    4:  		/* addi R5, R11, -17668 */
		/* 82266950h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFBAFC);
		/* 82266950h case    4:*/		return 0x82266954;
		  /* 82266954h */ case    5:  		/* mr R4, R29 */
		/* 82266954h case    5:*/		regs.R4 = regs.R29;
		/* 82266954h case    5:*/		return 0x82266958;
		  /* 82266958h */ case    6:  		/* li R7, 185 */
		/* 82266958h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0xB9);
		/* 82266958h case    6:*/		return 0x8226695C;
		  /* 8226695Ch */ case    7:  		/* li R3, 0 */
		/* 8226695Ch case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8226695Ch case    7:*/		return 0x82266960;
		  /* 82266960h */ case    8:  		/* bl -1109336 */
		/* 82266960h case    8:*/		regs.LR = 0x82266964; return 0x82157C08;
		/* 82266960h case    8:*/		return 0x82266964;
	}
	return 0x82266964;
} // Block from 82266940h-82266964h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82266964h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266964( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266964) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266964);
		  /* 82266964h */ case    0:  		/* lwz R11, <#[R27 + 4]> */
		/* 82266964h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 82266964h case    0:*/		return 0x82266968;
		  /* 82266968h */ case    1:  		/* mulli R10, R31, 5 */
		/* 82266968h case    1:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R31,0x5);
		/* 82266968h case    1:*/		return 0x8226696C;
		  /* 8226696Ch */ case    2:  		/* add R11, R10, R11 */
		/* 8226696Ch case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8226696Ch case    2:*/		return 0x82266970;
	}
	return 0x82266970;
} // Block from 82266964h-82266970h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82266970h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266970( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266970) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266970);
		  /* 82266970h */ case    0:  		/* lis R10, -32251 */
		/* 82266970h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 82266970h case    0:*/		return 0x82266974;
		  /* 82266974h */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82266974h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82266974h case    1:*/		return 0x82266978;
		  /* 82266978h */ case    2:  		/* addi R10, R10, -18024 */
		/* 82266978h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFB998);
		/* 82266978h case    2:*/		return 0x8226697C;
		  /* 8226697Ch */ case    3:  		/* lwzx R11, <#[R11 + R10]> */
		/* 8226697Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8226697Ch case    3:*/		return 0x82266980;
		  /* 82266980h */ case    4:  		/* addi R11, R11, 1 */
		/* 82266980h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82266980h case    4:*/		return 0x82266984;
		  /* 82266984h */ case    5:  		/* addic R10, R11, -1 */
		/* 82266984h case    5:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R11,0xFFFFFFFF);
		/* 82266984h case    5:*/		return 0x82266988;
		  /* 82266988h */ case    6:  		/* subfe R3, R10, R11 */
		/* 82266988h case    6:*/		cpu::op::subfe<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 82266988h case    6:*/		return 0x8226698C;
	}
	return 0x8226698C;
} // Block from 82266970h-8226698Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8226698Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226698C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226698C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226698C);
		  /* 8226698Ch */ case    0:  		/* addi R1, R1, 144 */
		/* 8226698Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 8226698Ch case    0:*/		return 0x82266990;
		  /* 82266990h */ case    1:  		/* b -1922796 */
		/* 82266990h case    1:*/		return 0x820912A4;
		/* 82266990h case    1:*/		return 0x82266994;
		  /* 82266994h */ case    2:  		/* nop */
		/* 82266994h case    2:*/		cpu::op::nop();
		/* 82266994h case    2:*/		return 0x82266998;
	}
	return 0x82266998;
} // Block from 8226698Ch-82266998h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82266998h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266998( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266998) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266998);
		  /* 82266998h */ case    0:  		/* mfspr R12, LR */
		/* 82266998h case    0:*/		regs.R12 = regs.LR;
		/* 82266998h case    0:*/		return 0x8226699C;
		  /* 8226699Ch */ case    1:  		/* bl -1922888 */
		/* 8226699Ch case    1:*/		regs.LR = 0x822669A0; return 0x82091254;
		/* 8226699Ch case    1:*/		return 0x822669A0;
		  /* 822669A0h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 822669A0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 822669A0h case    2:*/		return 0x822669A4;
		  /* 822669A4h */ case    3:  		/* lwz R11, <#[R4]> */
		/* 822669A4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 822669A4h case    3:*/		return 0x822669A8;
		  /* 822669A8h */ case    4:  		/* mr R29, R3 */
		/* 822669A8h case    4:*/		regs.R29 = regs.R3;
		/* 822669A8h case    4:*/		return 0x822669AC;
		  /* 822669ACh */ case    5:  		/* mr R3, R4 */
		/* 822669ACh case    5:*/		regs.R3 = regs.R4;
		/* 822669ACh case    5:*/		return 0x822669B0;
		  /* 822669B0h */ case    6:  		/* mr R30, R4 */
		/* 822669B0h case    6:*/		regs.R30 = regs.R4;
		/* 822669B0h case    6:*/		return 0x822669B4;
		  /* 822669B4h */ case    7:  		/* lwz R11, <#[R11 + 52]> */
		/* 822669B4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000034) );
		/* 822669B4h case    7:*/		return 0x822669B8;
		  /* 822669B8h */ case    8:  		/* mtspr CTR, R11 */
		/* 822669B8h case    8:*/		regs.CTR = regs.R11;
		/* 822669B8h case    8:*/		return 0x822669BC;
		  /* 822669BCh */ case    9:  		/* bcctrl 20, CR0_LT */
		/* 822669BCh case    9:*/		if ( 1 ) { regs.LR = 0x822669C0; return (uint32)regs.CTR; }
		/* 822669BCh case    9:*/		return 0x822669C0;
		  /* 822669C0h */ case   10:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822669C0h case   10:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822669C0h case   10:*/		return 0x822669C4;
		  /* 822669C4h */ case   11:  		/* bc 4, CR0_EQ, 340 */
		/* 822669C4h case   11:*/		if ( !regs.CR[0].eq ) { return 0x82266B18;  }
		/* 822669C4h case   11:*/		return 0x822669C8;
		  /* 822669C8h */ case   12:  		/* addi R4, R1, 80 */
		/* 822669C8h case   12:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 822669C8h case   12:*/		return 0x822669CC;
		  /* 822669CCh */ case   13:  		/* mr R3, R30 */
		/* 822669CCh case   13:*/		regs.R3 = regs.R30;
		/* 822669CCh case   13:*/		return 0x822669D0;
		  /* 822669D0h */ case   14:  		/* bl -936 */
		/* 822669D0h case   14:*/		regs.LR = 0x822669D4; return 0x82266628;
		/* 822669D0h case   14:*/		return 0x822669D4;
		  /* 822669D4h */ case   15:  		/* lis R11, -32253 */
		/* 822669D4h case   15:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 822669D4h case   15:*/		return 0x822669D8;
		  /* 822669D8h */ case   16:  		/* lis R10, -32251 */
		/* 822669D8h case   16:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 822669D8h case   16:*/		return 0x822669DC;
		  /* 822669DCh */ case   17:  		/* mr R31, R3 */
		/* 822669DCh case   17:*/		regs.R31 = regs.R3;
		/* 822669DCh case   17:*/		return 0x822669E0;
		  /* 822669E0h */ case   18:  		/* cmpwi CR6, R3, -1 */
		/* 822669E0h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 822669E0h case   18:*/		return 0x822669E4;
		  /* 822669E4h */ case   19:  		/* addi R28, R11, 27460 */
		/* 822669E4h case   19:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R11,0x6B44);
		/* 822669E4h case   19:*/		return 0x822669E8;
		  /* 822669E8h */ case   20:  		/* addi R27, R10, -17768 */
		/* 822669E8h case   20:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R10,0xFFFFBA98);
		/* 822669E8h case   20:*/		return 0x822669EC;
		  /* 822669ECh */ case   21:  		/* bc 4, CR6_EQ, 32 */
		/* 822669ECh case   21:*/		if ( !regs.CR[6].eq ) { return 0x82266A0C;  }
		/* 822669ECh case   21:*/		return 0x822669F0;
		  /* 822669F0h */ case   22:  		/* lis R11, -32251 */
		/* 822669F0h case   22:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 822669F0h case   22:*/		return 0x822669F4;
		  /* 822669F4h */ case   23:  		/* mr R6, R27 */
		/* 822669F4h case   23:*/		regs.R6 = regs.R27;
		/* 822669F4h case   23:*/		return 0x822669F8;
		  /* 822669F8h */ case   24:  		/* addi R5, R11, -17628 */
		/* 822669F8h case   24:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFBB24);
		/* 822669F8h case   24:*/		return 0x822669FC;
		  /* 822669FCh */ case   25:  		/* mr R4, R28 */
		/* 822669FCh case   25:*/		regs.R4 = regs.R28;
		/* 822669FCh case   25:*/		return 0x82266A00;
		  /* 82266A00h */ case   26:  		/* li R7, 202 */
		/* 82266A00h case   26:*/		cpu::op::li<0>(regs,&regs.R7,0xCA);
		/* 82266A00h case   26:*/		return 0x82266A04;
		  /* 82266A04h */ case   27:  		/* li R3, 0 */
		/* 82266A04h case   27:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82266A04h case   27:*/		return 0x82266A08;
		  /* 82266A08h */ case   28:  		/* bl -1109504 */
		/* 82266A08h case   28:*/		regs.LR = 0x82266A0C; return 0x82157C08;
		/* 82266A08h case   28:*/		return 0x82266A0C;
	}
	return 0x82266A0C;
} // Block from 82266998h-82266A0Ch (29 instructions)

//////////////////////////////////////////////////////
// Block at 82266A0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266A0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266A0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266A0C);
		  /* 82266A0Ch */ case    0:  		/* lwz R11, <#[R29 + 4]> */
		/* 82266A0Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 82266A0Ch case    0:*/		return 0x82266A10;
		  /* 82266A10h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 82266A10h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82266A10h case    1:*/		return 0x82266A14;
		  /* 82266A14h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 82266A14h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82266A24;  }
		/* 82266A14h case    2:*/		return 0x82266A18;
		  /* 82266A18h */ case    3:  		/* lbz R11, <#[R1 + 80]> */
		/* 82266A18h case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82266A18h case    3:*/		return 0x82266A1C;
		  /* 82266A1Ch */ case    4:  		/* stb R11, <#[R29 + 8]> */
		/* 82266A1Ch case    4:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 82266A1Ch case    4:*/		return 0x82266A20;
		  /* 82266A20h */ case    5:  		/* b 56 */
		/* 82266A20h case    5:*/		return 0x82266A58;
		/* 82266A20h case    5:*/		return 0x82266A24;
	}
	return 0x82266A24;
} // Block from 82266A0Ch-82266A24h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82266A24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266A24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266A24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266A24);
		  /* 82266A24h */ case    0:  		/* cmpwi CR6, R31, 0 */
		/* 82266A24h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 82266A24h case    0:*/		return 0x82266A28;
		  /* 82266A28h */ case    1:  		/* bc 12, CR6_EQ, 48 */
		/* 82266A28h case    1:*/		if ( regs.CR[6].eq ) { return 0x82266A58;  }
		/* 82266A28h case    1:*/		return 0x82266A2C;
		  /* 82266A2Ch */ case    2:  		/* lbz R11, <#[R1 + 80]> */
		/* 82266A2Ch case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82266A2Ch case    2:*/		return 0x82266A30;
		  /* 82266A30h */ case    3:  		/* lbz R10, <#[R29 + 8]> */
		/* 82266A30h case    3:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000008) );
		/* 82266A30h case    3:*/		return 0x82266A34;
		  /* 82266A34h */ case    4:  		/* cmplw CR6, R10, R11 */
		/* 82266A34h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 82266A34h case    4:*/		return 0x82266A38;
		  /* 82266A38h */ case    5:  		/* bc 12, CR6_EQ, 32 */
		/* 82266A38h case    5:*/		if ( regs.CR[6].eq ) { return 0x82266A58;  }
		/* 82266A38h case    5:*/		return 0x82266A3C;
		  /* 82266A3Ch */ case    6:  		/* lis R11, -32251 */
		/* 82266A3Ch case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82266A3Ch case    6:*/		return 0x82266A40;
		  /* 82266A40h */ case    7:  		/* mr R6, R27 */
		/* 82266A40h case    7:*/		regs.R6 = regs.R27;
		/* 82266A40h case    7:*/		return 0x82266A44;
		  /* 82266A44h */ case    8:  		/* addi R5, R11, -17608 */
		/* 82266A44h case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFBB38);
		/* 82266A44h case    8:*/		return 0x82266A48;
		  /* 82266A48h */ case    9:  		/* mr R4, R28 */
		/* 82266A48h case    9:*/		regs.R4 = regs.R28;
		/* 82266A48h case    9:*/		return 0x82266A4C;
		  /* 82266A4Ch */ case   10:  		/* li R7, 207 */
		/* 82266A4Ch case   10:*/		cpu::op::li<0>(regs,&regs.R7,0xCF);
		/* 82266A4Ch case   10:*/		return 0x82266A50;
		  /* 82266A50h */ case   11:  		/* li R3, 0 */
		/* 82266A50h case   11:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82266A50h case   11:*/		return 0x82266A54;
		  /* 82266A54h */ case   12:  		/* bl -1109580 */
		/* 82266A54h case   12:*/		regs.LR = 0x82266A58; return 0x82157C08;
		/* 82266A54h case   12:*/		return 0x82266A58;
	}
	return 0x82266A58;
} // Block from 82266A24h-82266A58h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82266A58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266A58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266A58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266A58);
		  /* 82266A58h */ case    0:  		/* lwz R11, <#[R30 + 24]> */
		/* 82266A58h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000018) );
		/* 82266A58h case    0:*/		return 0x82266A5C;
		  /* 82266A5Ch */ case    1:  		/* lis R10, -32216 */
		/* 82266A5Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8228);
		/* 82266A5Ch case    1:*/		return 0x82266A60;
		  /* 82266A60h */ case    2:  		/* mulli R11, R11, 52 */
		/* 82266A60h case    2:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x34);
		/* 82266A60h case    2:*/		return 0x82266A64;
		  /* 82266A64h */ case    3:  		/* addi R10, R10, 17992 */
		/* 82266A64h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4648);
		/* 82266A64h case    3:*/		return 0x82266A68;
		  /* 82266A68h */ case    4:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82266A68h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82266A68h case    4:*/		return 0x82266A6C;
		  /* 82266A6Ch */ case    5:  		/* rlwinm. R11, R11, 30, 31, 31 */
		/* 82266A6Ch case    5:*/		cpu::op::rlwinm<1,30,31,31>(regs,&regs.R11,regs.R11);
		/* 82266A6Ch case    5:*/		return 0x82266A70;
		  /* 82266A70h */ case    6:  		/* bc 12, CR0_EQ, 56 */
		/* 82266A70h case    6:*/		if ( regs.CR[0].eq ) { return 0x82266AA8;  }
		/* 82266A70h case    6:*/		return 0x82266A74;
		  /* 82266A74h */ case    7:  		/* cmpwi CR6, R31, 4 */
		/* 82266A74h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000004);
		/* 82266A74h case    7:*/		return 0x82266A78;
		  /* 82266A78h */ case    8:  		/* bc 4, CR6_GT, 32 */
		/* 82266A78h case    8:*/		if ( !regs.CR[6].gt ) { return 0x82266A98;  }
		/* 82266A78h case    8:*/		return 0x82266A7C;
		  /* 82266A7Ch */ case    9:  		/* lis R11, -32251 */
		/* 82266A7Ch case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82266A7Ch case    9:*/		return 0x82266A80;
		  /* 82266A80h */ case   10:  		/* mr R6, R27 */
		/* 82266A80h case   10:*/		regs.R6 = regs.R27;
		/* 82266A80h case   10:*/		return 0x82266A84;
		  /* 82266A84h */ case   11:  		/* addi R5, R11, -17648 */
		/* 82266A84h case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFBB10);
		/* 82266A84h case   11:*/		return 0x82266A88;
		  /* 82266A88h */ case   12:  		/* mr R4, R28 */
		/* 82266A88h case   12:*/		regs.R4 = regs.R28;
		/* 82266A88h case   12:*/		return 0x82266A8C;
		  /* 82266A8Ch */ case   13:  		/* li R7, 211 */
		/* 82266A8Ch case   13:*/		cpu::op::li<0>(regs,&regs.R7,0xD3);
		/* 82266A8Ch case   13:*/		return 0x82266A90;
		  /* 82266A90h */ case   14:  		/* li R3, 0 */
		/* 82266A90h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82266A90h case   14:*/		return 0x82266A94;
		  /* 82266A94h */ case   15:  		/* bl -1109644 */
		/* 82266A94h case   15:*/		regs.LR = 0x82266A98; return 0x82157C08;
		/* 82266A94h case   15:*/		return 0x82266A98;
	}
	return 0x82266A98;
} // Block from 82266A58h-82266A98h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82266A98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266A98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266A98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266A98);
		  /* 82266A98h */ case    0:  		/* lwz R11, <#[R29 + 4]> */
		/* 82266A98h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 82266A98h case    0:*/		return 0x82266A9C;
		  /* 82266A9Ch */ case    1:  		/* mulli R11, R11, 5 */
		/* 82266A9Ch case    1:*/		cpu::op::mulli<0>(regs,&regs.R11,regs.R11,0x5);
		/* 82266A9Ch case    1:*/		return 0x82266AA0;
		  /* 82266AA0h */ case    2:  		/* add R11, R11, R31 */
		/* 82266AA0h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 82266AA0h case    2:*/		return 0x82266AA4;
		  /* 82266AA4h */ case    3:  		/* b 56 */
		/* 82266AA4h case    3:*/		return 0x82266ADC;
		/* 82266AA4h case    3:*/		return 0x82266AA8;
	}
	return 0x82266AA8;
} // Block from 82266A98h-82266AA8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82266AA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266AA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266AA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266AA8);
		  /* 82266AA8h */ case    0:  		/* lwz R11, <#[R29 + 4]> */
		/* 82266AA8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 82266AA8h case    0:*/		return 0x82266AAC;
		  /* 82266AACh */ case    1:  		/* cmpwi CR6, R11, 4 */
		/* 82266AACh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000004);
		/* 82266AACh case    1:*/		return 0x82266AB0;
		  /* 82266AB0h */ case    2:  		/* bc 4, CR6_GT, 32 */
		/* 82266AB0h case    2:*/		if ( !regs.CR[6].gt ) { return 0x82266AD0;  }
		/* 82266AB0h case    2:*/		return 0x82266AB4;
		  /* 82266AB4h */ case    3:  		/* lis R11, -32251 */
		/* 82266AB4h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82266AB4h case    3:*/		return 0x82266AB8;
		  /* 82266AB8h */ case    4:  		/* mr R6, R27 */
		/* 82266AB8h case    4:*/		regs.R6 = regs.R27;
		/* 82266AB8h case    4:*/		return 0x82266ABC;
		  /* 82266ABCh */ case    5:  		/* addi R5, R11, -17668 */
		/* 82266ABCh case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFBAFC);
		/* 82266ABCh case    5:*/		return 0x82266AC0;
		  /* 82266AC0h */ case    6:  		/* mr R4, R28 */
		/* 82266AC0h case    6:*/		regs.R4 = regs.R28;
		/* 82266AC0h case    6:*/		return 0x82266AC4;
		  /* 82266AC4h */ case    7:  		/* li R7, 214 */
		/* 82266AC4h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0xD6);
		/* 82266AC4h case    7:*/		return 0x82266AC8;
		  /* 82266AC8h */ case    8:  		/* li R3, 0 */
		/* 82266AC8h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82266AC8h case    8:*/		return 0x82266ACC;
		  /* 82266ACCh */ case    9:  		/* bl -1109700 */
		/* 82266ACCh case    9:*/		regs.LR = 0x82266AD0; return 0x82157C08;
		/* 82266ACCh case    9:*/		return 0x82266AD0;
	}
	return 0x82266AD0;
} // Block from 82266AA8h-82266AD0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82266AD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266AD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266AD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266AD0);
		  /* 82266AD0h */ case    0:  		/* lwz R11, <#[R29 + 4]> */
		/* 82266AD0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 82266AD0h case    0:*/		return 0x82266AD4;
		  /* 82266AD4h */ case    1:  		/* mulli R10, R31, 5 */
		/* 82266AD4h case    1:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R31,0x5);
		/* 82266AD4h case    1:*/		return 0x82266AD8;
		  /* 82266AD8h */ case    2:  		/* add R11, R10, R11 */
		/* 82266AD8h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82266AD8h case    2:*/		return 0x82266ADC;
	}
	return 0x82266ADC;
} // Block from 82266AD0h-82266ADCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 82266ADCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266ADC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266ADC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266ADC);
		  /* 82266ADCh */ case    0:  		/* lis R10, -32251 */
		/* 82266ADCh case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 82266ADCh case    0:*/		return 0x82266AE0;
		  /* 82266AE0h */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 82266AE0h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 82266AE0h case    1:*/		return 0x82266AE4;
		  /* 82266AE4h */ case    2:  		/* addi R10, R10, -18024 */
		/* 82266AE4h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFB998);
		/* 82266AE4h case    2:*/		return 0x82266AE8;
		  /* 82266AE8h */ case    3:  		/* lwzx R11, <#[R11 + R10]> */
		/* 82266AE8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 82266AE8h case    3:*/		return 0x82266AEC;
		  /* 82266AECh */ case    4:  		/* stw R11, <#[R29 + 4]> */
		/* 82266AECh case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 82266AECh case    4:*/		return 0x82266AF0;
		  /* 82266AF0h */ case    5:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 82266AF0h case    5:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 82266AF0h case    5:*/		return 0x82266AF4;
		  /* 82266AF4h */ case    6:  		/* cmpwi CR6, R11, -1 */
		/* 82266AF4h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0xFFFFFFFF);
		/* 82266AF4h case    6:*/		return 0x82266AF8;
		  /* 82266AF8h */ case    7:  		/* bc 4, CR6_EQ, 32 */
		/* 82266AF8h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82266B18;  }
		/* 82266AF8h case    7:*/		return 0x82266AFC;
		  /* 82266AFCh */ case    8:  		/* lis R11, -32251 */
		/* 82266AFCh case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82266AFCh case    8:*/		return 0x82266B00;
		  /* 82266B00h */ case    9:  		/* mr R6, R27 */
		/* 82266B00h case    9:*/		regs.R6 = regs.R27;
		/* 82266B00h case    9:*/		return 0x82266B04;
		  /* 82266B04h */ case   10:  		/* addi R5, R11, -17784 */
		/* 82266B04h case   10:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFBA88);
		/* 82266B04h case   10:*/		return 0x82266B08;
		  /* 82266B08h */ case   11:  		/* mr R4, R28 */
		/* 82266B08h case   11:*/		regs.R4 = regs.R28;
		/* 82266B08h case   11:*/		return 0x82266B0C;
		  /* 82266B0Ch */ case   12:  		/* li R7, 218 */
		/* 82266B0Ch case   12:*/		cpu::op::li<0>(regs,&regs.R7,0xDA);
		/* 82266B0Ch case   12:*/		return 0x82266B10;
		  /* 82266B10h */ case   13:  		/* li R3, 0 */
		/* 82266B10h case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82266B10h case   13:*/		return 0x82266B14;
		  /* 82266B14h */ case   14:  		/* bl -1109772 */
		/* 82266B14h case   14:*/		regs.LR = 0x82266B18; return 0x82157C08;
		/* 82266B14h case   14:*/		return 0x82266B18;
	}
	return 0x82266B18;
} // Block from 82266ADCh-82266B18h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82266B18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266B18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266B18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266B18);
		  /* 82266B18h */ case    0:  		/* addi R1, R1, 144 */
		/* 82266B18h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82266B18h case    0:*/		return 0x82266B1C;
		  /* 82266B1Ch */ case    1:  		/* b -1923192 */
		/* 82266B1Ch case    1:*/		return 0x820912A4;
		/* 82266B1Ch case    1:*/		return 0x82266B20;
	}
	return 0x82266B20;
} // Block from 82266B18h-82266B20h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82266B20h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266B20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266B20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266B20);
		  /* 82266B20h */ case    0:  		/* lwz R10, <#[R4 + 228]> */
		/* 82266B20h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x000000E4) );
		/* 82266B20h case    0:*/		return 0x82266B24;
		  /* 82266B24h */ case    1:  		/* lis R11, -32216 */
		/* 82266B24h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 82266B24h case    1:*/		return 0x82266B28;
		  /* 82266B28h */ case    2:  		/* rlwinm. R10, R10, 31, 31, 31 */
		/* 82266B28h case    2:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R10,regs.R10);
		/* 82266B28h case    2:*/		return 0x82266B2C;
		  /* 82266B2Ch */ case    3:  		/* addi R11, R11, 17992 */
		/* 82266B2Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4648);
		/* 82266B2Ch case    3:*/		return 0x82266B30;
		  /* 82266B30h */ case    4:  		/* bc 12, CR0_EQ, 12 */
		/* 82266B30h case    4:*/		if ( regs.CR[0].eq ) { return 0x82266B3C;  }
		/* 82266B30h case    4:*/		return 0x82266B34;
		  /* 82266B34h */ case    5:  		/* li R10, 0 */
		/* 82266B34h case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82266B34h case    5:*/		return 0x82266B38;
		  /* 82266B38h */ case    6:  		/* b 20 */
		/* 82266B38h case    6:*/		return 0x82266B4C;
		/* 82266B38h case    6:*/		return 0x82266B3C;
	}
	return 0x82266B3C;
} // Block from 82266B20h-82266B3Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 82266B3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266B3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266B3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266B3C);
		  /* 82266B3Ch */ case    0:  		/* lwz R10, <#[R4 + 24]> */
		/* 82266B3Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000018) );
		/* 82266B3Ch case    0:*/		return 0x82266B40;
		  /* 82266B40h */ case    1:  		/* mulli R10, R10, 52 */
		/* 82266B40h case    1:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x34);
		/* 82266B40h case    1:*/		return 0x82266B44;
		  /* 82266B44h */ case    2:  		/* lwzx R10, <#[R10 + R11]> */
		/* 82266B44h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82266B44h case    2:*/		return 0x82266B48;
		  /* 82266B48h */ case    3:  		/* rlwinm R10, R10, 29, 31, 31 */
		/* 82266B48h case    3:*/		cpu::op::rlwinm<0,29,31,31>(regs,&regs.R10,regs.R10);
		/* 82266B48h case    3:*/		return 0x82266B4C;
	}
	return 0x82266B4C;
} // Block from 82266B3Ch-82266B4Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82266B4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266B4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266B4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266B4C);
		  /* 82266B4Ch */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 82266B4Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 82266B4Ch case    0:*/		return 0x82266B50;
		  /* 82266B50h */ case    1:  		/* bc 4, CR0_EQ, 20 */
		/* 82266B50h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82266B64;  }
		/* 82266B50h case    1:*/		return 0x82266B54;
		  /* 82266B54h */ case    2:  		/* lwz R11, <#[R3 + 24]> */
		/* 82266B54h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82266B54h case    2:*/		return 0x82266B58;
		  /* 82266B58h */ case    3:  		/* addi R11, R11, 1 */
		/* 82266B58h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82266B58h case    3:*/		return 0x82266B5C;
		  /* 82266B5Ch */ case    4:  		/* stw R11, <#[R3 + 24]> */
		/* 82266B5Ch case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82266B5Ch case    4:*/		return 0x82266B60;
		  /* 82266B60h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82266B60h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82266B60h case    5:*/		return 0x82266B64;
	}
	return 0x82266B64;
} // Block from 82266B4Ch-82266B64h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82266B64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266B64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266B64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266B64);
		  /* 82266B64h */ case    0:  		/* lwz R10, <#[R4 + 24]> */
		/* 82266B64h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000018) );
		/* 82266B64h case    0:*/		return 0x82266B68;
		  /* 82266B68h */ case    1:  		/* mulli R10, R10, 52 */
		/* 82266B68h case    1:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x34);
		/* 82266B68h case    1:*/		return 0x82266B6C;
		  /* 82266B6Ch */ case    2:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82266B6Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82266B6Ch case    2:*/		return 0x82266B70;
		  /* 82266B70h */ case    3:  		/* rlwinm. R10, R11, 30, 31, 31 */
		/* 82266B70h case    3:*/		cpu::op::rlwinm<1,30,31,31>(regs,&regs.R10,regs.R11);
		/* 82266B70h case    3:*/		return 0x82266B74;
		  /* 82266B74h */ case    4:  		/* bc 12, CR0_EQ, 20 */
		/* 82266B74h case    4:*/		if ( regs.CR[0].eq ) { return 0x82266B88;  }
		/* 82266B74h case    4:*/		return 0x82266B78;
		  /* 82266B78h */ case    5:  		/* lwz R11, <#[R3 + 20]> */
		/* 82266B78h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 82266B78h case    5:*/		return 0x82266B7C;
		  /* 82266B7Ch */ case    6:  		/* addi R11, R11, 1 */
		/* 82266B7Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82266B7Ch case    6:*/		return 0x82266B80;
		  /* 82266B80h */ case    7:  		/* stw R11, <#[R3 + 20]> */
		/* 82266B80h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 82266B80h case    7:*/		return 0x82266B84;
		  /* 82266B84h */ case    8:  		/* bclr 20, CR0_LT */
		/* 82266B84h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82266B84h case    8:*/		return 0x82266B88;
	}
	return 0x82266B88;
} // Block from 82266B64h-82266B88h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82266B88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266B88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266B88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266B88);
		  /* 82266B88h */ case    0:  		/* rlwinm. R11, R11, 31, 31, 31 */
		/* 82266B88h case    0:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R11,regs.R11);
		/* 82266B88h case    0:*/		return 0x82266B8C;
		  /* 82266B8Ch */ case    1:  		/* bclr 12, CR0_EQ */
		/* 82266B8Ch case    1:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 82266B8Ch case    1:*/		return 0x82266B90;
	}
	return 0x82266B90;
} // Block from 82266B88h-82266B90h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82266B90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266B90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266B90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266B90);
		  /* 82266B90h */ case    0:  		/* lwz R11, <#[R3 + 16]> */
		/* 82266B90h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82266B90h case    0:*/		return 0x82266B94;
		  /* 82266B94h */ case    1:  		/* addi R11, R11, 1 */
		/* 82266B94h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82266B94h case    1:*/		return 0x82266B98;
		  /* 82266B98h */ case    2:  		/* stw R11, <#[R3 + 16]> */
		/* 82266B98h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82266B98h case    2:*/		return 0x82266B9C;
		  /* 82266B9Ch */ case    3:  		/* bclr 20, CR0_LT */
		/* 82266B9Ch case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82266B9Ch case    3:*/		return 0x82266BA0;
	}
	return 0x82266BA0;
} // Block from 82266B90h-82266BA0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82266BA0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266BA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266BA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266BA0);
		  /* 82266BA0h */ case    0:  		/* lwz R10, <#[R4 + 228]> */
		/* 82266BA0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x000000E4) );
		/* 82266BA0h case    0:*/		return 0x82266BA4;
		  /* 82266BA4h */ case    1:  		/* lis R11, -32216 */
		/* 82266BA4h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 82266BA4h case    1:*/		return 0x82266BA8;
		  /* 82266BA8h */ case    2:  		/* rlwinm. R10, R10, 31, 31, 31 */
		/* 82266BA8h case    2:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R10,regs.R10);
		/* 82266BA8h case    2:*/		return 0x82266BAC;
		  /* 82266BACh */ case    3:  		/* addi R11, R11, 17992 */
		/* 82266BACh case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4648);
		/* 82266BACh case    3:*/		return 0x82266BB0;
		  /* 82266BB0h */ case    4:  		/* bc 12, CR0_EQ, 12 */
		/* 82266BB0h case    4:*/		if ( regs.CR[0].eq ) { return 0x82266BBC;  }
		/* 82266BB0h case    4:*/		return 0x82266BB4;
		  /* 82266BB4h */ case    5:  		/* li R10, 0 */
		/* 82266BB4h case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82266BB4h case    5:*/		return 0x82266BB8;
		  /* 82266BB8h */ case    6:  		/* b 20 */
		/* 82266BB8h case    6:*/		return 0x82266BCC;
		/* 82266BB8h case    6:*/		return 0x82266BBC;
	}
	return 0x82266BBC;
} // Block from 82266BA0h-82266BBCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 82266BBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266BBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266BBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266BBC);
		  /* 82266BBCh */ case    0:  		/* lwz R10, <#[R4 + 24]> */
		/* 82266BBCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000018) );
		/* 82266BBCh case    0:*/		return 0x82266BC0;
		  /* 82266BC0h */ case    1:  		/* mulli R10, R10, 52 */
		/* 82266BC0h case    1:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x34);
		/* 82266BC0h case    1:*/		return 0x82266BC4;
		  /* 82266BC4h */ case    2:  		/* lwzx R10, <#[R10 + R11]> */
		/* 82266BC4h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82266BC4h case    2:*/		return 0x82266BC8;
		  /* 82266BC8h */ case    3:  		/* rlwinm R10, R10, 29, 31, 31 */
		/* 82266BC8h case    3:*/		cpu::op::rlwinm<0,29,31,31>(regs,&regs.R10,regs.R10);
		/* 82266BC8h case    3:*/		return 0x82266BCC;
	}
	return 0x82266BCC;
} // Block from 82266BBCh-82266BCCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 82266BCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266BCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266BCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266BCC);
		  /* 82266BCCh */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 82266BCCh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 82266BCCh case    0:*/		return 0x82266BD0;
		  /* 82266BD0h */ case    1:  		/* bc 4, CR0_EQ, 20 */
		/* 82266BD0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82266BE4;  }
		/* 82266BD0h case    1:*/		return 0x82266BD4;
		  /* 82266BD4h */ case    2:  		/* lwz R11, <#[R3 + 24]> */
		/* 82266BD4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82266BD4h case    2:*/		return 0x82266BD8;
		  /* 82266BD8h */ case    3:  		/* addi R11, R11, -1 */
		/* 82266BD8h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82266BD8h case    3:*/		return 0x82266BDC;
		  /* 82266BDCh */ case    4:  		/* stw R11, <#[R3 + 24]> */
		/* 82266BDCh case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82266BDCh case    4:*/		return 0x82266BE0;
		  /* 82266BE0h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82266BE0h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82266BE0h case    5:*/		return 0x82266BE4;
	}
	return 0x82266BE4;
} // Block from 82266BCCh-82266BE4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82266BE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266BE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266BE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266BE4);
		  /* 82266BE4h */ case    0:  		/* lwz R10, <#[R4 + 24]> */
		/* 82266BE4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000018) );
		/* 82266BE4h case    0:*/		return 0x82266BE8;
		  /* 82266BE8h */ case    1:  		/* mulli R10, R10, 52 */
		/* 82266BE8h case    1:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x34);
		/* 82266BE8h case    1:*/		return 0x82266BEC;
		  /* 82266BECh */ case    2:  		/* lwzx R11, <#[R10 + R11]> */
		/* 82266BECh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82266BECh case    2:*/		return 0x82266BF0;
		  /* 82266BF0h */ case    3:  		/* rlwinm. R10, R11, 30, 31, 31 */
		/* 82266BF0h case    3:*/		cpu::op::rlwinm<1,30,31,31>(regs,&regs.R10,regs.R11);
		/* 82266BF0h case    3:*/		return 0x82266BF4;
		  /* 82266BF4h */ case    4:  		/* bc 12, CR0_EQ, 20 */
		/* 82266BF4h case    4:*/		if ( regs.CR[0].eq ) { return 0x82266C08;  }
		/* 82266BF4h case    4:*/		return 0x82266BF8;
		  /* 82266BF8h */ case    5:  		/* lwz R11, <#[R3 + 20]> */
		/* 82266BF8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 82266BF8h case    5:*/		return 0x82266BFC;
		  /* 82266BFCh */ case    6:  		/* addi R11, R11, -1 */
		/* 82266BFCh case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82266BFCh case    6:*/		return 0x82266C00;
		  /* 82266C00h */ case    7:  		/* stw R11, <#[R3 + 20]> */
		/* 82266C00h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 82266C00h case    7:*/		return 0x82266C04;
		  /* 82266C04h */ case    8:  		/* bclr 20, CR0_LT */
		/* 82266C04h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82266C04h case    8:*/		return 0x82266C08;
	}
	return 0x82266C08;
} // Block from 82266BE4h-82266C08h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82266C08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266C08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266C08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266C08);
		  /* 82266C08h */ case    0:  		/* rlwinm. R11, R11, 31, 31, 31 */
		/* 82266C08h case    0:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R11,regs.R11);
		/* 82266C08h case    0:*/		return 0x82266C0C;
		  /* 82266C0Ch */ case    1:  		/* bclr 12, CR0_EQ */
		/* 82266C0Ch case    1:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 82266C0Ch case    1:*/		return 0x82266C10;
	}
	return 0x82266C10;
} // Block from 82266C08h-82266C10h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82266C10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266C10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266C10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266C10);
		  /* 82266C10h */ case    0:  		/* lwz R11, <#[R3 + 16]> */
		/* 82266C10h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82266C10h case    0:*/		return 0x82266C14;
		  /* 82266C14h */ case    1:  		/* addi R11, R11, -1 */
		/* 82266C14h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82266C14h case    1:*/		return 0x82266C18;
		  /* 82266C18h */ case    2:  		/* stw R11, <#[R3 + 16]> */
		/* 82266C18h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82266C18h case    2:*/		return 0x82266C1C;
		  /* 82266C1Ch */ case    3:  		/* bclr 20, CR0_LT */
		/* 82266C1Ch case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82266C1Ch case    3:*/		return 0x82266C20;
	}
	return 0x82266C20;
} // Block from 82266C10h-82266C20h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82266C20h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266C20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266C20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266C20);
		  /* 82266C20h */ case    0:  		/* lwz R11, <#[R3 + 16]> */
		/* 82266C20h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 82266C20h case    0:*/		return 0x82266C24;
		  /* 82266C24h */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 82266C24h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82266C24h case    1:*/		return 0x82266C28;
		  /* 82266C28h */ case    2:  		/* bc 4, CR6_GT, 36 */
		/* 82266C28h case    2:*/		if ( !regs.CR[6].gt ) { return 0x82266C4C;  }
		/* 82266C28h case    2:*/		return 0x82266C2C;
		  /* 82266C2Ch */ case    3:  		/* lwz R11, <#[R3 + 228]> */
		/* 82266C2Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x000000E4) );
		/* 82266C2Ch case    3:*/		return 0x82266C30;
		  /* 82266C30h */ case    4:  		/* rlwinm. R11, R11, 26, 31, 31 */
		/* 82266C30h case    4:*/		cpu::op::rlwinm<1,26,31,31>(regs,&regs.R11,regs.R11);
		/* 82266C30h case    4:*/		return 0x82266C34;
		  /* 82266C34h */ case    5:  		/* bc 4, CR0_EQ, 16 */
		/* 82266C34h case    5:*/		if ( !regs.CR[0].eq ) { return 0x82266C44;  }
		/* 82266C34h case    5:*/		return 0x82266C38;
		  /* 82266C38h */ case    6:  		/* lwz R11, <#[R3 + 80]> */
		/* 82266C38h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000050) );
		/* 82266C38h case    6:*/		return 0x82266C3C;
		  /* 82266C3Ch */ case    7:  		/* cmpwi CR6, R11, 31 */
		/* 82266C3Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000001F);
		/* 82266C3Ch case    7:*/		return 0x82266C40;
		  /* 82266C40h */ case    8:  		/* bc 4, CR6_EQ, 12 */
		/* 82266C40h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82266C4C;  }
		/* 82266C40h case    8:*/		return 0x82266C44;
	}
	return 0x82266C44;
} // Block from 82266C20h-82266C44h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82266C44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266C44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266C44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266C44);
		  /* 82266C44h */ case    0:  		/* li R3, 1 */
		/* 82266C44h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82266C44h case    0:*/		return 0x82266C48;
		  /* 82266C48h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82266C48h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82266C48h case    1:*/		return 0x82266C4C;
	}
	return 0x82266C4C;
} // Block from 82266C44h-82266C4Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82266C4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266C4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266C4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266C4C);
		  /* 82266C4Ch */ case    0:  		/* li R3, 0 */
		/* 82266C4Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82266C4Ch case    0:*/		return 0x82266C50;
		  /* 82266C50h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82266C50h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82266C50h case    1:*/		return 0x82266C54;
	}
	return 0x82266C54;
} // Block from 82266C4Ch-82266C54h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82266C54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266C54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266C54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266C54);
		  /* 82266C54h */ case    0:  		/* nop */
		/* 82266C54h case    0:*/		cpu::op::nop();
		/* 82266C54h case    0:*/		return 0x82266C58;
	}
	return 0x82266C58;
} // Block from 82266C54h-82266C58h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82266C58h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266C58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266C58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266C58);
		  /* 82266C58h */ case    0:  		/* lwz R11, <#[R3 + 24]> */
		/* 82266C58h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82266C58h case    0:*/		return 0x82266C5C;
		  /* 82266C5Ch */ case    1:  		/* cmpwi CR6, R11, 104 */
		/* 82266C5Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000068);
		/* 82266C5Ch case    1:*/		return 0x82266C60;
		  /* 82266C60h */ case    2:  		/* bc 12, CR6_EQ, 72 */
		/* 82266C60h case    2:*/		if ( regs.CR[6].eq ) { return 0x82266CA8;  }
		/* 82266C60h case    2:*/		return 0x82266C64;
		  /* 82266C64h */ case    3:  		/* cmpwi CR6, R11, 105 */
		/* 82266C64h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000069);
		/* 82266C64h case    3:*/		return 0x82266C68;
		  /* 82266C68h */ case    4:  		/* bc 12, CR6_EQ, 64 */
		/* 82266C68h case    4:*/		if ( regs.CR[6].eq ) { return 0x82266CA8;  }
		/* 82266C68h case    4:*/		return 0x82266C6C;
		  /* 82266C6Ch */ case    5:  		/* cmpwi CR6, R11, 106 */
		/* 82266C6Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000006A);
		/* 82266C6Ch case    5:*/		return 0x82266C70;
		  /* 82266C70h */ case    6:  		/* bc 12, CR6_EQ, 56 */
		/* 82266C70h case    6:*/		if ( regs.CR[6].eq ) { return 0x82266CA8;  }
		/* 82266C70h case    6:*/		return 0x82266C74;
		  /* 82266C74h */ case    7:  		/* cmpwi CR6, R11, 107 */
		/* 82266C74h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000006B);
		/* 82266C74h case    7:*/		return 0x82266C78;
		  /* 82266C78h */ case    8:  		/* bc 12, CR6_EQ, 48 */
		/* 82266C78h case    8:*/		if ( regs.CR[6].eq ) { return 0x82266CA8;  }
		/* 82266C78h case    8:*/		return 0x82266C7C;
		  /* 82266C7Ch */ case    9:  		/* cmpwi CR6, R11, 108 */
		/* 82266C7Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000006C);
		/* 82266C7Ch case    9:*/		return 0x82266C80;
		  /* 82266C80h */ case   10:  		/* bc 12, CR6_EQ, 40 */
		/* 82266C80h case   10:*/		if ( regs.CR[6].eq ) { return 0x82266CA8;  }
		/* 82266C80h case   10:*/		return 0x82266C84;
		  /* 82266C84h */ case   11:  		/* cmpwi CR6, R11, 109 */
		/* 82266C84h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000006D);
		/* 82266C84h case   11:*/		return 0x82266C88;
		  /* 82266C88h */ case   12:  		/* bc 12, CR6_EQ, 32 */
		/* 82266C88h case   12:*/		if ( regs.CR[6].eq ) { return 0x82266CA8;  }
		/* 82266C88h case   12:*/		return 0x82266C8C;
		  /* 82266C8Ch */ case   13:  		/* cmpwi CR6, R11, 110 */
		/* 82266C8Ch case   13:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000006E);
		/* 82266C8Ch case   13:*/		return 0x82266C90;
		  /* 82266C90h */ case   14:  		/* bc 12, CR6_EQ, 24 */
		/* 82266C90h case   14:*/		if ( regs.CR[6].eq ) { return 0x82266CA8;  }
		/* 82266C90h case   14:*/		return 0x82266C94;
		  /* 82266C94h */ case   15:  		/* cmpwi CR6, R11, 111 */
		/* 82266C94h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000006F);
		/* 82266C94h case   15:*/		return 0x82266C98;
		  /* 82266C98h */ case   16:  		/* bc 12, CR6_EQ, 16 */
		/* 82266C98h case   16:*/		if ( regs.CR[6].eq ) { return 0x82266CA8;  }
		/* 82266C98h case   16:*/		return 0x82266C9C;
		  /* 82266C9Ch */ case   17:  		/* cmpwi CR6, R11, 112 */
		/* 82266C9Ch case   17:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000070);
		/* 82266C9Ch case   17:*/		return 0x82266CA0;
		  /* 82266CA0h */ case   18:  		/* li R11, 0 */
		/* 82266CA0h case   18:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82266CA0h case   18:*/		return 0x82266CA4;
		  /* 82266CA4h */ case   19:  		/* bc 4, CR6_EQ, 8 */
		/* 82266CA4h case   19:*/		if ( !regs.CR[6].eq ) { return 0x82266CAC;  }
		/* 82266CA4h case   19:*/		return 0x82266CA8;
	}
	return 0x82266CA8;
} // Block from 82266C58h-82266CA8h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82266CA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266CA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266CA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266CA8);
		  /* 82266CA8h */ case    0:  		/* li R11, 1 */
		/* 82266CA8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82266CA8h case    0:*/		return 0x82266CAC;
	}
	return 0x82266CAC;
} // Block from 82266CA8h-82266CACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82266CACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266CAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266CAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266CAC);
		  /* 82266CACh */ case    0:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 82266CACh case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 82266CACh case    0:*/		return 0x82266CB0;
		  /* 82266CB0h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82266CB0h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82266CB0h case    1:*/		return 0x82266CB4;
	}
	return 0x82266CB4;
} // Block from 82266CACh-82266CB4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82266CB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266CB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266CB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266CB4);
		  /* 82266CB4h */ case    0:  		/* nop */
		/* 82266CB4h case    0:*/		cpu::op::nop();
		/* 82266CB4h case    0:*/		return 0x82266CB8;
	}
	return 0x82266CB8;
} // Block from 82266CB4h-82266CB8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82266CB8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266CB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266CB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266CB8);
		  /* 82266CB8h */ case    0:  		/* lwz R11, <#[R3 + 24]> */
		/* 82266CB8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82266CB8h case    0:*/		return 0x82266CBC;
		  /* 82266CBCh */ case    1:  		/* cmpwi CR6, R11, 113 */
		/* 82266CBCh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000071);
		/* 82266CBCh case    1:*/		return 0x82266CC0;
		  /* 82266CC0h */ case    2:  		/* bc 12, CR6_EQ, 32 */
		/* 82266CC0h case    2:*/		if ( regs.CR[6].eq ) { return 0x82266CE0;  }
		/* 82266CC0h case    2:*/		return 0x82266CC4;
		  /* 82266CC4h */ case    3:  		/* cmpwi CR6, R11, 114 */
		/* 82266CC4h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000072);
		/* 82266CC4h case    3:*/		return 0x82266CC8;
		  /* 82266CC8h */ case    4:  		/* bc 12, CR6_EQ, 24 */
		/* 82266CC8h case    4:*/		if ( regs.CR[6].eq ) { return 0x82266CE0;  }
		/* 82266CC8h case    4:*/		return 0x82266CCC;
		  /* 82266CCCh */ case    5:  		/* cmpwi CR6, R11, 115 */
		/* 82266CCCh case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000073);
		/* 82266CCCh case    5:*/		return 0x82266CD0;
		  /* 82266CD0h */ case    6:  		/* bc 12, CR6_EQ, 16 */
		/* 82266CD0h case    6:*/		if ( regs.CR[6].eq ) { return 0x82266CE0;  }
		/* 82266CD0h case    6:*/		return 0x82266CD4;
		  /* 82266CD4h */ case    7:  		/* cmpwi CR6, R11, 116 */
		/* 82266CD4h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000074);
		/* 82266CD4h case    7:*/		return 0x82266CD8;
		  /* 82266CD8h */ case    8:  		/* li R11, 0 */
		/* 82266CD8h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82266CD8h case    8:*/		return 0x82266CDC;
		  /* 82266CDCh */ case    9:  		/* bc 4, CR6_EQ, 8 */
		/* 82266CDCh case    9:*/		if ( !regs.CR[6].eq ) { return 0x82266CE4;  }
		/* 82266CDCh case    9:*/		return 0x82266CE0;
	}
	return 0x82266CE0;
} // Block from 82266CB8h-82266CE0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82266CE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266CE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266CE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266CE0);
		  /* 82266CE0h */ case    0:  		/* li R11, 1 */
		/* 82266CE0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82266CE0h case    0:*/		return 0x82266CE4;
	}
	return 0x82266CE4;
} // Block from 82266CE0h-82266CE4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82266CE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266CE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266CE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266CE4);
		  /* 82266CE4h */ case    0:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 82266CE4h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 82266CE4h case    0:*/		return 0x82266CE8;
		  /* 82266CE8h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82266CE8h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82266CE8h case    1:*/		return 0x82266CEC;
	}
	return 0x82266CEC;
} // Block from 82266CE4h-82266CECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 82266CECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266CEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266CEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266CEC);
		  /* 82266CECh */ case    0:  		/* nop */
		/* 82266CECh case    0:*/		cpu::op::nop();
		/* 82266CECh case    0:*/		return 0x82266CF0;
	}
	return 0x82266CF0;
} // Block from 82266CECh-82266CF0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82266CF0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266CF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266CF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266CF0);
		  /* 82266CF0h */ case    0:  		/* lwz R11, <#[R3 + 24]> */
		/* 82266CF0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000018) );
		/* 82266CF0h case    0:*/		return 0x82266CF4;
		  /* 82266CF4h */ case    1:  		/* cmpwi CR6, R11, 43 */
		/* 82266CF4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000002B);
		/* 82266CF4h case    1:*/		return 0x82266CF8;
		  /* 82266CF8h */ case    2:  		/* bc 12, CR6_EQ, 40 */
		/* 82266CF8h case    2:*/		if ( regs.CR[6].eq ) { return 0x82266D20;  }
		/* 82266CF8h case    2:*/		return 0x82266CFC;
		  /* 82266CFCh */ case    3:  		/* cmpwi CR6, R11, 99 */
		/* 82266CFCh case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000063);
		/* 82266CFCh case    3:*/		return 0x82266D00;
		  /* 82266D00h */ case    4:  		/* bc 12, CR6_EQ, 32 */
		/* 82266D00h case    4:*/		if ( regs.CR[6].eq ) { return 0x82266D20;  }
		/* 82266D00h case    4:*/		return 0x82266D04;
		  /* 82266D04h */ case    5:  		/* cmpwi CR6, R11, 100 */
		/* 82266D04h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000064);
		/* 82266D04h case    5:*/		return 0x82266D08;
		  /* 82266D08h */ case    6:  		/* bc 12, CR6_EQ, 24 */
		/* 82266D08h case    6:*/		if ( regs.CR[6].eq ) { return 0x82266D20;  }
		/* 82266D08h case    6:*/		return 0x82266D0C;
		  /* 82266D0Ch */ case    7:  		/* cmpwi CR6, R11, 142 */
		/* 82266D0Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000008E);
		/* 82266D0Ch case    7:*/		return 0x82266D10;
		  /* 82266D10h */ case    8:  		/* bc 12, CR6_EQ, 16 */
		/* 82266D10h case    8:*/		if ( regs.CR[6].eq ) { return 0x82266D20;  }
		/* 82266D10h case    8:*/		return 0x82266D14;
		  /* 82266D14h */ case    9:  		/* cmpwi CR6, R11, 143 */
		/* 82266D14h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000008F);
		/* 82266D14h case    9:*/		return 0x82266D18;
		  /* 82266D18h */ case   10:  		/* li R11, 0 */
		/* 82266D18h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82266D18h case   10:*/		return 0x82266D1C;
		  /* 82266D1Ch */ case   11:  		/* bc 4, CR6_EQ, 8 */
		/* 82266D1Ch case   11:*/		if ( !regs.CR[6].eq ) { return 0x82266D24;  }
		/* 82266D1Ch case   11:*/		return 0x82266D20;
	}
	return 0x82266D20;
} // Block from 82266CF0h-82266D20h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82266D20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266D20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266D20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266D20);
		  /* 82266D20h */ case    0:  		/* li R11, 1 */
		/* 82266D20h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82266D20h case    0:*/		return 0x82266D24;
	}
	return 0x82266D24;
} // Block from 82266D20h-82266D24h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82266D24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266D24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266D24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266D24);
		  /* 82266D24h */ case    0:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 82266D24h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 82266D24h case    0:*/		return 0x82266D28;
		  /* 82266D28h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82266D28h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82266D28h case    1:*/		return 0x82266D2C;
	}
	return 0x82266D2C;
} // Block from 82266D24h-82266D2Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82266D2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266D2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266D2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266D2C);
		  /* 82266D2Ch */ case    0:  		/* nop */
		/* 82266D2Ch case    0:*/		cpu::op::nop();
		/* 82266D2Ch case    0:*/		return 0x82266D30;
	}
	return 0x82266D30;
} // Block from 82266D2Ch-82266D30h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82266D30h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266D30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266D30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266D30);
		  /* 82266D30h */ case    0:  		/* mfspr R12, LR */
		/* 82266D30h case    0:*/		regs.R12 = regs.LR;
		/* 82266D30h case    0:*/		return 0x82266D34;
		  /* 82266D34h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82266D34h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82266D34h case    1:*/		return 0x82266D38;
		  /* 82266D38h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82266D38h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82266D38h case    2:*/		return 0x82266D3C;
		  /* 82266D3Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82266D3Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82266D3Ch case    3:*/		return 0x82266D40;
		  /* 82266D40h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82266D40h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82266D40h case    4:*/		return 0x82266D44;
		  /* 82266D44h */ case    5:  		/* mr R31, R3 */
		/* 82266D44h case    5:*/		regs.R31 = regs.R3;
		/* 82266D44h case    5:*/		return 0x82266D48;
		  /* 82266D48h */ case    6:  		/* mr R30, R4 */
		/* 82266D48h case    6:*/		regs.R30 = regs.R4;
		/* 82266D48h case    6:*/		return 0x82266D4C;
		  /* 82266D4Ch */ case    7:  		/* cmpwi CR6, R7, 0 */
		/* 82266D4Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000000);
		/* 82266D4Ch case    7:*/		return 0x82266D50;
		  /* 82266D50h */ case    8:  		/* bc 4, CR6_EQ, 192 */
		/* 82266D50h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82266E10;  }
		/* 82266D50h case    8:*/		return 0x82266D54;
		  /* 82266D54h */ case    9:  		/* lwz R11, <#[R4 + 228]> */
		/* 82266D54h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x000000E4) );
		/* 82266D54h case    9:*/		return 0x82266D58;
		  /* 82266D58h */ case   10:  		/* rlwinm. R11, R11, 23, 31, 31 */
		/* 82266D58h case   10:*/		cpu::op::rlwinm<1,23,31,31>(regs,&regs.R11,regs.R11);
		/* 82266D58h case   10:*/		return 0x82266D5C;
		  /* 82266D5Ch */ case   11:  		/* bc 12, CR0_EQ, 36 */
		/* 82266D5Ch case   11:*/		if ( regs.CR[0].eq ) { return 0x82266D80;  }
		/* 82266D5Ch case   11:*/		return 0x82266D60;
		  /* 82266D60h */ case   12:  		/* lwz R11, <#[R4 + 20]> */
		/* 82266D60h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000014) );
		/* 82266D60h case   12:*/		return 0x82266D64;
		  /* 82266D64h */ case   13:  		/* cmpw CR6, R6, R11 */
		/* 82266D64h case   13:*/		cpu::op::cmpw<6>(regs,regs.R6,regs.R11);
		/* 82266D64h case   13:*/		return 0x82266D68;
		  /* 82266D68h */ case   14:  		/* bc 4, CR6_EQ, 24 */
		/* 82266D68h case   14:*/		if ( !regs.CR[6].eq ) { return 0x82266D80;  }
		/* 82266D68h case   14:*/		return 0x82266D6C;
		  /* 82266D6Ch */ case   15:  		/* mr R4, R3 */
		/* 82266D6Ch case   15:*/		regs.R4 = regs.R3;
		/* 82266D6Ch case   15:*/		return 0x82266D70;
		  /* 82266D70h */ case   16:  		/* mr R3, R30 */
		/* 82266D70h case   16:*/		regs.R3 = regs.R30;
		/* 82266D70h case   16:*/		return 0x82266D74;
		  /* 82266D74h */ case   17:  		/* bl -69588 */
		/* 82266D74h case   17:*/		regs.LR = 0x82266D78; return 0x82255DA0;
		/* 82266D74h case   17:*/		return 0x82266D78;
		  /* 82266D78h */ case   18:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82266D78h case   18:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82266D78h case   18:*/		return 0x82266D7C;
		  /* 82266D7Ch */ case   19:  		/* bc 4, CR0_EQ, 160 */
		/* 82266D7Ch case   19:*/		if ( !regs.CR[0].eq ) { return 0x82266E1C;  }
		/* 82266D7Ch case   19:*/		return 0x82266D80;
	}
	return 0x82266D80;
} // Block from 82266D30h-82266D80h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82266D80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266D80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266D80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266D80);
		  /* 82266D80h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 82266D80h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 82266D80h case    0:*/		return 0x82266D84;
		  /* 82266D84h */ case    1:  		/* mr R3, R30 */
		/* 82266D84h case    1:*/		regs.R3 = regs.R30;
		/* 82266D84h case    1:*/		return 0x82266D88;
		  /* 82266D88h */ case    2:  		/* lwz R11, <#[R11 + 72]> */
		/* 82266D88h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000048) );
		/* 82266D88h case    2:*/		return 0x82266D8C;
		  /* 82266D8Ch */ case    3:  		/* mtspr CTR, R11 */
		/* 82266D8Ch case    3:*/		regs.CTR = regs.R11;
		/* 82266D8Ch case    3:*/		return 0x82266D90;
		  /* 82266D90h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 82266D90h case    4:*/		if ( 1 ) { regs.LR = 0x82266D94; return (uint32)regs.CTR; }
		/* 82266D90h case    4:*/		return 0x82266D94;
		  /* 82266D94h */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82266D94h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82266D94h case    5:*/		return 0x82266D98;
		  /* 82266D98h */ case    6:  		/* bc 12, CR0_EQ, 112 */
		/* 82266D98h case    6:*/		if ( regs.CR[0].eq ) { return 0x82266E08;  }
		/* 82266D98h case    6:*/		return 0x82266D9C;
		  /* 82266D9Ch */ case    7:  		/* lwz R11, <#[R31]> */
		/* 82266D9Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82266D9Ch case    7:*/		return 0x82266DA0;
	}
	return 0x82266DA0;
} // Block from 82266D80h-82266DA0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82266DA0h
// Function '?FormatFloat@PrintTools@XGRAPHICS@@SAXMPAD@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266DA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266DA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266DA0);
		  /* 82266DA0h */ case    0:  		/* mr R3, R31 */
		/* 82266DA0h case    0:*/		regs.R3 = regs.R31;
		/* 82266DA0h case    0:*/		return 0x82266DA4;
		  /* 82266DA4h */ case    1:  		/* lwz R11, <#[R11 + 68]> */
		/* 82266DA4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000044) );
		/* 82266DA4h case    1:*/		return 0x82266DA8;
		  /* 82266DA8h */ case    2:  		/* mtspr CTR, R11 */
		/* 82266DA8h case    2:*/		regs.CTR = regs.R11;
		/* 82266DA8h case    2:*/		return 0x82266DAC;
		  /* 82266DACh */ case    3:  		/* bcctrl 20, CR0_LT */
		/* 82266DACh case    3:*/		if ( 1 ) { regs.LR = 0x82266DB0; return (uint32)regs.CTR; }
		/* 82266DACh case    3:*/		return 0x82266DB0;
		  /* 82266DB0h */ case    4:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82266DB0h case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82266DB0h case    4:*/		return 0x82266DB4;
		  /* 82266DB4h */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 82266DB4h case    5:*/		if ( regs.CR[0].eq ) { return 0x82266DC4;  }
		/* 82266DB4h case    5:*/		return 0x82266DB8;
		  /* 82266DB8h */ case    6:  		/* lwz R11, <#[R31 + 172]> */
		/* 82266DB8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000AC) );
		/* 82266DB8h case    6:*/		return 0x82266DBC;
		  /* 82266DBCh */ case    7:  		/* cmplw CR6, R11, R30 */
		/* 82266DBCh case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 82266DBCh case    7:*/		return 0x82266DC0;
		  /* 82266DC0h */ case    8:  		/* bc 12, CR6_EQ, 92 */
		/* 82266DC0h case    8:*/		if ( regs.CR[6].eq ) { return 0x82266E1C;  }
		/* 82266DC0h case    8:*/		return 0x82266DC4;
	}
	return 0x82266DC4;
} // Block from 82266DA0h-82266DC4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82266DC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266DC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266DC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266DC4);
		  /* 82266DC4h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 82266DC4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82266DC4h case    0:*/		return 0x82266DC8;
		  /* 82266DC8h */ case    1:  		/* mr R3, R31 */
		/* 82266DC8h case    1:*/		regs.R3 = regs.R31;
		/* 82266DC8h case    1:*/		return 0x82266DCC;
		  /* 82266DCCh */ case    2:  		/* lwz R11, <#[R11 + 24]> */
		/* 82266DCCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 82266DCCh case    2:*/		return 0x82266DD0;
		  /* 82266DD0h */ case    3:  		/* mtspr CTR, R11 */
		/* 82266DD0h case    3:*/		regs.CTR = regs.R11;
		/* 82266DD0h case    3:*/		return 0x82266DD4;
		  /* 82266DD4h */ case    4:  		/* bcctrl 20, CR0_LT */
		/* 82266DD4h case    4:*/		if ( 1 ) { regs.LR = 0x82266DD8; return (uint32)regs.CTR; }
		/* 82266DD4h case    4:*/		return 0x82266DD8;
		  /* 82266DD8h */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82266DD8h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82266DD8h case    5:*/		return 0x82266DDC;
		  /* 82266DDCh */ case    6:  		/* bc 12, CR0_EQ, 44 */
		/* 82266DDCh case    6:*/		if ( regs.CR[0].eq ) { return 0x82266E08;  }
		/* 82266DDCh case    6:*/		return 0x82266DE0;
		  /* 82266DE0h */ case    7:  		/* lwz R11, <#[R31]> */
		/* 82266DE0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82266DE0h case    7:*/		return 0x82266DE4;
		  /* 82266DE4h */ case    8:  		/* mr R3, R31 */
		/* 82266DE4h case    8:*/		regs.R3 = regs.R31;
		/* 82266DE4h case    8:*/		return 0x82266DE8;
		  /* 82266DE8h */ case    9:  		/* lwz R11, <#[R11 + 28]> */
		/* 82266DE8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000001C) );
		/* 82266DE8h case    9:*/		return 0x82266DEC;
		  /* 82266DECh */ case   10:  		/* mtspr CTR, R11 */
		/* 82266DECh case   10:*/		regs.CTR = regs.R11;
		/* 82266DECh case   10:*/		return 0x82266DF0;
		  /* 82266DF0h */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 82266DF0h case   11:*/		if ( 1 ) { regs.LR = 0x82266DF4; return (uint32)regs.CTR; }
		/* 82266DF0h case   11:*/		return 0x82266DF4;
		  /* 82266DF4h */ case   12:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 82266DF4h case   12:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 82266DF4h case   12:*/		return 0x82266DF8;
		  /* 82266DF8h */ case   13:  		/* bc 12, CR0_EQ, 16 */
		/* 82266DF8h case   13:*/		if ( regs.CR[0].eq ) { return 0x82266E08;  }
		/* 82266DF8h case   13:*/		return 0x82266DFC;
		  /* 82266DFCh */ case   14:  		/* lwz R11, <#[R31 + 180]> */
		/* 82266DFCh case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x000000B4) );
		/* 82266DFCh case   14:*/		return 0x82266E00;
		  /* 82266E00h */ case   15:  		/* cmplw CR6, R11, R30 */
		/* 82266E00h case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 82266E00h case   15:*/		return 0x82266E04;
		  /* 82266E04h */ case   16:  		/* bc 12, CR6_EQ, 24 */
		/* 82266E04h case   16:*/		if ( regs.CR[6].eq ) { return 0x82266E1C;  }
		/* 82266E04h case   16:*/		return 0x82266E08;
	}
	return 0x82266E08;
} // Block from 82266DC4h-82266E08h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82266E08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266E08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266E08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266E08);
		  /* 82266E08h */ case    0:  		/* li R3, 1 */
		/* 82266E08h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82266E08h case    0:*/		return 0x82266E0C;
		  /* 82266E0Ch */ case    1:  		/* b 20 */
		/* 82266E0Ch case    1:*/		return 0x82266E20;
		/* 82266E0Ch case    1:*/		return 0x82266E10;
	}
	return 0x82266E10;
} // Block from 82266E08h-82266E10h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82266E10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266E10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266E10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266E10);
		  /* 82266E10h */ case    0:  		/* cmpwi CR6, R7, 1 */
		/* 82266E10h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000001);
		/* 82266E10h case    0:*/		return 0x82266E14;
		  /* 82266E14h */ case    1:  		/* li R3, 1 */
		/* 82266E14h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82266E14h case    1:*/		return 0x82266E18;
		  /* 82266E18h */ case    2:  		/* bc 12, CR6_EQ, 8 */
		/* 82266E18h case    2:*/		if ( regs.CR[6].eq ) { return 0x82266E20;  }
		/* 82266E18h case    2:*/		return 0x82266E1C;
	}
	return 0x82266E1C;
} // Block from 82266E10h-82266E1Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82266E1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266E1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266E1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266E1C);
		  /* 82266E1Ch */ case    0:  		/* li R3, 0 */
		/* 82266E1Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82266E1Ch case    0:*/		return 0x82266E20;
	}
	return 0x82266E20;
} // Block from 82266E1Ch-82266E20h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82266E20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266E20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266E20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266E20);
		  /* 82266E20h */ case    0:  		/* addi R1, R1, 112 */
		/* 82266E20h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82266E20h case    0:*/		return 0x82266E24;
		  /* 82266E24h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82266E24h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82266E24h case    1:*/		return 0x82266E28;
		  /* 82266E28h */ case    2:  		/* mtspr LR, R12 */
		/* 82266E28h case    2:*/		regs.LR = regs.R12;
		/* 82266E28h case    2:*/		return 0x82266E2C;
		  /* 82266E2Ch */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 82266E2Ch case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82266E2Ch case    3:*/		return 0x82266E30;
		  /* 82266E30h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 82266E30h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82266E30h case    4:*/		return 0x82266E34;
		  /* 82266E34h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82266E34h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82266E34h case    5:*/		return 0x82266E38;
	}
	return 0x82266E38;
} // Block from 82266E20h-82266E38h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82266E38h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266E38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266E38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266E38);
		  /* 82266E38h */ case    0:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 82266E38h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 82266E38h case    0:*/		return 0x82266E3C;
		  /* 82266E3Ch */ case    1:  		/* mr R11, R3 */
		/* 82266E3Ch case    1:*/		regs.R11 = regs.R3;
		/* 82266E3Ch case    1:*/		return 0x82266E40;
		  /* 82266E40h */ case    2:  		/* add R9, R10, R4 */
		/* 82266E40h case    2:*/		cpu::op::add<0>(regs,&regs.R9,regs.R10,regs.R4);
		/* 82266E40h case    2:*/		return 0x82266E44;
		  /* 82266E44h */ case    3:  		/* lwzx R10, <#[R10 + R4]> */
		/* 82266E44h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R4 + 0x00000000) );
		/* 82266E44h case    3:*/		return 0x82266E48;
		  /* 82266E48h */ case    4:  		/* cmpw CR6, R10, R3 */
		/* 82266E48h case    4:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R3);
		/* 82266E48h case    4:*/		return 0x82266E4C;
		  /* 82266E4Ch */ case    5:  		/* bc 12, CR6_EQ, 28 */
		/* 82266E4Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x82266E68;  }
		/* 82266E4Ch case    5:*/		return 0x82266E50;
		  /* 82266E50h */ case    6:  		/* rlwinm R11, R10, 2, 0, 29 */
		/* 82266E50h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 82266E50h case    6:*/		return 0x82266E54;
		  /* 82266E54h */ case    7:  		/* lwzx R11, <#[R11 + R4]> */
		/* 82266E54h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R4 + 0x00000000) );
		/* 82266E54h case    7:*/		return 0x82266E58;
		  /* 82266E58h */ case    8:  		/* rlwinm R10, R11, 2, 0, 29 */
		/* 82266E58h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R11);
		/* 82266E58h case    8:*/		return 0x82266E5C;
		  /* 82266E5Ch */ case    9:  		/* lwzx R10, <#[R10 + R4]> */
		/* 82266E5Ch case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R4 + 0x00000000) );
		/* 82266E5Ch case    9:*/		return 0x82266E60;
		  /* 82266E60h */ case   10:  		/* cmpw CR6, R10, R11 */
		/* 82266E60h case   10:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R11);
		/* 82266E60h case   10:*/		return 0x82266E64;
		  /* 82266E64h */ case   11:  		/* bc 4, CR6_EQ, -20 */
		/* 82266E64h case   11:*/		if ( !regs.CR[6].eq ) { return 0x82266E50;  }
		/* 82266E64h case   11:*/		return 0x82266E68;
	}
	return 0x82266E68;
} // Block from 82266E38h-82266E68h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82266E68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266E68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266E68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266E68);
		  /* 82266E68h */ case    0:  		/* cmpw CR6, R3, R11 */
		/* 82266E68h case    0:*/		cpu::op::cmpw<6>(regs,regs.R3,regs.R11);
		/* 82266E68h case    0:*/		return 0x82266E6C;
		  /* 82266E6Ch */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 82266E6Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x82266E8C;  }
		/* 82266E6Ch case    1:*/		return 0x82266E70;
		  /* 82266E70h */ case    2:  		/* mr R10, R9 */
		/* 82266E70h case    2:*/		regs.R10 = regs.R9;
		/* 82266E70h case    2:*/		return 0x82266E74;
		  /* 82266E74h */ case    3:  		/* lwz R8, <#[R10]> */
		/* 82266E74h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 82266E74h case    3:*/		return 0x82266E78;
		  /* 82266E78h */ case    4:  		/* rlwinm R10, R8, 2, 0, 29 */
		/* 82266E78h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R8);
		/* 82266E78h case    4:*/		return 0x82266E7C;
		  /* 82266E7Ch */ case    5:  		/* cmpw CR6, R8, R11 */
		/* 82266E7Ch case    5:*/		cpu::op::cmpw<6>(regs,regs.R8,regs.R11);
		/* 82266E7Ch case    5:*/		return 0x82266E80;
		  /* 82266E80h */ case    6:  		/* add R10, R10, R4 */
		/* 82266E80h case    6:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R4);
		/* 82266E80h case    6:*/		return 0x82266E84;
		  /* 82266E84h */ case    7:  		/* stw R11, <#[R10]> */
		/* 82266E84h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82266E84h case    7:*/		return 0x82266E88;
		  /* 82266E88h */ case    8:  		/* bc 4, CR6_EQ, -20 */
		/* 82266E88h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82266E74;  }
		/* 82266E88h case    8:*/		return 0x82266E8C;
	}
	return 0x82266E8C;
} // Block from 82266E68h-82266E8Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 82266E8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266E8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266E8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266E8C);
		  /* 82266E8Ch */ case    0:  		/* stw R11, <#[R9]> */
		/* 82266E8Ch case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 82266E8Ch case    0:*/		return 0x82266E90;
		  /* 82266E90h */ case    1:  		/* mr R3, R11 */
		/* 82266E90h case    1:*/		regs.R3 = regs.R11;
		/* 82266E90h case    1:*/		return 0x82266E94;
		  /* 82266E94h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82266E94h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82266E94h case    2:*/		return 0x82266E98;
	}
	return 0x82266E98;
} // Block from 82266E8Ch-82266E98h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82266E98h
// Function '?Check@R400SlotModel@XGRAPHICS@@UAA_NPBVIRInst@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266E98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266E98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266E98);
		  /* 82266E98h */ case    0:  		/* rlwinm R11, R4, 2, 0, 29 */
		/* 82266E98h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R4);
		/* 82266E98h case    0:*/		return 0x82266E9C;
		  /* 82266E9Ch */ case    1:  		/* stwx R3, <#[R11 + R5]> */
		/* 82266E9Ch case    1:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + regs.R5 + 0x00000000) );
		/* 82266E9Ch case    1:*/		return 0x82266EA0;
		  /* 82266EA0h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82266EA0h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82266EA0h case    2:*/		return 0x82266EA4;
	}
	return 0x82266EA4;
} // Block from 82266E98h-82266EA4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82266EA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266EA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266EA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266EA4);
		  /* 82266EA4h */ case    0:  		/* nop */
		/* 82266EA4h case    0:*/		cpu::op::nop();
		/* 82266EA4h case    0:*/		return 0x82266EA8;
	}
	return 0x82266EA8;
} // Block from 82266EA4h-82266EA8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82266EA8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266EA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266EA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266EA8);
		  /* 82266EA8h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82266EA8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82266EA8h case    0:*/		return 0x82266EAC;
		  /* 82266EACh */ case    1:  		/* rlwinm. R11, R11, 0, 9, 9 */
		/* 82266EACh case    1:*/		cpu::op::rlwinm<1,0,9,9>(regs,&regs.R11,regs.R11);
		/* 82266EACh case    1:*/		return 0x82266EB0;
		  /* 82266EB0h */ case    2:  		/* bc 12, CR0_EQ, 76 */
		/* 82266EB0h case    2:*/		if ( regs.CR[0].eq ) { return 0x82266EFC;  }
		/* 82266EB0h case    2:*/		return 0x82266EB4;
		  /* 82266EB4h */ case    3:  		/* cmplwi CR6, R4, 1 */
		/* 82266EB4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000001);
		/* 82266EB4h case    3:*/		return 0x82266EB8;
		  /* 82266EB8h */ case    4:  		/* bc 12, CR6_LT, 56 */
		/* 82266EB8h case    4:*/		if ( regs.CR[6].lt ) { return 0x82266EF0;  }
		/* 82266EB8h case    4:*/		return 0x82266EBC;
		  /* 82266EBCh */ case    5:  		/* bc 12, CR6_EQ, 40 */
		/* 82266EBCh case    5:*/		if ( regs.CR[6].eq ) { return 0x82266EE4;  }
		/* 82266EBCh case    5:*/		return 0x82266EC0;
		  /* 82266EC0h */ case    6:  		/* cmplwi CR6, R4, 3 */
		/* 82266EC0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000003);
		/* 82266EC0h case    6:*/		return 0x82266EC4;
		  /* 82266EC4h */ case    7:  		/* bc 12, CR6_LT, 20 */
		/* 82266EC4h case    7:*/		if ( regs.CR[6].lt ) { return 0x82266ED8;  }
		/* 82266EC4h case    7:*/		return 0x82266EC8;
		  /* 82266EC8h */ case    8:  		/* bc 4, CR6_EQ, 52 */
		/* 82266EC8h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82266EFC;  }
		/* 82266EC8h case    8:*/		return 0x82266ECC;
		  /* 82266ECCh */ case    9:  		/* lwz R11, <#[R3 + 4]> */
		/* 82266ECCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82266ECCh case    9:*/		return 0x82266ED0;
		  /* 82266ED0h */ case   10:  		/* rlwinm R3, R11, 26, 30, 31 */
		/* 82266ED0h case   10:*/		cpu::op::rlwinm<0,26,30,31>(regs,&regs.R3,regs.R11);
		/* 82266ED0h case   10:*/		return 0x82266ED4;
		  /* 82266ED4h */ case   11:  		/* bclr 20, CR0_LT */
		/* 82266ED4h case   11:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82266ED4h case   11:*/		return 0x82266ED8;
	}
	return 0x82266ED8;
} // Block from 82266EA8h-82266ED8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82266ED8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266ED8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266ED8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266ED8);
		  /* 82266ED8h */ case    0:  		/* lwz R11, <#[R3 + 4]> */
		/* 82266ED8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82266ED8h case    0:*/		return 0x82266EDC;
		  /* 82266EDCh */ case    1:  		/* rlwinm R3, R11, 28, 30, 31 */
		/* 82266EDCh case    1:*/		cpu::op::rlwinm<0,28,30,31>(regs,&regs.R3,regs.R11);
		/* 82266EDCh case    1:*/		return 0x82266EE0;
		  /* 82266EE0h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82266EE0h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82266EE0h case    2:*/		return 0x82266EE4;
	}
	return 0x82266EE4;
} // Block from 82266ED8h-82266EE4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82266EE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266EE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266EE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266EE4);
		  /* 82266EE4h */ case    0:  		/* lwz R11, <#[R3 + 4]> */
		/* 82266EE4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82266EE4h case    0:*/		return 0x82266EE8;
		  /* 82266EE8h */ case    1:  		/* rlwinm R3, R11, 30, 30, 31 */
		/* 82266EE8h case    1:*/		cpu::op::rlwinm<0,30,30,31>(regs,&regs.R3,regs.R11);
		/* 82266EE8h case    1:*/		return 0x82266EEC;
		  /* 82266EECh */ case    2:  		/* bclr 20, CR0_LT */
		/* 82266EECh case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82266EECh case    2:*/		return 0x82266EF0;
	}
	return 0x82266EF0;
} // Block from 82266EE4h-82266EF0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82266EF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266EF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266EF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266EF0);
		  /* 82266EF0h */ case    0:  		/* lwz R11, <#[R3 + 4]> */
		/* 82266EF0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82266EF0h case    0:*/		return 0x82266EF4;
		  /* 82266EF4h */ case    1:  		/* rlwinm R3, R11, 0, 30, 31 */
		/* 82266EF4h case    1:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R3,regs.R11);
		/* 82266EF4h case    1:*/		return 0x82266EF8;
		  /* 82266EF8h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82266EF8h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82266EF8h case    2:*/		return 0x82266EFC;
	}
	return 0x82266EFC;
} // Block from 82266EF0h-82266EFCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 82266EFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266EFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266EFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266EFC);
		  /* 82266EFCh */ case    0:  		/* li R3, 1 */
		/* 82266EFCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82266EFCh case    0:*/		return 0x82266F00;
		  /* 82266F00h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82266F00h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82266F00h case    1:*/		return 0x82266F04;
	}
	return 0x82266F04;
} // Block from 82266EFCh-82266F04h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82266F04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266F04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266F04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266F04);
		  /* 82266F04h */ case    0:  		/* nop */
		/* 82266F04h case    0:*/		cpu::op::nop();
		/* 82266F04h case    0:*/		return 0x82266F08;
	}
	return 0x82266F08;
} // Block from 82266F04h-82266F08h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82266F08h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266F08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266F08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266F08);
		  /* 82266F08h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82266F08h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82266F08h case    0:*/		return 0x82266F0C;
		  /* 82266F0Ch */ case    1:  		/* cmplwi CR6, R4, 1 */
		/* 82266F0Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000001);
		/* 82266F0Ch case    1:*/		return 0x82266F10;
		  /* 82266F10h */ case    2:  		/* rlwinm. R11, R11, 0, 9, 9 */
		/* 82266F10h case    2:*/		cpu::op::rlwinm<1,0,9,9>(regs,&regs.R11,regs.R11);
		/* 82266F10h case    2:*/		return 0x82266F14;
		  /* 82266F14h */ case    3:  		/* bc 12, CR0_EQ, 76 */
		/* 82266F14h case    3:*/		if ( regs.CR[0].eq ) { return 0x82266F60;  }
		/* 82266F14h case    3:*/		return 0x82266F18;
		  /* 82266F18h */ case    4:  		/* bc 12, CR6_LT, 60 */
		/* 82266F18h case    4:*/		if ( regs.CR[6].lt ) { return 0x82266F54;  }
		/* 82266F18h case    4:*/		return 0x82266F1C;
		  /* 82266F1Ch */ case    5:  		/* cmplwi CR6, R4, 1 */
		/* 82266F1Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000001);
		/* 82266F1Ch case    5:*/		return 0x82266F20;
		  /* 82266F20h */ case    6:  		/* bc 12, CR6_EQ, 40 */
		/* 82266F20h case    6:*/		if ( regs.CR[6].eq ) { return 0x82266F48;  }
		/* 82266F20h case    6:*/		return 0x82266F24;
		  /* 82266F24h */ case    7:  		/* cmplwi CR6, R4, 3 */
		/* 82266F24h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000003);
		/* 82266F24h case    7:*/		return 0x82266F28;
		  /* 82266F28h */ case    8:  		/* bc 12, CR6_LT, 20 */
		/* 82266F28h case    8:*/		if ( regs.CR[6].lt ) { return 0x82266F3C;  }
		/* 82266F28h case    8:*/		return 0x82266F2C;
		  /* 82266F2Ch */ case    9:  		/* bc 4, CR6_EQ, 76 */
		/* 82266F2Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x82266F78;  }
		/* 82266F2Ch case    9:*/		return 0x82266F30;
		  /* 82266F30h */ case   10:  		/* lwz R11, <#[R3 + 4]> */
		/* 82266F30h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82266F30h case   10:*/		return 0x82266F34;
		  /* 82266F34h */ case   11:  		/* rlwinm R3, R11, 20, 29, 31 */
		/* 82266F34h case   11:*/		cpu::op::rlwinm<0,20,29,31>(regs,&regs.R3,regs.R11);
		/* 82266F34h case   11:*/		return 0x82266F38;
		  /* 82266F38h */ case   12:  		/* bclr 20, CR0_LT */
		/* 82266F38h case   12:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82266F38h case   12:*/		return 0x82266F3C;
	}
	return 0x82266F3C;
} // Block from 82266F08h-82266F3Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 82266F3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266F3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266F3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266F3C);
		  /* 82266F3Ch */ case    0:  		/* lwz R11, <#[R3 + 4]> */
		/* 82266F3Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82266F3Ch case    0:*/		return 0x82266F40;
		  /* 82266F40h */ case    1:  		/* rlwinm R3, R11, 24, 29, 31 */
		/* 82266F40h case    1:*/		cpu::op::rlwinm<0,24,29,31>(regs,&regs.R3,regs.R11);
		/* 82266F40h case    1:*/		return 0x82266F44;
		  /* 82266F44h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82266F44h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82266F44h case    2:*/		return 0x82266F48;
	}
	return 0x82266F48;
} // Block from 82266F3Ch-82266F48h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82266F48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266F48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266F48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266F48);
		  /* 82266F48h */ case    0:  		/* lwz R11, <#[R3 + 4]> */
		/* 82266F48h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82266F48h case    0:*/		return 0x82266F4C;
		  /* 82266F4Ch */ case    1:  		/* rlwinm R3, R11, 28, 29, 31 */
		/* 82266F4Ch case    1:*/		cpu::op::rlwinm<0,28,29,31>(regs,&regs.R3,regs.R11);
		/* 82266F4Ch case    1:*/		return 0x82266F50;
		  /* 82266F50h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82266F50h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82266F50h case    2:*/		return 0x82266F54;
	}
	return 0x82266F54;
} // Block from 82266F48h-82266F54h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82266F54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266F54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266F54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266F54);
		  /* 82266F54h */ case    0:  		/* lwz R11, <#[R3 + 4]> */
		/* 82266F54h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82266F54h case    0:*/		return 0x82266F58;
	}
	return 0x82266F58;
} // Block from 82266F54h-82266F58h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82266F58h
// Function '?Apply@R400SlotModel@XGRAPHICS@@UAAXPBVIRInst@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266F58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266F58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266F58);
		  /* 82266F58h */ case    0:  		/* rlwinm R3, R11, 0, 29, 31 */
		/* 82266F58h case    0:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R3,regs.R11);
		/* 82266F58h case    0:*/		return 0x82266F5C;
		  /* 82266F5Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 82266F5Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82266F5Ch case    1:*/		return 0x82266F60;
	}
	return 0x82266F60;
} // Block from 82266F58h-82266F60h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82266F60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266F60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266F60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266F60);
		  /* 82266F60h */ case    0:  		/* bc 12, CR6_LT, 56 */
		/* 82266F60h case    0:*/		if ( regs.CR[6].lt ) { return 0x82266F98;  }
		/* 82266F60h case    0:*/		return 0x82266F64;
		  /* 82266F64h */ case    1:  		/* cmplwi CR6, R4, 1 */
		/* 82266F64h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000001);
		/* 82266F64h case    1:*/		return 0x82266F68;
		  /* 82266F68h */ case    2:  		/* bc 12, CR6_EQ, 40 */
		/* 82266F68h case    2:*/		if ( regs.CR[6].eq ) { return 0x82266F90;  }
		/* 82266F68h case    2:*/		return 0x82266F6C;
		  /* 82266F6Ch */ case    3:  		/* cmplwi CR6, R4, 3 */
		/* 82266F6Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000003);
		/* 82266F6Ch case    3:*/		return 0x82266F70;
		  /* 82266F70h */ case    4:  		/* bc 12, CR6_LT, 24 */
		/* 82266F70h case    4:*/		if ( regs.CR[6].lt ) { return 0x82266F88;  }
		/* 82266F70h case    4:*/		return 0x82266F74;
		  /* 82266F74h */ case    5:  		/* bc 12, CR6_EQ, 12 */
		/* 82266F74h case    5:*/		if ( regs.CR[6].eq ) { return 0x82266F80;  }
		/* 82266F74h case    5:*/		return 0x82266F78;
	}
	return 0x82266F78;
} // Block from 82266F60h-82266F78h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82266F78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266F78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266F78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266F78);
		  /* 82266F78h */ case    0:  		/* li R3, -1 */
		/* 82266F78h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 82266F78h case    0:*/		return 0x82266F7C;
		  /* 82266F7Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 82266F7Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82266F7Ch case    1:*/		return 0x82266F80;
	}
	return 0x82266F80;
} // Block from 82266F78h-82266F80h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82266F80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266F80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266F80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266F80);
		  /* 82266F80h */ case    0:  		/* li R3, 3 */
		/* 82266F80h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x3);
		/* 82266F80h case    0:*/		return 0x82266F84;
		  /* 82266F84h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82266F84h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82266F84h case    1:*/		return 0x82266F88;
	}
	return 0x82266F88;
} // Block from 82266F80h-82266F88h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82266F88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266F88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266F88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266F88);
		  /* 82266F88h */ case    0:  		/* li R3, 2 */
		/* 82266F88h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x2);
		/* 82266F88h case    0:*/		return 0x82266F8C;
		  /* 82266F8Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 82266F8Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82266F8Ch case    1:*/		return 0x82266F90;
	}
	return 0x82266F90;
} // Block from 82266F88h-82266F90h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82266F90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266F90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266F90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266F90);
		  /* 82266F90h */ case    0:  		/* li R3, 1 */
		/* 82266F90h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82266F90h case    0:*/		return 0x82266F94;
		  /* 82266F94h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82266F94h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82266F94h case    1:*/		return 0x82266F98;
	}
	return 0x82266F98;
} // Block from 82266F90h-82266F98h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82266F98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266F98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266F98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266F98);
		  /* 82266F98h */ case    0:  		/* li R3, 0 */
		/* 82266F98h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82266F98h case    0:*/		return 0x82266F9C;
		  /* 82266F9Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 82266F9Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82266F9Ch case    1:*/		return 0x82266FA0;
	}
	return 0x82266FA0;
} // Block from 82266F98h-82266FA0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82266FA0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266FA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266FA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266FA0);
		  /* 82266FA0h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 82266FA0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82266FA0h case    0:*/		return 0x82266FA4;
		  /* 82266FA4h */ case    1:  		/* rlwinm. R11, R11, 0, 9, 9 */
		/* 82266FA4h case    1:*/		cpu::op::rlwinm<1,0,9,9>(regs,&regs.R11,regs.R11);
		/* 82266FA4h case    1:*/		return 0x82266FA8;
		  /* 82266FA8h */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 82266FA8h case    2:*/		if ( regs.CR[0].eq ) { return 0x82266FB8;  }
		/* 82266FA8h case    2:*/		return 0x82266FAC;
		  /* 82266FACh */ case    3:  		/* lwz R11, <#[R3 + 4]> */
		/* 82266FACh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 82266FACh case    3:*/		return 0x82266FB0;
		  /* 82266FB0h */ case    4:  		/* andi. R3, R11, 34952 */
		/* 82266FB0h case    4:*/		cpu::op::andi<1>(regs,&regs.R3,regs.R11,0x8888);
		/* 82266FB0h case    4:*/		return 0x82266FB4;
		  /* 82266FB4h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82266FB4h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82266FB4h case    5:*/		return 0x82266FB8;
	}
	return 0x82266FB8;
} // Block from 82266FA0h-82266FB8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82266FB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266FB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266FB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266FB8);
		  /* 82266FB8h */ case    0:  		/* li R3, 0 */
		/* 82266FB8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82266FB8h case    0:*/		return 0x82266FBC;
		  /* 82266FBCh */ case    1:  		/* bclr 20, CR0_LT */
		/* 82266FBCh case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82266FBCh case    1:*/		return 0x82266FC0;
	}
	return 0x82266FC0;
} // Block from 82266FB8h-82266FC0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82266FC0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82266FC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82266FC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82266FC0);
		  /* 82266FC0h */ case    0:  		/* mfspr R12, LR */
		/* 82266FC0h case    0:*/		regs.R12 = regs.LR;
		/* 82266FC0h case    0:*/		return 0x82266FC4;
		  /* 82266FC4h */ case    1:  		/* bl -1924464 */
		/* 82266FC4h case    1:*/		regs.LR = 0x82266FC8; return 0x82091254;
		/* 82266FC4h case    1:*/		return 0x82266FC8;
		  /* 82266FC8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82266FC8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82266FC8h case    2:*/		return 0x82266FCC;
		  /* 82266FCCh */ case    3:  		/* lwz R11, <#[R3]> */
		/* 82266FCCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82266FCCh case    3:*/		return 0x82266FD0;
		  /* 82266FD0h */ case    4:  		/* mr R28, R3 */
		/* 82266FD0h case    4:*/		regs.R28 = regs.R3;
		/* 82266FD0h case    4:*/		return 0x82266FD4;
		  /* 82266FD4h */ case    5:  		/* rlwinm. R11, R11, 0, 9, 9 */
		/* 82266FD4h case    5:*/		cpu::op::rlwinm<1,0,9,9>(regs,&regs.R11,regs.R11);
		/* 82266FD4h case    5:*/		return 0x82266FD8;
		  /* 82266FD8h */ case    6:  		/* bc 12, CR0_EQ, 156 */
		/* 82266FD8h case    6:*/		if ( regs.CR[0].eq ) { return 0x82267074;  }
		/* 82266FD8h case    6:*/		return 0x82266FDC;
		  /* 82266FDCh */ case    7:  		/* lis R9, -32253 */
		/* 82266FDCh case    7:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 82266FDCh case    7:*/		return 0x82266FE0;
		  /* 82266FE0h */ case    8:  		/* lis R10, -32255 */
		/* 82266FE0h case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 82266FE0h case    8:*/		return 0x82266FE4;
		  /* 82266FE4h */ case    9:  		/* lis R11, -32251 */
		/* 82266FE4h case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82266FE4h case    9:*/		return 0x82266FE8;
		  /* 82266FE8h */ case   10:  		/* li R27, 0 */
		/* 82266FE8h case   10:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 82266FE8h case   10:*/		return 0x82266FEC;
		  /* 82266FECh */ case   11:  		/* addi R31, R9, 27460 */
		/* 82266FECh case   11:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R9,0x6B44);
		/* 82266FECh case   11:*/		return 0x82266FF0;
		  /* 82266FF0h */ case   12:  		/* addi R30, R10, 5216 */
		/* 82266FF0h case   12:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R10,0x1460);
		/* 82266FF0h case   12:*/		return 0x82266FF4;
		  /* 82266FF4h */ case   13:  		/* addi R29, R11, -17400 */
		/* 82266FF4h case   13:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0xFFFFBC08);
		/* 82266FF4h case   13:*/		return 0x82266FF8;
		  /* 82266FF8h */ case   14:  		/* cmplwi CR6, R27, 1 */
		/* 82266FF8h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000001);
		/* 82266FF8h case   14:*/		return 0x82266FFC;
		  /* 82266FFCh */ case   15:  		/* bc 12, CR6_LT, 84 */
		/* 82266FFCh case   15:*/		if ( regs.CR[6].lt ) { return 0x82267050;  }
		/* 82266FFCh case   15:*/		return 0x82267000;
		  /* 82267000h */ case   16:  		/* bc 12, CR6_EQ, 68 */
		/* 82267000h case   16:*/		if ( regs.CR[6].eq ) { return 0x82267044;  }
		/* 82267000h case   16:*/		return 0x82267004;
		  /* 82267004h */ case   17:  		/* cmplwi CR6, R27, 3 */
		/* 82267004h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000003);
		/* 82267004h case   17:*/		return 0x82267008;
		  /* 82267008h */ case   18:  		/* bc 12, CR6_LT, 48 */
		/* 82267008h case   18:*/		if ( regs.CR[6].lt ) { return 0x82267038;  }
		/* 82267008h case   18:*/		return 0x8226700C;
		  /* 8226700Ch */ case   19:  		/* bc 12, CR6_EQ, 32 */
		/* 8226700Ch case   19:*/		if ( regs.CR[6].eq ) { return 0x8226702C;  }
		/* 8226700Ch case   19:*/		return 0x82267010;
		  /* 82267010h */ case   20:  		/* mr R6, R29 */
		/* 82267010h case   20:*/		regs.R6 = regs.R29;
		/* 82267010h case   20:*/		return 0x82267014;
		  /* 82267014h */ case   21:  		/* mr R5, R30 */
		/* 82267014h case   21:*/		regs.R5 = regs.R30;
		/* 82267014h case   21:*/		return 0x82267018;
		  /* 82267018h */ case   22:  		/* mr R4, R31 */
		/* 82267018h case   22:*/		regs.R4 = regs.R31;
		/* 82267018h case   22:*/		return 0x8226701C;
		  /* 8226701Ch */ case   23:  		/* li R7, 166 */
		/* 8226701Ch case   23:*/		cpu::op::li<0>(regs,&regs.R7,0xA6);
		/* 8226701Ch case   23:*/		return 0x82267020;
		  /* 82267020h */ case   24:  		/* li R3, 0 */
		/* 82267020h case   24:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82267020h case   24:*/		return 0x82267024;
		  /* 82267024h */ case   25:  		/* bl -1111068 */
		/* 82267024h case   25:*/		regs.LR = 0x82267028; return 0x82157C08;
		/* 82267024h case   25:*/		return 0x82267028;
		  /* 82267028h */ case   26:  		/* b 64 */
		/* 82267028h case   26:*/		return 0x82267068;
		/* 82267028h case   26:*/		return 0x8226702C;
	}
	return 0x8226702C;
} // Block from 82266FC0h-8226702Ch (27 instructions)

//////////////////////////////////////////////////////
// Block at 8226702Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226702C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226702C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226702C);
		  /* 8226702Ch */ case    0:  		/* lwz R11, <#[R28 + 4]> */
		/* 8226702Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 8226702Ch case    0:*/		return 0x82267030;
		  /* 82267030h */ case    1:  		/* rlwinm R11, R11, 26, 30, 31 */
		/* 82267030h case    1:*/		cpu::op::rlwinm<0,26,30,31>(regs,&regs.R11,regs.R11);
		/* 82267030h case    1:*/		return 0x82267034;
		  /* 82267034h */ case    2:  		/* b 36 */
		/* 82267034h case    2:*/		return 0x82267058;
		/* 82267034h case    2:*/		return 0x82267038;
	}
	return 0x82267038;
} // Block from 8226702Ch-82267038h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82267038h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267038( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267038) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267038);
		  /* 82267038h */ case    0:  		/* lwz R11, <#[R28 + 4]> */
		/* 82267038h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 82267038h case    0:*/		return 0x8226703C;
		  /* 8226703Ch */ case    1:  		/* rlwinm R11, R11, 28, 30, 31 */
		/* 8226703Ch case    1:*/		cpu::op::rlwinm<0,28,30,31>(regs,&regs.R11,regs.R11);
		/* 8226703Ch case    1:*/		return 0x82267040;
	}
	return 0x82267040;
} // Block from 82267038h-82267040h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82267040h
// Function '?InstConstantState@R400ConstantModel@XGRAPHICS@@SA?AW4R400ConstantState@12@PBVIRInst@2@AA_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267040( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267040) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267040);
		  /* 82267040h */ case    0:  		/* b 24 */
		/* 82267040h case    0:*/		return 0x82267058;
		/* 82267040h case    0:*/		return 0x82267044;
	}
	return 0x82267044;
} // Block from 82267040h-82267044h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82267044h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267044( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267044) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267044);
		  /* 82267044h */ case    0:  		/* lwz R11, <#[R28 + 4]> */
		/* 82267044h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 82267044h case    0:*/		return 0x82267048;
		  /* 82267048h */ case    1:  		/* rlwinm R11, R11, 30, 30, 31 */
		/* 82267048h case    1:*/		cpu::op::rlwinm<0,30,30,31>(regs,&regs.R11,regs.R11);
		/* 82267048h case    1:*/		return 0x8226704C;
		  /* 8226704Ch */ case    2:  		/* b 12 */
		/* 8226704Ch case    2:*/		return 0x82267058;
		/* 8226704Ch case    2:*/		return 0x82267050;
	}
	return 0x82267050;
} // Block from 82267044h-82267050h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82267050h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267050( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267050) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267050);
		  /* 82267050h */ case    0:  		/* lwz R11, <#[R28 + 4]> */
		/* 82267050h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 82267050h case    0:*/		return 0x82267054;
		  /* 82267054h */ case    1:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 82267054h case    1:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 82267054h case    1:*/		return 0x82267058;
	}
	return 0x82267058;
} // Block from 82267050h-82267058h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82267058h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267058( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267058) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267058);
		  /* 82267058h */ case    0:  		/* cmplwi CR6, R11, 2 */
		/* 82267058h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 82267058h case    0:*/		return 0x8226705C;
		  /* 8226705Ch */ case    1:  		/* bc 12, CR6_EQ, 36 */
		/* 8226705Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x82267080;  }
		/* 8226705Ch case    1:*/		return 0x82267060;
		  /* 82267060h */ case    2:  		/* cmplwi CR6, R11, 3 */
		/* 82267060h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 82267060h case    2:*/		return 0x82267064;
		  /* 82267064h */ case    3:  		/* bc 12, CR6_EQ, 28 */
		/* 82267064h case    3:*/		if ( regs.CR[6].eq ) { return 0x82267080;  }
		/* 82267064h case    3:*/		return 0x82267068;
	}
	return 0x82267068;
} // Block from 82267058h-82267068h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82267068h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267068( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267068) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267068);
		  /* 82267068h */ case    0:  		/* addi R27, R27, 1 */
		/* 82267068h case    0:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 82267068h case    0:*/		return 0x8226706C;
		  /* 8226706Ch */ case    1:  		/* cmpwi CR6, R27, 4 */
		/* 8226706Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000004);
		/* 8226706Ch case    1:*/		return 0x82267070;
		  /* 82267070h */ case    2:  		/* bc 12, CR6_LT, -120 */
		/* 82267070h case    2:*/		if ( regs.CR[6].lt ) { return 0x82266FF8;  }
		/* 82267070h case    2:*/		return 0x82267074;
	}
	return 0x82267074;
} // Block from 82267068h-82267074h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82267074h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267074( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267074) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267074);
		  /* 82267074h */ case    0:  		/* li R3, 0 */
		/* 82267074h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82267074h case    0:*/		return 0x82267078;
		  /* 82267078h */ case    1:  		/* addi R1, R1, 128 */
		/* 82267078h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82267078h case    1:*/		return 0x8226707C;
		  /* 8226707Ch */ case    2:  		/* b -1924568 */
		/* 8226707Ch case    2:*/		return 0x820912A4;
		/* 8226707Ch case    2:*/		return 0x82267080;
	}
	return 0x82267080;
} // Block from 82267074h-82267080h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82267080h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267080( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267080) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267080);
		  /* 82267080h */ case    0:  		/* li R3, 1 */
		/* 82267080h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82267080h case    0:*/		return 0x82267084;
		  /* 82267084h */ case    1:  		/* b -12 */
		/* 82267084h case    1:*/		return 0x82267078;
		/* 82267084h case    1:*/		return 0x82267088;
	}
	return 0x82267088;
} // Block from 82267080h-82267088h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82267088h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267088( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267088) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267088);
		  /* 82267088h */ case    0:  		/* mfspr R12, LR */
		/* 82267088h case    0:*/		regs.R12 = regs.LR;
		/* 82267088h case    0:*/		return 0x8226708C;
		  /* 8226708Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8226708Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8226708Ch case    1:*/		return 0x82267090;
		  /* 82267090h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82267090h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82267090h case    2:*/		return 0x82267094;
		  /* 82267094h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82267094h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82267094h case    3:*/		return 0x82267098;
		  /* 82267098h */ case    4:  		/* addi R11, R4, 7 */
		/* 82267098h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x7);
		/* 82267098h case    4:*/		return 0x8226709C;
		  /* 8226709Ch */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8226709Ch case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8226709Ch case    5:*/		return 0x822670A0;
		  /* 822670A0h */ case    6:  		/* lwzx R31, <#[R11 + R3]> */
		/* 822670A0h case    6:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 822670A0h case    6:*/		return 0x822670A4;
		  /* 822670A4h */ case    7:  		/* mr R3, R31 */
		/* 822670A4h case    7:*/		regs.R3 = regs.R31;
		/* 822670A4h case    7:*/		return 0x822670A8;
		  /* 822670A8h */ case    8:  		/* lwz R11, <#[R31]> */
		/* 822670A8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822670A8h case    8:*/		return 0x822670AC;
		  /* 822670ACh */ case    9:  		/* lwz R11, <#[R11 + 16]> */
		/* 822670ACh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 822670ACh case    9:*/		return 0x822670B0;
		  /* 822670B0h */ case   10:  		/* mtspr CTR, R11 */
		/* 822670B0h case   10:*/		regs.CTR = regs.R11;
		/* 822670B0h case   10:*/		return 0x822670B4;
		  /* 822670B4h */ case   11:  		/* bcctrl 20, CR0_LT */
		/* 822670B4h case   11:*/		if ( 1 ) { regs.LR = 0x822670B8; return (uint32)regs.CTR; }
		/* 822670B4h case   11:*/		return 0x822670B8;
		  /* 822670B8h */ case   12:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 822670B8h case   12:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 822670B8h case   12:*/		return 0x822670BC;
		  /* 822670BCh */ case   13:  		/* bc 12, CR0_EQ, 12 */
		/* 822670BCh case   13:*/		if ( regs.CR[0].eq ) { return 0x822670C8;  }
		/* 822670BCh case   13:*/		return 0x822670C0;
		  /* 822670C0h */ case   14:  		/* lwz R3, <#[R31 + 48]> */
		/* 822670C0h case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 822670C0h case   14:*/		return 0x822670C4;
		  /* 822670C4h */ case   15:  		/* b 8 */
		/* 822670C4h case   15:*/		return 0x822670CC;
		/* 822670C4h case   15:*/		return 0x822670C8;
	}
	return 0x822670C8;
} // Block from 82267088h-822670C8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 822670C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822670C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822670C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822670C8);
		  /* 822670C8h */ case    0:  		/* li R3, -1 */
		/* 822670C8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 822670C8h case    0:*/		return 0x822670CC;
	}
	return 0x822670CC;
} // Block from 822670C8h-822670CCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 822670CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822670CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822670CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822670CC);
		  /* 822670CCh */ case    0:  		/* addi R1, R1, 96 */
		/* 822670CCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 822670CCh case    0:*/		return 0x822670D0;
		  /* 822670D0h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 822670D0h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822670D0h case    1:*/		return 0x822670D4;
		  /* 822670D4h */ case    2:  		/* mtspr LR, R12 */
		/* 822670D4h case    2:*/		regs.LR = regs.R12;
		/* 822670D4h case    2:*/		return 0x822670D8;
		  /* 822670D8h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 822670D8h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822670D8h case    3:*/		return 0x822670DC;
		  /* 822670DCh */ case    4:  		/* bclr 20, CR0_LT */
		/* 822670DCh case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822670DCh case    4:*/		return 0x822670E0;
	}
	return 0x822670E0;
} // Block from 822670CCh-822670E0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822670E0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822670E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822670E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822670E0);
		  /* 822670E0h */ case    0:  		/* mfspr R12, LR */
		/* 822670E0h case    0:*/		regs.R12 = regs.LR;
		/* 822670E0h case    0:*/		return 0x822670E4;
		  /* 822670E4h */ case    1:  		/* bl -1924748 */
		/* 822670E4h case    1:*/		regs.LR = 0x822670E8; return 0x82091258;
		/* 822670E4h case    1:*/		return 0x822670E8;
		  /* 822670E8h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 822670E8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 822670E8h case    2:*/		return 0x822670EC;
		  /* 822670ECh */ case    3:  		/* mr R30, R3 */
		/* 822670ECh case    3:*/		regs.R30 = regs.R3;
		/* 822670ECh case    3:*/		return 0x822670F0;
		  /* 822670F0h */ case    4:  		/* mr R8, R4 */
		/* 822670F0h case    4:*/		regs.R8 = regs.R4;
		/* 822670F0h case    4:*/		return 0x822670F4;
		  /* 822670F4h */ case    5:  		/* mr R9, R5 */
		/* 822670F4h case    5:*/		regs.R9 = regs.R5;
		/* 822670F4h case    5:*/		return 0x822670F8;
		  /* 822670F8h */ case    6:  		/* mr R29, R6 */
		/* 822670F8h case    6:*/		regs.R29 = regs.R6;
		/* 822670F8h case    6:*/		return 0x822670FC;
		  /* 822670FCh */ case    7:  		/* mr R31, R7 */
		/* 822670FCh case    7:*/		regs.R31 = regs.R7;
		/* 822670FCh case    7:*/		return 0x82267100;
		  /* 82267100h */ case    8:  		/* li R28, 0 */
		/* 82267100h case    8:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 82267100h case    8:*/		return 0x82267104;
		  /* 82267104h */ case    9:  		/* cmplwi CR6, R6, 0 */
		/* 82267104h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 82267104h case    9:*/		return 0x82267108;
		  /* 82267108h */ case   10:  		/* bc 12, CR6_EQ, 8 */
		/* 82267108h case   10:*/		if ( regs.CR[6].eq ) { return 0x82267110;  }
		/* 82267108h case   10:*/		return 0x8226710C;
		  /* 8226710Ch */ case   11:  		/* stw R28, <#[R6]> */
		/* 8226710Ch case   11:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R6 + 0x00000000) );
		/* 8226710Ch case   11:*/		return 0x82267110;
	}
	return 0x82267110;
} // Block from 822670E0h-82267110h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82267110h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267110( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267110) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267110);
		  /* 82267110h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 82267110h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82267110h case    0:*/		return 0x82267114;
		  /* 82267114h */ case    1:  		/* lis R11, -32217 */
		/* 82267114h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82267114h case    1:*/		return 0x82267118;
		  /* 82267118h */ case    2:  		/* mr R3, R30 */
		/* 82267118h case    2:*/		regs.R3 = regs.R30;
		/* 82267118h case    2:*/		return 0x8226711C;
		  /* 8226711Ch */ case    3:  		/* bc 12, CR6_EQ, 152 */
		/* 8226711Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x822671B4;  }
		/* 8226711Ch case    3:*/		return 0x82267120;
		  /* 82267120h */ case    4:  		/* li R6, 259 */
		/* 82267120h case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x103);
		/* 82267120h case    4:*/		return 0x82267124;
		  /* 82267124h */ case    5:  		/* lwz R7, <#[R31 + 8]> */
		/* 82267124h case    5:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000008) );
		/* 82267124h case    5:*/		return 0x82267128;
		  /* 82267128h */ case    6:  		/* lwz R5, <#[R31 + 12]> */
		/* 82267128h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000000C) );
		/* 82267128h case    6:*/		return 0x8226712C;
		  /* 8226712Ch */ case    7:  		/* addi R10, R1, 88 */
		/* 8226712Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x58);
		/* 8226712Ch case    7:*/		return 0x82267130;
		  /* 82267130h */ case    8:  		/* stw R6, <#[R31]> */
		/* 82267130h case    8:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R31 + 0x00000000) );
		/* 82267130h case    8:*/		return 0x82267134;
		  /* 82267134h */ case    9:  		/* lwz R11, <#[R11 + 6896]> */
		/* 82267134h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00001AF0) );
		/* 82267134h case    9:*/		return 0x82267138;
		  /* 82267138h */ case   10:  		/* lwz R4, <#[R31 + 16]> */
		/* 82267138h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000010) );
		/* 82267138h case   10:*/		return 0x8226713C;
		  /* 8226713Ch */ case   11:  		/* stw R7, <#[R1 + 92]> */
		/* 8226713Ch case   11:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x0000005C) );
		/* 8226713Ch case   11:*/		return 0x82267140;
		  /* 82267140h */ case   12:  		/* stw R5, <#[R1 + 88]> */
		/* 82267140h case   12:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x00000058) );
		/* 82267140h case   12:*/		return 0x82267144;
		  /* 82267144h */ case   13:  		/* rlwinm R6, R4, 0, 31, 31 */
		/* 82267144h case   13:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R6,regs.R4);
		/* 82267144h case   13:*/		return 0x82267148;
		  /* 82267148h */ case   14:  		/* li R5, 0 */
		/* 82267148h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82267148h case   14:*/		return 0x8226714C;
		  /* 8226714Ch */ case   15:  		/* addic R7, R6, -1 */
		/* 8226714Ch case   15:*/		cpu::op::addic<0>(regs,&regs.R7,regs.R6,0xFFFFFFFF);
		/* 8226714Ch case   15:*/		return 0x82267150;
		  /* 82267150h */ case   16:  		/* mr R7, R31 */
		/* 82267150h case   16:*/		regs.R7 = regs.R31;
		/* 82267150h case   16:*/		return 0x82267154;
		  /* 82267154h */ case   17:  		/* subfe R6, R6, R6 */
		/* 82267154h case   17:*/		cpu::op::subfe<0>(regs,&regs.R6,regs.R6,regs.R6);
		/* 82267154h case   17:*/		return 0x82267158;
		  /* 82267158h */ case   18:  		/* and R6, R6, R31 */
		/* 82267158h case   18:*/		cpu::op::and<0>(regs,&regs.R6,regs.R6,regs.R31);
		/* 82267158h case   18:*/		return 0x8226715C;
		  /* 8226715Ch */ case   19:  		/* lwz R11, <#[R11 + 16]> */
		/* 8226715Ch case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 8226715Ch case   19:*/		return 0x82267160;
		  /* 82267160h */ case   20:  		/* mtspr CTR, R11 */
		/* 82267160h case   20:*/		regs.CTR = regs.R11;
		/* 82267160h case   20:*/		return 0x82267164;
		  /* 82267164h */ case   21:  		/* bcctrl 20, CR0_LT */
		/* 82267164h case   21:*/		if ( 1 ) { regs.LR = 0x82267168; return (uint32)regs.CTR; }
		/* 82267164h case   21:*/		return 0x82267168;
		  /* 82267168h */ case   22:  		/* cmpwi CR0, R3, 0 */
		/* 82267168h case   22:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82267168h case   22:*/		return 0x8226716C;
		  /* 8226716Ch */ case   23:  		/* bc 12, CR0_LT, 36 */
		/* 8226716Ch case   23:*/		if ( regs.CR[0].lt ) { return 0x82267190;  }
		/* 8226716Ch case   23:*/		return 0x82267170;
		  /* 82267170h */ case   24:  		/* cmpwi CR6, R3, 259 */
		/* 82267170h case   24:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000103);
		/* 82267170h case   24:*/		return 0x82267174;
		  /* 82267174h */ case   25:  		/* bc 12, CR6_EQ, 28 */
		/* 82267174h case   25:*/		if ( regs.CR[6].eq ) { return 0x82267190;  }
		/* 82267174h case   25:*/		return 0x82267178;
		  /* 82267178h */ case   26:  		/* cmplwi CR6, R29, 0 */
		/* 82267178h case   26:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82267178h case   26:*/		return 0x8226717C;
		  /* 8226717Ch */ case   27:  		/* bc 12, CR6_EQ, 12 */
		/* 8226717Ch case   27:*/		if ( regs.CR[6].eq ) { return 0x82267188;  }
		/* 8226717Ch case   27:*/		return 0x82267180;
		  /* 82267180h */ case   28:  		/* lwz R11, <#[R31 + 4]> */
		/* 82267180h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 82267180h case   28:*/		return 0x82267184;
		  /* 82267184h */ case   29:  		/* stw R11, <#[R29]> */
		/* 82267184h case   29:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82267184h case   29:*/		return 0x82267188;
	}
	return 0x82267188;
} // Block from 82267110h-82267188h (30 instructions)

//////////////////////////////////////////////////////
// Block at 82267188h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267188( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267188) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267188);
		  /* 82267188h */ case    0:  		/* li R3, 1 */
		/* 82267188h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82267188h case    0:*/		return 0x8226718C;
		  /* 8226718Ch */ case    1:  		/* b 200 */
		/* 8226718Ch case    1:*/		return 0x82267254;
		/* 8226718Ch case    1:*/		return 0x82267190;
	}
	return 0x82267190;
} // Block from 82267188h-82267190h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82267190h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267190( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267190) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267190);
		  /* 82267190h */ case    0:  		/* lis R11, -16384 */
		/* 82267190h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFFC000);
		/* 82267190h case    0:*/		return 0x82267194;
		  /* 82267194h */ case    1:  		/* ori R11, R11, 17 */
		/* 82267194h case    1:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x11);
		/* 82267194h case    1:*/		return 0x82267198;
		  /* 82267198h */ case    2:  		/* cmpw CR6, R3, R11 */
		/* 82267198h case    2:*/		cpu::op::cmpw<6>(regs,regs.R3,regs.R11);
		/* 82267198h case    2:*/		return 0x8226719C;
		  /* 8226719Ch */ case    3:  		/* bc 4, CR6_EQ, 176 */
		/* 8226719Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x8226724C;  }
		/* 8226719Ch case    3:*/		return 0x822671A0;
		  /* 822671A0h */ case    4:  		/* cmplwi CR6, R29, 0 */
		/* 822671A0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 822671A0h case    4:*/		return 0x822671A4;
		  /* 822671A4h */ case    5:  		/* bc 12, CR6_EQ, 8 */
		/* 822671A4h case    5:*/		if ( regs.CR[6].eq ) { return 0x822671AC;  }
		/* 822671A4h case    5:*/		return 0x822671A8;
		  /* 822671A8h */ case    6:  		/* stw R28, <#[R29]> */
		/* 822671A8h case    6:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R29 + 0x00000000) );
		/* 822671A8h case    6:*/		return 0x822671AC;
	}
	return 0x822671AC;
} // Block from 82267190h-822671ACh (7 instructions)

//////////////////////////////////////////////////////
// Block at 822671ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822671AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822671AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822671AC);
		  /* 822671ACh */ case    0:  		/* mr R3, R11 */
		/* 822671ACh case    0:*/		regs.R3 = regs.R11;
		/* 822671ACh case    0:*/		return 0x822671B0;
		  /* 822671B0h */ case    1:  		/* b 156 */
		/* 822671B0h case    1:*/		return 0x8226724C;
		/* 822671B0h case    1:*/		return 0x822671B4;
	}
	return 0x822671B4;
} // Block from 822671ACh-822671B4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822671B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822671B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822671B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822671B4);
		  /* 822671B4h */ case    0:  		/* lwz R11, <#[R11 + 6896]> */
		/* 822671B4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00001AF0) );
		/* 822671B4h case    0:*/		return 0x822671B8;
		  /* 822671B8h */ case    1:  		/* li R10, 0 */
		/* 822671B8h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 822671B8h case    1:*/		return 0x822671BC;
		  /* 822671BCh */ case    2:  		/* addi R7, R1, 80 */
		/* 822671BCh case    2:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 822671BCh case    2:*/		return 0x822671C0;
		  /* 822671C0h */ case    3:  		/* li R6, 0 */
		/* 822671C0h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 822671C0h case    3:*/		return 0x822671C4;
		  /* 822671C4h */ case    4:  		/* li R5, 0 */
		/* 822671C4h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 822671C4h case    4:*/		return 0x822671C8;
		  /* 822671C8h */ case    5:  		/* li R4, 0 */
		/* 822671C8h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 822671C8h case    5:*/		return 0x822671CC;
		  /* 822671CCh */ case    6:  		/* lwz R11, <#[R11 + 16]> */
		/* 822671CCh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000010) );
		/* 822671CCh case    6:*/		return 0x822671D0;
		  /* 822671D0h */ case    7:  		/* mtspr CTR, R11 */
		/* 822671D0h case    7:*/		regs.CTR = regs.R11;
		/* 822671D0h case    7:*/		return 0x822671D4;
		  /* 822671D4h */ case    8:  		/* bcctrl 20, CR0_LT */
		/* 822671D4h case    8:*/		if ( 1 ) { regs.LR = 0x822671D8; return (uint32)regs.CTR; }
		/* 822671D4h case    8:*/		return 0x822671D8;
		  /* 822671D8h */ case    9:  		/* cmpwi CR6, R3, 259 */
		/* 822671D8h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000103);
		/* 822671D8h case    9:*/		return 0x822671DC;
		  /* 822671DCh */ case   10:  		/* bc 4, CR6_EQ, 36 */
		/* 822671DCh case   10:*/		if ( !regs.CR[6].eq ) { return 0x82267200;  }
		/* 822671DCh case   10:*/		return 0x822671E0;
		  /* 822671E0h */ case   11:  		/* li R6, 0 */
		/* 822671E0h case   11:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 822671E0h case   11:*/		return 0x822671E4;
		  /* 822671E4h */ case   12:  		/* li R5, 0 */
		/* 822671E4h case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 822671E4h case   12:*/		return 0x822671E8;
		  /* 822671E8h */ case   13:  		/* li R4, 1 */
		/* 822671E8h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 822671E8h case   13:*/		return 0x822671EC;
		  /* 822671ECh */ case   14:  		/* mr R3, R30 */
		/* 822671ECh case   14:*/		regs.R3 = regs.R30;
		/* 822671ECh case   14:*/		return 0x822671F0;
		  /* 822671F0h */ case   15:  		/* bl 24952 */
		/* 822671F0h case   15:*/		regs.LR = 0x822671F4; return 0x8226D368;
		/* 822671F0h case   15:*/		return 0x822671F4;
		  /* 822671F4h */ case   16:  		/* cmpwi CR0, R3, 0 */
		/* 822671F4h case   16:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 822671F4h case   16:*/		return 0x822671F8;
		  /* 822671F8h */ case   17:  		/* bc 12, CR0_LT, 32 */
		/* 822671F8h case   17:*/		if ( regs.CR[0].lt ) { return 0x82267218;  }
		/* 822671F8h case   17:*/		return 0x822671FC;
		  /* 822671FCh */ case   18:  		/* lwz R3, <#[R1 + 80]> */
		/* 822671FCh case   18:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 822671FCh case   18:*/		return 0x82267200;
	}
	return 0x82267200;
} // Block from 822671B4h-82267200h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82267200h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267200( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267200) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267200);
		  /* 82267200h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 82267200h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 82267200h case    0:*/		return 0x82267204;
		  /* 82267204h */ case    1:  		/* bc 12, CR6_LT, 20 */
		/* 82267204h case    1:*/		if ( regs.CR[6].lt ) { return 0x82267218;  }
		/* 82267204h case    1:*/		return 0x82267208;
		  /* 82267208h */ case    2:  		/* lwz R11, <#[R1 + 84]> */
		/* 82267208h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82267208h case    2:*/		return 0x8226720C;
		  /* 8226720Ch */ case    3:  		/* li R3, 1 */
		/* 8226720Ch case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8226720Ch case    3:*/		return 0x82267210;
		  /* 82267210h */ case    4:  		/* stw R11, <#[R29]> */
		/* 82267210h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82267210h case    4:*/		return 0x82267214;
		  /* 82267214h */ case    5:  		/* b 64 */
		/* 82267214h case    5:*/		return 0x82267254;
		/* 82267214h case    5:*/		return 0x82267218;
	}
	return 0x82267218;
} // Block from 82267200h-82267218h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82267218h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267218( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267218) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267218);
		  /* 82267218h */ case    0:  		/* lis R11, -16384 */
		/* 82267218h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFFC000);
		/* 82267218h case    0:*/		return 0x8226721C;
		  /* 8226721Ch */ case    1:  		/* ori R11, R11, 17 */
		/* 8226721Ch case    1:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x11);
		/* 8226721Ch case    1:*/		return 0x82267220;
		  /* 82267220h */ case    2:  		/* cmpw CR6, R3, R11 */
		/* 82267220h case    2:*/		cpu::op::cmpw<6>(regs,regs.R3,regs.R11);
		/* 82267220h case    2:*/		return 0x82267224;
		  /* 82267224h */ case    3:  		/* bc 4, CR6_EQ, 16 */
		/* 82267224h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82267234;  }
		/* 82267224h case    3:*/		return 0x82267228;
		  /* 82267228h */ case    4:  		/* li R3, 1 */
		/* 82267228h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82267228h case    4:*/		return 0x8226722C;
		  /* 8226722Ch */ case    5:  		/* stw R28, <#[R29]> */
		/* 8226722Ch case    5:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R29 + 0x00000000) );
		/* 8226722Ch case    5:*/		return 0x82267230;
		  /* 82267230h */ case    6:  		/* b 36 */
		/* 82267230h case    6:*/		return 0x82267254;
		/* 82267230h case    6:*/		return 0x82267234;
	}
	return 0x82267234;
} // Block from 82267218h-82267234h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82267234h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267234( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267234) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267234);
		  /* 82267234h */ case    0:  		/* rlwinm R11, R3, 0, 0, 1 */
		/* 82267234h case    0:*/		cpu::op::rlwinm<0,0,0,1>(regs,&regs.R11,regs.R3);
		/* 82267234h case    0:*/		return 0x82267238;
		  /* 82267238h */ case    1:  		/* lis R10, -32768 */
		/* 82267238h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8000);
		/* 82267238h case    1:*/		return 0x8226723C;
		  /* 8226723Ch */ case    2:  		/* cmplw CR6, R11, R10 */
		/* 8226723Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8226723Ch case    2:*/		return 0x82267240;
		  /* 82267240h */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 82267240h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8226724C;  }
		/* 82267240h case    3:*/		return 0x82267244;
		  /* 82267244h */ case    4:  		/* lwz R11, <#[R1 + 84]> */
		/* 82267244h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82267244h case    4:*/		return 0x82267248;
		  /* 82267248h */ case    5:  		/* stw R11, <#[R29]> */
		/* 82267248h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 82267248h case    5:*/		return 0x8226724C;
	}
	return 0x8226724C;
} // Block from 82267234h-8226724Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8226724Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226724C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226724C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226724C);
		  /* 8226724Ch */ case    0:  		/* bl -1952556 */
		/* 8226724Ch case    0:*/		regs.LR = 0x82267250; return 0x8208A720;
		/* 8226724Ch case    0:*/		return 0x82267250;
		  /* 82267250h */ case    1:  		/* li R3, 0 */
		/* 82267250h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82267250h case    1:*/		return 0x82267254;
	}
	return 0x82267254;
} // Block from 8226724Ch-82267254h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82267254h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267254( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267254) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267254);
		  /* 82267254h */ case    0:  		/* addi R1, R1, 144 */
		/* 82267254h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82267254h case    0:*/		return 0x82267258;
		  /* 82267258h */ case    1:  		/* b -1925040 */
		/* 82267258h case    1:*/		return 0x820912A8;
		/* 82267258h case    1:*/		return 0x8226725C;
		  /* 8226725Ch */ case    2:  		/* nop */
		/* 8226725Ch case    2:*/		cpu::op::nop();
		/* 8226725Ch case    2:*/		return 0x82267260;
	}
	return 0x82267260;
} // Block from 82267254h-82267260h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82267260h
// Function '?Check@R400ConstantModel@XGRAPHICS@@UAA_NPBVIRInst@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267260( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267260) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267260);
		  /* 82267260h */ case    0:  		/* b 25320 */
		/* 82267260h case    0:*/		return 0x8226D548;
		/* 82267260h case    0:*/		return 0x82267264;
		  /* 82267264h */ case    1:  		/* nop */
		/* 82267264h case    1:*/		cpu::op::nop();
		/* 82267264h case    1:*/		return 0x82267268;
	}
	return 0x82267268;
} // Block from 82267260h-82267268h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82267268h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267268( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267268) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267268);
		  /* 82267268h */ case    0:  		/* mfspr R12, LR */
		/* 82267268h case    0:*/		regs.R12 = regs.LR;
		/* 82267268h case    0:*/		return 0x8226726C;
		  /* 8226726Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8226726Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8226726Ch case    1:*/		return 0x82267270;
		  /* 82267270h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82267270h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82267270h case    2:*/		return 0x82267274;
		  /* 82267274h */ case    3:  		/* stwu R1, <#[R1 - 112]> */
		/* 82267274h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82267274h case    3:*/		return 0x82267278;
		  /* 82267278h */ case    4:  		/* mr R31, R4 */
		/* 82267278h case    4:*/		regs.R31 = regs.R4;
		/* 82267278h case    4:*/		return 0x8226727C;
		  /* 8226727Ch */ case    5:  		/* addi R4, R1, 80 */
		/* 8226727Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 8226727Ch case    5:*/		return 0x82267280;
		  /* 82267280h */ case    6:  		/* bl 1416 */
		/* 82267280h case    6:*/		regs.LR = 0x82267284; return 0x82267808;
		/* 82267280h case    6:*/		return 0x82267284;
		  /* 82267284h */ case    7:  		/* cmpwi CR0, R3, 0 */
		/* 82267284h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82267284h case    7:*/		return 0x82267288;
		  /* 82267288h */ case    8:  		/* bc 12, CR0_EQ, 48 */
		/* 82267288h case    8:*/		if ( regs.CR[0].eq ) { return 0x822672B8;  }
		/* 82267288h case    8:*/		return 0x8226728C;
		  /* 8226728Ch */ case    9:  		/* cmplwi CR6, R31, 0 */
		/* 8226728Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 8226728Ch case    9:*/		return 0x82267290;
		  /* 82267290h */ case   10:  		/* bc 12, CR6_EQ, 12 */
		/* 82267290h case   10:*/		if ( regs.CR[6].eq ) { return 0x8226729C;  }
		/* 82267290h case   10:*/		return 0x82267294;
		  /* 82267294h */ case   11:  		/* lwz R11, <#[R1 + 80]> */
		/* 82267294h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82267294h case   11:*/		return 0x82267298;
		  /* 82267298h */ case   12:  		/* stw R11, <#[R31]> */
		/* 82267298h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82267298h case   12:*/		return 0x8226729C;
	}
	return 0x8226729C;
} // Block from 82267268h-8226729Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8226729Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226729C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226729C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226729C);
		  /* 8226729Ch */ case    0:  		/* lwz R3, <#[R1 + 84]> */
		/* 8226729Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000054) );
		/* 8226729Ch case    0:*/		return 0x822672A0;
		  /* 822672A0h */ case    1:  		/* cmpwi CR6, R3, -1 */
		/* 822672A0h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R3,0xFFFFFFFF);
		/* 822672A0h case    1:*/		return 0x822672A4;
		  /* 822672A4h */ case    2:  		/* bc 4, CR6_EQ, 24 */
		/* 822672A4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x822672BC;  }
		/* 822672A4h case    2:*/		return 0x822672A8;
		  /* 822672A8h */ case    3:  		/* li R3, 0 */
		/* 822672A8h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822672A8h case    3:*/		return 0x822672AC;
		  /* 822672ACh */ case    4:  		/* bl -1952692 */
		/* 822672ACh case    4:*/		regs.LR = 0x822672B0; return 0x8208A6F8;
		/* 822672ACh case    4:*/		return 0x822672B0;
		  /* 822672B0h */ case    5:  		/* lwz R3, <#[R1 + 84]> */
		/* 822672B0h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000054) );
		/* 822672B0h case    5:*/		return 0x822672B4;
		  /* 822672B4h */ case    6:  		/* b 8 */
		/* 822672B4h case    6:*/		return 0x822672BC;
		/* 822672B4h case    6:*/		return 0x822672B8;
	}
	return 0x822672B8;
} // Block from 8226729Ch-822672B8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 822672B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822672B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822672B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822672B8);
		  /* 822672B8h */ case    0:  		/* li R3, -1 */
		/* 822672B8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 822672B8h case    0:*/		return 0x822672BC;
	}
	return 0x822672BC;
} // Block from 822672B8h-822672BCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 822672BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822672BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822672BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822672BC);
		  /* 822672BCh */ case    0:  		/* addi R1, R1, 112 */
		/* 822672BCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 822672BCh case    0:*/		return 0x822672C0;
		  /* 822672C0h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 822672C0h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822672C0h case    1:*/		return 0x822672C4;
		  /* 822672C4h */ case    2:  		/* mtspr LR, R12 */
		/* 822672C4h case    2:*/		regs.LR = regs.R12;
		/* 822672C4h case    2:*/		return 0x822672C8;
		  /* 822672C8h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 822672C8h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822672C8h case    3:*/		return 0x822672CC;
		  /* 822672CCh */ case    4:  		/* bclr 20, CR0_LT */
		/* 822672CCh case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822672CCh case    4:*/		return 0x822672D0;
	}
	return 0x822672D0;
} // Block from 822672BCh-822672D0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822672D0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822672D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822672D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822672D0);
		  /* 822672D0h */ case    0:  		/* mfspr R12, LR */
		/* 822672D0h case    0:*/		regs.R12 = regs.LR;
		/* 822672D0h case    0:*/		return 0x822672D4;
		  /* 822672D4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 822672D4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822672D4h case    1:*/		return 0x822672D8;
		  /* 822672D8h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 822672D8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 822672D8h case    2:*/		return 0x822672DC;
		  /* 822672DCh */ case    3:  		/* lis R9, -32218 */
		/* 822672DCh case    3:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8226);
		/* 822672DCh case    3:*/		return 0x822672E0;
		  /* 822672E0h */ case    4:  		/* stw R3, <#[R1 + 80]> */
		/* 822672E0h case    4:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 822672E0h case    4:*/		return 0x822672E4;
		  /* 822672E4h */ case    5:  		/* li R10, 0 */
		/* 822672E4h case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 822672E4h case    5:*/		return 0x822672E8;
		  /* 822672E8h */ case    6:  		/* rlwinm R8, R4, 0, 31, 31 */
		/* 822672E8h case    6:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R8,regs.R4);
		/* 822672E8h case    6:*/		return 0x822672EC;
		  /* 822672ECh */ case    7:  		/* addi R9, R9, 29392 */
		/* 822672ECh case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x72D0);
		/* 822672ECh case    7:*/		return 0x822672F0;
		  /* 822672F0h */ case    8:  		/* stw R10, <#[R1 + 88]> */
		/* 822672F0h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 822672F0h case    8:*/		return 0x822672F4;
		  /* 822672F4h */ case    9:  		/* mr R11, R5 */
		/* 822672F4h case    9:*/		regs.R11 = regs.R5;
		/* 822672F4h case    9:*/		return 0x822672F8;
		  /* 822672F8h */ case   10:  		/* stw R8, <#[R1 + 84]> */
		/* 822672F8h case   10:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x00000054) );
		/* 822672F8h case   10:*/		return 0x822672FC;
		  /* 822672FCh */ case   11:  		/* cmplwi CR6, R6, 0 */
		/* 822672FCh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 822672FCh case   11:*/		return 0x82267300;
		  /* 82267300h */ case   12:  		/* stw R9, <#[R1 + 92]> */
		/* 82267300h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x0000005C) );
		/* 82267300h case   12:*/		return 0x82267304;
		  /* 82267304h */ case   13:  		/* bc 12, CR6_EQ, 48 */
		/* 82267304h case   13:*/		if ( regs.CR[6].eq ) { return 0x82267334;  }
		/* 82267304h case   13:*/		return 0x82267308;
		  /* 82267308h */ case   14:  		/* cmplwi CR6, R5, 15 */
		/* 82267308h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x0000000F);
		/* 82267308h case   14:*/		return 0x8226730C;
		  /* 8226730Ch */ case   15:  		/* bc 4, CR6_GT, 8 */
		/* 8226730Ch case   15:*/		if ( !regs.CR[6].gt ) { return 0x82267314;  }
		/* 8226730Ch case   15:*/		return 0x82267310;
		  /* 82267310h */ case   16:  		/* li R11, 15 */
		/* 82267310h case   16:*/		cpu::op::li<0>(regs,&regs.R11,0xF);
		/* 82267310h case   16:*/		return 0x82267314;
	}
	return 0x82267314;
} // Block from 822672D0h-82267314h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82267314h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267314( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267314) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267314);
		  /* 82267314h */ case    0:  		/* stw R11, <#[R1 + 96]> */
		/* 82267314h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82267314h case    0:*/		return 0x82267318;
		  /* 82267318h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 82267318h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 82267318h case    1:*/		return 0x8226731C;
		  /* 8226731Ch */ case    2:  		/* bc 12, CR6_EQ, 28 */
		/* 8226731Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x82267338;  }
		/* 8226731Ch case    2:*/		return 0x82267320;
		  /* 82267320h */ case    3:  		/* mr R4, R6 */
		/* 82267320h case    3:*/		regs.R4 = regs.R6;
		/* 82267320h case    3:*/		return 0x82267324;
		  /* 82267324h */ case    4:  		/* addi R3, R1, 100 */
		/* 82267324h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x64);
		/* 82267324h case    4:*/		return 0x82267328;
		  /* 82267328h */ case    5:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 82267328h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 82267328h case    5:*/		return 0x8226732C;
		  /* 8226732Ch */ case    6:  		/* bl -1922292 */
		/* 8226732Ch case    6:*/		regs.LR = 0x82267330; return 0x82091E38;
		/* 8226732Ch case    6:*/		return 0x82267330;
		  /* 82267330h */ case    7:  		/* b 8 */
		/* 82267330h case    7:*/		return 0x82267338;
		/* 82267330h case    7:*/		return 0x82267334;
	}
	return 0x82267334;
} // Block from 82267314h-82267334h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82267334h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267334( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267334) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267334);
		  /* 82267334h */ case    0:  		/* stw R10, <#[R1 + 96]> */
		/* 82267334h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 82267334h case    0:*/		return 0x82267338;
	}
	return 0x82267338;
} // Block from 82267334h-82267338h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82267338h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267338( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267338) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267338);
		  /* 82267338h */ case    0:  		/* addi R3, R1, 80 */
		/* 82267338h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82267338h case    0:*/		return 0x8226733C;
		  /* 8226733Ch */ case    1:  		/* bl 24492 */
		/* 8226733Ch case    1:*/		regs.LR = 0x82267340; return 0x8226D2E8;
		/* 8226733Ch case    1:*/		return 0x82267340;
		  /* 82267340h */ case    2:  		/* addi R1, R1, 176 */
		/* 82267340h case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 82267340h case    2:*/		return 0x82267344;
		  /* 82267344h */ case    3:  		/* lwz R12, <#[R1 - 8]> */
		/* 82267344h case    3:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82267344h case    3:*/		return 0x82267348;
		  /* 82267348h */ case    4:  		/* mtspr LR, R12 */
		/* 82267348h case    4:*/		regs.LR = regs.R12;
		/* 82267348h case    4:*/		return 0x8226734C;
		  /* 8226734Ch */ case    5:  		/* bclr 20, CR0_LT */
		/* 8226734Ch case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8226734Ch case    5:*/		return 0x82267350;
	}
	return 0x82267350;
} // Block from 82267338h-82267350h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82267350h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267350( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267350) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267350);
		  /* 82267350h */ case    0:  		/* b 24920 */
		/* 82267350h case    0:*/		return 0x8226D4A8;
		/* 82267350h case    0:*/		return 0x82267354;
		  /* 82267354h */ case    1:  		/* nop */
		/* 82267354h case    1:*/		cpu::op::nop();
		/* 82267354h case    1:*/		return 0x82267358;
	}
	return 0x82267358;
} // Block from 82267350h-82267358h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82267358h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267358( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267358) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267358);
		  /* 82267358h */ case    0:  		/* mr R5, R4 */
		/* 82267358h case    0:*/		regs.R5 = regs.R4;
		/* 82267358h case    0:*/		return 0x8226735C;
		  /* 8226735Ch */ case    1:  		/* li R4, 1 */
		/* 8226735Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8226735Ch case    1:*/		return 0x82267360;
		  /* 82267360h */ case    2:  		/* b 24920 */
		/* 82267360h case    2:*/		return 0x8226D4B8;
		/* 82267360h case    2:*/		return 0x82267364;
		  /* 82267364h */ case    3:  		/* nop */
		/* 82267364h case    3:*/		cpu::op::nop();
		/* 82267364h case    3:*/		return 0x82267368;
	}
	return 0x82267368;
} // Block from 82267358h-82267368h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82267368h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267368( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267368) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267368);
		  /* 82267368h */ case    0:  		/* cmplwi CR6, R3, 0 */
		/* 82267368h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82267368h case    0:*/		return 0x8226736C;
		  /* 8226736Ch */ case    1:  		/* bc 12, CR6_EQ, 196 */
		/* 8226736Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x82267430;  }
		/* 8226736Ch case    1:*/		return 0x82267370;
		  /* 82267370h */ case    2:  		/* lis R10, -32251 */
		/* 82267370h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 82267370h case    2:*/		return 0x82267374;
		  /* 82267374h */ case    3:  		/* mr R11, R3 */
		/* 82267374h case    3:*/		regs.R11 = regs.R3;
		/* 82267374h case    3:*/		return 0x82267378;
		  /* 82267378h */ case    4:  		/* addi R10, R10, -17260 */
		/* 82267378h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFBC94);
		/* 82267378h case    4:*/		return 0x8226737C;
		  /* 8226737Ch */ case    5:  		/* lbz R9, <#[R11]> */
		/* 8226737Ch case    5:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 8226737Ch case    5:*/		return 0x82267380;
		  /* 82267380h */ case    6:  		/* lbz R8, <#[R10]> */
		/* 82267380h case    6:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 82267380h case    6:*/		return 0x82267384;
		  /* 82267384h */ case    7:  		/* cmpwi CR0, R9, 0 */
		/* 82267384h case    7:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 82267384h case    7:*/		return 0x82267388;
		  /* 82267388h */ case    8:  		/* subf R9, R8, R9 */
		/* 82267388h case    8:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 82267388h case    8:*/		return 0x8226738C;
		  /* 8226738Ch */ case    9:  		/* bc 12, CR0_EQ, 20 */
		/* 8226738Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x822673A0;  }
		/* 8226738Ch case    9:*/		return 0x82267390;
		  /* 82267390h */ case   10:  		/* addi R11, R11, 1 */
		/* 82267390h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82267390h case   10:*/		return 0x82267394;
		  /* 82267394h */ case   11:  		/* addi R10, R10, 1 */
		/* 82267394h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82267394h case   11:*/		return 0x82267398;
		  /* 82267398h */ case   12:  		/* cmpwi CR6, R9, 0 */
		/* 82267398h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 82267398h case   12:*/		return 0x8226739C;
		  /* 8226739Ch */ case   13:  		/* bc 12, CR6_EQ, -32 */
		/* 8226739Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x8226737C;  }
		/* 8226739Ch case   13:*/		return 0x822673A0;
	}
	return 0x822673A0;
} // Block from 82267368h-822673A0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 822673A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822673A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822673A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822673A0);
		  /* 822673A0h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 822673A0h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 822673A0h case    0:*/		return 0x822673A4;
		  /* 822673A4h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 822673A4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x822673B0;  }
		/* 822673A4h case    1:*/		return 0x822673A8;
		  /* 822673A8h */ case    2:  		/* ori R4, R4, 2 */
		/* 822673A8h case    2:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0x2);
		/* 822673A8h case    2:*/		return 0x822673AC;
		  /* 822673ACh */ case    3:  		/* b 128 */
		/* 822673ACh case    3:*/		return 0x8226742C;
		/* 822673ACh case    3:*/		return 0x822673B0;
	}
	return 0x822673B0;
} // Block from 822673A0h-822673B0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822673B0h
// Function '?Apply@R400ConstantModel@XGRAPHICS@@UAAXPBVIRInst@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822673B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822673B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822673B0);
		  /* 822673B0h */ case    0:  		/* lis R10, -32251 */
		/* 822673B0h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 822673B0h case    0:*/		return 0x822673B4;
		  /* 822673B4h */ case    1:  		/* mr R11, R3 */
		/* 822673B4h case    1:*/		regs.R11 = regs.R3;
		/* 822673B4h case    1:*/		return 0x822673B8;
		  /* 822673B8h */ case    2:  		/* addi R10, R10, -17280 */
		/* 822673B8h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFBC80);
		/* 822673B8h case    2:*/		return 0x822673BC;
		  /* 822673BCh */ case    3:  		/* lbz R9, <#[R11]> */
		/* 822673BCh case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 822673BCh case    3:*/		return 0x822673C0;
		  /* 822673C0h */ case    4:  		/* lbz R8, <#[R10]> */
		/* 822673C0h case    4:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 822673C0h case    4:*/		return 0x822673C4;
		  /* 822673C4h */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 822673C4h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 822673C4h case    5:*/		return 0x822673C8;
		  /* 822673C8h */ case    6:  		/* subf R9, R8, R9 */
		/* 822673C8h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 822673C8h case    6:*/		return 0x822673CC;
		  /* 822673CCh */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 822673CCh case    7:*/		if ( regs.CR[0].eq ) { return 0x822673E0;  }
		/* 822673CCh case    7:*/		return 0x822673D0;
		  /* 822673D0h */ case    8:  		/* addi R11, R11, 1 */
		/* 822673D0h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 822673D0h case    8:*/		return 0x822673D4;
		  /* 822673D4h */ case    9:  		/* addi R10, R10, 1 */
		/* 822673D4h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 822673D4h case    9:*/		return 0x822673D8;
		  /* 822673D8h */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 822673D8h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 822673D8h case   10:*/		return 0x822673DC;
		  /* 822673DCh */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 822673DCh case   11:*/		if ( regs.CR[6].eq ) { return 0x822673BC;  }
		/* 822673DCh case   11:*/		return 0x822673E0;
	}
	return 0x822673E0;
} // Block from 822673B0h-822673E0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 822673E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822673E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822673E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822673E0);
		  /* 822673E0h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 822673E0h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 822673E0h case    0:*/		return 0x822673E4;
		  /* 822673E4h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 822673E4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x822673F0;  }
		/* 822673E4h case    1:*/		return 0x822673E8;
		  /* 822673E8h */ case    2:  		/* ori R4, R4, 256 */
		/* 822673E8h case    2:*/		cpu::op::ori<0>(regs,&regs.R4,regs.R4,0x100);
		/* 822673E8h case    2:*/		return 0x822673EC;
		  /* 822673ECh */ case    3:  		/* b 64 */
		/* 822673ECh case    3:*/		return 0x8226742C;
		/* 822673ECh case    3:*/		return 0x822673F0;
	}
	return 0x822673F0;
} // Block from 822673E0h-822673F0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822673F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822673F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822673F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822673F0);
		  /* 822673F0h */ case    0:  		/* lis R10, -32251 */
		/* 822673F0h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 822673F0h case    0:*/		return 0x822673F4;
		  /* 822673F4h */ case    1:  		/* mr R11, R3 */
		/* 822673F4h case    1:*/		regs.R11 = regs.R3;
		/* 822673F4h case    1:*/		return 0x822673F8;
		  /* 822673F8h */ case    2:  		/* addi R10, R10, -17300 */
		/* 822673F8h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFBC6C);
		/* 822673F8h case    2:*/		return 0x822673FC;
		  /* 822673FCh */ case    3:  		/* lbz R9, <#[R11]> */
		/* 822673FCh case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 822673FCh case    3:*/		return 0x82267400;
		  /* 82267400h */ case    4:  		/* lbz R8, <#[R10]> */
		/* 82267400h case    4:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 82267400h case    4:*/		return 0x82267404;
		  /* 82267404h */ case    5:  		/* cmpwi CR0, R9, 0 */
		/* 82267404h case    5:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 82267404h case    5:*/		return 0x82267408;
		  /* 82267408h */ case    6:  		/* subf R9, R8, R9 */
		/* 82267408h case    6:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 82267408h case    6:*/		return 0x8226740C;
		  /* 8226740Ch */ case    7:  		/* bc 12, CR0_EQ, 20 */
		/* 8226740Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x82267420;  }
		/* 8226740Ch case    7:*/		return 0x82267410;
		  /* 82267410h */ case    8:  		/* addi R11, R11, 1 */
		/* 82267410h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82267410h case    8:*/		return 0x82267414;
		  /* 82267414h */ case    9:  		/* addi R10, R10, 1 */
		/* 82267414h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82267414h case    9:*/		return 0x82267418;
		  /* 82267418h */ case   10:  		/* cmpwi CR6, R9, 0 */
		/* 82267418h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 82267418h case   10:*/		return 0x8226741C;
		  /* 8226741Ch */ case   11:  		/* bc 12, CR6_EQ, -32 */
		/* 8226741Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x822673FC;  }
		/* 8226741Ch case   11:*/		return 0x82267420;
	}
	return 0x82267420;
} // Block from 822673F0h-82267420h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82267420h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267420( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267420) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267420);
		  /* 82267420h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 82267420h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 82267420h case    0:*/		return 0x82267424;
		  /* 82267424h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 82267424h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82267430;  }
		/* 82267424h case    1:*/		return 0x82267428;
		  /* 82267428h */ case    2:  		/* oris R4, R4, 4 */
		/* 82267428h case    2:*/		cpu::op::oris<0>(regs,&regs.R4,regs.R4,0x4);
		/* 82267428h case    2:*/		return 0x8226742C;
	}
	return 0x8226742C;
} // Block from 82267420h-8226742Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8226742Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226742C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226742C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226742C);
		  /* 8226742Ch */ case    0:  		/* li R3, 0 */
		/* 8226742Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8226742Ch case    0:*/		return 0x82267430;
	}
	return 0x82267430;
} // Block from 8226742Ch-82267430h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82267430h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267430( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267430) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267430);
		  /* 82267430h */ case    0:  		/* b 24728 */
		/* 82267430h case    0:*/		return 0x8226D4C8;
		/* 82267430h case    0:*/		return 0x82267434;
		  /* 82267434h */ case    1:  		/* nop */
		/* 82267434h case    1:*/		cpu::op::nop();
		/* 82267434h case    1:*/		return 0x82267438;
	}
	return 0x82267438;
} // Block from 82267430h-82267438h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82267438h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267438( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267438) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267438);
		  /* 82267438h */ case    0:  		/* mfspr R12, LR */
		/* 82267438h case    0:*/		regs.R12 = regs.LR;
		/* 82267438h case    0:*/		return 0x8226743C;
		  /* 8226743Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8226743Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8226743Ch case    1:*/		return 0x82267440;
		  /* 82267440h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82267440h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82267440h case    2:*/		return 0x82267444;
		  /* 82267444h */ case    3:  		/* stwu R1, <#[R1 - 112]> */
		/* 82267444h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82267444h case    3:*/		return 0x82267448;
		  /* 82267448h */ case    4:  		/* mr R4, R3 */
		/* 82267448h case    4:*/		regs.R4 = regs.R3;
		/* 82267448h case    4:*/		return 0x8226744C;
		  /* 8226744Ch */ case    5:  		/* addi R3, R1, 88 */
		/* 8226744Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x58);
		/* 8226744Ch case    5:*/		return 0x82267450;
		  /* 82267450h */ case    6:  		/* bl 24872 */
		/* 82267450h case    6:*/		regs.LR = 0x82267454; return 0x8226D578;
		/* 82267450h case    6:*/		return 0x82267454;
		  /* 82267454h */ case    7:  		/* li R5, 1 */
		/* 82267454h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82267454h case    7:*/		return 0x82267458;
		  /* 82267458h */ case    8:  		/* addi R4, R1, 88 */
		/* 82267458h case    8:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x58);
		/* 82267458h case    8:*/		return 0x8226745C;
		  /* 8226745Ch */ case    9:  		/* addi R3, R1, 80 */
		/* 8226745Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 8226745Ch case    9:*/		return 0x82267460;
		  /* 82267460h */ case   10:  		/* bl 24840 */
		/* 82267460h case   10:*/		regs.LR = 0x82267464; return 0x8226D568;
		/* 82267460h case   10:*/		return 0x82267464;
		  /* 82267464h */ case   11:  		/* or. R31, R3, R3 */
		/* 82267464h case   11:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 82267464h case   11:*/		return 0x82267468;
		  /* 82267468h */ case   12:  		/* bc 4, CR0_LT, 16 */
		/* 82267468h case   12:*/		if ( !regs.CR[0].lt ) { return 0x82267478;  }
		/* 82267468h case   12:*/		return 0x8226746C;
		  /* 8226746Ch */ case   13:  		/* lis R11, -32256 */
		/* 8226746Ch case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8226746Ch case   13:*/		return 0x82267470;
		  /* 82267470h */ case   14:  		/* addi R11, R11, 4485 */
		/* 82267470h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1185);
		/* 82267470h case   14:*/		return 0x82267474;
		  /* 82267474h */ case   15:  		/* stw R11, <#[R1 + 84]> */
		/* 82267474h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82267474h case   15:*/		return 0x82267478;
	}
	return 0x82267478;
} // Block from 82267438h-82267478h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82267478h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267478( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267478) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267478);
		  /* 82267478h */ case    0:  		/* lwz R3, <#[R1 + 84]> */
		/* 82267478h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000054) );
		/* 82267478h case    0:*/		return 0x8226747C;
		  /* 8226747Ch */ case    1:  		/* bl -1962276 */
		/* 8226747Ch case    1:*/		regs.LR = 0x82267480; return 0x82088358;
		/* 8226747Ch case    1:*/		return 0x82267480;
		  /* 82267480h */ case    2:  		/* cmpwi CR6, R31, 0 */
		/* 82267480h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 82267480h case    2:*/		return 0x82267484;
		  /* 82267484h */ case    3:  		/* bc 12, CR6_LT, 12 */
		/* 82267484h case    3:*/		if ( regs.CR[6].lt ) { return 0x82267490;  }
		/* 82267484h case    3:*/		return 0x82267488;
		  /* 82267488h */ case    4:  		/* addi R3, R1, 80 */
		/* 82267488h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82267488h case    4:*/		return 0x8226748C;
		  /* 8226748Ch */ case    5:  		/* bl 24780 */
		/* 8226748Ch case    5:*/		regs.LR = 0x82267490; return 0x8226D558;
		/* 8226748Ch case    5:*/		return 0x82267490;
	}
	return 0x82267490;
} // Block from 82267478h-82267490h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82267490h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267490( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267490) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267490);
		  /* 82267490h */ case    0:  		/* addi R1, R1, 112 */
		/* 82267490h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82267490h case    0:*/		return 0x82267494;
		  /* 82267494h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82267494h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82267494h case    1:*/		return 0x82267498;
		  /* 82267498h */ case    2:  		/* mtspr LR, R12 */
		/* 82267498h case    2:*/		regs.LR = regs.R12;
		/* 82267498h case    2:*/		return 0x8226749C;
		  /* 8226749Ch */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 8226749Ch case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8226749Ch case    3:*/		return 0x822674A0;
		  /* 822674A0h */ case    4:  		/* bclr 20, CR0_LT */
		/* 822674A0h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822674A0h case    4:*/		return 0x822674A4;
	}
	return 0x822674A4;
} // Block from 82267490h-822674A4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822674A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822674A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822674A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822674A4);
		  /* 822674A4h */ case    0:  		/* nop */
		/* 822674A4h case    0:*/		cpu::op::nop();
		/* 822674A4h case    0:*/		return 0x822674A8;
	}
	return 0x822674A8;
} // Block from 822674A4h-822674A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822674A8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822674A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822674A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822674A8);
		  /* 822674A8h */ case    0:  		/* mfspr R12, LR */
		/* 822674A8h case    0:*/		regs.R12 = regs.LR;
		/* 822674A8h case    0:*/		return 0x822674AC;
		  /* 822674ACh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 822674ACh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822674ACh case    1:*/		return 0x822674B0;
		  /* 822674B0h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 822674B0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 822674B0h case    2:*/		return 0x822674B4;
		  /* 822674B4h */ case    3:  		/* addi R4, R1, 80 */
		/* 822674B4h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 822674B4h case    3:*/		return 0x822674B8;
		  /* 822674B8h */ case    4:  		/* bl 24784 */
		/* 822674B8h case    4:*/		regs.LR = 0x822674BC; return 0x8226D588;
		/* 822674B8h case    4:*/		return 0x822674BC;
		  /* 822674BCh */ case    5:  		/* cmpwi CR0, R3, 0 */
		/* 822674BCh case    5:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 822674BCh case    5:*/		return 0x822674C0;
		  /* 822674C0h */ case    6:  		/* bc 12, CR0_LT, 12 */
		/* 822674C0h case    6:*/		if ( regs.CR[0].lt ) { return 0x822674CC;  }
		/* 822674C0h case    6:*/		return 0x822674C4;
		  /* 822674C4h */ case    7:  		/* li R3, 1 */
		/* 822674C4h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 822674C4h case    7:*/		return 0x822674C8;
		  /* 822674C8h */ case    8:  		/* b 12 */
		/* 822674C8h case    8:*/		return 0x822674D4;
		/* 822674C8h case    8:*/		return 0x822674CC;
	}
	return 0x822674CC;
} // Block from 822674A8h-822674CCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 822674CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822674CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822674CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822674CC);
		  /* 822674CCh */ case    0:  		/* bl -1953196 */
		/* 822674CCh case    0:*/		regs.LR = 0x822674D0; return 0x8208A720;
		/* 822674CCh case    0:*/		return 0x822674D0;
		  /* 822674D0h */ case    1:  		/* li R3, 0 */
		/* 822674D0h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822674D0h case    1:*/		return 0x822674D4;
	}
	return 0x822674D4;
} // Block from 822674CCh-822674D4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822674D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822674D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822674D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822674D4);
		  /* 822674D4h */ case    0:  		/* addi R1, R1, 96 */
		/* 822674D4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 822674D4h case    0:*/		return 0x822674D8;
		  /* 822674D8h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 822674D8h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822674D8h case    1:*/		return 0x822674DC;
		  /* 822674DCh */ case    2:  		/* mtspr LR, R12 */
		/* 822674DCh case    2:*/		regs.LR = regs.R12;
		/* 822674DCh case    2:*/		return 0x822674E0;
		  /* 822674E0h */ case    3:  		/* bclr 20, CR0_LT */
		/* 822674E0h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822674E0h case    3:*/		return 0x822674E4;
	}
	return 0x822674E4;
} // Block from 822674D4h-822674E4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822674E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822674E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822674E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822674E4);
		  /* 822674E4h */ case    0:  		/* nop */
		/* 822674E4h case    0:*/		cpu::op::nop();
		/* 822674E4h case    0:*/		return 0x822674E8;
	}
	return 0x822674E8;
} // Block from 822674E4h-822674E8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822674E8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822674E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822674E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822674E8);
		  /* 822674E8h */ case    0:  		/* mfspr R12, LR */
		/* 822674E8h case    0:*/		regs.R12 = regs.LR;
		/* 822674E8h case    0:*/		return 0x822674EC;
		  /* 822674ECh */ case    1:  		/* bl -1925780 */
		/* 822674ECh case    1:*/		regs.LR = 0x822674F0; return 0x82091258;
		/* 822674ECh case    1:*/		return 0x822674F0;
		  /* 822674F0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 822674F0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 822674F0h case    2:*/		return 0x822674F4;
		  /* 822674F4h */ case    3:  		/* mr R29, R5 */
		/* 822674F4h case    3:*/		regs.R29 = regs.R5;
		/* 822674F4h case    3:*/		return 0x822674F8;
		  /* 822674F8h */ case    4:  		/* mr R4, R6 */
		/* 822674F8h case    4:*/		regs.R4 = regs.R6;
		/* 822674F8h case    4:*/		return 0x822674FC;
		  /* 822674FCh */ case    5:  		/* mr R28, R7 */
		/* 822674FCh case    5:*/		regs.R28 = regs.R7;
		/* 822674FCh case    5:*/		return 0x82267500;
		  /* 82267500h */ case    6:  		/* mr R30, R8 */
		/* 82267500h case    6:*/		regs.R30 = regs.R8;
		/* 82267500h case    6:*/		return 0x82267504;
		  /* 82267504h */ case    7:  		/* cmplwi CR6, R10, 0 */
		/* 82267504h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82267504h case    7:*/		return 0x82267508;
		  /* 82267508h */ case    8:  		/* bc 12, CR6_EQ, 12 */
		/* 82267508h case    8:*/		if ( regs.CR[6].eq ) { return 0x82267514;  }
		/* 82267508h case    8:*/		return 0x8226750C;
		  /* 8226750Ch */ case    9:  		/* li R11, 0 */
		/* 8226750Ch case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8226750Ch case    9:*/		return 0x82267510;
		  /* 82267510h */ case   10:  		/* stw R11, <#[R10]> */
		/* 82267510h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82267510h case   10:*/		return 0x82267514;
	}
	return 0x82267514;
} // Block from 822674E8h-82267514h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82267514h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267514( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267514) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267514);
		  /* 82267514h */ case    0:  		/* cmplwi CR6, R3, 65001 */
		/* 82267514h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x0000FDE9);
		/* 82267514h case    0:*/		return 0x82267518;
		  /* 82267518h */ case    1:  		/* bc 4, CR6_EQ, 24 */
		/* 82267518h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82267530;  }
		/* 82267518h case    1:*/		return 0x8226751C;
		  /* 8226751Ch */ case    2:  		/* mr R6, R30 */
		/* 8226751Ch case    2:*/		regs.R6 = regs.R30;
		/* 8226751Ch case    2:*/		return 0x82267520;
		  /* 82267520h */ case    3:  		/* mr R5, R28 */
		/* 82267520h case    3:*/		regs.R5 = regs.R28;
		/* 82267520h case    3:*/		return 0x82267524;
		  /* 82267524h */ case    4:  		/* mr R3, R29 */
		/* 82267524h case    4:*/		regs.R3 = regs.R29;
		/* 82267524h case    4:*/		return 0x82267528;
		  /* 82267528h */ case    5:  		/* bl 848 */
		/* 82267528h case    5:*/		regs.LR = 0x8226752C; return 0x82267878;
		/* 82267528h case    5:*/		return 0x8226752C;
		  /* 8226752Ch */ case    6:  		/* b 116 */
		/* 8226752Ch case    6:*/		return 0x822675A0;
		/* 8226752Ch case    6:*/		return 0x82267530;
	}
	return 0x82267530;
} // Block from 82267514h-82267530h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82267530h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267530);
		  /* 82267530h */ case    0:  		/* cmpwi CR6, R4, -1 */
		/* 82267530h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R4,0xFFFFFFFF);
		/* 82267530h case    0:*/		return 0x82267534;
		  /* 82267534h */ case    1:  		/* bc 4, CR6_EQ, 20 */
		/* 82267534h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82267548;  }
		/* 82267534h case    1:*/		return 0x82267538;
	}
	return 0x82267538;
} // Block from 82267530h-82267538h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82267538h
// Function '?AddUpResourceUsage@R400SchedModel@XGRAPHICS@@QAAXPBVIRInst@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267538( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267538) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267538);
		  /* 82267538h */ case    0:  		/* mr R3, R29 */
		/* 82267538h case    0:*/		regs.R3 = regs.R29;
		/* 82267538h case    0:*/		return 0x8226753C;
		  /* 8226753Ch */ case    1:  		/* bl -1916220 */
		/* 8226753Ch case    1:*/		regs.LR = 0x82267540; return 0x82093800;
		/* 8226753Ch case    1:*/		return 0x82267540;
		  /* 82267540h */ case    2:  		/* addi R31, R3, 1 */
		/* 82267540h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R3,0x1);
		/* 82267540h case    2:*/		return 0x82267544;
		  /* 82267544h */ case    3:  		/* b 8 */
		/* 82267544h case    3:*/		return 0x8226754C;
		/* 82267544h case    3:*/		return 0x82267548;
	}
	return 0x82267548;
} // Block from 82267538h-82267548h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82267548h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267548( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267548) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267548);
		  /* 82267548h */ case    0:  		/* mr R31, R4 */
		/* 82267548h case    0:*/		regs.R31 = regs.R4;
		/* 82267548h case    0:*/		return 0x8226754C;
	}
	return 0x8226754C;
} // Block from 82267548h-8226754Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226754Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226754C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226754C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226754C);
		  /* 8226754Ch */ case    0:  		/* cmpwi CR6, R30, 0 */
		/* 8226754Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 8226754Ch case    0:*/		return 0x82267550;
		  /* 82267550h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 82267550h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8226755C;  }
		/* 82267550h case    1:*/		return 0x82267554;
		  /* 82267554h */ case    2:  		/* mr R3, R31 */
		/* 82267554h case    2:*/		regs.R3 = regs.R31;
		/* 82267554h case    2:*/		return 0x82267558;
		  /* 82267558h */ case    3:  		/* b 72 */
		/* 82267558h case    3:*/		return 0x822675A0;
		/* 82267558h case    3:*/		return 0x8226755C;
	}
	return 0x8226755C;
} // Block from 8226754Ch-8226755Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226755Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226755C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226755C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226755C);
		  /* 8226755Ch */ case    0:  		/* cmpwi CR6, R31, 0 */
		/* 8226755Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 8226755Ch case    0:*/		return 0x82267560;
		  /* 82267560h */ case    1:  		/* bc 12, CR6_LT, 52 */
		/* 82267560h case    1:*/		if ( regs.CR[6].lt ) { return 0x82267594;  }
		/* 82267560h case    1:*/		return 0x82267564;
		  /* 82267564h */ case    2:  		/* cmpw CR6, R30, R31 */
		/* 82267564h case    2:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R31);
		/* 82267564h case    2:*/		return 0x82267568;
		  /* 82267568h */ case    3:  		/* bc 12, CR6_LT, 44 */
		/* 82267568h case    3:*/		if ( regs.CR[6].lt ) { return 0x82267594;  }
		/* 82267568h case    3:*/		return 0x8226756C;
		  /* 8226756Ch */ case    4:  		/* rlwinm R7, R31, 1, 0, 30 */
		/* 8226756Ch case    4:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R7,regs.R31);
		/* 8226756Ch case    4:*/		return 0x82267570;
		  /* 82267570h */ case    5:  		/* mr R6, R29 */
		/* 82267570h case    5:*/		regs.R6 = regs.R29;
		/* 82267570h case    5:*/		return 0x82267574;
		  /* 82267574h */ case    6:  		/* li R5, 0 */
		/* 82267574h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82267574h case    6:*/		return 0x82267578;
		  /* 82267578h */ case    7:  		/* mr R4, R30 */
		/* 82267578h case    7:*/		regs.R4 = regs.R30;
		/* 82267578h case    7:*/		return 0x8226757C;
		  /* 8226757Ch */ case    8:  		/* mr R3, R28 */
		/* 8226757Ch case    8:*/		regs.R3 = regs.R28;
		/* 8226757Ch case    8:*/		return 0x82267580;
		  /* 82267580h */ case    9:  		/* bl 24600 */
		/* 82267580h case    9:*/		regs.LR = 0x82267584; return 0x8226D598;
		/* 82267580h case    9:*/		return 0x82267584;
		  /* 82267584h */ case   10:  		/* cmpwi CR0, R3, 0 */
		/* 82267584h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82267584h case   10:*/		return 0x82267588;
		  /* 82267588h */ case   11:  		/* bc 4, CR0_LT, -52 */
		/* 82267588h case   11:*/		if ( !regs.CR[0].lt ) { return 0x82267554;  }
		/* 82267588h case   11:*/		return 0x8226758C;
		  /* 8226758Ch */ case   12:  		/* bl 24108 */
		/* 8226758Ch case   12:*/		regs.LR = 0x82267590; return 0x8226D3B8;
		/* 8226758Ch case   12:*/		return 0x82267590;
		  /* 82267590h */ case   13:  		/* b 8 */
		/* 82267590h case   13:*/		return 0x82267598;
		/* 82267590h case   13:*/		return 0x82267594;
	}
	return 0x82267594;
} // Block from 8226755Ch-82267594h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82267594h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267594( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267594) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267594);
		  /* 82267594h */ case    0:  		/* li R3, 122 */
		/* 82267594h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x7A);
		/* 82267594h case    0:*/		return 0x82267598;
	}
	return 0x82267598;
} // Block from 82267594h-82267598h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82267598h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267598( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267598) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267598);
		  /* 82267598h */ case    0:  		/* bl -1953440 */
		/* 82267598h case    0:*/		regs.LR = 0x8226759C; return 0x8208A6F8;
		/* 82267598h case    0:*/		return 0x8226759C;
		  /* 8226759Ch */ case    1:  		/* li R3, 0 */
		/* 8226759Ch case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8226759Ch case    1:*/		return 0x822675A0;
	}
	return 0x822675A0;
} // Block from 82267598h-822675A0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822675A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822675A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822675A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822675A0);
		  /* 822675A0h */ case    0:  		/* addi R1, R1, 128 */
		/* 822675A0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 822675A0h case    0:*/		return 0x822675A4;
		  /* 822675A4h */ case    1:  		/* b -1925884 */
		/* 822675A4h case    1:*/		return 0x820912A8;
		/* 822675A4h case    1:*/		return 0x822675A8;
	}
	return 0x822675A8;
} // Block from 822675A0h-822675A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822675A8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822675A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822675A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822675A8);
		  /* 822675A8h */ case    0:  		/* mfspr R12, LR */
		/* 822675A8h case    0:*/		regs.R12 = regs.LR;
		/* 822675A8h case    0:*/		return 0x822675AC;
		  /* 822675ACh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 822675ACh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822675ACh case    1:*/		return 0x822675B0;
		  /* 822675B0h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 822675B0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 822675B0h case    2:*/		return 0x822675B4;
		  /* 822675B4h */ case    3:  		/* mr R4, R3 */
		/* 822675B4h case    3:*/		regs.R4 = regs.R3;
		/* 822675B4h case    3:*/		return 0x822675B8;
	}
	return 0x822675B8;
} // Block from 822675A8h-822675B8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822675B8h
// Function '?ReduceResourceUsage@R400SchedModel@XGRAPHICS@@QAAXPBVIRInst@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822675B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822675B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822675B8);
		  /* 822675B8h */ case    0:  		/* addi R3, R1, 80 */
		/* 822675B8h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 822675B8h case    0:*/		return 0x822675BC;
		  /* 822675BCh */ case    1:  		/* bl 23612 */
		/* 822675BCh case    1:*/		regs.LR = 0x822675C0; return 0x8226D1F8;
		/* 822675BCh case    1:*/		return 0x822675C0;
		  /* 822675C0h */ case    2:  		/* li R11, -3 */
		/* 822675C0h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0xFFFFFFFD);
		/* 822675C0h case    2:*/		return 0x822675C4;
		  /* 822675C4h */ case    3:  		/* li R10, 64 */
		/* 822675C4h case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x40);
		/* 822675C4h case    3:*/		return 0x822675C8;
		  /* 822675C8h */ case    4:  		/* addi R9, R1, 80 */
		/* 822675C8h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x50);
		/* 822675C8h case    4:*/		return 0x822675CC;
		  /* 822675CCh */ case    5:  		/* stw R11, <#[R1 + 88]> */
		/* 822675CCh case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 822675CCh case    5:*/		return 0x822675D0;
		  /* 822675D0h */ case    6:  		/* stw R10, <#[R1 + 96]> */
		/* 822675D0h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000060) );
		/* 822675D0h case    6:*/		return 0x822675D4;
		  /* 822675D4h */ case    7:  		/* addi R4, R1, 112 */
		/* 822675D4h case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x70);
		/* 822675D4h case    7:*/		return 0x822675D8;
		  /* 822675D8h */ case    8:  		/* stw R9, <#[R1 + 92]> */
		/* 822675D8h case    8:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x0000005C) );
		/* 822675D8h case    8:*/		return 0x822675DC;
		  /* 822675DCh */ case    9:  		/* addi R3, R1, 88 */
		/* 822675DCh case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x58);
		/* 822675DCh case    9:*/		return 0x822675E0;
		  /* 822675E0h */ case   10:  		/* bl 24040 */
		/* 822675E0h case   10:*/		regs.LR = 0x822675E4; return 0x8226D3C8;
		/* 822675E0h case   10:*/		return 0x822675E4;
		  /* 822675E4h */ case   11:  		/* cmpwi CR0, R3, 0 */
		/* 822675E4h case   11:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 822675E4h case   11:*/		return 0x822675E8;
		  /* 822675E8h */ case   12:  		/* bc 12, CR0_LT, 12 */
		/* 822675E8h case   12:*/		if ( regs.CR[0].lt ) { return 0x822675F4;  }
		/* 822675E8h case   12:*/		return 0x822675EC;
		  /* 822675ECh */ case   13:  		/* lwz R3, <#[R1 + 160]> */
		/* 822675ECh case   13:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x000000A0) );
		/* 822675ECh case   13:*/		return 0x822675F0;
		  /* 822675F0h */ case   14:  		/* b 12 */
		/* 822675F0h case   14:*/		return 0x822675FC;
		/* 822675F0h case   14:*/		return 0x822675F4;
	}
	return 0x822675F4;
} // Block from 822675B8h-822675F4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 822675F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822675F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822675F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822675F4);
		  /* 822675F4h */ case    0:  		/* bl -1953492 */
		/* 822675F4h case    0:*/		regs.LR = 0x822675F8; return 0x8208A720;
		/* 822675F4h case    0:*/		return 0x822675F8;
		  /* 822675F8h */ case    1:  		/* li R3, -1 */
		/* 822675F8h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 822675F8h case    1:*/		return 0x822675FC;
	}
	return 0x822675FC;
} // Block from 822675F4h-822675FCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 822675FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822675FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822675FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822675FC);
		  /* 822675FCh */ case    0:  		/* addi R1, R1, 176 */
		/* 822675FCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 822675FCh case    0:*/		return 0x82267600;
		  /* 82267600h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82267600h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82267600h case    1:*/		return 0x82267604;
		  /* 82267604h */ case    2:  		/* mtspr LR, R12 */
		/* 82267604h case    2:*/		regs.LR = regs.R12;
		/* 82267604h case    2:*/		return 0x82267608;
		  /* 82267608h */ case    3:  		/* bclr 20, CR0_LT */
		/* 82267608h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82267608h case    3:*/		return 0x8226760C;
	}
	return 0x8226760C;
} // Block from 822675FCh-8226760Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226760Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226760C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226760C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226760C);
		  /* 8226760Ch */ case    0:  		/* nop */
		/* 8226760Ch case    0:*/		cpu::op::nop();
		/* 8226760Ch case    0:*/		return 0x82267610;
	}
	return 0x82267610;
} // Block from 8226760Ch-82267610h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82267610h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267610( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267610) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267610);
		  /* 82267610h */ case    0:  		/* mfspr R12, LR */
		/* 82267610h case    0:*/		regs.R12 = regs.LR;
		/* 82267610h case    0:*/		return 0x82267614;
		  /* 82267614h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82267614h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82267614h case    1:*/		return 0x82267618;
		  /* 82267618h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82267618h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82267618h case    2:*/		return 0x8226761C;
		  /* 8226761Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 8226761Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8226761Ch case    3:*/		return 0x82267620;
		  /* 82267620h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82267620h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82267620h case    4:*/		return 0x82267624;
		  /* 82267624h */ case    5:  		/* mr R31, R4 */
		/* 82267624h case    5:*/		regs.R31 = regs.R4;
		/* 82267624h case    5:*/		return 0x82267628;
		  /* 82267628h */ case    6:  		/* mr R6, R4 */
		/* 82267628h case    6:*/		regs.R6 = regs.R4;
		/* 82267628h case    6:*/		return 0x8226762C;
		  /* 8226762Ch */ case    7:  		/* mr R30, R3 */
		/* 8226762Ch case    7:*/		regs.R30 = regs.R3;
		/* 8226762Ch case    7:*/		return 0x82267630;
		  /* 82267630h */ case    8:  		/* mr R4, R3 */
		/* 82267630h case    8:*/		regs.R4 = regs.R3;
		/* 82267630h case    8:*/		return 0x82267634;
		  /* 82267634h */ case    9:  		/* li R7, -1 */
		/* 82267634h case    9:*/		cpu::op::li<0>(regs,&regs.R7,0xFFFFFFFF);
		/* 82267634h case    9:*/		return 0x82267638;
	}
	return 0x82267638;
} // Block from 82267610h-82267638h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82267638h
// Function '?DefIsFixedResource@XGRAPHICS@@YA_NPBVIRInst@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267638( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267638) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267638);
		  /* 82267638h */ case    0:  		/* li R5, -1 */
		/* 82267638h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0xFFFFFFFF);
		/* 82267638h case    0:*/		return 0x8226763C;
		  /* 8226763Ch */ case    1:  		/* li R3, 1 */
		/* 8226763Ch case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8226763Ch case    1:*/		return 0x82267640;
		  /* 82267640h */ case    2:  		/* bl 880 */
		/* 82267640h case    2:*/		regs.LR = 0x82267644; return 0x822679B0;
		/* 82267640h case    2:*/		return 0x82267644;
		  /* 82267644h */ case    3:  		/* cmpwi CR0, R3, 0 */
		/* 82267644h case    3:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82267644h case    3:*/		return 0x82267648;
		  /* 82267648h */ case    4:  		/* bc 4, CR0_EQ, 56 */
		/* 82267648h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82267680;  }
		/* 82267648h case    4:*/		return 0x8226764C;
		  /* 8226764Ch */ case    5:  		/* cmplwi CR6, R30, 0 */
		/* 8226764Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 8226764Ch case    5:*/		return 0x82267650;
		  /* 82267650h */ case    6:  		/* bc 12, CR6_EQ, 36 */
		/* 82267650h case    6:*/		if ( regs.CR[6].eq ) { return 0x82267674;  }
		/* 82267650h case    6:*/		return 0x82267654;
		  /* 82267654h */ case    7:  		/* cmplwi CR6, R31, 0 */
		/* 82267654h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82267654h case    7:*/		return 0x82267658;
		  /* 82267658h */ case    8:  		/* bc 12, CR6_EQ, 20 */
		/* 82267658h case    8:*/		if ( regs.CR[6].eq ) { return 0x8226766C;  }
		/* 82267658h case    8:*/		return 0x8226765C;
		  /* 8226765Ch */ case    9:  		/* mr R4, R31 */
		/* 8226765Ch case    9:*/		regs.R4 = regs.R31;
		/* 8226765Ch case    9:*/		return 0x82267660;
		  /* 82267660h */ case   10:  		/* mr R3, R30 */
		/* 82267660h case   10:*/		regs.R3 = regs.R30;
		/* 82267660h case   10:*/		return 0x82267664;
		  /* 82267664h */ case   11:  		/* bl -1917492 */
		/* 82267664h case   11:*/		regs.LR = 0x82267668; return 0x82093430;
		/* 82267664h case   11:*/		return 0x82267668;
		  /* 82267668h */ case   12:  		/* b 28 */
		/* 82267668h case   12:*/		return 0x82267684;
		/* 82267668h case   12:*/		return 0x8226766C;
	}
	return 0x8226766C;
} // Block from 82267638h-8226766Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8226766Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226766C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226766C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226766C);
		  /* 8226766Ch */ case    0:  		/* li R3, 1 */
		/* 8226766Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 8226766Ch case    0:*/		return 0x82267670;
	}
	return 0x82267670;
} // Block from 8226766Ch-82267670h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82267670h
// Function '?IsRealFetch@XGRAPHICS@@YA_NPBVIRInst@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267670( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267670) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267670);
		  /* 82267670h */ case    0:  		/* b 20 */
		/* 82267670h case    0:*/		return 0x82267684;
		/* 82267670h case    0:*/		return 0x82267674;
	}
	return 0x82267674;
} // Block from 82267670h-82267674h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82267674h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267674( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267674) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267674);
		  /* 82267674h */ case    0:  		/* subfic R11, R31, 0 */
		/* 82267674h case    0:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R31,0x0);
		/* 82267674h case    0:*/		return 0x82267678;
		  /* 82267678h */ case    1:  		/* subfe R3, R11, R11 */
		/* 82267678h case    1:*/		cpu::op::subfe<0>(regs,&regs.R3,regs.R11,regs.R11);
		/* 82267678h case    1:*/		return 0x8226767C;
		  /* 8226767Ch */ case    2:  		/* b 8 */
		/* 8226767Ch case    2:*/		return 0x82267684;
		/* 8226767Ch case    2:*/		return 0x82267680;
	}
	return 0x82267680;
} // Block from 82267674h-82267680h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82267680h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267680( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267680) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267680);
		  /* 82267680h */ case    0:  		/* addi R3, R3, -2 */
		/* 82267680h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0xFFFFFFFE);
		/* 82267680h case    0:*/		return 0x82267684;
	}
	return 0x82267684;
} // Block from 82267680h-82267684h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82267684h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267684( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267684) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267684);
		  /* 82267684h */ case    0:  		/* addi R1, R1, 112 */
		/* 82267684h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82267684h case    0:*/		return 0x82267688;
		  /* 82267688h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82267688h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82267688h case    1:*/		return 0x8226768C;
		  /* 8226768Ch */ case    2:  		/* mtspr LR, R12 */
		/* 8226768Ch case    2:*/		regs.LR = regs.R12;
		/* 8226768Ch case    2:*/		return 0x82267690;
		  /* 82267690h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 82267690h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82267690h case    3:*/		return 0x82267694;
		  /* 82267694h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 82267694h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82267694h case    4:*/		return 0x82267698;
		  /* 82267698h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82267698h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82267698h case    5:*/		return 0x8226769C;
	}
	return 0x8226769C;
} // Block from 82267684h-8226769Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 8226769Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226769C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226769C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226769C);
		  /* 8226769Ch */ case    0:  		/* nop */
		/* 8226769Ch case    0:*/		cpu::op::nop();
		/* 8226769Ch case    0:*/		return 0x822676A0;
	}
	return 0x822676A0;
} // Block from 8226769Ch-822676A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822676A0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822676A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822676A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822676A0);
		  /* 822676A0h */ case    0:  		/* mfspr R12, LR */
		/* 822676A0h case    0:*/		regs.R12 = regs.LR;
		/* 822676A0h case    0:*/		return 0x822676A4;
		  /* 822676A4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 822676A4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822676A4h case    1:*/		return 0x822676A8;
		  /* 822676A8h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 822676A8h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822676A8h case    2:*/		return 0x822676AC;
		  /* 822676ACh */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 822676ACh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 822676ACh case    3:*/		return 0x822676B0;
		  /* 822676B0h */ case    4:  		/* mr R11, R5 */
		/* 822676B0h case    4:*/		regs.R11 = regs.R5;
		/* 822676B0h case    4:*/		return 0x822676B4;
		  /* 822676B4h */ case    5:  		/* mr R4, R6 */
		/* 822676B4h case    5:*/		regs.R4 = regs.R6;
		/* 822676B4h case    5:*/		return 0x822676B8;
		  /* 822676B8h */ case    6:  		/* mr R9, R7 */
		/* 822676B8h case    6:*/		regs.R9 = regs.R7;
		/* 822676B8h case    6:*/		return 0x822676BC;
		  /* 822676BCh */ case    7:  		/* cmplwi CR6, R3, 65001 */
		/* 822676BCh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x0000FDE9);
		/* 822676BCh case    7:*/		return 0x822676C0;
		  /* 822676C0h */ case    8:  		/* bc 4, CR6_EQ, 24 */
		/* 822676C0h case    8:*/		if ( !regs.CR[6].eq ) { return 0x822676D8;  }
		/* 822676C0h case    8:*/		return 0x822676C4;
		  /* 822676C4h */ case    9:  		/* mr R6, R8 */
		/* 822676C4h case    9:*/		regs.R6 = regs.R8;
		/* 822676C4h case    9:*/		return 0x822676C8;
		  /* 822676C8h */ case   10:  		/* mr R5, R7 */
		/* 822676C8h case   10:*/		regs.R5 = regs.R7;
		/* 822676C8h case   10:*/		return 0x822676CC;
		  /* 822676CCh */ case   11:  		/* mr R3, R11 */
		/* 822676CCh case   11:*/		regs.R3 = regs.R11;
		/* 822676CCh case   11:*/		return 0x822676D0;
	}
	return 0x822676D0;
} // Block from 822676A0h-822676D0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 822676D0h
// Function '?IsTexturePipeYieldDisabler@XGRAPHICS@@YA_NPBVIRInst@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822676D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822676D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822676D0);
		  /* 822676D0h */ case    0:  		/* bl 1208 */
		/* 822676D0h case    0:*/		regs.LR = 0x822676D4; return 0x82267B88;
		/* 822676D0h case    0:*/		return 0x822676D4;
		  /* 822676D4h */ case    1:  		/* b 140 */
		/* 822676D4h case    1:*/		return 0x82267760;
		/* 822676D4h case    1:*/		return 0x822676D8;
	}
	return 0x822676D8;
} // Block from 822676D0h-822676D8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822676D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822676D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822676D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822676D8);
		  /* 822676D8h */ case    0:  		/* cmpwi CR6, R4, -1 */
		/* 822676D8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R4,0xFFFFFFFF);
		/* 822676D8h case    0:*/		return 0x822676DC;
		  /* 822676DCh */ case    1:  		/* bc 4, CR6_EQ, 44 */
		/* 822676DCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x82267708;  }
		/* 822676DCh case    1:*/		return 0x822676E0;
		  /* 822676E0h */ case    2:  		/* mr R10, R11 */
		/* 822676E0h case    2:*/		regs.R10 = regs.R11;
		/* 822676E0h case    2:*/		return 0x822676E4;
		  /* 822676E4h */ case    3:  		/* lbz R7, <#[R10]> */
		/* 822676E4h case    3:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 822676E4h case    3:*/		return 0x822676E8;
		  /* 822676E8h */ case    4:  		/* addi R10, R10, 1 */
		/* 822676E8h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 822676E8h case    4:*/		return 0x822676EC;
		  /* 822676ECh */ case    5:  		/* cmplwi CR6, R7, 0 */
		/* 822676ECh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 822676ECh case    5:*/		return 0x822676F0;
		  /* 822676F0h */ case    6:  		/* bc 4, CR6_EQ, -12 */
		/* 822676F0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x822676E4;  }
		/* 822676F0h case    6:*/		return 0x822676F4;
		  /* 822676F4h */ case    7:  		/* subf R10, R11, R10 */
		/* 822676F4h case    7:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 822676F4h case    7:*/		return 0x822676F8;
		  /* 822676F8h */ case    8:  		/* addi R10, R10, -1 */
		/* 822676F8h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 822676F8h case    8:*/		return 0x822676FC;
		  /* 822676FCh */ case    9:  		/* rlwinm R10, R10, 0, 0, 31 */
		/* 822676FCh case    9:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R10);
		/* 822676FCh case    9:*/		return 0x82267700;
		  /* 82267700h */ case   10:  		/* addi R31, R10, 1 */
		/* 82267700h case   10:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R10,0x1);
		/* 82267700h case   10:*/		return 0x82267704;
		  /* 82267704h */ case   11:  		/* b 8 */
		/* 82267704h case   11:*/		return 0x8226770C;
		/* 82267704h case   11:*/		return 0x82267708;
	}
	return 0x82267708;
} // Block from 822676D8h-82267708h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82267708h
// Function '?IsShaderPipeYieldDisabler@XGRAPHICS@@YA_NPBVIRInst@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267708( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267708) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267708);
		  /* 82267708h */ case    0:  		/* mr R31, R4 */
		/* 82267708h case    0:*/		regs.R31 = regs.R4;
		/* 82267708h case    0:*/		return 0x8226770C;
	}
	return 0x8226770C;
} // Block from 82267708h-8226770Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226770Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226770C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226770C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226770C);
		  /* 8226770Ch */ case    0:  		/* cmpwi CR6, R8, 0 */
		/* 8226770Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 8226770Ch case    0:*/		return 0x82267710;
		  /* 82267710h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 82267710h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8226771C;  }
		/* 82267710h case    1:*/		return 0x82267714;
		  /* 82267714h */ case    2:  		/* mr R3, R31 */
		/* 82267714h case    2:*/		regs.R3 = regs.R31;
		/* 82267714h case    2:*/		return 0x82267718;
		  /* 82267718h */ case    3:  		/* b 72 */
		/* 82267718h case    3:*/		return 0x82267760;
		/* 82267718h case    3:*/		return 0x8226771C;
	}
	return 0x8226771C;
} // Block from 8226770Ch-8226771Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226771Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226771C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226771C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226771C);
		  /* 8226771Ch */ case    0:  		/* cmpwi CR6, R31, 0 */
		/* 8226771Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000000);
		/* 8226771Ch case    0:*/		return 0x82267720;
		  /* 82267720h */ case    1:  		/* bc 12, CR6_LT, 52 */
		/* 82267720h case    1:*/		if ( regs.CR[6].lt ) { return 0x82267754;  }
		/* 82267720h case    1:*/		return 0x82267724;
		  /* 82267724h */ case    2:  		/* cmpw CR6, R8, R31 */
		/* 82267724h case    2:*/		cpu::op::cmpw<6>(regs,regs.R8,regs.R31);
		/* 82267724h case    2:*/		return 0x82267728;
		  /* 82267728h */ case    3:  		/* bc 12, CR6_LT, 44 */
		/* 82267728h case    3:*/		if ( regs.CR[6].lt ) { return 0x82267754;  }
		/* 82267728h case    3:*/		return 0x8226772C;
		  /* 8226772Ch */ case    4:  		/* mr R7, R31 */
		/* 8226772Ch case    4:*/		regs.R7 = regs.R31;
		/* 8226772Ch case    4:*/		return 0x82267730;
		  /* 82267730h */ case    5:  		/* mr R6, R11 */
		/* 82267730h case    5:*/		regs.R6 = regs.R11;
		/* 82267730h case    5:*/		return 0x82267734;
		  /* 82267734h */ case    6:  		/* li R5, 0 */
		/* 82267734h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82267734h case    6:*/		return 0x82267738;
		  /* 82267738h */ case    7:  		/* rlwinm R4, R8, 1, 0, 30 */
		/* 82267738h case    7:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R4,regs.R8);
		/* 82267738h case    7:*/		return 0x8226773C;
		  /* 8226773Ch */ case    8:  		/* mr R3, R9 */
		/* 8226773Ch case    8:*/		regs.R3 = regs.R9;
		/* 8226773Ch case    8:*/		return 0x82267740;
		  /* 82267740h */ case    9:  		/* bl 24168 */
		/* 82267740h case    9:*/		regs.LR = 0x82267744; return 0x8226D5A8;
		/* 82267740h case    9:*/		return 0x82267744;
		  /* 82267744h */ case   10:  		/* cmpwi CR0, R3, 0 */
		/* 82267744h case   10:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82267744h case   10:*/		return 0x82267748;
	}
	return 0x82267748;
} // Block from 8226771Ch-82267748h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82267748h
// Function '?Latency@XGRAPHICS@@YAHPBVIRInst@1@0HHW4DepType@1@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267748( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267748) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267748);
		  /* 82267748h */ case    0:  		/* bc 4, CR0_LT, -52 */
		/* 82267748h case    0:*/		if ( !regs.CR[0].lt ) { return 0x82267714;  }
		/* 82267748h case    0:*/		return 0x8226774C;
		  /* 8226774Ch */ case    1:  		/* bl 23660 */
		/* 8226774Ch case    1:*/		regs.LR = 0x82267750; return 0x8226D3B8;
		/* 8226774Ch case    1:*/		return 0x82267750;
		  /* 82267750h */ case    2:  		/* b 8 */
		/* 82267750h case    2:*/		return 0x82267758;
		/* 82267750h case    2:*/		return 0x82267754;
	}
	return 0x82267754;
} // Block from 82267748h-82267754h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82267754h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267754( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267754) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267754);
		  /* 82267754h */ case    0:  		/* li R3, 122 */
		/* 82267754h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x7A);
		/* 82267754h case    0:*/		return 0x82267758;
	}
	return 0x82267758;
} // Block from 82267754h-82267758h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82267758h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267758( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267758) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267758);
		  /* 82267758h */ case    0:  		/* bl -1953888 */
		/* 82267758h case    0:*/		regs.LR = 0x8226775C; return 0x8208A6F8;
		/* 82267758h case    0:*/		return 0x8226775C;
		  /* 8226775Ch */ case    1:  		/* li R3, 0 */
		/* 8226775Ch case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8226775Ch case    1:*/		return 0x82267760;
	}
	return 0x82267760;
} // Block from 82267758h-82267760h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82267760h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267760( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267760) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267760);
		  /* 82267760h */ case    0:  		/* addi R1, R1, 96 */
		/* 82267760h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82267760h case    0:*/		return 0x82267764;
		  /* 82267764h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82267764h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82267764h case    1:*/		return 0x82267768;
		  /* 82267768h */ case    2:  		/* mtspr LR, R12 */
		/* 82267768h case    2:*/		regs.LR = regs.R12;
		/* 82267768h case    2:*/		return 0x8226776C;
		  /* 8226776Ch */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 8226776Ch case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8226776Ch case    3:*/		return 0x82267770;
		  /* 82267770h */ case    4:  		/* bclr 20, CR0_LT */
		/* 82267770h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82267770h case    4:*/		return 0x82267774;
	}
	return 0x82267774;
} // Block from 82267760h-82267774h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82267774h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267774( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267774) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267774);
		  /* 82267774h */ case    0:  		/* nop */
		/* 82267774h case    0:*/		cpu::op::nop();
		/* 82267774h case    0:*/		return 0x82267778;
	}
	return 0x82267778;
} // Block from 82267774h-82267778h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82267778h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267778( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267778) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267778);
		  /* 82267778h */ case    0:  		/* mfspr R12, LR */
		/* 82267778h case    0:*/		regs.R12 = regs.LR;
		/* 82267778h case    0:*/		return 0x8226777C;
		  /* 8226777Ch */ case    1:  		/* bl -1926432 */
		/* 8226777Ch case    1:*/		regs.LR = 0x82267780; return 0x8209125C;
		/* 8226777Ch case    1:*/		return 0x82267780;
		  /* 82267780h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 82267780h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 82267780h case    2:*/		return 0x82267784;
		  /* 82267784h */ case    3:  		/* lis R11, -32217 */
		/* 82267784h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82267784h case    3:*/		return 0x82267788;
		  /* 82267788h */ case    4:  		/* mr R31, R4 */
		/* 82267788h case    4:*/		regs.R31 = regs.R4;
		/* 82267788h case    4:*/		return 0x8226778C;
		  /* 8226778Ch */ case    5:  		/* mr R30, R5 */
		/* 8226778Ch case    5:*/		regs.R30 = regs.R5;
		/* 8226778Ch case    5:*/		return 0x82267790;
		  /* 82267790h */ case    6:  		/* mr R29, R6 */
		/* 82267790h case    6:*/		regs.R29 = regs.R6;
		/* 82267790h case    6:*/		return 0x82267794;
		  /* 82267794h */ case    7:  		/* li R7, 34 */
		/* 82267794h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x22);
		/* 82267794h case    7:*/		return 0x82267798;
		  /* 82267798h */ case    8:  		/* lwz R11, <#[R11 + 6896]> */
		/* 82267798h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00001AF0) );
		/* 82267798h case    8:*/		return 0x8226779C;
		  /* 8226779Ch */ case    9:  		/* li R6, 56 */
		/* 8226779Ch case    9:*/		cpu::op::li<0>(regs,&regs.R6,0x38);
		/* 8226779Ch case    9:*/		return 0x822677A0;
		  /* 822677A0h */ case   10:  		/* addi R5, R1, 96 */
		/* 822677A0h case   10:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x60);
		/* 822677A0h case   10:*/		return 0x822677A4;
		  /* 822677A4h */ case   11:  		/* addi R4, R1, 80 */
		/* 822677A4h case   11:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 822677A4h case   11:*/		return 0x822677A8;
		  /* 822677A8h */ case   12:  		/* lwz R11, <#[R11 + 32]> */
		/* 822677A8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000020) );
		/* 822677A8h case   12:*/		return 0x822677AC;
		  /* 822677ACh */ case   13:  		/* mtspr CTR, R11 */
		/* 822677ACh case   13:*/		regs.CTR = regs.R11;
		/* 822677ACh case   13:*/		return 0x822677B0;
		  /* 822677B0h */ case   14:  		/* bcctrl 20, CR0_LT */
		/* 822677B0h case   14:*/		if ( 1 ) { regs.LR = 0x822677B4; return (uint32)regs.CTR; }
		/* 822677B0h case   14:*/		return 0x822677B4;
		  /* 822677B4h */ case   15:  		/* cmpwi CR0, R3, 0 */
		/* 822677B4h case   15:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 822677B4h case   15:*/		return 0x822677B8;
		  /* 822677B8h */ case   16:  		/* bc 12, CR0_LT, 60 */
		/* 822677B8h case   16:*/		if ( regs.CR[0].lt ) { return 0x822677F4;  }
		/* 822677B8h case   16:*/		return 0x822677BC;
		  /* 822677BCh */ case   17:  		/* cmplwi CR6, R31, 0 */
		/* 822677BCh case   17:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 822677BCh case   17:*/		return 0x822677C0;
		  /* 822677C0h */ case   18:  		/* bc 12, CR6_EQ, 12 */
		/* 822677C0h case   18:*/		if ( regs.CR[6].eq ) { return 0x822677CC;  }
		/* 822677C0h case   18:*/		return 0x822677C4;
		  /* 822677C4h */ case   19:  		/* ld R11, <#[R1 + 96]> */
		/* 822677C4h case   19:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 822677C4h case   19:*/		return 0x822677C8;
		  /* 822677C8h */ case   20:  		/* std R11, <#[R31]> */
		/* 822677C8h case   20:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822677C8h case   20:*/		return 0x822677CC;
	}
	return 0x822677CC;
} // Block from 82267778h-822677CCh (21 instructions)

//////////////////////////////////////////////////////
// Block at 822677CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822677CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822677CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822677CC);
		  /* 822677CCh */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 822677CCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 822677CCh case    0:*/		return 0x822677D0;
		  /* 822677D0h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 822677D0h case    1:*/		if ( regs.CR[6].eq ) { return 0x822677DC;  }
		/* 822677D0h case    1:*/		return 0x822677D4;
		  /* 822677D4h */ case    2:  		/* ld R11, <#[R1 + 104]> */
		/* 822677D4h case    2:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R1 + 0x00000068) );
		/* 822677D4h case    2:*/		return 0x822677D8;
		  /* 822677D8h */ case    3:  		/* std R11, <#[R30]> */
		/* 822677D8h case    3:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 822677D8h case    3:*/		return 0x822677DC;
	}
	return 0x822677DC;
} // Block from 822677CCh-822677DCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 822677DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822677DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822677DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822677DC);
		  /* 822677DCh */ case    0:  		/* cmplwi CR6, R29, 0 */
		/* 822677DCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 822677DCh case    0:*/		return 0x822677E0;
		  /* 822677E0h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 822677E0h case    1:*/		if ( regs.CR[6].eq ) { return 0x822677EC;  }
		/* 822677E0h case    1:*/		return 0x822677E4;
		  /* 822677E4h */ case    2:  		/* ld R11, <#[R1 + 112]> */
		/* 822677E4h case    2:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R1 + 0x00000070) );
		/* 822677E4h case    2:*/		return 0x822677E8;
		  /* 822677E8h */ case    3:  		/* std R11, <#[R29]> */
		/* 822677E8h case    3:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 822677E8h case    3:*/		return 0x822677EC;
	}
	return 0x822677EC;
} // Block from 822677DCh-822677ECh (4 instructions)

//////////////////////////////////////////////////////
// Block at 822677ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822677EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822677EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822677EC);
		  /* 822677ECh */ case    0:  		/* li R3, 1 */
		/* 822677ECh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 822677ECh case    0:*/		return 0x822677F0;
		  /* 822677F0h */ case    1:  		/* b 12 */
		/* 822677F0h case    1:*/		return 0x822677FC;
		/* 822677F0h case    1:*/		return 0x822677F4;
	}
	return 0x822677F4;
} // Block from 822677ECh-822677F4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822677F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822677F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822677F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822677F4);
		  /* 822677F4h */ case    0:  		/* bl -1954004 */
		/* 822677F4h case    0:*/		regs.LR = 0x822677F8; return 0x8208A720;
		/* 822677F4h case    0:*/		return 0x822677F8;
		  /* 822677F8h */ case    1:  		/* li R3, 0 */
		/* 822677F8h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822677F8h case    1:*/		return 0x822677FC;
	}
	return 0x822677FC;
} // Block from 822677F4h-822677FCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 822677FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822677FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822677FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822677FC);
		  /* 822677FCh */ case    0:  		/* addi R1, R1, 192 */
		/* 822677FCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 822677FCh case    0:*/		return 0x82267800;
		  /* 82267800h */ case    1:  		/* b -1926484 */
		/* 82267800h case    1:*/		return 0x820912AC;
		/* 82267800h case    1:*/		return 0x82267804;
		  /* 82267804h */ case    2:  		/* nop */
		/* 82267804h case    2:*/		cpu::op::nop();
		/* 82267804h case    2:*/		return 0x82267808;
	}
	return 0x82267808;
} // Block from 822677FCh-82267808h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82267808h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267808( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267808) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267808);
		  /* 82267808h */ case    0:  		/* mfspr R12, LR */
		/* 82267808h case    0:*/		regs.R12 = regs.LR;
		/* 82267808h case    0:*/		return 0x8226780C;
		  /* 8226780Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8226780Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8226780Ch case    1:*/		return 0x82267810;
		  /* 82267810h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82267810h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82267810h case    2:*/		return 0x82267814;
		  /* 82267814h */ case    3:  		/* stwu R1, <#[R1 - 176]> */
		/* 82267814h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 82267814h case    3:*/		return 0x82267818;
		  /* 82267818h */ case    4:  		/* lis R11, -32217 */
		/* 82267818h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82267818h case    4:*/		return 0x8226781C;
		  /* 8226781Ch */ case    5:  		/* mr R31, R4 */
		/* 8226781Ch case    5:*/		regs.R31 = regs.R4;
		/* 8226781Ch case    5:*/		return 0x82267820;
		  /* 82267820h */ case    6:  		/* li R7, 34 */
		/* 82267820h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x22);
		/* 82267820h case    6:*/		return 0x82267824;
		  /* 82267824h */ case    7:  		/* li R6, 56 */
		/* 82267824h case    7:*/		cpu::op::li<0>(regs,&regs.R6,0x38);
		/* 82267824h case    7:*/		return 0x82267828;
		  /* 82267828h */ case    8:  		/* addi R5, R1, 96 */
		/* 82267828h case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x60);
		/* 82267828h case    8:*/		return 0x8226782C;
		  /* 8226782Ch */ case    9:  		/* lwz R11, <#[R11 + 6896]> */
		/* 8226782Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00001AF0) );
		/* 8226782Ch case    9:*/		return 0x82267830;
		  /* 82267830h */ case   10:  		/* addi R4, R1, 80 */
		/* 82267830h case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 82267830h case   10:*/		return 0x82267834;
		  /* 82267834h */ case   11:  		/* lwz R11, <#[R11 + 32]> */
		/* 82267834h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000020) );
		/* 82267834h case   11:*/		return 0x82267838;
		  /* 82267838h */ case   12:  		/* mtspr CTR, R11 */
		/* 82267838h case   12:*/		regs.CTR = regs.R11;
		/* 82267838h case   12:*/		return 0x8226783C;
		  /* 8226783Ch */ case   13:  		/* bcctrl 20, CR0_LT */
		/* 8226783Ch case   13:*/		if ( 1 ) { regs.LR = 0x82267840; return (uint32)regs.CTR; }
		/* 8226783Ch case   13:*/		return 0x82267840;
		  /* 82267840h */ case   14:  		/* cmpwi CR0, R3, 0 */
		/* 82267840h case   14:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82267840h case   14:*/		return 0x82267844;
		  /* 82267844h */ case   15:  		/* bc 4, CR0_LT, 16 */
		/* 82267844h case   15:*/		if ( !regs.CR[0].lt ) { return 0x82267854;  }
		/* 82267844h case   15:*/		return 0x82267848;
		  /* 82267848h */ case   16:  		/* bl -1954088 */
		/* 82267848h case   16:*/		regs.LR = 0x8226784C; return 0x8208A720;
		/* 82267848h case   16:*/		return 0x8226784C;
		  /* 8226784Ch */ case   17:  		/* li R3, 0 */
		/* 8226784Ch case   17:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 8226784Ch case   17:*/		return 0x82267850;
	}
	return 0x82267850;
} // Block from 82267808h-82267850h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82267850h
// Function '?Find@XGRAPHICS@@YAHHPAH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267850( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267850) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267850);
		  /* 82267850h */ case    0:  		/* b 16 */
		/* 82267850h case    0:*/		return 0x82267860;
		/* 82267850h case    0:*/		return 0x82267854;
	}
	return 0x82267854;
} // Block from 82267850h-82267854h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82267854h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267854( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267854) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267854);
		  /* 82267854h */ case    0:  		/* ld R11, <#[R1 + 136]> */
		/* 82267854h case    0:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R1 + 0x00000088) );
		/* 82267854h case    0:*/		return 0x82267858;
		  /* 82267858h */ case    1:  		/* li R3, 1 */
		/* 82267858h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82267858h case    1:*/		return 0x8226785C;
		  /* 8226785Ch */ case    2:  		/* std R11, <#[R31]> */
		/* 8226785Ch case    2:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8226785Ch case    2:*/		return 0x82267860;
	}
	return 0x82267860;
} // Block from 82267854h-82267860h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82267860h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267860( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267860) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267860);
		  /* 82267860h */ case    0:  		/* addi R1, R1, 176 */
		/* 82267860h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 82267860h case    0:*/		return 0x82267864;
		  /* 82267864h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82267864h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82267864h case    1:*/		return 0x82267868;
		  /* 82267868h */ case    2:  		/* mtspr LR, R12 */
		/* 82267868h case    2:*/		regs.LR = regs.R12;
		/* 82267868h case    2:*/		return 0x8226786C;
		  /* 8226786Ch */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 8226786Ch case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8226786Ch case    3:*/		return 0x82267870;
		  /* 82267870h */ case    4:  		/* bclr 20, CR0_LT */
		/* 82267870h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82267870h case    4:*/		return 0x82267874;
	}
	return 0x82267874;
} // Block from 82267860h-82267874h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82267874h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267874( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267874) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267874);
		  /* 82267874h */ case    0:  		/* nop */
		/* 82267874h case    0:*/		cpu::op::nop();
		/* 82267874h case    0:*/		return 0x82267878;
	}
	return 0x82267878;
} // Block from 82267874h-82267878h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82267878h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267878( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267878) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267878);
		  /* 82267878h */ case    0:  		/* mfspr R12, LR */
		/* 82267878h case    0:*/		regs.R12 = regs.LR;
		/* 82267878h case    0:*/		return 0x8226787C;
		  /* 8226787Ch */ case    1:  		/* bl -1926692 */
		/* 8226787Ch case    1:*/		regs.LR = 0x82267880; return 0x82091258;
		/* 8226787Ch case    1:*/		return 0x82267880;
		  /* 82267880h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82267880h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82267880h case    2:*/		return 0x82267884;
		  /* 82267884h */ case    3:  		/* mr R28, R3 */
		/* 82267884h case    3:*/		regs.R28 = regs.R3;
		/* 82267884h case    3:*/		return 0x82267888;
		  /* 82267888h */ case    4:  		/* mr R31, R5 */
		/* 82267888h case    4:*/		regs.R31 = regs.R5;
		/* 82267888h case    4:*/		return 0x8226788C;
		  /* 8226788Ch */ case    5:  		/* mr R29, R6 */
		/* 8226788Ch case    5:*/		regs.R29 = regs.R6;
		/* 8226788Ch case    5:*/		return 0x82267890;
		  /* 82267890h */ case    6:  		/* li R30, 0 */
		/* 82267890h case    6:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 82267890h case    6:*/		return 0x82267894;
		  /* 82267894h */ case    7:  		/* cmpwi CR6, R4, -1 */
		/* 82267894h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R4,0xFFFFFFFF);
		/* 82267894h case    7:*/		return 0x82267898;
		  /* 82267898h */ case    8:  		/* bc 4, CR6_EQ, 12 */
		/* 82267898h case    8:*/		if ( !regs.CR[6].eq ) { return 0x822678A4;  }
		/* 82267898h case    8:*/		return 0x8226789C;
		  /* 8226789Ch */ case    9:  		/* bl -1917084 */
		/* 8226789Ch case    9:*/		regs.LR = 0x822678A0; return 0x82093800;
		/* 8226789Ch case    9:*/		return 0x822678A0;
		  /* 822678A0h */ case   10:  		/* addi R4, R3, 1 */
		/* 822678A0h case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R3,0x1);
		/* 822678A0h case   10:*/		return 0x822678A4;
	}
	return 0x822678A4;
} // Block from 82267878h-822678A4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 822678A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822678A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822678A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822678A4);
		  /* 822678A4h */ case    0:  		/* cmpwi CR6, R4, 0 */
		/* 822678A4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000000);
		/* 822678A4h case    0:*/		return 0x822678A8;
		  /* 822678A8h */ case    1:  		/* bc 4, CR6_GT, 216 */
		/* 822678A8h case    1:*/		if ( !regs.CR[6].gt ) { return 0x82267980;  }
		/* 822678A8h case    1:*/		return 0x822678AC;
		  /* 822678ACh */ case    2:  		/* mtspr CTR, R4 */
		/* 822678ACh case    2:*/		regs.CTR = regs.R4;
		/* 822678ACh case    2:*/		return 0x822678B0;
	}
	return 0x822678B0;
} // Block from 822678A4h-822678B0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822678B0h
// Function '?Union@XGRAPHICS@@YAXHHPAH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822678B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822678B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822678B0);
		  /* 822678B0h */ case    0:  		/* li R9, 1 */
		/* 822678B0h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 822678B0h case    0:*/		return 0x822678B4;
		  /* 822678B4h */ case    1:  		/* lhz R10, <#[R28]> */
		/* 822678B4h case    1:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000000) );
		/* 822678B4h case    1:*/		return 0x822678B8;
		  /* 822678B8h */ case    2:  		/* mr R11, R10 */
		/* 822678B8h case    2:*/		regs.R11 = regs.R10;
		/* 822678B8h case    2:*/		return 0x822678BC;
		  /* 822678BCh */ case    3:  		/* cmplwi CR6, R10, 127 */
		/* 822678BCh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000007F);
		/* 822678BCh case    3:*/		return 0x822678C0;
	}
	return 0x822678C0;
} // Block from 822678B0h-822678C0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822678C0h
// Function '?Mask@ILFormatDecode@XGRAPHICS@@SAHPBTIL_Dst@2@H@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822678C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822678C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822678C0);
		  /* 822678C0h */ case    0:  		/* bc 12, CR6_GT, 36 */
		/* 822678C0h case    0:*/		if ( regs.CR[6].gt ) { return 0x822678E4;  }
		/* 822678C0h case    0:*/		return 0x822678C4;
		  /* 822678C4h */ case    1:  		/* addi R30, R30, 1 */
		/* 822678C4h case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 822678C4h case    1:*/		return 0x822678C8;
		  /* 822678C8h */ case    2:  		/* cmpw CR6, R30, R29 */
		/* 822678C8h case    2:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R29);
		/* 822678C8h case    2:*/		return 0x822678CC;
		  /* 822678CCh */ case    3:  		/* bc 12, CR6_GT, 172 */
		/* 822678CCh case    3:*/		if ( regs.CR[6].gt ) { return 0x82267978;  }
		/* 822678CCh case    3:*/		return 0x822678D0;
		  /* 822678D0h */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 822678D0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 822678D0h case    4:*/		return 0x822678D4;
		  /* 822678D4h */ case    5:  		/* bc 12, CR6_EQ, 164 */
		/* 822678D4h case    5:*/		if ( regs.CR[6].eq ) { return 0x82267978;  }
		/* 822678D4h case    5:*/		return 0x822678D8;
		  /* 822678D8h */ case    6:  		/* rlwinm R11, R10, 0, 24, 31 */
		/* 822678D8h case    6:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R10);
		/* 822678D8h case    6:*/		return 0x822678DC;
		  /* 822678DCh */ case    7:  		/* stb R11, <#[R31]> */
		/* 822678DCh case    7:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 822678DCh case    7:*/		return 0x822678E0;
		  /* 822678E0h */ case    8:  		/* b 148 */
		/* 822678E0h case    8:*/		return 0x82267974;
		/* 822678E0h case    8:*/		return 0x822678E4;
	}
	return 0x822678E4;
} // Block from 822678C0h-822678E4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 822678E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822678E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822678E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822678E4);
		  /* 822678E4h */ case    0:  		/* cmplwi CR6, R11, 2047 */
		/* 822678E4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x000007FF);
		/* 822678E4h case    0:*/		return 0x822678E8;
		  /* 822678E8h */ case    1:  		/* addi R11, R30, 1 */
		/* 822678E8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x1);
		/* 822678E8h case    1:*/		return 0x822678EC;
		  /* 822678ECh */ case    2:  		/* bc 12, CR6_GT, 32 */
		/* 822678ECh case    2:*/		if ( regs.CR[6].gt ) { return 0x8226790C;  }
		/* 822678ECh case    2:*/		return 0x822678F0;
		  /* 822678F0h */ case    3:  		/* cmpw CR6, R11, R29 */
		/* 822678F0h case    3:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R29);
		/* 822678F0h case    3:*/		return 0x822678F4;
		  /* 822678F4h */ case    4:  		/* bc 12, CR6_GT, 96 */
		/* 822678F4h case    4:*/		if ( regs.CR[6].gt ) { return 0x82267954;  }
		/* 822678F4h case    4:*/		return 0x822678F8;
		  /* 822678F8h */ case    5:  		/* cmplwi CR6, R31, 0 */
		/* 822678F8h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 822678F8h case    5:*/		return 0x822678FC;
		  /* 822678FCh */ case    6:  		/* bc 12, CR6_EQ, 88 */
		/* 822678FCh case    6:*/		if ( regs.CR[6].eq ) { return 0x82267954;  }
		/* 822678FCh case    6:*/		return 0x82267900;
		  /* 82267900h */ case    7:  		/* li R8, 192 */
		/* 82267900h case    7:*/		cpu::op::li<0>(regs,&regs.R8,0xC0);
		/* 82267900h case    7:*/		return 0x82267904;
		  /* 82267904h */ case    8:  		/* rlwimi R8, R10, 26, 27, 31 */
		/* 82267904h case    8:*/		cpu::op::rlwimi<0,26,27,31>(regs,&regs.R8,regs.R10);
		/* 82267904h case    8:*/		return 0x82267908;
		  /* 82267908h */ case    9:  		/* b 68 */
		/* 82267908h case    9:*/		return 0x8226794C;
		/* 82267908h case    9:*/		return 0x8226790C;
	}
	return 0x8226790C;
} // Block from 822678E4h-8226790Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8226790Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226790C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226790C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226790C);
		  /* 8226790Ch */ case    0:  		/* cmpw CR6, R11, R29 */
		/* 8226790Ch case    0:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R29);
		/* 8226790Ch case    0:*/		return 0x82267910;
		  /* 82267910h */ case    1:  		/* bc 12, CR6_GT, 28 */
		/* 82267910h case    1:*/		if ( regs.CR[6].gt ) { return 0x8226792C;  }
		/* 82267910h case    1:*/		return 0x82267914;
		  /* 82267914h */ case    2:  		/* cmplwi CR6, R31, 0 */
		/* 82267914h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82267914h case    2:*/		return 0x82267918;
		  /* 82267918h */ case    3:  		/* bc 12, CR6_EQ, 20 */
		/* 82267918h case    3:*/		if ( regs.CR[6].eq ) { return 0x8226792C;  }
		/* 82267918h case    3:*/		return 0x8226791C;
		  /* 8226791Ch */ case    4:  		/* li R8, 224 */
		/* 8226791Ch case    4:*/		cpu::op::li<0>(regs,&regs.R8,0xE0);
		/* 8226791Ch case    4:*/		return 0x82267920;
	}
	return 0x82267920;
} // Block from 8226790Ch-82267920h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82267920h
// Function '?Swizzle@ILFormatDecode@XGRAPHICS@@SAHPBTIL_Src@2@H@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267920( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267920) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267920);
		  /* 82267920h */ case    0:  		/* rlwimi R8, R10, 20, 28, 31 */
		/* 82267920h case    0:*/		cpu::op::rlwimi<0,20,28,31>(regs,&regs.R8,regs.R10);
		/* 82267920h case    0:*/		return 0x82267924;
		  /* 82267924h */ case    1:  		/* stb R8, <#[R31]> */
		/* 82267924h case    1:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 82267924h case    1:*/		return 0x82267928;
		  /* 82267928h */ case    2:  		/* addi R31, R31, 1 */
		/* 82267928h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82267928h case    2:*/		return 0x8226792C;
	}
	return 0x8226792C;
} // Block from 82267920h-8226792Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8226792Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226792C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226792C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226792C);
		  /* 8226792Ch */ case    0:  		/* addi R11, R11, 1 */
		/* 8226792Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8226792Ch case    0:*/		return 0x82267930;
		  /* 82267930h */ case    1:  		/* cmpw CR6, R11, R29 */
		/* 82267930h case    1:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R29);
		/* 82267930h case    1:*/		return 0x82267934;
		  /* 82267934h */ case    2:  		/* bc 12, CR6_GT, 32 */
		/* 82267934h case    2:*/		if ( regs.CR[6].gt ) { return 0x82267954;  }
		/* 82267934h case    2:*/		return 0x82267938;
		  /* 82267938h */ case    3:  		/* cmplwi CR6, R31, 0 */
		/* 82267938h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82267938h case    3:*/		return 0x8226793C;
		  /* 8226793Ch */ case    4:  		/* bc 12, CR6_EQ, 24 */
		/* 8226793Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x82267954;  }
		/* 8226793Ch case    4:*/		return 0x82267940;
		  /* 82267940h */ case    5:  		/* lhz R10, <#[R28]> */
		/* 82267940h case    5:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000000) );
		/* 82267940h case    5:*/		return 0x82267944;
		  /* 82267944h */ case    6:  		/* li R8, 128 */
		/* 82267944h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x80);
		/* 82267944h case    6:*/		return 0x82267948;
		  /* 82267948h */ case    7:  		/* rlwimi R8, R10, 26, 26, 31 */
		/* 82267948h case    7:*/		cpu::op::rlwimi<0,26,26,31>(regs,&regs.R8,regs.R10);
		/* 82267948h case    7:*/		return 0x8226794C;
	}
	return 0x8226794C;
} // Block from 8226792Ch-8226794Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8226794Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226794C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226794C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226794C);
		  /* 8226794Ch */ case    0:  		/* stb R8, <#[R31]> */
		/* 8226794Ch case    0:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 8226794Ch case    0:*/		return 0x82267950;
		  /* 82267950h */ case    1:  		/* addi R31, R31, 1 */
		/* 82267950h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82267950h case    1:*/		return 0x82267954;
	}
	return 0x82267954;
} // Block from 8226794Ch-82267954h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82267954h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267954( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267954) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267954);
		  /* 82267954h */ case    0:  		/* addi R30, R11, 1 */
		/* 82267954h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0x1);
		/* 82267954h case    0:*/		return 0x82267958;
		  /* 82267958h */ case    1:  		/* cmpw CR6, R30, R29 */
		/* 82267958h case    1:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R29);
		/* 82267958h case    1:*/		return 0x8226795C;
		  /* 8226795Ch */ case    2:  		/* bc 12, CR6_GT, 28 */
		/* 8226795Ch case    2:*/		if ( regs.CR[6].gt ) { return 0x82267978;  }
		/* 8226795Ch case    2:*/		return 0x82267960;
		  /* 82267960h */ case    3:  		/* cmplwi CR6, R31, 0 */
		/* 82267960h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82267960h case    3:*/		return 0x82267964;
		  /* 82267964h */ case    4:  		/* bc 12, CR6_EQ, 20 */
		/* 82267964h case    4:*/		if ( regs.CR[6].eq ) { return 0x82267978;  }
		/* 82267964h case    4:*/		return 0x82267968;
		  /* 82267968h */ case    5:  		/* lhz R11, <#[R28]> */
		/* 82267968h case    5:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 82267968h case    5:*/		return 0x8226796C;
		  /* 8226796Ch */ case    6:  		/* rlwimi R11, R9, 7, 0, 25 */
		/* 8226796Ch case    6:*/		cpu::op::rlwimi<0,7,0,25>(regs,&regs.R11,regs.R9);
		/* 8226796Ch case    6:*/		return 0x82267970;
		  /* 82267970h */ case    7:  		/* stb R11, <#[R31]> */
		/* 82267970h case    7:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82267970h case    7:*/		return 0x82267974;
	}
	return 0x82267974;
} // Block from 82267954h-82267974h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82267974h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267974( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267974) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267974);
		  /* 82267974h */ case    0:  		/* addi R31, R31, 1 */
		/* 82267974h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82267974h case    0:*/		return 0x82267978;
	}
	return 0x82267978;
} // Block from 82267974h-82267978h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82267978h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267978( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267978) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267978);
		  /* 82267978h */ case    0:  		/* addi R28, R28, 2 */
		/* 82267978h case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x2);
		/* 82267978h case    0:*/		return 0x8226797C;
		  /* 8226797Ch */ case    1:  		/* bc 16, CR0_LT, -200 */
		/* 8226797Ch case    1:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x822678B4;  }
		/* 8226797Ch case    1:*/		return 0x82267980;
	}
	return 0x82267980;
} // Block from 82267978h-82267980h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82267980h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267980( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267980) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267980);
		  /* 82267980h */ case    0:  		/* cmpwi CR6, R29, 0 */
		/* 82267980h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 82267980h case    0:*/		return 0x82267984;
		  /* 82267984h */ case    1:  		/* bc 12, CR6_EQ, 28 */
		/* 82267984h case    1:*/		if ( regs.CR[6].eq ) { return 0x822679A0;  }
		/* 82267984h case    1:*/		return 0x82267988;
		  /* 82267988h */ case    2:  		/* cmpw CR6, R29, R30 */
		/* 82267988h case    2:*/		cpu::op::cmpw<6>(regs,regs.R29,regs.R30);
		/* 82267988h case    2:*/		return 0x8226798C;
		  /* 8226798Ch */ case    3:  		/* bc 4, CR6_LT, 20 */
		/* 8226798Ch case    3:*/		if ( !regs.CR[6].lt ) { return 0x822679A0;  }
		/* 8226798Ch case    3:*/		return 0x82267990;
		  /* 82267990h */ case    4:  		/* li R3, 122 */
		/* 82267990h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x7A);
		/* 82267990h case    4:*/		return 0x82267994;
		  /* 82267994h */ case    5:  		/* bl -1954460 */
		/* 82267994h case    5:*/		regs.LR = 0x82267998; return 0x8208A6F8;
		/* 82267994h case    5:*/		return 0x82267998;
		  /* 82267998h */ case    6:  		/* li R3, 0 */
		/* 82267998h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82267998h case    6:*/		return 0x8226799C;
		  /* 8226799Ch */ case    7:  		/* b 8 */
		/* 8226799Ch case    7:*/		return 0x822679A4;
		/* 8226799Ch case    7:*/		return 0x822679A0;
	}
	return 0x822679A0;
} // Block from 82267980h-822679A0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 822679A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822679A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822679A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822679A0);
		  /* 822679A0h */ case    0:  		/* mr R3, R30 */
		/* 822679A0h case    0:*/		regs.R3 = regs.R30;
		/* 822679A0h case    0:*/		return 0x822679A4;
	}
	return 0x822679A4;
} // Block from 822679A0h-822679A4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822679A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822679A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822679A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822679A4);
		  /* 822679A4h */ case    0:  		/* addi R1, R1, 128 */
		/* 822679A4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 822679A4h case    0:*/		return 0x822679A8;
		  /* 822679A8h */ case    1:  		/* b -1926912 */
		/* 822679A8h case    1:*/		return 0x820912A8;
		/* 822679A8h case    1:*/		return 0x822679AC;
		  /* 822679ACh */ case    2:  		/* nop */
		/* 822679ACh case    2:*/		cpu::op::nop();
		/* 822679ACh case    2:*/		return 0x822679B0;
	}
	return 0x822679B0;
} // Block from 822679A4h-822679B0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822679B0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822679B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822679B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822679B0);
		  /* 822679B0h */ case    0:  		/* mfspr R12, LR */
		/* 822679B0h case    0:*/		regs.R12 = regs.LR;
		/* 822679B0h case    0:*/		return 0x822679B4;
		  /* 822679B4h */ case    1:  		/* bl -1927008 */
		/* 822679B4h case    1:*/		regs.LR = 0x822679B8; return 0x82091254;
		/* 822679B4h case    1:*/		return 0x822679B8;
	}
	return 0x822679B8;
} // Block from 822679B0h-822679B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822679B8h
// Function '?AllNegates@ILFormatDecode@XGRAPHICS@@SAHPBTIL_Src@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822679B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822679B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822679B8);
		  /* 822679B8h */ case    0:  		/* stwu R1, <#[R1 - 128]> */
		/* 822679B8h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 822679B8h case    0:*/		return 0x822679BC;
		  /* 822679BCh */ case    1:  		/* mr R11, R3 */
		/* 822679BCh case    1:*/		regs.R11 = regs.R3;
		/* 822679BCh case    1:*/		return 0x822679C0;
		  /* 822679C0h */ case    2:  		/* nor R10, R3, R3 */
		/* 822679C0h case    2:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R3,regs.R3);
		/* 822679C0h case    2:*/		return 0x822679C4;
		  /* 822679C4h */ case    3:  		/* li R3, 0 */
		/* 822679C4h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822679C4h case    3:*/		return 0x822679C8;
		  /* 822679C8h */ case    4:  		/* rlwinm R30, R10, 20, 31, 31 */
		/* 822679C8h case    4:*/		cpu::op::rlwinm<0,20,31,31>(regs,&regs.R30,regs.R10);
		/* 822679C8h case    4:*/		return 0x822679CC;
		  /* 822679CCh */ case    5:  		/* rlwinm R29, R11, 0, 31, 31 */
		/* 822679CCh case    5:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R29,regs.R11);
		/* 822679CCh case    5:*/		return 0x822679D0;
		  /* 822679D0h */ case    6:  		/* rlwinm R28, R11, 0, 29, 29 */
		/* 822679D0h case    6:*/		cpu::op::rlwinm<0,0,29,29>(regs,&regs.R28,regs.R11);
		/* 822679D0h case    6:*/		return 0x822679D4;
		  /* 822679D4h */ case    7:  		/* cmplwi CR6, R4, 0 */
		/* 822679D4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 822679D4h case    7:*/		return 0x822679D8;
	}
	return 0x822679D8;
} // Block from 822679B8h-822679D8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 822679D8h
// Function '?HasZeroOrOne@ILFormatDecode@XGRAPHICS@@SA_NPBTIL_Dst@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822679D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822679D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822679D8);
		  /* 822679D8h */ case    0:  		/* bc 12, CR6_EQ, 408 */
		/* 822679D8h case    0:*/		if ( regs.CR[6].eq ) { return 0x82267B70;  }
		/* 822679D8h case    0:*/		return 0x822679DC;
		  /* 822679DCh */ case    1:  		/* cmplwi CR6, R6, 0 */
		/* 822679DCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 822679DCh case    1:*/		return 0x822679E0;
		  /* 822679E0h */ case    2:  		/* bc 12, CR6_EQ, 400 */
		/* 822679E0h case    2:*/		if ( regs.CR[6].eq ) { return 0x82267B70;  }
		/* 822679E0h case    2:*/		return 0x822679E4;
		  /* 822679E4h */ case    3:  		/* cmpwi CR6, R5, -1 */
		/* 822679E4h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R5,0xFFFFFFFF);
		/* 822679E4h case    3:*/		return 0x822679E8;
		  /* 822679E8h */ case    4:  		/* bc 12, CR6_LT, 392 */
		/* 822679E8h case    4:*/		if ( regs.CR[6].lt ) { return 0x82267B70;  }
		/* 822679E8h case    4:*/		return 0x822679EC;
		  /* 822679ECh */ case    5:  		/* cmpwi CR6, R7, -1 */
		/* 822679ECh case    5:*/		cpu::op::cmpwi<6>(regs,regs.R7,0xFFFFFFFF);
		/* 822679ECh case    5:*/		return 0x822679F0;
		  /* 822679F0h */ case    6:  		/* bc 12, CR6_LT, 384 */
		/* 822679F0h case    6:*/		if ( regs.CR[6].lt ) { return 0x82267B70;  }
		/* 822679F0h case    6:*/		return 0x822679F4;
		  /* 822679F4h */ case    7:  		/* cmpwi CR6, R5, 0 */
		/* 822679F4h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 822679F4h case    7:*/		return 0x822679F8;
		  /* 822679F8h */ case    8:  		/* bc 12, CR6_EQ, 348 */
		/* 822679F8h case    8:*/		if ( regs.CR[6].eq ) { return 0x82267B54;  }
		/* 822679F8h case    8:*/		return 0x822679FC;
		  /* 822679FCh */ case    9:  		/* lis R11, -32216 */
		/* 822679FCh case    9:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 822679FCh case    9:*/		return 0x82267A00;
		  /* 82267A00h */ case   10:  		/* addi R31, R11, 25800 */
		/* 82267A00h case   10:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x64C8);
		/* 82267A00h case   10:*/		return 0x82267A04;
		  /* 82267A04h */ case   11:  		/* cmpwi CR6, R7, 0 */
		/* 82267A04h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000000);
		/* 82267A04h case   11:*/		return 0x82267A08;
		  /* 82267A08h */ case   12:  		/* bc 12, CR6_EQ, 324 */
		/* 82267A08h case   12:*/		if ( regs.CR[6].eq ) { return 0x82267B4C;  }
		/* 82267A08h case   12:*/		return 0x82267A0C;
		  /* 82267A0Ch */ case   13:  		/* lbz R10, <#[R4]> */
		/* 82267A0Ch case   13:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 82267A0Ch case   13:*/		return 0x82267A10;
		  /* 82267A10h */ case   14:  		/* extsb. R11, R10 */
		/* 82267A10h case   14:*/		cpu::op::extsb<1>(regs,&regs.R11,regs.R10);
		/* 82267A10h case   14:*/		return 0x82267A14;
		  /* 82267A14h */ case   15:  		/* bc 4, CR0_EQ, 16 */
		/* 82267A14h case   15:*/		if ( !regs.CR[0].eq ) { return 0x82267A24;  }
		/* 82267A14h case   15:*/		return 0x82267A18;
		  /* 82267A18h */ case   16:  		/* lbz R9, <#[R6]> */
		/* 82267A18h case   16:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R6 + 0x00000000) );
		/* 82267A18h case   16:*/		return 0x82267A1C;
		  /* 82267A1Ch */ case   17:  		/* cmplwi CR0, R9, 0 */
		/* 82267A1Ch case   17:*/		cpu::op::cmplwi<0>(regs,regs.R9,0x00000000);
		/* 82267A1Ch case   17:*/		return 0x82267A20;
		  /* 82267A20h */ case   18:  		/* bc 12, CR0_EQ, 264 */
		/* 82267A20h case   18:*/		if ( regs.CR[0].eq ) { return 0x82267B28;  }
		/* 82267A20h case   18:*/		return 0x82267A24;
	}
	return 0x82267A24;
} // Block from 822679D8h-82267A24h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82267A24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267A24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267A24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267A24);
		  /* 82267A24h */ case    0:  		/* cmpwi CR6, R11, 0 */
		/* 82267A24h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82267A24h case    0:*/		return 0x82267A28;
		  /* 82267A28h */ case    1:  		/* bc 12, CR6_EQ, 276 */
		/* 82267A28h case    1:*/		if ( regs.CR[6].eq ) { return 0x82267B3C;  }
		/* 82267A28h case    1:*/		return 0x82267A2C;
		  /* 82267A2Ch */ case    2:  		/* lbz R11, <#[R6]> */
		/* 82267A2Ch case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000000) );
		/* 82267A2Ch case    2:*/		return 0x82267A30;
		  /* 82267A30h */ case    3:  		/* cmplwi CR0, R11, 0 */
		/* 82267A30h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 82267A30h case    3:*/		return 0x82267A34;
		  /* 82267A34h */ case    4:  		/* bc 12, CR0_EQ, 272 */
		/* 82267A34h case    4:*/		if ( regs.CR[0].eq ) { return 0x82267B44;  }
		/* 82267A34h case    4:*/		return 0x82267A38;
		  /* 82267A38h */ case    5:  		/* rlwinm R9, R10, 2, 22, 29 */
		/* 82267A38h case    5:*/		cpu::op::rlwinm<0,2,22,29>(regs,&regs.R9,regs.R10);
		/* 82267A38h case    5:*/		return 0x82267A3C;
		  /* 82267A3Ch */ case    6:  		/* rlwinm R27, R11, 2, 22, 29 */
		/* 82267A3Ch case    6:*/		cpu::op::rlwinm<0,2,22,29>(regs,&regs.R27,regs.R11);
		/* 82267A3Ch case    6:*/		return 0x82267A40;
		  /* 82267A40h */ case    7:  		/* rlwinm R10, R10, 0, 24, 31 */
		/* 82267A40h case    7:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R10);
		/* 82267A40h case    7:*/		return 0x82267A44;
		  /* 82267A44h */ case    8:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 82267A44h case    8:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82267A44h case    8:*/		return 0x82267A48;
		  /* 82267A48h */ case    9:  		/* cmpwi CR6, R30, 0 */
		/* 82267A48h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 82267A48h case    9:*/		return 0x82267A4C;
		  /* 82267A4Ch */ case   10:  		/* lwzx R8, <#[R9 + R31]> */
		/* 82267A4Ch case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + regs.R31 + 0x00000000) );
		/* 82267A4Ch case   10:*/		return 0x82267A50;
		  /* 82267A50h */ case   11:  		/* lwzx R9, <#[R27 + R31]> */
		/* 82267A50h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + regs.R31 + 0x00000000) );
		/* 82267A50h case   11:*/		return 0x82267A54;
		  /* 82267A54h */ case   12:  		/* bc 12, CR6_EQ, 96 */
		/* 82267A54h case   12:*/		if ( regs.CR[6].eq ) { return 0x82267AB4;  }
		/* 82267A54h case   12:*/		return 0x82267A58;
		  /* 82267A58h */ case   13:  		/* rlwinm. R27, R8, 0, 15, 15 */
		/* 82267A58h case   13:*/		cpu::op::rlwinm<1,0,15,15>(regs,&regs.R27,regs.R8);
		/* 82267A58h case   13:*/		return 0x82267A5C;
		  /* 82267A5Ch */ case   14:  		/* bc 12, CR0_EQ, 60 */
		/* 82267A5Ch case   14:*/		if ( regs.CR[0].eq ) { return 0x82267A98;  }
		/* 82267A5Ch case   14:*/		return 0x82267A60;
		  /* 82267A60h */ case   15:  		/* rlwinm. R11, R9, 0, 15, 15 */
		/* 82267A60h case   15:*/		cpu::op::rlwinm<1,0,15,15>(regs,&regs.R11,regs.R9);
		/* 82267A60h case   15:*/		return 0x82267A64;
		  /* 82267A64h */ case   16:  		/* bc 12, CR0_EQ, 32 */
		/* 82267A64h case   16:*/		if ( regs.CR[0].eq ) { return 0x82267A84;  }
		/* 82267A64h case   16:*/		return 0x82267A68;
		  /* 82267A68h */ case   17:  		/* cmplw CR6, R8, R9 */
		/* 82267A68h case   17:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 82267A68h case   17:*/		return 0x82267A6C;
		  /* 82267A6Ch */ case   18:  		/* bc 4, CR6_LT, 12 */
		/* 82267A6Ch case   18:*/		if ( !regs.CR[6].lt ) { return 0x82267A78;  }
		/* 82267A6Ch case   18:*/		return 0x82267A70;
		  /* 82267A70h */ case   19:  		/* li R3, 7 */
		/* 82267A70h case   19:*/		cpu::op::li<0>(regs,&regs.R3,0x7);
		/* 82267A70h case   19:*/		return 0x82267A74;
		  /* 82267A74h */ case   20:  		/* b 152 */
		/* 82267A74h case   20:*/		return 0x82267B0C;
		/* 82267A74h case   20:*/		return 0x82267A78;
	}
	return 0x82267A78;
} // Block from 82267A24h-82267A78h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82267A78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267A78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267A78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267A78);
		  /* 82267A78h */ case    0:  		/* bc 4, CR6_GT, 148 */
		/* 82267A78h case    0:*/		if ( !regs.CR[6].gt ) { return 0x82267B0C;  }
		/* 82267A78h case    0:*/		return 0x82267A7C;
		  /* 82267A7Ch */ case    1:  		/* li R3, 11 */
		/* 82267A7Ch case    1:*/		cpu::op::li<0>(regs,&regs.R3,0xB);
		/* 82267A7Ch case    1:*/		return 0x82267A80;
		  /* 82267A80h */ case    2:  		/* b 140 */
		/* 82267A80h case    2:*/		return 0x82267B0C;
		/* 82267A80h case    2:*/		return 0x82267A84;
	}
	return 0x82267A84;
} // Block from 82267A78h-82267A84h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82267A84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267A84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267A84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267A84);
		  /* 82267A84h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 82267A84h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 82267A84h case    0:*/		return 0x82267A88;
		  /* 82267A88h */ case    1:  		/* bc 4, CR6_EQ, 8 */
		/* 82267A88h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82267A90;  }
		/* 82267A88h case    1:*/		return 0x82267A8C;
		  /* 82267A8Ch */ case    2:  		/* li R3, 4 */
		/* 82267A8Ch case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x4);
		/* 82267A8Ch case    2:*/		return 0x82267A90;
	}
	return 0x82267A90;
} // Block from 82267A84h-82267A90h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82267A90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267A90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267A90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267A90);
		  /* 82267A90h */ case    0:  		/* ori R3, R3, 1 */
		/* 82267A90h case    0:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x1);
		/* 82267A90h case    0:*/		return 0x82267A94;
		  /* 82267A94h */ case    1:  		/* b 128 */
		/* 82267A94h case    1:*/		return 0x82267B14;
		/* 82267A94h case    1:*/		return 0x82267A98;
	}
	return 0x82267A98;
} // Block from 82267A90h-82267A98h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82267A98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267A98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267A98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267A98);
		  /* 82267A98h */ case    0:  		/* rlwinm. R27, R9, 0, 15, 15 */
		/* 82267A98h case    0:*/		cpu::op::rlwinm<1,0,15,15>(regs,&regs.R27,regs.R9);
		/* 82267A98h case    0:*/		return 0x82267A9C;
		  /* 82267A9Ch */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 82267A9Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82267AB4;  }
		/* 82267A9Ch case    1:*/		return 0x82267AA0;
	}
	return 0x82267AA0;
} // Block from 82267A98h-82267AA0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82267AA0h
// Function '?Index@LiveSet@XGRAPHICS@@SAHPAVIRInst@2@H@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267AA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267AA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267AA0);
		  /* 82267AA0h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 82267AA0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 82267AA0h case    0:*/		return 0x82267AA4;
		  /* 82267AA4h */ case    1:  		/* bc 4, CR6_EQ, 8 */
		/* 82267AA4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82267AAC;  }
		/* 82267AA4h case    1:*/		return 0x82267AA8;
		  /* 82267AA8h */ case    2:  		/* li R3, 8 */
		/* 82267AA8h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x8);
		/* 82267AA8h case    2:*/		return 0x82267AAC;
	}
	return 0x82267AAC;
} // Block from 82267AA0h-82267AACh (3 instructions)

//////////////////////////////////////////////////////
// Block at 82267AACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267AAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267AAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267AAC);
		  /* 82267AACh */ case    0:  		/* ori R3, R3, 2 */
		/* 82267AACh case    0:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x2);
		/* 82267AACh case    0:*/		return 0x82267AB0;
		  /* 82267AB0h */ case    1:  		/* b 28 */
		/* 82267AB0h case    1:*/		return 0x82267ACC;
		/* 82267AB0h case    1:*/		return 0x82267AB4;
	}
	return 0x82267AB4;
} // Block from 82267AACh-82267AB4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82267AB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267AB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267AB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267AB4);
		  /* 82267AB4h */ case    0:  		/* cmpwi CR6, R28, 0 */
		/* 82267AB4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 82267AB4h case    0:*/		return 0x82267AB8;
		  /* 82267AB8h */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 82267AB8h case    1:*/		if ( regs.CR[6].eq ) { return 0x82267AD8;  }
		/* 82267AB8h case    1:*/		return 0x82267ABC;
		  /* 82267ABCh */ case    2:  		/* rlwinm. R27, R8, 0, 14, 14 */
		/* 82267ABCh case    2:*/		cpu::op::rlwinm<1,0,14,14>(regs,&regs.R27,regs.R8);
		/* 82267ABCh case    2:*/		return 0x82267AC0;
		  /* 82267AC0h */ case    3:  		/* bc 4, CR0_EQ, 84 */
		/* 82267AC0h case    3:*/		if ( !regs.CR[0].eq ) { return 0x82267B14;  }
		/* 82267AC0h case    3:*/		return 0x82267AC4;
		  /* 82267AC4h */ case    4:  		/* rlwinm. R27, R9, 0, 14, 14 */
		/* 82267AC4h case    4:*/		cpu::op::rlwinm<1,0,14,14>(regs,&regs.R27,regs.R9);
		/* 82267AC4h case    4:*/		return 0x82267AC8;
		  /* 82267AC8h */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 82267AC8h case    5:*/		if ( regs.CR[0].eq ) { return 0x82267AD8;  }
		/* 82267AC8h case    5:*/		return 0x82267ACC;
	}
	return 0x82267ACC;
} // Block from 82267AB4h-82267ACCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 82267ACCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267ACC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267ACC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267ACC);
		  /* 82267ACCh */ case    0:  		/* addi R6, R6, 1 */
		/* 82267ACCh case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 82267ACCh case    0:*/		return 0x82267AD0;
		  /* 82267AD0h */ case    1:  		/* addi R7, R7, -1 */
		/* 82267AD0h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0xFFFFFFFF);
		/* 82267AD0h case    1:*/		return 0x82267AD4;
		  /* 82267AD4h */ case    2:  		/* b 72 */
		/* 82267AD4h case    2:*/		return 0x82267B1C;
		/* 82267AD4h case    2:*/		return 0x82267AD8;
	}
	return 0x82267AD8;
} // Block from 82267ACCh-82267AD8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82267AD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267AD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267AD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267AD8);
		  /* 82267AD8h */ case    0:  		/* cmpwi CR6, R29, 0 */
		/* 82267AD8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 82267AD8h case    0:*/		return 0x82267ADC;
		  /* 82267ADCh */ case    1:  		/* bc 12, CR6_EQ, 36 */
		/* 82267ADCh case    1:*/		if ( regs.CR[6].eq ) { return 0x82267B00;  }
		/* 82267ADCh case    1:*/		return 0x82267AE0;
		  /* 82267AE0h */ case    2:  		/* rlwinm. R27, R8, 0, 11, 11 */
		/* 82267AE0h case    2:*/		cpu::op::rlwinm<1,0,11,11>(regs,&regs.R27,regs.R8);
		/* 82267AE0h case    2:*/		return 0x82267AE4;
		  /* 82267AE4h */ case    3:  		/* bc 12, CR0_EQ, 12 */
		/* 82267AE4h case    3:*/		if ( regs.CR[0].eq ) { return 0x82267AF0;  }
		/* 82267AE4h case    3:*/		return 0x82267AE8;
		  /* 82267AE8h */ case    4:  		/* addi R10, R10, 32 */
		/* 82267AE8h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x20);
		/* 82267AE8h case    4:*/		return 0x82267AEC;
		  /* 82267AECh */ case    5:  		/* oris R8, R10, 8 */
		/* 82267AECh case    5:*/		cpu::op::oris<0>(regs,&regs.R8,regs.R10,0x8);
		/* 82267AECh case    5:*/		return 0x82267AF0;
	}
	return 0x82267AF0;
} // Block from 82267AD8h-82267AF0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82267AF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267AF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267AF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267AF0);
		  /* 82267AF0h */ case    0:  		/* rlwinm. R10, R9, 0, 11, 11 */
		/* 82267AF0h case    0:*/		cpu::op::rlwinm<1,0,11,11>(regs,&regs.R10,regs.R9);
		/* 82267AF0h case    0:*/		return 0x82267AF4;
		  /* 82267AF4h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 82267AF4h case    1:*/		if ( regs.CR[0].eq ) { return 0x82267B00;  }
		/* 82267AF4h case    1:*/		return 0x82267AF8;
	}
	return 0x82267AF8;
} // Block from 82267AF0h-82267AF8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82267AF8h
// Function 'DebugBreak'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267AF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267AF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267AF8);
		  /* 82267AF8h */ case    0:  		/* addi R11, R11, 32 */
		/* 82267AF8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x20);
		/* 82267AF8h case    0:*/		return 0x82267AFC;
		  /* 82267AFCh */ case    1:  		/* oris R9, R11, 8 */
		/* 82267AFCh case    1:*/		cpu::op::oris<0>(regs,&regs.R9,regs.R11,0x8);
		/* 82267AFCh case    1:*/		return 0x82267B00;
	}
	return 0x82267B00;
} // Block from 82267AF8h-82267B00h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82267B00h
// Function 'GetFileSize'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267B00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267B00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267B00);
		  /* 82267B00h */ case    0:  		/* cmplw CR6, R8, R9 */
		/* 82267B00h case    0:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 82267B00h case    0:*/		return 0x82267B04;
		  /* 82267B04h */ case    1:  		/* bc 12, CR6_LT, 56 */
		/* 82267B04h case    1:*/		if ( regs.CR[6].lt ) { return 0x82267B3C;  }
		/* 82267B04h case    1:*/		return 0x82267B08;
		  /* 82267B08h */ case    2:  		/* bc 12, CR6_GT, 60 */
		/* 82267B08h case    2:*/		if ( regs.CR[6].gt ) { return 0x82267B44;  }
		/* 82267B08h case    2:*/		return 0x82267B0C;
	}
	return 0x82267B0C;
} // Block from 82267B00h-82267B0Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82267B0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267B0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267B0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267B0C);
		  /* 82267B0Ch */ case    0:  		/* addi R7, R7, -1 */
		/* 82267B0Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0xFFFFFFFF);
		/* 82267B0Ch case    0:*/		return 0x82267B10;
		  /* 82267B10h */ case    1:  		/* addi R6, R6, 1 */
		/* 82267B10h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 82267B10h case    1:*/		return 0x82267B14;
	}
	return 0x82267B14;
} // Block from 82267B0Ch-82267B14h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82267B14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267B14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267B14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267B14);
		  /* 82267B14h */ case    0:  		/* addi R5, R5, -1 */
		/* 82267B14h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0xFFFFFFFF);
		/* 82267B14h case    0:*/		return 0x82267B18;
		  /* 82267B18h */ case    1:  		/* addi R4, R4, 1 */
		/* 82267B18h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 82267B18h case    1:*/		return 0x82267B1C;
	}
	return 0x82267B1C;
} // Block from 82267B14h-82267B1Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82267B1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267B1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267B1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267B1C);
		  /* 82267B1Ch */ case    0:  		/* cmpwi CR6, R5, 0 */
		/* 82267B1Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 82267B1Ch case    0:*/		return 0x82267B20;
		  /* 82267B20h */ case    1:  		/* bc 4, CR6_EQ, -284 */
		/* 82267B20h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82267A04;  }
		/* 82267B20h case    1:*/		return 0x82267B24;
		  /* 82267B24h */ case    2:  		/* b 48 */
		/* 82267B24h case    2:*/		return 0x82267B54;
		/* 82267B24h case    2:*/		return 0x82267B28;
	}
	return 0x82267B28;
} // Block from 82267B1Ch-82267B28h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82267B28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267B28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267B28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267B28);
		  /* 82267B28h */ case    0:  		/* lis R11, -32216 */
		/* 82267B28h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 82267B28h case    0:*/		return 0x82267B2C;
		  /* 82267B2Ch */ case    1:  		/* rlwinm R10, R3, 2, 0, 29 */
		/* 82267B2Ch case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R3);
		/* 82267B2Ch case    1:*/		return 0x82267B30;
		  /* 82267B30h */ case    2:  		/* addi R11, R11, 26824 */
		/* 82267B30h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x68C8);
		/* 82267B30h case    2:*/		return 0x82267B34;
		  /* 82267B34h */ case    3:  		/* lwzx R3, <#[R10 + R11]> */
		/* 82267B34h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82267B34h case    3:*/		return 0x82267B38;
		  /* 82267B38h */ case    4:  		/* b 68 */
		/* 82267B38h case    4:*/		return 0x82267B7C;
		/* 82267B38h case    4:*/		return 0x82267B3C;
	}
	return 0x82267B3C;
} // Block from 82267B28h-82267B3Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82267B3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267B3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267B3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267B3C);
		  /* 82267B3Ch */ case    0:  		/* li R3, 1 */
		/* 82267B3Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 82267B3Ch case    0:*/		return 0x82267B40;
		  /* 82267B40h */ case    1:  		/* b 60 */
		/* 82267B40h case    1:*/		return 0x82267B7C;
		/* 82267B40h case    1:*/		return 0x82267B44;
	}
	return 0x82267B44;
} // Block from 82267B3Ch-82267B44h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82267B44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267B44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267B44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267B44);
		  /* 82267B44h */ case    0:  		/* li R3, 3 */
		/* 82267B44h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x3);
		/* 82267B44h case    0:*/		return 0x82267B48;
		  /* 82267B48h */ case    1:  		/* b 52 */
		/* 82267B48h case    1:*/		return 0x82267B7C;
		/* 82267B48h case    1:*/		return 0x82267B4C;
	}
	return 0x82267B4C;
} // Block from 82267B44h-82267B4Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82267B4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267B4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267B4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267B4C);
		  /* 82267B4Ch */ case    0:  		/* cmpwi CR6, R5, 0 */
		/* 82267B4Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 82267B4Ch case    0:*/		return 0x82267B50;
		  /* 82267B50h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 82267B50h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82267B5C;  }
		/* 82267B50h case    1:*/		return 0x82267B54;
	}
	return 0x82267B54;
} // Block from 82267B4Ch-82267B54h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82267B54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267B54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267B54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267B54);
		  /* 82267B54h */ case    0:  		/* cmpwi CR6, R7, 0 */
		/* 82267B54h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R7,0x00000000);
		/* 82267B54h case    0:*/		return 0x82267B58;
		  /* 82267B58h */ case    1:  		/* bc 12, CR6_EQ, -48 */
		/* 82267B58h case    1:*/		if ( regs.CR[6].eq ) { return 0x82267B28;  }
		/* 82267B58h case    1:*/		return 0x82267B5C;
	}
	return 0x82267B5C;
} // Block from 82267B54h-82267B5Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 82267B5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267B5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267B5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267B5C);
		  /* 82267B5Ch */ case    0:  		/* subfic R11, R5, 0 */
		/* 82267B5Ch case    0:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R5,0x0);
		/* 82267B5Ch case    0:*/		return 0x82267B60;
		  /* 82267B60h */ case    1:  		/* subfe R11, R11, R11 */
		/* 82267B60h case    1:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82267B60h case    1:*/		return 0x82267B64;
		  /* 82267B64h */ case    2:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 82267B64h case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 82267B64h case    2:*/		return 0x82267B68;
	}
	return 0x82267B68;
} // Block from 82267B5Ch-82267B68h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82267B68h
// Function 'ReadFile'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267B68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267B68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267B68);
		  /* 82267B68h */ case    0:  		/* addi R3, R11, 3 */
		/* 82267B68h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x3);
		/* 82267B68h case    0:*/		return 0x82267B6C;
		  /* 82267B6Ch */ case    1:  		/* b 16 */
		/* 82267B6Ch case    1:*/		return 0x82267B7C;
		/* 82267B6Ch case    1:*/		return 0x82267B70;
	}
	return 0x82267B70;
} // Block from 82267B68h-82267B70h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82267B70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267B70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267B70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267B70);
		  /* 82267B70h */ case    0:  		/* li R3, 87 */
		/* 82267B70h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x57);
		/* 82267B70h case    0:*/		return 0x82267B74;
		  /* 82267B74h */ case    1:  		/* bl -1954940 */
		/* 82267B74h case    1:*/		regs.LR = 0x82267B78; return 0x8208A6F8;
		/* 82267B74h case    1:*/		return 0x82267B78;
		  /* 82267B78h */ case    2:  		/* li R3, 0 */
		/* 82267B78h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82267B78h case    2:*/		return 0x82267B7C;
	}
	return 0x82267B7C;
} // Block from 82267B70h-82267B7Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82267B7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267B7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267B7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267B7C);
		  /* 82267B7Ch */ case    0:  		/* addi R1, R1, 128 */
		/* 82267B7Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82267B7Ch case    0:*/		return 0x82267B80;
		  /* 82267B80h */ case    1:  		/* b -1927388 */
		/* 82267B80h case    1:*/		return 0x820912A4;
		/* 82267B80h case    1:*/		return 0x82267B84;
		  /* 82267B84h */ case    2:  		/* nop */
		/* 82267B84h case    2:*/		cpu::op::nop();
		/* 82267B84h case    2:*/		return 0x82267B88;
	}
	return 0x82267B88;
} // Block from 82267B7Ch-82267B88h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82267B88h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267B88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267B88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267B88);
		  /* 82267B88h */ case    0:  		/* mfspr R12, LR */
		/* 82267B88h case    0:*/		regs.R12 = regs.LR;
		/* 82267B88h case    0:*/		return 0x82267B8C;
		  /* 82267B8Ch */ case    1:  		/* bl -1927508 */
		/* 82267B8Ch case    1:*/		regs.LR = 0x82267B90; return 0x82091238;
		/* 82267B8Ch case    1:*/		return 0x82267B90;
		  /* 82267B90h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 82267B90h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 82267B90h case    2:*/		return 0x82267B94;
		  /* 82267B94h */ case    3:  		/* mr R24, R3 */
		/* 82267B94h case    3:*/		regs.R24 = regs.R3;
		/* 82267B94h case    3:*/		return 0x82267B98;
		  /* 82267B98h */ case    4:  		/* li R3, 0 */
		/* 82267B98h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82267B98h case    4:*/		return 0x82267B9C;
		  /* 82267B9Ch */ case    5:  		/* mr R10, R24 */
		/* 82267B9Ch case    5:*/		regs.R10 = regs.R24;
		/* 82267B9Ch case    5:*/		return 0x82267BA0;
		  /* 82267BA0h */ case    6:  		/* cmpwi CR6, R4, -1 */
		/* 82267BA0h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R4,0xFFFFFFFF);
		/* 82267BA0h case    6:*/		return 0x82267BA4;
		  /* 82267BA4h */ case    7:  		/* bc 4, CR6_EQ, 40 */
		/* 82267BA4h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82267BCC;  }
		/* 82267BA4h case    7:*/		return 0x82267BA8;
		  /* 82267BA8h */ case    8:  		/* mr R11, R24 */
		/* 82267BA8h case    8:*/		regs.R11 = regs.R24;
		/* 82267BA8h case    8:*/		return 0x82267BAC;
		  /* 82267BACh */ case    9:  		/* lbz R9, <#[R11]> */
		/* 82267BACh case    9:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 82267BACh case    9:*/		return 0x82267BB0;
		  /* 82267BB0h */ case   10:  		/* addi R11, R11, 1 */
		/* 82267BB0h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82267BB0h case   10:*/		return 0x82267BB4;
		  /* 82267BB4h */ case   11:  		/* cmplwi CR6, R9, 0 */
		/* 82267BB4h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 82267BB4h case   11:*/		return 0x82267BB8;
		  /* 82267BB8h */ case   12:  		/* bc 4, CR6_EQ, -12 */
		/* 82267BB8h case   12:*/		if ( !regs.CR[6].eq ) { return 0x82267BAC;  }
		/* 82267BB8h case   12:*/		return 0x82267BBC;
		  /* 82267BBCh */ case   13:  		/* subf R11, R24, R11 */
		/* 82267BBCh case   13:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R24,regs.R11);
		/* 82267BBCh case   13:*/		return 0x82267BC0;
		  /* 82267BC0h */ case   14:  		/* addi R11, R11, -1 */
		/* 82267BC0h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82267BC0h case   14:*/		return 0x82267BC4;
		  /* 82267BC4h */ case   15:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 82267BC4h case   15:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 82267BC4h case   15:*/		return 0x82267BC8;
		  /* 82267BC8h */ case   16:  		/* addi R4, R11, 1 */
		/* 82267BC8h case   16:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x1);
		/* 82267BC8h case   16:*/		return 0x82267BCC;
	}
	return 0x82267BCC;
} // Block from 82267B88h-82267BCCh (17 instructions)

//////////////////////////////////////////////////////
// Block at 82267BCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267BCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267BCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267BCC);
		  /* 82267BCCh */ case    0:  		/* cmpwi CR6, R4, 0 */
		/* 82267BCCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000000);
		/* 82267BCCh case    0:*/		return 0x82267BD0;
		  /* 82267BD0h */ case    1:  		/* bc 4, CR6_GT, 408 */
		/* 82267BD0h case    1:*/		if ( !regs.CR[6].gt ) { return 0x82267D68;  }
		/* 82267BD0h case    1:*/		return 0x82267BD4;
		  /* 82267BD4h */ case    2:  		/* lis R9, -32216 */
		/* 82267BD4h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8228);
		/* 82267BD4h case    2:*/		return 0x82267BD8;
		  /* 82267BD8h */ case    3:  		/* lis R11, -32216 */
		/* 82267BD8h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 82267BD8h case    3:*/		return 0x82267BDC;
		  /* 82267BDCh */ case    4:  		/* li R31, 0 */
		/* 82267BDCh case    4:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 82267BDCh case    4:*/		return 0x82267BE0;
		  /* 82267BE0h */ case    5:  		/* addi R5, R5, -2 */
		/* 82267BE0h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0xFFFFFFFE);
		/* 82267BE0h case    5:*/		return 0x82267BE4;
		  /* 82267BE4h */ case    6:  		/* lis R29, -32216 */
		/* 82267BE4h case    6:*/		cpu::op::lis<0>(regs,&regs.R29,0xFFFF8228);
		/* 82267BE4h case    6:*/		return 0x82267BE8;
		  /* 82267BE8h */ case    7:  		/* lis R28, -32216 */
		/* 82267BE8h case    7:*/		cpu::op::lis<0>(regs,&regs.R28,0xFFFF8228);
		/* 82267BE8h case    7:*/		return 0x82267BEC;
		  /* 82267BECh */ case    8:  		/* lis R27, -32216 */
		/* 82267BECh case    8:*/		cpu::op::lis<0>(regs,&regs.R27,0xFFFF8228);
		/* 82267BECh case    8:*/		return 0x82267BF0;
		  /* 82267BF0h */ case    9:  		/* lis R26, -32216 */
		/* 82267BF0h case    9:*/		cpu::op::lis<0>(regs,&regs.R26,0xFFFF8228);
		/* 82267BF0h case    9:*/		return 0x82267BF4;
		  /* 82267BF4h */ case   10:  		/* lis R25, -32216 */
		/* 82267BF4h case   10:*/		cpu::op::lis<0>(regs,&regs.R25,0xFFFF8228);
		/* 82267BF4h case   10:*/		return 0x82267BF8;
		  /* 82267BF8h */ case   11:  		/* lis R21, -32216 */
		/* 82267BF8h case   11:*/		cpu::op::lis<0>(regs,&regs.R21,0xFFFF8228);
		/* 82267BF8h case   11:*/		return 0x82267BFC;
		  /* 82267BFCh */ case   12:  		/* lis R20, -32216 */
		/* 82267BFCh case   12:*/		cpu::op::lis<0>(regs,&regs.R20,0xFFFF8228);
		/* 82267BFCh case   12:*/		return 0x82267C00;
		  /* 82267C00h */ case   13:  		/* lis R22, -32216 */
		/* 82267C00h case   13:*/		cpu::op::lis<0>(regs,&regs.R22,0xFFFF8228);
		/* 82267C00h case   13:*/		return 0x82267C04;
		  /* 82267C04h */ case   14:  		/* addi R23, R9, 26904 */
		/* 82267C04h case   14:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R9,0x6918);
		/* 82267C04h case   14:*/		return 0x82267C08;
		  /* 82267C08h */ case   15:  		/* addi R30, R11, 26928 */
		/* 82267C08h case   15:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0x6930);
		/* 82267C08h case   15:*/		return 0x82267C0C;
		  /* 82267C0Ch */ case   16:  		/* lbz R8, <#[R10]> */
		/* 82267C0Ch case   16:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 82267C0Ch case   16:*/		return 0x82267C10;
		  /* 82267C10h */ case   17:  		/* li R11, 0 */
		/* 82267C10h case   17:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82267C10h case   17:*/		return 0x82267C14;
		  /* 82267C14h */ case   18:  		/* lbzx R9, <#[R8 + R30]> */
		/* 82267C14h case   18:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R8 + regs.R30 + 0x00000000) );
		/* 82267C14h case   18:*/		return 0x82267C18;
		  /* 82267C18h */ case   19:  		/* extsb R9, R9 */
		/* 82267C18h case   19:*/		cpu::op::extsb<0>(regs,&regs.R9,regs.R9);
		/* 82267C18h case   19:*/		return 0x82267C1C;
		  /* 82267C1Ch */ case   20:  		/* rlwinm R9, R9, 0, 16, 31 */
		/* 82267C1Ch case   20:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R9,regs.R9);
		/* 82267C1Ch case   20:*/		return 0x82267C20;
		  /* 82267C20h */ case   21:  		/* subf R7, R24, R9 */
		/* 82267C20h case   21:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R24,regs.R9);
		/* 82267C20h case   21:*/		return 0x82267C24;
		  /* 82267C24h */ case   22:  		/* add R7, R7, R10 */
		/* 82267C24h case   22:*/		cpu::op::add<0>(regs,&regs.R7,regs.R7,regs.R10);
		/* 82267C24h case   22:*/		return 0x82267C28;
		  /* 82267C28h */ case   23:  		/* cmpw CR6, R7, R4 */
		/* 82267C28h case   23:*/		cpu::op::cmpw<6>(regs,regs.R7,regs.R4);
		/* 82267C28h case   23:*/		return 0x82267C2C;
		  /* 82267C2Ch */ case   24:  		/* bc 4, CR6_LT, 316 */
		/* 82267C2Ch case   24:*/		if ( !regs.CR[6].lt ) { return 0x82267D68;  }
		/* 82267C2Ch case   24:*/		return 0x82267C30;
		  /* 82267C30h */ case   25:  		/* cmplwi CR6, R9, 1 */
		/* 82267C30h case   25:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000001);
		/* 82267C30h case   25:*/		return 0x82267C34;
		  /* 82267C34h */ case   26:  		/* bc 12, CR6_LT, 124 */
		/* 82267C34h case   26:*/		if ( regs.CR[6].lt ) { return 0x82267CB0;  }
		/* 82267C34h case   26:*/		return 0x82267C38;
		  /* 82267C38h */ case   27:  		/* bc 12, CR6_EQ, 100 */
		/* 82267C38h case   27:*/		if ( regs.CR[6].eq ) { return 0x82267C9C;  }
		/* 82267C38h case   27:*/		return 0x82267C3C;
		  /* 82267C3Ch */ case   28:  		/* cmplwi CR6, R9, 3 */
		/* 82267C3Ch case   28:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000003);
		/* 82267C3Ch case   28:*/		return 0x82267C40;
		  /* 82267C40h */ case   29:  		/* bc 12, CR6_LT, 72 */
		/* 82267C40h case   29:*/		if ( regs.CR[6].lt ) { return 0x82267C88;  }
		/* 82267C40h case   29:*/		return 0x82267C44;
		  /* 82267C44h */ case   30:  		/* bc 12, CR6_EQ, 48 */
		/* 82267C44h case   30:*/		if ( regs.CR[6].eq ) { return 0x82267C74;  }
		/* 82267C44h case   30:*/		return 0x82267C48;
		  /* 82267C48h */ case   31:  		/* cmplwi CR6, R9, 5 */
		/* 82267C48h case   31:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000005);
		/* 82267C48h case   31:*/		return 0x82267C4C;
		  /* 82267C4Ch */ case   32:  		/* bc 12, CR6_LT, 20 */
		/* 82267C4Ch case   32:*/		if ( regs.CR[6].lt ) { return 0x82267C60;  }
		/* 82267C4Ch case   32:*/		return 0x82267C50;
		  /* 82267C50h */ case   33:  		/* bc 4, CR6_EQ, 112 */
		/* 82267C50h case   33:*/		if ( !regs.CR[6].eq ) { return 0x82267CC0;  }
		/* 82267C50h case   33:*/		return 0x82267C54;
		  /* 82267C54h */ case   34:  		/* addi R10, R10, 1 */
		/* 82267C54h case   34:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82267C54h case   34:*/		return 0x82267C58;
		  /* 82267C58h */ case   35:  		/* addi R31, R31, 1 */
		/* 82267C58h case   35:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82267C58h case   35:*/		return 0x82267C5C;
		  /* 82267C5Ch */ case   36:  		/* rlwinm R11, R8, 6, 0, 25 */
		/* 82267C5Ch case   36:*/		cpu::op::rlwinm<0,6,0,25>(regs,&regs.R11,regs.R8);
		/* 82267C5Ch case   36:*/		return 0x82267C60;
	}
	return 0x82267C60;
} // Block from 82267BCCh-82267C60h (37 instructions)

//////////////////////////////////////////////////////
// Block at 82267C60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267C60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267C60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267C60);
		  /* 82267C60h */ case    0:  		/* lbz R8, <#[R10]> */
		/* 82267C60h case    0:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 82267C60h case    0:*/		return 0x82267C64;
		  /* 82267C64h */ case    1:  		/* addi R10, R10, 1 */
		/* 82267C64h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82267C64h case    1:*/		return 0x82267C68;
		  /* 82267C68h */ case    2:  		/* addi R31, R31, 1 */
		/* 82267C68h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82267C68h case    2:*/		return 0x82267C6C;
		  /* 82267C6Ch */ case    3:  		/* add R11, R8, R11 */
		/* 82267C6Ch case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 82267C6Ch case    3:*/		return 0x82267C70;
		  /* 82267C70h */ case    4:  		/* rlwinm R11, R11, 6, 0, 25 */
		/* 82267C70h case    4:*/		cpu::op::rlwinm<0,6,0,25>(regs,&regs.R11,regs.R11);
		/* 82267C70h case    4:*/		return 0x82267C74;
	}
	return 0x82267C74;
} // Block from 82267C60h-82267C74h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82267C74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267C74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267C74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267C74);
		  /* 82267C74h */ case    0:  		/* lbz R8, <#[R10]> */
		/* 82267C74h case    0:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 82267C74h case    0:*/		return 0x82267C78;
		  /* 82267C78h */ case    1:  		/* addi R10, R10, 1 */
		/* 82267C78h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82267C78h case    1:*/		return 0x82267C7C;
		  /* 82267C7Ch */ case    2:  		/* addi R31, R31, 1 */
		/* 82267C7Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82267C7Ch case    2:*/		return 0x82267C80;
		  /* 82267C80h */ case    3:  		/* add R11, R8, R11 */
		/* 82267C80h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 82267C80h case    3:*/		return 0x82267C84;
		  /* 82267C84h */ case    4:  		/* rlwinm R11, R11, 6, 0, 25 */
		/* 82267C84h case    4:*/		cpu::op::rlwinm<0,6,0,25>(regs,&regs.R11,regs.R11);
		/* 82267C84h case    4:*/		return 0x82267C88;
	}
	return 0x82267C88;
} // Block from 82267C74h-82267C88h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82267C88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267C88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267C88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267C88);
		  /* 82267C88h */ case    0:  		/* lbz R8, <#[R10]> */
		/* 82267C88h case    0:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 82267C88h case    0:*/		return 0x82267C8C;
		  /* 82267C8Ch */ case    1:  		/* addi R10, R10, 1 */
		/* 82267C8Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82267C8Ch case    1:*/		return 0x82267C90;
		  /* 82267C90h */ case    2:  		/* addi R31, R31, 1 */
		/* 82267C90h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82267C90h case    2:*/		return 0x82267C94;
		  /* 82267C94h */ case    3:  		/* add R11, R8, R11 */
		/* 82267C94h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 82267C94h case    3:*/		return 0x82267C98;
		  /* 82267C98h */ case    4:  		/* rlwinm R11, R11, 6, 0, 25 */
		/* 82267C98h case    4:*/		cpu::op::rlwinm<0,6,0,25>(regs,&regs.R11,regs.R11);
		/* 82267C98h case    4:*/		return 0x82267C9C;
	}
	return 0x82267C9C;
} // Block from 82267C88h-82267C9Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82267C9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267C9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267C9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267C9C);
		  /* 82267C9Ch */ case    0:  		/* lbz R8, <#[R10]> */
		/* 82267C9Ch case    0:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 82267C9Ch case    0:*/		return 0x82267CA0;
		  /* 82267CA0h */ case    1:  		/* addi R10, R10, 1 */
		/* 82267CA0h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82267CA0h case    1:*/		return 0x82267CA4;
		  /* 82267CA4h */ case    2:  		/* addi R31, R31, 1 */
		/* 82267CA4h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82267CA4h case    2:*/		return 0x82267CA8;
		  /* 82267CA8h */ case    3:  		/* add R11, R8, R11 */
		/* 82267CA8h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 82267CA8h case    3:*/		return 0x82267CAC;
		  /* 82267CACh */ case    4:  		/* rlwinm R11, R11, 6, 0, 25 */
		/* 82267CACh case    4:*/		cpu::op::rlwinm<0,6,0,25>(regs,&regs.R11,regs.R11);
		/* 82267CACh case    4:*/		return 0x82267CB0;
	}
	return 0x82267CB0;
} // Block from 82267C9Ch-82267CB0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82267CB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267CB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267CB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267CB0);
		  /* 82267CB0h */ case    0:  		/* lbz R8, <#[R10]> */
		/* 82267CB0h case    0:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 82267CB0h case    0:*/		return 0x82267CB4;
		  /* 82267CB4h */ case    1:  		/* addi R10, R10, 1 */
		/* 82267CB4h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82267CB4h case    1:*/		return 0x82267CB8;
		  /* 82267CB8h */ case    2:  		/* addi R31, R31, 1 */
		/* 82267CB8h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 82267CB8h case    2:*/		return 0x82267CBC;
		  /* 82267CBCh */ case    3:  		/* add R11, R8, R11 */
		/* 82267CBCh case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 82267CBCh case    3:*/		return 0x82267CC0;
	}
	return 0x82267CC0;
} // Block from 82267CB0h-82267CC0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82267CC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267CC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267CC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267CC0);
		  /* 82267CC0h */ case    0:  		/* rlwinm R9, R9, 2, 0, 29 */
		/* 82267CC0h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R9);
		/* 82267CC0h case    0:*/		return 0x82267CC4;
		  /* 82267CC4h */ case    1:  		/* lwz R8, <#[R22 + 26876]> */
		/* 82267CC4h case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R22 + 0x000068FC) );
		/* 82267CC4h case    1:*/		return 0x82267CC8;
		  /* 82267CC8h */ case    2:  		/* lwzx R9, <#[R9 + R23]> */
		/* 82267CC8h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + regs.R23 + 0x00000000) );
		/* 82267CC8h case    2:*/		return 0x82267CCC;
		  /* 82267CCCh */ case    3:  		/* subf R11, R9, R11 */
		/* 82267CCCh case    3:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82267CCCh case    3:*/		return 0x82267CD0;
		  /* 82267CD0h */ case    4:  		/* cmplw CR6, R11, R8 */
		/* 82267CD0h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 82267CD0h case    4:*/		return 0x82267CD4;
		  /* 82267CD4h */ case    5:  		/* bc 12, CR6_GT, 20 */
		/* 82267CD4h case    5:*/		if ( regs.CR[6].gt ) { return 0x82267CE8;  }
		/* 82267CD4h case    5:*/		return 0x82267CD8;
		  /* 82267CD8h */ case    6:  		/* addi R3, R3, 1 */
		/* 82267CD8h case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x1);
		/* 82267CD8h case    6:*/		return 0x82267CDC;
		  /* 82267CDCh */ case    7:  		/* cmpw CR6, R3, R6 */
		/* 82267CDCh case    7:*/		cpu::op::cmpw<6>(regs,regs.R3,regs.R6);
		/* 82267CDCh case    7:*/		return 0x82267CE0;
		  /* 82267CE0h */ case    8:  		/* bc 12, CR6_GT, 128 */
		/* 82267CE0h case    8:*/		if ( regs.CR[6].gt ) { return 0x82267D60;  }
		/* 82267CE0h case    8:*/		return 0x82267CE4;
		  /* 82267CE4h */ case    9:  		/* b 32 */
		/* 82267CE4h case    9:*/		return 0x82267D04;
		/* 82267CE4h case    9:*/		return 0x82267CE8;
	}
	return 0x82267CE8;
} // Block from 82267CC0h-82267CE8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82267CE8h
// Function 'RaiseException'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267CE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267CE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267CE8);
		  /* 82267CE8h */ case    0:  		/* lwz R9, <#[R20 + 26880]> */
		/* 82267CE8h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R20 + 0x00006900) );
		/* 82267CE8h case    0:*/		return 0x82267CEC;
		  /* 82267CECh */ case    1:  		/* cmplw CR6, R11, R9 */
		/* 82267CECh case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 82267CECh case    1:*/		return 0x82267CF0;
		  /* 82267CF0h */ case    2:  		/* bc 4, CR6_GT, 36 */
		/* 82267CF0h case    2:*/		if ( !regs.CR[6].gt ) { return 0x82267D14;  }
		/* 82267CF0h case    2:*/		return 0x82267CF4;
		  /* 82267CF4h */ case    3:  		/* addi R3, R3, 1 */
		/* 82267CF4h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x1);
		/* 82267CF4h case    3:*/		return 0x82267CF8;
		  /* 82267CF8h */ case    4:  		/* cmpw CR6, R3, R6 */
		/* 82267CF8h case    4:*/		cpu::op::cmpw<6>(regs,regs.R3,regs.R6);
		/* 82267CF8h case    4:*/		return 0x82267CFC;
		  /* 82267CFCh */ case    5:  		/* bc 12, CR6_GT, 100 */
		/* 82267CFCh case    5:*/		if ( regs.CR[6].gt ) { return 0x82267D60;  }
		/* 82267CFCh case    5:*/		return 0x82267D00;
		  /* 82267D00h */ case    6:  		/* lwz R11, <#[R21 + 26872]> */
		/* 82267D00h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x000068F8) );
		/* 82267D00h case    6:*/		return 0x82267D04;
	}
	return 0x82267D04;
} // Block from 82267CE8h-82267D04h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82267D04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267D04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267D04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267D04);
		  /* 82267D04h */ case    0:  		/* rlwinm R11, R11, 0, 16, 31 */
		/* 82267D04h case    0:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R11,regs.R11);
		/* 82267D04h case    0:*/		return 0x82267D08;
		  /* 82267D08h */ case    1:  		/* sth R11, <#[R5 + 2]> */
		/* 82267D08h case    1:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R5 + 0x00000002) );
		/* 82267D08h case    1:*/		return 0x82267D0C;
		  /* 82267D0Ch */ case    2:  		/* addi R5, R5, 2 */
		/* 82267D0Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x2);
		/* 82267D0Ch case    2:*/		return 0x82267D10;
		  /* 82267D10h */ case    3:  		/* b 80 */
		/* 82267D10h case    3:*/		return 0x82267D60;
		/* 82267D10h case    3:*/		return 0x82267D14;
	}
	return 0x82267D14;
} // Block from 82267D04h-82267D14h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82267D14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267D14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267D14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267D14);
		  /* 82267D14h */ case    0:  		/* lwz R9, <#[R25 + 26888]> */
		/* 82267D14h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + 0x00006908) );
		/* 82267D14h case    0:*/		return 0x82267D18;
		  /* 82267D18h */ case    1:  		/* addi R7, R3, 1 */
		/* 82267D18h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R3,0x1);
		/* 82267D18h case    1:*/		return 0x82267D1C;
		  /* 82267D1Ch */ case    2:  		/* subf R11, R9, R11 */
		/* 82267D1Ch case    2:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82267D1Ch case    2:*/		return 0x82267D20;
		  /* 82267D20h */ case    3:  		/* cmpw CR6, R7, R6 */
		/* 82267D20h case    3:*/		cpu::op::cmpw<6>(regs,regs.R7,regs.R6);
		/* 82267D20h case    3:*/		return 0x82267D24;
		  /* 82267D24h */ case    4:  		/* bc 12, CR6_GT, 28 */
		/* 82267D24h case    4:*/		if ( regs.CR[6].gt ) { return 0x82267D40;  }
		/* 82267D24h case    4:*/		return 0x82267D28;
		  /* 82267D28h */ case    5:  		/* lwz R9, <#[R26 + 26884]> */
		/* 82267D28h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x00006904) );
		/* 82267D28h case    5:*/		return 0x82267D2C;
		  /* 82267D2Ch */ case    6:  		/* lwz R8, <#[R27 + 26896]> */
		/* 82267D2Ch case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R27 + 0x00006910) );
		/* 82267D2Ch case    6:*/		return 0x82267D30;
		  /* 82267D30h */ case    7:  		/* srw R9, R11, R9 */
		/* 82267D30h case    7:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 82267D30h case    7:*/		return 0x82267D34;
		  /* 82267D34h */ case    8:  		/* add R9, R9, R8 */
		/* 82267D34h case    8:*/		cpu::op::add<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 82267D34h case    8:*/		return 0x82267D38;
		  /* 82267D38h */ case    9:  		/* sth R9, <#[R5 + 2]> */
		/* 82267D38h case    9:*/		cpu::mem::store16( regs, regs.R9, (uint32)(regs.R5 + 0x00000002) );
		/* 82267D38h case    9:*/		return 0x82267D3C;
		  /* 82267D3Ch */ case   10:  		/* addi R5, R5, 2 */
		/* 82267D3Ch case   10:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x2);
		/* 82267D3Ch case   10:*/		return 0x82267D40;
	}
	return 0x82267D40;
} // Block from 82267D14h-82267D40h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82267D40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267D40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267D40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267D40);
		  /* 82267D40h */ case    0:  		/* addi R3, R7, 1 */
		/* 82267D40h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R7,0x1);
		/* 82267D40h case    0:*/		return 0x82267D44;
		  /* 82267D44h */ case    1:  		/* cmpw CR6, R3, R6 */
		/* 82267D44h case    1:*/		cpu::op::cmpw<6>(regs,regs.R3,regs.R6);
		/* 82267D44h case    1:*/		return 0x82267D48;
		  /* 82267D48h */ case    2:  		/* bc 12, CR6_GT, 24 */
		/* 82267D48h case    2:*/		if ( regs.CR[6].gt ) { return 0x82267D60;  }
		/* 82267D48h case    2:*/		return 0x82267D4C;
		  /* 82267D4Ch */ case    3:  		/* lwz R9, <#[R28 + 26892]> */
		/* 82267D4Ch case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x0000690C) );
		/* 82267D4Ch case    3:*/		return 0x82267D50;
		  /* 82267D50h */ case    4:  		/* lwz R8, <#[R29 + 26900]> */
		/* 82267D50h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R29 + 0x00006914) );
		/* 82267D50h case    4:*/		return 0x82267D54;
		  /* 82267D54h */ case    5:  		/* and R11, R9, R11 */
		/* 82267D54h case    5:*/		cpu::op::and<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82267D54h case    5:*/		return 0x82267D58;
		  /* 82267D58h */ case    6:  		/* add R11, R11, R8 */
		/* 82267D58h case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 82267D58h case    6:*/		return 0x82267D5C;
		  /* 82267D5Ch */ case    7:  		/* sthu R11, <#[R5 + 2]> */
		/* 82267D5Ch case    7:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R5 + 0x00000002) );
		regs.R5 = (uint32)(regs.R5 + 0x00000002);
		/* 82267D5Ch case    7:*/		return 0x82267D60;
	}
	return 0x82267D60;
} // Block from 82267D40h-82267D60h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82267D60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267D60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267D60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267D60);
		  /* 82267D60h */ case    0:  		/* cmpw CR6, R31, R4 */
		/* 82267D60h case    0:*/		cpu::op::cmpw<6>(regs,regs.R31,regs.R4);
		/* 82267D60h case    0:*/		return 0x82267D64;
		  /* 82267D64h */ case    1:  		/* bc 12, CR6_LT, -344 */
		/* 82267D64h case    1:*/		if ( regs.CR[6].lt ) { return 0x82267C0C;  }
		/* 82267D64h case    1:*/		return 0x82267D68;
	}
	return 0x82267D68;
} // Block from 82267D60h-82267D68h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82267D68h
// Function 'XInputGetCapabilities'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267D68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267D68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267D68);
		  /* 82267D68h */ case    0:  		/* cmpwi CR6, R6, 0 */
		/* 82267D68h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x00000000);
		/* 82267D68h case    0:*/		return 0x82267D6C;
		  /* 82267D6Ch */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 82267D6Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x82267D84;  }
		/* 82267D6Ch case    1:*/		return 0x82267D70;
	}
	return 0x82267D70;
} // Block from 82267D68h-82267D70h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82267D70h
// Function 'XInputGetState'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267D70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267D70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267D70);
		  /* 82267D70h */ case    0:  		/* cmpw CR6, R6, R3 */
		/* 82267D70h case    0:*/		cpu::op::cmpw<6>(regs,regs.R6,regs.R3);
		/* 82267D70h case    0:*/		return 0x82267D74;
		  /* 82267D74h */ case    1:  		/* bc 4, CR6_LT, 16 */
		/* 82267D74h case    1:*/		if ( !regs.CR[6].lt ) { return 0x82267D84;  }
		/* 82267D74h case    1:*/		return 0x82267D78;
		  /* 82267D78h */ case    2:  		/* li R3, 122 */
		/* 82267D78h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x7A);
		/* 82267D78h case    2:*/		return 0x82267D7C;
		  /* 82267D7Ch */ case    3:  		/* bl -1955460 */
		/* 82267D7Ch case    3:*/		regs.LR = 0x82267D80; return 0x8208A6F8;
		/* 82267D7Ch case    3:*/		return 0x82267D80;
	}
	return 0x82267D80;
} // Block from 82267D70h-82267D80h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82267D80h
// Function 'XLaunchNewImage'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267D80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267D80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267D80);
		  /* 82267D80h */ case    0:  		/* li R3, 0 */
		/* 82267D80h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82267D80h case    0:*/		return 0x82267D84;
	}
	return 0x82267D84;
} // Block from 82267D80h-82267D84h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82267D84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267D84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267D84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267D84);
		  /* 82267D84h */ case    0:  		/* addi R1, R1, 192 */
		/* 82267D84h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 82267D84h case    0:*/		return 0x82267D88;
		  /* 82267D88h */ case    1:  		/* b -1927936 */
		/* 82267D88h case    1:*/		return 0x82091288;
		/* 82267D88h case    1:*/		return 0x82267D8C;
		  /* 82267D8Ch */ case    2:  		/* nop */
		/* 82267D8Ch case    2:*/		cpu::op::nop();
		/* 82267D8Ch case    2:*/		return 0x82267D90;
	}
	return 0x82267D90;
} // Block from 82267D84h-82267D90h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82267D90h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267D90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267D90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267D90);
		  /* 82267D90h */ case    0:  		/* mr R11, R3 */
		/* 82267D90h case    0:*/		regs.R11 = regs.R3;
		/* 82267D90h case    0:*/		return 0x82267D94;
		  /* 82267D94h */ case    1:  		/* lbz R10, <#[R11]> */
		/* 82267D94h case    1:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82267D94h case    1:*/		return 0x82267D98;
		  /* 82267D98h */ case    2:  		/* addi R11, R11, 1 */
		/* 82267D98h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82267D98h case    2:*/		return 0x82267D9C;
		  /* 82267D9Ch */ case    3:  		/* cmplwi CR6, R10, 0 */
		/* 82267D9Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 82267D9Ch case    3:*/		return 0x82267DA0;
		  /* 82267DA0h */ case    4:  		/* bc 4, CR6_EQ, -12 */
		/* 82267DA0h case    4:*/		if ( !regs.CR[6].eq ) { return 0x82267D94;  }
		/* 82267DA0h case    4:*/		return 0x82267DA4;
		  /* 82267DA4h */ case    5:  		/* subf R11, R3, R11 */
		/* 82267DA4h case    5:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 82267DA4h case    5:*/		return 0x82267DA8;
		  /* 82267DA8h */ case    6:  		/* addi R11, R11, -1 */
		/* 82267DA8h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82267DA8h case    6:*/		return 0x82267DAC;
		  /* 82267DACh */ case    7:  		/* rlwinm R3, R11, 0, 0, 31 */
		/* 82267DACh case    7:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R3,regs.R11);
		/* 82267DACh case    7:*/		return 0x82267DB0;
		  /* 82267DB0h */ case    8:  		/* bclr 20, CR0_LT */
		/* 82267DB0h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82267DB0h case    8:*/		return 0x82267DB4;
	}
	return 0x82267DB4;
} // Block from 82267D90h-82267DB4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82267DB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267DB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267DB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267DB4);
		  /* 82267DB4h */ case    0:  		/* nop */
		/* 82267DB4h case    0:*/		cpu::op::nop();
		/* 82267DB4h case    0:*/		return 0x82267DB8;
	}
	return 0x82267DB8;
} // Block from 82267DB4h-82267DB8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82267DB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267DB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267DB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267DB8);
		  /* 82267DB8h */ case    0:  		/* mfspr R12, LR */
		/* 82267DB8h case    0:*/		regs.R12 = regs.LR;
		/* 82267DB8h case    0:*/		return 0x82267DBC;
		  /* 82267DBCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82267DBCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82267DBCh case    1:*/		return 0x82267DC0;
		  /* 82267DC0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82267DC0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82267DC0h case    2:*/		return 0x82267DC4;
		  /* 82267DC4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82267DC4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82267DC4h case    3:*/		return 0x82267DC8;
		  /* 82267DC8h */ case    4:  		/* stwu R1, <#[R1 - 128]> */
		/* 82267DC8h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82267DC8h case    4:*/		return 0x82267DCC;
		  /* 82267DCCh */ case    5:  		/* mr R30, R3 */
		/* 82267DCCh case    5:*/		regs.R30 = regs.R3;
		/* 82267DCCh case    5:*/		return 0x82267DD0;
		  /* 82267DD0h */ case    6:  		/* cmplwi CR6, R3, 0 */
		/* 82267DD0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82267DD0h case    6:*/		return 0x82267DD4;
		  /* 82267DD4h */ case    7:  		/* bc 4, CR6_EQ, 32 */
		/* 82267DD4h case    7:*/		if ( !regs.CR[6].eq ) { return 0x82267DF4;  }
		/* 82267DD4h case    7:*/		return 0x82267DD8;
		  /* 82267DD8h */ case    8:  		/* bl -1912528 */
		/* 82267DD8h case    8:*/		regs.LR = 0x82267DDC; return 0x82094F08;
		/* 82267DD8h case    8:*/		return 0x82267DDC;
		  /* 82267DDCh */ case    9:  		/* li R11, 22 */
		/* 82267DDCh case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x16);
		/* 82267DDCh case    9:*/		return 0x82267DE0;
		  /* 82267DE0h */ case   10:  		/* stw R11, <#[R3]> */
		/* 82267DE0h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82267DE0h case   10:*/		return 0x82267DE4;
		  /* 82267DE4h */ case   11:  		/* bl -1918084 */
		/* 82267DE4h case   11:*/		regs.LR = 0x82267DE8; return 0x82093960;
		/* 82267DE4h case   11:*/		return 0x82267DE8;
		  /* 82267DE8h */ case   12:  		/* lis R11, -32256 */
		/* 82267DE8h case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82267DE8h case   12:*/		return 0x82267DEC;
		  /* 82267DECh */ case   13:  		/* lfd FR1, <#[R11 + 1808]> */
		/* 82267DECh case   13:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R11 + 0x00000710) );
		/* 82267DECh case   13:*/		return 0x82267DF0;
		  /* 82267DF0h */ case   14:  		/* b 108 */
		/* 82267DF0h case   14:*/		return 0x82267E5C;
		/* 82267DF0h case   14:*/		return 0x82267DF4;
	}
	return 0x82267DF4;
} // Block from 82267DB8h-82267DF4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82267DF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267DF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267DF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267DF4);
		  /* 82267DF4h */ case    0:  		/* lis R11, -32217 */
		/* 82267DF4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82267DF4h case    0:*/		return 0x82267DF8;
		  /* 82267DF8h */ case    1:  		/* addi R31, R11, 8856 */
		/* 82267DF8h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x2298);
		/* 82267DF8h case    1:*/		return 0x82267DFC;
		  /* 82267DFCh */ case    2:  		/* lwz R11, <#[R11 + 8856]> */
		/* 82267DFCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00002298) );
		/* 82267DFCh case    2:*/		return 0x82267E00;
		  /* 82267E00h */ case    3:  		/* lwz R10, <#[R11 + 172]> */
		/* 82267E00h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x000000AC) );
		/* 82267E00h case    3:*/		return 0x82267E04;
		  /* 82267E04h */ case    4:  		/* cmpwi CR6, R10, 1 */
		/* 82267E04h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000001);
		/* 82267E04h case    4:*/		return 0x82267E08;
		  /* 82267E08h */ case    5:  		/* bc 4, CR6_GT, 28 */
		/* 82267E08h case    5:*/		if ( !regs.CR[6].gt ) { return 0x82267E24;  }
		/* 82267E08h case    5:*/		return 0x82267E0C;
		  /* 82267E0Ch */ case    6:  		/* mr R5, R31 */
		/* 82267E0Ch case    6:*/		regs.R5 = regs.R31;
		/* 82267E0Ch case    6:*/		return 0x82267E10;
		  /* 82267E10h */ case    7:  		/* lbz R3, <#[R30]> */
		/* 82267E10h case    7:*/		cpu::mem::load8z( regs, &regs.R3, (uint32)(regs.R30 + 0x00000000) );
		/* 82267E10h case    7:*/		return 0x82267E14;
		  /* 82267E14h */ case    8:  		/* li R4, 8 */
		/* 82267E14h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x8);
		/* 82267E14h case    8:*/		return 0x82267E18;
		  /* 82267E18h */ case    9:  		/* bl -1887552 */
		/* 82267E18h case    9:*/		regs.LR = 0x82267E1C; return 0x8209B0D8;
		/* 82267E18h case    9:*/		return 0x82267E1C;
		  /* 82267E1Ch */ case   10:  		/* lwz R11, <#[R31]> */
		/* 82267E1Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82267E1Ch case   10:*/		return 0x82267E20;
		  /* 82267E20h */ case   11:  		/* b 24 */
		/* 82267E20h case   11:*/		return 0x82267E38;
		/* 82267E20h case   11:*/		return 0x82267E24;
	}
	return 0x82267E24;
} // Block from 82267DF4h-82267E24h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82267E24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267E24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267E24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267E24);
		  /* 82267E24h */ case    0:  		/* lbz R10, <#[R30]> */
		/* 82267E24h case    0:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 82267E24h case    0:*/		return 0x82267E28;
		  /* 82267E28h */ case    1:  		/* lwz R9, <#[R11 + 200]> */
		/* 82267E28h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x000000C8) );
		/* 82267E28h case    1:*/		return 0x82267E2C;
		  /* 82267E2Ch */ case    2:  		/* rlwinm R10, R10, 1, 0, 31 */
		/* 82267E2Ch case    2:*/		cpu::op::rlwinm<0,1,0,31>(regs,&regs.R10,regs.R10);
		/* 82267E2Ch case    2:*/		return 0x82267E30;
		  /* 82267E30h */ case    3:  		/* lhzx R10, <#[R10 + R9]> */
		/* 82267E30h case    3:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82267E30h case    3:*/		return 0x82267E34;
		  /* 82267E34h */ case    4:  		/* rlwinm R3, R10, 0, 28, 28 */
		/* 82267E34h case    4:*/		cpu::op::rlwinm<0,0,28,28>(regs,&regs.R3,regs.R10);
		/* 82267E34h case    4:*/		return 0x82267E38;
	}
	return 0x82267E38;
} // Block from 82267E24h-82267E38h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82267E38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267E38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267E38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267E38);
		  /* 82267E38h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 82267E38h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 82267E38h case    0:*/		return 0x82267E3C;
		  /* 82267E3Ch */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 82267E3Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x82267E48;  }
		/* 82267E3Ch case    1:*/		return 0x82267E40;
		  /* 82267E40h */ case    2:  		/* addi R30, R30, 1 */
		/* 82267E40h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x1);
		/* 82267E40h case    2:*/		return 0x82267E44;
		  /* 82267E44h */ case    3:  		/* b -68 */
		/* 82267E44h case    3:*/		return 0x82267E00;
		/* 82267E44h case    3:*/		return 0x82267E48;
	}
	return 0x82267E48;
} // Block from 82267E38h-82267E48h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82267E48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267E48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267E48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267E48);
		  /* 82267E48h */ case    0:  		/* mr R5, R31 */
		/* 82267E48h case    0:*/		regs.R5 = regs.R31;
		/* 82267E48h case    0:*/		return 0x82267E4C;
		  /* 82267E4Ch */ case    1:  		/* mr R4, R30 */
		/* 82267E4Ch case    1:*/		regs.R4 = regs.R30;
		/* 82267E4Ch case    1:*/		return 0x82267E50;
	}
	return 0x82267E50;
} // Block from 82267E48h-82267E50h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82267E50h
// Function 'OutputDebugStringW'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267E50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267E50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267E50);
		  /* 82267E50h */ case    0:  		/* addi R3, R1, 80 */
		/* 82267E50h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82267E50h case    0:*/		return 0x82267E54;
		  /* 82267E54h */ case    1:  		/* bl 6244 */
		/* 82267E54h case    1:*/		regs.LR = 0x82267E58; return 0x822696B8;
		/* 82267E54h case    1:*/		return 0x82267E58;
		  /* 82267E58h */ case    2:  		/* lfd FR1, <#[R3 + 16]> */
		/* 82267E58h case    2:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R3 + 0x00000010) );
		/* 82267E58h case    2:*/		return 0x82267E5C;
	}
	return 0x82267E5C;
} // Block from 82267E50h-82267E5Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 82267E5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267E5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267E5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267E5C);
		  /* 82267E5Ch */ case    0:  		/* addi R1, R1, 128 */
		/* 82267E5Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82267E5Ch case    0:*/		return 0x82267E60;
		  /* 82267E60h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82267E60h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82267E60h case    1:*/		return 0x82267E64;
		  /* 82267E64h */ case    2:  		/* mtspr LR, R12 */
		/* 82267E64h case    2:*/		regs.LR = regs.R12;
		/* 82267E64h case    2:*/		return 0x82267E68;
		  /* 82267E68h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 82267E68h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82267E68h case    3:*/		return 0x82267E6C;
		  /* 82267E6Ch */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 82267E6Ch case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82267E6Ch case    4:*/		return 0x82267E70;
		  /* 82267E70h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82267E70h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82267E70h case    5:*/		return 0x82267E74;
	}
	return 0x82267E74;
} // Block from 82267E5Ch-82267E74h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82267E74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267E74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267E74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267E74);
		  /* 82267E74h */ case    0:  		/* nop */
		/* 82267E74h case    0:*/		cpu::op::nop();
		/* 82267E74h case    0:*/		return 0x82267E78;
	}
	return 0x82267E78;
} // Block from 82267E74h-82267E78h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82267E78h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267E78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267E78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267E78);
		  /* 82267E78h */ case    0:  		/* li R4, 0 */
		/* 82267E78h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82267E78h case    0:*/		return 0x82267E7C;
		  /* 82267E7Ch */ case    1:  		/* b -196 */
		/* 82267E7Ch case    1:*/		return 0x82267DB8;
		/* 82267E7Ch case    1:*/		return 0x82267E80;
	}
	return 0x82267E80;
} // Block from 82267E78h-82267E80h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82267E80h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267E80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267E80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267E80);
		  /* 82267E80h */ case    0:  		/* lbz R6, <#[R3]> */
		/* 82267E80h case    0:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R3 + 0x00000000) );
		/* 82267E80h case    0:*/		return 0x82267E84;
		  /* 82267E84h */ case    1:  		/* cmpwi CR0, R4, 0 */
		/* 82267E84h case    1:*/		cpu::op::cmpwi<0>(regs,regs.R4,0x00000000);
		/* 82267E84h case    1:*/		return 0x82267E88;
		  /* 82267E88h */ case    2:  		/* bc 12, CR0_EQ, 28 */
		/* 82267E88h case    2:*/		if ( regs.CR[0].eq ) { return 0x82267EA4;  }
		/* 82267E88h case    2:*/		return 0x82267E8C;
		  /* 82267E8Ch */ case    3:  		/* cmpwi CR1, R6, 0 */
		/* 82267E8Ch case    3:*/		cpu::op::cmpwi<1>(regs,regs.R6,0x00000000);
		/* 82267E8Ch case    3:*/		return 0x82267E90;
		  /* 82267E90h */ case    4:  		/* cmpw CR0, R6, R4 */
		/* 82267E90h case    4:*/		cpu::op::cmpw<0>(regs,regs.R6,regs.R4);
		/* 82267E90h case    4:*/		return 0x82267E94;
		  /* 82267E94h */ case    5:  		/* bc 12, CR1_EQ, 32 */
		/* 82267E94h case    5:*/		if ( regs.CR[1].eq ) { return 0x82267EB4;  }
		/* 82267E94h case    5:*/		return 0x82267E98;
		  /* 82267E98h */ case    6:  		/* bc 12, CR0_EQ, 32 */
		/* 82267E98h case    6:*/		if ( regs.CR[0].eq ) { return 0x82267EB8;  }
		/* 82267E98h case    6:*/		return 0x82267E9C;
		  /* 82267E9Ch */ case    7:  		/* lbzu R6, <#[R3 + 1]> */
		/* 82267E9Ch case    7:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R3 + 0x00000001) );
		regs.R3 = (uint32)(regs.R3 + 0x00000001);
		/* 82267E9Ch case    7:*/		return 0x82267EA0;
		  /* 82267EA0h */ case    8:  		/* b -20 */
		/* 82267EA0h case    8:*/		return 0x82267E8C;
		/* 82267EA0h case    8:*/		return 0x82267EA4;
	}
	return 0x82267EA4;
} // Block from 82267E80h-82267EA4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82267EA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267EA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267EA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267EA4);
		  /* 82267EA4h */ case    0:  		/* cmpwi CR0, R6, 0 */
		/* 82267EA4h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R6,0x00000000);
		/* 82267EA4h case    0:*/		return 0x82267EA8;
		  /* 82267EA8h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 82267EA8h case    1:*/		if ( regs.CR[0].eq ) { return 0x82267EB8;  }
		/* 82267EA8h case    1:*/		return 0x82267EAC;
		  /* 82267EACh */ case    2:  		/* lbzu R6, <#[R3 + 1]> */
		/* 82267EACh case    2:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R3 + 0x00000001) );
		regs.R3 = (uint32)(regs.R3 + 0x00000001);
		/* 82267EACh case    2:*/		return 0x82267EB0;
		  /* 82267EB0h */ case    3:  		/* b -12 */
		/* 82267EB0h case    3:*/		return 0x82267EA4;
		/* 82267EB0h case    3:*/		return 0x82267EB4;
	}
	return 0x82267EB4;
} // Block from 82267EA4h-82267EB4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82267EB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267EB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267EB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267EB4);
		  /* 82267EB4h */ case    0:  		/* li R3, 0 */
		/* 82267EB4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82267EB4h case    0:*/		return 0x82267EB8;
	}
	return 0x82267EB8;
} // Block from 82267EB4h-82267EB8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82267EB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267EB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267EB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267EB8);
		  /* 82267EB8h */ case    0:  		/* bclr 20, CR0_LT */
		/* 82267EB8h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82267EB8h case    0:*/		return 0x82267EBC;
	}
	return 0x82267EBC;
} // Block from 82267EB8h-82267EBCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 82267EBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267EBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267EBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267EBC);
		  /* 82267EBCh */ case    0:  		/* nop */
		/* 82267EBCh case    0:*/		cpu::op::nop();
		/* 82267EBCh case    0:*/		return 0x82267EC0;
	}
	return 0x82267EC0;
} // Block from 82267EBCh-82267EC0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82267EC0h
// Function 'FlushFileBuffers'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267EC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267EC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267EC0);
		  /* 82267EC0h */ case    0:  		/* cmpwi CR6, R3, 97 */
		/* 82267EC0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000061);
		/* 82267EC0h case    0:*/		return 0x82267EC4;
		  /* 82267EC4h */ case    1:  		/* bclr 12, CR6_LT */
		/* 82267EC4h case    1:*/		if ( regs.CR[6].lt ) { return (uint32)regs.LR; }
		/* 82267EC4h case    1:*/		return 0x82267EC8;
	}
	return 0x82267EC8;
} // Block from 82267EC0h-82267EC8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82267EC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267EC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267EC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267EC8);
		  /* 82267EC8h */ case    0:  		/* cmpwi CR6, R3, 122 */
		/* 82267EC8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x0000007A);
		/* 82267EC8h case    0:*/		return 0x82267ECC;
		  /* 82267ECCh */ case    1:  		/* bclr 12, CR6_GT */
		/* 82267ECCh case    1:*/		if ( regs.CR[6].gt ) { return (uint32)regs.LR; }
		/* 82267ECCh case    1:*/		return 0x82267ED0;
	}
	return 0x82267ED0;
} // Block from 82267EC8h-82267ED0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82267ED0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267ED0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267ED0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267ED0);
		  /* 82267ED0h */ case    0:  		/* addi R3, R3, -32 */
		/* 82267ED0h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0xFFFFFFE0);
		/* 82267ED0h case    0:*/		return 0x82267ED4;
		  /* 82267ED4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82267ED4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82267ED4h case    1:*/		return 0x82267ED8;
	}
	return 0x82267ED8;
} // Block from 82267ED0h-82267ED8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82267ED8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267ED8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267ED8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267ED8);
		  /* 82267ED8h */ case    0:  		/* fabs FR0, FR1 */
		/* 82267ED8h case    0:*/		cpu::op::fabs<0>(regs,&regs.FR0,regs.FR1);
		/* 82267ED8h case    0:*/		return 0x82267EDC;
		  /* 82267EDCh */ case    1:  		/* lis R11, -32216 */
		/* 82267EDCh case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 82267EDCh case    1:*/		return 0x82267EE0;
		  /* 82267EE0h */ case    2:  		/* stfd FR0, <#[R1 - 16]> */
		/* 82267EE0h case    2:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82267EE0h case    2:*/		return 0x82267EE4;
		  /* 82267EE4h */ case    3:  		/* addi R11, R11, 27184 */
		/* 82267EE4h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6A30);
		/* 82267EE4h case    3:*/		return 0x82267EE8;
		  /* 82267EE8h */ case    4:  		/* lfs FR13, <#[R11 + 176]> */
		/* 82267EE8h case    4:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R11 + 0x000000B0) );
		/* 82267EE8h case    4:*/		return 0x82267EEC;
		  /* 82267EECh */ case    5:  		/* fcmpu CR6, FR0, FR13 */
		/* 82267EECh case    5:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82267EECh case    5:*/		return 0x82267EF0;
		  /* 82267EF0h */ case    6:  		/* bc 4, CR6_GT, 36 */
		/* 82267EF0h case    6:*/		if ( !regs.CR[6].gt ) { return 0x82267F14;  }
		/* 82267EF0h case    6:*/		return 0x82267EF4;
		  /* 82267EF4h */ case    7:  		/* lfd FR12, <#[R11 + 48]> */
		/* 82267EF4h case    7:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R11 + 0x00000030) );
		/* 82267EF4h case    7:*/		return 0x82267EF8;
		  /* 82267EF8h */ case    8:  		/* fcmpu CR6, FR0, FR12 */
		/* 82267EF8h case    8:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR12);
		/* 82267EF8h case    8:*/		return 0x82267EFC;
		  /* 82267EFCh */ case    9:  		/* bc 4, CR6_GT, 12 */
		/* 82267EFCh case    9:*/		if ( !regs.CR[6].gt ) { return 0x82267F08;  }
		/* 82267EFCh case    9:*/		return 0x82267F00;
	}
	return 0x82267F00;
} // Block from 82267ED8h-82267F00h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82267F00h
// Function 'WideCharToMultiByte'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267F00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267F00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267F00);
		  /* 82267F00h */ case    0:  		/* lfd FR0, <#[R11 + 8]> */
		/* 82267F00h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000008) );
		/* 82267F00h case    0:*/		return 0x82267F04;
		  /* 82267F04h */ case    1:  		/* b 160 */
		/* 82267F04h case    1:*/		return 0x82267FA4;
		/* 82267F04h case    1:*/		return 0x82267F08;
	}
	return 0x82267F08;
} // Block from 82267F00h-82267F08h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82267F08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267F08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267F08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267F08);
		  /* 82267F08h */ case    0:  		/* li R10, 2 */
		/* 82267F08h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x2);
		/* 82267F08h case    0:*/		return 0x82267F0C;
		  /* 82267F0Ch */ case    1:  		/* fdiv FR0, FR13, FR0 */
		/* 82267F0Ch case    1:*/		cpu::op::fdiv<0>(regs,&regs.FR0,regs.FR13,regs.FR0);
		/* 82267F0Ch case    1:*/		return 0x82267F10;
		  /* 82267F10h */ case    2:  		/* b 8 */
		/* 82267F10h case    2:*/		return 0x82267F18;
		/* 82267F10h case    2:*/		return 0x82267F14;
	}
	return 0x82267F14;
} // Block from 82267F08h-82267F14h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82267F14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267F14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267F14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267F14);
		  /* 82267F14h */ case    0:  		/* li R10, 0 */
		/* 82267F14h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82267F14h case    0:*/		return 0x82267F18;
	}
	return 0x82267F18;
} // Block from 82267F14h-82267F18h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82267F18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267F18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267F18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267F18);
		  /* 82267F18h */ case    0:  		/* lfd FR12, <#[R11 + 24]> */
		/* 82267F18h case    0:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R11 + 0x00000018) );
		/* 82267F18h case    0:*/		return 0x82267F1C;
		  /* 82267F1Ch */ case    1:  		/* fcmpu CR6, FR0, FR12 */
		/* 82267F1Ch case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR12);
		/* 82267F1Ch case    1:*/		return 0x82267F20;
		  /* 82267F20h */ case    2:  		/* bc 4, CR6_GT, 24 */
		/* 82267F20h case    2:*/		if ( !regs.CR[6].gt ) { return 0x82267F38;  }
		/* 82267F20h case    2:*/		return 0x82267F24;
		  /* 82267F24h */ case    3:  		/* lfd FR12, <#[R11 + 40]> */
		/* 82267F24h case    3:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R11 + 0x00000028) );
		/* 82267F24h case    3:*/		return 0x82267F28;
		  /* 82267F28h */ case    4:  		/* addi R10, R10, 1 */
		/* 82267F28h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82267F28h case    4:*/		return 0x82267F2C;
		  /* 82267F2Ch */ case    5:  		/* fadd FR11, FR12, FR0 */
		/* 82267F2Ch case    5:*/		cpu::op::fadd<0>(regs,&regs.FR11,regs.FR12,regs.FR0);
		/* 82267F2Ch case    5:*/		return 0x82267F30;
		  /* 82267F30h */ case    6:  		/* fmsub FR0, FR12, FR0, FR13 */
		/* 82267F30h case    6:*/		cpu::op::fmsub<0>(regs,&regs.FR0,regs.FR12,regs.FR0,regs.FR13);
		/* 82267F30h case    6:*/		return 0x82267F34;
		  /* 82267F34h */ case    7:  		/* fdiv FR0, FR0, FR11 */
		/* 82267F34h case    7:*/		cpu::op::fdiv<0>(regs,&regs.FR0,regs.FR0,regs.FR11);
		/* 82267F34h case    7:*/		return 0x82267F38;
	}
	return 0x82267F38;
} // Block from 82267F18h-82267F38h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82267F38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267F38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267F38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267F38);
		  /* 82267F38h */ case    0:  		/* fmul FR5, FR0, FR0 */
		/* 82267F38h case    0:*/		cpu::op::fmul<0>(regs,&regs.FR5,regs.FR0,regs.FR0);
		/* 82267F38h case    0:*/		return 0x82267F3C;
		  /* 82267F3Ch */ case    1:  		/* lfd FR12, <#[R11 + 72]> */
		/* 82267F3Ch case    1:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R11 + 0x00000048) );
		/* 82267F3Ch case    1:*/		return 0x82267F40;
		  /* 82267F40h */ case    2:  		/* lfd FR13, <#[R11 + 80]> */
		/* 82267F40h case    2:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000050) );
		/* 82267F40h case    2:*/		return 0x82267F44;
		  /* 82267F44h */ case    3:  		/* cmpwi CR6, R10, 1 */
		/* 82267F44h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000001);
		/* 82267F44h case    3:*/		return 0x82267F48;
		  /* 82267F48h */ case    4:  		/* lfd FR11, <#[R11 + 112]> */
		/* 82267F48h case    4:*/		cpu::mem::load64f( regs, &regs.FR11, (uint32)(regs.R11 + 0x00000070) );
		/* 82267F48h case    4:*/		return 0x82267F4C;
		  /* 82267F4Ch */ case    5:  		/* lfd FR10, <#[R11 + 64]> */
		/* 82267F4Ch case    5:*/		cpu::mem::load64f( regs, &regs.FR10, (uint32)(regs.R11 + 0x00000040) );
		/* 82267F4Ch case    5:*/		return 0x82267F50;
		  /* 82267F50h */ case    6:  		/* lfd FR9, <#[R11 + 104]> */
		/* 82267F50h case    6:*/		cpu::mem::load64f( regs, &regs.FR9, (uint32)(regs.R11 + 0x00000068) );
		/* 82267F50h case    6:*/		return 0x82267F54;
		  /* 82267F54h */ case    7:  		/* lfd FR8, <#[R11 + 56]> */
		/* 82267F54h case    7:*/		cpu::mem::load64f( regs, &regs.FR8, (uint32)(regs.R11 + 0x00000038) );
		/* 82267F54h case    7:*/		return 0x82267F58;
		  /* 82267F58h */ case    8:  		/* lfd FR7, <#[R11 + 96]> */
		/* 82267F58h case    8:*/		cpu::mem::load64f( regs, &regs.FR7, (uint32)(regs.R11 + 0x00000060) );
		/* 82267F58h case    8:*/		return 0x82267F5C;
		  /* 82267F5Ch */ case    9:  		/* lfd FR6, <#[R11 + 88]> */
		/* 82267F5Ch case    9:*/		cpu::mem::load64f( regs, &regs.FR6, (uint32)(regs.R11 + 0x00000058) );
		/* 82267F5Ch case    9:*/		return 0x82267F60;
		  /* 82267F60h */ case   10:  		/* fmadd FR13, FR13, FR5, FR12 */
		/* 82267F60h case   10:*/		cpu::op::fmadd<0>(regs,&regs.FR13,regs.FR13,regs.FR5,regs.FR12);
		/* 82267F60h case   10:*/		return 0x82267F64;
		  /* 82267F64h */ case   11:  		/* fadd FR12, FR11, FR5 */
		/* 82267F64h case   11:*/		cpu::op::fadd<0>(regs,&regs.FR12,regs.FR11,regs.FR5);
		/* 82267F64h case   11:*/		return 0x82267F68;
		  /* 82267F68h */ case   12:  		/* fmadd FR13, FR13, FR5, FR10 */
		/* 82267F68h case   12:*/		cpu::op::fmadd<0>(regs,&regs.FR13,regs.FR13,regs.FR5,regs.FR10);
		/* 82267F68h case   12:*/		return 0x82267F6C;
		  /* 82267F6Ch */ case   13:  		/* fmadd FR12, FR12, FR5, FR9 */
		/* 82267F6Ch case   13:*/		cpu::op::fmadd<0>(regs,&regs.FR12,regs.FR12,regs.FR5,regs.FR9);
		/* 82267F6Ch case   13:*/		return 0x82267F70;
		  /* 82267F70h */ case   14:  		/* fmadd FR13, FR13, FR5, FR8 */
		/* 82267F70h case   14:*/		cpu::op::fmadd<0>(regs,&regs.FR13,regs.FR13,regs.FR5,regs.FR8);
		/* 82267F70h case   14:*/		return 0x82267F74;
		  /* 82267F74h */ case   15:  		/* fmadd FR12, FR12, FR5, FR7 */
		/* 82267F74h case   15:*/		cpu::op::fmadd<0>(regs,&regs.FR12,regs.FR12,regs.FR5,regs.FR7);
		/* 82267F74h case   15:*/		return 0x82267F78;
		  /* 82267F78h */ case   16:  		/* fmul FR13, FR13, FR5 */
		/* 82267F78h case   16:*/		cpu::op::fmul<0>(regs,&regs.FR13,regs.FR13,regs.FR5);
		/* 82267F78h case   16:*/		return 0x82267F7C;
		  /* 82267F7Ch */ case   17:  		/* fmadd FR12, FR12, FR5, FR6 */
		/* 82267F7Ch case   17:*/		cpu::op::fmadd<0>(regs,&regs.FR12,regs.FR12,regs.FR5,regs.FR6);
		/* 82267F7Ch case   17:*/		return 0x82267F80;
		  /* 82267F80h */ case   18:  		/* fmul FR13, FR13, FR0 */
		/* 82267F80h case   18:*/		cpu::op::fmul<0>(regs,&regs.FR13,regs.FR13,regs.FR0);
		/* 82267F80h case   18:*/		return 0x82267F84;
		  /* 82267F84h */ case   19:  		/* fdiv FR13, FR13, FR12 */
		/* 82267F84h case   19:*/		cpu::op::fdiv<0>(regs,&regs.FR13,regs.FR13,regs.FR12);
		/* 82267F84h case   19:*/		return 0x82267F88;
		  /* 82267F88h */ case   20:  		/* fadd FR0, FR13, FR0 */
		/* 82267F88h case   20:*/		cpu::op::fadd<0>(regs,&regs.FR0,regs.FR13,regs.FR0);
		/* 82267F88h case   20:*/		return 0x82267F8C;
		  /* 82267F8Ch */ case   21:  		/* bc 4, CR6_GT, 8 */
		/* 82267F8Ch case   21:*/		if ( !regs.CR[6].gt ) { return 0x82267F94;  }
		/* 82267F8Ch case   21:*/		return 0x82267F90;
		  /* 82267F90h */ case   22:  		/* fneg FR0, FR0 */
		/* 82267F90h case   22:*/		cpu::op::fneg<0>(regs,&regs.FR0,regs.FR0);
		/* 82267F90h case   22:*/		return 0x82267F94;
	}
	return 0x82267F94;
} // Block from 82267F38h-82267F94h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82267F94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267F94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267F94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267F94);
		  /* 82267F94h */ case    0:  		/* rlwinm R10, R10, 3, 0, 28 */
		/* 82267F94h case    0:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R10);
		/* 82267F94h case    0:*/		return 0x82267F98;
		  /* 82267F98h */ case    1:  		/* addi R11, R11, 128 */
		/* 82267F98h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x80);
		/* 82267F98h case    1:*/		return 0x82267F9C;
		  /* 82267F9Ch */ case    2:  		/* lfdx FR13, <#[R10 + R11]> */
		/* 82267F9Ch case    2:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82267F9Ch case    2:*/		return 0x82267FA0;
		  /* 82267FA0h */ case    3:  		/* fadd FR0, FR13, FR0 */
		/* 82267FA0h case    3:*/		cpu::op::fadd<0>(regs,&regs.FR0,regs.FR13,regs.FR0);
		/* 82267FA0h case    3:*/		return 0x82267FA4;
	}
	return 0x82267FA4;
} // Block from 82267F94h-82267FA4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82267FA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267FA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267FA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267FA4);
		  /* 82267FA4h */ case    0:  		/* ld R11, <#[R1 - 16]> */
		/* 82267FA4h case    0:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82267FA4h case    0:*/		return 0x82267FA8;
		  /* 82267FA8h */ case    1:  		/* cmpdi CR6, R11, 0 */
		/* 82267FA8h case    1:*/		cpu::op::cmpdi<6>(regs,regs.R11,0x00000000);
		/* 82267FA8h case    1:*/		return 0x82267FAC;
		  /* 82267FACh */ case    2:  		/* bclr 12, CR6_EQ */
		/* 82267FACh case    2:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 82267FACh case    2:*/		return 0x82267FB0;
	}
	return 0x82267FB0;
} // Block from 82267FA4h-82267FB0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82267FB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267FB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267FB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267FB0);
		  /* 82267FB0h */ case    0:  		/* fneg FR13, FR0 */
		/* 82267FB0h case    0:*/		cpu::op::fneg<0>(regs,&regs.FR13,regs.FR0);
		/* 82267FB0h case    0:*/		return 0x82267FB4;
		  /* 82267FB4h */ case    1:  		/* fsel FR1, FR1, FR0, FR13 */
		/* 82267FB4h case    1:*/		cpu::op::fsel<0>(regs,&regs.FR1,regs.FR1,regs.FR0,regs.FR13);
		/* 82267FB4h case    1:*/		return 0x82267FB8;
		  /* 82267FB8h */ case    2:  		/* bclr 20, CR0_LT */
		/* 82267FB8h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82267FB8h case    2:*/		return 0x82267FBC;
	}
	return 0x82267FBC;
} // Block from 82267FB0h-82267FBCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 82267FBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267FBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267FBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267FBC);
		  /* 82267FBCh */ case    0:  		/* nop */
		/* 82267FBCh case    0:*/		cpu::op::nop();
		/* 82267FBCh case    0:*/		return 0x82267FC0;
	}
	return 0x82267FC0;
} // Block from 82267FBCh-82267FC0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82267FC0h
// Function 'GetFileAttributesA'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267FC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267FC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267FC0);
		  /* 82267FC0h */ case    0:  		/* lis R11, -32216 */
		/* 82267FC0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 82267FC0h case    0:*/		return 0x82267FC4;
		  /* 82267FC4h */ case    1:  		/* stfd FR1, <#[R1 + 16]> */
		/* 82267FC4h case    1:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000010) );
		/* 82267FC4h case    1:*/		return 0x82267FC8;
		  /* 82267FC8h */ case    2:  		/* stfd FR2, <#[R1 + 24]> */
		/* 82267FC8h case    2:*/		cpu::mem::store64f( regs, regs.FR2, (uint32)(regs.R1 + 0x00000018) );
		/* 82267FC8h case    2:*/		return 0x82267FCC;
		  /* 82267FCCh */ case    3:  		/* addi R11, R11, 27184 */
		/* 82267FCCh case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6A30);
		/* 82267FCCh case    3:*/		return 0x82267FD0;
		  /* 82267FD0h */ case    4:  		/* lfs FR0, <#[R11 + 168]> */
		/* 82267FD0h case    4:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x000000A8) );
		/* 82267FD0h case    4:*/		return 0x82267FD4;
		  /* 82267FD4h */ case    5:  		/* fcmpu CR6, FR2, FR0 */
		/* 82267FD4h case    5:*/		cpu::op::fcmpu<6>(regs,regs.FR2,regs.FR0);
		/* 82267FD4h case    5:*/		return 0x82267FD8;
		  /* 82267FD8h */ case    6:  		/* bc 4, CR6_EQ, 64 */
		/* 82267FD8h case    6:*/		if ( !regs.CR[6].eq ) { return 0x82268018;  }
		/* 82267FD8h case    6:*/		return 0x82267FDC;
		  /* 82267FDCh */ case    7:  		/* fcmpu CR6, FR1, FR0 */
		/* 82267FDCh case    7:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 82267FDCh case    7:*/		return 0x82267FE0;
		  /* 82267FE0h */ case    8:  		/* bc 4, CR6_EQ, 48 */
		/* 82267FE0h case    8:*/		if ( !regs.CR[6].eq ) { return 0x82268010;  }
		/* 82267FE0h case    8:*/		return 0x82267FE4;
		  /* 82267FE4h */ case    9:  		/* lwz R10, <#[R1 + 24]> */
		/* 82267FE4h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000018) );
		/* 82267FE4h case    9:*/		return 0x82267FE8;
		  /* 82267FE8h */ case   10:  		/* rlwinm. R10, R10, 0, 0, 0 */
		/* 82267FE8h case   10:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R10,regs.R10);
		/* 82267FE8h case   10:*/		return 0x82267FEC;
		  /* 82267FECh */ case   11:  		/* bclr 12, CR0_EQ */
		/* 82267FECh case   11:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 82267FECh case   11:*/		return 0x82267FF0;
	}
	return 0x82267FF0;
} // Block from 82267FC0h-82267FF0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82267FF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82267FF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82267FF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82267FF0);
		  /* 82267FF0h */ case    0:  		/* lwz R10, <#[R1 + 16]> */
		/* 82267FF0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000010) );
		/* 82267FF0h case    0:*/		return 0x82267FF4;
		  /* 82267FF4h */ case    1:  		/* rlwinm. R10, R10, 0, 0, 0 */
		/* 82267FF4h case    1:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R10,regs.R10);
		/* 82267FF4h case    1:*/		return 0x82267FF8;
		  /* 82267FF8h */ case    2:  		/* bc 12, CR0_EQ, 16 */
		/* 82267FF8h case    2:*/		if ( regs.CR[0].eq ) { return 0x82268008;  }
		/* 82267FF8h case    2:*/		return 0x82267FFC;
		  /* 82267FFCh */ case    3:  		/* lfd FR0, <#[R11 + 16]> */
		/* 82267FFCh case    3:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000010) );
		/* 82267FFCh case    3:*/		return 0x82268000;
		  /* 82268000h */ case    4:  		/* fneg FR1, FR0 */
		/* 82268000h case    4:*/		cpu::op::fneg<0>(regs,&regs.FR1,regs.FR0);
		/* 82268000h case    4:*/		return 0x82268004;
		  /* 82268004h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82268004h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82268004h case    5:*/		return 0x82268008;
	}
	return 0x82268008;
} // Block from 82267FF0h-82268008h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82268008h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268008( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268008) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268008);
		  /* 82268008h */ case    0:  		/* lfd FR1, <#[R11 + 16]> */
		/* 82268008h case    0:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R11 + 0x00000010) );
		/* 82268008h case    0:*/		return 0x8226800C;
		  /* 8226800Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 8226800Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8226800Ch case    1:*/		return 0x82268010;
	}
	return 0x82268010;
} // Block from 82268008h-82268010h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82268010h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268010( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268010) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268010);
		  /* 82268010h */ case    0:  		/* lfd FR0, <#[R11 + 8]> */
		/* 82268010h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000008) );
		/* 82268010h case    0:*/		return 0x82268014;
		  /* 82268014h */ case    1:  		/* b 188 */
		/* 82268014h case    1:*/		return 0x822680D0;
		/* 82268014h case    1:*/		return 0x82268018;
	}
	return 0x82268018;
} // Block from 82268010h-82268018h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82268018h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268018( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268018) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268018);
		  /* 82268018h */ case    0:  		/* fabs FR13, FR2 */
		/* 82268018h case    0:*/		cpu::op::fabs<0>(regs,&regs.FR13,regs.FR2);
		/* 82268018h case    0:*/		return 0x8226801C;
		  /* 8226801Ch */ case    1:  		/* li R10, 0 */
		/* 8226801Ch case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8226801Ch case    1:*/		return 0x82268020;
		  /* 82268020h */ case    2:  		/* fabs FR0, FR1 */
		/* 82268020h case    2:*/		cpu::op::fabs<0>(regs,&regs.FR0,regs.FR1);
		/* 82268020h case    2:*/		return 0x82268024;
		  /* 82268024h */ case    3:  		/* fmr FR12, FR13 */
		/* 82268024h case    3:*/		cpu::op::fmr<0>(regs,&regs.FR12,regs.FR13);
		/* 82268024h case    3:*/		return 0x82268028;
	}
	return 0x82268028;
} // Block from 82268018h-82268028h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82268028h
// Function 'lstrcmpiA'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268028( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268028) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268028);
		  /* 82268028h */ case    0:  		/* fcmpu CR6, FR0, FR13 */
		/* 82268028h case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82268028h case    0:*/		return 0x8226802C;
		  /* 8226802Ch */ case    1:  		/* bc 4, CR6_GT, 16 */
		/* 8226802Ch case    1:*/		if ( !regs.CR[6].gt ) { return 0x8226803C;  }
		/* 8226802Ch case    1:*/		return 0x82268030;
		  /* 82268030h */ case    2:  		/* fmr FR12, FR0 */
		/* 82268030h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR12,regs.FR0);
		/* 82268030h case    2:*/		return 0x82268034;
		  /* 82268034h */ case    3:  		/* li R10, 2 */
		/* 82268034h case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x2);
		/* 82268034h case    3:*/		return 0x82268038;
		  /* 82268038h */ case    4:  		/* fmr FR0, FR13 */
		/* 82268038h case    4:*/		cpu::op::fmr<0>(regs,&regs.FR0,regs.FR13);
		/* 82268038h case    4:*/		return 0x8226803C;
	}
	return 0x8226803C;
} // Block from 82268028h-8226803Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8226803Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226803C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226803C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226803C);
		  /* 8226803Ch */ case    0:  		/* fdiv FR0, FR0, FR12 */
		/* 8226803Ch case    0:*/		cpu::op::fdiv<0>(regs,&regs.FR0,regs.FR0,regs.FR12);
		/* 8226803Ch case    0:*/		return 0x82268040;
		  /* 82268040h */ case    1:  		/* lfd FR13, <#[R11 + 24]> */
		/* 82268040h case    1:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000018) );
		/* 82268040h case    1:*/		return 0x82268044;
		  /* 82268044h */ case    2:  		/* fcmpu CR6, FR0, FR13 */
		/* 82268044h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 82268044h case    2:*/		return 0x82268048;
		  /* 82268048h */ case    3:  		/* bc 4, CR6_GT, 28 */
		/* 82268048h case    3:*/		if ( !regs.CR[6].gt ) { return 0x82268064;  }
		/* 82268048h case    3:*/		return 0x8226804C;
		  /* 8226804Ch */ case    4:  		/* lfd FR13, <#[R11 + 40]> */
		/* 8226804Ch case    4:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000028) );
		/* 8226804Ch case    4:*/		return 0x82268050;
		  /* 82268050h */ case    5:  		/* addi R10, R10, 1 */
		/* 82268050h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82268050h case    5:*/		return 0x82268054;
		  /* 82268054h */ case    6:  		/* lfs FR12, <#[R11 + 176]> */
		/* 82268054h case    6:*/		cpu::mem::load32f( regs, &regs.FR12, (uint32)(regs.R11 + 0x000000B0) );
		/* 82268054h case    6:*/		return 0x82268058;
		  /* 82268058h */ case    7:  		/* fadd FR11, FR13, FR0 */
		/* 82268058h case    7:*/		cpu::op::fadd<0>(regs,&regs.FR11,regs.FR13,regs.FR0);
		/* 82268058h case    7:*/		return 0x8226805C;
		  /* 8226805Ch */ case    8:  		/* fmsub FR0, FR13, FR0, FR12 */
		/* 8226805Ch case    8:*/		cpu::op::fmsub<0>(regs,&regs.FR0,regs.FR13,regs.FR0,regs.FR12);
		/* 8226805Ch case    8:*/		return 0x82268060;
		  /* 82268060h */ case    9:  		/* fdiv FR0, FR0, FR11 */
		/* 82268060h case    9:*/		cpu::op::fdiv<0>(regs,&regs.FR0,regs.FR0,regs.FR11);
		/* 82268060h case    9:*/		return 0x82268064;
	}
	return 0x82268064;
} // Block from 8226803Ch-82268064h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82268064h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268064( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268064) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268064);
		  /* 82268064h */ case    0:  		/* fmul FR5, FR0, FR0 */
		/* 82268064h case    0:*/		cpu::op::fmul<0>(regs,&regs.FR5,regs.FR0,regs.FR0);
		/* 82268064h case    0:*/		return 0x82268068;
		  /* 82268068h */ case    1:  		/* lfd FR12, <#[R11 + 72]> */
		/* 82268068h case    1:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R11 + 0x00000048) );
		/* 82268068h case    1:*/		return 0x8226806C;
		  /* 8226806Ch */ case    2:  		/* lfd FR13, <#[R11 + 80]> */
		/* 8226806Ch case    2:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000050) );
		/* 8226806Ch case    2:*/		return 0x82268070;
		  /* 82268070h */ case    3:  		/* cmpwi CR6, R10, 1 */
		/* 82268070h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000001);
		/* 82268070h case    3:*/		return 0x82268074;
		  /* 82268074h */ case    4:  		/* lfd FR11, <#[R11 + 112]> */
		/* 82268074h case    4:*/		cpu::mem::load64f( regs, &regs.FR11, (uint32)(regs.R11 + 0x00000070) );
		/* 82268074h case    4:*/		return 0x82268078;
		  /* 82268078h */ case    5:  		/* lfd FR10, <#[R11 + 64]> */
		/* 82268078h case    5:*/		cpu::mem::load64f( regs, &regs.FR10, (uint32)(regs.R11 + 0x00000040) );
		/* 82268078h case    5:*/		return 0x8226807C;
		  /* 8226807Ch */ case    6:  		/* lfd FR9, <#[R11 + 104]> */
		/* 8226807Ch case    6:*/		cpu::mem::load64f( regs, &regs.FR9, (uint32)(regs.R11 + 0x00000068) );
		/* 8226807Ch case    6:*/		return 0x82268080;
		  /* 82268080h */ case    7:  		/* lfd FR8, <#[R11 + 56]> */
		/* 82268080h case    7:*/		cpu::mem::load64f( regs, &regs.FR8, (uint32)(regs.R11 + 0x00000038) );
		/* 82268080h case    7:*/		return 0x82268084;
		  /* 82268084h */ case    8:  		/* lfd FR7, <#[R11 + 96]> */
		/* 82268084h case    8:*/		cpu::mem::load64f( regs, &regs.FR7, (uint32)(regs.R11 + 0x00000060) );
		/* 82268084h case    8:*/		return 0x82268088;
		  /* 82268088h */ case    9:  		/* lfd FR6, <#[R11 + 88]> */
		/* 82268088h case    9:*/		cpu::mem::load64f( regs, &regs.FR6, (uint32)(regs.R11 + 0x00000058) );
		/* 82268088h case    9:*/		return 0x8226808C;
		  /* 8226808Ch */ case   10:  		/* fmadd FR13, FR13, FR5, FR12 */
		/* 8226808Ch case   10:*/		cpu::op::fmadd<0>(regs,&regs.FR13,regs.FR13,regs.FR5,regs.FR12);
		/* 8226808Ch case   10:*/		return 0x82268090;
		  /* 82268090h */ case   11:  		/* fadd FR12, FR11, FR5 */
		/* 82268090h case   11:*/		cpu::op::fadd<0>(regs,&regs.FR12,regs.FR11,regs.FR5);
		/* 82268090h case   11:*/		return 0x82268094;
		  /* 82268094h */ case   12:  		/* fmadd FR13, FR13, FR5, FR10 */
		/* 82268094h case   12:*/		cpu::op::fmadd<0>(regs,&regs.FR13,regs.FR13,regs.FR5,regs.FR10);
		/* 82268094h case   12:*/		return 0x82268098;
		  /* 82268098h */ case   13:  		/* fmadd FR12, FR12, FR5, FR9 */
		/* 82268098h case   13:*/		cpu::op::fmadd<0>(regs,&regs.FR12,regs.FR12,regs.FR5,regs.FR9);
		/* 82268098h case   13:*/		return 0x8226809C;
		  /* 8226809Ch */ case   14:  		/* fmadd FR13, FR13, FR5, FR8 */
		/* 8226809Ch case   14:*/		cpu::op::fmadd<0>(regs,&regs.FR13,regs.FR13,regs.FR5,regs.FR8);
		/* 8226809Ch case   14:*/		return 0x822680A0;
		  /* 822680A0h */ case   15:  		/* fmadd FR12, FR12, FR5, FR7 */
		/* 822680A0h case   15:*/		cpu::op::fmadd<0>(regs,&regs.FR12,regs.FR12,regs.FR5,regs.FR7);
		/* 822680A0h case   15:*/		return 0x822680A4;
		  /* 822680A4h */ case   16:  		/* fmul FR13, FR13, FR5 */
		/* 822680A4h case   16:*/		cpu::op::fmul<0>(regs,&regs.FR13,regs.FR13,regs.FR5);
		/* 822680A4h case   16:*/		return 0x822680A8;
		  /* 822680A8h */ case   17:  		/* fmadd FR12, FR12, FR5, FR6 */
		/* 822680A8h case   17:*/		cpu::op::fmadd<0>(regs,&regs.FR12,regs.FR12,regs.FR5,regs.FR6);
		/* 822680A8h case   17:*/		return 0x822680AC;
		  /* 822680ACh */ case   18:  		/* fmul FR13, FR13, FR0 */
		/* 822680ACh case   18:*/		cpu::op::fmul<0>(regs,&regs.FR13,regs.FR13,regs.FR0);
		/* 822680ACh case   18:*/		return 0x822680B0;
		  /* 822680B0h */ case   19:  		/* fdiv FR13, FR13, FR12 */
		/* 822680B0h case   19:*/		cpu::op::fdiv<0>(regs,&regs.FR13,regs.FR13,regs.FR12);
		/* 822680B0h case   19:*/		return 0x822680B4;
		  /* 822680B4h */ case   20:  		/* fadd FR0, FR13, FR0 */
		/* 822680B4h case   20:*/		cpu::op::fadd<0>(regs,&regs.FR0,regs.FR13,regs.FR0);
		/* 822680B4h case   20:*/		return 0x822680B8;
	}
	return 0x822680B8;
} // Block from 82268064h-822680B8h (21 instructions)

//////////////////////////////////////////////////////
// Block at 822680B8h
// Function 'MultiByteToWideChar'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822680B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822680B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822680B8);
		  /* 822680B8h */ case    0:  		/* bc 4, CR6_GT, 8 */
		/* 822680B8h case    0:*/		if ( !regs.CR[6].gt ) { return 0x822680C0;  }
		/* 822680B8h case    0:*/		return 0x822680BC;
		  /* 822680BCh */ case    1:  		/* fneg FR0, FR0 */
		/* 822680BCh case    1:*/		cpu::op::fneg<0>(regs,&regs.FR0,regs.FR0);
		/* 822680BCh case    1:*/		return 0x822680C0;
	}
	return 0x822680C0;
} // Block from 822680B8h-822680C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822680C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822680C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822680C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822680C0);
		  /* 822680C0h */ case    0:  		/* rlwinm R10, R10, 3, 0, 28 */
		/* 822680C0h case    0:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R10);
		/* 822680C0h case    0:*/		return 0x822680C4;
		  /* 822680C4h */ case    1:  		/* addi R9, R11, 128 */
		/* 822680C4h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x80);
		/* 822680C4h case    1:*/		return 0x822680C8;
		  /* 822680C8h */ case    2:  		/* lfdx FR13, <#[R10 + R9]> */
		/* 822680C8h case    2:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 822680C8h case    2:*/		return 0x822680CC;
		  /* 822680CCh */ case    3:  		/* fadd FR0, FR13, FR0 */
		/* 822680CCh case    3:*/		cpu::op::fadd<0>(regs,&regs.FR0,regs.FR13,regs.FR0);
		/* 822680CCh case    3:*/		return 0x822680D0;
	}
	return 0x822680D0;
} // Block from 822680C0h-822680D0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822680D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822680D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822680D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822680D0);
		  /* 822680D0h */ case    0:  		/* lfd FR13, <#[R11 + 16]> */
		/* 822680D0h case    0:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000010) );
		/* 822680D0h case    0:*/		return 0x822680D4;
		  /* 822680D4h */ case    1:  		/* lwz R11, <#[R1 + 16]> */
		/* 822680D4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000010) );
		/* 822680D4h case    1:*/		return 0x822680D8;
		  /* 822680D8h */ case    2:  		/* fsub FR13, FR13, FR0 */
		/* 822680D8h case    2:*/		cpu::op::fsub<0>(regs,&regs.FR13,regs.FR13,regs.FR0);
		/* 822680D8h case    2:*/		return 0x822680DC;
		  /* 822680DCh */ case    3:  		/* rlwinm. R11, R11, 0, 0, 0 */
		/* 822680DCh case    3:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R11,regs.R11);
		/* 822680DCh case    3:*/		return 0x822680E0;
		  /* 822680E0h */ case    4:  		/* fsel FR1, FR2, FR0, FR13 */
		/* 822680E0h case    4:*/		cpu::op::fsel<0>(regs,&regs.FR1,regs.FR2,regs.FR0,regs.FR13);
		/* 822680E0h case    4:*/		return 0x822680E4;
		  /* 822680E4h */ case    5:  		/* bclr 12, CR0_EQ */
		/* 822680E4h case    5:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 822680E4h case    5:*/		return 0x822680E8;
	}
	return 0x822680E8;
} // Block from 822680D0h-822680E8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822680E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822680E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822680E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822680E8);
		  /* 822680E8h */ case    0:  		/* fneg FR1, FR1 */
		/* 822680E8h case    0:*/		cpu::op::fneg<0>(regs,&regs.FR1,regs.FR1);
		/* 822680E8h case    0:*/		return 0x822680EC;
		  /* 822680ECh */ case    1:  		/* bclr 20, CR0_LT */
		/* 822680ECh case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822680ECh case    1:*/		return 0x822680F0;
	}
	return 0x822680F0;
} // Block from 822680E8h-822680F0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822680F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822680F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822680F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822680F0);
		  /* 822680F0h */ case    0:  		/* fabs FR13, FR1 */
		/* 822680F0h case    0:*/		cpu::op::fabs<0>(regs,&regs.FR13,regs.FR1);
		/* 822680F0h case    0:*/		return 0x822680F4;
		  /* 822680F4h */ case    1:  		/* lis R11, -32216 */
		/* 822680F4h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 822680F4h case    1:*/		return 0x822680F8;
		  /* 822680F8h */ case    2:  		/* addi R11, R11, 27368 */
		/* 822680F8h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6AE8);
		/* 822680F8h case    2:*/		return 0x822680FC;
		  /* 822680FCh */ case    3:  		/* lfs FR0, <#[R11 + 12]> */
		/* 822680FCh case    3:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x0000000C) );
		/* 822680FCh case    3:*/		return 0x82268100;
		  /* 82268100h */ case    4:  		/* fcmpu CR6, FR13, FR0 */
		/* 82268100h case    4:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 82268100h case    4:*/		return 0x82268104;
		  /* 82268104h */ case    5:  		/* bc 4, CR6_GT, 40 */
		/* 82268104h case    5:*/		if ( !regs.CR[6].gt ) { return 0x8226812C;  }
		/* 82268104h case    5:*/		return 0x82268108;
		  /* 82268108h */ case    6:  		/* lfs FR12, <#[R11 + 4]> */
		/* 82268108h case    6:*/		cpu::mem::load32f( regs, &regs.FR12, (uint32)(regs.R11 + 0x00000004) );
		/* 82268108h case    6:*/		return 0x8226810C;
		  /* 8226810Ch */ case    7:  		/* subfic R10, R4, 1 */
		/* 8226810Ch case    7:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R4,0x1);
		/* 8226810Ch case    7:*/		return 0x82268110;
		  /* 82268110h */ case    8:  		/* fsub FR12, FR12, FR13 */
		/* 82268110h case    8:*/		cpu::op::fsub<0>(regs,&regs.FR12,regs.FR12,regs.FR13);
		/* 82268110h case    8:*/		return 0x82268114;
		  /* 82268114h */ case    9:  		/* lfs FR13, <#[R11 + 8]> */
		/* 82268114h case    9:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000008) );
		/* 82268114h case    9:*/		return 0x82268118;
		  /* 82268118h */ case   10:  		/* fmul FR0, FR12, FR0 */
		/* 82268118h case   10:*/		cpu::op::fmul<0>(regs,&regs.FR0,regs.FR12,regs.FR0);
		/* 82268118h case   10:*/		return 0x8226811C;
		  /* 8226811Ch */ case   11:  		/* fsqrt FR12, FR0 */
		/* 8226811Ch case   11:*/		cpu::op::fsqrt<0>(regs,&regs.FR12,regs.FR0);
		/* 8226811Ch case   11:*/		return 0x82268120;
		  /* 82268120h */ case   12:  		/* fmul FR13, FR12, FR13 */
		/* 82268120h case   12:*/		cpu::op::fmul<0>(regs,&regs.FR13,regs.FR12,regs.FR13);
		/* 82268120h case   12:*/		return 0x82268124;
		  /* 82268124h */ case   13:  		/* fneg FR13, FR13 */
		/* 82268124h case   13:*/		cpu::op::fneg<0>(regs,&regs.FR13,regs.FR13);
		/* 82268124h case   13:*/		return 0x82268128;
		  /* 82268128h */ case   14:  		/* b 32 */
		/* 82268128h case   14:*/		return 0x82268148;
		/* 82268128h case   14:*/		return 0x8226812C;
	}
	return 0x8226812C;
} // Block from 822680F0h-8226812Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8226812Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226812C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226812C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226812C);
		  /* 8226812Ch */ case    0:  		/* mr R10, R4 */
		/* 8226812Ch case    0:*/		regs.R10 = regs.R4;
		/* 8226812Ch case    0:*/		return 0x82268130;
		  /* 82268130h */ case    1:  		/* fmul FR0, FR13, FR13 */
		/* 82268130h case    1:*/		cpu::op::fmul<0>(regs,&regs.FR0,regs.FR13,regs.FR13);
		/* 82268130h case    1:*/		return 0x82268134;
		  /* 82268134h */ case    2:  		/* cmpwi CR6, R4, 0 */
		/* 82268134h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000000);
		/* 82268134h case    2:*/		return 0x82268138;
		  /* 82268138h */ case    3:  		/* bc 4, CR6_EQ, 16 */
		/* 82268138h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82268148;  }
		/* 82268138h case    3:*/		return 0x8226813C;
		  /* 8226813Ch */ case    4:  		/* lfs FR12, <#[R11]> */
		/* 8226813Ch case    4:*/		cpu::mem::load32f( regs, &regs.FR12, (uint32)(regs.R11 + 0x00000000) );
		/* 8226813Ch case    4:*/		return 0x82268140;
		  /* 82268140h */ case    5:  		/* fcmpu CR6, FR1, FR12 */
		/* 82268140h case    5:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR12);
		/* 82268140h case    5:*/		return 0x82268144;
		  /* 82268144h */ case    6:  		/* bclr 12, CR6_EQ */
		/* 82268144h case    6:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 82268144h case    6:*/		return 0x82268148;
	}
	return 0x82268148;
} // Block from 8226812Ch-82268148h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82268148h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268148( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268148) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268148);
		  /* 82268148h */ case    0:  		/* lfd FR12, <#[R11 + 80]> */
		/* 82268148h case    0:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R11 + 0x00000050) );
		/* 82268148h case    0:*/		return 0x8226814C;
		  /* 8226814Ch */ case    1:  		/* cmpwi CR6, R4, 0 */
		/* 8226814Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000000);
		/* 8226814Ch case    1:*/		return 0x82268150;
		  /* 82268150h */ case    2:  		/* lfd FR11, <#[R11 + 72]> */
		/* 82268150h case    2:*/		cpu::mem::load64f( regs, &regs.FR11, (uint32)(regs.R11 + 0x00000048) );
		/* 82268150h case    2:*/		return 0x82268154;
		  /* 82268154h */ case    3:  		/* rlwinm R10, R10, 3, 0, 28 */
		/* 82268154h case    3:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R10);
		/* 82268154h case    3:*/		return 0x82268158;
		  /* 82268158h */ case    4:  		/* fmadd FR5, FR12, FR0, FR11 */
		/* 82268158h case    4:*/		cpu::op::fmadd<0>(regs,&regs.FR5,regs.FR12,regs.FR0,regs.FR11);
		/* 82268158h case    4:*/		return 0x8226815C;
		  /* 8226815Ch */ case    5:  		/* lfd FR12, <#[R11 + 120]> */
		/* 8226815Ch case    5:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R11 + 0x00000078) );
		/* 8226815Ch case    5:*/		return 0x82268160;
		  /* 82268160h */ case    6:  		/* lfd FR11, <#[R11 + 64]> */
		/* 82268160h case    6:*/		cpu::mem::load64f( regs, &regs.FR11, (uint32)(regs.R11 + 0x00000040) );
		/* 82268160h case    6:*/		return 0x82268164;
		  /* 82268164h */ case    7:  		/* fadd FR4, FR12, FR0 */
		/* 82268164h case    7:*/		cpu::op::fadd<0>(regs,&regs.FR4,regs.FR12,regs.FR0);
		/* 82268164h case    7:*/		return 0x82268168;
		  /* 82268168h */ case    8:  		/* lfd FR12, <#[R11 + 112]> */
		/* 82268168h case    8:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R11 + 0x00000070) );
		/* 82268168h case    8:*/		return 0x8226816C;
		  /* 8226816Ch */ case    9:  		/* lfd FR10, <#[R11 + 56]> */
		/* 8226816Ch case    9:*/		cpu::mem::load64f( regs, &regs.FR10, (uint32)(regs.R11 + 0x00000038) );
		/* 8226816Ch case    9:*/		return 0x82268170;
		  /* 82268170h */ case   10:  		/* lfd FR9, <#[R11 + 104]> */
		/* 82268170h case   10:*/		cpu::mem::load64f( regs, &regs.FR9, (uint32)(regs.R11 + 0x00000068) );
		/* 82268170h case   10:*/		return 0x82268174;
		  /* 82268174h */ case   11:  		/* lfd FR8, <#[R11 + 48]> */
		/* 82268174h case   11:*/		cpu::mem::load64f( regs, &regs.FR8, (uint32)(regs.R11 + 0x00000030) );
		/* 82268174h case   11:*/		return 0x82268178;
		  /* 82268178h */ case   12:  		/* lfd FR7, <#[R11 + 96]> */
		/* 82268178h case   12:*/		cpu::mem::load64f( regs, &regs.FR7, (uint32)(regs.R11 + 0x00000060) );
		/* 82268178h case   12:*/		return 0x8226817C;
		  /* 8226817Ch */ case   13:  		/* lfd FR6, <#[R11 + 88]> */
		/* 8226817Ch case   13:*/		cpu::mem::load64f( regs, &regs.FR6, (uint32)(regs.R11 + 0x00000058) );
		/* 8226817Ch case   13:*/		return 0x82268180;
		  /* 82268180h */ case   14:  		/* fmadd FR11, FR5, FR0, FR11 */
		/* 82268180h case   14:*/		cpu::op::fmadd<0>(regs,&regs.FR11,regs.FR5,regs.FR0,regs.FR11);
		/* 82268180h case   14:*/		return 0x82268184;
		  /* 82268184h */ case   15:  		/* fmadd FR12, FR4, FR0, FR12 */
		/* 82268184h case   15:*/		cpu::op::fmadd<0>(regs,&regs.FR12,regs.FR4,regs.FR0,regs.FR12);
		/* 82268184h case   15:*/		return 0x82268188;
		  /* 82268188h */ case   16:  		/* fmadd FR11, FR11, FR0, FR10 */
		/* 82268188h case   16:*/		cpu::op::fmadd<0>(regs,&regs.FR11,regs.FR11,regs.FR0,regs.FR10);
		/* 82268188h case   16:*/		return 0x8226818C;
		  /* 8226818Ch */ case   17:  		/* fmadd FR12, FR12, FR0, FR9 */
		/* 8226818Ch case   17:*/		cpu::op::fmadd<0>(regs,&regs.FR12,regs.FR12,regs.FR0,regs.FR9);
		/* 8226818Ch case   17:*/		return 0x82268190;
	}
	return 0x82268190;
} // Block from 82268148h-82268190h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82268190h
// Function 'GetFileTime'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268190( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268190) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268190);
		  /* 82268190h */ case    0:  		/* fmadd FR11, FR11, FR0, FR8 */
		/* 82268190h case    0:*/		cpu::op::fmadd<0>(regs,&regs.FR11,regs.FR11,regs.FR0,regs.FR8);
		/* 82268190h case    0:*/		return 0x82268194;
		  /* 82268194h */ case    1:  		/* fmadd FR12, FR12, FR0, FR7 */
		/* 82268194h case    1:*/		cpu::op::fmadd<0>(regs,&regs.FR12,regs.FR12,regs.FR0,regs.FR7);
		/* 82268194h case    1:*/		return 0x82268198;
		  /* 82268198h */ case    2:  		/* fmul FR11, FR11, FR0 */
		/* 82268198h case    2:*/		cpu::op::fmul<0>(regs,&regs.FR11,regs.FR11,regs.FR0);
		/* 82268198h case    2:*/		return 0x8226819C;
		  /* 8226819Ch */ case    3:  		/* fmadd FR0, FR12, FR0, FR6 */
		/* 8226819Ch case    3:*/		cpu::op::fmadd<0>(regs,&regs.FR0,regs.FR12,regs.FR0,regs.FR6);
		/* 8226819Ch case    3:*/		return 0x822681A0;
		  /* 822681A0h */ case    4:  		/* fmul FR12, FR11, FR13 */
		/* 822681A0h case    4:*/		cpu::op::fmul<0>(regs,&regs.FR12,regs.FR11,regs.FR13);
		/* 822681A0h case    4:*/		return 0x822681A4;
		  /* 822681A4h */ case    5:  		/* fdiv FR0, FR12, FR0 */
		/* 822681A4h case    5:*/		cpu::op::fdiv<0>(regs,&regs.FR0,regs.FR12,regs.FR0);
		/* 822681A4h case    5:*/		return 0x822681A8;
		  /* 822681A8h */ case    6:  		/* fadd FR0, FR0, FR13 */
		/* 822681A8h case    6:*/		cpu::op::fadd<0>(regs,&regs.FR0,regs.FR0,regs.FR13);
		/* 822681A8h case    6:*/		return 0x822681AC;
		  /* 822681ACh */ case    7:  		/* bc 4, CR6_EQ, 28 */
		/* 822681ACh case    7:*/		if ( !regs.CR[6].eq ) { return 0x822681C8;  }
		/* 822681ACh case    7:*/		return 0x822681B0;
		  /* 822681B0h */ case    8:  		/* addi R11, R11, 16 */
		/* 822681B0h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x10);
		/* 822681B0h case    8:*/		return 0x822681B4;
		  /* 822681B4h */ case    9:  		/* lfdx FR13, <#[R10 + R11]> */
		/* 822681B4h case    9:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 822681B4h case    9:*/		return 0x822681B8;
		  /* 822681B8h */ case   10:  		/* fadd FR0, FR13, FR0 */
		/* 822681B8h case   10:*/		cpu::op::fadd<0>(regs,&regs.FR0,regs.FR13,regs.FR0);
		/* 822681B8h case   10:*/		return 0x822681BC;
		  /* 822681BCh */ case   11:  		/* fneg FR13, FR0 */
		/* 822681BCh case   11:*/		cpu::op::fneg<0>(regs,&regs.FR13,regs.FR0);
		/* 822681BCh case   11:*/		return 0x822681C0;
		  /* 822681C0h */ case   12:  		/* fsel FR1, FR1, FR0, FR13 */
		/* 822681C0h case   12:*/		cpu::op::fsel<0>(regs,&regs.FR1,regs.FR1,regs.FR0,regs.FR13);
		/* 822681C0h case   12:*/		return 0x822681C4;
		  /* 822681C4h */ case   13:  		/* bclr 20, CR0_LT */
		/* 822681C4h case   13:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822681C4h case   13:*/		return 0x822681C8;
	}
	return 0x822681C8;
} // Block from 82268190h-822681C8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 822681C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822681C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822681C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822681C8);
		  /* 822681C8h */ case    0:  		/* addi R9, R11, 16 */
		/* 822681C8h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x10);
		/* 822681C8h case    0:*/		return 0x822681CC;
		  /* 822681CCh */ case    1:  		/* addi R11, R11, 32 */
		/* 822681CCh case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x20);
		/* 822681CCh case    1:*/		return 0x822681D0;
		  /* 822681D0h */ case    2:  		/* lfdx FR13, <#[R10 + R9]> */
		/* 822681D0h case    2:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 822681D0h case    2:*/		return 0x822681D4;
		  /* 822681D4h */ case    3:  		/* lfdx FR12, <#[R10 + R11]> */
		/* 822681D4h case    3:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 822681D4h case    3:*/		return 0x822681D8;
		  /* 822681D8h */ case    4:  		/* fsub FR13, FR13, FR0 */
		/* 822681D8h case    4:*/		cpu::op::fsub<0>(regs,&regs.FR13,regs.FR13,regs.FR0);
		/* 822681D8h case    4:*/		return 0x822681DC;
		  /* 822681DCh */ case    5:  		/* fadd FR0, FR12, FR0 */
		/* 822681DCh case    5:*/		cpu::op::fadd<0>(regs,&regs.FR0,regs.FR12,regs.FR0);
		/* 822681DCh case    5:*/		return 0x822681E0;
		  /* 822681E0h */ case    6:  		/* fsel FR1, FR1, FR13, FR0 */
		/* 822681E0h case    6:*/		cpu::op::fsel<0>(regs,&regs.FR1,regs.FR1,regs.FR13,regs.FR0);
		/* 822681E0h case    6:*/		return 0x822681E4;
		  /* 822681E4h */ case    7:  		/* bclr 20, CR0_LT */
		/* 822681E4h case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822681E4h case    7:*/		return 0x822681E8;
	}
	return 0x822681E8;
} // Block from 822681C8h-822681E8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 822681E8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822681E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822681E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822681E8);
		  /* 822681E8h */ case    0:  		/* fabs FR13, FR1 */
		/* 822681E8h case    0:*/		cpu::op::fabs<0>(regs,&regs.FR13,regs.FR1);
		/* 822681E8h case    0:*/		return 0x822681EC;
		  /* 822681ECh */ case    1:  		/* lis R11, -32216 */
		/* 822681ECh case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 822681ECh case    1:*/		return 0x822681F0;
		  /* 822681F0h */ case    2:  		/* addi R11, R11, 27368 */
		/* 822681F0h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6AE8);
		/* 822681F0h case    2:*/		return 0x822681F4;
		  /* 822681F4h */ case    3:  		/* lfs FR0, <#[R11 + 12]> */
		/* 822681F4h case    3:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x0000000C) );
		/* 822681F4h case    3:*/		return 0x822681F8;
		  /* 822681F8h */ case    4:  		/* fcmpu CR6, FR13, FR0 */
		/* 822681F8h case    4:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 822681F8h case    4:*/		return 0x822681FC;
		  /* 822681FCh */ case    5:  		/* bc 4, CR6_GT, 40 */
		/* 822681FCh case    5:*/		if ( !regs.CR[6].gt ) { return 0x82268224;  }
		/* 822681FCh case    5:*/		return 0x82268200;
		  /* 82268200h */ case    6:  		/* lfs FR12, <#[R11 + 4]> */
		/* 82268200h case    6:*/		cpu::mem::load32f( regs, &regs.FR12, (uint32)(regs.R11 + 0x00000004) );
		/* 82268200h case    6:*/		return 0x82268204;
		  /* 82268204h */ case    7:  		/* li R10, 1 */
		/* 82268204h case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 82268204h case    7:*/		return 0x82268208;
		  /* 82268208h */ case    8:  		/* fsub FR12, FR12, FR13 */
		/* 82268208h case    8:*/		cpu::op::fsub<0>(regs,&regs.FR12,regs.FR12,regs.FR13);
		/* 82268208h case    8:*/		return 0x8226820C;
		  /* 8226820Ch */ case    9:  		/* lfs FR13, <#[R11 + 8]> */
		/* 8226820Ch case    9:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000008) );
		/* 8226820Ch case    9:*/		return 0x82268210;
		  /* 82268210h */ case   10:  		/* fmul FR0, FR12, FR0 */
		/* 82268210h case   10:*/		cpu::op::fmul<0>(regs,&regs.FR0,regs.FR12,regs.FR0);
		/* 82268210h case   10:*/		return 0x82268214;
		  /* 82268214h */ case   11:  		/* fsqrt FR12, FR0 */
		/* 82268214h case   11:*/		cpu::op::fsqrt<0>(regs,&regs.FR12,regs.FR0);
		/* 82268214h case   11:*/		return 0x82268218;
		  /* 82268218h */ case   12:  		/* fmul FR13, FR12, FR13 */
		/* 82268218h case   12:*/		cpu::op::fmul<0>(regs,&regs.FR13,regs.FR12,regs.FR13);
		/* 82268218h case   12:*/		return 0x8226821C;
		  /* 8226821Ch */ case   13:  		/* fneg FR13, FR13 */
		/* 8226821Ch case   13:*/		cpu::op::fneg<0>(regs,&regs.FR13,regs.FR13);
		/* 8226821Ch case   13:*/		return 0x82268220;
	}
	return 0x82268220;
} // Block from 822681E8h-82268220h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82268220h
// Function 'GetFileSizeEx'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268220( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268220) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268220);
		  /* 82268220h */ case    0:  		/* b 24 */
		/* 82268220h case    0:*/		return 0x82268238;
		/* 82268220h case    0:*/		return 0x82268224;
	}
	return 0x82268224;
} // Block from 82268220h-82268224h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82268224h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268224( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268224) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268224);
		  /* 82268224h */ case    0:  		/* lfs FR12, <#[R11]> */
		/* 82268224h case    0:*/		cpu::mem::load32f( regs, &regs.FR12, (uint32)(regs.R11 + 0x00000000) );
		/* 82268224h case    0:*/		return 0x82268228;
		  /* 82268228h */ case    1:  		/* li R10, 0 */
		/* 82268228h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82268228h case    1:*/		return 0x8226822C;
		  /* 8226822Ch */ case    2:  		/* fmul FR0, FR13, FR13 */
		/* 8226822Ch case    2:*/		cpu::op::fmul<0>(regs,&regs.FR0,regs.FR13,regs.FR13);
		/* 8226822Ch case    2:*/		return 0x82268230;
		  /* 82268230h */ case    3:  		/* fcmpu CR6, FR1, FR12 */
		/* 82268230h case    3:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR12);
		/* 82268230h case    3:*/		return 0x82268234;
		  /* 82268234h */ case    4:  		/* bclr 12, CR6_EQ */
		/* 82268234h case    4:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 82268234h case    4:*/		return 0x82268238;
	}
	return 0x82268238;
} // Block from 82268224h-82268238h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82268238h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268238( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268238) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268238);
		  /* 82268238h */ case    0:  		/* lfd FR12, <#[R11 + 80]> */
		/* 82268238h case    0:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R11 + 0x00000050) );
		/* 82268238h case    0:*/		return 0x8226823C;
		  /* 8226823Ch */ case    1:  		/* rlwinm R10, R10, 3, 0, 28 */
		/* 8226823Ch case    1:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R10);
		/* 8226823Ch case    1:*/		return 0x82268240;
		  /* 82268240h */ case    2:  		/* lfd FR11, <#[R11 + 72]> */
		/* 82268240h case    2:*/		cpu::mem::load64f( regs, &regs.FR11, (uint32)(regs.R11 + 0x00000048) );
		/* 82268240h case    2:*/		return 0x82268244;
		  /* 82268244h */ case    3:  		/* addi R9, R11, 16 */
		/* 82268244h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x10);
		/* 82268244h case    3:*/		return 0x82268248;
		  /* 82268248h */ case    4:  		/* fmadd FR5, FR12, FR0, FR11 */
		/* 82268248h case    4:*/		cpu::op::fmadd<0>(regs,&regs.FR5,regs.FR12,regs.FR0,regs.FR11);
		/* 82268248h case    4:*/		return 0x8226824C;
		  /* 8226824Ch */ case    5:  		/* lfd FR12, <#[R11 + 120]> */
		/* 8226824Ch case    5:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R11 + 0x00000078) );
		/* 8226824Ch case    5:*/		return 0x82268250;
		  /* 82268250h */ case    6:  		/* lfd FR11, <#[R11 + 64]> */
		/* 82268250h case    6:*/		cpu::mem::load64f( regs, &regs.FR11, (uint32)(regs.R11 + 0x00000040) );
		/* 82268250h case    6:*/		return 0x82268254;
		  /* 82268254h */ case    7:  		/* fadd FR4, FR12, FR0 */
		/* 82268254h case    7:*/		cpu::op::fadd<0>(regs,&regs.FR4,regs.FR12,regs.FR0);
		/* 82268254h case    7:*/		return 0x82268258;
		  /* 82268258h */ case    8:  		/* lfd FR12, <#[R11 + 112]> */
		/* 82268258h case    8:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R11 + 0x00000070) );
		/* 82268258h case    8:*/		return 0x8226825C;
		  /* 8226825Ch */ case    9:  		/* lfd FR10, <#[R11 + 56]> */
		/* 8226825Ch case    9:*/		cpu::mem::load64f( regs, &regs.FR10, (uint32)(regs.R11 + 0x00000038) );
		/* 8226825Ch case    9:*/		return 0x82268260;
		  /* 82268260h */ case   10:  		/* lfd FR9, <#[R11 + 104]> */
		/* 82268260h case   10:*/		cpu::mem::load64f( regs, &regs.FR9, (uint32)(regs.R11 + 0x00000068) );
		/* 82268260h case   10:*/		return 0x82268264;
		  /* 82268264h */ case   11:  		/* lfd FR8, <#[R11 + 48]> */
		/* 82268264h case   11:*/		cpu::mem::load64f( regs, &regs.FR8, (uint32)(regs.R11 + 0x00000030) );
		/* 82268264h case   11:*/		return 0x82268268;
		  /* 82268268h */ case   12:  		/* lfd FR7, <#[R11 + 96]> */
		/* 82268268h case   12:*/		cpu::mem::load64f( regs, &regs.FR7, (uint32)(regs.R11 + 0x00000060) );
		/* 82268268h case   12:*/		return 0x8226826C;
		  /* 8226826Ch */ case   13:  		/* lfd FR6, <#[R11 + 88]> */
		/* 8226826Ch case   13:*/		cpu::mem::load64f( regs, &regs.FR6, (uint32)(regs.R11 + 0x00000058) );
		/* 8226826Ch case   13:*/		return 0x82268270;
		  /* 82268270h */ case   14:  		/* lfdx FR3, <#[R10 + R9]> */
		/* 82268270h case   14:*/		cpu::mem::load64f( regs, &regs.FR3, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82268270h case   14:*/		return 0x82268274;
		  /* 82268274h */ case   15:  		/* fmadd FR11, FR5, FR0, FR11 */
		/* 82268274h case   15:*/		cpu::op::fmadd<0>(regs,&regs.FR11,regs.FR5,regs.FR0,regs.FR11);
		/* 82268274h case   15:*/		return 0x82268278;
		  /* 82268278h */ case   16:  		/* fmadd FR12, FR4, FR0, FR12 */
		/* 82268278h case   16:*/		cpu::op::fmadd<0>(regs,&regs.FR12,regs.FR4,regs.FR0,regs.FR12);
		/* 82268278h case   16:*/		return 0x8226827C;
		  /* 8226827Ch */ case   17:  		/* fmadd FR11, FR11, FR0, FR10 */
		/* 8226827Ch case   17:*/		cpu::op::fmadd<0>(regs,&regs.FR11,regs.FR11,regs.FR0,regs.FR10);
		/* 8226827Ch case   17:*/		return 0x82268280;
		  /* 82268280h */ case   18:  		/* fmadd FR12, FR12, FR0, FR9 */
		/* 82268280h case   18:*/		cpu::op::fmadd<0>(regs,&regs.FR12,regs.FR12,regs.FR0,regs.FR9);
		/* 82268280h case   18:*/		return 0x82268284;
		  /* 82268284h */ case   19:  		/* fmadd FR11, FR11, FR0, FR8 */
		/* 82268284h case   19:*/		cpu::op::fmadd<0>(regs,&regs.FR11,regs.FR11,regs.FR0,regs.FR8);
		/* 82268284h case   19:*/		return 0x82268288;
		  /* 82268288h */ case   20:  		/* fmadd FR12, FR12, FR0, FR7 */
		/* 82268288h case   20:*/		cpu::op::fmadd<0>(regs,&regs.FR12,regs.FR12,regs.FR0,regs.FR7);
		/* 82268288h case   20:*/		return 0x8226828C;
		  /* 8226828Ch */ case   21:  		/* fmul FR11, FR11, FR0 */
		/* 8226828Ch case   21:*/		cpu::op::fmul<0>(regs,&regs.FR11,regs.FR11,regs.FR0);
		/* 8226828Ch case   21:*/		return 0x82268290;
	}
	return 0x82268290;
} // Block from 82268238h-82268290h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82268290h
// Function 'UnicodeToUTF8'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268290( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268290) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268290);
		  /* 82268290h */ case    0:  		/* fmadd FR0, FR12, FR0, FR6 */
		/* 82268290h case    0:*/		cpu::op::fmadd<0>(regs,&regs.FR0,regs.FR12,regs.FR0,regs.FR6);
		/* 82268290h case    0:*/		return 0x82268294;
		  /* 82268294h */ case    1:  		/* fmul FR12, FR11, FR13 */
		/* 82268294h case    1:*/		cpu::op::fmul<0>(regs,&regs.FR12,regs.FR11,regs.FR13);
		/* 82268294h case    1:*/		return 0x82268298;
		  /* 82268298h */ case    2:  		/* fdiv FR0, FR12, FR0 */
		/* 82268298h case    2:*/		cpu::op::fdiv<0>(regs,&regs.FR0,regs.FR12,regs.FR0);
		/* 82268298h case    2:*/		return 0x8226829C;
		  /* 8226829Ch */ case    3:  		/* fadd FR0, FR0, FR13 */
		/* 8226829Ch case    3:*/		cpu::op::fadd<0>(regs,&regs.FR0,regs.FR0,regs.FR13);
		/* 8226829Ch case    3:*/		return 0x822682A0;
		  /* 822682A0h */ case    4:  		/* fadd FR0, FR0, FR3 */
		/* 822682A0h case    4:*/		cpu::op::fadd<0>(regs,&regs.FR0,regs.FR0,regs.FR3);
		/* 822682A0h case    4:*/		return 0x822682A4;
		  /* 822682A4h */ case    5:  		/* fneg FR13, FR0 */
		/* 822682A4h case    5:*/		cpu::op::fneg<0>(regs,&regs.FR13,regs.FR0);
		/* 822682A4h case    5:*/		return 0x822682A8;
		  /* 822682A8h */ case    6:  		/* fsel FR1, FR1, FR0, FR13 */
		/* 822682A8h case    6:*/		cpu::op::fsel<0>(regs,&regs.FR1,regs.FR1,regs.FR0,regs.FR13);
		/* 822682A8h case    6:*/		return 0x822682AC;
		  /* 822682ACh */ case    7:  		/* bclr 20, CR0_LT */
		/* 822682ACh case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822682ACh case    7:*/		return 0x822682B0;
	}
	return 0x822682B0;
} // Block from 82268290h-822682B0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 822682B0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822682B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822682B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822682B0);
		  /* 822682B0h */ case    0:  		/* li R4, 1 */
		/* 822682B0h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 822682B0h case    0:*/		return 0x822682B4;
		  /* 822682B4h */ case    1:  		/* b -452 */
		/* 822682B4h case    1:*/		return 0x822680F0;
		/* 822682B4h case    1:*/		return 0x822682B8;
		  /* 822682B8h */ case    2:  		/* mr R11, R4 */
		/* 822682B8h case    2:*/		regs.R11 = regs.R4;
		/* 822682B8h case    2:*/		return 0x822682BC;
		  /* 822682BCh */ case    3:  		/* cmpwi CR6, R6, 0 */
		/* 822682BCh case    3:*/		cpu::op::cmpwi<6>(regs,regs.R6,0x00000000);
		/* 822682BCh case    3:*/		return 0x822682C0;
		  /* 822682C0h */ case    4:  		/* bc 12, CR6_EQ, 20 */
		/* 822682C0h case    4:*/		if ( regs.CR[6].eq ) { return 0x822682D4;  }
		/* 822682C0h case    4:*/		return 0x822682C4;
		  /* 822682C4h */ case    5:  		/* li R10, 45 */
		/* 822682C4h case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x2D);
		/* 822682C4h case    5:*/		return 0x822682C8;
		  /* 822682C8h */ case    6:  		/* addi R11, R4, 1 */
		/* 822682C8h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x1);
		/* 822682C8h case    6:*/		return 0x822682CC;
		  /* 822682CCh */ case    7:  		/* stb R10, <#[R4]> */
		/* 822682CCh case    7:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 822682CCh case    7:*/		return 0x822682D0;
		  /* 822682D0h */ case    8:  		/* neg R3, R3 */
		/* 822682D0h case    8:*/		cpu::op::neg<0>(regs,&regs.R3,regs.R3);
		/* 822682D0h case    8:*/		return 0x822682D4;
	}
	return 0x822682D4;
} // Block from 822682B0h-822682D4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 822682D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822682D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822682D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822682D4);
		  /* 822682D4h */ case    0:  		/* mr R9, R11 */
		/* 822682D4h case    0:*/		regs.R9 = regs.R11;
		/* 822682D4h case    0:*/		return 0x822682D8;
		  /* 822682D8h */ case    1:  		/* divwu R10, R3, R5 */
		/* 822682D8h case    1:*/		cpu::op::divwu<0>(regs,&regs.R10,regs.R3,regs.R5);
		/* 822682D8h case    1:*/		return 0x822682DC;
		  /* 822682DCh */ case    2:  		/* twi 6, R5, 0 */
		/* 822682DCh case    2:*/		cpu::op::tw<6>(regs, 0x822682DC, regs.R5, 0x00000000);
		/* 822682DCh case    2:*/		return 0x822682E0;
		  /* 822682E0h */ case    3:  		/* mullw R10, R10, R5 */
		/* 822682E0h case    3:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R10,regs.R5);
		/* 822682E0h case    3:*/		return 0x822682E4;
		  /* 822682E4h */ case    4:  		/* subf R10, R10, R3 */
		/* 822682E4h case    4:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R10,regs.R3);
		/* 822682E4h case    4:*/		return 0x822682E8;
		  /* 822682E8h */ case    5:  		/* divwu R3, R3, R5 */
		/* 822682E8h case    5:*/		cpu::op::divwu<0>(regs,&regs.R3,regs.R3,regs.R5);
		/* 822682E8h case    5:*/		return 0x822682EC;
		  /* 822682ECh */ case    6:  		/* twi 6, R5, 0 */
		/* 822682ECh case    6:*/		cpu::op::tw<6>(regs, 0x822682EC, regs.R5, 0x00000000);
		/* 822682ECh case    6:*/		return 0x822682F0;
		  /* 822682F0h */ case    7:  		/* cmplwi CR6, R10, 9 */
		/* 822682F0h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000009);
		/* 822682F0h case    7:*/		return 0x822682F4;
		  /* 822682F4h */ case    8:  		/* bc 4, CR6_GT, 16 */
		/* 822682F4h case    8:*/		if ( !regs.CR[6].gt ) { return 0x82268304;  }
		/* 822682F4h case    8:*/		return 0x822682F8;
		  /* 822682F8h */ case    9:  		/* addi R10, R10, 87 */
		/* 822682F8h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x57);
		/* 822682F8h case    9:*/		return 0x822682FC;
		  /* 822682FCh */ case   10:  		/* extsb R10, R10 */
		/* 822682FCh case   10:*/		cpu::op::extsb<0>(regs,&regs.R10,regs.R10);
		/* 822682FCh case   10:*/		return 0x82268300;
		  /* 82268300h */ case   11:  		/* b 8 */
		/* 82268300h case   11:*/		return 0x82268308;
		/* 82268300h case   11:*/		return 0x82268304;
	}
	return 0x82268304;
} // Block from 822682D4h-82268304h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82268304h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268304( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268304) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268304);
		  /* 82268304h */ case    0:  		/* addi R10, R10, 48 */
		/* 82268304h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x30);
		/* 82268304h case    0:*/		return 0x82268308;
	}
	return 0x82268308;
} // Block from 82268304h-82268308h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82268308h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268308( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268308) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268308);
		  /* 82268308h */ case    0:  		/* stb R10, <#[R11]> */
		/* 82268308h case    0:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 82268308h case    0:*/		return 0x8226830C;
		  /* 8226830Ch */ case    1:  		/* addi R11, R11, 1 */
		/* 8226830Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8226830Ch case    1:*/		return 0x82268310;
		  /* 82268310h */ case    2:  		/* cmplwi CR6, R3, 0 */
		/* 82268310h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82268310h case    2:*/		return 0x82268314;
		  /* 82268314h */ case    3:  		/* bc 4, CR6_EQ, -60 */
		/* 82268314h case    3:*/		if ( !regs.CR[6].eq ) { return 0x822682D8;  }
		/* 82268314h case    3:*/		return 0x82268318;
		  /* 82268318h */ case    4:  		/* li R10, 0 */
		/* 82268318h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82268318h case    4:*/		return 0x8226831C;
		  /* 8226831Ch */ case    5:  		/* stb R10, <#[R11]> */
		/* 8226831Ch case    5:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8226831Ch case    5:*/		return 0x82268320;
		  /* 82268320h */ case    6:  		/* addi R11, R11, -1 */
		/* 82268320h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82268320h case    6:*/		return 0x82268324;
		  /* 82268324h */ case    7:  		/* lbz R10, <#[R9]> */
		/* 82268324h case    7:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 82268324h case    7:*/		return 0x82268328;
		  /* 82268328h */ case    8:  		/* lbz R8, <#[R11]> */
		/* 82268328h case    8:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 82268328h case    8:*/		return 0x8226832C;
		  /* 8226832Ch */ case    9:  		/* stb R10, <#[R11]> */
		/* 8226832Ch case    9:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8226832Ch case    9:*/		return 0x82268330;
		  /* 82268330h */ case   10:  		/* addi R11, R11, -1 */
		/* 82268330h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82268330h case   10:*/		return 0x82268334;
		  /* 82268334h */ case   11:  		/* stb R8, <#[R9]> */
		/* 82268334h case   11:*/		cpu::mem::store8( regs, regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 82268334h case   11:*/		return 0x82268338;
		  /* 82268338h */ case   12:  		/* addi R9, R9, 1 */
		/* 82268338h case   12:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82268338h case   12:*/		return 0x8226833C;
		  /* 8226833Ch */ case   13:  		/* cmplw CR6, R9, R11 */
		/* 8226833Ch case   13:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 8226833Ch case   13:*/		return 0x82268340;
		  /* 82268340h */ case   14:  		/* bc 12, CR6_LT, -28 */
		/* 82268340h case   14:*/		if ( regs.CR[6].lt ) { return 0x82268324;  }
		/* 82268340h case   14:*/		return 0x82268344;
		  /* 82268344h */ case   15:  		/* bclr 20, CR0_LT */
		/* 82268344h case   15:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82268344h case   15:*/		return 0x82268348;
	}
	return 0x82268348;
} // Block from 82268308h-82268348h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82268348h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268348( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268348) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268348);
		  /* 82268348h */ case    0:  		/* mfspr R12, LR */
		/* 82268348h case    0:*/		regs.R12 = regs.LR;
		/* 82268348h case    0:*/		return 0x8226834C;
		  /* 8226834Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8226834Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8226834Ch case    1:*/		return 0x82268350;
		  /* 82268350h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 82268350h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82268350h case    2:*/		return 0x82268354;
		  /* 82268354h */ case    3:  		/* li R6, 0 */
		/* 82268354h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 82268354h case    3:*/		return 0x82268358;
		  /* 82268358h */ case    4:  		/* mr R7, R4 */
		/* 82268358h case    4:*/		regs.R7 = regs.R4;
		/* 82268358h case    4:*/		return 0x8226835C;
		  /* 8226835Ch */ case    5:  		/* bl -164 */
		/* 8226835Ch case    5:*/		regs.LR = 0x82268360; return 0x822682B8;
		/* 8226835Ch case    5:*/		return 0x82268360;
		  /* 82268360h */ case    6:  		/* mr R3, R4 */
		/* 82268360h case    6:*/		regs.R3 = regs.R4;
		/* 82268360h case    6:*/		return 0x82268364;
		  /* 82268364h */ case    7:  		/* addi R1, R1, 96 */
		/* 82268364h case    7:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82268364h case    7:*/		return 0x82268368;
		  /* 82268368h */ case    8:  		/* lwz R12, <#[R1 - 8]> */
		/* 82268368h case    8:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82268368h case    8:*/		return 0x8226836C;
		  /* 8226836Ch */ case    9:  		/* mtspr LR, R12 */
		/* 8226836Ch case    9:*/		regs.LR = regs.R12;
		/* 8226836Ch case    9:*/		return 0x82268370;
		  /* 82268370h */ case   10:  		/* bclr 20, CR0_LT */
		/* 82268370h case   10:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82268370h case   10:*/		return 0x82268374;
	}
	return 0x82268374;
} // Block from 82268348h-82268374h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82268374h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268374( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268374) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268374);
		  /* 82268374h */ case    0:  		/* nop */
		/* 82268374h case    0:*/		cpu::op::nop();
		/* 82268374h case    0:*/		return 0x82268378;
	}
	return 0x82268378;
} // Block from 82268374h-82268378h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82268378h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268378( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268378) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268378);
		  /* 82268378h */ case    0:  		/* mfspr R12, LR */
		/* 82268378h case    0:*/		regs.R12 = regs.LR;
		/* 82268378h case    0:*/		return 0x8226837C;
		  /* 8226837Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8226837Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8226837Ch case    1:*/		return 0x82268380;
		  /* 82268380h */ case    2:  		/* stfd FR30, <#[R1 - 24]> */
		/* 82268380h case    2:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82268380h case    2:*/		return 0x82268384;
		  /* 82268384h */ case    3:  		/* stfd FR31, <#[R1 - 16]> */
		/* 82268384h case    3:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82268384h case    3:*/		return 0x82268388;
		  /* 82268388h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 82268388h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82268388h case    4:*/		return 0x8226838C;
		  /* 8226838Ch */ case    5:  		/* lis R11, -32256 */
		/* 8226838Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8226838Ch case    5:*/		return 0x82268390;
		  /* 82268390h */ case    6:  		/* fmr FR30, FR1 */
		/* 82268390h case    6:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR1);
		/* 82268390h case    6:*/		return 0x82268394;
		  /* 82268394h */ case    7:  		/* fabs FR0, FR1 */
		/* 82268394h case    7:*/		cpu::op::fabs<0>(regs,&regs.FR0,regs.FR1);
		/* 82268394h case    7:*/		return 0x82268398;
		  /* 82268398h */ case    8:  		/* lfd FR13, <#[R11 + 1808]> */
		/* 82268398h case    8:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000710) );
		/* 82268398h case    8:*/		return 0x8226839C;
		  /* 8226839Ch */ case    9:  		/* fcmpu CR6, FR1, FR13 */
		/* 8226839Ch case    9:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR13);
		/* 8226839Ch case    9:*/		return 0x822683A0;
		  /* 822683A0h */ case   10:  		/* bc 4, CR6_EQ, 8 */
		/* 822683A0h case   10:*/		if ( !regs.CR[6].eq ) { return 0x822683A8;  }
		/* 822683A0h case   10:*/		return 0x822683A4;
		  /* 822683A4h */ case   11:  		/* b 188 */
		/* 822683A4h case   11:*/		return 0x82268460;
		/* 822683A4h case   11:*/		return 0x822683A8;
	}
	return 0x822683A8;
} // Block from 82268378h-822683A8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 822683A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822683A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822683A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822683A8);
		  /* 822683A8h */ case    0:  		/* lis R11, -32251 */
		/* 822683A8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 822683A8h case    0:*/		return 0x822683AC;
		  /* 822683ACh */ case    1:  		/* addi R11, R11, -17192 */
		/* 822683ACh case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFBCD8);
		/* 822683ACh case    1:*/		return 0x822683B0;
		  /* 822683B0h */ case    2:  		/* lfd FR13, <#[R11 - 32]> */
		/* 822683B0h case    2:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0xFFFFFFE0) );
		/* 822683B0h case    2:*/		return 0x822683B4;
		  /* 822683B4h */ case    3:  		/* fcmpu CR6, FR0, FR13 */
		/* 822683B4h case    3:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 822683B4h case    3:*/		return 0x822683B8;
		  /* 822683B8h */ case    4:  		/* bc 4, CR6_GT, 80 */
		/* 822683B8h case    4:*/		if ( !regs.CR[6].gt ) { return 0x82268408;  }
		/* 822683B8h case    4:*/		return 0x822683BC;
		  /* 822683BCh */ case    5:  		/* lfd FR13, <#[R11 - 40]> */
		/* 822683BCh case    5:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0xFFFFFFD8) );
		/* 822683BCh case    5:*/		return 0x822683C0;
		  /* 822683C0h */ case    6:  		/* fcmpu CR6, FR0, FR13 */
		/* 822683C0h case    6:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 822683C0h case    6:*/		return 0x822683C4;
		  /* 822683C4h */ case    7:  		/* bc 4, CR6_GT, 16 */
		/* 822683C4h case    7:*/		if ( !regs.CR[6].gt ) { return 0x822683D4;  }
		/* 822683C4h case    7:*/		return 0x822683C8;
	}
	return 0x822683C8;
} // Block from 822683A8h-822683C8h (8 instructions)

//////////////////////////////////////////////////////
// Block at 822683C8h
// Function 'xCompareStringA'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822683C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822683C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822683C8);
		  /* 822683C8h */ case    0:  		/* lis R11, -32256 */
		/* 822683C8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 822683C8h case    0:*/		return 0x822683CC;
		  /* 822683CCh */ case    1:  		/* lfd FR0, <#[R11 + 1848]> */
		/* 822683CCh case    1:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000738) );
		/* 822683CCh case    1:*/		return 0x822683D0;
		  /* 822683D0h */ case    2:  		/* b 136 */
		/* 822683D0h case    2:*/		return 0x82268458;
		/* 822683D0h case    2:*/		return 0x822683D4;
	}
	return 0x822683D4;
} // Block from 822683C8h-822683D4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822683D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822683D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822683D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822683D4);
		  /* 822683D4h */ case    0:  		/* lis R11, -32255 */
		/* 822683D4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 822683D4h case    0:*/		return 0x822683D8;
		  /* 822683D8h */ case    1:  		/* lfd FR31, <#[R11 - 24504]> */
		/* 822683D8h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0xFFFFA048) );
		/* 822683D8h case    1:*/		return 0x822683DC;
		  /* 822683DCh */ case    2:  		/* fmul FR1, FR0, FR31 */
		/* 822683DCh case    2:*/		cpu::op::fmul<0>(regs,&regs.FR1,regs.FR0,regs.FR31);
		/* 822683DCh case    2:*/		return 0x822683E0;
		  /* 822683E0h */ case    3:  		/* bl 1832 */
		/* 822683E0h case    3:*/		regs.LR = 0x822683E4; return 0x82268B08;
		/* 822683E0h case    3:*/		return 0x822683E4;
		  /* 822683E4h */ case    4:  		/* lis R11, -32256 */
		/* 822683E4h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 822683E4h case    4:*/		return 0x822683E8;
		  /* 822683E8h */ case    5:  		/* lis R10, -32256 */
		/* 822683E8h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 822683E8h case    5:*/		return 0x822683EC;
		  /* 822683ECh */ case    6:  		/* lfd FR0, <#[R11 + 1848]> */
		/* 822683ECh case    6:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000738) );
		/* 822683ECh case    6:*/		return 0x822683F0;
		  /* 822683F0h */ case    7:  		/* fadd FR12, FR1, FR0 */
		/* 822683F0h case    7:*/		cpu::op::fadd<0>(regs,&regs.FR12,regs.FR1,regs.FR0);
		/* 822683F0h case    7:*/		return 0x822683F4;
		  /* 822683F4h */ case    8:  		/* lfd FR13, <#[R10 + 4736]> */
		/* 822683F4h case    8:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R10 + 0x00001280) );
		/* 822683F4h case    8:*/		return 0x822683F8;
		  /* 822683F8h */ case    9:  		/* fdiv FR0, FR0, FR12 */
		/* 822683F8h case    9:*/		cpu::op::fdiv<0>(regs,&regs.FR0,regs.FR0,regs.FR12);
		/* 822683F8h case    9:*/		return 0x822683FC;
		  /* 822683FCh */ case   10:  		/* fsub FR0, FR13, FR0 */
		/* 822683FCh case   10:*/		cpu::op::fsub<0>(regs,&regs.FR0,regs.FR13,regs.FR0);
		/* 822683FCh case   10:*/		return 0x82268400;
		  /* 82268400h */ case   11:  		/* fmul FR0, FR0, FR31 */
		/* 82268400h case   11:*/		cpu::op::fmul<0>(regs,&regs.FR0,regs.FR0,regs.FR31);
		/* 82268400h case   11:*/		return 0x82268404;
		  /* 82268404h */ case   12:  		/* b 84 */
		/* 82268404h case   12:*/		return 0x82268458;
		/* 82268404h case   12:*/		return 0x82268408;
	}
	return 0x82268408;
} // Block from 822683D4h-82268408h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82268408h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268408( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268408) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268408);
		  /* 82268408h */ case    0:  		/* fmul FR6, FR0, FR0 */
		/* 82268408h case    0:*/		cpu::op::fmul<0>(regs,&regs.FR6,regs.FR0,regs.FR0);
		/* 82268408h case    0:*/		return 0x8226840C;
		  /* 8226840Ch */ case    1:  		/* lis R10, -32251 */
		/* 8226840Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 8226840Ch case    1:*/		return 0x82268410;
		  /* 82268410h */ case    2:  		/* lfd FR12, <#[R11 - 16]> */
		/* 82268410h case    2:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R11 + 0xFFFFFFF0) );
		/* 82268410h case    2:*/		return 0x82268414;
		  /* 82268414h */ case    3:  		/* lis R9, -32251 */
		/* 82268414h case    3:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8205);
		/* 82268414h case    3:*/		return 0x82268418;
		  /* 82268418h */ case    4:  		/* lfd FR11, <#[R11 + 16]> */
		/* 82268418h case    4:*/		cpu::mem::load64f( regs, &regs.FR11, (uint32)(regs.R11 + 0x00000010) );
		/* 82268418h case    4:*/		return 0x8226841C;
		  /* 8226841Ch */ case    5:  		/* lis R8, -32256 */
		/* 8226841Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8200);
		/* 8226841Ch case    5:*/		return 0x82268420;
		  /* 82268420h */ case    6:  		/* lfd FR9, <#[R11 + 8]> */
		/* 82268420h case    6:*/		cpu::mem::load64f( regs, &regs.FR9, (uint32)(regs.R11 + 0x00000008) );
		/* 82268420h case    6:*/		return 0x82268424;
		  /* 82268424h */ case    7:  		/* lfd FR8, <#[R11]> */
		/* 82268424h case    7:*/		cpu::mem::load64f( regs, &regs.FR8, (uint32)(regs.R11 + 0x00000000) );
		/* 82268424h case    7:*/		return 0x82268428;
		  /* 82268428h */ case    8:  		/* lfd FR13, <#[R10 - 17152]> */
		/* 82268428h case    8:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R10 + 0xFFFFBD00) );
		/* 82268428h case    8:*/		return 0x8226842C;
		  /* 8226842Ch */ case    9:  		/* lfd FR10, <#[R9 - 17160]> */
		/* 8226842Ch case    9:*/		cpu::mem::load64f( regs, &regs.FR10, (uint32)(regs.R9 + 0xFFFFBCF8) );
		/* 8226842Ch case    9:*/		return 0x82268430;
		  /* 82268430h */ case   10:  		/* lfd FR7, <#[R8 + 1848]> */
		/* 82268430h case   10:*/		cpu::mem::load64f( regs, &regs.FR7, (uint32)(regs.R8 + 0x00000738) );
		/* 82268430h case   10:*/		return 0x82268434;
		  /* 82268434h */ case   11:  		/* fnmsub FR13, FR6, FR13, FR12 */
		/* 82268434h case   11:*/		cpu::op::fnmsub<0>(regs,&regs.FR13,regs.FR6,regs.FR13,regs.FR12);
		/* 82268434h case   11:*/		return 0x82268438;
		  /* 82268438h */ case   12:  		/* fadd FR12, FR6, FR11 */
		/* 82268438h case   12:*/		cpu::op::fadd<0>(regs,&regs.FR12,regs.FR6,regs.FR11);
		/* 82268438h case   12:*/		return 0x8226843C;
		  /* 8226843Ch */ case   13:  		/* fmsub FR13, FR13, FR6, FR10 */
		/* 8226843Ch case   13:*/		cpu::op::fmsub<0>(regs,&regs.FR13,regs.FR13,regs.FR6,regs.FR10);
		/* 8226843Ch case   13:*/		return 0x82268440;
		  /* 82268440h */ case   14:  		/* fmadd FR12, FR12, FR6, FR9 */
		/* 82268440h case   14:*/		cpu::op::fmadd<0>(regs,&regs.FR12,regs.FR12,regs.FR6,regs.FR9);
		/* 82268440h case   14:*/		return 0x82268444;
		  /* 82268444h */ case   15:  		/* fmul FR13, FR13, FR6 */
		/* 82268444h case   15:*/		cpu::op::fmul<0>(regs,&regs.FR13,regs.FR13,regs.FR6);
		/* 82268444h case   15:*/		return 0x82268448;
		  /* 82268448h */ case   16:  		/* fmadd FR12, FR12, FR6, FR8 */
		/* 82268448h case   16:*/		cpu::op::fmadd<0>(regs,&regs.FR12,regs.FR12,regs.FR6,regs.FR8);
		/* 82268448h case   16:*/		return 0x8226844C;
		  /* 8226844Ch */ case   17:  		/* fdiv FR13, FR13, FR12 */
		/* 8226844Ch case   17:*/		cpu::op::fdiv<0>(regs,&regs.FR13,regs.FR13,regs.FR12);
		/* 8226844Ch case   17:*/		return 0x82268450;
		  /* 82268450h */ case   18:  		/* fadd FR13, FR13, FR7 */
		/* 82268450h case   18:*/		cpu::op::fadd<0>(regs,&regs.FR13,regs.FR13,regs.FR7);
		/* 82268450h case   18:*/		return 0x82268454;
		  /* 82268454h */ case   19:  		/* fmul FR0, FR13, FR0 */
		/* 82268454h case   19:*/		cpu::op::fmul<0>(regs,&regs.FR0,regs.FR13,regs.FR0);
		/* 82268454h case   19:*/		return 0x82268458;
	}
	return 0x82268458;
} // Block from 82268408h-82268458h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82268458h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268458( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268458) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268458);
		  /* 82268458h */ case    0:  		/* fneg FR13, FR0 */
		/* 82268458h case    0:*/		cpu::op::fneg<0>(regs,&regs.FR13,regs.FR0);
		/* 82268458h case    0:*/		return 0x8226845C;
		  /* 8226845Ch */ case    1:  		/* fsel FR1, FR30, FR0, FR13 */
		/* 8226845Ch case    1:*/		cpu::op::fsel<0>(regs,&regs.FR1,regs.FR30,regs.FR0,regs.FR13);
		/* 8226845Ch case    1:*/		return 0x82268460;
	}
	return 0x82268460;
} // Block from 82268458h-82268460h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82268460h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268460( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268460) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268460);
		  /* 82268460h */ case    0:  		/* addi R1, R1, 112 */
		/* 82268460h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82268460h case    0:*/		return 0x82268464;
		  /* 82268464h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82268464h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82268464h case    1:*/		return 0x82268468;
		  /* 82268468h */ case    2:  		/* mtspr LR, R12 */
		/* 82268468h case    2:*/		regs.LR = regs.R12;
		/* 82268468h case    2:*/		return 0x8226846C;
		  /* 8226846Ch */ case    3:  		/* lfd FR30, <#[R1 - 24]> */
		/* 8226846Ch case    3:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 8226846Ch case    3:*/		return 0x82268470;
		  /* 82268470h */ case    4:  		/* lfd FR31, <#[R1 - 16]> */
		/* 82268470h case    4:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82268470h case    4:*/		return 0x82268474;
		  /* 82268474h */ case    5:  		/* bclr 20, CR0_LT */
		/* 82268474h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82268474h case    5:*/		return 0x82268478;
	}
	return 0x82268478;
} // Block from 82268460h-82268478h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82268478h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268478( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268478) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268478);
		  /* 82268478h */ case    0:  		/* lis R11, -32256 */
		/* 82268478h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82268478h case    0:*/		return 0x8226847C;
		  /* 8226847Ch */ case    1:  		/* lfd FR0, <#[R11 + 1808]> */
		/* 8226847Ch case    1:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000710) );
		/* 8226847Ch case    1:*/		return 0x82268480;
		  /* 82268480h */ case    2:  		/* fcmpu CR6, FR1, FR0 */
		/* 82268480h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 82268480h case    2:*/		return 0x82268484;
		  /* 82268484h */ case    3:  		/* bclr 12, CR6_EQ */
		/* 82268484h case    3:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 82268484h case    3:*/		return 0x82268488;
	}
	return 0x82268488;
} // Block from 82268478h-82268488h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82268488h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268488( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268488) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268488);
		  /* 82268488h */ case    0:  		/* lis R11, -32251 */
		/* 82268488h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82268488h case    0:*/		return 0x8226848C;
		  /* 8226848Ch */ case    1:  		/* lis R10, -32216 */
		/* 8226848Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8228);
		/* 8226848Ch case    1:*/		return 0x82268490;
		  /* 82268490h */ case    2:  		/* addi R11, R11, -17144 */
		/* 82268490h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFBD08);
		/* 82268490h case    2:*/		return 0x82268494;
		  /* 82268494h */ case    3:  		/* addi R9, R10, 27496 */
		/* 82268494h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x6B68);
		/* 82268494h case    3:*/		return 0x82268498;
		  /* 82268498h */ case    4:  		/* lis R8, -32251 */
		/* 82268498h case    4:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8205);
		/* 82268498h case    4:*/		return 0x8226849C;
		  /* 8226849Ch */ case    5:  		/* lis R7, -32251 */
		/* 8226849Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8205);
		/* 8226849Ch case    5:*/		return 0x822684A0;
		  /* 822684A0h */ case    6:  		/* lfd FR13, <#[R10 + 27496]> */
		/* 822684A0h case    6:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R10 + 0x00006B68) );
		/* 822684A0h case    6:*/		return 0x822684A4;
		  /* 822684A4h */ case    7:  		/* lis R10, -32251 */
		/* 822684A4h case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 822684A4h case    7:*/		return 0x822684A8;
		  /* 822684A8h */ case    8:  		/* lfd FR0, <#[R11]> */
		/* 822684A8h case    8:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000000) );
		/* 822684A8h case    8:*/		return 0x822684AC;
		  /* 822684ACh */ case    9:  		/* lis R6, -32251 */
		/* 822684ACh case    9:*/		cpu::op::lis<0>(regs,&regs.R6,0xFFFF8205);
		/* 822684ACh case    9:*/		return 0x822684B0;
		  /* 822684B0h */ case   10:  		/* fmul FR4, FR1, FR0 */
		/* 822684B0h case   10:*/		cpu::op::fmul<0>(regs,&regs.FR4,regs.FR1,regs.FR0);
		/* 822684B0h case   10:*/		return 0x822684B4;
		  /* 822684B4h */ case   11:  		/* lfd FR12, <#[R9 + 8]> */
		/* 822684B4h case   11:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R9 + 0x00000008) );
		/* 822684B4h case   11:*/		return 0x822684B8;
		  /* 822684B8h */ case   12:  		/* lfd FR10, <#[R11 + 32]> */
		/* 822684B8h case   12:*/		cpu::mem::load64f( regs, &regs.FR10, (uint32)(regs.R11 + 0x00000020) );
		/* 822684B8h case   12:*/		return 0x822684BC;
		  /* 822684BCh */ case   13:  		/* lfd FR11, <#[R8 - 17032]> */
		/* 822684BCh case   13:*/		cpu::mem::load64f( regs, &regs.FR11, (uint32)(regs.R8 + 0xFFFFBD78) );
		/* 822684BCh case   13:*/		return 0x822684C0;
		  /* 822684C0h */ case   14:  		/* lfd FR9, <#[R11 + 80]> */
		/* 822684C0h case   14:*/		cpu::mem::load64f( regs, &regs.FR9, (uint32)(regs.R11 + 0x00000050) );
		/* 822684C0h case   14:*/		return 0x822684C4;
		  /* 822684C4h */ case   15:  		/* lfd FR8, <#[R7 - 17040]> */
		/* 822684C4h case   15:*/		cpu::mem::load64f( regs, &regs.FR8, (uint32)(regs.R7 + 0xFFFFBD70) );
		/* 822684C4h case   15:*/		return 0x822684C8;
		  /* 822684C8h */ case   16:  		/* lfd FR7, <#[R10 - 17048]> */
		/* 822684C8h case   16:*/		cpu::mem::load64f( regs, &regs.FR7, (uint32)(regs.R10 + 0xFFFFBD68) );
		/* 822684C8h case   16:*/		return 0x822684CC;
		  /* 822684CCh */ case   17:  		/* lfd FR6, <#[R11 + 64]> */
		/* 822684CCh case   17:*/		cpu::mem::load64f( regs, &regs.FR6, (uint32)(regs.R11 + 0x00000040) );
		/* 822684CCh case   17:*/		return 0x822684D0;
		  /* 822684D0h */ case   18:  		/* lfd FR0, <#[R11 + 48]> */
		/* 822684D0h case   18:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000030) );
		/* 822684D0h case   18:*/		return 0x822684D4;
		  /* 822684D4h */ case   19:  		/* lfd FR5, <#[R6 - 17056]> */
		/* 822684D4h case   19:*/		cpu::mem::load64f( regs, &regs.FR5, (uint32)(regs.R6 + 0xFFFFBD60) );
		/* 822684D4h case   19:*/		return 0x822684D8;
		  /* 822684D8h */ case   20:  		/* fctid FR4, FR4 */
		/* 822684D8h case   20:*/		cpu::op::fctid<0>(regs,&regs.FR4,regs.FR4);
		/* 822684D8h case   20:*/		return 0x822684DC;
		  /* 822684DCh */ case   21:  		/* stfd FR4, <#[R1 - 16]> */
		/* 822684DCh case   21:*/		cpu::mem::store64f( regs, regs.FR4, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822684DCh case   21:*/		return 0x822684E0;
		  /* 822684E0h */ case   22:  		/* ld R10, <#[R1 - 16]> */
		/* 822684E0h case   22:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822684E0h case   22:*/		return 0x822684E4;
		  /* 822684E4h */ case   23:  		/* rldicl R10, R10, 0, 63 */
		/* 822684E4h case   23:*/		cpu::op::rldicl<0,0,63>(regs,&regs.R10,regs.R10);
		/* 822684E4h case   23:*/		return 0x822684E8;
		  /* 822684E8h */ case   24:  		/* fcfid FR4, FR4 */
		/* 822684E8h case   24:*/		cpu::op::fcfid<0>(regs,&regs.FR4,regs.FR4);
		/* 822684E8h case   24:*/		return 0x822684EC;
		  /* 822684ECh */ case   25:  		/* cmpdi CR6, R10, 0 */
		/* 822684ECh case   25:*/		cpu::op::cmpdi<6>(regs,regs.R10,0x00000000);
		/* 822684ECh case   25:*/		return 0x822684F0;
		  /* 822684F0h */ case   26:  		/* fnmsub FR13, FR13, FR4, FR1 */
		/* 822684F0h case   26:*/		cpu::op::fnmsub<0>(regs,&regs.FR13,regs.FR13,regs.FR4,regs.FR1);
		/* 822684F0h case   26:*/		return 0x822684F4;
		  /* 822684F4h */ case   27:  		/* fnmsub FR13, FR12, FR4, FR13 */
		/* 822684F4h case   27:*/		cpu::op::fnmsub<0>(regs,&regs.FR13,regs.FR12,regs.FR4,regs.FR13);
		/* 822684F4h case   27:*/		return 0x822684F8;
		  /* 822684F8h */ case   28:  		/* fmul FR12, FR13, FR13 */
		/* 822684F8h case   28:*/		cpu::op::fmul<0>(regs,&regs.FR12,regs.FR13,regs.FR13);
		/* 822684F8h case   28:*/		return 0x822684FC;
		  /* 822684FCh */ case   29:  		/* fnmsub FR11, FR12, FR11, FR10 */
		/* 822684FCh case   29:*/		cpu::op::fnmsub<0>(regs,&regs.FR11,regs.FR12,regs.FR11,regs.FR10);
		/* 822684FCh case   29:*/		return 0x82268500;
		  /* 82268500h */ case   30:  		/* fmsub FR10, FR12, FR9, FR8 */
		/* 82268500h case   30:*/		cpu::op::fmsub<0>(regs,&regs.FR10,regs.FR12,regs.FR9,regs.FR8);
		/* 82268500h case   30:*/		return 0x82268504;
		  /* 82268504h */ case   31:  		/* fmsub FR11, FR11, FR12, FR7 */
		/* 82268504h case   31:*/		cpu::op::fmsub<0>(regs,&regs.FR11,regs.FR11,regs.FR12,regs.FR7);
		/* 82268504h case   31:*/		return 0x82268508;
		  /* 82268508h */ case   32:  		/* fmadd FR10, FR10, FR12, FR6 */
		/* 82268508h case   32:*/		cpu::op::fmadd<0>(regs,&regs.FR10,regs.FR10,regs.FR12,regs.FR6);
		/* 82268508h case   32:*/		return 0x8226850C;
		  /* 8226850Ch */ case   33:  		/* fmadd FR11, FR11, FR12, FR0 */
		/* 8226850Ch case   33:*/		cpu::op::fmadd<0>(regs,&regs.FR11,regs.FR11,regs.FR12,regs.FR0);
		/* 8226850Ch case   33:*/		return 0x82268510;
		  /* 82268510h */ case   34:  		/* fmsub FR10, FR10, FR12, FR5 */
		/* 82268510h case   34:*/		cpu::op::fmsub<0>(regs,&regs.FR10,regs.FR10,regs.FR12,regs.FR5);
		/* 82268510h case   34:*/		return 0x82268514;
		  /* 82268514h */ case   35:  		/* fmul FR13, FR11, FR13 */
		/* 82268514h case   35:*/		cpu::op::fmul<0>(regs,&regs.FR13,regs.FR11,regs.FR13);
		/* 82268514h case   35:*/		return 0x82268518;
		  /* 82268518h */ case   36:  		/* fmadd FR0, FR10, FR12, FR0 */
		/* 82268518h case   36:*/		cpu::op::fmadd<0>(regs,&regs.FR0,regs.FR10,regs.FR12,regs.FR0);
		/* 82268518h case   36:*/		return 0x8226851C;
		  /* 8226851Ch */ case   37:  		/* bc 12, CR6_EQ, 16 */
		/* 8226851Ch case   37:*/		if ( regs.CR[6].eq ) { return 0x8226852C;  }
		/* 8226851Ch case   37:*/		return 0x82268520;
		  /* 82268520h */ case   38:  		/* fneg FR13, FR13 */
		/* 82268520h case   38:*/		cpu::op::fneg<0>(regs,&regs.FR13,regs.FR13);
		/* 82268520h case   38:*/		return 0x82268524;
		  /* 82268524h */ case   39:  		/* fdiv FR0, FR0, FR13 */
		/* 82268524h case   39:*/		cpu::op::fdiv<0>(regs,&regs.FR0,regs.FR0,regs.FR13);
		/* 82268524h case   39:*/		return 0x82268528;
		  /* 82268528h */ case   40:  		/* b 8 */
		/* 82268528h case   40:*/		return 0x82268530;
		/* 82268528h case   40:*/		return 0x8226852C;
	}
	return 0x8226852C;
} // Block from 82268488h-8226852Ch (41 instructions)

//////////////////////////////////////////////////////
// Block at 8226852Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226852C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226852C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226852C);
		  /* 8226852Ch */ case    0:  		/* fdiv FR0, FR13, FR0 */
		/* 8226852Ch case    0:*/		cpu::op::fdiv<0>(regs,&regs.FR0,regs.FR13,regs.FR0);
		/* 8226852Ch case    0:*/		return 0x82268530;
	}
	return 0x82268530;
} // Block from 8226852Ch-82268530h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82268530h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268530);
		  /* 82268530h */ case    0:  		/* fabs FR11, FR1 */
		/* 82268530h case    0:*/		cpu::op::fabs<0>(regs,&regs.FR11,regs.FR1);
		/* 82268530h case    0:*/		return 0x82268534;
		  /* 82268534h */ case    1:  		/* lfd FR13, <#[R11 + 16]> */
		/* 82268534h case    1:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000010) );
		/* 82268534h case    1:*/		return 0x82268538;
		  /* 82268538h */ case    2:  		/* lis R11, -32217 */
		/* 82268538h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82268538h case    2:*/		return 0x8226853C;
		  /* 8226853Ch */ case    3:  		/* lfd FR12, <#[R11 + 7336]> */
		/* 8226853Ch case    3:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R11 + 0x00001CA8) );
		/* 8226853Ch case    3:*/		return 0x82268540;
		  /* 82268540h */ case    4:  		/* fsub FR13, FR11, FR13 */
		/* 82268540h case    4:*/		cpu::op::fsub<0>(regs,&regs.FR13,regs.FR11,regs.FR13);
		/* 82268540h case    4:*/		return 0x82268544;
		  /* 82268544h */ case    5:  		/* fsel FR1, FR13, FR12, FR0 */
		/* 82268544h case    5:*/		cpu::op::fsel<0>(regs,&regs.FR1,regs.FR13,regs.FR12,regs.FR0);
		/* 82268544h case    5:*/		return 0x82268548;
		  /* 82268548h */ case    6:  		/* bclr 20, CR0_LT */
		/* 82268548h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82268548h case    6:*/		return 0x8226854C;
	}
	return 0x8226854C;
} // Block from 82268530h-8226854Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8226854Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226854C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226854C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226854C);
		  /* 8226854Ch */ case    0:  		/* nop */
		/* 8226854Ch case    0:*/		cpu::op::nop();
		/* 8226854Ch case    0:*/		return 0x82268550;
	}
	return 0x82268550;
} // Block from 8226854Ch-82268550h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82268550h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268550( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268550) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268550);
		  /* 82268550h */ case    0:  		/* mfspr R12, LR */
		/* 82268550h case    0:*/		regs.R12 = regs.LR;
		/* 82268550h case    0:*/		return 0x82268554;
		  /* 82268554h */ case    1:  		/* bl -1929976 */
		/* 82268554h case    1:*/		regs.LR = 0x82268558; return 0x8209125C;
		/* 82268554h case    1:*/		return 0x82268558;
		  /* 82268558h */ case    2:  		/* stfd FR30, <#[R1 - 48]> */
		/* 82268558h case    2:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R1 + 0xFFFFFFD0) );
		/* 82268558h case    2:*/		return 0x8226855C;
		  /* 8226855Ch */ case    3:  		/* stfd FR31, <#[R1 - 40]> */
		/* 8226855Ch case    3:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFD8) );
		/* 8226855Ch case    3:*/		return 0x82268560;
		  /* 82268560h */ case    4:  		/* stwu R1, <#[R1 - 144]> */
		/* 82268560h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82268560h case    4:*/		return 0x82268564;
		  /* 82268564h */ case    5:  		/* lis R11, -16377 */
		/* 82268564h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFFC007);
		/* 82268564h case    5:*/		return 0x82268568;
		  /* 82268568h */ case    6:  		/* stfd FR1, <#[R1 + 160]> */
		/* 82268568h case    6:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x000000A0) );
		/* 82268568h case    6:*/		return 0x8226856C;
		  /* 8226856Ch */ case    7:  		/* li R3, 248 */
		/* 8226856Ch case    7:*/		cpu::op::li<0>(regs,&regs.R3,0xF8);
		/* 8226856Ch case    7:*/		return 0x82268570;
		  /* 82268570h */ case    8:  		/* fmr FR31, FR1 */
		/* 82268570h case    8:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR1);
		/* 82268570h case    8:*/		return 0x82268574;
		  /* 82268574h */ case    9:  		/* ori R29, R11, 65279 */
		/* 82268574h case    9:*/		cpu::op::ori<0>(regs,&regs.R29,regs.R11,0xFEFF);
		/* 82268574h case    9:*/		return 0x82268578;
		  /* 82268578h */ case   10:  		/* mr R4, R29 */
		/* 82268578h case   10:*/		regs.R4 = regs.R29;
		/* 82268578h case   10:*/		return 0x8226857C;
		  /* 8226857Ch */ case   11:  		/* bl -1898172 */
		/* 8226857Ch case   11:*/		regs.LR = 0x82268580; return 0x82098EC0;
		/* 8226857Ch case   11:*/		return 0x82268580;
		  /* 82268580h */ case   12:  		/* lhz R11, <#[R1 + 160]> */
		/* 82268580h case   12:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000A0) );
		/* 82268580h case   12:*/		return 0x82268584;
		  /* 82268584h */ case   13:  		/* mr R31, R3 */
		/* 82268584h case   13:*/		regs.R31 = regs.R3;
		/* 82268584h case   13:*/		return 0x82268588;
		  /* 82268588h */ case   14:  		/* rlwinm R11, R11, 0, 17, 27 */
		/* 82268588h case   14:*/		cpu::op::rlwinm<0,0,17,27>(regs,&regs.R11,regs.R11);
		/* 82268588h case   14:*/		return 0x8226858C;
		  /* 8226858Ch */ case   15:  		/* cmplwi CR6, R11, 32752 */
		/* 8226858Ch case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00007FF0);
		/* 8226858Ch case   15:*/		return 0x82268590;
		  /* 82268590h */ case   16:  		/* bc 4, CR6_EQ, 96 */
		/* 82268590h case   16:*/		if ( !regs.CR[6].eq ) { return 0x822685F0;  }
		/* 82268590h case   16:*/		return 0x82268594;
		  /* 82268594h */ case   17:  		/* fmr FR1, FR31 */
		/* 82268594h case   17:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 82268594h case   17:*/		return 0x82268598;
		  /* 82268598h */ case   18:  		/* bl -1915800 */
		/* 82268598h case   18:*/		regs.LR = 0x8226859C; return 0x82094A00;
		/* 82268598h case   18:*/		return 0x8226859C;
		  /* 8226859Ch */ case   19:  		/* cmpwi CR0, R3, 0 */
		/* 8226859Ch case   19:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8226859Ch case   19:*/		return 0x822685A0;
	}
	return 0x822685A0;
} // Block from 82268550h-822685A0h (20 instructions)

//////////////////////////////////////////////////////
// Block at 822685A0h
// Function 'UTF8ToUnicode'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822685A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822685A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822685A0);
		  /* 822685A0h */ case    0:  		/* bc 4, CR0_GT, 60 */
		/* 822685A0h case    0:*/		if ( !regs.CR[0].gt ) { return 0x822685DC;  }
		/* 822685A0h case    0:*/		return 0x822685A4;
		  /* 822685A4h */ case    1:  		/* cmpwi CR6, R3, 2 */
		/* 822685A4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000002);
		/* 822685A4h case    1:*/		return 0x822685A8;
		  /* 822685A8h */ case    2:  		/* bc 4, CR6_GT, 32 */
		/* 822685A8h case    2:*/		if ( !regs.CR[6].gt ) { return 0x822685C8;  }
		/* 822685A8h case    2:*/		return 0x822685AC;
		  /* 822685ACh */ case    3:  		/* cmpwi CR6, R3, 3 */
		/* 822685ACh case    3:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000003);
		/* 822685ACh case    3:*/		return 0x822685B0;
		  /* 822685B0h */ case    4:  		/* bc 4, CR6_EQ, 44 */
		/* 822685B0h case    4:*/		if ( !regs.CR[6].eq ) { return 0x822685DC;  }
		/* 822685B0h case    4:*/		return 0x822685B4;
		  /* 822685B4h */ case    5:  		/* mr R5, R31 */
		/* 822685B4h case    5:*/		regs.R5 = regs.R31;
		/* 822685B4h case    5:*/		return 0x822685B8;
		  /* 822685B8h */ case    6:  		/* fmr FR1, FR31 */
		/* 822685B8h case    6:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 822685B8h case    6:*/		return 0x822685BC;
		  /* 822685BCh */ case    7:  		/* li R3, 31 */
		/* 822685BCh case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x1F);
		/* 822685BCh case    7:*/		return 0x822685C0;
		  /* 822685C0h */ case    8:  		/* bl -1898960 */
		/* 822685C0h case    8:*/		regs.LR = 0x822685C4; return 0x82098BF0;
		/* 822685C0h case    8:*/		return 0x822685C4;
		  /* 822685C4h */ case    9:  		/* b 480 */
		/* 822685C4h case    9:*/		return 0x822687A4;
		/* 822685C4h case    9:*/		return 0x822685C8;
	}
	return 0x822685C8;
} // Block from 822685A0h-822685C8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 822685C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822685C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822685C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822685C8);
		  /* 822685C8h */ case    0:  		/* mr R4, R29 */
		/* 822685C8h case    0:*/		regs.R4 = regs.R29;
		/* 822685C8h case    0:*/		return 0x822685CC;
		  /* 822685CCh */ case    1:  		/* mr R3, R31 */
		/* 822685CCh case    1:*/		regs.R3 = regs.R31;
		/* 822685CCh case    1:*/		return 0x822685D0;
		  /* 822685D0h */ case    2:  		/* bl -1898256 */
		/* 822685D0h case    2:*/		regs.LR = 0x822685D4; return 0x82098EC0;
		/* 822685D0h case    2:*/		return 0x822685D4;
		  /* 822685D4h */ case    3:  		/* fmr FR1, FR31 */
		/* 822685D4h case    3:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 822685D4h case    3:*/		return 0x822685D8;
		  /* 822685D8h */ case    4:  		/* b 460 */
		/* 822685D8h case    4:*/		return 0x822687A4;
		/* 822685D8h case    4:*/		return 0x822685DC;
	}
	return 0x822685DC;
} // Block from 822685C8h-822685DCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 822685DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822685DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822685DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822685DC);
		  /* 822685DCh */ case    0:  		/* lis R11, -32256 */
		/* 822685DCh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 822685DCh case    0:*/		return 0x822685E0;
		  /* 822685E0h */ case    1:  		/* li R3, 8 */
		/* 822685E0h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x8);
		/* 822685E0h case    1:*/		return 0x822685E4;
		  /* 822685E4h */ case    2:  		/* lfd FR0, <#[R11 + 1848]> */
		/* 822685E4h case    2:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000738) );
		/* 822685E4h case    2:*/		return 0x822685E8;
		  /* 822685E8h */ case    3:  		/* fadd FR2, FR31, FR0 */
		/* 822685E8h case    3:*/		cpu::op::fadd<0>(regs,&regs.FR2,regs.FR31,regs.FR0);
		/* 822685E8h case    3:*/		return 0x822685EC;
		  /* 822685ECh */ case    4:  		/* b 424 */
		/* 822685ECh case    4:*/		return 0x82268794;
		/* 822685ECh case    4:*/		return 0x822685F0;
	}
	return 0x822685F0;
} // Block from 822685DCh-822685F0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822685F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822685F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822685F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822685F0);
		  /* 822685F0h */ case    0:  		/* lis R11, -32256 */
		/* 822685F0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 822685F0h case    0:*/		return 0x822685F4;
		  /* 822685F4h */ case    1:  		/* lfd FR0, <#[R11 + 1808]> */
		/* 822685F4h case    1:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000710) );
		/* 822685F4h case    1:*/		return 0x822685F8;
		  /* 822685F8h */ case    2:  		/* fcmpu CR6, FR31, FR0 */
		/* 822685F8h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR0);
		/* 822685F8h case    2:*/		return 0x822685FC;
		  /* 822685FCh */ case    3:  		/* bc 12, CR6_EQ, -52 */
		/* 822685FCh case    3:*/		if ( regs.CR[6].eq ) { return 0x822685C8;  }
		/* 822685FCh case    3:*/		return 0x82268600;
		  /* 82268600h */ case    4:  		/* fabs FR1, FR31 */
		/* 82268600h case    4:*/		cpu::op::fabs<0>(regs,&regs.FR1,regs.FR31);
		/* 82268600h case    4:*/		return 0x82268604;
		  /* 82268604h */ case    5:  		/* li R30, -1 */
		/* 82268604h case    5:*/		cpu::op::li<0>(regs,&regs.R30,0xFFFFFFFF);
		/* 82268604h case    5:*/		return 0x82268608;
		  /* 82268608h */ case    6:  		/* fcmpu CR6, FR31, FR0 */
		/* 82268608h case    6:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR0);
		/* 82268608h case    6:*/		return 0x8226860C;
		  /* 8226860Ch */ case    7:  		/* bc 12, CR6_LT, 8 */
		/* 8226860Ch case    7:*/		if ( regs.CR[6].lt ) { return 0x82268614;  }
		/* 8226860Ch case    7:*/		return 0x82268610;
		  /* 82268610h */ case    8:  		/* li R30, 1 */
		/* 82268610h case    8:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 82268610h case    8:*/		return 0x82268614;
	}
	return 0x82268614;
} // Block from 822685F0h-82268614h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82268614h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268614( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268614) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268614);
		  /* 82268614h */ case    0:  		/* lis R11, -32256 */
		/* 82268614h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82268614h case    0:*/		return 0x82268618;
		  /* 82268618h */ case    1:  		/* lfd FR30, <#[R11 + 1848]> */
		/* 82268618h case    1:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R11 + 0x00000738) );
		/* 82268618h case    1:*/		return 0x8226861C;
		  /* 8226861Ch */ case    2:  		/* lis R11, -32251 */
		/* 8226861Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8226861Ch case    2:*/		return 0x82268620;
		  /* 82268620h */ case    3:  		/* fcmpu CR6, FR1, FR30 */
		/* 82268620h case    3:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR30);
		/* 82268620h case    3:*/		return 0x82268624;
		  /* 82268624h */ case    4:  		/* addi R11, R11, -17024 */
		/* 82268624h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFBD80);
		/* 82268624h case    4:*/		return 0x82268628;
		  /* 82268628h */ case    5:  		/* bc 4, CR6_GT, 160 */
		/* 82268628h case    5:*/		if ( !regs.CR[6].gt ) { return 0x822686C8;  }
		/* 82268628h case    5:*/		return 0x8226862C;
		  /* 8226862Ch */ case    6:  		/* lfd FR0, <#[R11 + 8]> */
		/* 8226862Ch case    6:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000008) );
		/* 8226862Ch case    6:*/		return 0x82268630;
		  /* 82268630h */ case    7:  		/* fcmpu CR6, FR1, FR0 */
		/* 82268630h case    7:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 82268630h case    7:*/		return 0x82268634;
		  /* 82268634h */ case    8:  		/* bc 4, CR6_GT, 96 */
		/* 82268634h case    8:*/		if ( !regs.CR[6].gt ) { return 0x82268694;  }
		/* 82268634h case    8:*/		return 0x82268638;
		  /* 82268638h */ case    9:  		/* lfd FR0, <#[R11 + 16]> */
		/* 82268638h case    9:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000010) );
		/* 82268638h case    9:*/		return 0x8226863C;
		  /* 8226863Ch */ case   10:  		/* fcmpu CR6, FR1, FR0 */
		/* 8226863Ch case   10:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 8226863Ch case   10:*/		return 0x82268640;
		  /* 82268640h */ case   11:  		/* bc 4, CR6_GT, 24 */
		/* 82268640h case   11:*/		if ( !regs.CR[6].gt ) { return 0x82268658;  }
		/* 82268640h case   11:*/		return 0x82268644;
		  /* 82268644h */ case   12:  		/* lis R11, -32217 */
		/* 82268644h case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82268644h case   12:*/		return 0x82268648;
		  /* 82268648h */ case   13:  		/* li R3, 17 */
		/* 82268648h case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x11);
		/* 82268648h case   13:*/		return 0x8226864C;
		  /* 8226864Ch */ case   14:  		/* lfd FR0, <#[R11 + 7328]> */
		/* 8226864Ch case   14:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00001CA0) );
		/* 8226864Ch case   14:*/		return 0x82268650;
		  /* 82268650h */ case   15:  		/* fmul FR2, FR0, FR31 */
		/* 82268650h case   15:*/		cpu::op::fmul<0>(regs,&regs.FR2,regs.FR0,regs.FR31);
		/* 82268650h case   15:*/		return 0x82268654;
		  /* 82268654h */ case   16:  		/* b 320 */
		/* 82268654h case   16:*/		return 0x82268794;
		/* 82268654h case   16:*/		return 0x82268658;
	}
	return 0x82268658;
} // Block from 82268614h-82268658h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82268658h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268658( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268658) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268658);
		  /* 82268658h */ case    0:  		/* addi R4, R1, 80 */
		/* 82268658h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 82268658h case    0:*/		return 0x8226865C;
		  /* 8226865Ch */ case    1:  		/* bl 1420 */
		/* 8226865Ch case    1:*/		regs.LR = 0x82268660; return 0x82268BE8;
		/* 8226865Ch case    1:*/		return 0x82268660;
		  /* 82268660h */ case    2:  		/* lwz R11, <#[R1 + 80]> */
		/* 82268660h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82268660h case    2:*/		return 0x82268664;
		  /* 82268664h */ case    3:  		/* addi R4, R11, -1 */
		/* 82268664h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFF);
		/* 82268664h case    3:*/		return 0x82268668;
		  /* 82268668h */ case    4:  		/* stw R4, <#[R1 + 80]> */
		/* 82268668h case    4:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 82268668h case    4:*/		return 0x8226866C;
		  /* 8226866Ch */ case    5:  		/* cmpwi CR6, R4, 1024 */
		/* 8226866Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000400);
		/* 8226866Ch case    5:*/		return 0x82268670;
		  /* 82268670h */ case    6:  		/* bc 4, CR6_GT, 24 */
		/* 82268670h case    6:*/		if ( !regs.CR[6].gt ) { return 0x82268688;  }
		/* 82268670h case    6:*/		return 0x82268674;
		  /* 82268674h */ case    7:  		/* addi R4, R4, -1536 */
		/* 82268674h case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0xFFFFFA00);
		/* 82268674h case    7:*/		return 0x82268678;
		  /* 82268678h */ case    8:  		/* bl -1916144 */
		/* 82268678h case    8:*/		regs.LR = 0x8226867C; return 0x82094988;
		/* 82268678h case    8:*/		return 0x8226867C;
		  /* 8226867Ch */ case    9:  		/* fmr FR2, FR1 */
		/* 8226867Ch case    9:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR1);
		/* 8226867Ch case    9:*/		return 0x82268680;
		  /* 82268680h */ case   10:  		/* li R3, 17 */
		/* 82268680h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x11);
		/* 82268680h case   10:*/		return 0x82268684;
		  /* 82268684h */ case   11:  		/* b 272 */
		/* 82268684h case   11:*/		return 0x82268794;
		/* 82268684h case   11:*/		return 0x82268688;
	}
	return 0x82268688;
} // Block from 82268658h-82268688h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82268688h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268688( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268688) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268688);
		  /* 82268688h */ case    0:  		/* bl -1916160 */
		/* 82268688h case    0:*/		regs.LR = 0x8226868C; return 0x82094988;
		/* 82268688h case    0:*/		return 0x8226868C;
		  /* 8226868Ch */ case    1:  		/* fmr FR30, FR1 */
		/* 8226868Ch case    1:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR1);
		/* 8226868Ch case    1:*/		return 0x82268690;
		  /* 82268690h */ case    2:  		/* b 40 */
		/* 82268690h case    2:*/		return 0x822686B8;
		/* 82268690h case    2:*/		return 0x82268694;
	}
	return 0x82268694;
} // Block from 82268688h-82268694h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82268694h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268694( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268694) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268694);
		  /* 82268694h */ case    0:  		/* addi R4, R1, 80 */
		/* 82268694h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 82268694h case    0:*/		return 0x82268698;
		  /* 82268698h */ case    1:  		/* bl 1360 */
		/* 82268698h case    1:*/		regs.LR = 0x8226869C; return 0x82268BE8;
		/* 82268698h case    1:*/		return 0x8226869C;
		  /* 8226869Ch */ case    2:  		/* lwz R4, <#[R1 + 80]> */
		/* 8226869Ch case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 8226869Ch case    2:*/		return 0x822686A0;
		  /* 822686A0h */ case    3:  		/* bl -1916184 */
		/* 822686A0h case    3:*/		regs.LR = 0x822686A4; return 0x82094988;
		/* 822686A0h case    3:*/		return 0x822686A4;
		  /* 822686A4h */ case    4:  		/* fdiv FR13, FR30, FR1 */
		/* 822686A4h case    4:*/		cpu::op::fdiv<0>(regs,&regs.FR13,regs.FR30,regs.FR1);
		/* 822686A4h case    4:*/		return 0x822686A8;
		  /* 822686A8h */ case    5:  		/* lis R11, -32256 */
		/* 822686A8h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 822686A8h case    5:*/		return 0x822686AC;
		  /* 822686ACh */ case    6:  		/* lfd FR0, <#[R11 + 4736]> */
		/* 822686ACh case    6:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00001280) );
		/* 822686ACh case    6:*/		return 0x822686B0;
		  /* 822686B0h */ case    7:  		/* fsub FR13, FR1, FR13 */
		/* 822686B0h case    7:*/		cpu::op::fsub<0>(regs,&regs.FR13,regs.FR1,regs.FR13);
		/* 822686B0h case    7:*/		return 0x822686B4;
		  /* 822686B4h */ case    8:  		/* fmul FR30, FR13, FR0 */
		/* 822686B4h case    8:*/		cpu::op::fmul<0>(regs,&regs.FR30,regs.FR13,regs.FR0);
		/* 822686B4h case    8:*/		return 0x822686B8;
	}
	return 0x822686B8;
} // Block from 82268694h-822686B8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 822686B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822686B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822686B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822686B8);
		  /* 822686B8h */ case    0:  		/* cmpwi CR6, R30, 0 */
		/* 822686B8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 822686B8h case    0:*/		return 0x822686BC;
		  /* 822686BCh */ case    1:  		/* bc 4, CR6_LT, 180 */
		/* 822686BCh case    1:*/		if ( !regs.CR[6].lt ) { return 0x82268770;  }
		/* 822686BCh case    1:*/		return 0x822686C0;
		  /* 822686C0h */ case    2:  		/* fneg FR30, FR30 */
		/* 822686C0h case    2:*/		cpu::op::fneg<0>(regs,&regs.FR30,regs.FR30);
		/* 822686C0h case    2:*/		return 0x822686C4;
		  /* 822686C4h */ case    3:  		/* b 172 */
		/* 822686C4h case    3:*/		return 0x82268770;
		/* 822686C4h case    3:*/		return 0x822686C8;
	}
	return 0x822686C8;
} // Block from 822686B8h-822686C8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822686C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822686C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822686C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822686C8);
		  /* 822686C8h */ case    0:  		/* lfd FR0, <#[R11]> */
		/* 822686C8h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000000) );
		/* 822686C8h case    0:*/		return 0x822686CC;
		  /* 822686CCh */ case    1:  		/* fcmpu CR6, FR1, FR0 */
		/* 822686CCh case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 822686CCh case    1:*/		return 0x822686D0;
		  /* 822686D0h */ case    2:  		/* bc 4, CR6_LT, 72 */
		/* 822686D0h case    2:*/		if ( !regs.CR[6].lt ) { return 0x82268718;  }
		/* 822686D0h case    2:*/		return 0x822686D4;
		  /* 822686D4h */ case    3:  		/* stfd FR31, <#[R1 + 88]> */
		/* 822686D4h case    3:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0x00000058) );
		/* 822686D4h case    3:*/		return 0x822686D8;
		  /* 822686D8h */ case    4:  		/* lhz R11, <#[R1 + 88]> */
		/* 822686D8h case    4:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 822686D8h case    4:*/		return 0x822686DC;
		  /* 822686DCh */ case    5:  		/* fmr FR30, FR31 */
		/* 822686DCh case    5:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR31);
		/* 822686DCh case    5:*/		return 0x822686E0;
		  /* 822686E0h */ case    6:  		/* rlwinm. R11, R11, 0, 17, 27 */
		/* 822686E0h case    6:*/		cpu::op::rlwinm<1,0,17,27>(regs,&regs.R11,regs.R11);
		/* 822686E0h case    6:*/		return 0x822686E4;
		  /* 822686E4h */ case    7:  		/* bc 4, CR0_EQ, 140 */
		/* 822686E4h case    7:*/		if ( !regs.CR[0].eq ) { return 0x82268770;  }
		/* 822686E4h case    7:*/		return 0x822686E8;
		  /* 822686E8h */ case    8:  		/* lwz R11, <#[R1 + 88]> */
		/* 822686E8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 822686E8h case    8:*/		return 0x822686EC;
		  /* 822686ECh */ case    9:  		/* rlwinm. R11, R11, 0, 12, 31 */
		/* 822686ECh case    9:*/		cpu::op::rlwinm<1,0,12,31>(regs,&regs.R11,regs.R11);
		/* 822686ECh case    9:*/		return 0x822686F0;
		  /* 822686F0h */ case   10:  		/* bc 4, CR0_EQ, 16 */
		/* 822686F0h case   10:*/		if ( !regs.CR[0].eq ) { return 0x82268700;  }
		/* 822686F0h case   10:*/		return 0x822686F4;
		  /* 822686F4h */ case   11:  		/* lwz R11, <#[R1 + 92]> */
		/* 822686F4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 822686F4h case   11:*/		return 0x822686F8;
		  /* 822686F8h */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 822686F8h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 822686F8h case   12:*/		return 0x822686FC;
		  /* 822686FCh */ case   13:  		/* bc 12, CR6_EQ, 116 */
		/* 822686FCh case   13:*/		if ( regs.CR[6].eq ) { return 0x82268770;  }
		/* 822686FCh case   13:*/		return 0x82268700;
	}
	return 0x82268700;
} // Block from 822686C8h-82268700h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82268700h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268700( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268700) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268700);
		  /* 82268700h */ case    0:  		/* li R4, 1536 */
		/* 82268700h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x600);
		/* 82268700h case    0:*/		return 0x82268704;
		  /* 82268704h */ case    1:  		/* fmr FR1, FR31 */
		/* 82268704h case    1:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 82268704h case    1:*/		return 0x82268708;
		  /* 82268708h */ case    2:  		/* bl -1916224 */
		/* 82268708h case    2:*/		regs.LR = 0x8226870C; return 0x820949C8;
		/* 82268708h case    2:*/		return 0x8226870C;
		  /* 8226870Ch */ case    3:  		/* li R3, 18 */
		/* 8226870Ch case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x12);
		/* 8226870Ch case    3:*/		return 0x82268710;
		  /* 82268710h */ case    4:  		/* fmr FR2, FR1 */
		/* 82268710h case    4:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR1);
		/* 82268710h case    4:*/		return 0x82268714;
		  /* 82268714h */ case    5:  		/* b 128 */
		/* 82268714h case    5:*/		return 0x82268794;
		/* 82268714h case    5:*/		return 0x82268718;
	}
	return 0x82268718;
} // Block from 82268700h-82268718h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82268718h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268718( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268718) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268718);
		  /* 82268718h */ case    0:  		/* fmul FR7, FR31, FR31 */
		/* 82268718h case    0:*/		cpu::op::fmul<0>(regs,&regs.FR7,regs.FR31,regs.FR31);
		/* 82268718h case    0:*/		return 0x8226871C;
		  /* 8226871Ch */ case    1:  		/* lis R10, -32251 */
		/* 8226871Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 8226871Ch case    1:*/		return 0x82268720;
		  /* 82268720h */ case    2:  		/* lis R9, -32251 */
		/* 82268720h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8205);
		/* 82268720h case    2:*/		return 0x82268724;
		  /* 82268724h */ case    3:  		/* lfd FR13, <#[R11 + 40]> */
		/* 82268724h case    3:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000028) );
		/* 82268724h case    3:*/		return 0x82268728;
		  /* 82268728h */ case    4:  		/* lis R8, -32251 */
		/* 82268728h case    4:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF8205);
		/* 82268728h case    4:*/		return 0x8226872C;
		  /* 8226872Ch */ case    5:  		/* lfd FR10, <#[R11 + 64]> */
		/* 8226872Ch case    5:*/		cpu::mem::load64f( regs, &regs.FR10, (uint32)(regs.R11 + 0x00000040) );
		/* 8226872Ch case    5:*/		return 0x82268730;
		  /* 82268730h */ case    6:  		/* lis R11, -32251 */
		/* 82268730h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82268730h case    6:*/		return 0x82268734;
		  /* 82268734h */ case    7:  		/* lis R7, -32251 */
		/* 82268734h case    7:*/		cpu::op::lis<0>(regs,&regs.R7,0xFFFF8205);
		/* 82268734h case    7:*/		return 0x82268738;
		  /* 82268738h */ case    8:  		/* lfd FR0, <#[R10 - 16912]> */
		/* 82268738h case    8:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0xFFFFBDF0) );
		/* 82268738h case    8:*/		return 0x8226873C;
		  /* 8226873Ch */ case    9:  		/* lfd FR12, <#[R9 - 16920]> */
		/* 8226873Ch case    9:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R9 + 0xFFFFBDE8) );
		/* 8226873Ch case    9:*/		return 0x82268740;
		  /* 82268740h */ case   10:  		/* lfd FR11, <#[R8 - 16928]> */
		/* 82268740h case   10:*/		cpu::mem::load64f( regs, &regs.FR11, (uint32)(regs.R8 + 0xFFFFBDE0) );
		/* 82268740h case   10:*/		return 0x82268744;
		  /* 82268744h */ case   11:  		/* lfd FR9, <#[R11 - 16936]> */
		/* 82268744h case   11:*/		cpu::mem::load64f( regs, &regs.FR9, (uint32)(regs.R11 + 0xFFFFBDD8) );
		/* 82268744h case   11:*/		return 0x82268748;
		  /* 82268748h */ case   12:  		/* lfd FR8, <#[R7 - 16944]> */
		/* 82268748h case   12:*/		cpu::mem::load64f( regs, &regs.FR8, (uint32)(regs.R7 + 0xFFFFBDD0) );
		/* 82268748h case   12:*/		return 0x8226874C;
		  /* 8226874Ch */ case   13:  		/* fnmsub FR0, FR7, FR0, FR13 */
		/* 8226874Ch case   13:*/		cpu::op::fnmsub<0>(regs,&regs.FR0,regs.FR7,regs.FR0,regs.FR13);
		/* 8226874Ch case   13:*/		return 0x82268750;
		  /* 82268750h */ case   14:  		/* fsub FR13, FR7, FR12 */
		/* 82268750h case   14:*/		cpu::op::fsub<0>(regs,&regs.FR13,regs.FR7,regs.FR12);
		/* 82268750h case   14:*/		return 0x82268754;
		  /* 82268754h */ case   15:  		/* fmsub FR0, FR0, FR7, FR11 */
		/* 82268754h case   15:*/		cpu::op::fmsub<0>(regs,&regs.FR0,regs.FR0,regs.FR7,regs.FR11);
		/* 82268754h case   15:*/		return 0x82268758;
		  /* 82268758h */ case   16:  		/* fmadd FR13, FR13, FR7, FR10 */
		/* 82268758h case   16:*/		cpu::op::fmadd<0>(regs,&regs.FR13,regs.FR13,regs.FR7,regs.FR10);
		/* 82268758h case   16:*/		return 0x8226875C;
		  /* 8226875Ch */ case   17:  		/* fmsub FR0, FR0, FR7, FR9 */
		/* 8226875Ch case   17:*/		cpu::op::fmsub<0>(regs,&regs.FR0,regs.FR0,regs.FR7,regs.FR9);
		/* 8226875Ch case   17:*/		return 0x82268760;
		  /* 82268760h */ case   18:  		/* fmsub FR13, FR13, FR7, FR8 */
		/* 82268760h case   18:*/		cpu::op::fmsub<0>(regs,&regs.FR13,regs.FR13,regs.FR7,regs.FR8);
		/* 82268760h case   18:*/		return 0x82268764;
		  /* 82268764h */ case   19:  		/* fdiv FR0, FR0, FR13 */
		/* 82268764h case   19:*/		cpu::op::fdiv<0>(regs,&regs.FR0,regs.FR0,regs.FR13);
		/* 82268764h case   19:*/		return 0x82268768;
		  /* 82268768h */ case   20:  		/* fmadd FR0, FR0, FR7, FR30 */
		/* 82268768h case   20:*/		cpu::op::fmadd<0>(regs,&regs.FR0,regs.FR0,regs.FR7,regs.FR30);
		/* 82268768h case   20:*/		return 0x8226876C;
		  /* 8226876Ch */ case   21:  		/* fmul FR30, FR0, FR31 */
		/* 8226876Ch case   21:*/		cpu::op::fmul<0>(regs,&regs.FR30,regs.FR0,regs.FR31);
		/* 8226876Ch case   21:*/		return 0x82268770;
	}
	return 0x82268770;
} // Block from 82268718h-82268770h (22 instructions)

//////////////////////////////////////////////////////
// Block at 82268770h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268770( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268770) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268770);
		  /* 82268770h */ case    0:  		/* rlwinm. R11, R31, 0, 28, 28 */
		/* 82268770h case    0:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R31);
		/* 82268770h case    0:*/		return 0x82268774;
		  /* 82268774h */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 82268774h case    1:*/		if ( regs.CR[0].eq ) { return 0x8226878C;  }
		/* 82268774h case    1:*/		return 0x82268778;
		  /* 82268778h */ case    2:  		/* mr R4, R29 */
		/* 82268778h case    2:*/		regs.R4 = regs.R29;
		/* 82268778h case    2:*/		return 0x8226877C;
		  /* 8226877Ch */ case    3:  		/* mr R3, R31 */
		/* 8226877Ch case    3:*/		regs.R3 = regs.R31;
		/* 8226877Ch case    3:*/		return 0x82268780;
		  /* 82268780h */ case    4:  		/* bl -1898688 */
		/* 82268780h case    4:*/		regs.LR = 0x82268784; return 0x82098EC0;
		/* 82268780h case    4:*/		return 0x82268784;
		  /* 82268784h */ case    5:  		/* fmr FR1, FR30 */
		/* 82268784h case    5:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR30);
		/* 82268784h case    5:*/		return 0x82268788;
		  /* 82268788h */ case    6:  		/* b 28 */
		/* 82268788h case    6:*/		return 0x822687A4;
		/* 82268788h case    6:*/		return 0x8226878C;
	}
	return 0x8226878C;
} // Block from 82268770h-8226878Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8226878Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226878C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226878C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226878C);
		  /* 8226878Ch */ case    0:  		/* fmr FR2, FR30 */
		/* 8226878Ch case    0:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR30);
		/* 8226878Ch case    0:*/		return 0x82268790;
		  /* 82268790h */ case    1:  		/* li R3, 16 */
		/* 82268790h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x10);
		/* 82268790h case    1:*/		return 0x82268794;
	}
	return 0x82268794;
} // Block from 8226878Ch-82268794h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82268794h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268794( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268794) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268794);
		  /* 82268794h */ case    0:  		/* mr R7, R31 */
		/* 82268794h case    0:*/		regs.R7 = regs.R31;
		/* 82268794h case    0:*/		return 0x82268798;
		  /* 82268798h */ case    1:  		/* fmr FR1, FR31 */
		/* 82268798h case    1:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 82268798h case    1:*/		return 0x8226879C;
		  /* 8226879Ch */ case    2:  		/* li R4, 31 */
		/* 8226879Ch case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x1F);
		/* 8226879Ch case    2:*/		return 0x822687A0;
		  /* 822687A0h */ case    3:  		/* bl -1899176 */
		/* 822687A0h case    3:*/		regs.LR = 0x822687A4; return 0x82098CF8;
		/* 822687A0h case    3:*/		return 0x822687A4;
	}
	return 0x822687A4;
} // Block from 82268794h-822687A4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822687A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822687A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822687A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822687A4);
		  /* 822687A4h */ case    0:  		/* addi R1, R1, 144 */
		/* 822687A4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 822687A4h case    0:*/		return 0x822687A8;
	}
	return 0x822687A8;
} // Block from 822687A4h-822687A8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822687A8h
// Function '_mbstrlen'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822687A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822687A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822687A8);
		  /* 822687A8h */ case    0:  		/* lfd FR30, <#[R1 - 48]> */
		/* 822687A8h case    0:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R1 + 0xFFFFFFD0) );
		/* 822687A8h case    0:*/		return 0x822687AC;
		  /* 822687ACh */ case    1:  		/* lfd FR31, <#[R1 - 40]> */
		/* 822687ACh case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFD8) );
		/* 822687ACh case    1:*/		return 0x822687B0;
		  /* 822687B0h */ case    2:  		/* b -1930500 */
		/* 822687B0h case    2:*/		return 0x820912AC;
		/* 822687B0h case    2:*/		return 0x822687B4;
		  /* 822687B4h */ case    3:  		/* nop */
		/* 822687B4h case    3:*/		cpu::op::nop();
		/* 822687B4h case    3:*/		return 0x822687B8;
	}
	return 0x822687B8;
} // Block from 822687A8h-822687B8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822687B8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822687B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822687B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822687B8);
		  /* 822687B8h */ case    0:  		/* mfspr R12, LR */
		/* 822687B8h case    0:*/		regs.R12 = regs.LR;
		/* 822687B8h case    0:*/		return 0x822687BC;
		  /* 822687BCh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 822687BCh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822687BCh case    1:*/		return 0x822687C0;
		  /* 822687C0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 822687C0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 822687C0h case    2:*/		return 0x822687C4;
		  /* 822687C4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 822687C4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822687C4h case    3:*/		return 0x822687C8;
		  /* 822687C8h */ case    4:  		/* stfd FR30, <#[R1 - 40]> */
		/* 822687C8h case    4:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R1 + 0xFFFFFFD8) );
		/* 822687C8h case    4:*/		return 0x822687CC;
		  /* 822687CCh */ case    5:  		/* stfd FR31, <#[R1 - 32]> */
		/* 822687CCh case    5:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFE0) );
		/* 822687CCh case    5:*/		return 0x822687D0;
	}
	return 0x822687D0;
} // Block from 822687B8h-822687D0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 822687D0h
// Function '_atof_l'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822687D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822687D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822687D0);
		  /* 822687D0h */ case    0:  		/* stwu R1, <#[R1 - 128]> */
		/* 822687D0h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 822687D0h case    0:*/		return 0x822687D4;
		  /* 822687D4h */ case    1:  		/* lis R11, -16377 */
		/* 822687D4h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFFC007);
		/* 822687D4h case    1:*/		return 0x822687D8;
		  /* 822687D8h */ case    2:  		/* stfd FR1, <#[R1 + 144]> */
		/* 822687D8h case    2:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000090) );
		/* 822687D8h case    2:*/		return 0x822687DC;
		  /* 822687DCh */ case    3:  		/* li R3, 248 */
		/* 822687DCh case    3:*/		cpu::op::li<0>(regs,&regs.R3,0xF8);
		/* 822687DCh case    3:*/		return 0x822687E0;
		  /* 822687E0h */ case    4:  		/* fmr FR30, FR1 */
		/* 822687E0h case    4:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR1);
		/* 822687E0h case    4:*/		return 0x822687E4;
		  /* 822687E4h */ case    5:  		/* ori R30, R11, 65279 */
		/* 822687E4h case    5:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R11,0xFEFF);
		/* 822687E4h case    5:*/		return 0x822687E8;
		  /* 822687E8h */ case    6:  		/* mr R4, R30 */
		/* 822687E8h case    6:*/		regs.R4 = regs.R30;
		/* 822687E8h case    6:*/		return 0x822687EC;
		  /* 822687ECh */ case    7:  		/* bl -1898796 */
		/* 822687ECh case    7:*/		regs.LR = 0x822687F0; return 0x82098EC0;
		/* 822687ECh case    7:*/		return 0x822687F0;
		  /* 822687F0h */ case    8:  		/* lhz R11, <#[R1 + 144]> */
		/* 822687F0h case    8:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000090) );
		/* 822687F0h case    8:*/		return 0x822687F4;
		  /* 822687F4h */ case    9:  		/* mr R31, R3 */
		/* 822687F4h case    9:*/		regs.R31 = regs.R3;
		/* 822687F4h case    9:*/		return 0x822687F8;
		  /* 822687F8h */ case   10:  		/* rlwinm R11, R11, 0, 17, 27 */
		/* 822687F8h case   10:*/		cpu::op::rlwinm<0,0,17,27>(regs,&regs.R11,regs.R11);
		/* 822687F8h case   10:*/		return 0x822687FC;
		  /* 822687FCh */ case   11:  		/* cmplwi CR6, R11, 32752 */
		/* 822687FCh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00007FF0);
		/* 822687FCh case   11:*/		return 0x82268800;
		  /* 82268800h */ case   12:  		/* bc 4, CR6_EQ, 100 */
		/* 82268800h case   12:*/		if ( !regs.CR[6].eq ) { return 0x82268864;  }
		/* 82268800h case   12:*/		return 0x82268804;
		  /* 82268804h */ case   13:  		/* fmr FR1, FR30 */
		/* 82268804h case   13:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR30);
		/* 82268804h case   13:*/		return 0x82268808;
		  /* 82268808h */ case   14:  		/* bl -1916424 */
		/* 82268808h case   14:*/		regs.LR = 0x8226880C; return 0x82094A00;
		/* 82268808h case   14:*/		return 0x8226880C;
		  /* 8226880Ch */ case   15:  		/* cmpwi CR0, R3, 0 */
		/* 8226880Ch case   15:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8226880Ch case   15:*/		return 0x82268810;
		  /* 82268810h */ case   16:  		/* bc 4, CR0_GT, 64 */
		/* 82268810h case   16:*/		if ( !regs.CR[0].gt ) { return 0x82268850;  }
		/* 82268810h case   16:*/		return 0x82268814;
		  /* 82268814h */ case   17:  		/* cmpwi CR6, R3, 2 */
		/* 82268814h case   17:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000002);
		/* 82268814h case   17:*/		return 0x82268818;
		  /* 82268818h */ case   18:  		/* bc 4, CR6_GT, 32 */
		/* 82268818h case   18:*/		if ( !regs.CR[6].gt ) { return 0x82268838;  }
		/* 82268818h case   18:*/		return 0x8226881C;
		  /* 8226881Ch */ case   19:  		/* cmpwi CR6, R3, 3 */
		/* 8226881Ch case   19:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000003);
		/* 8226881Ch case   19:*/		return 0x82268820;
		  /* 82268820h */ case   20:  		/* bc 4, CR6_EQ, 48 */
		/* 82268820h case   20:*/		if ( !regs.CR[6].eq ) { return 0x82268850;  }
		/* 82268820h case   20:*/		return 0x82268824;
		  /* 82268824h */ case   21:  		/* mr R5, R31 */
		/* 82268824h case   21:*/		regs.R5 = regs.R31;
		/* 82268824h case   21:*/		return 0x82268828;
		  /* 82268828h */ case   22:  		/* fmr FR1, FR30 */
		/* 82268828h case   22:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR30);
		/* 82268828h case   22:*/		return 0x8226882C;
		  /* 8226882Ch */ case   23:  		/* li R3, 19 */
		/* 8226882Ch case   23:*/		cpu::op::li<0>(regs,&regs.R3,0x13);
		/* 8226882Ch case   23:*/		return 0x82268830;
		  /* 82268830h */ case   24:  		/* bl -1899584 */
		/* 82268830h case   24:*/		regs.LR = 0x82268834; return 0x82098BF0;
		/* 82268830h case   24:*/		return 0x82268834;
		  /* 82268834h */ case   25:  		/* b 296 */
		/* 82268834h case   25:*/		return 0x8226895C;
		/* 82268834h case   25:*/		return 0x82268838;
	}
	return 0x82268838;
} // Block from 822687D0h-82268838h (26 instructions)

//////////////////////////////////////////////////////
// Block at 82268838h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268838( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268838) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268838);
		  /* 82268838h */ case    0:  		/* mr R4, R30 */
		/* 82268838h case    0:*/		regs.R4 = regs.R30;
		/* 82268838h case    0:*/		return 0x8226883C;
		  /* 8226883Ch */ case    1:  		/* mr R3, R31 */
		/* 8226883Ch case    1:*/		regs.R3 = regs.R31;
		/* 8226883Ch case    1:*/		return 0x82268840;
		  /* 82268840h */ case    2:  		/* bl -1898880 */
		/* 82268840h case    2:*/		regs.LR = 0x82268844; return 0x82098EC0;
		/* 82268840h case    2:*/		return 0x82268844;
		  /* 82268844h */ case    3:  		/* lis R11, -32217 */
		/* 82268844h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82268844h case    3:*/		return 0x82268848;
		  /* 82268848h */ case    4:  		/* lfd FR1, <#[R11 + 7328]> */
		/* 82268848h case    4:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R11 + 0x00001CA0) );
		/* 82268848h case    4:*/		return 0x8226884C;
		  /* 8226884Ch */ case    5:  		/* b 272 */
		/* 8226884Ch case    5:*/		return 0x8226895C;
		/* 8226884Ch case    5:*/		return 0x82268850;
	}
	return 0x82268850;
} // Block from 82268838h-82268850h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82268850h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268850( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268850) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268850);
		  /* 82268850h */ case    0:  		/* lis R11, -32256 */
		/* 82268850h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82268850h case    0:*/		return 0x82268854;
		  /* 82268854h */ case    1:  		/* li R3, 8 */
		/* 82268854h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x8);
		/* 82268854h case    1:*/		return 0x82268858;
		  /* 82268858h */ case    2:  		/* lfd FR0, <#[R11 + 1848]> */
		/* 82268858h case    2:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000738) );
		/* 82268858h case    2:*/		return 0x8226885C;
		  /* 8226885Ch */ case    3:  		/* fadd FR2, FR30, FR0 */
		/* 8226885Ch case    3:*/		cpu::op::fadd<0>(regs,&regs.FR2,regs.FR30,regs.FR0);
		/* 8226885Ch case    3:*/		return 0x82268860;
		  /* 82268860h */ case    4:  		/* b 236 */
		/* 82268860h case    4:*/		return 0x8226894C;
		/* 82268860h case    4:*/		return 0x82268864;
	}
	return 0x82268864;
} // Block from 82268850h-82268864h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82268864h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268864( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268864) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268864);
		  /* 82268864h */ case    0:  		/* lis R11, -32256 */
		/* 82268864h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82268864h case    0:*/		return 0x82268868;
		  /* 82268868h */ case    1:  		/* lfd FR0, <#[R11 + 1808]> */
		/* 82268868h case    1:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000710) );
		/* 82268868h case    1:*/		return 0x8226886C;
		  /* 8226886Ch */ case    2:  		/* fcmpu CR6, FR30, FR0 */
		/* 8226886Ch case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR30,regs.FR0);
		/* 8226886Ch case    2:*/		return 0x82268870;
		  /* 82268870h */ case    3:  		/* bc 4, CR6_EQ, 28 */
		/* 82268870h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8226888C;  }
		/* 82268870h case    3:*/		return 0x82268874;
		  /* 82268874h */ case    4:  		/* mr R4, R30 */
		/* 82268874h case    4:*/		regs.R4 = regs.R30;
		/* 82268874h case    4:*/		return 0x82268878;
		  /* 82268878h */ case    5:  		/* mr R3, R31 */
		/* 82268878h case    5:*/		regs.R3 = regs.R31;
		/* 82268878h case    5:*/		return 0x8226887C;
		  /* 8226887Ch */ case    6:  		/* bl -1898940 */
		/* 8226887Ch case    6:*/		regs.LR = 0x82268880; return 0x82098EC0;
		/* 8226887Ch case    6:*/		return 0x82268880;
		  /* 82268880h */ case    7:  		/* lis R11, -32256 */
		/* 82268880h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82268880h case    7:*/		return 0x82268884;
		  /* 82268884h */ case    8:  		/* lfd FR1, <#[R11 + 1848]> */
		/* 82268884h case    8:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R11 + 0x00000738) );
		/* 82268884h case    8:*/		return 0x82268888;
		  /* 82268888h */ case    9:  		/* b 212 */
		/* 82268888h case    9:*/		return 0x8226895C;
		/* 82268888h case    9:*/		return 0x8226888C;
	}
	return 0x8226888C;
} // Block from 82268864h-8226888Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 8226888Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226888C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226888C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226888C);
		  /* 8226888Ch */ case    0:  		/* fabs FR1, FR30 */
		/* 8226888Ch case    0:*/		cpu::op::fabs<0>(regs,&regs.FR1,regs.FR30);
		/* 8226888Ch case    0:*/		return 0x82268890;
	}
	return 0x82268890;
} // Block from 8226888Ch-82268890h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82268890h
// Function 'atof'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268890( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268890) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268890);
		  /* 82268890h */ case    0:  		/* lis R11, -32251 */
		/* 82268890h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82268890h case    0:*/		return 0x82268894;
		  /* 82268894h */ case    1:  		/* addi R11, R11, -17008 */
		/* 82268894h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFBD90);
		/* 82268894h case    1:*/		return 0x82268898;
		  /* 82268898h */ case    2:  		/* lfd FR0, <#[R11 - 8]> */
		/* 82268898h case    2:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0xFFFFFFF8) );
		/* 82268898h case    2:*/		return 0x8226889C;
		  /* 8226889Ch */ case    3:  		/* fcmpu CR6, FR1, FR0 */
		/* 8226889Ch case    3:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 8226889Ch case    3:*/		return 0x822688A0;
	}
	return 0x822688A0;
} // Block from 82268890h-822688A0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822688A0h
// Function 'strchr'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822688A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822688A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822688A0);
		  /* 822688A0h */ case    0:  		/* bc 4, CR6_GT, 92 */
		/* 822688A0h case    0:*/		if ( !regs.CR[6].gt ) { return 0x822688FC;  }
		/* 822688A0h case    0:*/		return 0x822688A4;
		  /* 822688A4h */ case    1:  		/* lfd FR0, <#[R11]> */
		/* 822688A4h case    1:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000000) );
		/* 822688A4h case    1:*/		return 0x822688A8;
		  /* 822688A8h */ case    2:  		/* fcmpu CR6, FR1, FR0 */
		/* 822688A8h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 822688A8h case    2:*/		return 0x822688AC;
		  /* 822688ACh */ case    3:  		/* bc 4, CR6_GT, 20 */
		/* 822688ACh case    3:*/		if ( !regs.CR[6].gt ) { return 0x822688C0;  }
		/* 822688ACh case    3:*/		return 0x822688B0;
		  /* 822688B0h */ case    4:  		/* lis R11, -32217 */
		/* 822688B0h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 822688B0h case    4:*/		return 0x822688B4;
		  /* 822688B4h */ case    5:  		/* li R3, 17 */
		/* 822688B4h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x11);
		/* 822688B4h case    5:*/		return 0x822688B8;
		  /* 822688B8h */ case    6:  		/* lfd FR2, <#[R11 + 7328]> */
		/* 822688B8h case    6:*/		cpu::mem::load64f( regs, &regs.FR2, (uint32)(regs.R11 + 0x00001CA0) );
		/* 822688B8h case    6:*/		return 0x822688BC;
		  /* 822688BCh */ case    7:  		/* b 144 */
		/* 822688BCh case    7:*/		return 0x8226894C;
		/* 822688BCh case    7:*/		return 0x822688C0;
	}
	return 0x822688C0;
} // Block from 822688A0h-822688C0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 822688C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822688C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822688C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822688C0);
		  /* 822688C0h */ case    0:  		/* addi R4, R1, 80 */
		/* 822688C0h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 822688C0h case    0:*/		return 0x822688C4;
		  /* 822688C4h */ case    1:  		/* bl 804 */
		/* 822688C4h case    1:*/		regs.LR = 0x822688C8; return 0x82268BE8;
		/* 822688C4h case    1:*/		return 0x822688C8;
		  /* 822688C8h */ case    2:  		/* lwz R11, <#[R1 + 80]> */
		/* 822688C8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 822688C8h case    2:*/		return 0x822688CC;
		  /* 822688CCh */ case    3:  		/* addi R4, R11, -1 */
		/* 822688CCh case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFF);
		/* 822688CCh case    3:*/		return 0x822688D0;
		  /* 822688D0h */ case    4:  		/* stw R4, <#[R1 + 80]> */
		/* 822688D0h case    4:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 822688D0h case    4:*/		return 0x822688D4;
		  /* 822688D4h */ case    5:  		/* cmpwi CR6, R4, 1024 */
		/* 822688D4h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000400);
		/* 822688D4h case    5:*/		return 0x822688D8;
		  /* 822688D8h */ case    6:  		/* bc 4, CR6_GT, 24 */
		/* 822688D8h case    6:*/		if ( !regs.CR[6].gt ) { return 0x822688F0;  }
		/* 822688D8h case    6:*/		return 0x822688DC;
		  /* 822688DCh */ case    7:  		/* addi R4, R4, -1536 */
		/* 822688DCh case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0xFFFFFA00);
		/* 822688DCh case    7:*/		return 0x822688E0;
	}
	return 0x822688E0;
} // Block from 822688C0h-822688E0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 822688E0h
// Function 'toupper'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822688E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822688E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822688E0);
		  /* 822688E0h */ case    0:  		/* bl -1916760 */
		/* 822688E0h case    0:*/		regs.LR = 0x822688E4; return 0x82094988;
		/* 822688E0h case    0:*/		return 0x822688E4;
		  /* 822688E4h */ case    1:  		/* fmr FR2, FR1 */
		/* 822688E4h case    1:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR1);
		/* 822688E4h case    1:*/		return 0x822688E8;
		  /* 822688E8h */ case    2:  		/* li R3, 17 */
		/* 822688E8h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x11);
		/* 822688E8h case    2:*/		return 0x822688EC;
		  /* 822688ECh */ case    3:  		/* b 96 */
		/* 822688ECh case    3:*/		return 0x8226894C;
		/* 822688ECh case    3:*/		return 0x822688F0;
	}
	return 0x822688F0;
} // Block from 822688E0h-822688F0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822688F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822688F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822688F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822688F0);
		  /* 822688F0h */ case    0:  		/* bl -1916776 */
		/* 822688F0h case    0:*/		regs.LR = 0x822688F4; return 0x82094988;
		/* 822688F0h case    0:*/		return 0x822688F4;
		  /* 822688F4h */ case    1:  		/* fmr FR31, FR1 */
		/* 822688F4h case    1:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR1);
		/* 822688F4h case    1:*/		return 0x822688F8;
	}
	return 0x822688F8;
} // Block from 822688F0h-822688F8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822688F8h
// Function 'atan'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822688F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822688F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822688F8);
		  /* 822688F8h */ case    0:  		/* b 48 */
		/* 822688F8h case    0:*/		return 0x82268928;
		/* 822688F8h case    0:*/		return 0x822688FC;
	}
	return 0x822688FC;
} // Block from 822688F8h-822688FCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 822688FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822688FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822688FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822688FC);
		  /* 822688FCh */ case    0:  		/* addi R4, R1, 80 */
		/* 822688FCh case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 822688FCh case    0:*/		return 0x82268900;
		  /* 82268900h */ case    1:  		/* bl 744 */
		/* 82268900h case    1:*/		regs.LR = 0x82268904; return 0x82268BE8;
		/* 82268900h case    1:*/		return 0x82268904;
		  /* 82268904h */ case    2:  		/* lwz R4, <#[R1 + 80]> */
		/* 82268904h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 82268904h case    2:*/		return 0x82268908;
		  /* 82268908h */ case    3:  		/* bl -1916800 */
		/* 82268908h case    3:*/		regs.LR = 0x8226890C; return 0x82094988;
		/* 82268908h case    3:*/		return 0x8226890C;
		  /* 8226890Ch */ case    4:  		/* lis R11, -32256 */
		/* 8226890Ch case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8226890Ch case    4:*/		return 0x82268910;
		  /* 82268910h */ case    5:  		/* lis R10, -32256 */
		/* 82268910h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 82268910h case    5:*/		return 0x82268914;
		  /* 82268914h */ case    6:  		/* lfd FR0, <#[R11 + 1848]> */
		/* 82268914h case    6:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000738) );
		/* 82268914h case    6:*/		return 0x82268918;
		  /* 82268918h */ case    7:  		/* fdiv FR0, FR0, FR1 */
		/* 82268918h case    7:*/		cpu::op::fdiv<0>(regs,&regs.FR0,regs.FR0,regs.FR1);
		/* 82268918h case    7:*/		return 0x8226891C;
		  /* 8226891Ch */ case    8:  		/* lfd FR13, <#[R10 + 4736]> */
		/* 8226891Ch case    8:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R10 + 0x00001280) );
		/* 8226891Ch case    8:*/		return 0x82268920;
		  /* 82268920h */ case    9:  		/* fadd FR0, FR0, FR1 */
		/* 82268920h case    9:*/		cpu::op::fadd<0>(regs,&regs.FR0,regs.FR0,regs.FR1);
		/* 82268920h case    9:*/		return 0x82268924;
		  /* 82268924h */ case   10:  		/* fmul FR31, FR0, FR13 */
		/* 82268924h case   10:*/		cpu::op::fmul<0>(regs,&regs.FR31,regs.FR0,regs.FR13);
		/* 82268924h case   10:*/		return 0x82268928;
	}
	return 0x82268928;
} // Block from 822688FCh-82268928h (11 instructions)

//////////////////////////////////////////////////////
// Block at 82268928h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268928( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268928) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268928);
		  /* 82268928h */ case    0:  		/* rlwinm. R11, R31, 0, 28, 28 */
		/* 82268928h case    0:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R31);
		/* 82268928h case    0:*/		return 0x8226892C;
		  /* 8226892Ch */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 8226892Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82268944;  }
		/* 8226892Ch case    1:*/		return 0x82268930;
		  /* 82268930h */ case    2:  		/* mr R4, R30 */
		/* 82268930h case    2:*/		regs.R4 = regs.R30;
		/* 82268930h case    2:*/		return 0x82268934;
		  /* 82268934h */ case    3:  		/* mr R3, R31 */
		/* 82268934h case    3:*/		regs.R3 = regs.R31;
		/* 82268934h case    3:*/		return 0x82268938;
		  /* 82268938h */ case    4:  		/* bl -1899128 */
		/* 82268938h case    4:*/		regs.LR = 0x8226893C; return 0x82098EC0;
		/* 82268938h case    4:*/		return 0x8226893C;
		  /* 8226893Ch */ case    5:  		/* fmr FR1, FR31 */
		/* 8226893Ch case    5:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 8226893Ch case    5:*/		return 0x82268940;
		  /* 82268940h */ case    6:  		/* b 28 */
		/* 82268940h case    6:*/		return 0x8226895C;
		/* 82268940h case    6:*/		return 0x82268944;
	}
	return 0x82268944;
} // Block from 82268928h-82268944h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82268944h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268944( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268944) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268944);
		  /* 82268944h */ case    0:  		/* fmr FR2, FR31 */
		/* 82268944h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR31);
		/* 82268944h case    0:*/		return 0x82268948;
		  /* 82268948h */ case    1:  		/* li R3, 16 */
		/* 82268948h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x10);
		/* 82268948h case    1:*/		return 0x8226894C;
	}
	return 0x8226894C;
} // Block from 82268944h-8226894Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226894Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226894C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226894C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226894C);
		  /* 8226894Ch */ case    0:  		/* mr R7, R31 */
		/* 8226894Ch case    0:*/		regs.R7 = regs.R31;
		/* 8226894Ch case    0:*/		return 0x82268950;
		  /* 82268950h */ case    1:  		/* fmr FR1, FR30 */
		/* 82268950h case    1:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR30);
		/* 82268950h case    1:*/		return 0x82268954;
		  /* 82268954h */ case    2:  		/* li R4, 19 */
		/* 82268954h case    2:*/		cpu::op::li<0>(regs,&regs.R4,0x13);
		/* 82268954h case    2:*/		return 0x82268958;
		  /* 82268958h */ case    3:  		/* bl -1899616 */
		/* 82268958h case    3:*/		regs.LR = 0x8226895C; return 0x82098CF8;
		/* 82268958h case    3:*/		return 0x8226895C;
	}
	return 0x8226895C;
} // Block from 8226894Ch-8226895Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226895Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226895C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226895C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226895C);
		  /* 8226895Ch */ case    0:  		/* addi R1, R1, 128 */
		/* 8226895Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8226895Ch case    0:*/		return 0x82268960;
		  /* 82268960h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82268960h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82268960h case    1:*/		return 0x82268964;
		  /* 82268964h */ case    2:  		/* mtspr LR, R12 */
		/* 82268964h case    2:*/		regs.LR = regs.R12;
		/* 82268964h case    2:*/		return 0x82268968;
		  /* 82268968h */ case    3:  		/* lfd FR30, <#[R1 - 40]> */
		/* 82268968h case    3:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R1 + 0xFFFFFFD8) );
		/* 82268968h case    3:*/		return 0x8226896C;
		  /* 8226896Ch */ case    4:  		/* lfd FR31, <#[R1 - 32]> */
		/* 8226896Ch case    4:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFE0) );
		/* 8226896Ch case    4:*/		return 0x82268970;
		  /* 82268970h */ case    5:  		/* ld R30, <#[R1 - 24]> */
		/* 82268970h case    5:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82268970h case    5:*/		return 0x82268974;
		  /* 82268974h */ case    6:  		/* ld R31, <#[R1 - 16]> */
		/* 82268974h case    6:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82268974h case    6:*/		return 0x82268978;
		  /* 82268978h */ case    7:  		/* bclr 20, CR0_LT */
		/* 82268978h case    7:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82268978h case    7:*/		return 0x8226897C;
	}
	return 0x8226897C;
} // Block from 8226895Ch-8226897Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8226897Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226897C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226897C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226897C);
		  /* 8226897Ch */ case    0:  		/* nop */
		/* 8226897Ch case    0:*/		cpu::op::nop();
		/* 8226897Ch case    0:*/		return 0x82268980;
	}
	return 0x82268980;
} // Block from 8226897Ch-82268980h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82268980h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268980( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268980) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268980);
		  /* 82268980h */ case    0:  		/* stfd FR1, <#[R1 + 16]> */
		/* 82268980h case    0:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000010) );
		/* 82268980h case    0:*/		return 0x82268984;
		  /* 82268984h */ case    1:  		/* lhz R11, <#[R1 + 16]> */
		/* 82268984h case    1:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000010) );
		/* 82268984h case    1:*/		return 0x82268988;
		  /* 82268988h */ case    2:  		/* rlwinm R11, R11, 0, 17, 27 */
		/* 82268988h case    2:*/		cpu::op::rlwinm<0,0,17,27>(regs,&regs.R11,regs.R11);
		/* 82268988h case    2:*/		return 0x8226898C;
		  /* 8226898Ch */ case    3:  		/* stfd FR2, <#[R1 + 24]> */
		/* 8226898Ch case    3:*/		cpu::mem::store64f( regs, regs.FR2, (uint32)(regs.R1 + 0x00000018) );
		/* 8226898Ch case    3:*/		return 0x82268990;
		  /* 82268990h */ case    4:  		/* cmplwi CR6, R11, 32752 */
		/* 82268990h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00007FF0);
		/* 82268990h case    4:*/		return 0x82268994;
		  /* 82268994h */ case    5:  		/* bc 4, CR6_EQ, 16 */
		/* 82268994h case    5:*/		if ( !regs.CR[6].eq ) { return 0x822689A4;  }
		/* 82268994h case    5:*/		return 0x82268998;
		  /* 82268998h */ case    6:  		/* lis R11, -32217 */
		/* 82268998h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 82268998h case    6:*/		return 0x8226899C;
		  /* 8226899Ch */ case    7:  		/* lfd FR1, <#[R11 + 7336]> */
		/* 8226899Ch case    7:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R11 + 0x00001CA8) );
		/* 8226899Ch case    7:*/		return 0x822689A0;
		  /* 822689A0h */ case    8:  		/* bclr 20, CR0_LT */
		/* 822689A0h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822689A0h case    8:*/		return 0x822689A4;
	}
	return 0x822689A4;
} // Block from 82268980h-822689A4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 822689A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822689A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822689A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822689A4);
		  /* 822689A4h */ case    0:  		/* lhz R11, <#[R1 + 24]> */
		/* 822689A4h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000018) );
		/* 822689A4h case    0:*/		return 0x822689A8;
		  /* 822689A8h */ case    1:  		/* rlwinm R11, R11, 0, 17, 27 */
		/* 822689A8h case    1:*/		cpu::op::rlwinm<0,0,17,27>(regs,&regs.R11,regs.R11);
		/* 822689A8h case    1:*/		return 0x822689AC;
		  /* 822689ACh */ case    2:  		/* cmplwi CR6, R11, 32752 */
		/* 822689ACh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00007FF0);
		/* 822689ACh case    2:*/		return 0x822689B0;
		  /* 822689B0h */ case    3:  		/* bc 4, CR6_EQ, 56 */
		/* 822689B0h case    3:*/		if ( !regs.CR[6].eq ) { return 0x822689E8;  }
		/* 822689B0h case    3:*/		return 0x822689B4;
		  /* 822689B4h */ case    4:  		/* lwz R11, <#[R1 + 24]> */
		/* 822689B4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000018) );
		/* 822689B4h case    4:*/		return 0x822689B8;
		  /* 822689B8h */ case    5:  		/* lis R9, 32752 */
		/* 822689B8h case    5:*/		cpu::op::lis<0>(regs,&regs.R9,0x7FF0);
		/* 822689B8h case    5:*/		return 0x822689BC;
		  /* 822689BCh */ case    6:  		/* lwz R10, <#[R1 + 28]> */
		/* 822689BCh case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x0000001C) );
		/* 822689BCh case    6:*/		return 0x822689C0;
		  /* 822689C0h */ case    7:  		/* cmplw CR6, R11, R9 */
		/* 822689C0h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 822689C0h case    7:*/		return 0x822689C4;
		  /* 822689C4h */ case    8:  		/* bc 4, CR6_EQ, 12 */
		/* 822689C4h case    8:*/		if ( !regs.CR[6].eq ) { return 0x822689D0;  }
		/* 822689C4h case    8:*/		return 0x822689C8;
		  /* 822689C8h */ case    9:  		/* cmplwi CR6, R10, 0 */
		/* 822689C8h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 822689C8h case    9:*/		return 0x822689CC;
		  /* 822689CCh */ case   10:  		/* bclr 12, CR6_EQ */
		/* 822689CCh case   10:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 822689CCh case   10:*/		return 0x822689D0;
	}
	return 0x822689D0;
} // Block from 822689A4h-822689D0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 822689D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822689D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822689D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822689D0);
		  /* 822689D0h */ case    0:  		/* lis R9, -16 */
		/* 822689D0h case    0:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFFFFF0);
		/* 822689D0h case    0:*/		return 0x822689D4;
		  /* 822689D4h */ case    1:  		/* cmplw CR6, R11, R9 */
		/* 822689D4h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 822689D4h case    1:*/		return 0x822689D8;
		  /* 822689D8h */ case    2:  		/* bc 4, CR6_EQ, -64 */
		/* 822689D8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82268998;  }
		/* 822689D8h case    2:*/		return 0x822689DC;
		  /* 822689DCh */ case    3:  		/* cmplwi CR6, R10, 0 */
		/* 822689DCh case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 822689DCh case    3:*/		return 0x822689E0;
	}
	return 0x822689E0;
} // Block from 822689D0h-822689E0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822689E0h
// Function 'atan2'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822689E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822689E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822689E0);
		  /* 822689E0h */ case    0:  		/* bclr 12, CR6_EQ */
		/* 822689E0h case    0:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 822689E0h case    0:*/		return 0x822689E4;
	}
	return 0x822689E4;
} // Block from 822689E0h-822689E4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822689E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822689E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822689E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822689E4);
		  /* 822689E4h */ case    0:  		/* b -76 */
		/* 822689E4h case    0:*/		return 0x82268998;
		/* 822689E4h case    0:*/		return 0x822689E8;
	}
	return 0x822689E8;
} // Block from 822689E4h-822689E8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822689E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822689E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822689E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822689E8);
		  /* 822689E8h */ case    0:  		/* ld R10, <#[R1 + 24]> */
		/* 822689E8h case    0:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R1 + 0x00000018) );
		/* 822689E8h case    0:*/		return 0x822689EC;
		  /* 822689ECh */ case    1:  		/* ld R9, <#[R1 + 16]> */
		/* 822689ECh case    1:*/		cpu::mem::load64( regs, &regs.R9, (uint32)(regs.R1 + 0x00000010) );
		/* 822689ECh case    1:*/		return 0x822689F0;
		  /* 822689F0h */ case    2:  		/* rldicl R11, R10, 0, 1 */
		/* 822689F0h case    2:*/		cpu::op::rldicl<0,0,1>(regs,&regs.R11,regs.R10);
		/* 822689F0h case    2:*/		return 0x822689F4;
		  /* 822689F4h */ case    3:  		/* rldicl R8, R9, 0, 1 */
		/* 822689F4h case    3:*/		cpu::op::rldicl<0,0,1>(regs,&regs.R8,regs.R9);
		/* 822689F4h case    3:*/		return 0x822689F8;
		  /* 822689F8h */ case    4:  		/* cmpld CR6, R8, R11 */
		/* 822689F8h case    4:*/		cpu::op::cmpld<6>(regs,regs.R8,regs.R11);
		/* 822689F8h case    4:*/		return 0x822689FC;
		  /* 822689FCh */ case    5:  		/* bclr 12, CR6_LT */
		/* 822689FCh case    5:*/		if ( regs.CR[6].lt ) { return (uint32)regs.LR; }
		/* 822689FCh case    5:*/		return 0x82268A00;
	}
	return 0x82268A00;
} // Block from 822689E8h-82268A00h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82268A00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268A00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268A00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268A00);
		  /* 82268A00h */ case    0:  		/* rldicl R8, R10, 12, 53 */
		/* 82268A00h case    0:*/		cpu::op::rldicl<0,12,53>(regs,&regs.R8,regs.R10);
		/* 82268A00h case    0:*/		return 0x82268A04;
		  /* 82268A04h */ case    1:  		/* li R11, 1 */
		/* 82268A04h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82268A04h case    1:*/		return 0x82268A08;
		  /* 82268A08h */ case    2:  		/* rldicr R5, R9, 0, 0 */
		/* 82268A08h case    2:*/		cpu::op::rldicr<0,0,0>(regs,&regs.R5,regs.R9);
		/* 82268A08h case    2:*/		return 0x82268A0C;
		  /* 82268A0Ch */ case    3:  		/* rldicl R10, R10, 11, 1 */
		/* 82268A0Ch case    3:*/		cpu::op::rldicl<0,11,1>(regs,&regs.R10,regs.R10);
		/* 82268A0Ch case    3:*/		return 0x82268A10;
		  /* 82268A10h */ case    4:  		/* rldicr R7, R11, 63, 63 */
		/* 82268A10h case    4:*/		cpu::op::rldicr<0,63,63>(regs,&regs.R7,regs.R11);
		/* 82268A10h case    4:*/		return 0x82268A14;
		  /* 82268A14h */ case    5:  		/* std R5, <#[R1 - 16]> */
		/* 82268A14h case    5:*/		cpu::mem::store64( regs, regs.R5, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82268A14h case    5:*/		return 0x82268A18;
		  /* 82268A18h */ case    6:  		/* rldicl R11, R9, 12, 53 */
		/* 82268A18h case    6:*/		cpu::op::rldicl<0,12,53>(regs,&regs.R11,regs.R9);
		/* 82268A18h case    6:*/		return 0x82268A1C;
		  /* 82268A1Ch */ case    7:  		/* rldicr R10, R10, 0, 52 */
		/* 82268A1Ch case    7:*/		cpu::op::rldicr<0,0,52>(regs,&regs.R10,regs.R10);
		/* 82268A1Ch case    7:*/		return 0x82268A20;
		  /* 82268A20h */ case    8:  		/* cmpdi CR6, R8, 0 */
		/* 82268A20h case    8:*/		cpu::op::cmpdi<6>(regs,regs.R8,0x00000000);
		/* 82268A20h case    8:*/		return 0x82268A24;
		  /* 82268A24h */ case    9:  		/* bc 4, CR6_EQ, 32 */
		/* 82268A24h case    9:*/		if ( !regs.CR[6].eq ) { return 0x82268A44;  }
		/* 82268A24h case    9:*/		return 0x82268A28;
		  /* 82268A28h */ case   10:  		/* cmpldi CR6, R10, 0 */
		/* 82268A28h case   10:*/		cpu::op::cmpldi<6>(regs,regs.R10,0x00000000);
		/* 82268A28h case   10:*/		return 0x82268A2C;
		  /* 82268A2Ch */ case   11:  		/* bc 12, CR6_EQ, -148 */
		/* 82268A2Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x82268998;  }
		/* 82268A2Ch case   11:*/		return 0x82268A30;
		  /* 82268A30h */ case   12:  		/* cntlzd R8, R10 */
		/* 82268A30h case   12:*/		cpu::op::cntlzd<0>(regs,&regs.R8,regs.R10);
		/* 82268A30h case   12:*/		return 0x82268A34;
		  /* 82268A34h */ case   13:  		/* extsw R8, R8 */
		/* 82268A34h case   13:*/		cpu::op::extsw<0>(regs,&regs.R8,regs.R8);
		/* 82268A34h case   13:*/		return 0x82268A38;
		  /* 82268A38h */ case   14:  		/* sld R6, R10, R8 */
		/* 82268A38h case   14:*/		cpu::op::sld<0>(regs,&regs.R6,regs.R10,regs.R8);
		/* 82268A38h case   14:*/		return 0x82268A3C;
		  /* 82268A3Ch */ case   15:  		/* subfic R8, R8, 1 */
		/* 82268A3Ch case   15:*/		cpu::op::subfic<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82268A3Ch case   15:*/		return 0x82268A40;
		  /* 82268A40h */ case   16:  		/* b 8 */
		/* 82268A40h case   16:*/		return 0x82268A48;
		/* 82268A40h case   16:*/		return 0x82268A44;
	}
	return 0x82268A44;
} // Block from 82268A00h-82268A44h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82268A44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268A44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268A44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268A44);
		  /* 82268A44h */ case    0:  		/* or R6, R10, R7 */
		/* 82268A44h case    0:*/		cpu::op::or<0>(regs,&regs.R6,regs.R10,regs.R7);
		/* 82268A44h case    0:*/		return 0x82268A48;
	}
	return 0x82268A48;
} // Block from 82268A44h-82268A48h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82268A48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268A48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268A48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268A48);
		  /* 82268A48h */ case    0:  		/* li R10, 0 */
		/* 82268A48h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82268A48h case    0:*/		return 0x82268A4C;
		  /* 82268A4Ch */ case    1:  		/* cmpdi CR6, R11, 0 */
		/* 82268A4Ch case    1:*/		cpu::op::cmpdi<6>(regs,regs.R11,0x00000000);
		/* 82268A4Ch case    1:*/		return 0x82268A50;
		  /* 82268A50h */ case    2:  		/* rldimi R10, R9, 11, 1 */
		/* 82268A50h case    2:*/		cpu::op::rldimi<0,11,1>(regs,&regs.R10,regs.R9);
		/* 82268A50h case    2:*/		return 0x82268A54;
		  /* 82268A54h */ case    3:  		/* bc 4, CR6_EQ, 32 */
		/* 82268A54h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82268A74;  }
		/* 82268A54h case    3:*/		return 0x82268A58;
		  /* 82268A58h */ case    4:  		/* cmpldi CR6, R10, 0 */
		/* 82268A58h case    4:*/		cpu::op::cmpldi<6>(regs,regs.R10,0x00000000);
		/* 82268A58h case    4:*/		return 0x82268A5C;
		  /* 82268A5Ch */ case    5:  		/* bclr 12, CR6_EQ */
		/* 82268A5Ch case    5:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 82268A5Ch case    5:*/		return 0x82268A60;
	}
	return 0x82268A60;
} // Block from 82268A48h-82268A60h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82268A60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268A60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268A60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268A60);
		  /* 82268A60h */ case    0:  		/* cntlzd R11, R10 */
		/* 82268A60h case    0:*/		cpu::op::cntlzd<0>(regs,&regs.R11,regs.R10);
		/* 82268A60h case    0:*/		return 0x82268A64;
		  /* 82268A64h */ case    1:  		/* extsw R11, R11 */
		/* 82268A64h case    1:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R11);
		/* 82268A64h case    1:*/		return 0x82268A68;
		  /* 82268A68h */ case    2:  		/* sld R10, R10, R11 */
		/* 82268A68h case    2:*/		cpu::op::sld<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 82268A68h case    2:*/		return 0x82268A6C;
		  /* 82268A6Ch */ case    3:  		/* subfic R11, R11, 1 */
		/* 82268A6Ch case    3:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82268A6Ch case    3:*/		return 0x82268A70;
		  /* 82268A70h */ case    4:  		/* b 8 */
		/* 82268A70h case    4:*/		return 0x82268A78;
		/* 82268A70h case    4:*/		return 0x82268A74;
	}
	return 0x82268A74;
} // Block from 82268A60h-82268A74h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82268A74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268A74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268A74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268A74);
		  /* 82268A74h */ case    0:  		/* or R10, R10, R7 */
		/* 82268A74h case    0:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R7);
		/* 82268A74h case    0:*/		return 0x82268A78;
	}
	return 0x82268A78;
} // Block from 82268A74h-82268A78h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82268A78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268A78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268A78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268A78);
		  /* 82268A78h */ case    0:  		/* rldicl R7, R6, 63, 1 */
		/* 82268A78h case    0:*/		cpu::op::rldicl<0,63,1>(regs,&regs.R7,regs.R6);
		/* 82268A78h case    0:*/		return 0x82268A7C;
		  /* 82268A7Ch */ case    1:  		/* b 40 */
		/* 82268A7Ch case    1:*/		return 0x82268AA4;
		/* 82268A7Ch case    1:*/		return 0x82268A80;
		  /* 82268A80h */ case    2:  		/* cmpld CR6, R10, R6 */
		/* 82268A80h case    2:*/		cpu::op::cmpld<6>(regs,regs.R10,regs.R6);
		/* 82268A80h case    2:*/		return 0x82268A84;
		  /* 82268A84h */ case    3:  		/* mr R9, R6 */
		/* 82268A84h case    3:*/		regs.R9 = regs.R6;
		/* 82268A84h case    3:*/		return 0x82268A88;
		  /* 82268A88h */ case    4:  		/* bc 4, CR6_LT, 8 */
		/* 82268A88h case    4:*/		if ( !regs.CR[6].lt ) { return 0x82268A90;  }
		/* 82268A88h case    4:*/		return 0x82268A8C;
		  /* 82268A8Ch */ case    5:  		/* mr R9, R7 */
		/* 82268A8Ch case    5:*/		regs.R9 = regs.R7;
		/* 82268A8Ch case    5:*/		return 0x82268A90;
	}
	return 0x82268A90;
} // Block from 82268A78h-82268A90h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82268A90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268A90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268A90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268A90);
		  /* 82268A90h */ case    0:  		/* subf R10, R9, R10 */
		/* 82268A90h case    0:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82268A90h case    0:*/		return 0x82268A94;
		  /* 82268A94h */ case    1:  		/* cntlzd R9, R10 */
		/* 82268A94h case    1:*/		cpu::op::cntlzd<0>(regs,&regs.R9,regs.R10);
		/* 82268A94h case    1:*/		return 0x82268A98;
		  /* 82268A98h */ case    2:  		/* extsw R9, R9 */
		/* 82268A98h case    2:*/		cpu::op::extsw<0>(regs,&regs.R9,regs.R9);
		/* 82268A98h case    2:*/		return 0x82268A9C;
		  /* 82268A9Ch */ case    3:  		/* subf R11, R9, R11 */
		/* 82268A9Ch case    3:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82268A9Ch case    3:*/		return 0x82268AA0;
		  /* 82268AA0h */ case    4:  		/* sld R10, R10, R9 */
		/* 82268AA0h case    4:*/		cpu::op::sld<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82268AA0h case    4:*/		return 0x82268AA4;
	}
	return 0x82268AA4;
} // Block from 82268A90h-82268AA4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82268AA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268AA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268AA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268AA4);
		  /* 82268AA4h */ case    0:  		/* cmpd CR6, R11, R8 */
		/* 82268AA4h case    0:*/		cpu::op::cmpd<6>(regs,regs.R11,regs.R8);
		/* 82268AA4h case    0:*/		return 0x82268AA8;
		  /* 82268AA8h */ case    1:  		/* bc 12, CR6_GT, -40 */
		/* 82268AA8h case    1:*/		if ( regs.CR[6].gt ) { return 0x82268A80;  }
		/* 82268AA8h case    1:*/		return 0x82268AAC;
		  /* 82268AACh */ case    2:  		/* bc 4, CR6_EQ, 32 */
		/* 82268AACh case    2:*/		if ( !regs.CR[6].eq ) { return 0x82268ACC;  }
		/* 82268AACh case    2:*/		return 0x82268AB0;
		  /* 82268AB0h */ case    3:  		/* cmpld CR6, R10, R6 */
		/* 82268AB0h case    3:*/		cpu::op::cmpld<6>(regs,regs.R10,regs.R6);
		/* 82268AB0h case    3:*/		return 0x82268AB4;
		  /* 82268AB4h */ case    4:  		/* bc 12, CR6_LT, 24 */
		/* 82268AB4h case    4:*/		if ( regs.CR[6].lt ) { return 0x82268ACC;  }
		/* 82268AB4h case    4:*/		return 0x82268AB8;
		  /* 82268AB8h */ case    5:  		/* subf R10, R6, R10 */
		/* 82268AB8h case    5:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R6,regs.R10);
		/* 82268AB8h case    5:*/		return 0x82268ABC;
		  /* 82268ABCh */ case    6:  		/* cntlzd R9, R10 */
		/* 82268ABCh case    6:*/		cpu::op::cntlzd<0>(regs,&regs.R9,regs.R10);
		/* 82268ABCh case    6:*/		return 0x82268AC0;
		  /* 82268AC0h */ case    7:  		/* extsw R9, R9 */
		/* 82268AC0h case    7:*/		cpu::op::extsw<0>(regs,&regs.R9,regs.R9);
		/* 82268AC0h case    7:*/		return 0x82268AC4;
		  /* 82268AC4h */ case    8:  		/* sld R10, R10, R9 */
		/* 82268AC4h case    8:*/		cpu::op::sld<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82268AC4h case    8:*/		return 0x82268AC8;
		  /* 82268AC8h */ case    9:  		/* subf R11, R9, R11 */
		/* 82268AC8h case    9:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 82268AC8h case    9:*/		return 0x82268ACC;
	}
	return 0x82268ACC;
} // Block from 82268AA4h-82268ACCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 82268ACCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268ACC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268ACC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268ACC);
		  /* 82268ACCh */ case    0:  		/* cmpldi CR6, R10, 0 */
		/* 82268ACCh case    0:*/		cpu::op::cmpldi<6>(regs,regs.R10,0x00000000);
		/* 82268ACCh case    0:*/		return 0x82268AD0;
		  /* 82268AD0h */ case    1:  		/* bc 12, CR6_EQ, 44 */
		/* 82268AD0h case    1:*/		if ( regs.CR[6].eq ) { return 0x82268AFC;  }
		/* 82268AD0h case    1:*/		return 0x82268AD4;
		  /* 82268AD4h */ case    2:  		/* cmpdi CR6, R11, 0 */
		/* 82268AD4h case    2:*/		cpu::op::cmpdi<6>(regs,regs.R11,0x00000000);
		/* 82268AD4h case    2:*/		return 0x82268AD8;
		  /* 82268AD8h */ case    3:  		/* bc 12, CR6_GT, 16 */
		/* 82268AD8h case    3:*/		if ( regs.CR[6].gt ) { return 0x82268AE8;  }
		/* 82268AD8h case    3:*/		return 0x82268ADC;
		  /* 82268ADCh */ case    4:  		/* subfic R9, R11, 1 */
		/* 82268ADCh case    4:*/		cpu::op::subfic<0>(regs,&regs.R9,regs.R11,0x1);
		/* 82268ADCh case    4:*/		return 0x82268AE0;
		  /* 82268AE0h */ case    5:  		/* li R11, 0 */
		/* 82268AE0h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82268AE0h case    5:*/		return 0x82268AE4;
		  /* 82268AE4h */ case    6:  		/* srd R10, R10, R9 */
		/* 82268AE4h case    6:*/		cpu::op::srd<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 82268AE4h case    6:*/		return 0x82268AE8;
	}
	return 0x82268AE8;
} // Block from 82268ACCh-82268AE8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82268AE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268AE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268AE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268AE8);
		  /* 82268AE8h */ case    0:  		/* rldicr R11, R11, 52, 11 */
		/* 82268AE8h case    0:*/		cpu::op::rldicr<0,52,11>(regs,&regs.R11,regs.R11);
		/* 82268AE8h case    0:*/		return 0x82268AEC;
		  /* 82268AECh */ case    1:  		/* rldicl R10, R10, 53, 12 */
		/* 82268AECh case    1:*/		cpu::op::rldicl<0,53,12>(regs,&regs.R10,regs.R10);
		/* 82268AECh case    1:*/		return 0x82268AF0;
		  /* 82268AF0h */ case    2:  		/* add R11, R10, R11 */
		/* 82268AF0h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82268AF0h case    2:*/		return 0x82268AF4;
		  /* 82268AF4h */ case    3:  		/* add R11, R11, R5 */
		/* 82268AF4h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R5);
		/* 82268AF4h case    3:*/		return 0x82268AF8;
		  /* 82268AF8h */ case    4:  		/* std R11, <#[R1 - 16]> */
		/* 82268AF8h case    4:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82268AF8h case    4:*/		return 0x82268AFC;
	}
	return 0x82268AFC;
} // Block from 82268AE8h-82268AFCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 82268AFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268AFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268AFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268AFC);
		  /* 82268AFCh */ case    0:  		/* lfd FR1, <#[R1 - 16]> */
		/* 82268AFCh case    0:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82268AFCh case    0:*/		return 0x82268B00;
		  /* 82268B00h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82268B00h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82268B00h case    1:*/		return 0x82268B04;
	}
	return 0x82268B04;
} // Block from 82268AFCh-82268B04h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82268B04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268B04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268B04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268B04);
		  /* 82268B04h */ case    0:  		/* nop */
		/* 82268B04h case    0:*/		cpu::op::nop();
		/* 82268B04h case    0:*/		return 0x82268B08;
	}
	return 0x82268B08;
} // Block from 82268B04h-82268B08h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82268B08h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268B08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268B08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268B08);
		  /* 82268B08h */ case    0:  		/* lis R11, -32216 */
		/* 82268B08h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 82268B08h case    0:*/		return 0x82268B0C;
		  /* 82268B0Ch */ case    1:  		/* addi R11, R11, 27512 */
		/* 82268B0Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6B78);
		/* 82268B0Ch case    1:*/		return 0x82268B10;
	}
	return 0x82268B10;
} // Block from 82268B08h-82268B10h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82268B10h
// Function '_asincos'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268B10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268B10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268B10);
		  /* 82268B10h */ case    0:  		/* lfd FR0, <#[R11 + 32]> */
		/* 82268B10h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000020) );
		/* 82268B10h case    0:*/		return 0x82268B14;
		  /* 82268B14h */ case    1:  		/* fmul FR5, FR0, FR1 */
		/* 82268B14h case    1:*/		cpu::op::fmul<0>(regs,&regs.FR5,regs.FR0,regs.FR1);
		/* 82268B14h case    1:*/		return 0x82268B18;
		  /* 82268B18h */ case    2:  		/* lfd FR13, <#[R11 + 40]> */
		/* 82268B18h case    2:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000028) );
		/* 82268B18h case    2:*/		return 0x82268B1C;
		  /* 82268B1Ch */ case    3:  		/* lfd FR12, <#[R11 + 48]> */
		/* 82268B1Ch case    3:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R11 + 0x00000030) );
		/* 82268B1Ch case    3:*/		return 0x82268B20;
		  /* 82268B20h */ case    4:  		/* lfd FR10, <#[R11 + 64]> */
		/* 82268B20h case    4:*/		cpu::mem::load64f( regs, &regs.FR10, (uint32)(regs.R11 + 0x00000040) );
		/* 82268B20h case    4:*/		return 0x82268B24;
		  /* 82268B24h */ case    5:  		/* lfd FR11, <#[R11 + 72]> */
		/* 82268B24h case    5:*/		cpu::mem::load64f( regs, &regs.FR11, (uint32)(regs.R11 + 0x00000048) );
		/* 82268B24h case    5:*/		return 0x82268B28;
		  /* 82268B28h */ case    6:  		/* lfd FR9, <#[R11 + 96]> */
		/* 82268B28h case    6:*/		cpu::mem::load64f( regs, &regs.FR9, (uint32)(regs.R11 + 0x00000060) );
		/* 82268B28h case    6:*/		return 0x82268B2C;
		  /* 82268B2Ch */ case    7:  		/* lfd FR8, <#[R11 + 88]> */
		/* 82268B2Ch case    7:*/		cpu::mem::load64f( regs, &regs.FR8, (uint32)(regs.R11 + 0x00000058) );
		/* 82268B2Ch case    7:*/		return 0x82268B30;
		  /* 82268B30h */ case    8:  		/* lfd FR7, <#[R11 + 56]> */
		/* 82268B30h case    8:*/		cpu::mem::load64f( regs, &regs.FR7, (uint32)(regs.R11 + 0x00000038) );
		/* 82268B30h case    8:*/		return 0x82268B34;
		  /* 82268B34h */ case    9:  		/* lfd FR6, <#[R11 + 80]> */
		/* 82268B34h case    9:*/		cpu::mem::load64f( regs, &regs.FR6, (uint32)(regs.R11 + 0x00000050) );
		/* 82268B34h case    9:*/		return 0x82268B38;
		  /* 82268B38h */ case   10:  		/* lfs FR0, <#[R11 + 108]> */
		/* 82268B38h case   10:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R11 + 0x0000006C) );
		/* 82268B38h case   10:*/		return 0x82268B3C;
		  /* 82268B3Ch */ case   11:  		/* fctid FR5, FR5 */
		/* 82268B3Ch case   11:*/		cpu::op::fctid<0>(regs,&regs.FR5,regs.FR5);
		/* 82268B3Ch case   11:*/		return 0x82268B40;
		  /* 82268B40h */ case   12:  		/* fcfid FR5, FR5 */
		/* 82268B40h case   12:*/		cpu::op::fcfid<0>(regs,&regs.FR5,regs.FR5);
		/* 82268B40h case   12:*/		return 0x82268B44;
		  /* 82268B44h */ case   13:  		/* fnmsub FR13, FR13, FR5, FR1 */
		/* 82268B44h case   13:*/		cpu::op::fnmsub<0>(regs,&regs.FR13,regs.FR13,regs.FR5,regs.FR1);
		/* 82268B44h case   13:*/		return 0x82268B48;
		  /* 82268B48h */ case   14:  		/* fctiwz FR4, FR5 */
		/* 82268B48h case   14:*/		cpu::op::fctiwz<0>(regs,&regs.FR4,regs.FR5);
		/* 82268B48h case   14:*/		return 0x82268B4C;
		  /* 82268B4Ch */ case   15:  		/* stfd FR4, <#[R1 - 16]> */
		/* 82268B4Ch case   15:*/		cpu::mem::store64f( regs, regs.FR4, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82268B4Ch case   15:*/		return 0x82268B50;
		  /* 82268B50h */ case   16:  		/* lwz R10, <#[R1 - 12]> */
		/* 82268B50h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0xFFFFFFF4) );
		/* 82268B50h case   16:*/		return 0x82268B54;
		  /* 82268B54h */ case   17:  		/* addic. R10, R10, 1 */
		/* 82268B54h case   17:*/		cpu::op::addic<1>(regs,&regs.R10,regs.R10,0x1);
		/* 82268B54h case   17:*/		return 0x82268B58;
		  /* 82268B58h */ case   18:  		/* fnmsub FR13, FR12, FR5, FR13 */
		/* 82268B58h case   18:*/		cpu::op::fnmsub<0>(regs,&regs.FR13,regs.FR12,regs.FR5,regs.FR13);
		/* 82268B58h case   18:*/		return 0x82268B5C;
		  /* 82268B5Ch */ case   19:  		/* fmul FR12, FR13, FR13 */
		/* 82268B5Ch case   19:*/		cpu::op::fmul<0>(regs,&regs.FR12,regs.FR13,regs.FR13);
		/* 82268B5Ch case   19:*/		return 0x82268B60;
		  /* 82268B60h */ case   20:  		/* fmadd FR11, FR11, FR12, FR10 */
		/* 82268B60h case   20:*/		cpu::op::fmadd<0>(regs,&regs.FR11,regs.FR11,regs.FR12,regs.FR10);
		/* 82268B60h case   20:*/		return 0x82268B64;
		  /* 82268B64h */ case   21:  		/* fmadd FR10, FR9, FR12, FR8 */
		/* 82268B64h case   21:*/		cpu::op::fmadd<0>(regs,&regs.FR10,regs.FR9,regs.FR12,regs.FR8);
		/* 82268B64h case   21:*/		return 0x82268B68;
		  /* 82268B68h */ case   22:  		/* fmadd FR11, FR11, FR12, FR7 */
		/* 82268B68h case   22:*/		cpu::op::fmadd<0>(regs,&regs.FR11,regs.FR11,regs.FR12,regs.FR7);
		/* 82268B68h case   22:*/		return 0x82268B6C;
		  /* 82268B6Ch */ case   23:  		/* fmadd FR12, FR10, FR12, FR6 */
		/* 82268B6Ch case   23:*/		cpu::op::fmadd<0>(regs,&regs.FR12,regs.FR10,regs.FR12,regs.FR6);
		/* 82268B6Ch case   23:*/		return 0x82268B70;
		  /* 82268B70h */ case   24:  		/* fmul FR13, FR11, FR13 */
		/* 82268B70h case   24:*/		cpu::op::fmul<0>(regs,&regs.FR13,regs.FR11,regs.FR13);
		/* 82268B70h case   24:*/		return 0x82268B74;
		  /* 82268B74h */ case   25:  		/* fsub FR12, FR12, FR13 */
		/* 82268B74h case   25:*/		cpu::op::fsub<0>(regs,&regs.FR12,regs.FR12,regs.FR13);
		/* 82268B74h case   25:*/		return 0x82268B78;
		  /* 82268B78h */ case   26:  		/* fdiv FR13, FR13, FR12 */
		/* 82268B78h case   26:*/		cpu::op::fdiv<0>(regs,&regs.FR13,regs.FR13,regs.FR12);
		/* 82268B78h case   26:*/		return 0x82268B7C;
		  /* 82268B7Ch */ case   27:  		/* fadd FR0, FR13, FR0 */
		/* 82268B7Ch case   27:*/		cpu::op::fadd<0>(regs,&regs.FR0,regs.FR13,regs.FR0);
		/* 82268B7Ch case   27:*/		return 0x82268B80;
		  /* 82268B80h */ case   28:  		/* bc 12, CR0_EQ, 64 */
		/* 82268B80h case   28:*/		if ( regs.CR[0].eq ) { return 0x82268BC0;  }
		/* 82268B80h case   28:*/		return 0x82268B84;
		  /* 82268B84h */ case   29:  		/* stfd FR0, <#[R1 - 16]> */
		/* 82268B84h case   29:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82268B84h case   29:*/		return 0x82268B88;
		  /* 82268B88h */ case   30:  		/* lhz R8, <#[R1 - 16]> */
		/* 82268B88h case   30:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82268B88h case   30:*/		return 0x82268B8C;
		  /* 82268B8Ch */ case   31:  		/* stfd FR0, <#[R1 - 16]> */
		/* 82268B8Ch case   31:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82268B8Ch case   31:*/		return 0x82268B90;
		  /* 82268B90h */ case   32:  		/* lhz R9, <#[R1 - 16]> */
		/* 82268B90h case   32:*/		cpu::mem::load16z( regs, &regs.R9, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82268B90h case   32:*/		return 0x82268B94;
		  /* 82268B94h */ case   33:  		/* andi. R8, R8, 32783 */
		/* 82268B94h case   33:*/		cpu::op::andi<1>(regs,&regs.R8,regs.R8,0x800F);
		/* 82268B94h case   33:*/		return 0x82268B98;
		  /* 82268B98h */ case   34:  		/* stfd FR0, <#[R1 - 16]> */
		/* 82268B98h case   34:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82268B98h case   34:*/		return 0x82268B9C;
		  /* 82268B9Ch */ case   35:  		/* rlwinm R9, R9, 28, 21, 31 */
		/* 82268B9Ch case   35:*/		cpu::op::rlwinm<0,28,21,31>(regs,&regs.R9,regs.R9);
		/* 82268B9Ch case   35:*/		return 0x82268BA0;
		  /* 82268BA0h */ case   36:  		/* addi R9, R9, -1022 */
		/* 82268BA0h case   36:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFC02);
		/* 82268BA0h case   36:*/		return 0x82268BA4;
		  /* 82268BA4h */ case   37:  		/* extsh R9, R9 */
		/* 82268BA4h case   37:*/		cpu::op::extsh<0>(regs,&regs.R9,regs.R9);
		/* 82268BA4h case   37:*/		return 0x82268BA8;
		  /* 82268BA8h */ case   38:  		/* add R10, R9, R10 */
		/* 82268BA8h case   38:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 82268BA8h case   38:*/		return 0x82268BAC;
		  /* 82268BACh */ case   39:  		/* addi R10, R10, 1022 */
		/* 82268BACh case   39:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x3FE);
		/* 82268BACh case   39:*/		return 0x82268BB0;
		  /* 82268BB0h */ case   40:  		/* rlwinm R10, R10, 4, 0, 27 */
		/* 82268BB0h case   40:*/		cpu::op::rlwinm<0,4,0,27>(regs,&regs.R10,regs.R10);
		/* 82268BB0h case   40:*/		return 0x82268BB4;
		  /* 82268BB4h */ case   41:  		/* or R10, R10, R8 */
		/* 82268BB4h case   41:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 82268BB4h case   41:*/		return 0x82268BB8;
		  /* 82268BB8h */ case   42:  		/* sth R10, <#[R1 - 16]> */
		/* 82268BB8h case   42:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82268BB8h case   42:*/		return 0x82268BBC;
		  /* 82268BBCh */ case   43:  		/* lfd FR0, <#[R1 - 16]> */
		/* 82268BBCh case   43:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82268BBCh case   43:*/		return 0x82268BC0;
	}
	return 0x82268BC0;
} // Block from 82268B10h-82268BC0h (44 instructions)

//////////////////////////////////////////////////////
// Block at 82268BC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268BC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268BC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268BC0);
		  /* 82268BC0h */ case    0:  		/* lfd FR13, <#[R11]> */
		/* 82268BC0h case    0:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000000) );
		/* 82268BC0h case    0:*/		return 0x82268BC4;
		  /* 82268BC4h */ case    1:  		/* fsub FR11, FR1, FR13 */
		/* 82268BC4h case    1:*/		cpu::op::fsub<0>(regs,&regs.FR11,regs.FR1,regs.FR13);
		/* 82268BC4h case    1:*/		return 0x82268BC8;
		  /* 82268BC8h */ case    2:  		/* lfd FR13, <#[R11 + 8]> */
		/* 82268BC8h case    2:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000008) );
		/* 82268BC8h case    2:*/		return 0x82268BCC;
		  /* 82268BCCh */ case    3:  		/* lfd FR12, <#[R11 + 16]> */
		/* 82268BCCh case    3:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R11 + 0x00000010) );
		/* 82268BCCh case    3:*/		return 0x82268BD0;
		  /* 82268BD0h */ case    4:  		/* fsub FR10, FR13, FR1 */
		/* 82268BD0h case    4:*/		cpu::op::fsub<0>(regs,&regs.FR10,regs.FR13,regs.FR1);
		/* 82268BD0h case    4:*/		return 0x82268BD4;
		  /* 82268BD4h */ case    5:  		/* lfs FR13, <#[R11 + 104]> */
		/* 82268BD4h case    5:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R11 + 0x00000068) );
		/* 82268BD4h case    5:*/		return 0x82268BD8;
		  /* 82268BD8h */ case    6:  		/* fsel FR0, FR11, FR12, FR0 */
		/* 82268BD8h case    6:*/		cpu::op::fsel<0>(regs,&regs.FR0,regs.FR11,regs.FR12,regs.FR0);
		/* 82268BD8h case    6:*/		return 0x82268BDC;
		  /* 82268BDCh */ case    7:  		/* fsel FR1, FR10, FR13, FR0 */
		/* 82268BDCh case    7:*/		cpu::op::fsel<0>(regs,&regs.FR1,regs.FR10,regs.FR13,regs.FR0);
		/* 82268BDCh case    7:*/		return 0x82268BE0;
		  /* 82268BE0h */ case    8:  		/* bclr 20, CR0_LT */
		/* 82268BE0h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82268BE0h case    8:*/		return 0x82268BE4;
	}
	return 0x82268BE4;
} // Block from 82268BC0h-82268BE4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82268BE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268BE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268BE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268BE4);
		  /* 82268BE4h */ case    0:  		/* nop */
		/* 82268BE4h case    0:*/		cpu::op::nop();
		/* 82268BE4h case    0:*/		return 0x82268BE8;
	}
	return 0x82268BE8;
} // Block from 82268BE4h-82268BE8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82268BE8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268BE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268BE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268BE8);
		  /* 82268BE8h */ case    0:  		/* mfspr R12, LR */
		/* 82268BE8h case    0:*/		regs.R12 = regs.LR;
		/* 82268BE8h case    0:*/		return 0x82268BEC;
		  /* 82268BECh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82268BECh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82268BECh case    1:*/		return 0x82268BF0;
		  /* 82268BF0h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82268BF0h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82268BF0h case    2:*/		return 0x82268BF4;
		  /* 82268BF4h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82268BF4h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82268BF4h case    3:*/		return 0x82268BF8;
		  /* 82268BF8h */ case    4:  		/* stfd FR30, <#[R1 - 40]> */
		/* 82268BF8h case    4:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R1 + 0xFFFFFFD8) );
		/* 82268BF8h case    4:*/		return 0x82268BFC;
		  /* 82268BFCh */ case    5:  		/* stfd FR31, <#[R1 - 32]> */
		/* 82268BFCh case    5:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFE0) );
		/* 82268BFCh case    5:*/		return 0x82268C00;
		  /* 82268C00h */ case    6:  		/* stwu R1, <#[R1 - 128]> */
		/* 82268C00h case    6:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82268C00h case    6:*/		return 0x82268C04;
		  /* 82268C04h */ case    7:  		/* lis R11, -32216 */
		/* 82268C04h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 82268C04h case    7:*/		return 0x82268C08;
	}
	return 0x82268C08;
} // Block from 82268BE8h-82268C08h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82268C08h
// Function 'asin'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268C08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268C08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268C08);
		  /* 82268C08h */ case    0:  		/* fmr FR31, FR1 */
		/* 82268C08h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR1);
		/* 82268C08h case    0:*/		return 0x82268C0C;
		  /* 82268C0Ch */ case    1:  		/* mr R31, R4 */
		/* 82268C0Ch case    1:*/		regs.R31 = regs.R4;
		/* 82268C0Ch case    1:*/		return 0x82268C10;
		  /* 82268C10h */ case    2:  		/* addi R30, R11, 27512 */
		/* 82268C10h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0x6B78);
		/* 82268C10h case    2:*/		return 0x82268C14;
		  /* 82268C14h */ case    3:  		/* lfd FR0, <#[R30 + 32]> */
		/* 82268C14h case    3:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R30 + 0x00000020) );
		/* 82268C14h case    3:*/		return 0x82268C18;
		  /* 82268C18h */ case    4:  		/* fmul FR1, FR0, FR1 */
		/* 82268C18h case    4:*/		cpu::op::fmul<0>(regs,&regs.FR1,regs.FR0,regs.FR1);
		/* 82268C18h case    4:*/		return 0x82268C1C;
		  /* 82268C1Ch */ case    5:  		/* bl 2900 */
		/* 82268C1Ch case    5:*/		regs.LR = 0x82268C20; return 0x82269770;
		/* 82268C1Ch case    5:*/		return 0x82268C20;
		  /* 82268C20h */ case    6:  		/* lfd FR0, <#[R30 + 40]> */
		/* 82268C20h case    6:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R30 + 0x00000028) );
		/* 82268C20h case    6:*/		return 0x82268C24;
		  /* 82268C24h */ case    7:  		/* lis R11, -32256 */
		/* 82268C24h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82268C24h case    7:*/		return 0x82268C28;
		  /* 82268C28h */ case    8:  		/* fnmsub FR0, FR0, FR1, FR31 */
		/* 82268C28h case    8:*/		cpu::op::fnmsub<0>(regs,&regs.FR0,regs.FR0,regs.FR1,regs.FR31);
		/* 82268C28h case    8:*/		return 0x82268C2C;
		  /* 82268C2Ch */ case    9:  		/* lfd FR13, <#[R30 + 48]> */
		/* 82268C2Ch case    9:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R30 + 0x00000030) );
		/* 82268C2Ch case    9:*/		return 0x82268C30;
		  /* 82268C30h */ case   10:  		/* lfd FR11, <#[R30 + 64]> */
		/* 82268C30h case   10:*/		cpu::mem::load64f( regs, &regs.FR11, (uint32)(regs.R30 + 0x00000040) );
		/* 82268C30h case   10:*/		return 0x82268C34;
		  /* 82268C34h */ case   11:  		/* fmr FR30, FR1 */
		/* 82268C34h case   11:*/		cpu::op::fmr<0>(regs,&regs.FR30,regs.FR1);
		/* 82268C34h case   11:*/		return 0x82268C38;
		  /* 82268C38h */ case   12:  		/* lfd FR12, <#[R30 + 72]> */
		/* 82268C38h case   12:*/		cpu::mem::load64f( regs, &regs.FR12, (uint32)(regs.R30 + 0x00000048) );
		/* 82268C38h case   12:*/		return 0x82268C3C;
		  /* 82268C3Ch */ case   13:  		/* lfd FR10, <#[R30 + 96]> */
		/* 82268C3Ch case   13:*/		cpu::mem::load64f( regs, &regs.FR10, (uint32)(regs.R30 + 0x00000060) );
		/* 82268C3Ch case   13:*/		return 0x82268C40;
		  /* 82268C40h */ case   14:  		/* lfd FR9, <#[R30 + 88]> */
		/* 82268C40h case   14:*/		cpu::mem::load64f( regs, &regs.FR9, (uint32)(regs.R30 + 0x00000058) );
		/* 82268C40h case   14:*/		return 0x82268C44;
		  /* 82268C44h */ case   15:  		/* lfd FR8, <#[R30 + 56]> */
		/* 82268C44h case   15:*/		cpu::mem::load64f( regs, &regs.FR8, (uint32)(regs.R30 + 0x00000038) );
		/* 82268C44h case   15:*/		return 0x82268C48;
		  /* 82268C48h */ case   16:  		/* lfd FR7, <#[R30 + 80]> */
		/* 82268C48h case   16:*/		cpu::mem::load64f( regs, &regs.FR7, (uint32)(regs.R30 + 0x00000050) );
		/* 82268C48h case   16:*/		return 0x82268C4C;
		  /* 82268C4Ch */ case   17:  		/* lfd FR6, <#[R11 + 4736]> */
		/* 82268C4Ch case   17:*/		cpu::mem::load64f( regs, &regs.FR6, (uint32)(regs.R11 + 0x00001280) );
		/* 82268C4Ch case   17:*/		return 0x82268C50;
		  /* 82268C50h */ case   18:  		/* fnmsub FR0, FR13, FR1, FR0 */
		/* 82268C50h case   18:*/		cpu::op::fnmsub<0>(regs,&regs.FR0,regs.FR13,regs.FR1,regs.FR0);
		/* 82268C50h case   18:*/		return 0x82268C54;
		  /* 82268C54h */ case   19:  		/* fmul FR13, FR0, FR0 */
		/* 82268C54h case   19:*/		cpu::op::fmul<0>(regs,&regs.FR13,regs.FR0,regs.FR0);
		/* 82268C54h case   19:*/		return 0x82268C58;
		  /* 82268C58h */ case   20:  		/* fmadd FR12, FR12, FR13, FR11 */
		/* 82268C58h case   20:*/		cpu::op::fmadd<0>(regs,&regs.FR12,regs.FR12,regs.FR13,regs.FR11);
		/* 82268C58h case   20:*/		return 0x82268C5C;
		  /* 82268C5Ch */ case   21:  		/* fmadd FR11, FR10, FR13, FR9 */
		/* 82268C5Ch case   21:*/		cpu::op::fmadd<0>(regs,&regs.FR11,regs.FR10,regs.FR13,regs.FR9);
		/* 82268C5Ch case   21:*/		return 0x82268C60;
		  /* 82268C60h */ case   22:  		/* fmadd FR12, FR12, FR13, FR8 */
		/* 82268C60h case   22:*/		cpu::op::fmadd<0>(regs,&regs.FR12,regs.FR12,regs.FR13,regs.FR8);
		/* 82268C60h case   22:*/		return 0x82268C64;
		  /* 82268C64h */ case   23:  		/* fmadd FR13, FR11, FR13, FR7 */
		/* 82268C64h case   23:*/		cpu::op::fmadd<0>(regs,&regs.FR13,regs.FR11,regs.FR13,regs.FR7);
		/* 82268C64h case   23:*/		return 0x82268C68;
		  /* 82268C68h */ case   24:  		/* fmul FR0, FR12, FR0 */
		/* 82268C68h case   24:*/		cpu::op::fmul<0>(regs,&regs.FR0,regs.FR12,regs.FR0);
		/* 82268C68h case   24:*/		return 0x82268C6C;
		  /* 82268C6Ch */ case   25:  		/* fsub FR13, FR13, FR0 */
		/* 82268C6Ch case   25:*/		cpu::op::fsub<0>(regs,&regs.FR13,regs.FR13,regs.FR0);
		/* 82268C6Ch case   25:*/		return 0x82268C70;
		  /* 82268C70h */ case   26:  		/* fdiv FR0, FR0, FR13 */
		/* 82268C70h case   26:*/		cpu::op::fdiv<0>(regs,&regs.FR0,regs.FR0,regs.FR13);
		/* 82268C70h case   26:*/		return 0x82268C74;
		  /* 82268C74h */ case   27:  		/* fadd FR31, FR0, FR6 */
		/* 82268C74h case   27:*/		cpu::op::fadd<0>(regs,&regs.FR31,regs.FR0,regs.FR6);
		/* 82268C74h case   27:*/		return 0x82268C78;
		  /* 82268C78h */ case   28:  		/* fmr FR1, FR31 */
		/* 82268C78h case   28:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 82268C78h case   28:*/		return 0x82268C7C;
		  /* 82268C7Ch */ case   29:  		/* bl -1917644 */
		/* 82268C7Ch case   29:*/		regs.LR = 0x82268C80; return 0x820949B0;
		/* 82268C7Ch case   29:*/		return 0x82268C80;
		  /* 82268C80h */ case   30:  		/* fctiwz FR0, FR30 */
		/* 82268C80h case   30:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR30);
		/* 82268C80h case   30:*/		return 0x82268C84;
		  /* 82268C84h */ case   31:  		/* stfd FR0, <#[R1 + 80]> */
		/* 82268C84h case   31:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 82268C84h case   31:*/		return 0x82268C88;
		  /* 82268C88h */ case   32:  		/* lwz R11, <#[R1 + 84]> */
		/* 82268C88h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 82268C88h case   32:*/		return 0x82268C8C;
		  /* 82268C8Ch */ case   33:  		/* add R11, R3, R11 */
		/* 82268C8Ch case   33:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 82268C8Ch case   33:*/		return 0x82268C90;
		  /* 82268C90h */ case   34:  		/* addi R11, R11, 1 */
		/* 82268C90h case   34:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 82268C90h case   34:*/		return 0x82268C94;
		  /* 82268C94h */ case   35:  		/* fmr FR1, FR31 */
		/* 82268C94h case   35:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 82268C94h case   35:*/		return 0x82268C98;
		  /* 82268C98h */ case   36:  		/* stw R11, <#[R31]> */
		/* 82268C98h case   36:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 82268C98h case   36:*/		return 0x82268C9C;
		  /* 82268C9Ch */ case   37:  		/* addi R1, R1, 128 */
		/* 82268C9Ch case   37:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82268C9Ch case   37:*/		return 0x82268CA0;
		  /* 82268CA0h */ case   38:  		/* lwz R12, <#[R1 - 8]> */
		/* 82268CA0h case   38:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82268CA0h case   38:*/		return 0x82268CA4;
		  /* 82268CA4h */ case   39:  		/* mtspr LR, R12 */
		/* 82268CA4h case   39:*/		regs.LR = regs.R12;
		/* 82268CA4h case   39:*/		return 0x82268CA8;
		  /* 82268CA8h */ case   40:  		/* lfd FR30, <#[R1 - 40]> */
		/* 82268CA8h case   40:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R1 + 0xFFFFFFD8) );
		/* 82268CA8h case   40:*/		return 0x82268CAC;
		  /* 82268CACh */ case   41:  		/* lfd FR31, <#[R1 - 32]> */
		/* 82268CACh case   41:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFE0) );
		/* 82268CACh case   41:*/		return 0x82268CB0;
		  /* 82268CB0h */ case   42:  		/* ld R30, <#[R1 - 24]> */
		/* 82268CB0h case   42:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82268CB0h case   42:*/		return 0x82268CB4;
		  /* 82268CB4h */ case   43:  		/* ld R31, <#[R1 - 16]> */
		/* 82268CB4h case   43:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82268CB4h case   43:*/		return 0x82268CB8;
		  /* 82268CB8h */ case   44:  		/* bclr 20, CR0_LT */
		/* 82268CB8h case   44:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82268CB8h case   44:*/		return 0x82268CBC;
	}
	return 0x82268CBC;
} // Block from 82268C08h-82268CBCh (45 instructions)

//////////////////////////////////////////////////////
// Block at 82268CBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268CBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268CBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268CBC);
		  /* 82268CBCh */ case    0:  		/* nop */
		/* 82268CBCh case    0:*/		cpu::op::nop();
		/* 82268CBCh case    0:*/		return 0x82268CC0;
	}
	return 0x82268CC0;
} // Block from 82268CBCh-82268CC0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82268CC0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268CC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268CC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268CC0);
		  /* 82268CC0h */ case    0:  		/* mfspr R12, LR */
		/* 82268CC0h case    0:*/		regs.R12 = regs.LR;
		/* 82268CC0h case    0:*/		return 0x82268CC4;
		  /* 82268CC4h */ case    1:  		/* bl -1931880 */
		/* 82268CC4h case    1:*/		regs.LR = 0x82268CC8; return 0x8209125C;
		/* 82268CC4h case    1:*/		return 0x82268CC8;
		  /* 82268CC8h */ case    2:  		/* std R5, <#[R1 + 32]> */
		/* 82268CC8h case    2:*/		cpu::mem::store64( regs, regs.R5, (uint32)(regs.R1 + 0x00000020) );
		/* 82268CC8h case    2:*/		return 0x82268CCC;
		  /* 82268CCCh */ case    3:  		/* std R6, <#[R1 + 40]> */
		/* 82268CCCh case    3:*/		cpu::mem::store64( regs, regs.R6, (uint32)(regs.R1 + 0x00000028) );
		/* 82268CCCh case    3:*/		return 0x82268CD0;
	}
	return 0x82268CD0;
} // Block from 82268CC0h-82268CD0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82268CD0h
// Function 'acos'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268CD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268CD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268CD0);
		  /* 82268CD0h */ case    0:  		/* std R7, <#[R1 + 48]> */
		/* 82268CD0h case    0:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R1 + 0x00000030) );
		/* 82268CD0h case    0:*/		return 0x82268CD4;
		  /* 82268CD4h */ case    1:  		/* std R8, <#[R1 + 56]> */
		/* 82268CD4h case    1:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R1 + 0x00000038) );
		/* 82268CD4h case    1:*/		return 0x82268CD8;
	}
	return 0x82268CD8;
} // Block from 82268CD0h-82268CD8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82268CD8h
// Function '?xtoa@@YAXKPADIH@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268CD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268CD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268CD8);
		  /* 82268CD8h */ case    0:  		/* std R9, <#[R1 + 64]> */
		/* 82268CD8h case    0:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000040) );
		/* 82268CD8h case    0:*/		return 0x82268CDC;
		  /* 82268CDCh */ case    1:  		/* std R10, <#[R1 + 72]> */
		/* 82268CDCh case    1:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000048) );
		/* 82268CDCh case    1:*/		return 0x82268CE0;
		  /* 82268CE0h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 82268CE0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82268CE0h case    2:*/		return 0x82268CE4;
		  /* 82268CE4h */ case    3:  		/* mr R31, R3 */
		/* 82268CE4h case    3:*/		regs.R31 = regs.R3;
		/* 82268CE4h case    3:*/		return 0x82268CE8;
		  /* 82268CE8h */ case    4:  		/* stw R4, <#[R1 + 188]> */
		/* 82268CE8h case    4:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x000000BC) );
		/* 82268CE8h case    4:*/		return 0x82268CEC;
		  /* 82268CECh */ case    5:  		/* mr R30, R4 */
		/* 82268CECh case    5:*/		regs.R30 = regs.R4;
		/* 82268CECh case    5:*/		return 0x82268CF0;
		  /* 82268CF0h */ case    6:  		/* li R29, 0 */
		/* 82268CF0h case    6:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 82268CF0h case    6:*/		return 0x82268CF4;
		  /* 82268CF4h */ case    7:  		/* li R5, 28 */
		/* 82268CF4h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x1C);
		/* 82268CF4h case    7:*/		return 0x82268CF8;
		  /* 82268CF8h */ case    8:  		/* li R4, 0 */
		/* 82268CF8h case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82268CF8h case    8:*/		return 0x82268CFC;
		  /* 82268CFCh */ case    9:  		/* stw R29, <#[R1 + 96]> */
		/* 82268CFCh case    9:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x00000060) );
		/* 82268CFCh case    9:*/		return 0x82268D00;
		  /* 82268D00h */ case   10:  		/* addi R3, R1, 100 */
		/* 82268D00h case   10:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x64);
		/* 82268D00h case   10:*/		return 0x82268D04;
		  /* 82268D04h */ case   11:  		/* bl -1931716 */
		/* 82268D04h case   11:*/		regs.LR = 0x82268D08; return 0x82091340;
		/* 82268D04h case   11:*/		return 0x82268D08;
		  /* 82268D08h */ case   12:  		/* cmplwi CR6, R30, 0 */
		/* 82268D08h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82268D08h case   12:*/		return 0x82268D0C;
		  /* 82268D0Ch */ case   13:  		/* bc 4, CR6_EQ, 28 */
		/* 82268D0Ch case   13:*/		if ( !regs.CR[6].eq ) { return 0x82268D28;  }
		/* 82268D0Ch case   13:*/		return 0x82268D10;
		  /* 82268D10h */ case   14:  		/* bl -1916424 */
		/* 82268D10h case   14:*/		regs.LR = 0x82268D14; return 0x82094F08;
		/* 82268D10h case   14:*/		return 0x82268D14;
		  /* 82268D14h */ case   15:  		/* li R11, 22 */
		/* 82268D14h case   15:*/		cpu::op::li<0>(regs,&regs.R11,0x16);
		/* 82268D14h case   15:*/		return 0x82268D18;
		  /* 82268D18h */ case   16:  		/* stw R11, <#[R3]> */
		/* 82268D18h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82268D18h case   16:*/		return 0x82268D1C;
		  /* 82268D1Ch */ case   17:  		/* bl -1921980 */
		/* 82268D1Ch case   17:*/		regs.LR = 0x82268D20; return 0x82093960;
		/* 82268D1Ch case   17:*/		return 0x82268D20;
		  /* 82268D20h */ case   18:  		/* li R3, -1 */
		/* 82268D20h case   18:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 82268D20h case   18:*/		return 0x82268D24;
		  /* 82268D24h */ case   19:  		/* b 120 */
		/* 82268D24h case   19:*/		return 0x82268D9C;
		/* 82268D24h case   19:*/		return 0x82268D28;
	}
	return 0x82268D28;
} // Block from 82268CD8h-82268D28h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82268D28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268D28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268D28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268D28);
		  /* 82268D28h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 82268D28h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82268D28h case    0:*/		return 0x82268D2C;
		  /* 82268D2Ch */ case    1:  		/* bc 12, CR6_EQ, -28 */
		/* 82268D2Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x82268D10;  }
		/* 82268D2Ch case    1:*/		return 0x82268D30;
		  /* 82268D30h */ case    2:  		/* lis R11, 32767 */
		/* 82268D30h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0x7FFF);
		/* 82268D30h case    2:*/		return 0x82268D34;
		  /* 82268D34h */ case    3:  		/* stw R31, <#[R1 + 104]> */
		/* 82268D34h case    3:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000068) );
		/* 82268D34h case    3:*/		return 0x82268D38;
		  /* 82268D38h */ case    4:  		/* li R10, 66 */
		/* 82268D38h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x42);
		/* 82268D38h case    4:*/		return 0x82268D3C;
		  /* 82268D3Ch */ case    5:  		/* stw R31, <#[R1 + 96]> */
		/* 82268D3Ch case    5:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000060) );
		/* 82268D3Ch case    5:*/		return 0x82268D40;
		  /* 82268D40h */ case    6:  		/* ori R11, R11, 65535 */
		/* 82268D40h case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xFFFF);
		/* 82268D40h case    6:*/		return 0x82268D44;
		  /* 82268D44h */ case    7:  		/* stw R10, <#[R1 + 108]> */
		/* 82268D44h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x0000006C) );
		/* 82268D44h case    7:*/		return 0x82268D48;
		  /* 82268D48h */ case    8:  		/* addi R10, R1, 80 */
		/* 82268D48h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 82268D48h case    8:*/		return 0x82268D4C;
		  /* 82268D4Ch */ case    9:  		/* stw R11, <#[R1 + 100]> */
		/* 82268D4Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 82268D4Ch case    9:*/		return 0x82268D50;
		  /* 82268D50h */ case   10:  		/* addi R11, R1, 192 */
		/* 82268D50h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0xC0);
		/* 82268D50h case   10:*/		return 0x82268D54;
		  /* 82268D54h */ case   11:  		/* li R5, 0 */
		/* 82268D54h case   11:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82268D54h case   11:*/		return 0x82268D58;
		  /* 82268D58h */ case   12:  		/* mr R4, R30 */
		/* 82268D58h case   12:*/		regs.R4 = regs.R30;
		/* 82268D58h case   12:*/		return 0x82268D5C;
		  /* 82268D5Ch */ case   13:  		/* addi R3, R1, 96 */
		/* 82268D5Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 82268D5Ch case   13:*/		return 0x82268D60;
		  /* 82268D60h */ case   14:  		/* stw R11, <#[R10]> */
		/* 82268D60h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82268D60h case   14:*/		return 0x82268D64;
		  /* 82268D64h */ case   15:  		/* lwz R6, <#[R1 + 80]> */
		/* 82268D64h case   15:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 82268D64h case   15:*/		return 0x82268D68;
	}
	return 0x82268D68;
} // Block from 82268D28h-82268D68h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82268D68h
// Function '_ultoa'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268D68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268D68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268D68);
		  /* 82268D68h */ case    0:  		/* bl -1910640 */
		/* 82268D68h case    0:*/		regs.LR = 0x82268D6C; return 0x820965F8;
		/* 82268D68h case    0:*/		return 0x82268D6C;
		  /* 82268D6Ch */ case    1:  		/* lwz R11, <#[R1 + 100]> */
		/* 82268D6Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 82268D6Ch case    1:*/		return 0x82268D70;
		  /* 82268D70h */ case    2:  		/* addic. R11, R11, -1 */
		/* 82268D70h case    2:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82268D70h case    2:*/		return 0x82268D74;
		  /* 82268D74h */ case    3:  		/* mr R31, R3 */
		/* 82268D74h case    3:*/		regs.R31 = regs.R3;
		/* 82268D74h case    3:*/		return 0x82268D78;
		  /* 82268D78h */ case    4:  		/* stw R11, <#[R1 + 100]> */
		/* 82268D78h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 82268D78h case    4:*/		return 0x82268D7C;
		  /* 82268D7Ch */ case    5:  		/* bc 12, CR0_LT, 16 */
		/* 82268D7Ch case    5:*/		if ( regs.CR[0].lt ) { return 0x82268D8C;  }
		/* 82268D7Ch case    5:*/		return 0x82268D80;
		  /* 82268D80h */ case    6:  		/* lwz R11, <#[R1 + 96]> */
		/* 82268D80h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82268D80h case    6:*/		return 0x82268D84;
		  /* 82268D84h */ case    7:  		/* stb R29, <#[R11]> */
		/* 82268D84h case    7:*/		cpu::mem::store8( regs, regs.R29, (uint32)(regs.R11 + 0x00000000) );
		/* 82268D84h case    7:*/		return 0x82268D88;
		  /* 82268D88h */ case    8:  		/* b 16 */
		/* 82268D88h case    8:*/		return 0x82268D98;
		/* 82268D88h case    8:*/		return 0x82268D8C;
	}
	return 0x82268D8C;
} // Block from 82268D68h-82268D8Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 82268D8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268D8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268D8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268D8C);
		  /* 82268D8Ch */ case    0:  		/* addi R4, R1, 96 */
		/* 82268D8Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 82268D8Ch case    0:*/		return 0x82268D90;
		  /* 82268D90h */ case    1:  		/* li R3, 0 */
		/* 82268D90h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82268D90h case    1:*/		return 0x82268D94;
		  /* 82268D94h */ case    2:  		/* bl -1917140 */
		/* 82268D94h case    2:*/		regs.LR = 0x82268D98; return 0x82094CC0;
		/* 82268D94h case    2:*/		return 0x82268D98;
	}
	return 0x82268D98;
} // Block from 82268D8Ch-82268D98h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82268D98h
// Function 'tanh'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268D98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268D98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268D98);
		  /* 82268D98h */ case    0:  		/* mr R3, R31 */
		/* 82268D98h case    0:*/		regs.R3 = regs.R31;
		/* 82268D98h case    0:*/		return 0x82268D9C;
	}
	return 0x82268D9C;
} // Block from 82268D98h-82268D9Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82268D9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268D9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268D9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268D9C);
		  /* 82268D9Ch */ case    0:  		/* addi R1, R1, 160 */
		/* 82268D9Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 82268D9Ch case    0:*/		return 0x82268DA0;
		  /* 82268DA0h */ case    1:  		/* b -1932020 */
		/* 82268DA0h case    1:*/		return 0x820912AC;
		/* 82268DA0h case    1:*/		return 0x82268DA4;
		  /* 82268DA4h */ case    2:  		/* nop */
		/* 82268DA4h case    2:*/		cpu::op::nop();
		/* 82268DA4h case    2:*/		return 0x82268DA8;
	}
	return 0x82268DA8;
} // Block from 82268D9Ch-82268DA8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82268DA8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268DA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268DA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268DA8);
		  /* 82268DA8h */ case    0:  		/* mfspr R12, LR */
		/* 82268DA8h case    0:*/		regs.R12 = regs.LR;
		/* 82268DA8h case    0:*/		return 0x82268DAC;
		  /* 82268DACh */ case    1:  		/* bl -1932116 */
		/* 82268DACh case    1:*/		regs.LR = 0x82268DB0; return 0x82091258;
		/* 82268DACh case    1:*/		return 0x82268DB0;
		  /* 82268DB0h */ case    2:  		/* std R6, <#[R1 + 40]> */
		/* 82268DB0h case    2:*/		cpu::mem::store64( regs, regs.R6, (uint32)(regs.R1 + 0x00000028) );
		/* 82268DB0h case    2:*/		return 0x82268DB4;
		  /* 82268DB4h */ case    3:  		/* std R7, <#[R1 + 48]> */
		/* 82268DB4h case    3:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R1 + 0x00000030) );
		/* 82268DB4h case    3:*/		return 0x82268DB8;
		  /* 82268DB8h */ case    4:  		/* std R8, <#[R1 + 56]> */
		/* 82268DB8h case    4:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R1 + 0x00000038) );
		/* 82268DB8h case    4:*/		return 0x82268DBC;
		  /* 82268DBCh */ case    5:  		/* std R9, <#[R1 + 64]> */
		/* 82268DBCh case    5:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000040) );
		/* 82268DBCh case    5:*/		return 0x82268DC0;
		  /* 82268DC0h */ case    6:  		/* std R10, <#[R1 + 72]> */
		/* 82268DC0h case    6:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000048) );
		/* 82268DC0h case    6:*/		return 0x82268DC4;
		  /* 82268DC4h */ case    7:  		/* stwu R1, <#[R1 - 176]> */
		/* 82268DC4h case    7:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 82268DC4h case    7:*/		return 0x82268DC8;
		  /* 82268DC8h */ case    8:  		/* mr R31, R3 */
		/* 82268DC8h case    8:*/		regs.R31 = regs.R3;
		/* 82268DC8h case    8:*/		return 0x82268DCC;
		  /* 82268DCCh */ case    9:  		/* stw R5, <#[R1 + 212]> */
		/* 82268DCCh case    9:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x000000D4) );
		/* 82268DCCh case    9:*/		return 0x82268DD0;
		  /* 82268DD0h */ case   10:  		/* mr R30, R4 */
		/* 82268DD0h case   10:*/		regs.R30 = regs.R4;
		/* 82268DD0h case   10:*/		return 0x82268DD4;
		  /* 82268DD4h */ case   11:  		/* mr R29, R5 */
		/* 82268DD4h case   11:*/		regs.R29 = regs.R5;
		/* 82268DD4h case   11:*/		return 0x82268DD8;
		  /* 82268DD8h */ case   12:  		/* li R28, 0 */
		/* 82268DD8h case   12:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 82268DD8h case   12:*/		return 0x82268DDC;
		  /* 82268DDCh */ case   13:  		/* li R5, 28 */
		/* 82268DDCh case   13:*/		cpu::op::li<0>(regs,&regs.R5,0x1C);
		/* 82268DDCh case   13:*/		return 0x82268DE0;
		  /* 82268DE0h */ case   14:  		/* li R4, 0 */
		/* 82268DE0h case   14:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 82268DE0h case   14:*/		return 0x82268DE4;
		  /* 82268DE4h */ case   15:  		/* stw R28, <#[R1 + 96]> */
		/* 82268DE4h case   15:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000060) );
		/* 82268DE4h case   15:*/		return 0x82268DE8;
		  /* 82268DE8h */ case   16:  		/* addi R3, R1, 100 */
		/* 82268DE8h case   16:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x64);
		/* 82268DE8h case   16:*/		return 0x82268DEC;
		  /* 82268DECh */ case   17:  		/* bl -1931948 */
		/* 82268DECh case   17:*/		regs.LR = 0x82268DF0; return 0x82091340;
		/* 82268DECh case   17:*/		return 0x82268DF0;
		  /* 82268DF0h */ case   18:  		/* cmplwi CR6, R29, 0 */
		/* 82268DF0h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 82268DF0h case   18:*/		return 0x82268DF4;
		  /* 82268DF4h */ case   19:  		/* bc 4, CR6_EQ, 28 */
		/* 82268DF4h case   19:*/		if ( !regs.CR[6].eq ) { return 0x82268E10;  }
		/* 82268DF4h case   19:*/		return 0x82268DF8;
		  /* 82268DF8h */ case   20:  		/* bl -1916656 */
		/* 82268DF8h case   20:*/		regs.LR = 0x82268DFC; return 0x82094F08;
		/* 82268DF8h case   20:*/		return 0x82268DFC;
		  /* 82268DFCh */ case   21:  		/* li R11, 22 */
		/* 82268DFCh case   21:*/		cpu::op::li<0>(regs,&regs.R11,0x16);
		/* 82268DFCh case   21:*/		return 0x82268E00;
		  /* 82268E00h */ case   22:  		/* stw R11, <#[R3]> */
		/* 82268E00h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82268E00h case   22:*/		return 0x82268E04;
		  /* 82268E04h */ case   23:  		/* bl -1922212 */
		/* 82268E04h case   23:*/		regs.LR = 0x82268E08; return 0x82093960;
		/* 82268E04h case   23:*/		return 0x82268E08;
		  /* 82268E08h */ case   24:  		/* li R3, -1 */
		/* 82268E08h case   24:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 82268E08h case   24:*/		return 0x82268E0C;
		  /* 82268E0Ch */ case   25:  		/* b 148 */
		/* 82268E0Ch case   25:*/		return 0x82268EA0;
		/* 82268E0Ch case   25:*/		return 0x82268E10;
	}
	return 0x82268E10;
} // Block from 82268DA8h-82268E10h (26 instructions)

//////////////////////////////////////////////////////
// Block at 82268E10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268E10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268E10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268E10);
		  /* 82268E10h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 82268E10h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 82268E10h case    0:*/		return 0x82268E14;
		  /* 82268E14h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 82268E14h case    1:*/		if ( regs.CR[6].eq ) { return 0x82268E20;  }
		/* 82268E14h case    1:*/		return 0x82268E18;
		  /* 82268E18h */ case    2:  		/* cmplwi CR6, R31, 0 */
		/* 82268E18h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82268E18h case    2:*/		return 0x82268E1C;
		  /* 82268E1Ch */ case    3:  		/* bc 12, CR6_EQ, -36 */
		/* 82268E1Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x82268DF8;  }
		/* 82268E1Ch case    3:*/		return 0x82268E20;
	}
	return 0x82268E20;
} // Block from 82268E10h-82268E20h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82268E20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268E20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268E20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268E20);
		  /* 82268E20h */ case    0:  		/* addi R10, R1, 80 */
		/* 82268E20h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 82268E20h case    0:*/		return 0x82268E24;
		  /* 82268E24h */ case    1:  		/* lis R11, 32767 */
		/* 82268E24h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0x7FFF);
		/* 82268E24h case    1:*/		return 0x82268E28;
		  /* 82268E28h */ case    2:  		/* addi R9, R1, 216 */
		/* 82268E28h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0xD8);
		/* 82268E28h case    2:*/		return 0x82268E2C;
		  /* 82268E2Ch */ case    3:  		/* ori R11, R11, 65535 */
		/* 82268E2Ch case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0xFFFF);
		/* 82268E2Ch case    3:*/		return 0x82268E30;
		  /* 82268E30h */ case    4:  		/* cmplw CR6, R30, R11 */
		/* 82268E30h case    4:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R11);
		/* 82268E30h case    4:*/		return 0x82268E34;
		  /* 82268E34h */ case    5:  		/* stw R9, <#[R10]> */
		/* 82268E34h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82268E34h case    5:*/		return 0x82268E38;
		  /* 82268E38h */ case    6:  		/* stw R11, <#[R1 + 100]> */
		/* 82268E38h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 82268E38h case    6:*/		return 0x82268E3C;
		  /* 82268E3Ch */ case    7:  		/* bc 12, CR6_GT, 8 */
		/* 82268E3Ch case    7:*/		if ( regs.CR[6].gt ) { return 0x82268E44;  }
		/* 82268E3Ch case    7:*/		return 0x82268E40;
		  /* 82268E40h */ case    8:  		/* stw R30, <#[R1 + 100]> */
		/* 82268E40h case    8:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000064) );
		/* 82268E40h case    8:*/		return 0x82268E44;
	}
	return 0x82268E44;
} // Block from 82268E20h-82268E44h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82268E44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268E44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268E44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268E44);
		  /* 82268E44h */ case    0:  		/* li R11, 66 */
		/* 82268E44h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x42);
		/* 82268E44h case    0:*/		return 0x82268E48;
		  /* 82268E48h */ case    1:  		/* stw R31, <#[R1 + 104]> */
		/* 82268E48h case    1:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000068) );
		/* 82268E48h case    1:*/		return 0x82268E4C;
		  /* 82268E4Ch */ case    2:  		/* stw R31, <#[R1 + 96]> */
		/* 82268E4Ch case    2:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000060) );
		/* 82268E4Ch case    2:*/		return 0x82268E50;
		  /* 82268E50h */ case    3:  		/* li R5, 0 */
		/* 82268E50h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82268E50h case    3:*/		return 0x82268E54;
		  /* 82268E54h */ case    4:  		/* stw R11, <#[R1 + 108]> */
		/* 82268E54h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000006C) );
		/* 82268E54h case    4:*/		return 0x82268E58;
		  /* 82268E58h */ case    5:  		/* mr R4, R29 */
		/* 82268E58h case    5:*/		regs.R4 = regs.R29;
		/* 82268E58h case    5:*/		return 0x82268E5C;
		  /* 82268E5Ch */ case    6:  		/* addi R3, R1, 96 */
		/* 82268E5Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 82268E5Ch case    6:*/		return 0x82268E60;
		  /* 82268E60h */ case    7:  		/* lwz R6, <#[R1 + 80]> */
		/* 82268E60h case    7:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000050) );
		/* 82268E60h case    7:*/		return 0x82268E64;
		  /* 82268E64h */ case    8:  		/* bl -1910892 */
		/* 82268E64h case    8:*/		regs.LR = 0x82268E68; return 0x820965F8;
		/* 82268E64h case    8:*/		return 0x82268E68;
		  /* 82268E68h */ case    9:  		/* mr R30, R3 */
		/* 82268E68h case    9:*/		regs.R30 = regs.R3;
		/* 82268E68h case    9:*/		return 0x82268E6C;
		  /* 82268E6Ch */ case   10:  		/* cmplwi CR6, R31, 0 */
		/* 82268E6Ch case   10:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82268E6Ch case   10:*/		return 0x82268E70;
		  /* 82268E70h */ case   11:  		/* bc 12, CR6_EQ, 44 */
		/* 82268E70h case   11:*/		if ( regs.CR[6].eq ) { return 0x82268E9C;  }
		/* 82268E70h case   11:*/		return 0x82268E74;
		  /* 82268E74h */ case   12:  		/* lwz R11, <#[R1 + 100]> */
		/* 82268E74h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 82268E74h case   12:*/		return 0x82268E78;
		  /* 82268E78h */ case   13:  		/* addic. R11, R11, -1 */
		/* 82268E78h case   13:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 82268E78h case   13:*/		return 0x82268E7C;
		  /* 82268E7Ch */ case   14:  		/* stw R11, <#[R1 + 100]> */
		/* 82268E7Ch case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000064) );
		/* 82268E7Ch case   14:*/		return 0x82268E80;
		  /* 82268E80h */ case   15:  		/* bc 12, CR0_LT, 16 */
		/* 82268E80h case   15:*/		if ( regs.CR[0].lt ) { return 0x82268E90;  }
		/* 82268E80h case   15:*/		return 0x82268E84;
		  /* 82268E84h */ case   16:  		/* lwz R11, <#[R1 + 96]> */
		/* 82268E84h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 82268E84h case   16:*/		return 0x82268E88;
		  /* 82268E88h */ case   17:  		/* stb R28, <#[R11]> */
		/* 82268E88h case   17:*/		cpu::mem::store8( regs, regs.R28, (uint32)(regs.R11 + 0x00000000) );
		/* 82268E88h case   17:*/		return 0x82268E8C;
		  /* 82268E8Ch */ case   18:  		/* b 16 */
		/* 82268E8Ch case   18:*/		return 0x82268E9C;
		/* 82268E8Ch case   18:*/		return 0x82268E90;
	}
	return 0x82268E90;
} // Block from 82268E44h-82268E90h (19 instructions)

//////////////////////////////////////////////////////
// Block at 82268E90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268E90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268E90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268E90);
		  /* 82268E90h */ case    0:  		/* addi R4, R1, 96 */
		/* 82268E90h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x60);
		/* 82268E90h case    0:*/		return 0x82268E94;
		  /* 82268E94h */ case    1:  		/* li R3, 0 */
		/* 82268E94h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82268E94h case    1:*/		return 0x82268E98;
	}
	return 0x82268E98;
} // Block from 82268E90h-82268E98h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82268E98h
// Function 'tan'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268E98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268E98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268E98);
		  /* 82268E98h */ case    0:  		/* bl -1917400 */
		/* 82268E98h case    0:*/		regs.LR = 0x82268E9C; return 0x82094CC0;
		/* 82268E98h case    0:*/		return 0x82268E9C;
	}
	return 0x82268E9C;
} // Block from 82268E98h-82268E9Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82268E9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268E9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268E9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268E9C);
		  /* 82268E9Ch */ case    0:  		/* mr R3, R30 */
		/* 82268E9Ch case    0:*/		regs.R3 = regs.R30;
		/* 82268E9Ch case    0:*/		return 0x82268EA0;
	}
	return 0x82268EA0;
} // Block from 82268E9Ch-82268EA0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82268EA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268EA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268EA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268EA0);
		  /* 82268EA0h */ case    0:  		/* addi R1, R1, 176 */
		/* 82268EA0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 82268EA0h case    0:*/		return 0x82268EA4;
		  /* 82268EA4h */ case    1:  		/* b -1932284 */
		/* 82268EA4h case    1:*/		return 0x820912A8;
		/* 82268EA4h case    1:*/		return 0x82268EA8;
		  /* 82268EA8h */ case    2:  		/* nop */
		/* 82268EA8h case    2:*/		cpu::op::nop();
		/* 82268EA8h case    2:*/		return 0x82268EAC;
		  /* 82268EACh */ case    3:  		/* nop */
		/* 82268EACh case    3:*/		cpu::op::nop();
		/* 82268EACh case    3:*/		return 0x82268EB0;
	}
	return 0x82268EB0;
} // Block from 82268EA0h-82268EB0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82268EB0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268EB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268EB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268EB0);
		  /* 82268EB0h */ case    0:  		/* mfspr R0, LR */
		/* 82268EB0h case    0:*/		regs.R0 = regs.LR;
		/* 82268EB0h case    0:*/		return 0x82268EB4;
		  /* 82268EB4h */ case    1:  		/* stwu R1, <#[R1 - 80]> */
		/* 82268EB4h case    1:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFB0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFB0);
		/* 82268EB4h case    1:*/		return 0x82268EB8;
		  /* 82268EB8h */ case    2:  		/* stw R0, <#[R1 + 8]> */
		/* 82268EB8h case    2:*/		cpu::mem::store32( regs, regs.R0, (uint32)(regs.R1 + 0x00000008) );
		/* 82268EB8h case    2:*/		return 0x82268EBC;
		  /* 82268EBCh */ case    3:  		/* mr R6, R4 */
		/* 82268EBCh case    3:*/		regs.R6 = regs.R4;
		/* 82268EBCh case    3:*/		return 0x82268EC0;
		  /* 82268EC0h */ case    4:  		/* cmpwi CR0, R4, 0 */
		/* 82268EC0h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R4,0x00000000);
		/* 82268EC0h case    4:*/		return 0x82268EC4;
		  /* 82268EC4h */ case    5:  		/* lwz R0, <#[R3 + 312]> */
		/* 82268EC4h case    5:*/		cpu::mem::load32z( regs, &regs.R0, (uint32)(regs.R3 + 0x00000138) );
		/* 82268EC4h case    5:*/		return 0x82268EC8;
		  /* 82268EC8h */ case    6:  		/* cmpwi CR1, R0, 0 */
		/* 82268EC8h case    6:*/		cpu::op::cmpwi<1>(regs,regs.R0,0x00000000);
		/* 82268EC8h case    6:*/		return 0x82268ECC;
		  /* 82268ECCh */ case    7:  		/* mr R7, R3 */
		/* 82268ECCh case    7:*/		regs.R7 = regs.R3;
		/* 82268ECCh case    7:*/		return 0x82268ED0;
		  /* 82268ED0h */ case    8:  		/* li R5, 0 */
		/* 82268ED0h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 82268ED0h case    8:*/		return 0x82268ED4;
		  /* 82268ED4h */ case    9:  		/* bc 4, CR0_EQ, 8 */
		/* 82268ED4h case    9:*/		if ( !regs.CR[0].eq ) { return 0x82268EDC;  }
		/* 82268ED4h case    9:*/		return 0x82268ED8;
		  /* 82268ED8h */ case   10:  		/* li R6, 1 */
		/* 82268ED8h case   10:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 82268ED8h case   10:*/		return 0x82268EDC;
	}
	return 0x82268EDC;
} // Block from 82268EB0h-82268EDCh (11 instructions)

//////////////////////////////////////////////////////
// Block at 82268EDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268EDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268EDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268EDC);
		  /* 82268EDCh */ case    0:  		/* bc 4, CR1_EQ, 704 */
		/* 82268EDCh case    0:*/		if ( !regs.CR[1].eq ) { return 0x8226919C;  }
		/* 82268EDCh case    0:*/		return 0x82268EE0;
		  /* 82268EE0h */ case    1:  		/* lwz R3, <#[R7 + 308]> */
		/* 82268EE0h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R7 + 0x00000134) );
		/* 82268EE0h case    1:*/		return 0x82268EE4;
		  /* 82268EE4h */ case    2:  		/* lwz R4, <#[R7 + 144]> */
		/* 82268EE4h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R7 + 0x00000090) );
		/* 82268EE4h case    2:*/		return 0x82268EE8;
		  /* 82268EE8h */ case    3:  		/* bl 2264 */
		/* 82268EE8h case    3:*/		regs.LR = 0x82268EEC; return 0x822697C0;
		/* 82268EE8h case    3:*/		return 0x82268EEC;
		  /* 82268EECh */ case    4:  		/* lfd FR14, <#[R7]> */
		/* 82268EECh case    4:*/		cpu::mem::load64f( regs, &regs.FR14, (uint32)(regs.R7 + 0x00000000) );
		/* 82268EECh case    4:*/		return 0x82268EF0;
		  /* 82268EF0h */ case    5:  		/* lfd FR15, <#[R7 + 8]> */
		/* 82268EF0h case    5:*/		cpu::mem::load64f( regs, &regs.FR15, (uint32)(regs.R7 + 0x00000008) );
		/* 82268EF0h case    5:*/		return 0x82268EF4;
		  /* 82268EF4h */ case    6:  		/* lfd FR16, <#[R7 + 16]> */
		/* 82268EF4h case    6:*/		cpu::mem::load64f( regs, &regs.FR16, (uint32)(regs.R7 + 0x00000010) );
		/* 82268EF4h case    6:*/		return 0x82268EF8;
		  /* 82268EF8h */ case    7:  		/* lfd FR17, <#[R7 + 24]> */
		/* 82268EF8h case    7:*/		cpu::mem::load64f( regs, &regs.FR17, (uint32)(regs.R7 + 0x00000018) );
		/* 82268EF8h case    7:*/		return 0x82268EFC;
		  /* 82268EFCh */ case    8:  		/* lfd FR18, <#[R7 + 32]> */
		/* 82268EFCh case    8:*/		cpu::mem::load64f( regs, &regs.FR18, (uint32)(regs.R7 + 0x00000020) );
		/* 82268EFCh case    8:*/		return 0x82268F00;
		  /* 82268F00h */ case    9:  		/* lfd FR19, <#[R7 + 40]> */
		/* 82268F00h case    9:*/		cpu::mem::load64f( regs, &regs.FR19, (uint32)(regs.R7 + 0x00000028) );
		/* 82268F00h case    9:*/		return 0x82268F04;
		  /* 82268F04h */ case   10:  		/* lfd FR20, <#[R7 + 48]> */
		/* 82268F04h case   10:*/		cpu::mem::load64f( regs, &regs.FR20, (uint32)(regs.R7 + 0x00000030) );
		/* 82268F04h case   10:*/		return 0x82268F08;
		  /* 82268F08h */ case   11:  		/* lfd FR21, <#[R7 + 56]> */
		/* 82268F08h case   11:*/		cpu::mem::load64f( regs, &regs.FR21, (uint32)(regs.R7 + 0x00000038) );
		/* 82268F08h case   11:*/		return 0x82268F0C;
		  /* 82268F0Ch */ case   12:  		/* lfd FR22, <#[R7 + 64]> */
		/* 82268F0Ch case   12:*/		cpu::mem::load64f( regs, &regs.FR22, (uint32)(regs.R7 + 0x00000040) );
		/* 82268F0Ch case   12:*/		return 0x82268F10;
		  /* 82268F10h */ case   13:  		/* lfd FR23, <#[R7 + 72]> */
		/* 82268F10h case   13:*/		cpu::mem::load64f( regs, &regs.FR23, (uint32)(regs.R7 + 0x00000048) );
		/* 82268F10h case   13:*/		return 0x82268F14;
		  /* 82268F14h */ case   14:  		/* lfd FR24, <#[R7 + 80]> */
		/* 82268F14h case   14:*/		cpu::mem::load64f( regs, &regs.FR24, (uint32)(regs.R7 + 0x00000050) );
		/* 82268F14h case   14:*/		return 0x82268F18;
		  /* 82268F18h */ case   15:  		/* lfd FR25, <#[R7 + 88]> */
		/* 82268F18h case   15:*/		cpu::mem::load64f( regs, &regs.FR25, (uint32)(regs.R7 + 0x00000058) );
		/* 82268F18h case   15:*/		return 0x82268F1C;
		  /* 82268F1Ch */ case   16:  		/* lfd FR26, <#[R7 + 96]> */
		/* 82268F1Ch case   16:*/		cpu::mem::load64f( regs, &regs.FR26, (uint32)(regs.R7 + 0x00000060) );
		/* 82268F1Ch case   16:*/		return 0x82268F20;
		  /* 82268F20h */ case   17:  		/* lfd FR27, <#[R7 + 104]> */
		/* 82268F20h case   17:*/		cpu::mem::load64f( regs, &regs.FR27, (uint32)(regs.R7 + 0x00000068) );
		/* 82268F20h case   17:*/		return 0x82268F24;
		  /* 82268F24h */ case   18:  		/* lfd FR28, <#[R7 + 112]> */
		/* 82268F24h case   18:*/		cpu::mem::load64f( regs, &regs.FR28, (uint32)(regs.R7 + 0x00000070) );
		/* 82268F24h case   18:*/		return 0x82268F28;
		  /* 82268F28h */ case   19:  		/* lfd FR29, <#[R7 + 120]> */
		/* 82268F28h case   19:*/		cpu::mem::load64f( regs, &regs.FR29, (uint32)(regs.R7 + 0x00000078) );
		/* 82268F28h case   19:*/		return 0x82268F2C;
		  /* 82268F2Ch */ case   20:  		/* lfd FR30, <#[R7 + 128]> */
		/* 82268F2Ch case   20:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R7 + 0x00000080) );
		/* 82268F2Ch case   20:*/		return 0x82268F30;
		  /* 82268F30h */ case   21:  		/* lfd FR31, <#[R7 + 136]> */
		/* 82268F30h case   21:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R7 + 0x00000088) );
		/* 82268F30h case   21:*/		return 0x82268F34;
		  /* 82268F34h */ case   22:  		/* ld R13, <#[R7 + 152]> */
		/* 82268F34h case   22:*/		cpu::mem::load64( regs, &regs.R13, (uint32)(regs.R7 + 0x00000098) );
		/* 82268F34h case   22:*/		return 0x82268F38;
		  /* 82268F38h */ case   23:  		/* ld R14, <#[R7 + 160]> */
		/* 82268F38h case   23:*/		cpu::mem::load64( regs, &regs.R14, (uint32)(regs.R7 + 0x000000A0) );
		/* 82268F38h case   23:*/		return 0x82268F3C;
		  /* 82268F3Ch */ case   24:  		/* ld R15, <#[R7 + 168]> */
		/* 82268F3Ch case   24:*/		cpu::mem::load64( regs, &regs.R15, (uint32)(regs.R7 + 0x000000A8) );
		/* 82268F3Ch case   24:*/		return 0x82268F40;
		  /* 82268F40h */ case   25:  		/* ld R16, <#[R7 + 176]> */
		/* 82268F40h case   25:*/		cpu::mem::load64( regs, &regs.R16, (uint32)(regs.R7 + 0x000000B0) );
		/* 82268F40h case   25:*/		return 0x82268F44;
		  /* 82268F44h */ case   26:  		/* ld R17, <#[R7 + 184]> */
		/* 82268F44h case   26:*/		cpu::mem::load64( regs, &regs.R17, (uint32)(regs.R7 + 0x000000B8) );
		/* 82268F44h case   26:*/		return 0x82268F48;
		  /* 82268F48h */ case   27:  		/* ld R18, <#[R7 + 192]> */
		/* 82268F48h case   27:*/		cpu::mem::load64( regs, &regs.R18, (uint32)(regs.R7 + 0x000000C0) );
		/* 82268F48h case   27:*/		return 0x82268F4C;
		  /* 82268F4Ch */ case   28:  		/* ld R19, <#[R7 + 200]> */
		/* 82268F4Ch case   28:*/		cpu::mem::load64( regs, &regs.R19, (uint32)(regs.R7 + 0x000000C8) );
		/* 82268F4Ch case   28:*/		return 0x82268F50;
		  /* 82268F50h */ case   29:  		/* ld R20, <#[R7 + 208]> */
		/* 82268F50h case   29:*/		cpu::mem::load64( regs, &regs.R20, (uint32)(regs.R7 + 0x000000D0) );
		/* 82268F50h case   29:*/		return 0x82268F54;
		  /* 82268F54h */ case   30:  		/* ld R21, <#[R7 + 216]> */
		/* 82268F54h case   30:*/		cpu::mem::load64( regs, &regs.R21, (uint32)(regs.R7 + 0x000000D8) );
		/* 82268F54h case   30:*/		return 0x82268F58;
		  /* 82268F58h */ case   31:  		/* ld R22, <#[R7 + 224]> */
		/* 82268F58h case   31:*/		cpu::mem::load64( regs, &regs.R22, (uint32)(regs.R7 + 0x000000E0) );
		/* 82268F58h case   31:*/		return 0x82268F5C;
		  /* 82268F5Ch */ case   32:  		/* ld R23, <#[R7 + 232]> */
		/* 82268F5Ch case   32:*/		cpu::mem::load64( regs, &regs.R23, (uint32)(regs.R7 + 0x000000E8) );
		/* 82268F5Ch case   32:*/		return 0x82268F60;
		  /* 82268F60h */ case   33:  		/* ld R24, <#[R7 + 240]> */
		/* 82268F60h case   33:*/		cpu::mem::load64( regs, &regs.R24, (uint32)(regs.R7 + 0x000000F0) );
		/* 82268F60h case   33:*/		return 0x82268F64;
		  /* 82268F64h */ case   34:  		/* ld R25, <#[R7 + 248]> */
		/* 82268F64h case   34:*/		cpu::mem::load64( regs, &regs.R25, (uint32)(regs.R7 + 0x000000F8) );
		/* 82268F64h case   34:*/		return 0x82268F68;
		  /* 82268F68h */ case   35:  		/* ld R26, <#[R7 + 256]> */
		/* 82268F68h case   35:*/		cpu::mem::load64( regs, &regs.R26, (uint32)(regs.R7 + 0x00000100) );
		/* 82268F68h case   35:*/		return 0x82268F6C;
		  /* 82268F6Ch */ case   36:  		/* ld R27, <#[R7 + 264]> */
		/* 82268F6Ch case   36:*/		cpu::mem::load64( regs, &regs.R27, (uint32)(regs.R7 + 0x00000108) );
		/* 82268F6Ch case   36:*/		return 0x82268F70;
	}
	return 0x82268F70;
} // Block from 82268EDCh-82268F70h (37 instructions)

//////////////////////////////////////////////////////
// Block at 82268F70h
// Function 'sinh'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82268F70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82268F70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82268F70);
		  /* 82268F70h */ case    0:  		/* ld R28, <#[R7 + 272]> */
		/* 82268F70h case    0:*/		cpu::mem::load64( regs, &regs.R28, (uint32)(regs.R7 + 0x00000110) );
		/* 82268F70h case    0:*/		return 0x82268F74;
		  /* 82268F74h */ case    1:  		/* ld R29, <#[R7 + 280]> */
		/* 82268F74h case    1:*/		cpu::mem::load64( regs, &regs.R29, (uint32)(regs.R7 + 0x00000118) );
		/* 82268F74h case    1:*/		return 0x82268F78;
		  /* 82268F78h */ case    2:  		/* ld R30, <#[R7 + 288]> */
		/* 82268F78h case    2:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R7 + 0x00000120) );
		/* 82268F78h case    2:*/		return 0x82268F7C;
		  /* 82268F7Ch */ case    3:  		/* ld R31, <#[R7 + 296]> */
		/* 82268F7Ch case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R7 + 0x00000128) );
		/* 82268F7Ch case    3:*/		return 0x82268F80;
		  /* 82268F80h */ case    4:  		/* li R3, 320 */
		/* 82268F80h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x140);
		/* 82268F80h case    4:*/		return 0x82268F84;
		  /* 82268F84h */ case    5:  		/* lvx VR64, <#[R3 + R7]> */
		/* 82268F84h case    5:*/		cpu::mem::lvx( regs, &regs.VR64, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 82268F84h case    5:*/		return 0x82268F88;
		  /* 82268F88h */ case    6:  		/* li R3, 336 */
		/* 82268F88h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x150);
		/* 82268F88h case    6:*/		return 0x82268F8C;
		  /* 82268F8Ch */ case    7:  		/* lvx VR65, <#[R3 + R7]> */
		/* 82268F8Ch case    7:*/		cpu::mem::lvx( regs, &regs.VR65, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 82268F8Ch case    7:*/		return 0x82268F90;
		  /* 82268F90h */ case    8:  		/* li R3, 352 */
		/* 82268F90h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x160);
		/* 82268F90h case    8:*/		return 0x82268F94;
		  /* 82268F94h */ case    9:  		/* lvx VR66, <#[R3 + R7]> */
		/* 82268F94h case    9:*/		cpu::mem::lvx( regs, &regs.VR66, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 82268F94h case    9:*/		return 0x82268F98;
		  /* 82268F98h */ case   10:  		/* li R3, 368 */
		/* 82268F98h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x170);
		/* 82268F98h case   10:*/		return 0x82268F9C;
		  /* 82268F9Ch */ case   11:  		/* lvx VR67, <#[R3 + R7]> */
		/* 82268F9Ch case   11:*/		cpu::mem::lvx( regs, &regs.VR67, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 82268F9Ch case   11:*/		return 0x82268FA0;
		  /* 82268FA0h */ case   12:  		/* li R3, 384 */
		/* 82268FA0h case   12:*/		cpu::op::li<0>(regs,&regs.R3,0x180);
		/* 82268FA0h case   12:*/		return 0x82268FA4;
		  /* 82268FA4h */ case   13:  		/* lvx VR68, <#[R3 + R7]> */
		/* 82268FA4h case   13:*/		cpu::mem::lvx( regs, &regs.VR68, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 82268FA4h case   13:*/		return 0x82268FA8;
		  /* 82268FA8h */ case   14:  		/* li R3, 400 */
		/* 82268FA8h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x190);
		/* 82268FA8h case   14:*/		return 0x82268FAC;
		  /* 82268FACh */ case   15:  		/* lvx VR69, <#[R3 + R7]> */
		/* 82268FACh case   15:*/		cpu::mem::lvx( regs, &regs.VR69, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 82268FACh case   15:*/		return 0x82268FB0;
		  /* 82268FB0h */ case   16:  		/* li R3, 416 */
		/* 82268FB0h case   16:*/		cpu::op::li<0>(regs,&regs.R3,0x1A0);
		/* 82268FB0h case   16:*/		return 0x82268FB4;
		  /* 82268FB4h */ case   17:  		/* lvx VR70, <#[R3 + R7]> */
		/* 82268FB4h case   17:*/		cpu::mem::lvx( regs, &regs.VR70, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 82268FB4h case   17:*/		return 0x82268FB8;
		  /* 82268FB8h */ case   18:  		/* li R3, 432 */
		/* 82268FB8h case   18:*/		cpu::op::li<0>(regs,&regs.R3,0x1B0);
		/* 82268FB8h case   18:*/		return 0x82268FBC;
		  /* 82268FBCh */ case   19:  		/* lvx VR71, <#[R3 + R7]> */
		/* 82268FBCh case   19:*/		cpu::mem::lvx( regs, &regs.VR71, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 82268FBCh case   19:*/		return 0x82268FC0;
		  /* 82268FC0h */ case   20:  		/* li R3, 448 */
		/* 82268FC0h case   20:*/		cpu::op::li<0>(regs,&regs.R3,0x1C0);
		/* 82268FC0h case   20:*/		return 0x82268FC4;
		  /* 82268FC4h */ case   21:  		/* lvx VR72, <#[R3 + R7]> */
		/* 82268FC4h case   21:*/		cpu::mem::lvx( regs, &regs.VR72, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 82268FC4h case   21:*/		return 0x82268FC8;
		  /* 82268FC8h */ case   22:  		/* li R3, 464 */
		/* 82268FC8h case   22:*/		cpu::op::li<0>(regs,&regs.R3,0x1D0);
		/* 82268FC8h case   22:*/		return 0x82268FCC;
		  /* 82268FCCh */ case   23:  		/* lvx VR73, <#[R3 + R7]> */
		/* 82268FCCh case   23:*/		cpu::mem::lvx( regs, &regs.VR73, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 82268FCCh case   23:*/		return 0x82268FD0;
		  /* 82268FD0h */ case   24:  		/* li R3, 480 */
		/* 82268FD0h case   24:*/		cpu::op::li<0>(regs,&regs.R3,0x1E0);
		/* 82268FD0h case   24:*/		return 0x82268FD4;
		  /* 82268FD4h */ case   25:  		/* lvx VR74, <#[R3 + R7]> */
		/* 82268FD4h case   25:*/		cpu::mem::lvx( regs, &regs.VR74, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 82268FD4h case   25:*/		return 0x82268FD8;
		  /* 82268FD8h */ case   26:  		/* li R3, 496 */
		/* 82268FD8h case   26:*/		cpu::op::li<0>(regs,&regs.R3,0x1F0);
		/* 82268FD8h case   26:*/		return 0x82268FDC;
		  /* 82268FDCh */ case   27:  		/* lvx VR75, <#[R3 + R7]> */
		/* 82268FDCh case   27:*/		cpu::mem::lvx( regs, &regs.VR75, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 82268FDCh case   27:*/		return 0x82268FE0;
		  /* 82268FE0h */ case   28:  		/* li R3, 512 */
		/* 82268FE0h case   28:*/		cpu::op::li<0>(regs,&regs.R3,0x200);
		/* 82268FE0h case   28:*/		return 0x82268FE4;
		  /* 82268FE4h */ case   29:  		/* lvx VR76, <#[R3 + R7]> */
		/* 82268FE4h case   29:*/		cpu::mem::lvx( regs, &regs.VR76, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 82268FE4h case   29:*/		return 0x82268FE8;
		  /* 82268FE8h */ case   30:  		/* li R3, 528 */
		/* 82268FE8h case   30:*/		cpu::op::li<0>(regs,&regs.R3,0x210);
		/* 82268FE8h case   30:*/		return 0x82268FEC;
		  /* 82268FECh */ case   31:  		/* lvx VR77, <#[R3 + R7]> */
		/* 82268FECh case   31:*/		cpu::mem::lvx( regs, &regs.VR77, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 82268FECh case   31:*/		return 0x82268FF0;
		  /* 82268FF0h */ case   32:  		/* li R3, 544 */
		/* 82268FF0h case   32:*/		cpu::op::li<0>(regs,&regs.R3,0x220);
		/* 82268FF0h case   32:*/		return 0x82268FF4;
		  /* 82268FF4h */ case   33:  		/* lvx VR78, <#[R3 + R7]> */
		/* 82268FF4h case   33:*/		cpu::mem::lvx( regs, &regs.VR78, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 82268FF4h case   33:*/		return 0x82268FF8;
		  /* 82268FF8h */ case   34:  		/* li R3, 560 */
		/* 82268FF8h case   34:*/		cpu::op::li<0>(regs,&regs.R3,0x230);
		/* 82268FF8h case   34:*/		return 0x82268FFC;
		  /* 82268FFCh */ case   35:  		/* lvx VR79, <#[R3 + R7]> */
		/* 82268FFCh case   35:*/		cpu::mem::lvx( regs, &regs.VR79, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 82268FFCh case   35:*/		return 0x82269000;
		  /* 82269000h */ case   36:  		/* li R3, 576 */
		/* 82269000h case   36:*/		cpu::op::li<0>(regs,&regs.R3,0x240);
		/* 82269000h case   36:*/		return 0x82269004;
		  /* 82269004h */ case   37:  		/* lvx VR80, <#[R3 + R7]> */
		/* 82269004h case   37:*/		cpu::mem::lvx( regs, &regs.VR80, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 82269004h case   37:*/		return 0x82269008;
		  /* 82269008h */ case   38:  		/* li R3, 592 */
		/* 82269008h case   38:*/		cpu::op::li<0>(regs,&regs.R3,0x250);
		/* 82269008h case   38:*/		return 0x8226900C;
		  /* 8226900Ch */ case   39:  		/* lvx VR81, <#[R3 + R7]> */
		/* 8226900Ch case   39:*/		cpu::mem::lvx( regs, &regs.VR81, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 8226900Ch case   39:*/		return 0x82269010;
		  /* 82269010h */ case   40:  		/* li R3, 608 */
		/* 82269010h case   40:*/		cpu::op::li<0>(regs,&regs.R3,0x260);
		/* 82269010h case   40:*/		return 0x82269014;
		  /* 82269014h */ case   41:  		/* lvx VR82, <#[R3 + R7]> */
		/* 82269014h case   41:*/		cpu::mem::lvx( regs, &regs.VR82, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 82269014h case   41:*/		return 0x82269018;
		  /* 82269018h */ case   42:  		/* li R3, 624 */
		/* 82269018h case   42:*/		cpu::op::li<0>(regs,&regs.R3,0x270);
		/* 82269018h case   42:*/		return 0x8226901C;
		  /* 8226901Ch */ case   43:  		/* lvx VR83, <#[R3 + R7]> */
		/* 8226901Ch case   43:*/		cpu::mem::lvx( regs, &regs.VR83, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 8226901Ch case   43:*/		return 0x82269020;
		  /* 82269020h */ case   44:  		/* li R3, 640 */
		/* 82269020h case   44:*/		cpu::op::li<0>(regs,&regs.R3,0x280);
		/* 82269020h case   44:*/		return 0x82269024;
		  /* 82269024h */ case   45:  		/* lvx VR84, <#[R3 + R7]> */
		/* 82269024h case   45:*/		cpu::mem::lvx( regs, &regs.VR84, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 82269024h case   45:*/		return 0x82269028;
		  /* 82269028h */ case   46:  		/* li R3, 656 */
		/* 82269028h case   46:*/		cpu::op::li<0>(regs,&regs.R3,0x290);
		/* 82269028h case   46:*/		return 0x8226902C;
		  /* 8226902Ch */ case   47:  		/* lvx VR85, <#[R3 + R7]> */
		/* 8226902Ch case   47:*/		cpu::mem::lvx( regs, &regs.VR85, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 8226902Ch case   47:*/		return 0x82269030;
		  /* 82269030h */ case   48:  		/* li R3, 672 */
		/* 82269030h case   48:*/		cpu::op::li<0>(regs,&regs.R3,0x2A0);
		/* 82269030h case   48:*/		return 0x82269034;
		  /* 82269034h */ case   49:  		/* lvx VR86, <#[R3 + R7]> */
		/* 82269034h case   49:*/		cpu::mem::lvx( regs, &regs.VR86, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 82269034h case   49:*/		return 0x82269038;
		  /* 82269038h */ case   50:  		/* li R3, 688 */
		/* 82269038h case   50:*/		cpu::op::li<0>(regs,&regs.R3,0x2B0);
		/* 82269038h case   50:*/		return 0x8226903C;
		  /* 8226903Ch */ case   51:  		/* lvx VR87, <#[R3 + R7]> */
		/* 8226903Ch case   51:*/		cpu::mem::lvx( regs, &regs.VR87, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 8226903Ch case   51:*/		return 0x82269040;
		  /* 82269040h */ case   52:  		/* li R3, 704 */
		/* 82269040h case   52:*/		cpu::op::li<0>(regs,&regs.R3,0x2C0);
		/* 82269040h case   52:*/		return 0x82269044;
		  /* 82269044h */ case   53:  		/* lvx VR88, <#[R3 + R7]> */
		/* 82269044h case   53:*/		cpu::mem::lvx( regs, &regs.VR88, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 82269044h case   53:*/		return 0x82269048;
		  /* 82269048h */ case   54:  		/* li R3, 720 */
		/* 82269048h case   54:*/		cpu::op::li<0>(regs,&regs.R3,0x2D0);
		/* 82269048h case   54:*/		return 0x8226904C;
		  /* 8226904Ch */ case   55:  		/* lvx VR89, <#[R3 + R7]> */
		/* 8226904Ch case   55:*/		cpu::mem::lvx( regs, &regs.VR89, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 8226904Ch case   55:*/		return 0x82269050;
		  /* 82269050h */ case   56:  		/* li R3, 736 */
		/* 82269050h case   56:*/		cpu::op::li<0>(regs,&regs.R3,0x2E0);
		/* 82269050h case   56:*/		return 0x82269054;
		  /* 82269054h */ case   57:  		/* lvx VR90, <#[R3 + R7]> */
		/* 82269054h case   57:*/		cpu::mem::lvx( regs, &regs.VR90, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 82269054h case   57:*/		return 0x82269058;
		  /* 82269058h */ case   58:  		/* li R3, 752 */
		/* 82269058h case   58:*/		cpu::op::li<0>(regs,&regs.R3,0x2F0);
		/* 82269058h case   58:*/		return 0x8226905C;
		  /* 8226905Ch */ case   59:  		/* lvx VR91, <#[R3 + R7]> */
		/* 8226905Ch case   59:*/		cpu::mem::lvx( regs, &regs.VR91, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 8226905Ch case   59:*/		return 0x82269060;
		  /* 82269060h */ case   60:  		/* li R3, 768 */
		/* 82269060h case   60:*/		cpu::op::li<0>(regs,&regs.R3,0x300);
		/* 82269060h case   60:*/		return 0x82269064;
		  /* 82269064h */ case   61:  		/* lvx VR92, <#[R3 + R7]> */
		/* 82269064h case   61:*/		cpu::mem::lvx( regs, &regs.VR92, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 82269064h case   61:*/		return 0x82269068;
		  /* 82269068h */ case   62:  		/* li R3, 784 */
		/* 82269068h case   62:*/		cpu::op::li<0>(regs,&regs.R3,0x310);
		/* 82269068h case   62:*/		return 0x8226906C;
		  /* 8226906Ch */ case   63:  		/* lvx VR93, <#[R3 + R7]> */
		/* 8226906Ch case   63:*/		cpu::mem::lvx( regs, &regs.VR93, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 8226906Ch case   63:*/		return 0x82269070;
		  /* 82269070h */ case   64:  		/* li R3, 800 */
		/* 82269070h case   64:*/		cpu::op::li<0>(regs,&regs.R3,0x320);
		/* 82269070h case   64:*/		return 0x82269074;
		  /* 82269074h */ case   65:  		/* lvx VR94, <#[R3 + R7]> */
		/* 82269074h case   65:*/		cpu::mem::lvx( regs, &regs.VR94, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 82269074h case   65:*/		return 0x82269078;
		  /* 82269078h */ case   66:  		/* li R3, 816 */
		/* 82269078h case   66:*/		cpu::op::li<0>(regs,&regs.R3,0x330);
		/* 82269078h case   66:*/		return 0x8226907C;
		  /* 8226907Ch */ case   67:  		/* lvx VR95, <#[R3 + R7]> */
		/* 8226907Ch case   67:*/		cpu::mem::lvx( regs, &regs.VR95, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 8226907Ch case   67:*/		return 0x82269080;
		  /* 82269080h */ case   68:  		/* li R3, 832 */
		/* 82269080h case   68:*/		cpu::op::li<0>(regs,&regs.R3,0x340);
		/* 82269080h case   68:*/		return 0x82269084;
		  /* 82269084h */ case   69:  		/* lvx VR96, <#[R3 + R7]> */
		/* 82269084h case   69:*/		cpu::mem::lvx( regs, &regs.VR96, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 82269084h case   69:*/		return 0x82269088;
		  /* 82269088h */ case   70:  		/* li R3, 848 */
		/* 82269088h case   70:*/		cpu::op::li<0>(regs,&regs.R3,0x350);
		/* 82269088h case   70:*/		return 0x8226908C;
		  /* 8226908Ch */ case   71:  		/* lvx VR97, <#[R3 + R7]> */
		/* 8226908Ch case   71:*/		cpu::mem::lvx( regs, &regs.VR97, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 8226908Ch case   71:*/		return 0x82269090;
		  /* 82269090h */ case   72:  		/* li R3, 864 */
		/* 82269090h case   72:*/		cpu::op::li<0>(regs,&regs.R3,0x360);
		/* 82269090h case   72:*/		return 0x82269094;
		  /* 82269094h */ case   73:  		/* lvx VR98, <#[R3 + R7]> */
		/* 82269094h case   73:*/		cpu::mem::lvx( regs, &regs.VR98, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 82269094h case   73:*/		return 0x82269098;
		  /* 82269098h */ case   74:  		/* li R3, 880 */
		/* 82269098h case   74:*/		cpu::op::li<0>(regs,&regs.R3,0x370);
		/* 82269098h case   74:*/		return 0x8226909C;
		  /* 8226909Ch */ case   75:  		/* lvx VR99, <#[R3 + R7]> */
		/* 8226909Ch case   75:*/		cpu::mem::lvx( regs, &regs.VR99, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 8226909Ch case   75:*/		return 0x822690A0;
		  /* 822690A0h */ case   76:  		/* li R3, 896 */
		/* 822690A0h case   76:*/		cpu::op::li<0>(regs,&regs.R3,0x380);
		/* 822690A0h case   76:*/		return 0x822690A4;
		  /* 822690A4h */ case   77:  		/* lvx VR100, <#[R3 + R7]> */
		/* 822690A4h case   77:*/		cpu::mem::lvx( regs, &regs.VR100, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 822690A4h case   77:*/		return 0x822690A8;
		  /* 822690A8h */ case   78:  		/* li R3, 912 */
		/* 822690A8h case   78:*/		cpu::op::li<0>(regs,&regs.R3,0x390);
		/* 822690A8h case   78:*/		return 0x822690AC;
		  /* 822690ACh */ case   79:  		/* lvx VR101, <#[R3 + R7]> */
		/* 822690ACh case   79:*/		cpu::mem::lvx( regs, &regs.VR101, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 822690ACh case   79:*/		return 0x822690B0;
		  /* 822690B0h */ case   80:  		/* li R3, 928 */
		/* 822690B0h case   80:*/		cpu::op::li<0>(regs,&regs.R3,0x3A0);
		/* 822690B0h case   80:*/		return 0x822690B4;
		  /* 822690B4h */ case   81:  		/* lvx VR102, <#[R3 + R7]> */
		/* 822690B4h case   81:*/		cpu::mem::lvx( regs, &regs.VR102, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 822690B4h case   81:*/		return 0x822690B8;
		  /* 822690B8h */ case   82:  		/* li R3, 944 */
		/* 822690B8h case   82:*/		cpu::op::li<0>(regs,&regs.R3,0x3B0);
		/* 822690B8h case   82:*/		return 0x822690BC;
		  /* 822690BCh */ case   83:  		/* lvx VR103, <#[R3 + R7]> */
		/* 822690BCh case   83:*/		cpu::mem::lvx( regs, &regs.VR103, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 822690BCh case   83:*/		return 0x822690C0;
		  /* 822690C0h */ case   84:  		/* li R3, 960 */
		/* 822690C0h case   84:*/		cpu::op::li<0>(regs,&regs.R3,0x3C0);
		/* 822690C0h case   84:*/		return 0x822690C4;
		  /* 822690C4h */ case   85:  		/* lvx VR104, <#[R3 + R7]> */
		/* 822690C4h case   85:*/		cpu::mem::lvx( regs, &regs.VR104, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 822690C4h case   85:*/		return 0x822690C8;
		  /* 822690C8h */ case   86:  		/* li R3, 976 */
		/* 822690C8h case   86:*/		cpu::op::li<0>(regs,&regs.R3,0x3D0);
		/* 822690C8h case   86:*/		return 0x822690CC;
		  /* 822690CCh */ case   87:  		/* lvx VR105, <#[R3 + R7]> */
		/* 822690CCh case   87:*/		cpu::mem::lvx( regs, &regs.VR105, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 822690CCh case   87:*/		return 0x822690D0;
		  /* 822690D0h */ case   88:  		/* li R3, 992 */
		/* 822690D0h case   88:*/		cpu::op::li<0>(regs,&regs.R3,0x3E0);
		/* 822690D0h case   88:*/		return 0x822690D4;
		  /* 822690D4h */ case   89:  		/* lvx VR106, <#[R3 + R7]> */
		/* 822690D4h case   89:*/		cpu::mem::lvx( regs, &regs.VR106, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 822690D4h case   89:*/		return 0x822690D8;
		  /* 822690D8h */ case   90:  		/* li R3, 1008 */
		/* 822690D8h case   90:*/		cpu::op::li<0>(regs,&regs.R3,0x3F0);
		/* 822690D8h case   90:*/		return 0x822690DC;
		  /* 822690DCh */ case   91:  		/* lvx VR107, <#[R3 + R7]> */
		/* 822690DCh case   91:*/		cpu::mem::lvx( regs, &regs.VR107, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 822690DCh case   91:*/		return 0x822690E0;
		  /* 822690E0h */ case   92:  		/* li R3, 1024 */
		/* 822690E0h case   92:*/		cpu::op::li<0>(regs,&regs.R3,0x400);
		/* 822690E0h case   92:*/		return 0x822690E4;
		  /* 822690E4h */ case   93:  		/* lvx VR108, <#[R3 + R7]> */
		/* 822690E4h case   93:*/		cpu::mem::lvx( regs, &regs.VR108, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 822690E4h case   93:*/		return 0x822690E8;
		  /* 822690E8h */ case   94:  		/* li R3, 1040 */
		/* 822690E8h case   94:*/		cpu::op::li<0>(regs,&regs.R3,0x410);
		/* 822690E8h case   94:*/		return 0x822690EC;
		  /* 822690ECh */ case   95:  		/* lvx VR109, <#[R3 + R7]> */
		/* 822690ECh case   95:*/		cpu::mem::lvx( regs, &regs.VR109, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 822690ECh case   95:*/		return 0x822690F0;
		  /* 822690F0h */ case   96:  		/* li R3, 1056 */
		/* 822690F0h case   96:*/		cpu::op::li<0>(regs,&regs.R3,0x420);
		/* 822690F0h case   96:*/		return 0x822690F4;
		  /* 822690F4h */ case   97:  		/* lvx VR110, <#[R3 + R7]> */
		/* 822690F4h case   97:*/		cpu::mem::lvx( regs, &regs.VR110, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 822690F4h case   97:*/		return 0x822690F8;
		  /* 822690F8h */ case   98:  		/* li R3, 1072 */
		/* 822690F8h case   98:*/		cpu::op::li<0>(regs,&regs.R3,0x430);
		/* 822690F8h case   98:*/		return 0x822690FC;
		  /* 822690FCh */ case   99:  		/* lvx VR111, <#[R3 + R7]> */
		/* 822690FCh case   99:*/		cpu::mem::lvx( regs, &regs.VR111, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 822690FCh case   99:*/		return 0x82269100;
		  /* 82269100h */ case  100:  		/* li R3, 1088 */
		/* 82269100h case  100:*/		cpu::op::li<0>(regs,&regs.R3,0x440);
		/* 82269100h case  100:*/		return 0x82269104;
		  /* 82269104h */ case  101:  		/* lvx VR112, <#[R3 + R7]> */
		/* 82269104h case  101:*/		cpu::mem::lvx( regs, &regs.VR112, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 82269104h case  101:*/		return 0x82269108;
		  /* 82269108h */ case  102:  		/* li R3, 1104 */
		/* 82269108h case  102:*/		cpu::op::li<0>(regs,&regs.R3,0x450);
		/* 82269108h case  102:*/		return 0x8226910C;
		  /* 8226910Ch */ case  103:  		/* lvx VR113, <#[R3 + R7]> */
		/* 8226910Ch case  103:*/		cpu::mem::lvx( regs, &regs.VR113, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 8226910Ch case  103:*/		return 0x82269110;
		  /* 82269110h */ case  104:  		/* li R3, 1120 */
		/* 82269110h case  104:*/		cpu::op::li<0>(regs,&regs.R3,0x460);
		/* 82269110h case  104:*/		return 0x82269114;
		  /* 82269114h */ case  105:  		/* lvx VR114, <#[R3 + R7]> */
		/* 82269114h case  105:*/		cpu::mem::lvx( regs, &regs.VR114, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 82269114h case  105:*/		return 0x82269118;
		  /* 82269118h */ case  106:  		/* li R3, 1136 */
		/* 82269118h case  106:*/		cpu::op::li<0>(regs,&regs.R3,0x470);
		/* 82269118h case  106:*/		return 0x8226911C;
		  /* 8226911Ch */ case  107:  		/* lvx VR115, <#[R3 + R7]> */
		/* 8226911Ch case  107:*/		cpu::mem::lvx( regs, &regs.VR115, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 8226911Ch case  107:*/		return 0x82269120;
		  /* 82269120h */ case  108:  		/* li R3, 1152 */
		/* 82269120h case  108:*/		cpu::op::li<0>(regs,&regs.R3,0x480);
		/* 82269120h case  108:*/		return 0x82269124;
		  /* 82269124h */ case  109:  		/* lvx VR116, <#[R3 + R7]> */
		/* 82269124h case  109:*/		cpu::mem::lvx( regs, &regs.VR116, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 82269124h case  109:*/		return 0x82269128;
		  /* 82269128h */ case  110:  		/* li R3, 1168 */
		/* 82269128h case  110:*/		cpu::op::li<0>(regs,&regs.R3,0x490);
		/* 82269128h case  110:*/		return 0x8226912C;
		  /* 8226912Ch */ case  111:  		/* lvx VR117, <#[R3 + R7]> */
		/* 8226912Ch case  111:*/		cpu::mem::lvx( regs, &regs.VR117, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 8226912Ch case  111:*/		return 0x82269130;
		  /* 82269130h */ case  112:  		/* li R3, 1184 */
		/* 82269130h case  112:*/		cpu::op::li<0>(regs,&regs.R3,0x4A0);
		/* 82269130h case  112:*/		return 0x82269134;
		  /* 82269134h */ case  113:  		/* lvx VR118, <#[R3 + R7]> */
		/* 82269134h case  113:*/		cpu::mem::lvx( regs, &regs.VR118, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 82269134h case  113:*/		return 0x82269138;
		  /* 82269138h */ case  114:  		/* li R3, 1200 */
		/* 82269138h case  114:*/		cpu::op::li<0>(regs,&regs.R3,0x4B0);
		/* 82269138h case  114:*/		return 0x8226913C;
		  /* 8226913Ch */ case  115:  		/* lvx VR119, <#[R3 + R7]> */
		/* 8226913Ch case  115:*/		cpu::mem::lvx( regs, &regs.VR119, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 8226913Ch case  115:*/		return 0x82269140;
		  /* 82269140h */ case  116:  		/* li R3, 1216 */
		/* 82269140h case  116:*/		cpu::op::li<0>(regs,&regs.R3,0x4C0);
		/* 82269140h case  116:*/		return 0x82269144;
		  /* 82269144h */ case  117:  		/* lvx VR120, <#[R3 + R7]> */
		/* 82269144h case  117:*/		cpu::mem::lvx( regs, &regs.VR120, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 82269144h case  117:*/		return 0x82269148;
		  /* 82269148h */ case  118:  		/* li R3, 1232 */
		/* 82269148h case  118:*/		cpu::op::li<0>(regs,&regs.R3,0x4D0);
		/* 82269148h case  118:*/		return 0x8226914C;
		  /* 8226914Ch */ case  119:  		/* lvx VR121, <#[R3 + R7]> */
		/* 8226914Ch case  119:*/		cpu::mem::lvx( regs, &regs.VR121, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 8226914Ch case  119:*/		return 0x82269150;
		  /* 82269150h */ case  120:  		/* li R3, 1248 */
		/* 82269150h case  120:*/		cpu::op::li<0>(regs,&regs.R3,0x4E0);
		/* 82269150h case  120:*/		return 0x82269154;
		  /* 82269154h */ case  121:  		/* lvx VR122, <#[R3 + R7]> */
		/* 82269154h case  121:*/		cpu::mem::lvx( regs, &regs.VR122, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 82269154h case  121:*/		return 0x82269158;
		  /* 82269158h */ case  122:  		/* li R3, 1264 */
		/* 82269158h case  122:*/		cpu::op::li<0>(regs,&regs.R3,0x4F0);
		/* 82269158h case  122:*/		return 0x8226915C;
		  /* 8226915Ch */ case  123:  		/* lvx VR123, <#[R3 + R7]> */
		/* 8226915Ch case  123:*/		cpu::mem::lvx( regs, &regs.VR123, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 8226915Ch case  123:*/		return 0x82269160;
		  /* 82269160h */ case  124:  		/* li R3, 1280 */
		/* 82269160h case  124:*/		cpu::op::li<0>(regs,&regs.R3,0x500);
		/* 82269160h case  124:*/		return 0x82269164;
		  /* 82269164h */ case  125:  		/* lvx VR124, <#[R3 + R7]> */
		/* 82269164h case  125:*/		cpu::mem::lvx( regs, &regs.VR124, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 82269164h case  125:*/		return 0x82269168;
		  /* 82269168h */ case  126:  		/* li R3, 1296 */
		/* 82269168h case  126:*/		cpu::op::li<0>(regs,&regs.R3,0x510);
		/* 82269168h case  126:*/		return 0x8226916C;
		  /* 8226916Ch */ case  127:  		/* lvx VR125, <#[R3 + R7]> */
		/* 8226916Ch case  127:*/		cpu::mem::lvx( regs, &regs.VR125, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 8226916Ch case  127:*/		return 0x82269170;
		  /* 82269170h */ case  128:  		/* li R3, 1312 */
		/* 82269170h case  128:*/		cpu::op::li<0>(regs,&regs.R3,0x520);
		/* 82269170h case  128:*/		return 0x82269174;
		  /* 82269174h */ case  129:  		/* lvx VR126, <#[R3 + R7]> */
		/* 82269174h case  129:*/		cpu::mem::lvx( regs, &regs.VR126, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 82269174h case  129:*/		return 0x82269178;
		  /* 82269178h */ case  130:  		/* li R3, 1328 */
		/* 82269178h case  130:*/		cpu::op::li<0>(regs,&regs.R3,0x530);
		/* 82269178h case  130:*/		return 0x8226917C;
		  /* 8226917Ch */ case  131:  		/* lvx VR127, <#[R3 + R7]> */
		/* 8226917Ch case  131:*/		cpu::mem::lvx( regs, &regs.VR127, (uint32)(regs.R3 + regs.R7 + 0x00000000) );
		/* 8226917Ch case  131:*/		return 0x82269180;
		  /* 82269180h */ case  132:  		/* lwz R5, <#[R7 + 308]> */
		/* 82269180h case  132:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R7 + 0x00000134) );
		/* 82269180h case  132:*/		return 0x82269184;
		  /* 82269184h */ case  133:  		/* lwz R4, <#[R7 + 304]> */
		/* 82269184h case  133:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R7 + 0x00000130) );
		/* 82269184h case  133:*/		return 0x82269188;
		  /* 82269188h */ case  134:  		/* mtspr LR, R5 */
		/* 82269188h case  134:*/		regs.LR = regs.R5;
		/* 82269188h case  134:*/		return 0x8226918C;
		  /* 8226918Ch */ case  135:  		/* ld R1, <#[R7 + 144]> */
		/* 8226918Ch case  135:*/		cpu::mem::load64( regs, &regs.R1, (uint32)(regs.R7 + 0x00000090) );
		/* 8226918Ch case  135:*/		return 0x82269190;
		  /* 82269190h */ case  136:  		/* mtcrf 255, R4 */
		/* 82269190h case  136:*/		cpu::op::mtcrf<0>(regs,0xFF,regs.R4);
		/* 82269190h case  136:*/		return 0x82269194;
		  /* 82269194h */ case  137:  		/* mr R3, R6 */
		/* 82269194h case  137:*/		regs.R3 = regs.R6;
		/* 82269194h case  137:*/		return 0x82269198;
		  /* 82269198h */ case  138:  		/* bclr 20, CR0_LT */
		/* 82269198h case  138:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82269198h case  138:*/		return 0x8226919C;
	}
	return 0x8226919C;
} // Block from 82268F70h-8226919Ch (139 instructions)

//////////////////////////////////////////////////////
// Block at 8226919Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226919C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226919C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226919C);
		  /* 8226919Ch */ case    0:  		/* lwz R3, <#[R7 + 4]> */
		/* 8226919Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R7 + 0x00000004) );
		/* 8226919Ch case    0:*/		return 0x822691A0;
		  /* 822691A0h */ case    1:  		/* lwz R4, <#[R7]> */
		/* 822691A0h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R7 + 0x00000000) );
		/* 822691A0h case    1:*/		return 0x822691A4;
		  /* 822691A4h */ case    2:  		/* bl 1564 */
		/* 822691A4h case    2:*/		regs.LR = 0x822691A8; return 0x822697C0;
		/* 822691A4h case    2:*/		return 0x822691A8;
		  /* 822691A8h */ case    3:  		/* lwz R3, <#[R7]> */
		/* 822691A8h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R7 + 0x00000000) );
		/* 822691A8h case    3:*/		return 0x822691AC;
		  /* 822691ACh */ case    4:  		/* lwz R4, <#[R7 + 4]> */
		/* 822691ACh case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R7 + 0x00000004) );
		/* 822691ACh case    4:*/		return 0x822691B0;
		  /* 822691B0h */ case    5:  		/* bl 17288 */
		/* 822691B0h case    5:*/		regs.LR = 0x822691B4; return 0x8226D538;
		/* 822691B0h case    5:*/		return 0x822691B4;
		  /* 822691B4h */ case    6:  		/* lwz R0, <#[R1 + 8]> */
		/* 822691B4h case    6:*/		cpu::mem::load32z( regs, &regs.R0, (uint32)(regs.R1 + 0x00000008) );
		/* 822691B4h case    6:*/		return 0x822691B8;
		  /* 822691B8h */ case    7:  		/* mtspr LR, R0 */
		/* 822691B8h case    7:*/		regs.LR = regs.R0;
		/* 822691B8h case    7:*/		return 0x822691BC;
		  /* 822691BCh */ case    8:  		/* addi R1, R1, 80 */
		/* 822691BCh case    8:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x50);
		/* 822691BCh case    8:*/		return 0x822691C0;
		  /* 822691C0h */ case    9:  		/* bclr 20, CR0_LT */
		/* 822691C0h case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822691C0h case    9:*/		return 0x822691C4;
	}
	return 0x822691C4;
} // Block from 8226919Ch-822691C4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 822691C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822691C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822691C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822691C4);
		  /* 822691C4h */ case    0:  		/* nop */
		/* 822691C4h case    0:*/		cpu::op::nop();
		/* 822691C4h case    0:*/		return 0x822691C8;
		  /* 822691C8h */ case    1:  		/* nop */
		/* 822691C8h case    1:*/		cpu::op::nop();
		/* 822691C8h case    1:*/		return 0x822691CC;
		  /* 822691CCh */ case    2:  		/* nop */
		/* 822691CCh case    2:*/		cpu::op::nop();
		/* 822691CCh case    2:*/		return 0x822691D0;
	}
	return 0x822691D0;
} // Block from 822691C4h-822691D0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822691D0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822691D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822691D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822691D0);
		  /* 822691D0h */ case    0:  		/* lis R4, -32215 */
		/* 822691D0h case    0:*/		cpu::op::lis<0>(regs,&regs.R4,0xFFFF8229);
		/* 822691D0h case    0:*/		return 0x822691D4;
		  /* 822691D4h */ case    1:  		/* lwz R0, <#[R4 - 25524]> */
		/* 822691D4h case    1:*/		cpu::mem::load32z( regs, &regs.R0, (uint32)(regs.R4 + 0xFFFF9C4C) );
		/* 822691D4h case    1:*/		return 0x822691D8;
	}
	return 0x822691D8;
} // Block from 822691D0h-822691D8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822691D8h
// Function 'cosh'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822691D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822691D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822691D8);
		  /* 822691D8h */ case    0:  		/* cmpwi CR0, R0, 0 */
		/* 822691D8h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R0,0x00000000);
		/* 822691D8h case    0:*/		return 0x822691DC;
		  /* 822691DCh */ case    1:  		/* mtspr CTR, R0 */
		/* 822691DCh case    1:*/		regs.CTR = regs.R0;
		/* 822691DCh case    1:*/		return 0x822691E0;
		  /* 822691E0h */ case    2:  		/* bcctr 4, CR0_EQ */
		/* 822691E0h case    2:*/		if ( !regs.CR[0].eq ) { return (uint32)regs.CTR; }
		/* 822691E0h case    2:*/		return 0x822691E4;
		  /* 822691E4h */ case    3:  		/* mfspr R0, LR */
		/* 822691E4h case    3:*/		regs.R0 = regs.LR;
		/* 822691E4h case    3:*/		return 0x822691E8;
		  /* 822691E8h */ case    4:  		/* mfcr R4 */
		/* 822691E8h case    4:*/		cpu::op::mfcr<0>(regs,&regs.R4);
		/* 822691E8h case    4:*/		return 0x822691EC;
		  /* 822691ECh */ case    5:  		/* stfd FR14, <#[R3]> */
		/* 822691ECh case    5:*/		cpu::mem::store64f( regs, regs.FR14, (uint32)(regs.R3 + 0x00000000) );
		/* 822691ECh case    5:*/		return 0x822691F0;
		  /* 822691F0h */ case    6:  		/* stfd FR15, <#[R3 + 8]> */
		/* 822691F0h case    6:*/		cpu::mem::store64f( regs, regs.FR15, (uint32)(regs.R3 + 0x00000008) );
		/* 822691F0h case    6:*/		return 0x822691F4;
		  /* 822691F4h */ case    7:  		/* stfd FR16, <#[R3 + 16]> */
		/* 822691F4h case    7:*/		cpu::mem::store64f( regs, regs.FR16, (uint32)(regs.R3 + 0x00000010) );
		/* 822691F4h case    7:*/		return 0x822691F8;
		  /* 822691F8h */ case    8:  		/* stfd FR17, <#[R3 + 24]> */
		/* 822691F8h case    8:*/		cpu::mem::store64f( regs, regs.FR17, (uint32)(regs.R3 + 0x00000018) );
		/* 822691F8h case    8:*/		return 0x822691FC;
		  /* 822691FCh */ case    9:  		/* stfd FR18, <#[R3 + 32]> */
		/* 822691FCh case    9:*/		cpu::mem::store64f( regs, regs.FR18, (uint32)(regs.R3 + 0x00000020) );
		/* 822691FCh case    9:*/		return 0x82269200;
		  /* 82269200h */ case   10:  		/* stfd FR19, <#[R3 + 40]> */
		/* 82269200h case   10:*/		cpu::mem::store64f( regs, regs.FR19, (uint32)(regs.R3 + 0x00000028) );
		/* 82269200h case   10:*/		return 0x82269204;
		  /* 82269204h */ case   11:  		/* stfd FR20, <#[R3 + 48]> */
		/* 82269204h case   11:*/		cpu::mem::store64f( regs, regs.FR20, (uint32)(regs.R3 + 0x00000030) );
		/* 82269204h case   11:*/		return 0x82269208;
		  /* 82269208h */ case   12:  		/* stfd FR21, <#[R3 + 56]> */
		/* 82269208h case   12:*/		cpu::mem::store64f( regs, regs.FR21, (uint32)(regs.R3 + 0x00000038) );
		/* 82269208h case   12:*/		return 0x8226920C;
		  /* 8226920Ch */ case   13:  		/* stfd FR22, <#[R3 + 64]> */
		/* 8226920Ch case   13:*/		cpu::mem::store64f( regs, regs.FR22, (uint32)(regs.R3 + 0x00000040) );
		/* 8226920Ch case   13:*/		return 0x82269210;
		  /* 82269210h */ case   14:  		/* stfd FR23, <#[R3 + 72]> */
		/* 82269210h case   14:*/		cpu::mem::store64f( regs, regs.FR23, (uint32)(regs.R3 + 0x00000048) );
		/* 82269210h case   14:*/		return 0x82269214;
		  /* 82269214h */ case   15:  		/* stfd FR24, <#[R3 + 80]> */
		/* 82269214h case   15:*/		cpu::mem::store64f( regs, regs.FR24, (uint32)(regs.R3 + 0x00000050) );
		/* 82269214h case   15:*/		return 0x82269218;
		  /* 82269218h */ case   16:  		/* stfd FR25, <#[R3 + 88]> */
		/* 82269218h case   16:*/		cpu::mem::store64f( regs, regs.FR25, (uint32)(regs.R3 + 0x00000058) );
		/* 82269218h case   16:*/		return 0x8226921C;
		  /* 8226921Ch */ case   17:  		/* stfd FR26, <#[R3 + 96]> */
		/* 8226921Ch case   17:*/		cpu::mem::store64f( regs, regs.FR26, (uint32)(regs.R3 + 0x00000060) );
		/* 8226921Ch case   17:*/		return 0x82269220;
		  /* 82269220h */ case   18:  		/* stfd FR27, <#[R3 + 104]> */
		/* 82269220h case   18:*/		cpu::mem::store64f( regs, regs.FR27, (uint32)(regs.R3 + 0x00000068) );
		/* 82269220h case   18:*/		return 0x82269224;
		  /* 82269224h */ case   19:  		/* stfd FR28, <#[R3 + 112]> */
		/* 82269224h case   19:*/		cpu::mem::store64f( regs, regs.FR28, (uint32)(regs.R3 + 0x00000070) );
		/* 82269224h case   19:*/		return 0x82269228;
		  /* 82269228h */ case   20:  		/* stfd FR29, <#[R3 + 120]> */
		/* 82269228h case   20:*/		cpu::mem::store64f( regs, regs.FR29, (uint32)(regs.R3 + 0x00000078) );
		/* 82269228h case   20:*/		return 0x8226922C;
		  /* 8226922Ch */ case   21:  		/* stfd FR30, <#[R3 + 128]> */
		/* 8226922Ch case   21:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R3 + 0x00000080) );
		/* 8226922Ch case   21:*/		return 0x82269230;
		  /* 82269230h */ case   22:  		/* stfd FR31, <#[R3 + 136]> */
		/* 82269230h case   22:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R3 + 0x00000088) );
		/* 82269230h case   22:*/		return 0x82269234;
		  /* 82269234h */ case   23:  		/* std R13, <#[R3 + 152]> */
		/* 82269234h case   23:*/		cpu::mem::store64( regs, regs.R13, (uint32)(regs.R3 + 0x00000098) );
		/* 82269234h case   23:*/		return 0x82269238;
		  /* 82269238h */ case   24:  		/* std R14, <#[R3 + 160]> */
		/* 82269238h case   24:*/		cpu::mem::store64( regs, regs.R14, (uint32)(regs.R3 + 0x000000A0) );
		/* 82269238h case   24:*/		return 0x8226923C;
		  /* 8226923Ch */ case   25:  		/* std R15, <#[R3 + 168]> */
		/* 8226923Ch case   25:*/		cpu::mem::store64( regs, regs.R15, (uint32)(regs.R3 + 0x000000A8) );
		/* 8226923Ch case   25:*/		return 0x82269240;
		  /* 82269240h */ case   26:  		/* std R16, <#[R3 + 176]> */
		/* 82269240h case   26:*/		cpu::mem::store64( regs, regs.R16, (uint32)(regs.R3 + 0x000000B0) );
		/* 82269240h case   26:*/		return 0x82269244;
		  /* 82269244h */ case   27:  		/* std R17, <#[R3 + 184]> */
		/* 82269244h case   27:*/		cpu::mem::store64( regs, regs.R17, (uint32)(regs.R3 + 0x000000B8) );
		/* 82269244h case   27:*/		return 0x82269248;
		  /* 82269248h */ case   28:  		/* std R18, <#[R3 + 192]> */
		/* 82269248h case   28:*/		cpu::mem::store64( regs, regs.R18, (uint32)(regs.R3 + 0x000000C0) );
		/* 82269248h case   28:*/		return 0x8226924C;
		  /* 8226924Ch */ case   29:  		/* std R19, <#[R3 + 200]> */
		/* 8226924Ch case   29:*/		cpu::mem::store64( regs, regs.R19, (uint32)(regs.R3 + 0x000000C8) );
		/* 8226924Ch case   29:*/		return 0x82269250;
		  /* 82269250h */ case   30:  		/* std R20, <#[R3 + 208]> */
		/* 82269250h case   30:*/		cpu::mem::store64( regs, regs.R20, (uint32)(regs.R3 + 0x000000D0) );
		/* 82269250h case   30:*/		return 0x82269254;
		  /* 82269254h */ case   31:  		/* std R21, <#[R3 + 216]> */
		/* 82269254h case   31:*/		cpu::mem::store64( regs, regs.R21, (uint32)(regs.R3 + 0x000000D8) );
		/* 82269254h case   31:*/		return 0x82269258;
		  /* 82269258h */ case   32:  		/* std R22, <#[R3 + 224]> */
		/* 82269258h case   32:*/		cpu::mem::store64( regs, regs.R22, (uint32)(regs.R3 + 0x000000E0) );
		/* 82269258h case   32:*/		return 0x8226925C;
		  /* 8226925Ch */ case   33:  		/* std R23, <#[R3 + 232]> */
		/* 8226925Ch case   33:*/		cpu::mem::store64( regs, regs.R23, (uint32)(regs.R3 + 0x000000E8) );
		/* 8226925Ch case   33:*/		return 0x82269260;
		  /* 82269260h */ case   34:  		/* std R24, <#[R3 + 240]> */
		/* 82269260h case   34:*/		cpu::mem::store64( regs, regs.R24, (uint32)(regs.R3 + 0x000000F0) );
		/* 82269260h case   34:*/		return 0x82269264;
		  /* 82269264h */ case   35:  		/* std R25, <#[R3 + 248]> */
		/* 82269264h case   35:*/		cpu::mem::store64( regs, regs.R25, (uint32)(regs.R3 + 0x000000F8) );
		/* 82269264h case   35:*/		return 0x82269268;
		  /* 82269268h */ case   36:  		/* std R26, <#[R3 + 256]> */
		/* 82269268h case   36:*/		cpu::mem::store64( regs, regs.R26, (uint32)(regs.R3 + 0x00000100) );
		/* 82269268h case   36:*/		return 0x8226926C;
		  /* 8226926Ch */ case   37:  		/* std R27, <#[R3 + 264]> */
		/* 8226926Ch case   37:*/		cpu::mem::store64( regs, regs.R27, (uint32)(regs.R3 + 0x00000108) );
		/* 8226926Ch case   37:*/		return 0x82269270;
		  /* 82269270h */ case   38:  		/* std R28, <#[R3 + 272]> */
		/* 82269270h case   38:*/		cpu::mem::store64( regs, regs.R28, (uint32)(regs.R3 + 0x00000110) );
		/* 82269270h case   38:*/		return 0x82269274;
		  /* 82269274h */ case   39:  		/* std R29, <#[R3 + 280]> */
		/* 82269274h case   39:*/		cpu::mem::store64( regs, regs.R29, (uint32)(regs.R3 + 0x00000118) );
		/* 82269274h case   39:*/		return 0x82269278;
		  /* 82269278h */ case   40:  		/* std R30, <#[R3 + 288]> */
		/* 82269278h case   40:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R3 + 0x00000120) );
		/* 82269278h case   40:*/		return 0x8226927C;
		  /* 8226927Ch */ case   41:  		/* std R31, <#[R3 + 296]> */
		/* 8226927Ch case   41:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R3 + 0x00000128) );
		/* 8226927Ch case   41:*/		return 0x82269280;
		  /* 82269280h */ case   42:  		/* li R5, 320 */
		/* 82269280h case   42:*/		cpu::op::li<0>(regs,&regs.R5,0x140);
		/* 82269280h case   42:*/		return 0x82269284;
		  /* 82269284h */ case   43:  		/* stvlx VR64, <#[R5 + R3]> */
		/* 82269284h case   43:*/		cpu::mem::stvlx( regs, regs.VR64, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 82269284h case   43:*/		return 0x82269288;
		  /* 82269288h */ case   44:  		/* li R5, 336 */
		/* 82269288h case   44:*/		cpu::op::li<0>(regs,&regs.R5,0x150);
		/* 82269288h case   44:*/		return 0x8226928C;
		  /* 8226928Ch */ case   45:  		/* stvlx VR65, <#[R5 + R3]> */
		/* 8226928Ch case   45:*/		cpu::mem::stvlx( regs, regs.VR65, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 8226928Ch case   45:*/		return 0x82269290;
		  /* 82269290h */ case   46:  		/* li R5, 352 */
		/* 82269290h case   46:*/		cpu::op::li<0>(regs,&regs.R5,0x160);
		/* 82269290h case   46:*/		return 0x82269294;
		  /* 82269294h */ case   47:  		/* stvlx VR66, <#[R5 + R3]> */
		/* 82269294h case   47:*/		cpu::mem::stvlx( regs, regs.VR66, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 82269294h case   47:*/		return 0x82269298;
		  /* 82269298h */ case   48:  		/* li R5, 368 */
		/* 82269298h case   48:*/		cpu::op::li<0>(regs,&regs.R5,0x170);
		/* 82269298h case   48:*/		return 0x8226929C;
		  /* 8226929Ch */ case   49:  		/* stvlx VR67, <#[R5 + R3]> */
		/* 8226929Ch case   49:*/		cpu::mem::stvlx( regs, regs.VR67, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 8226929Ch case   49:*/		return 0x822692A0;
		  /* 822692A0h */ case   50:  		/* li R5, 384 */
		/* 822692A0h case   50:*/		cpu::op::li<0>(regs,&regs.R5,0x180);
		/* 822692A0h case   50:*/		return 0x822692A4;
		  /* 822692A4h */ case   51:  		/* stvlx VR68, <#[R5 + R3]> */
		/* 822692A4h case   51:*/		cpu::mem::stvlx( regs, regs.VR68, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 822692A4h case   51:*/		return 0x822692A8;
		  /* 822692A8h */ case   52:  		/* li R5, 400 */
		/* 822692A8h case   52:*/		cpu::op::li<0>(regs,&regs.R5,0x190);
		/* 822692A8h case   52:*/		return 0x822692AC;
		  /* 822692ACh */ case   53:  		/* stvlx VR69, <#[R5 + R3]> */
		/* 822692ACh case   53:*/		cpu::mem::stvlx( regs, regs.VR69, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 822692ACh case   53:*/		return 0x822692B0;
		  /* 822692B0h */ case   54:  		/* li R5, 416 */
		/* 822692B0h case   54:*/		cpu::op::li<0>(regs,&regs.R5,0x1A0);
		/* 822692B0h case   54:*/		return 0x822692B4;
		  /* 822692B4h */ case   55:  		/* stvlx VR70, <#[R5 + R3]> */
		/* 822692B4h case   55:*/		cpu::mem::stvlx( regs, regs.VR70, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 822692B4h case   55:*/		return 0x822692B8;
		  /* 822692B8h */ case   56:  		/* li R5, 432 */
		/* 822692B8h case   56:*/		cpu::op::li<0>(regs,&regs.R5,0x1B0);
		/* 822692B8h case   56:*/		return 0x822692BC;
		  /* 822692BCh */ case   57:  		/* stvlx VR71, <#[R5 + R3]> */
		/* 822692BCh case   57:*/		cpu::mem::stvlx( regs, regs.VR71, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 822692BCh case   57:*/		return 0x822692C0;
		  /* 822692C0h */ case   58:  		/* li R5, 448 */
		/* 822692C0h case   58:*/		cpu::op::li<0>(regs,&regs.R5,0x1C0);
		/* 822692C0h case   58:*/		return 0x822692C4;
		  /* 822692C4h */ case   59:  		/* stvlx VR72, <#[R5 + R3]> */
		/* 822692C4h case   59:*/		cpu::mem::stvlx( regs, regs.VR72, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 822692C4h case   59:*/		return 0x822692C8;
		  /* 822692C8h */ case   60:  		/* li R5, 464 */
		/* 822692C8h case   60:*/		cpu::op::li<0>(regs,&regs.R5,0x1D0);
		/* 822692C8h case   60:*/		return 0x822692CC;
		  /* 822692CCh */ case   61:  		/* stvlx VR73, <#[R5 + R3]> */
		/* 822692CCh case   61:*/		cpu::mem::stvlx( regs, regs.VR73, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 822692CCh case   61:*/		return 0x822692D0;
		  /* 822692D0h */ case   62:  		/* li R5, 480 */
		/* 822692D0h case   62:*/		cpu::op::li<0>(regs,&regs.R5,0x1E0);
		/* 822692D0h case   62:*/		return 0x822692D4;
		  /* 822692D4h */ case   63:  		/* stvlx VR74, <#[R5 + R3]> */
		/* 822692D4h case   63:*/		cpu::mem::stvlx( regs, regs.VR74, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 822692D4h case   63:*/		return 0x822692D8;
		  /* 822692D8h */ case   64:  		/* li R5, 496 */
		/* 822692D8h case   64:*/		cpu::op::li<0>(regs,&regs.R5,0x1F0);
		/* 822692D8h case   64:*/		return 0x822692DC;
		  /* 822692DCh */ case   65:  		/* stvlx VR75, <#[R5 + R3]> */
		/* 822692DCh case   65:*/		cpu::mem::stvlx( regs, regs.VR75, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 822692DCh case   65:*/		return 0x822692E0;
		  /* 822692E0h */ case   66:  		/* li R5, 512 */
		/* 822692E0h case   66:*/		cpu::op::li<0>(regs,&regs.R5,0x200);
		/* 822692E0h case   66:*/		return 0x822692E4;
		  /* 822692E4h */ case   67:  		/* stvlx VR76, <#[R5 + R3]> */
		/* 822692E4h case   67:*/		cpu::mem::stvlx( regs, regs.VR76, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 822692E4h case   67:*/		return 0x822692E8;
		  /* 822692E8h */ case   68:  		/* li R5, 528 */
		/* 822692E8h case   68:*/		cpu::op::li<0>(regs,&regs.R5,0x210);
		/* 822692E8h case   68:*/		return 0x822692EC;
		  /* 822692ECh */ case   69:  		/* stvlx VR77, <#[R5 + R3]> */
		/* 822692ECh case   69:*/		cpu::mem::stvlx( regs, regs.VR77, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 822692ECh case   69:*/		return 0x822692F0;
		  /* 822692F0h */ case   70:  		/* li R5, 544 */
		/* 822692F0h case   70:*/		cpu::op::li<0>(regs,&regs.R5,0x220);
		/* 822692F0h case   70:*/		return 0x822692F4;
		  /* 822692F4h */ case   71:  		/* stvlx VR78, <#[R5 + R3]> */
		/* 822692F4h case   71:*/		cpu::mem::stvlx( regs, regs.VR78, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 822692F4h case   71:*/		return 0x822692F8;
		  /* 822692F8h */ case   72:  		/* li R5, 560 */
		/* 822692F8h case   72:*/		cpu::op::li<0>(regs,&regs.R5,0x230);
		/* 822692F8h case   72:*/		return 0x822692FC;
		  /* 822692FCh */ case   73:  		/* stvlx VR79, <#[R5 + R3]> */
		/* 822692FCh case   73:*/		cpu::mem::stvlx( regs, regs.VR79, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 822692FCh case   73:*/		return 0x82269300;
		  /* 82269300h */ case   74:  		/* li R5, 576 */
		/* 82269300h case   74:*/		cpu::op::li<0>(regs,&regs.R5,0x240);
		/* 82269300h case   74:*/		return 0x82269304;
		  /* 82269304h */ case   75:  		/* stvlx VR80, <#[R5 + R3]> */
		/* 82269304h case   75:*/		cpu::mem::stvlx( regs, regs.VR80, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 82269304h case   75:*/		return 0x82269308;
		  /* 82269308h */ case   76:  		/* li R5, 592 */
		/* 82269308h case   76:*/		cpu::op::li<0>(regs,&regs.R5,0x250);
		/* 82269308h case   76:*/		return 0x8226930C;
		  /* 8226930Ch */ case   77:  		/* stvlx VR81, <#[R5 + R3]> */
		/* 8226930Ch case   77:*/		cpu::mem::stvlx( regs, regs.VR81, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 8226930Ch case   77:*/		return 0x82269310;
		  /* 82269310h */ case   78:  		/* li R5, 608 */
		/* 82269310h case   78:*/		cpu::op::li<0>(regs,&regs.R5,0x260);
		/* 82269310h case   78:*/		return 0x82269314;
		  /* 82269314h */ case   79:  		/* stvlx VR82, <#[R5 + R3]> */
		/* 82269314h case   79:*/		cpu::mem::stvlx( regs, regs.VR82, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 82269314h case   79:*/		return 0x82269318;
		  /* 82269318h */ case   80:  		/* li R5, 624 */
		/* 82269318h case   80:*/		cpu::op::li<0>(regs,&regs.R5,0x270);
		/* 82269318h case   80:*/		return 0x8226931C;
		  /* 8226931Ch */ case   81:  		/* stvlx VR83, <#[R5 + R3]> */
		/* 8226931Ch case   81:*/		cpu::mem::stvlx( regs, regs.VR83, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 8226931Ch case   81:*/		return 0x82269320;
		  /* 82269320h */ case   82:  		/* li R5, 640 */
		/* 82269320h case   82:*/		cpu::op::li<0>(regs,&regs.R5,0x280);
		/* 82269320h case   82:*/		return 0x82269324;
		  /* 82269324h */ case   83:  		/* stvlx VR84, <#[R5 + R3]> */
		/* 82269324h case   83:*/		cpu::mem::stvlx( regs, regs.VR84, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 82269324h case   83:*/		return 0x82269328;
		  /* 82269328h */ case   84:  		/* li R5, 656 */
		/* 82269328h case   84:*/		cpu::op::li<0>(regs,&regs.R5,0x290);
		/* 82269328h case   84:*/		return 0x8226932C;
		  /* 8226932Ch */ case   85:  		/* stvlx VR85, <#[R5 + R3]> */
		/* 8226932Ch case   85:*/		cpu::mem::stvlx( regs, regs.VR85, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 8226932Ch case   85:*/		return 0x82269330;
		  /* 82269330h */ case   86:  		/* li R5, 672 */
		/* 82269330h case   86:*/		cpu::op::li<0>(regs,&regs.R5,0x2A0);
		/* 82269330h case   86:*/		return 0x82269334;
		  /* 82269334h */ case   87:  		/* stvlx VR86, <#[R5 + R3]> */
		/* 82269334h case   87:*/		cpu::mem::stvlx( regs, regs.VR86, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 82269334h case   87:*/		return 0x82269338;
		  /* 82269338h */ case   88:  		/* li R5, 688 */
		/* 82269338h case   88:*/		cpu::op::li<0>(regs,&regs.R5,0x2B0);
		/* 82269338h case   88:*/		return 0x8226933C;
		  /* 8226933Ch */ case   89:  		/* stvlx VR87, <#[R5 + R3]> */
		/* 8226933Ch case   89:*/		cpu::mem::stvlx( regs, regs.VR87, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 8226933Ch case   89:*/		return 0x82269340;
		  /* 82269340h */ case   90:  		/* li R5, 704 */
		/* 82269340h case   90:*/		cpu::op::li<0>(regs,&regs.R5,0x2C0);
		/* 82269340h case   90:*/		return 0x82269344;
		  /* 82269344h */ case   91:  		/* stvlx VR88, <#[R5 + R3]> */
		/* 82269344h case   91:*/		cpu::mem::stvlx( regs, regs.VR88, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 82269344h case   91:*/		return 0x82269348;
		  /* 82269348h */ case   92:  		/* li R5, 720 */
		/* 82269348h case   92:*/		cpu::op::li<0>(regs,&regs.R5,0x2D0);
		/* 82269348h case   92:*/		return 0x8226934C;
		  /* 8226934Ch */ case   93:  		/* stvlx VR89, <#[R5 + R3]> */
		/* 8226934Ch case   93:*/		cpu::mem::stvlx( regs, regs.VR89, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 8226934Ch case   93:*/		return 0x82269350;
		  /* 82269350h */ case   94:  		/* li R5, 736 */
		/* 82269350h case   94:*/		cpu::op::li<0>(regs,&regs.R5,0x2E0);
		/* 82269350h case   94:*/		return 0x82269354;
		  /* 82269354h */ case   95:  		/* stvlx VR90, <#[R5 + R3]> */
		/* 82269354h case   95:*/		cpu::mem::stvlx( regs, regs.VR90, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 82269354h case   95:*/		return 0x82269358;
		  /* 82269358h */ case   96:  		/* li R5, 752 */
		/* 82269358h case   96:*/		cpu::op::li<0>(regs,&regs.R5,0x2F0);
		/* 82269358h case   96:*/		return 0x8226935C;
		  /* 8226935Ch */ case   97:  		/* stvlx VR91, <#[R5 + R3]> */
		/* 8226935Ch case   97:*/		cpu::mem::stvlx( regs, regs.VR91, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 8226935Ch case   97:*/		return 0x82269360;
		  /* 82269360h */ case   98:  		/* li R5, 768 */
		/* 82269360h case   98:*/		cpu::op::li<0>(regs,&regs.R5,0x300);
		/* 82269360h case   98:*/		return 0x82269364;
		  /* 82269364h */ case   99:  		/* stvlx VR92, <#[R5 + R3]> */
		/* 82269364h case   99:*/		cpu::mem::stvlx( regs, regs.VR92, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 82269364h case   99:*/		return 0x82269368;
		  /* 82269368h */ case  100:  		/* li R5, 784 */
		/* 82269368h case  100:*/		cpu::op::li<0>(regs,&regs.R5,0x310);
		/* 82269368h case  100:*/		return 0x8226936C;
		  /* 8226936Ch */ case  101:  		/* stvlx VR93, <#[R5 + R3]> */
		/* 8226936Ch case  101:*/		cpu::mem::stvlx( regs, regs.VR93, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 8226936Ch case  101:*/		return 0x82269370;
		  /* 82269370h */ case  102:  		/* li R5, 800 */
		/* 82269370h case  102:*/		cpu::op::li<0>(regs,&regs.R5,0x320);
		/* 82269370h case  102:*/		return 0x82269374;
		  /* 82269374h */ case  103:  		/* stvlx VR94, <#[R5 + R3]> */
		/* 82269374h case  103:*/		cpu::mem::stvlx( regs, regs.VR94, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 82269374h case  103:*/		return 0x82269378;
		  /* 82269378h */ case  104:  		/* li R5, 816 */
		/* 82269378h case  104:*/		cpu::op::li<0>(regs,&regs.R5,0x330);
		/* 82269378h case  104:*/		return 0x8226937C;
		  /* 8226937Ch */ case  105:  		/* stvlx VR95, <#[R5 + R3]> */
		/* 8226937Ch case  105:*/		cpu::mem::stvlx( regs, regs.VR95, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 8226937Ch case  105:*/		return 0x82269380;
		  /* 82269380h */ case  106:  		/* li R5, 832 */
		/* 82269380h case  106:*/		cpu::op::li<0>(regs,&regs.R5,0x340);
		/* 82269380h case  106:*/		return 0x82269384;
		  /* 82269384h */ case  107:  		/* stvlx VR96, <#[R5 + R3]> */
		/* 82269384h case  107:*/		cpu::mem::stvlx( regs, regs.VR96, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 82269384h case  107:*/		return 0x82269388;
		  /* 82269388h */ case  108:  		/* li R5, 848 */
		/* 82269388h case  108:*/		cpu::op::li<0>(regs,&regs.R5,0x350);
		/* 82269388h case  108:*/		return 0x8226938C;
		  /* 8226938Ch */ case  109:  		/* stvlx VR97, <#[R5 + R3]> */
		/* 8226938Ch case  109:*/		cpu::mem::stvlx( regs, regs.VR97, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 8226938Ch case  109:*/		return 0x82269390;
		  /* 82269390h */ case  110:  		/* li R5, 864 */
		/* 82269390h case  110:*/		cpu::op::li<0>(regs,&regs.R5,0x360);
		/* 82269390h case  110:*/		return 0x82269394;
		  /* 82269394h */ case  111:  		/* stvlx VR98, <#[R5 + R3]> */
		/* 82269394h case  111:*/		cpu::mem::stvlx( regs, regs.VR98, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 82269394h case  111:*/		return 0x82269398;
		  /* 82269398h */ case  112:  		/* li R5, 880 */
		/* 82269398h case  112:*/		cpu::op::li<0>(regs,&regs.R5,0x370);
		/* 82269398h case  112:*/		return 0x8226939C;
		  /* 8226939Ch */ case  113:  		/* stvlx VR99, <#[R5 + R3]> */
		/* 8226939Ch case  113:*/		cpu::mem::stvlx( regs, regs.VR99, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 8226939Ch case  113:*/		return 0x822693A0;
	}
	return 0x822693A0;
} // Block from 822691D8h-822693A0h (114 instructions)

//////////////////////////////////////////////////////
// Block at 822693A0h
// Function 'fmod'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822693A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822693A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822693A0);
		  /* 822693A0h */ case    0:  		/* li R5, 896 */
		/* 822693A0h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x380);
		/* 822693A0h case    0:*/		return 0x822693A4;
		  /* 822693A4h */ case    1:  		/* stvlx VR100, <#[R5 + R3]> */
		/* 822693A4h case    1:*/		cpu::mem::stvlx( regs, regs.VR100, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 822693A4h case    1:*/		return 0x822693A8;
		  /* 822693A8h */ case    2:  		/* li R5, 912 */
		/* 822693A8h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x390);
		/* 822693A8h case    2:*/		return 0x822693AC;
		  /* 822693ACh */ case    3:  		/* stvlx VR101, <#[R5 + R3]> */
		/* 822693ACh case    3:*/		cpu::mem::stvlx( regs, regs.VR101, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 822693ACh case    3:*/		return 0x822693B0;
		  /* 822693B0h */ case    4:  		/* li R5, 928 */
		/* 822693B0h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x3A0);
		/* 822693B0h case    4:*/		return 0x822693B4;
		  /* 822693B4h */ case    5:  		/* stvlx VR102, <#[R5 + R3]> */
		/* 822693B4h case    5:*/		cpu::mem::stvlx( regs, regs.VR102, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 822693B4h case    5:*/		return 0x822693B8;
		  /* 822693B8h */ case    6:  		/* li R5, 944 */
		/* 822693B8h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x3B0);
		/* 822693B8h case    6:*/		return 0x822693BC;
		  /* 822693BCh */ case    7:  		/* stvlx VR103, <#[R5 + R3]> */
		/* 822693BCh case    7:*/		cpu::mem::stvlx( regs, regs.VR103, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 822693BCh case    7:*/		return 0x822693C0;
		  /* 822693C0h */ case    8:  		/* li R5, 960 */
		/* 822693C0h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x3C0);
		/* 822693C0h case    8:*/		return 0x822693C4;
		  /* 822693C4h */ case    9:  		/* stvlx VR104, <#[R5 + R3]> */
		/* 822693C4h case    9:*/		cpu::mem::stvlx( regs, regs.VR104, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 822693C4h case    9:*/		return 0x822693C8;
		  /* 822693C8h */ case   10:  		/* li R5, 976 */
		/* 822693C8h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x3D0);
		/* 822693C8h case   10:*/		return 0x822693CC;
		  /* 822693CCh */ case   11:  		/* stvlx VR105, <#[R5 + R3]> */
		/* 822693CCh case   11:*/		cpu::mem::stvlx( regs, regs.VR105, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 822693CCh case   11:*/		return 0x822693D0;
		  /* 822693D0h */ case   12:  		/* li R5, 992 */
		/* 822693D0h case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x3E0);
		/* 822693D0h case   12:*/		return 0x822693D4;
		  /* 822693D4h */ case   13:  		/* stvlx VR106, <#[R5 + R3]> */
		/* 822693D4h case   13:*/		cpu::mem::stvlx( regs, regs.VR106, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 822693D4h case   13:*/		return 0x822693D8;
		  /* 822693D8h */ case   14:  		/* li R5, 1008 */
		/* 822693D8h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0x3F0);
		/* 822693D8h case   14:*/		return 0x822693DC;
		  /* 822693DCh */ case   15:  		/* stvlx VR107, <#[R5 + R3]> */
		/* 822693DCh case   15:*/		cpu::mem::stvlx( regs, regs.VR107, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 822693DCh case   15:*/		return 0x822693E0;
		  /* 822693E0h */ case   16:  		/* li R5, 1024 */
		/* 822693E0h case   16:*/		cpu::op::li<0>(regs,&regs.R5,0x400);
		/* 822693E0h case   16:*/		return 0x822693E4;
		  /* 822693E4h */ case   17:  		/* stvlx VR108, <#[R5 + R3]> */
		/* 822693E4h case   17:*/		cpu::mem::stvlx( regs, regs.VR108, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 822693E4h case   17:*/		return 0x822693E8;
		  /* 822693E8h */ case   18:  		/* li R5, 1040 */
		/* 822693E8h case   18:*/		cpu::op::li<0>(regs,&regs.R5,0x410);
		/* 822693E8h case   18:*/		return 0x822693EC;
		  /* 822693ECh */ case   19:  		/* stvlx VR109, <#[R5 + R3]> */
		/* 822693ECh case   19:*/		cpu::mem::stvlx( regs, regs.VR109, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 822693ECh case   19:*/		return 0x822693F0;
		  /* 822693F0h */ case   20:  		/* li R5, 1056 */
		/* 822693F0h case   20:*/		cpu::op::li<0>(regs,&regs.R5,0x420);
		/* 822693F0h case   20:*/		return 0x822693F4;
		  /* 822693F4h */ case   21:  		/* stvlx VR110, <#[R5 + R3]> */
		/* 822693F4h case   21:*/		cpu::mem::stvlx( regs, regs.VR110, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 822693F4h case   21:*/		return 0x822693F8;
		  /* 822693F8h */ case   22:  		/* li R5, 1072 */
		/* 822693F8h case   22:*/		cpu::op::li<0>(regs,&regs.R5,0x430);
		/* 822693F8h case   22:*/		return 0x822693FC;
		  /* 822693FCh */ case   23:  		/* stvlx VR111, <#[R5 + R3]> */
		/* 822693FCh case   23:*/		cpu::mem::stvlx( regs, regs.VR111, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 822693FCh case   23:*/		return 0x82269400;
		  /* 82269400h */ case   24:  		/* li R5, 1088 */
		/* 82269400h case   24:*/		cpu::op::li<0>(regs,&regs.R5,0x440);
		/* 82269400h case   24:*/		return 0x82269404;
		  /* 82269404h */ case   25:  		/* stvlx VR112, <#[R5 + R3]> */
		/* 82269404h case   25:*/		cpu::mem::stvlx( regs, regs.VR112, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 82269404h case   25:*/		return 0x82269408;
		  /* 82269408h */ case   26:  		/* li R5, 1104 */
		/* 82269408h case   26:*/		cpu::op::li<0>(regs,&regs.R5,0x450);
		/* 82269408h case   26:*/		return 0x8226940C;
		  /* 8226940Ch */ case   27:  		/* stvlx VR113, <#[R5 + R3]> */
		/* 8226940Ch case   27:*/		cpu::mem::stvlx( regs, regs.VR113, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 8226940Ch case   27:*/		return 0x82269410;
		  /* 82269410h */ case   28:  		/* li R5, 1120 */
		/* 82269410h case   28:*/		cpu::op::li<0>(regs,&regs.R5,0x460);
		/* 82269410h case   28:*/		return 0x82269414;
		  /* 82269414h */ case   29:  		/* stvlx VR114, <#[R5 + R3]> */
		/* 82269414h case   29:*/		cpu::mem::stvlx( regs, regs.VR114, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 82269414h case   29:*/		return 0x82269418;
		  /* 82269418h */ case   30:  		/* li R5, 1136 */
		/* 82269418h case   30:*/		cpu::op::li<0>(regs,&regs.R5,0x470);
		/* 82269418h case   30:*/		return 0x8226941C;
		  /* 8226941Ch */ case   31:  		/* stvlx VR115, <#[R5 + R3]> */
		/* 8226941Ch case   31:*/		cpu::mem::stvlx( regs, regs.VR115, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 8226941Ch case   31:*/		return 0x82269420;
		  /* 82269420h */ case   32:  		/* li R5, 1152 */
		/* 82269420h case   32:*/		cpu::op::li<0>(regs,&regs.R5,0x480);
		/* 82269420h case   32:*/		return 0x82269424;
		  /* 82269424h */ case   33:  		/* stvlx VR116, <#[R5 + R3]> */
		/* 82269424h case   33:*/		cpu::mem::stvlx( regs, regs.VR116, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 82269424h case   33:*/		return 0x82269428;
		  /* 82269428h */ case   34:  		/* li R5, 1168 */
		/* 82269428h case   34:*/		cpu::op::li<0>(regs,&regs.R5,0x490);
		/* 82269428h case   34:*/		return 0x8226942C;
		  /* 8226942Ch */ case   35:  		/* stvlx VR117, <#[R5 + R3]> */
		/* 8226942Ch case   35:*/		cpu::mem::stvlx( regs, regs.VR117, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 8226942Ch case   35:*/		return 0x82269430;
		  /* 82269430h */ case   36:  		/* li R5, 1184 */
		/* 82269430h case   36:*/		cpu::op::li<0>(regs,&regs.R5,0x4A0);
		/* 82269430h case   36:*/		return 0x82269434;
		  /* 82269434h */ case   37:  		/* stvlx VR118, <#[R5 + R3]> */
		/* 82269434h case   37:*/		cpu::mem::stvlx( regs, regs.VR118, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 82269434h case   37:*/		return 0x82269438;
		  /* 82269438h */ case   38:  		/* li R5, 1200 */
		/* 82269438h case   38:*/		cpu::op::li<0>(regs,&regs.R5,0x4B0);
		/* 82269438h case   38:*/		return 0x8226943C;
		  /* 8226943Ch */ case   39:  		/* stvlx VR119, <#[R5 + R3]> */
		/* 8226943Ch case   39:*/		cpu::mem::stvlx( regs, regs.VR119, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 8226943Ch case   39:*/		return 0x82269440;
		  /* 82269440h */ case   40:  		/* li R5, 1216 */
		/* 82269440h case   40:*/		cpu::op::li<0>(regs,&regs.R5,0x4C0);
		/* 82269440h case   40:*/		return 0x82269444;
		  /* 82269444h */ case   41:  		/* stvlx VR120, <#[R5 + R3]> */
		/* 82269444h case   41:*/		cpu::mem::stvlx( regs, regs.VR120, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 82269444h case   41:*/		return 0x82269448;
		  /* 82269448h */ case   42:  		/* li R5, 1232 */
		/* 82269448h case   42:*/		cpu::op::li<0>(regs,&regs.R5,0x4D0);
		/* 82269448h case   42:*/		return 0x8226944C;
		  /* 8226944Ch */ case   43:  		/* stvlx VR121, <#[R5 + R3]> */
		/* 8226944Ch case   43:*/		cpu::mem::stvlx( regs, regs.VR121, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 8226944Ch case   43:*/		return 0x82269450;
		  /* 82269450h */ case   44:  		/* li R5, 1248 */
		/* 82269450h case   44:*/		cpu::op::li<0>(regs,&regs.R5,0x4E0);
		/* 82269450h case   44:*/		return 0x82269454;
		  /* 82269454h */ case   45:  		/* stvlx VR122, <#[R5 + R3]> */
		/* 82269454h case   45:*/		cpu::mem::stvlx( regs, regs.VR122, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 82269454h case   45:*/		return 0x82269458;
		  /* 82269458h */ case   46:  		/* li R5, 1264 */
		/* 82269458h case   46:*/		cpu::op::li<0>(regs,&regs.R5,0x4F0);
		/* 82269458h case   46:*/		return 0x8226945C;
		  /* 8226945Ch */ case   47:  		/* stvlx VR123, <#[R5 + R3]> */
		/* 8226945Ch case   47:*/		cpu::mem::stvlx( regs, regs.VR123, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 8226945Ch case   47:*/		return 0x82269460;
		  /* 82269460h */ case   48:  		/* li R5, 1280 */
		/* 82269460h case   48:*/		cpu::op::li<0>(regs,&regs.R5,0x500);
		/* 82269460h case   48:*/		return 0x82269464;
		  /* 82269464h */ case   49:  		/* stvlx VR124, <#[R5 + R3]> */
		/* 82269464h case   49:*/		cpu::mem::stvlx( regs, regs.VR124, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 82269464h case   49:*/		return 0x82269468;
		  /* 82269468h */ case   50:  		/* li R5, 1296 */
		/* 82269468h case   50:*/		cpu::op::li<0>(regs,&regs.R5,0x510);
		/* 82269468h case   50:*/		return 0x8226946C;
		  /* 8226946Ch */ case   51:  		/* stvlx VR125, <#[R5 + R3]> */
		/* 8226946Ch case   51:*/		cpu::mem::stvlx( regs, regs.VR125, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 8226946Ch case   51:*/		return 0x82269470;
		  /* 82269470h */ case   52:  		/* li R5, 1312 */
		/* 82269470h case   52:*/		cpu::op::li<0>(regs,&regs.R5,0x520);
		/* 82269470h case   52:*/		return 0x82269474;
		  /* 82269474h */ case   53:  		/* stvlx VR126, <#[R5 + R3]> */
		/* 82269474h case   53:*/		cpu::mem::stvlx( regs, regs.VR126, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 82269474h case   53:*/		return 0x82269478;
		  /* 82269478h */ case   54:  		/* li R5, 1328 */
		/* 82269478h case   54:*/		cpu::op::li<0>(regs,&regs.R5,0x530);
		/* 82269478h case   54:*/		return 0x8226947C;
		  /* 8226947Ch */ case   55:  		/* stvlx VR127, <#[R5 + R3]> */
		/* 8226947Ch case   55:*/		cpu::mem::stvlx( regs, regs.VR127, (uint32)(regs.R5 + regs.R3 + 0x00000000) );
		/* 8226947Ch case   55:*/		return 0x82269480;
		  /* 82269480h */ case   56:  		/* stw R0, <#[R3 + 308]> */
		/* 82269480h case   56:*/		cpu::mem::store32( regs, regs.R0, (uint32)(regs.R3 + 0x00000134) );
		/* 82269480h case   56:*/		return 0x82269484;
		  /* 82269484h */ case   57:  		/* stw R4, <#[R3 + 304]> */
		/* 82269484h case   57:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R3 + 0x00000130) );
		/* 82269484h case   57:*/		return 0x82269488;
		  /* 82269488h */ case   58:  		/* std R1, <#[R3 + 144]> */
		/* 82269488h case   58:*/		cpu::mem::store64( regs, regs.R1, (uint32)(regs.R3 + 0x00000090) );
		/* 82269488h case   58:*/		return 0x8226948C;
		  /* 8226948Ch */ case   59:  		/* li R0, 0 */
		/* 8226948Ch case   59:*/		cpu::op::li<0>(regs,&regs.R0,0x0);
		/* 8226948Ch case   59:*/		return 0x82269490;
		  /* 82269490h */ case   60:  		/* stw R0, <#[R3 + 312]> */
		/* 82269490h case   60:*/		cpu::mem::store32( regs, regs.R0, (uint32)(regs.R3 + 0x00000138) );
		/* 82269490h case   60:*/		return 0x82269494;
		  /* 82269494h */ case   61:  		/* li R3, 0 */
		/* 82269494h case   61:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82269494h case   61:*/		return 0x82269498;
		  /* 82269498h */ case   62:  		/* bclr 20, CR0_LT */
		/* 82269498h case   62:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82269498h case   62:*/		return 0x8226949C;
	}
	return 0x8226949C;
} // Block from 822693A0h-8226949Ch (63 instructions)

//////////////////////////////////////////////////////
// Block at 8226949Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226949C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226949C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226949C);
		  /* 8226949Ch */ case    0:  		/* nop */
		/* 8226949Ch case    0:*/		cpu::op::nop();
		/* 8226949Ch case    0:*/		return 0x822694A0;
	}
	return 0x822694A0;
} // Block from 8226949Ch-822694A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822694A0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822694A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822694A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822694A0);
		  /* 822694A0h */ case    0:  		/* mfspr R12, LR */
		/* 822694A0h case    0:*/		regs.R12 = regs.LR;
		/* 822694A0h case    0:*/		return 0x822694A4;
		  /* 822694A4h */ case    1:  		/* bl -1933900 */
		/* 822694A4h case    1:*/		regs.LR = 0x822694A8; return 0x82091258;
		/* 822694A4h case    1:*/		return 0x822694A8;
		  /* 822694A8h */ case    2:  		/* stfd FR31, <#[R1 - 48]> */
		/* 822694A8h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFD0) );
		/* 822694A8h case    2:*/		return 0x822694AC;
		  /* 822694ACh */ case    3:  		/* stwu R1, <#[R1 - 144]> */
		/* 822694ACh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 822694ACh case    3:*/		return 0x822694B0;
		  /* 822694B0h */ case    4:  		/* mr R31, R4 */
		/* 822694B0h case    4:*/		regs.R31 = regs.R4;
		/* 822694B0h case    4:*/		return 0x822694B4;
		  /* 822694B4h */ case    5:  		/* stfd FR1, <#[R1 + 160]> */
		/* 822694B4h case    5:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x000000A0) );
		/* 822694B4h case    5:*/		return 0x822694B8;
		  /* 822694B8h */ case    6:  		/* li R4, 0 */
		/* 822694B8h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 822694B8h case    6:*/		return 0x822694BC;
		  /* 822694BCh */ case    7:  		/* fmr FR31, FR1 */
		/* 822694BCh case    7:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR1);
		/* 822694BCh case    7:*/		return 0x822694C0;
		  /* 822694C0h */ case    8:  		/* li R3, 0 */
		/* 822694C0h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822694C0h case    8:*/		return 0x822694C4;
		  /* 822694C4h */ case    9:  		/* bl -1902084 */
		/* 822694C4h case    9:*/		regs.LR = 0x822694C8; return 0x82098EC0;
		/* 822694C4h case    9:*/		return 0x822694C8;
		  /* 822694C8h */ case   10:  		/* lis R10, -16377 */
		/* 822694C8h case   10:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFC007);
		/* 822694C8h case   10:*/		return 0x822694CC;
		  /* 822694CCh */ case   11:  		/* lis R11, -32216 */
		/* 822694CCh case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 822694CCh case   11:*/		return 0x822694D0;
		  /* 822694D0h */ case   12:  		/* ori R28, R10, 65279 */
		/* 822694D0h case   12:*/		cpu::op::ori<0>(regs,&regs.R28,regs.R10,0xFEFF);
		/* 822694D0h case   12:*/		return 0x822694D4;
		  /* 822694D4h */ case   13:  		/* mr R30, R3 */
		/* 822694D4h case   13:*/		regs.R30 = regs.R3;
		/* 822694D4h case   13:*/		return 0x822694D8;
		  /* 822694D8h */ case   14:  		/* mr R4, R28 */
		/* 822694D8h case   14:*/		regs.R4 = regs.R28;
		/* 822694D8h case   14:*/		return 0x822694DC;
		  /* 822694DCh */ case   15:  		/* lwz R3, <#[R11 + 27632]> */
		/* 822694DCh case   15:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x00006BF0) );
		/* 822694DCh case   15:*/		return 0x822694E0;
		  /* 822694E0h */ case   16:  		/* bl -1902112 */
		/* 822694E0h case   16:*/		regs.LR = 0x822694E4; return 0x82098EC0;
		/* 822694E0h case   16:*/		return 0x822694E4;
		  /* 822694E4h */ case   17:  		/* lhz R11, <#[R1 + 160]> */
		/* 822694E4h case   17:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000A0) );
		/* 822694E4h case   17:*/		return 0x822694E8;
		  /* 822694E8h */ case   18:  		/* fmr FR1, FR31 */
		/* 822694E8h case   18:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 822694E8h case   18:*/		return 0x822694EC;
		  /* 822694ECh */ case   19:  		/* rlwinm R10, R11, 0, 17, 27 */
		/* 822694ECh case   19:*/		cpu::op::rlwinm<0,0,17,27>(regs,&regs.R10,regs.R11);
		/* 822694ECh case   19:*/		return 0x822694F0;
		  /* 822694F0h */ case   20:  		/* mr R29, R11 */
		/* 822694F0h case   20:*/		regs.R29 = regs.R11;
		/* 822694F0h case   20:*/		return 0x822694F4;
		  /* 822694F4h */ case   21:  		/* cmplwi CR6, R10, 32752 */
		/* 822694F4h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00007FF0);
		/* 822694F4h case   21:*/		return 0x822694F8;
		  /* 822694F8h */ case   22:  		/* bc 4, CR6_EQ, 136 */
		/* 822694F8h case   22:*/		if ( !regs.CR[6].eq ) { return 0x82269580;  }
		/* 822694F8h case   22:*/		return 0x822694FC;
		  /* 822694FCh */ case   23:  		/* lis R11, -32217 */
		/* 822694FCh case   23:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8227);
		/* 822694FCh case   23:*/		return 0x82269500;
		  /* 82269500h */ case   24:  		/* lfd FR0, <#[R11 + 7336]> */
		/* 82269500h case   24:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00001CA8) );
		/* 82269500h case   24:*/		return 0x82269504;
		  /* 82269504h */ case   25:  		/* stfd FR0, <#[R31]> */
		/* 82269504h case   25:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R31 + 0x00000000) );
		/* 82269504h case   25:*/		return 0x82269508;
		  /* 82269508h */ case   26:  		/* bl -1919752 */
		/* 82269508h case   26:*/		regs.LR = 0x8226950C; return 0x82094A00;
		/* 82269508h case   26:*/		return 0x8226950C;
		  /* 8226950Ch */ case   27:  		/* cmpwi CR0, R3, 0 */
		/* 8226950Ch case   27:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8226950Ch case   27:*/		return 0x82269510;
		  /* 82269510h */ case   28:  		/* bc 4, CR0_GT, 72 */
		/* 82269510h case   28:*/		if ( !regs.CR[0].gt ) { return 0x82269558;  }
		/* 82269510h case   28:*/		return 0x82269514;
		  /* 82269514h */ case   29:  		/* cmpwi CR6, R3, 2 */
		/* 82269514h case   29:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000002);
		/* 82269514h case   29:*/		return 0x82269518;
		  /* 82269518h */ case   30:  		/* bc 4, CR6_GT, 36 */
		/* 82269518h case   30:*/		if ( !regs.CR[6].gt ) { return 0x8226953C;  }
		/* 82269518h case   30:*/		return 0x8226951C;
		  /* 8226951Ch */ case   31:  		/* cmpwi CR6, R3, 3 */
		/* 8226951Ch case   31:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000003);
		/* 8226951Ch case   31:*/		return 0x82269520;
		  /* 82269520h */ case   32:  		/* bc 4, CR6_EQ, 56 */
		/* 82269520h case   32:*/		if ( !regs.CR[6].eq ) { return 0x82269558;  }
		/* 82269520h case   32:*/		return 0x82269524;
		  /* 82269524h */ case   33:  		/* stfd FR31, <#[R31]> */
		/* 82269524h case   33:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R31 + 0x00000000) );
		/* 82269524h case   33:*/		return 0x82269528;
	}
	return 0x82269528;
} // Block from 822694A0h-82269528h (34 instructions)

//////////////////////////////////////////////////////
// Block at 82269528h
// Function 'exp'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269528( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269528) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269528);
		  /* 82269528h */ case    0:  		/* mr R5, R30 */
		/* 82269528h case    0:*/		regs.R5 = regs.R30;
		/* 82269528h case    0:*/		return 0x8226952C;
		  /* 8226952Ch */ case    1:  		/* li R3, 28 */
		/* 8226952Ch case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1C);
		/* 8226952Ch case    1:*/		return 0x82269530;
		  /* 82269530h */ case    2:  		/* fmr FR1, FR31 */
		/* 82269530h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 82269530h case    2:*/		return 0x82269534;
		  /* 82269534h */ case    3:  		/* bl -1902916 */
		/* 82269534h case    3:*/		regs.LR = 0x82269538; return 0x82098BF0;
		/* 82269534h case    3:*/		return 0x82269538;
		  /* 82269538h */ case    4:  		/* b 140 */
		/* 82269538h case    4:*/		return 0x822695C4;
		/* 82269538h case    4:*/		return 0x8226953C;
	}
	return 0x8226953C;
} // Block from 82269528h-8226953Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8226953Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226953C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226953C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226953C);
		  /* 8226953Ch */ case    0:  		/* stfd FR31, <#[R31]> */
		/* 8226953Ch case    0:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R31 + 0x00000000) );
		/* 8226953Ch case    0:*/		return 0x82269540;
		  /* 82269540h */ case    1:  		/* lis R11, -32256 */
		/* 82269540h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82269540h case    1:*/		return 0x82269544;
		  /* 82269544h */ case    2:  		/* fmr FR2, FR31 */
		/* 82269544h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR31);
		/* 82269544h case    2:*/		return 0x82269548;
		  /* 82269548h */ case    3:  		/* lfd FR1, <#[R11 + 1808]> */
		/* 82269548h case    3:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R11 + 0x00000710) );
		/* 82269548h case    3:*/		return 0x8226954C;
		  /* 8226954Ch */ case    4:  		/* bl -1906148 */
		/* 8226954Ch case    4:*/		regs.LR = 0x82269550; return 0x82097F68;
		/* 8226954Ch case    4:*/		return 0x82269550;
		  /* 82269550h */ case    5:  		/* fmr FR31, FR1 */
		/* 82269550h case    5:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR1);
		/* 82269550h case    5:*/		return 0x82269554;
		  /* 82269554h */ case    6:  		/* b 96 */
		/* 82269554h case    6:*/		return 0x822695B4;
		/* 82269554h case    6:*/		return 0x82269558;
	}
	return 0x82269558;
} // Block from 8226953Ch-82269558h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82269558h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269558( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269558) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269558);
		  /* 82269558h */ case    0:  		/* lis R11, -32256 */
		/* 82269558h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82269558h case    0:*/		return 0x8226955C;
		  /* 8226955Ch */ case    1:  		/* fmr FR1, FR31 */
		/* 8226955Ch case    1:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 8226955Ch case    1:*/		return 0x82269560;
		  /* 82269560h */ case    2:  		/* mr R7, R30 */
		/* 82269560h case    2:*/		regs.R7 = regs.R30;
		/* 82269560h case    2:*/		return 0x82269564;
		  /* 82269564h */ case    3:  		/* li R4, 28 */
		/* 82269564h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x1C);
		/* 82269564h case    3:*/		return 0x82269568;
		  /* 82269568h */ case    4:  		/* li R3, 8 */
		/* 82269568h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x8);
		/* 82269568h case    4:*/		return 0x8226956C;
		  /* 8226956Ch */ case    5:  		/* lfd FR0, <#[R11 + 1848]> */
		/* 8226956Ch case    5:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000738) );
		/* 8226956Ch case    5:*/		return 0x82269570;
		  /* 82269570h */ case    6:  		/* fadd FR2, FR31, FR0 */
		/* 82269570h case    6:*/		cpu::op::fadd<0>(regs,&regs.FR2,regs.FR31,regs.FR0);
		/* 82269570h case    6:*/		return 0x82269574;
		  /* 82269574h */ case    7:  		/* stfd FR2, <#[R31]> */
		/* 82269574h case    7:*/		cpu::mem::store64f( regs, regs.FR2, (uint32)(regs.R31 + 0x00000000) );
		/* 82269574h case    7:*/		return 0x82269578;
		  /* 82269578h */ case    8:  		/* bl -1902720 */
		/* 82269578h case    8:*/		regs.LR = 0x8226957C; return 0x82098CF8;
		/* 82269578h case    8:*/		return 0x8226957C;
		  /* 8226957Ch */ case    9:  		/* b 72 */
		/* 8226957Ch case    9:*/		return 0x822695C4;
		/* 8226957Ch case    9:*/		return 0x82269580;
	}
	return 0x82269580;
} // Block from 82269558h-82269580h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82269580h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269580( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269580) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269580);
		  /* 82269580h */ case    0:  		/* bl 496 */
		/* 82269580h case    0:*/		regs.LR = 0x82269584; return 0x82269770;
		/* 82269580h case    0:*/		return 0x82269584;
		  /* 82269584h */ case    1:  		/* fsub FR31, FR31, FR1 */
		/* 82269584h case    1:*/		cpu::op::fsub<0>(regs,&regs.FR31,regs.FR31,regs.FR1);
		/* 82269584h case    1:*/		return 0x82269588;
		  /* 82269588h */ case    2:  		/* lis R11, -32256 */
		/* 82269588h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82269588h case    2:*/		return 0x8226958C;
		  /* 8226958Ch */ case    3:  		/* stfd FR1, <#[R31]> */
		/* 8226958Ch case    3:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R31 + 0x00000000) );
		/* 8226958Ch case    3:*/		return 0x82269590;
		  /* 82269590h */ case    4:  		/* stfd FR31, <#[R1 + 80]> */
		/* 82269590h case    4:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0x00000050) );
		/* 82269590h case    4:*/		return 0x82269594;
		  /* 82269594h */ case    5:  		/* lfd FR0, <#[R11 + 1808]> */
		/* 82269594h case    5:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000710) );
		/* 82269594h case    5:*/		return 0x82269598;
		  /* 82269598h */ case    6:  		/* fcmpu CR6, FR31, FR0 */
		/* 82269598h case    6:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR0);
		/* 82269598h case    6:*/		return 0x8226959C;
		  /* 8226959Ch */ case    7:  		/* bc 4, CR6_EQ, 24 */
		/* 8226959Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x822695B4;  }
		/* 8226959Ch case    7:*/		return 0x822695A0;
		  /* 822695A0h */ case    8:  		/* lhz R11, <#[R1 + 80]> */
		/* 822695A0h case    8:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 822695A0h case    8:*/		return 0x822695A4;
		  /* 822695A4h */ case    9:  		/* rlwinm R10, R29, 0, 16, 16 */
		/* 822695A4h case    9:*/		cpu::op::rlwinm<0,0,16,16>(regs,&regs.R10,regs.R29);
		/* 822695A4h case    9:*/		return 0x822695A8;
		  /* 822695A8h */ case   10:  		/* or R11, R10, R11 */
		/* 822695A8h case   10:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 822695A8h case   10:*/		return 0x822695AC;
		  /* 822695ACh */ case   11:  		/* sth R11, <#[R1 + 80]> */
		/* 822695ACh case   11:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 822695ACh case   11:*/		return 0x822695B0;
		  /* 822695B0h */ case   12:  		/* lfd FR31, <#[R1 + 80]> */
		/* 822695B0h case   12:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0x00000050) );
		/* 822695B0h case   12:*/		return 0x822695B4;
	}
	return 0x822695B4;
} // Block from 82269580h-822695B4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 822695B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822695B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822695B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822695B4);
		  /* 822695B4h */ case    0:  		/* mr R4, R28 */
		/* 822695B4h case    0:*/		regs.R4 = regs.R28;
		/* 822695B4h case    0:*/		return 0x822695B8;
		  /* 822695B8h */ case    1:  		/* mr R3, R30 */
		/* 822695B8h case    1:*/		regs.R3 = regs.R30;
		/* 822695B8h case    1:*/		return 0x822695BC;
		  /* 822695BCh */ case    2:  		/* bl -1902332 */
		/* 822695BCh case    2:*/		regs.LR = 0x822695C0; return 0x82098EC0;
		/* 822695BCh case    2:*/		return 0x822695C0;
		  /* 822695C0h */ case    3:  		/* fmr FR1, FR31 */
		/* 822695C0h case    3:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 822695C0h case    3:*/		return 0x822695C4;
	}
	return 0x822695C4;
} // Block from 822695B4h-822695C4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822695C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822695C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822695C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822695C4);
		  /* 822695C4h */ case    0:  		/* addi R1, R1, 144 */
		/* 822695C4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 822695C4h case    0:*/		return 0x822695C8;
		  /* 822695C8h */ case    1:  		/* lfd FR31, <#[R1 - 48]> */
		/* 822695C8h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFD0) );
		/* 822695C8h case    1:*/		return 0x822695CC;
		  /* 822695CCh */ case    2:  		/* b -1934116 */
		/* 822695CCh case    2:*/		return 0x820912A8;
		/* 822695CCh case    2:*/		return 0x822695D0;
		  /* 822695D0h */ case    3:  		/* cmplwi CR6, R5, 0 */
		/* 822695D0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 822695D0h case    3:*/		return 0x822695D4;
		  /* 822695D4h */ case    4:  		/* bc 12, CR6_EQ, 92 */
		/* 822695D4h case    4:*/		if ( regs.CR[6].eq ) { return 0x82269630;  }
		/* 822695D4h case    4:*/		return 0x822695D8;
		  /* 822695D8h */ case    5:  		/* addi R8, R3, -1 */
		/* 822695D8h case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R3,0xFFFFFFFF);
		/* 822695D8h case    5:*/		return 0x822695DC;
		  /* 822695DCh */ case    6:  		/* addi R9, R4, -1 */
		/* 822695DCh case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R4,0xFFFFFFFF);
		/* 822695DCh case    6:*/		return 0x822695E0;
		  /* 822695E0h */ case    7:  		/* lbzu R10, <#[R8 + 1]> */
		/* 822695E0h case    7:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000001) );
		regs.R8 = (uint32)(regs.R8 + 0x00000001);
		/* 822695E0h case    7:*/		return 0x822695E4;
		  /* 822695E4h */ case    8:  		/* cmpwi CR6, R10, 65 */
		/* 822695E4h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000041);
		/* 822695E4h case    8:*/		return 0x822695E8;
		  /* 822695E8h */ case    9:  		/* bc 12, CR6_LT, 16 */
		/* 822695E8h case    9:*/		if ( regs.CR[6].lt ) { return 0x822695F8;  }
		/* 822695E8h case    9:*/		return 0x822695EC;
		  /* 822695ECh */ case   10:  		/* cmpwi CR6, R10, 90 */
		/* 822695ECh case   10:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000005A);
		/* 822695ECh case   10:*/		return 0x822695F0;
		  /* 822695F0h */ case   11:  		/* bc 12, CR6_GT, 8 */
		/* 822695F0h case   11:*/		if ( regs.CR[6].gt ) { return 0x822695F8;  }
		/* 822695F0h case   11:*/		return 0x822695F4;
		  /* 822695F4h */ case   12:  		/* addi R10, R10, 32 */
		/* 822695F4h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x20);
		/* 822695F4h case   12:*/		return 0x822695F8;
	}
	return 0x822695F8;
} // Block from 822695C4h-822695F8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 822695F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822695F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822695F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822695F8);
		  /* 822695F8h */ case    0:  		/* lbzu R11, <#[R9 + 1]> */
		/* 822695F8h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000001) );
		regs.R9 = (uint32)(regs.R9 + 0x00000001);
		/* 822695F8h case    0:*/		return 0x822695FC;
		  /* 822695FCh */ case    1:  		/* cmpwi CR6, R11, 65 */
		/* 822695FCh case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000041);
		/* 822695FCh case    1:*/		return 0x82269600;
		  /* 82269600h */ case    2:  		/* bc 12, CR6_LT, 16 */
		/* 82269600h case    2:*/		if ( regs.CR[6].lt ) { return 0x82269610;  }
		/* 82269600h case    2:*/		return 0x82269604;
		  /* 82269604h */ case    3:  		/* cmpwi CR6, R11, 90 */
		/* 82269604h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000005A);
		/* 82269604h case    3:*/		return 0x82269608;
	}
	return 0x82269608;
} // Block from 822695F8h-82269608h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82269608h
// Function '_exphlp'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269608( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269608) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269608);
		  /* 82269608h */ case    0:  		/* bc 12, CR6_GT, 8 */
		/* 82269608h case    0:*/		if ( regs.CR[6].gt ) { return 0x82269610;  }
		/* 82269608h case    0:*/		return 0x8226960C;
		  /* 8226960Ch */ case    1:  		/* addi R11, R11, 32 */
		/* 8226960Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x20);
		/* 8226960Ch case    1:*/		return 0x82269610;
	}
	return 0x82269610;
} // Block from 82269608h-82269610h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82269610h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269610( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269610) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269610);
		  /* 82269610h */ case    0:  		/* addic. R5, R5, -1 */
		/* 82269610h case    0:*/		cpu::op::addic<1>(regs,&regs.R5,regs.R5,0xFFFFFFFF);
		/* 82269610h case    0:*/		return 0x82269614;
		  /* 82269614h */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 82269614h case    1:*/		if ( regs.CR[0].eq ) { return 0x82269628;  }
		/* 82269614h case    1:*/		return 0x82269618;
		  /* 82269618h */ case    2:  		/* cmpwi CR6, R10, 0 */
		/* 82269618h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 82269618h case    2:*/		return 0x8226961C;
		  /* 8226961Ch */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 8226961Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x82269628;  }
		/* 8226961Ch case    3:*/		return 0x82269620;
		  /* 82269620h */ case    4:  		/* cmpw CR6, R10, R11 */
		/* 82269620h case    4:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R11);
		/* 82269620h case    4:*/		return 0x82269624;
		  /* 82269624h */ case    5:  		/* bc 12, CR6_EQ, -68 */
		/* 82269624h case    5:*/		if ( regs.CR[6].eq ) { return 0x822695E0;  }
		/* 82269624h case    5:*/		return 0x82269628;
	}
	return 0x82269628;
} // Block from 82269610h-82269628h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82269628h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269628( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269628) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269628);
		  /* 82269628h */ case    0:  		/* subf R3, R11, R10 */
		/* 82269628h case    0:*/		cpu::op::subf<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 82269628h case    0:*/		return 0x8226962C;
		  /* 8226962Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 8226962Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8226962Ch case    1:*/		return 0x82269630;
	}
	return 0x82269630;
} // Block from 82269628h-82269630h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82269630h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269630( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269630) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269630);
		  /* 82269630h */ case    0:  		/* li R3, 0 */
		/* 82269630h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 82269630h case    0:*/		return 0x82269634;
		  /* 82269634h */ case    1:  		/* bclr 20, CR0_LT */
		/* 82269634h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82269634h case    1:*/		return 0x82269638;
	}
	return 0x82269638;
} // Block from 82269630h-82269638h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82269638h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269638( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269638) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269638);
		  /* 82269638h */ case    0:  		/* mfspr R12, LR */
		/* 82269638h case    0:*/		regs.R12 = regs.LR;
		/* 82269638h case    0:*/		return 0x8226963C;
		  /* 8226963Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8226963Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8226963Ch case    1:*/		return 0x82269640;
		  /* 82269640h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82269640h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82269640h case    2:*/		return 0x82269644;
		  /* 82269644h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 82269644h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82269644h case    3:*/		return 0x82269648;
		  /* 82269648h */ case    4:  		/* cmplwi CR6, R3, 0 */
		/* 82269648h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 82269648h case    4:*/		return 0x8226964C;
		  /* 8226964Ch */ case    5:  		/* bc 4, CR6_EQ, 32 */
		/* 8226964Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x8226966C;  }
		/* 8226964Ch case    5:*/		return 0x82269650;
		  /* 82269650h */ case    6:  		/* bl -1918792 */
		/* 82269650h case    6:*/		regs.LR = 0x82269654; return 0x82094F08;
		/* 82269650h case    6:*/		return 0x82269654;
		  /* 82269654h */ case    7:  		/* li R11, 22 */
		/* 82269654h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x16);
		/* 82269654h case    7:*/		return 0x82269658;
		  /* 82269658h */ case    8:  		/* stw R11, <#[R3]> */
		/* 82269658h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 82269658h case    8:*/		return 0x8226965C;
		  /* 8226965Ch */ case    9:  		/* bl -1924348 */
		/* 8226965Ch case    9:*/		regs.LR = 0x82269660; return 0x82093960;
		/* 8226965Ch case    9:*/		return 0x82269660;
		  /* 82269660h */ case   10:  		/* lis R3, 32767 */
		/* 82269660h case   10:*/		cpu::op::lis<0>(regs,&regs.R3,0x7FFF);
		/* 82269660h case   10:*/		return 0x82269664;
		  /* 82269664h */ case   11:  		/* ori R3, R3, 65535 */
		/* 82269664h case   11:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0xFFFF);
		/* 82269664h case   11:*/		return 0x82269668;
		  /* 82269668h */ case   12:  		/* b 56 */
		/* 82269668h case   12:*/		return 0x822696A0;
		/* 82269668h case   12:*/		return 0x8226966C;
	}
	return 0x8226966C;
} // Block from 82269638h-8226966Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8226966Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226966C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226966C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226966C);
		  /* 8226966Ch */ case    0:  		/* cmplwi CR6, R4, 0 */
		/* 8226966Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 8226966Ch case    0:*/		return 0x82269670;
		  /* 82269670h */ case    1:  		/* bc 12, CR6_EQ, -32 */
		/* 82269670h case    1:*/		if ( regs.CR[6].eq ) { return 0x82269650;  }
		/* 82269670h case    1:*/		return 0x82269674;
		  /* 82269674h */ case    2:  		/* lis R11, 32767 */
		/* 82269674h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0x7FFF);
		/* 82269674h case    2:*/		return 0x82269678;
		  /* 82269678h */ case    3:  		/* ori R31, R11, 65535 */
		/* 82269678h case    3:*/		cpu::op::ori<0>(regs,&regs.R31,regs.R11,0xFFFF);
		/* 82269678h case    3:*/		return 0x8226967C;
		  /* 8226967Ch */ case    4:  		/* cmplw CR6, R5, R31 */
		/* 8226967Ch case    4:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R31);
		/* 8226967Ch case    4:*/		return 0x82269680;
		  /* 82269680h */ case    5:  		/* bc 4, CR6_GT, 28 */
		/* 82269680h case    5:*/		if ( !regs.CR[6].gt ) { return 0x8226969C;  }
		/* 82269680h case    5:*/		return 0x82269684;
		  /* 82269684h */ case    6:  		/* bl -1918844 */
		/* 82269684h case    6:*/		regs.LR = 0x82269688; return 0x82094F08;
		/* 82269684h case    6:*/		return 0x82269688;
		  /* 82269688h */ case    7:  		/* li R11, 22 */
		/* 82269688h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x16);
		/* 82269688h case    7:*/		return 0x8226968C;
		  /* 8226968Ch */ case    8:  		/* stw R11, <#[R3]> */
		/* 8226968Ch case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8226968Ch case    8:*/		return 0x82269690;
		  /* 82269690h */ case    9:  		/* bl -1924400 */
		/* 82269690h case    9:*/		regs.LR = 0x82269694; return 0x82093960;
		/* 82269690h case    9:*/		return 0x82269694;
		  /* 82269694h */ case   10:  		/* mr R3, R31 */
		/* 82269694h case   10:*/		regs.R3 = regs.R31;
		/* 82269694h case   10:*/		return 0x82269698;
		  /* 82269698h */ case   11:  		/* b 8 */
		/* 82269698h case   11:*/		return 0x822696A0;
		/* 82269698h case   11:*/		return 0x8226969C;
	}
	return 0x8226969C;
} // Block from 8226966Ch-8226969Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8226969Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226969C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226969C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226969C);
		  /* 8226969Ch */ case    0:  		/* bl -204 */
		/* 8226969Ch case    0:*/		regs.LR = 0x822696A0; return 0x822695D0;
		/* 8226969Ch case    0:*/		return 0x822696A0;
	}
	return 0x822696A0;
} // Block from 8226969Ch-822696A0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822696A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822696A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822696A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822696A0);
		  /* 822696A0h */ case    0:  		/* addi R1, R1, 96 */
		/* 822696A0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 822696A0h case    0:*/		return 0x822696A4;
		  /* 822696A4h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 822696A4h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822696A4h case    1:*/		return 0x822696A8;
		  /* 822696A8h */ case    2:  		/* mtspr LR, R12 */
		/* 822696A8h case    2:*/		regs.LR = regs.R12;
		/* 822696A8h case    2:*/		return 0x822696AC;
		  /* 822696ACh */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 822696ACh case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822696ACh case    3:*/		return 0x822696B0;
		  /* 822696B0h */ case    4:  		/* bclr 20, CR0_LT */
		/* 822696B0h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822696B0h case    4:*/		return 0x822696B4;
	}
	return 0x822696B4;
} // Block from 822696A0h-822696B4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 822696B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822696B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822696B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822696B4);
		  /* 822696B4h */ case    0:  		/* nop */
		/* 822696B4h case    0:*/		cpu::op::nop();
		/* 822696B4h case    0:*/		return 0x822696B8;
	}
	return 0x822696B8;
} // Block from 822696B4h-822696B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822696B8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822696B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822696B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822696B8);
		  /* 822696B8h */ case    0:  		/* mfspr R12, LR */
		/* 822696B8h case    0:*/		regs.R12 = regs.LR;
		/* 822696B8h case    0:*/		return 0x822696BC;
		  /* 822696BCh */ case    1:  		/* bl -1934440 */
		/* 822696BCh case    1:*/		regs.LR = 0x822696C0; return 0x82091254;
		/* 822696BCh case    1:*/		return 0x822696C0;
		  /* 822696C0h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 822696C0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 822696C0h case    2:*/		return 0x822696C4;
		  /* 822696C4h */ case    3:  		/* mr R10, R5 */
		/* 822696C4h case    3:*/		regs.R10 = regs.R5;
		/* 822696C4h case    3:*/		return 0x822696C8;
		  /* 822696C8h */ case    4:  		/* mr R29, R3 */
		/* 822696C8h case    4:*/		regs.R29 = regs.R3;
		/* 822696C8h case    4:*/		return 0x822696CC;
		  /* 822696CCh */ case    5:  		/* mr R28, R4 */
		/* 822696CCh case    5:*/		regs.R28 = regs.R4;
		/* 822696CCh case    5:*/		return 0x822696D0;
		  /* 822696D0h */ case    6:  		/* mr R5, R4 */
		/* 822696D0h case    6:*/		regs.R5 = regs.R4;
		/* 822696D0h case    6:*/		return 0x822696D4;
		  /* 822696D4h */ case    7:  		/* li R27, 0 */
		/* 822696D4h case    7:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 822696D4h case    7:*/		return 0x822696D8;
		  /* 822696D8h */ case    8:  		/* li R9, 0 */
		/* 822696D8h case    8:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 822696D8h case    8:*/		return 0x822696DC;
		  /* 822696DCh */ case    9:  		/* li R8, 0 */
		/* 822696DCh case    9:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 822696DCh case    9:*/		return 0x822696E0;
	}
	return 0x822696E0;
} // Block from 822696B8h-822696E0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 822696E0h
// Function 'sprintf'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822696E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822696E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822696E0);
		  /* 822696E0h */ case    0:  		/* li R7, 0 */
		/* 822696E0h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 822696E0h case    0:*/		return 0x822696E4;
		  /* 822696E4h */ case    1:  		/* li R6, 0 */
		/* 822696E4h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 822696E4h case    1:*/		return 0x822696E8;
		  /* 822696E8h */ case    2:  		/* addi R4, R1, 80 */
		/* 822696E8h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 822696E8h case    2:*/		return 0x822696EC;
		  /* 822696ECh */ case    3:  		/* addi R3, R1, 96 */
		/* 822696ECh case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 822696ECh case    3:*/		return 0x822696F0;
		  /* 822696F0h */ case    4:  		/* mr R30, R27 */
		/* 822696F0h case    4:*/		regs.R30 = regs.R27;
		/* 822696F0h case    4:*/		return 0x822696F4;
		  /* 822696F4h */ case    5:  		/* bl -1889228 */
		/* 822696F4h case    5:*/		regs.LR = 0x822696F8; return 0x8209C328;
		/* 822696F4h case    5:*/		return 0x822696F8;
		  /* 822696F8h */ case    6:  		/* mr R31, R3 */
		/* 822696F8h case    6:*/		regs.R31 = regs.R3;
		/* 822696F8h case    6:*/		return 0x822696FC;
		  /* 822696FCh */ case    7:  		/* rlwinm. R11, R3, 0, 29, 29 */
		/* 822696FCh case    7:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R3);
		/* 822696FCh case    7:*/		return 0x82269700;
		  /* 82269700h */ case    8:  		/* bc 12, CR0_EQ, 20 */
		/* 82269700h case    8:*/		if ( regs.CR[0].eq ) { return 0x82269714;  }
		/* 82269700h case    8:*/		return 0x82269704;
		  /* 82269704h */ case    9:  		/* li R30, 512 */
		/* 82269704h case    9:*/		cpu::op::li<0>(regs,&regs.R30,0x200);
		/* 82269704h case    9:*/		return 0x82269708;
		  /* 82269708h */ case   10:  		/* stw R27, <#[R1 + 88]> */
		/* 82269708h case   10:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000058) );
		/* 82269708h case   10:*/		return 0x8226970C;
		  /* 8226970Ch */ case   11:  		/* stw R27, <#[R1 + 92]> */
		/* 8226970Ch case   11:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x0000005C) );
		/* 8226970Ch case   11:*/		return 0x82269710;
		  /* 82269710h */ case   12:  		/* b 56 */
		/* 82269710h case   12:*/		return 0x82269748;
		/* 82269710h case   12:*/		return 0x82269714;
	}
	return 0x82269714;
} // Block from 822696E0h-82269714h (13 instructions)

//////////////////////////////////////////////////////
// Block at 82269714h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269714( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269714) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269714);
		  /* 82269714h */ case    0:  		/* addi R4, R1, 88 */
		/* 82269714h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x58);
		/* 82269714h case    0:*/		return 0x82269718;
		  /* 82269718h */ case    1:  		/* addi R3, R1, 96 */
		/* 82269718h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 82269718h case    1:*/		return 0x8226971C;
		  /* 8226971Ch */ case    2:  		/* bl -1892900 */
		/* 8226971Ch case    2:*/		regs.LR = 0x82269720; return 0x8209B4F8;
		/* 8226971Ch case    2:*/		return 0x82269720;
		  /* 82269720h */ case    3:  		/* rlwinm. R11, R31, 0, 30, 30 */
		/* 82269720h case    3:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R31);
		/* 82269720h case    3:*/		return 0x82269724;
		  /* 82269724h */ case    4:  		/* bc 4, CR0_EQ, 12 */
		/* 82269724h case    4:*/		if ( !regs.CR[0].eq ) { return 0x82269730;  }
		/* 82269724h case    4:*/		return 0x82269728;
		  /* 82269728h */ case    5:  		/* cmpwi CR6, R3, 1 */
		/* 82269728h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 82269728h case    5:*/		return 0x8226972C;
		  /* 8226972Ch */ case    6:  		/* bc 4, CR6_EQ, 8 */
		/* 8226972Ch case    6:*/		if ( !regs.CR[6].eq ) { return 0x82269734;  }
		/* 8226972Ch case    6:*/		return 0x82269730;
	}
	return 0x82269730;
} // Block from 82269714h-82269730h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82269730h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269730( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269730) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269730);
		  /* 82269730h */ case    0:  		/* li R30, 128 */
		/* 82269730h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x80);
		/* 82269730h case    0:*/		return 0x82269734;
	}
	return 0x82269734;
} // Block from 82269730h-82269734h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82269734h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269734( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269734) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269734);
		  /* 82269734h */ case    0:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 82269734h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 82269734h case    0:*/		return 0x82269738;
		  /* 82269738h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 82269738h case    1:*/		if ( !regs.CR[0].eq ) { return 0x82269744;  }
		/* 82269738h case    1:*/		return 0x8226973C;
		  /* 8226973Ch */ case    2:  		/* cmpwi CR6, R3, 2 */
		/* 8226973Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000002);
		/* 8226973Ch case    2:*/		return 0x82269740;
		  /* 82269740h */ case    3:  		/* bc 4, CR6_EQ, 8 */
		/* 82269740h case    3:*/		if ( !regs.CR[6].eq ) { return 0x82269748;  }
		/* 82269740h case    3:*/		return 0x82269744;
	}
	return 0x82269744;
} // Block from 82269734h-82269744h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82269744h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269744( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269744) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269744);
		  /* 82269744h */ case    0:  		/* ori R30, R30, 256 */
		/* 82269744h case    0:*/		cpu::op::ori<0>(regs,&regs.R30,regs.R30,0x100);
		/* 82269744h case    0:*/		return 0x82269748;
	}
	return 0x82269748;
} // Block from 82269744h-82269748h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82269748h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269748( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269748) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269748);
		  /* 82269748h */ case    0:  		/* lwz R11, <#[R1 + 80]> */
		/* 82269748h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82269748h case    0:*/		return 0x8226974C;
		  /* 8226974Ch */ case    1:  		/* mr R3, R29 */
		/* 8226974Ch case    1:*/		regs.R3 = regs.R29;
		/* 8226974Ch case    1:*/		return 0x82269750;
		  /* 82269750h */ case    2:  		/* ld R10, <#[R1 + 88]> */
		/* 82269750h case    2:*/		cpu::mem::load64( regs, &regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 82269750h case    2:*/		return 0x82269754;
		  /* 82269754h */ case    3:  		/* subf R11, R28, R11 */
		/* 82269754h case    3:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R28,regs.R11);
		/* 82269754h case    3:*/		return 0x82269758;
		  /* 82269758h */ case    4:  		/* stw R30, <#[R29]> */
		/* 82269758h case    4:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R29 + 0x00000000) );
		/* 82269758h case    4:*/		return 0x8226975C;
		  /* 8226975Ch */ case    5:  		/* stw R11, <#[R29 + 4]> */
		/* 8226975Ch case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 8226975Ch case    5:*/		return 0x82269760;
		  /* 82269760h */ case    6:  		/* std R10, <#[R29 + 16]> */
		/* 82269760h case    6:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R29 + 0x00000010) );
		/* 82269760h case    6:*/		return 0x82269764;
		  /* 82269764h */ case    7:  		/* addi R1, R1, 160 */
		/* 82269764h case    7:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 82269764h case    7:*/		return 0x82269768;
		  /* 82269768h */ case    8:  		/* b -1934532 */
		/* 82269768h case    8:*/		return 0x820912A4;
		/* 82269768h case    8:*/		return 0x8226976C;
		  /* 8226976Ch */ case    9:  		/* nop */
		/* 8226976Ch case    9:*/		cpu::op::nop();
		/* 8226976Ch case    9:*/		return 0x82269770;
	}
	return 0x82269770;
} // Block from 82269748h-82269770h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82269770h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269770( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269770) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269770);
		  /* 82269770h */ case    0:  		/* lis R12, -32251 */
		/* 82269770h case    0:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8205);
		/* 82269770h case    0:*/		return 0x82269774;
		  /* 82269774h */ case    1:  		/* lfd FR4, <#[R12 - 16896]> */
		/* 82269774h case    1:*/		cpu::mem::load64f( regs, &regs.FR4, (uint32)(regs.R12 + 0xFFFFBE00) );
		/* 82269774h case    1:*/		return 0x82269778;
		  /* 82269778h */ case    2:  		/* lis R12, -32251 */
		/* 82269778h case    2:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFF8205);
		/* 82269778h case    2:*/		return 0x8226977C;
		  /* 8226977Ch */ case    3:  		/* lfd FR5, <#[R12 - 16888]> */
		/* 8226977Ch case    3:*/		cpu::mem::load64f( regs, &regs.FR5, (uint32)(regs.R12 + 0xFFFFBE08) );
		/* 8226977Ch case    3:*/		return 0x82269780;
		  /* 82269780h */ case    4:  		/* fcmpu CR0, FR1, FR4 */
		/* 82269780h case    4:*/		cpu::op::fcmpu<0>(regs,regs.FR1,regs.FR4);
		/* 82269780h case    4:*/		return 0x82269784;
		  /* 82269784h */ case    5:  		/* bc 14, CR0_EQ, 44 */
		/* 82269784h case    5:*/		if ( regs.CR[0].eq ) { return 0x822697B0;  }
		/* 82269784h case    5:*/		return 0x82269788;
		  /* 82269788h */ case    6:  		/* fabs FR6, FR1 */
		/* 82269788h case    6:*/		cpu::op::fabs<0>(regs,&regs.FR6,regs.FR1);
		/* 82269788h case    6:*/		return 0x8226978C;
		  /* 8226978Ch */ case    7:  		/* fcmpu CR0, FR6, FR5 */
		/* 8226978Ch case    7:*/		cpu::op::fcmpu<0>(regs,regs.FR6,regs.FR5);
		/* 8226978Ch case    7:*/		return 0x82269790;
		  /* 82269790h */ case    8:  		/* bc 6, CR0_LT, 32 */
		/* 82269790h case    8:*/		if ( !regs.CR[0].lt ) { return 0x822697B0;  }
		/* 82269790h case    8:*/		return 0x82269794;
		  /* 82269794h */ case    9:  		/* fcmpu CR0, FR1, FR4 */
		/* 82269794h case    9:*/		cpu::op::fcmpu<0>(regs,regs.FR1,regs.FR4);
		/* 82269794h case    9:*/		return 0x82269798;
		  /* 82269798h */ case   10:  		/* bc 12, CR0_LT, 16 */
		/* 82269798h case   10:*/		if ( regs.CR[0].lt ) { return 0x822697A8;  }
		/* 82269798h case   10:*/		return 0x8226979C;
		  /* 8226979Ch */ case   11:  		/* fadd FR4, FR1, FR5 */
		/* 8226979Ch case   11:*/		cpu::op::fadd<0>(regs,&regs.FR4,regs.FR1,regs.FR5);
		/* 8226979Ch case   11:*/		return 0x822697A0;
		  /* 822697A0h */ case   12:  		/* fsub FR1, FR4, FR5 */
		/* 822697A0h case   12:*/		cpu::op::fsub<0>(regs,&regs.FR1,regs.FR4,regs.FR5);
		/* 822697A0h case   12:*/		return 0x822697A4;
		  /* 822697A4h */ case   13:  		/* b 12 */
		/* 822697A4h case   13:*/		return 0x822697B0;
		/* 822697A4h case   13:*/		return 0x822697A8;
	}
	return 0x822697A8;
} // Block from 82269770h-822697A8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 822697A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822697A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822697A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822697A8);
		  /* 822697A8h */ case    0:  		/* fsub FR4, FR1, FR5 */
		/* 822697A8h case    0:*/		cpu::op::fsub<0>(regs,&regs.FR4,regs.FR1,regs.FR5);
		/* 822697A8h case    0:*/		return 0x822697AC;
		  /* 822697ACh */ case    1:  		/* fadd FR1, FR4, FR5 */
		/* 822697ACh case    1:*/		cpu::op::fadd<0>(regs,&regs.FR1,regs.FR4,regs.FR5);
		/* 822697ACh case    1:*/		return 0x822697B0;
	}
	return 0x822697B0;
} // Block from 822697A8h-822697B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822697B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822697B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822697B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822697B0);
		  /* 822697B0h */ case    0:  		/* bclr 20, CR0_LT */
		/* 822697B0h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822697B0h case    0:*/		return 0x822697B4;
	}
	return 0x822697B4;
} // Block from 822697B0h-822697B4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822697B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822697B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822697B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822697B4);
		  /* 822697B4h */ case    0:  		/* nop */
		/* 822697B4h case    0:*/		cpu::op::nop();
		/* 822697B4h case    0:*/		return 0x822697B8;
		  /* 822697B8h */ case    1:  		/* nop */
		/* 822697B8h case    1:*/		cpu::op::nop();
		/* 822697B8h case    1:*/		return 0x822697BC;
		  /* 822697BCh */ case    2:  		/* nop */
		/* 822697BCh case    2:*/		cpu::op::nop();
		/* 822697BCh case    2:*/		return 0x822697C0;
	}
	return 0x822697C0;
} // Block from 822697B4h-822697C0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822697C0h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822697C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822697C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822697C0);
		  /* 822697C0h */ case    0:  		/* lis R11, -32216 */
		/* 822697C0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 822697C0h case    0:*/		return 0x822697C4;
		  /* 822697C4h */ case    1:  		/* addi R11, R11, 27648 */
		/* 822697C4h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6C00);
		/* 822697C4h case    1:*/		return 0x822697C8;
	}
	return 0x822697C8;
} // Block from 822697C0h-822697C8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 822697C8h
// Function '_snprintf'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822697C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822697C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822697C8);
		  /* 822697C8h */ case    0:  		/* stw R3, <#[R11 + 4]> */
		/* 822697C8h case    0:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x00000004) );
		/* 822697C8h case    0:*/		return 0x822697CC;
		  /* 822697CCh */ case    1:  		/* stw R4, <#[R11 + 12]> */
		/* 822697CCh case    1:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R11 + 0x0000000C) );
		/* 822697CCh case    1:*/		return 0x822697D0;
		  /* 822697D0h */ case    2:  		/* stw R5, <#[R11 + 8]> */
		/* 822697D0h case    2:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R11 + 0x00000008) );
		/* 822697D0h case    2:*/		return 0x822697D4;
		  /* 822697D4h */ case    3:  		/* bclr 20, CR0_LT */
		/* 822697D4h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822697D4h case    3:*/		return 0x822697D8;
	}
	return 0x822697D8;
} // Block from 822697C8h-822697D8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822697D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822697D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822697D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822697D8);
		  /* 822697D8h */ case    0:  		/* lwz R8, <#[R3]> */
		/* 822697D8h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000000) );
		/* 822697D8h case    0:*/		return 0x822697DC;
		  /* 822697DCh */ case    1:  		/* li R3, 0 */
		/* 822697DCh case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822697DCh case    1:*/		return 0x822697E0;
		  /* 822697E0h */ case    2:  		/* rlwinm. R11, R8, 0, 16, 16 */
		/* 822697E0h case    2:*/		cpu::op::rlwinm<1,0,16,16>(regs,&regs.R11,regs.R8);
		/* 822697E0h case    2:*/		return 0x822697E4;
		  /* 822697E4h */ case    3:  		/* bclr 12, CR0_EQ */
		/* 822697E4h case    3:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 822697E4h case    3:*/		return 0x822697E8;
	}
	return 0x822697E8;
} // Block from 822697D8h-822697E8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822697E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822697E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822697E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822697E8);
		  /* 822697E8h */ case    0:  		/* li R9, 0 */
		/* 822697E8h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 822697E8h case    0:*/		return 0x822697EC;
		  /* 822697ECh */ case    1:  		/* li R11, 1 */
		/* 822697ECh case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 822697ECh case    1:*/		return 0x822697F0;
		  /* 822697F0h */ case    2:  		/* rlwinm R10, R8, 16, 16, 31 */
		/* 822697F0h case    2:*/		cpu::op::rlwinm<0,16,16,31>(regs,&regs.R10,regs.R8);
		/* 822697F0h case    2:*/		return 0x822697F4;
		  /* 822697F4h */ case    3:  		/* slw R11, R11, R9 */
		/* 822697F4h case    3:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 822697F4h case    3:*/		return 0x822697F8;
		  /* 822697F8h */ case    4:  		/* and R10, R10, R11 */
		/* 822697F8h case    4:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 822697F8h case    4:*/		return 0x822697FC;
		  /* 822697FCh */ case    5:  		/* rlwinm R7, R8, 12, 20, 31 */
		/* 822697FCh case    5:*/		cpu::op::rlwinm<0,12,20,31>(regs,&regs.R7,regs.R8);
		/* 822697FCh case    5:*/		return 0x82269800;
		  /* 82269800h */ case    6:  		/* rlwinm R10, R10, 0, 28, 31 */
		/* 82269800h case    6:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R10,regs.R10);
		/* 82269800h case    6:*/		return 0x82269804;
		  /* 82269804h */ case    7:  		/* and R11, R7, R11 */
		/* 82269804h case    7:*/		cpu::op::and<0>(regs,&regs.R11,regs.R7,regs.R11);
		/* 82269804h case    7:*/		return 0x82269808;
		  /* 82269808h */ case    8:  		/* addic R7, R10, -1 */
		/* 82269808h case    8:*/		cpu::op::addic<0>(regs,&regs.R7,regs.R10,0xFFFFFFFF);
		/* 82269808h case    8:*/		return 0x8226980C;
		  /* 8226980Ch */ case    9:  		/* rlwinm R11, R11, 0, 28, 31 */
		/* 8226980Ch case    9:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R11,regs.R11);
		/* 8226980Ch case    9:*/		return 0x82269810;
		  /* 82269810h */ case   10:  		/* subfe R10, R7, R10 */
		/* 82269810h case   10:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R7,regs.R10);
		/* 82269810h case   10:*/		return 0x82269814;
		  /* 82269814h */ case   11:  		/* addic R7, R11, -1 */
		/* 82269814h case   11:*/		cpu::op::addic<0>(regs,&regs.R7,regs.R11,0xFFFFFFFF);
		/* 82269814h case   11:*/		return 0x82269818;
		  /* 82269818h */ case   12:  		/* rlwinm R10, R10, 1, 0, 30 */
		/* 82269818h case   12:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R10);
		/* 82269818h case   12:*/		return 0x8226981C;
		  /* 8226981Ch */ case   13:  		/* subfe R11, R7, R11 */
		/* 8226981Ch case   13:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R7,regs.R11);
		/* 8226981Ch case   13:*/		return 0x82269820;
		  /* 82269820h */ case   14:  		/* add R11, R10, R11 */
		/* 82269820h case   14:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 82269820h case   14:*/		return 0x82269824;
		  /* 82269824h */ case   15:  		/* cmplwi CR6, R11, 1 */
		/* 82269824h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 82269824h case   15:*/		return 0x82269828;
		  /* 82269828h */ case   16:  		/* bc 12, CR6_LT, 44 */
		/* 82269828h case   16:*/		if ( regs.CR[6].lt ) { return 0x82269854;  }
		/* 82269828h case   16:*/		return 0x8226982C;
		  /* 8226982Ch */ case   17:  		/* bc 12, CR6_EQ, 32 */
		/* 8226982Ch case   17:*/		if ( regs.CR[6].eq ) { return 0x8226984C;  }
		/* 8226982Ch case   17:*/		return 0x82269830;
		  /* 82269830h */ case   18:  		/* cmplwi CR6, R11, 3 */
		/* 82269830h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 82269830h case   18:*/		return 0x82269834;
		  /* 82269834h */ case   19:  		/* bc 12, CR6_LT, 16 */
		/* 82269834h case   19:*/		if ( regs.CR[6].lt ) { return 0x82269844;  }
		/* 82269834h case   19:*/		return 0x82269838;
		  /* 82269838h */ case   20:  		/* bc 4, CR6_EQ, 40 */
		/* 82269838h case   20:*/		if ( !regs.CR[6].eq ) { return 0x82269860;  }
		/* 82269838h case   20:*/		return 0x8226983C;
		  /* 8226983Ch */ case   21:  		/* ori R3, R3, 8 */
		/* 8226983Ch case   21:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x8);
		/* 8226983Ch case   21:*/		return 0x82269840;
		  /* 82269840h */ case   22:  		/* b 32 */
		/* 82269840h case   22:*/		return 0x82269860;
		/* 82269840h case   22:*/		return 0x82269844;
	}
	return 0x82269844;
} // Block from 822697E8h-82269844h (23 instructions)

//////////////////////////////////////////////////////
// Block at 82269844h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269844( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269844) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269844);
		  /* 82269844h */ case    0:  		/* ori R3, R3, 1 */
		/* 82269844h case    0:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x1);
		/* 82269844h case    0:*/		return 0x82269848;
		  /* 82269848h */ case    1:  		/* b 24 */
		/* 82269848h case    1:*/		return 0x82269860;
		/* 82269848h case    1:*/		return 0x8226984C;
	}
	return 0x8226984C;
} // Block from 82269844h-8226984Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226984Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226984C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226984C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226984C);
		  /* 8226984Ch */ case    0:  		/* ori R3, R3, 2 */
		/* 8226984Ch case    0:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x2);
		/* 8226984Ch case    0:*/		return 0x82269850;
		  /* 82269850h */ case    1:  		/* b 16 */
		/* 82269850h case    1:*/		return 0x82269860;
		/* 82269850h case    1:*/		return 0x82269854;
	}
	return 0x82269854;
} // Block from 8226984Ch-82269854h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82269854h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269854( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269854) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269854);
		  /* 82269854h */ case    0:  		/* rlwinm. R11, R8, 0, 17, 17 */
		/* 82269854h case    0:*/		cpu::op::rlwinm<1,0,17,17>(regs,&regs.R11,regs.R8);
		/* 82269854h case    0:*/		return 0x82269858;
		  /* 82269858h */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 82269858h case    1:*/		if ( regs.CR[0].eq ) { return 0x82269860;  }
		/* 82269858h case    1:*/		return 0x8226985C;
		  /* 8226985Ch */ case    2:  		/* ori R3, R3, 4 */
		/* 8226985Ch case    2:*/		cpu::op::ori<0>(regs,&regs.R3,regs.R3,0x4);
		/* 8226985Ch case    2:*/		return 0x82269860;
	}
	return 0x82269860;
} // Block from 82269854h-82269860h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82269860h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269860( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269860) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269860);
		  /* 82269860h */ case    0:  		/* addi R9, R9, 1 */
		/* 82269860h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 82269860h case    0:*/		return 0x82269864;
		  /* 82269864h */ case    1:  		/* cmpwi CR6, R9, 4 */
		/* 82269864h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000004);
		/* 82269864h case    1:*/		return 0x82269868;
		  /* 82269868h */ case    2:  		/* bc 12, CR6_LT, -124 */
		/* 82269868h case    2:*/		if ( regs.CR[6].lt ) { return 0x822697EC;  }
		/* 82269868h case    2:*/		return 0x8226986C;
		  /* 8226986Ch */ case    3:  		/* bclr 20, CR0_LT */
		/* 8226986Ch case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8226986Ch case    3:*/		return 0x82269870;
	}
	return 0x82269870;
} // Block from 82269860h-82269870h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82269870h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269870( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269870) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269870);
		  /* 82269870h */ case    0:  		/* mfspr R12, LR */
		/* 82269870h case    0:*/		regs.R12 = regs.LR;
		/* 82269870h case    0:*/		return 0x82269874;
		  /* 82269874h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82269874h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82269874h case    1:*/		return 0x82269878;
		  /* 82269878h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 82269878h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82269878h case    2:*/		return 0x8226987C;
		  /* 8226987Ch */ case    3:  		/* lbz R11, <#[R3 + 8]> */
		/* 8226987Ch case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8226987Ch case    3:*/		return 0x82269880;
		  /* 82269880h */ case    4:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 82269880h case    4:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 82269880h case    4:*/		return 0x82269884;
		  /* 82269884h */ case    5:  		/* cmplwi CR6, R11, 2 */
		/* 82269884h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 82269884h case    5:*/		return 0x82269888;
		  /* 82269888h */ case    6:  		/* bc 4, CR6_EQ, 68 */
		/* 82269888h case    6:*/		if ( !regs.CR[6].eq ) { return 0x822698CC;  }
		/* 82269888h case    6:*/		return 0x8226988C;
		  /* 8226988Ch */ case    7:  		/* lwz R11, <#[R3]> */
		/* 8226988Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 8226988Ch case    7:*/		return 0x82269890;
		  /* 82269890h */ case    8:  		/* rlwinm. R10, R11, 0, 16, 16 */
		/* 82269890h case    8:*/		cpu::op::rlwinm<1,0,16,16>(regs,&regs.R10,regs.R11);
		/* 82269890h case    8:*/		return 0x82269894;
		  /* 82269894h */ case    9:  		/* bc 12, CR0_EQ, 44 */
		/* 82269894h case    9:*/		if ( regs.CR[0].eq ) { return 0x822698C0;  }
		/* 82269894h case    9:*/		return 0x82269898;
		  /* 82269898h */ case   10:  		/* bl -192 */
		/* 82269898h case   10:*/		regs.LR = 0x8226989C; return 0x822697D8;
		/* 82269898h case   10:*/		return 0x8226989C;
		  /* 8226989Ch */ case   11:  		/* rlwinm. R11, R3, 0, 31, 31 */
		/* 8226989Ch case   11:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R3);
		/* 8226989Ch case   11:*/		return 0x822698A0;
		  /* 822698A0h */ case   12:  		/* bc 4, CR0_EQ, 44 */
		/* 822698A0h case   12:*/		if ( !regs.CR[0].eq ) { return 0x822698CC;  }
		/* 822698A0h case   12:*/		return 0x822698A4;
		  /* 822698A4h */ case   13:  		/* rlwinm. R11, R3, 0, 30, 30 */
		/* 822698A4h case   13:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R3);
		/* 822698A4h case   13:*/		return 0x822698A8;
		  /* 822698A8h */ case   14:  		/* bc 12, CR0_EQ, 12 */
		/* 822698A8h case   14:*/		if ( regs.CR[0].eq ) { return 0x822698B4;  }
		/* 822698A8h case   14:*/		return 0x822698AC;
		  /* 822698ACh */ case   15:  		/* li R3, 1 */
		/* 822698ACh case   15:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 822698ACh case   15:*/		return 0x822698B0;
		  /* 822698B0h */ case   16:  		/* b 32 */
		/* 822698B0h case   16:*/		return 0x822698D0;
		/* 822698B0h case   16:*/		return 0x822698B4;
	}
	return 0x822698B4;
} // Block from 82269870h-822698B4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 822698B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822698B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822698B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822698B4);
		  /* 822698B4h */ case    0:  		/* cntlzw R11, R3 */
		/* 822698B4h case    0:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R3);
		/* 822698B4h case    0:*/		return 0x822698B8;
		  /* 822698B8h */ case    1:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 822698B8h case    1:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 822698B8h case    1:*/		return 0x822698BC;
		  /* 822698BCh */ case    2:  		/* b 20 */
		/* 822698BCh case    2:*/		return 0x822698D0;
		/* 822698BCh case    2:*/		return 0x822698C0;
	}
	return 0x822698C0;
} // Block from 822698B4h-822698C0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 822698C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822698C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822698C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822698C0);
		  /* 822698C0h */ case    0:  		/* rlwinm. R11, R11, 0, 12, 15 */
		/* 822698C0h case    0:*/		cpu::op::rlwinm<1,0,12,15>(regs,&regs.R11,regs.R11);
		/* 822698C0h case    0:*/		return 0x822698C4;
		  /* 822698C4h */ case    1:  		/* li R3, 1 */
		/* 822698C4h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 822698C4h case    1:*/		return 0x822698C8;
		  /* 822698C8h */ case    2:  		/* bc 12, CR0_EQ, 8 */
		/* 822698C8h case    2:*/		if ( regs.CR[0].eq ) { return 0x822698D0;  }
		/* 822698C8h case    2:*/		return 0x822698CC;
	}
	return 0x822698CC;
} // Block from 822698C0h-822698CCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 822698CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822698CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822698CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822698CC);
		  /* 822698CCh */ case    0:  		/* li R3, 0 */
		/* 822698CCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 822698CCh case    0:*/		return 0x822698D0;
	}
	return 0x822698D0;
} // Block from 822698CCh-822698D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822698D0h
// Function 'longjmp'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822698D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822698D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822698D0);
		  /* 822698D0h */ case    0:  		/* addi R1, R1, 96 */
		/* 822698D0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 822698D0h case    0:*/		return 0x822698D4;
		  /* 822698D4h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 822698D4h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822698D4h case    1:*/		return 0x822698D8;
		  /* 822698D8h */ case    2:  		/* mtspr LR, R12 */
		/* 822698D8h case    2:*/		regs.LR = regs.R12;
		/* 822698D8h case    2:*/		return 0x822698DC;
		  /* 822698DCh */ case    3:  		/* bclr 20, CR0_LT */
		/* 822698DCh case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822698DCh case    3:*/		return 0x822698E0;
	}
	return 0x822698E0;
} // Block from 822698D0h-822698E0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 822698E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822698E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822698E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822698E0);
		  /* 822698E0h */ case    0:  		/* mfspr R12, LR */
		/* 822698E0h case    0:*/		regs.R12 = regs.LR;
		/* 822698E0h case    0:*/		return 0x822698E4;
		  /* 822698E4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 822698E4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822698E4h case    1:*/		return 0x822698E8;
		  /* 822698E8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 822698E8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 822698E8h case    2:*/		return 0x822698EC;
		  /* 822698ECh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 822698ECh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822698ECh case    3:*/		return 0x822698F0;
		  /* 822698F0h */ case    4:  		/* stwu R1, <#[R1 - 2160]> */
		/* 822698F0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFF790) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFF790);
		/* 822698F0h case    4:*/		return 0x822698F4;
		  /* 822698F4h */ case    5:  		/* mr R31, R3 */
		/* 822698F4h case    5:*/		regs.R31 = regs.R3;
		/* 822698F4h case    5:*/		return 0x822698F8;
		  /* 822698F8h */ case    6:  		/* mr R6, R5 */
		/* 822698F8h case    6:*/		regs.R6 = regs.R5;
		/* 822698F8h case    6:*/		return 0x822698FC;
		  /* 822698FCh */ case    7:  		/* cmplwi CR6, R3, 0 */
		/* 822698FCh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 822698FCh case    7:*/		return 0x82269900;
		  /* 82269900h */ case    8:  		/* bc 12, CR6_EQ, 196 */
		/* 82269900h case    8:*/		if ( regs.CR[6].eq ) { return 0x822699C4;  }
		/* 82269900h case    8:*/		return 0x82269904;
		  /* 82269904h */ case    9:  		/* lwz R11, <#[R3 + 8236]> */
		/* 82269904h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000202C) );
		/* 82269904h case    9:*/		return 0x82269908;
		  /* 82269908h */ case   10:  		/* cmpwi CR6, R11, 0 */
		/* 82269908h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 82269908h case   10:*/		return 0x8226990C;
		  /* 8226990Ch */ case   11:  		/* bc 12, CR6_LT, 184 */
		/* 8226990Ch case   11:*/		if ( regs.CR[6].lt ) { return 0x822699C4;  }
		/* 8226990Ch case   11:*/		return 0x82269910;
		  /* 82269910h */ case   12:  		/* mr R5, R4 */
		/* 82269910h case   12:*/		regs.R5 = regs.R4;
		/* 82269910h case   12:*/		return 0x82269914;
		  /* 82269914h */ case   13:  		/* li R4, 2048 */
		/* 82269914h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x800);
		/* 82269914h case   13:*/		return 0x82269918;
		  /* 82269918h */ case   14:  		/* addi R3, R1, 80 */
		/* 82269918h case   14:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 82269918h case   14:*/		return 0x8226991C;
		  /* 8226991Ch */ case   15:  		/* bl 14172 */
		/* 8226991Ch case   15:*/		regs.LR = 0x82269920; return 0x8226D078;
		/* 8226991Ch case   15:*/		return 0x82269920;
		  /* 82269920h */ case   16:  		/* or. R30, R3, R3 */
		/* 82269920h case   16:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 82269920h case   16:*/		return 0x82269924;
		  /* 82269924h */ case   17:  		/* bc 4, CR0_GT, 160 */
		/* 82269924h case   17:*/		if ( !regs.CR[0].gt ) { return 0x822699C4;  }
		/* 82269924h case   17:*/		return 0x82269928;
		  /* 82269928h */ case   18:  		/* lbz R11, <#[R31 + 8233]> */
		/* 82269928h case   18:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002029) );
		/* 82269928h case   18:*/		return 0x8226992C;
		  /* 8226992Ch */ case   19:  		/* cmplwi CR0, R11, 0 */
		/* 8226992Ch case   19:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8226992Ch case   19:*/		return 0x82269930;
		  /* 82269930h */ case   20:  		/* bc 12, CR0_EQ, 112 */
		/* 82269930h case   20:*/		if ( regs.CR[0].eq ) { return 0x822699A0;  }
		/* 82269930h case   20:*/		return 0x82269934;
		  /* 82269934h */ case   21:  		/* lbz R11, <#[R1 + 80]> */
		/* 82269934h case   21:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 82269934h case   21:*/		return 0x82269938;
		  /* 82269938h */ case   22:  		/* li R10, 0 */
		/* 82269938h case   22:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 82269938h case   22:*/		return 0x8226993C;
		  /* 8226993Ch */ case   23:  		/* extsb R11, R11 */
		/* 8226993Ch case   23:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R11);
		/* 8226993Ch case   23:*/		return 0x82269940;
		  /* 82269940h */ case   24:  		/* stb R10, <#[R31 + 8233]> */
		/* 82269940h case   24:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R31 + 0x00002029) );
		/* 82269940h case   24:*/		return 0x82269944;
		  /* 82269944h */ case   25:  		/* cmpwi CR6, R11, 32 */
		/* 82269944h case   25:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000020);
		/* 82269944h case   25:*/		return 0x82269948;
		  /* 82269948h */ case   26:  		/* bc 12, CR6_EQ, 36 */
		/* 82269948h case   26:*/		if ( regs.CR[6].eq ) { return 0x8226996C;  }
		/* 82269948h case   26:*/		return 0x8226994C;
		  /* 8226994Ch */ case   27:  		/* cmpwi CR6, R11, 45 */
		/* 8226994Ch case   27:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000002D);
		/* 8226994Ch case   27:*/		return 0x82269950;
		  /* 82269950h */ case   28:  		/* bc 12, CR6_EQ, 28 */
		/* 82269950h case   28:*/		if ( regs.CR[6].eq ) { return 0x8226996C;  }
		/* 82269950h case   28:*/		return 0x82269954;
		  /* 82269954h */ case   29:  		/* cmpwi CR6, R11, 48 */
		/* 82269954h case   29:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000030);
		/* 82269954h case   29:*/		return 0x82269958;
		  /* 82269958h */ case   30:  		/* bc 12, CR6_LT, 12 */
		/* 82269958h case   30:*/		if ( regs.CR[6].lt ) { return 0x82269964;  }
		/* 82269958h case   30:*/		return 0x8226995C;
		  /* 8226995Ch */ case   31:  		/* cmpwi CR6, R11, 57 */
		/* 8226995Ch case   31:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000039);
		/* 8226995Ch case   31:*/		return 0x82269960;
		  /* 82269960h */ case   32:  		/* bc 4, CR6_GT, 12 */
		/* 82269960h case   32:*/		if ( !regs.CR[6].gt ) { return 0x8226996C;  }
		/* 82269960h case   32:*/		return 0x82269964;
	}
	return 0x82269964;
} // Block from 822698E0h-82269964h (33 instructions)

//////////////////////////////////////////////////////
// Block at 82269964h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269964( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269964) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269964);
		  /* 82269964h */ case    0:  		/* li R11, 1 */
		/* 82269964h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82269964h case    0:*/		return 0x82269968;
		  /* 82269968h */ case    1:  		/* b 8 */
		/* 82269968h case    1:*/		return 0x82269970;
		/* 82269968h case    1:*/		return 0x8226996C;
	}
	return 0x8226996C;
} // Block from 82269964h-8226996Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226996Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226996C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226996C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226996C);
		  /* 8226996Ch */ case    0:  		/* li R11, 0 */
		/* 8226996Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 8226996Ch case    0:*/		return 0x82269970;
	}
	return 0x82269970;
} // Block from 8226996Ch-82269970h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82269970h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269970( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269970) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269970);
		  /* 82269970h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 82269970h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 82269970h case    0:*/		return 0x82269974;
		  /* 82269974h */ case    1:  		/* bc 4, CR0_EQ, 44 */
		/* 82269974h case    1:*/		if ( !regs.CR[0].eq ) { return 0x822699A0;  }
		/* 82269974h case    1:*/		return 0x82269978;
		  /* 82269978h */ case    2:  		/* lwz R11, <#[R31 + 8216]> */
		/* 82269978h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002018) );
		/* 82269978h case    2:*/		return 0x8226997C;
		  /* 8226997Ch */ case    3:  		/* lis R10, -32255 */
		/* 8226997Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 8226997Ch case    3:*/		return 0x82269980;
		  /* 82269980h */ case    4:  		/* li R5, 1 */
		/* 82269980h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 82269980h case    4:*/		return 0x82269984;
		  /* 82269984h */ case    5:  		/* lwz R3, <#[R31 + 8220]> */
		/* 82269984h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000201C) );
		/* 82269984h case    5:*/		return 0x82269988;
		  /* 82269988h */ case    6:  		/* addi R4, R10, -15864 */
		/* 82269988h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0xFFFFC208);
		/* 82269988h case    6:*/		return 0x8226998C;
		  /* 8226998Ch */ case    7:  		/* mtspr CTR, R11 */
		/* 8226998Ch case    7:*/		regs.CTR = regs.R11;
		/* 8226998Ch case    7:*/		return 0x82269990;
		  /* 82269990h */ case    8:  		/* bcctrl 20, CR0_LT */
		/* 82269990h case    8:*/		if ( 1 ) { regs.LR = 0x82269994; return (uint32)regs.CTR; }
		/* 82269990h case    8:*/		return 0x82269994;
		  /* 82269994h */ case    9:  		/* cmpwi CR0, R3, 0 */
		/* 82269994h case    9:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 82269994h case    9:*/		return 0x82269998;
		  /* 82269998h */ case   10:  		/* bc 4, CR0_LT, 8 */
		/* 82269998h case   10:*/		if ( !regs.CR[0].lt ) { return 0x822699A0;  }
		/* 82269998h case   10:*/		return 0x8226999C;
		  /* 8226999Ch */ case   11:  		/* stw R3, <#[R31 + 8236]> */
		/* 8226999Ch case   11:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000202C) );
		/* 8226999Ch case   11:*/		return 0x822699A0;
	}
	return 0x822699A0;
} // Block from 82269970h-822699A0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 822699A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822699A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822699A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822699A0);
		  /* 822699A0h */ case    0:  		/* lwz R11, <#[R31 + 8216]> */
		/* 822699A0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002018) );
		/* 822699A0h case    0:*/		return 0x822699A4;
		  /* 822699A4h */ case    1:  		/* mr R5, R30 */
		/* 822699A4h case    1:*/		regs.R5 = regs.R30;
		/* 822699A4h case    1:*/		return 0x822699A8;
		  /* 822699A8h */ case    2:  		/* addi R4, R1, 80 */
		/* 822699A8h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 822699A8h case    2:*/		return 0x822699AC;
		  /* 822699ACh */ case    3:  		/* lwz R3, <#[R31 + 8220]> */
		/* 822699ACh case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000201C) );
		/* 822699ACh case    3:*/		return 0x822699B0;
		  /* 822699B0h */ case    4:  		/* mtspr CTR, R11 */
		/* 822699B0h case    4:*/		regs.CTR = regs.R11;
		/* 822699B0h case    4:*/		return 0x822699B4;
		  /* 822699B4h */ case    5:  		/* bcctrl 20, CR0_LT */
		/* 822699B4h case    5:*/		if ( 1 ) { regs.LR = 0x822699B8; return (uint32)regs.CTR; }
		/* 822699B4h case    5:*/		return 0x822699B8;
		  /* 822699B8h */ case    6:  		/* cmpwi CR0, R3, 0 */
		/* 822699B8h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 822699B8h case    6:*/		return 0x822699BC;
		  /* 822699BCh */ case    7:  		/* bc 4, CR0_LT, 8 */
		/* 822699BCh case    7:*/		if ( !regs.CR[0].lt ) { return 0x822699C4;  }
		/* 822699BCh case    7:*/		return 0x822699C0;
		  /* 822699C0h */ case    8:  		/* stw R3, <#[R31 + 8236]> */
		/* 822699C0h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000202C) );
		/* 822699C0h case    8:*/		return 0x822699C4;
	}
	return 0x822699C4;
} // Block from 822699A0h-822699C4h (9 instructions)

//////////////////////////////////////////////////////
// Block at 822699C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822699C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822699C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822699C4);
		  /* 822699C4h */ case    0:  		/* addi R1, R1, 2160 */
		/* 822699C4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x870);
		/* 822699C4h case    0:*/		return 0x822699C8;
		  /* 822699C8h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 822699C8h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822699C8h case    1:*/		return 0x822699CC;
		  /* 822699CCh */ case    2:  		/* mtspr LR, R12 */
		/* 822699CCh case    2:*/		regs.LR = regs.R12;
		/* 822699CCh case    2:*/		return 0x822699D0;
		  /* 822699D0h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 822699D0h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 822699D0h case    3:*/		return 0x822699D4;
		  /* 822699D4h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 822699D4h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 822699D4h case    4:*/		return 0x822699D8;
		  /* 822699D8h */ case    5:  		/* bclr 20, CR0_LT */
		/* 822699D8h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 822699D8h case    5:*/		return 0x822699DC;
	}
	return 0x822699DC;
} // Block from 822699C4h-822699DCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 822699DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822699DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822699DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822699DC);
		  /* 822699DCh */ case    0:  		/* nop */
		/* 822699DCh case    0:*/		cpu::op::nop();
		/* 822699DCh case    0:*/		return 0x822699E0;
	}
	return 0x822699E0;
} // Block from 822699DCh-822699E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 822699E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block822699E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x822699E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x822699E0);
		  /* 822699E0h */ case    0:  		/* mfspr R12, LR */
		/* 822699E0h case    0:*/		regs.R12 = regs.LR;
		/* 822699E0h case    0:*/		return 0x822699E4;
		  /* 822699E4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 822699E4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 822699E4h case    1:*/		return 0x822699E8;
		  /* 822699E8h */ case    2:  		/* std R5, <#[R1 + 32]> */
		/* 822699E8h case    2:*/		cpu::mem::store64( regs, regs.R5, (uint32)(regs.R1 + 0x00000020) );
		/* 822699E8h case    2:*/		return 0x822699EC;
		  /* 822699ECh */ case    3:  		/* std R6, <#[R1 + 40]> */
		/* 822699ECh case    3:*/		cpu::mem::store64( regs, regs.R6, (uint32)(regs.R1 + 0x00000028) );
		/* 822699ECh case    3:*/		return 0x822699F0;
		  /* 822699F0h */ case    4:  		/* std R7, <#[R1 + 48]> */
		/* 822699F0h case    4:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R1 + 0x00000030) );
		/* 822699F0h case    4:*/		return 0x822699F4;
		  /* 822699F4h */ case    5:  		/* std R8, <#[R1 + 56]> */
		/* 822699F4h case    5:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R1 + 0x00000038) );
		/* 822699F4h case    5:*/		return 0x822699F8;
		  /* 822699F8h */ case    6:  		/* std R9, <#[R1 + 64]> */
		/* 822699F8h case    6:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000040) );
		/* 822699F8h case    6:*/		return 0x822699FC;
		  /* 822699FCh */ case    7:  		/* std R10, <#[R1 + 72]> */
		/* 822699FCh case    7:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000048) );
		/* 822699FCh case    7:*/		return 0x82269A00;
		  /* 82269A00h */ case    8:  		/* stwu R1, <#[R1 - 96]> */
		/* 82269A00h case    8:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 82269A00h case    8:*/		return 0x82269A04;
		  /* 82269A04h */ case    9:  		/* li R11, 0 */
		/* 82269A04h case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82269A04h case    9:*/		return 0x82269A08;
		  /* 82269A08h */ case   10:  		/* stw R4, <#[R1 + 124]> */
		/* 82269A08h case   10:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000007C) );
		/* 82269A08h case   10:*/		return 0x82269A0C;
		  /* 82269A0Ch */ case   11:  		/* addi R10, R1, 80 */
		/* 82269A0Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 82269A0Ch case   11:*/		return 0x82269A10;
		  /* 82269A10h */ case   12:  		/* stb R11, <#[R3 + 8232]> */
		/* 82269A10h case   12:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R3 + 0x00002028) );
		/* 82269A10h case   12:*/		return 0x82269A14;
		  /* 82269A14h */ case   13:  		/* addi R11, R1, 128 */
		/* 82269A14h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x80);
		/* 82269A14h case   13:*/		return 0x82269A18;
		  /* 82269A18h */ case   14:  		/* stw R11, <#[R10]> */
		/* 82269A18h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 82269A18h case   14:*/		return 0x82269A1C;
		  /* 82269A1Ch */ case   15:  		/* lwz R5, <#[R1 + 80]> */
		/* 82269A1Ch case   15:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000050) );
		/* 82269A1Ch case   15:*/		return 0x82269A20;
		  /* 82269A20h */ case   16:  		/* bl -320 */
		/* 82269A20h case   16:*/		regs.LR = 0x82269A24; return 0x822698E0;
		/* 82269A20h case   16:*/		return 0x82269A24;
		  /* 82269A24h */ case   17:  		/* addi R1, R1, 96 */
		/* 82269A24h case   17:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 82269A24h case   17:*/		return 0x82269A28;
		  /* 82269A28h */ case   18:  		/* lwz R12, <#[R1 - 8]> */
		/* 82269A28h case   18:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82269A28h case   18:*/		return 0x82269A2C;
		  /* 82269A2Ch */ case   19:  		/* mtspr LR, R12 */
		/* 82269A2Ch case   19:*/		regs.LR = regs.R12;
		/* 82269A2Ch case   19:*/		return 0x82269A30;
		  /* 82269A30h */ case   20:  		/* bclr 20, CR0_LT */
		/* 82269A30h case   20:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82269A30h case   20:*/		return 0x82269A34;
	}
	return 0x82269A34;
} // Block from 822699E0h-82269A34h (21 instructions)

//////////////////////////////////////////////////////
// Block at 82269A34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269A34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269A34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269A34);
		  /* 82269A34h */ case    0:  		/* nop */
		/* 82269A34h case    0:*/		cpu::op::nop();
		/* 82269A34h case    0:*/		return 0x82269A38;
	}
	return 0x82269A38;
} // Block from 82269A34h-82269A38h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82269A38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269A38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269A38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269A38);
		  /* 82269A38h */ case    0:  		/* mfspr R12, LR */
		/* 82269A38h case    0:*/		regs.R12 = regs.LR;
		/* 82269A38h case    0:*/		return 0x82269A3C;
		  /* 82269A3Ch */ case    1:  		/* bl -1935336 */
		/* 82269A3Ch case    1:*/		regs.LR = 0x82269A40; return 0x82091254;
		/* 82269A3Ch case    1:*/		return 0x82269A40;
		  /* 82269A40h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 82269A40h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 82269A40h case    2:*/		return 0x82269A44;
		  /* 82269A44h */ case    3:  		/* lwz R9, <#[R3 + 8]> */
		/* 82269A44h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x00000008) );
		/* 82269A44h case    3:*/		return 0x82269A48;
		  /* 82269A48h */ case    4:  		/* lis R11, -32255 */
		/* 82269A48h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82269A48h case    4:*/		return 0x82269A4C;
		  /* 82269A4Ch */ case    5:  		/* lis R10, -32255 */
		/* 82269A4Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 82269A4Ch case    5:*/		return 0x82269A50;
		  /* 82269A50h */ case    6:  		/* mr R31, R3 */
		/* 82269A50h case    6:*/		regs.R31 = regs.R3;
		/* 82269A50h case    6:*/		return 0x82269A54;
		  /* 82269A54h */ case    7:  		/* mr R30, R4 */
		/* 82269A54h case    7:*/		regs.R30 = regs.R4;
		/* 82269A54h case    7:*/		return 0x82269A58;
		  /* 82269A58h */ case    8:  		/* mr R27, R5 */
		/* 82269A58h case    8:*/		regs.R27 = regs.R5;
		/* 82269A58h case    8:*/		return 0x82269A5C;
		  /* 82269A5Ch */ case    9:  		/* rlwinm. R9, R9, 26, 31, 31 */
		/* 82269A5Ch case    9:*/		cpu::op::rlwinm<1,26,31,31>(regs,&regs.R9,regs.R9);
		/* 82269A5Ch case    9:*/		return 0x82269A60;
		  /* 82269A60h */ case   10:  		/* addi R29, R11, 5216 */
		/* 82269A60h case   10:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x1460);
		/* 82269A60h case   10:*/		return 0x82269A64;
		  /* 82269A64h */ case   11:  		/* addi R28, R10, 5224 */
		/* 82269A64h case   11:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R10,0x1468);
		/* 82269A64h case   11:*/		return 0x82269A68;
		  /* 82269A68h */ case   12:  		/* bc 4, CR0_EQ, 12 */
		/* 82269A68h case   12:*/		if ( !regs.CR[0].eq ) { return 0x82269A74;  }
		/* 82269A68h case   12:*/		return 0x82269A6C;
		  /* 82269A6Ch */ case   13:  		/* cmpwi CR6, R4, 0 */
		/* 82269A6Ch case   13:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000000);
		/* 82269A6Ch case   13:*/		return 0x82269A70;
		  /* 82269A70h */ case   14:  		/* bc 12, CR6_EQ, 60 */
		/* 82269A70h case   14:*/		if ( regs.CR[6].eq ) { return 0x82269AAC;  }
		/* 82269A70h case   14:*/		return 0x82269A74;
	}
	return 0x82269A74;
} // Block from 82269A38h-82269A74h (15 instructions)

//////////////////////////////////////////////////////
// Block at 82269A74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269A74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269A74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269A74);
		  /* 82269A74h */ case    0:  		/* rlwinm. R11, R6, 0, 24, 31 */
		/* 82269A74h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R6);
		/* 82269A74h case    0:*/		return 0x82269A78;
		  /* 82269A78h */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 82269A78h case    1:*/		if ( regs.CR[0].eq ) { return 0x82269A8C;  }
		/* 82269A78h case    1:*/		return 0x82269A7C;
		  /* 82269A7Ch */ case    2:  		/* lis R11, -32255 */
		/* 82269A7Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82269A7Ch case    2:*/		return 0x82269A80;
		  /* 82269A80h */ case    3:  		/* mr R3, R31 */
		/* 82269A80h case    3:*/		regs.R3 = regs.R31;
		/* 82269A80h case    3:*/		return 0x82269A84;
		  /* 82269A84h */ case    4:  		/* addi R4, R11, -16572 */
		/* 82269A84h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFBF44);
		/* 82269A84h case    4:*/		return 0x82269A88;
		  /* 82269A88h */ case    5:  		/* bl -168 */
		/* 82269A88h case    5:*/		regs.LR = 0x82269A8C; return 0x822699E0;
		/* 82269A88h case    5:*/		return 0x82269A8C;
	}
	return 0x82269A8C;
} // Block from 82269A74h-82269A8Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 82269A8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269A8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269A8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269A8C);
		  /* 82269A8Ch */ case    0:  		/* cmpwi CR6, R30, 0 */
		/* 82269A8Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 82269A8Ch case    0:*/		return 0x82269A90;
		  /* 82269A90h */ case    1:  		/* mr R5, R28 */
		/* 82269A90h case    1:*/		regs.R5 = regs.R28;
		/* 82269A90h case    1:*/		return 0x82269A94;
		  /* 82269A94h */ case    2:  		/* bc 4, CR6_EQ, 8 */
		/* 82269A94h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82269A9C;  }
		/* 82269A94h case    2:*/		return 0x82269A98;
		  /* 82269A98h */ case    3:  		/* mr R5, R29 */
		/* 82269A98h case    3:*/		regs.R5 = regs.R29;
		/* 82269A98h case    3:*/		return 0x82269A9C;
	}
	return 0x82269A9C;
} // Block from 82269A8Ch-82269A9Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82269A9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269A9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269A9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269A9C);
		  /* 82269A9Ch */ case    0:  		/* lis R11, -32251 */
		/* 82269A9Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82269A9Ch case    0:*/		return 0x82269AA0;
		  /* 82269AA0h */ case    1:  		/* mr R3, R31 */
		/* 82269AA0h case    1:*/		regs.R3 = regs.R31;
		/* 82269AA0h case    1:*/		return 0x82269AA4;
		  /* 82269AA4h */ case    2:  		/* addi R4, R11, -16364 */
		/* 82269AA4h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFC014);
		/* 82269AA4h case    2:*/		return 0x82269AA8;
		  /* 82269AA8h */ case    3:  		/* bl -200 */
		/* 82269AA8h case    3:*/		regs.LR = 0x82269AAC; return 0x822699E0;
		/* 82269AA8h case    3:*/		return 0x82269AAC;
	}
	return 0x82269AAC;
} // Block from 82269A9Ch-82269AACh (4 instructions)

//////////////////////////////////////////////////////
// Block at 82269AACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269AAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269AAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269AAC);
		  /* 82269AACh */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 82269AACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 82269AACh case    0:*/		return 0x82269AB0;
		  /* 82269AB0h */ case    1:  		/* rlwinm. R11, R11, 26, 31, 31 */
		/* 82269AB0h case    1:*/		cpu::op::rlwinm<1,26,31,31>(regs,&regs.R11,regs.R11);
		/* 82269AB0h case    1:*/		return 0x82269AB4;
		  /* 82269AB4h */ case    2:  		/* bc 4, CR0_EQ, 12 */
		/* 82269AB4h case    2:*/		if ( !regs.CR[0].eq ) { return 0x82269AC0;  }
		/* 82269AB4h case    2:*/		return 0x82269AB8;
		  /* 82269AB8h */ case    3:  		/* cmpwi CR6, R27, 0 */
		/* 82269AB8h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 82269AB8h case    3:*/		return 0x82269ABC;
		  /* 82269ABCh */ case    4:  		/* bc 4, CR6_EQ, 36 */
		/* 82269ABCh case    4:*/		if ( !regs.CR[6].eq ) { return 0x82269AE0;  }
		/* 82269ABCh case    4:*/		return 0x82269AC0;
	}
	return 0x82269AC0;
} // Block from 82269AACh-82269AC0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82269AC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269AC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269AC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269AC0);
		  /* 82269AC0h */ case    0:  		/* cmpwi CR6, R27, 0 */
		/* 82269AC0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 82269AC0h case    0:*/		return 0x82269AC4;
		  /* 82269AC4h */ case    1:  		/* mr R5, R28 */
		/* 82269AC4h case    1:*/		regs.R5 = regs.R28;
		/* 82269AC4h case    1:*/		return 0x82269AC8;
		  /* 82269AC8h */ case    2:  		/* bc 4, CR6_EQ, 8 */
		/* 82269AC8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x82269AD0;  }
		/* 82269AC8h case    2:*/		return 0x82269ACC;
		  /* 82269ACCh */ case    3:  		/* mr R5, R29 */
		/* 82269ACCh case    3:*/		regs.R5 = regs.R29;
		/* 82269ACCh case    3:*/		return 0x82269AD0;
	}
	return 0x82269AD0;
} // Block from 82269AC0h-82269AD0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82269AD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269AD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269AD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269AD0);
		  /* 82269AD0h */ case    0:  		/* lis R11, -32251 */
		/* 82269AD0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82269AD0h case    0:*/		return 0x82269AD4;
		  /* 82269AD4h */ case    1:  		/* mr R3, R31 */
		/* 82269AD4h case    1:*/		regs.R3 = regs.R31;
		/* 82269AD4h case    1:*/		return 0x82269AD8;
		  /* 82269AD8h */ case    2:  		/* addi R4, R11, -16392 */
		/* 82269AD8h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFBFF8);
		/* 82269AD8h case    2:*/		return 0x82269ADC;
		  /* 82269ADCh */ case    3:  		/* bl -252 */
		/* 82269ADCh case    3:*/		regs.LR = 0x82269AE0; return 0x822699E0;
		/* 82269ADCh case    3:*/		return 0x82269AE0;
	}
	return 0x82269AE0;
} // Block from 82269AD0h-82269AE0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82269AE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269AE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269AE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269AE0);
		  /* 82269AE0h */ case    0:  		/* addi R1, R1, 160 */
		/* 82269AE0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 82269AE0h case    0:*/		return 0x82269AE4;
		  /* 82269AE4h */ case    1:  		/* b -1935424 */
		/* 82269AE4h case    1:*/		return 0x820912A4;
		/* 82269AE4h case    1:*/		return 0x82269AE8;
	}
	return 0x82269AE8;
} // Block from 82269AE0h-82269AE8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82269AE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269AE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269AE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269AE8);
		  /* 82269AE8h */ case    0:  		/* mfspr R12, LR */
		/* 82269AE8h case    0:*/		regs.R12 = regs.LR;
		/* 82269AE8h case    0:*/		return 0x82269AEC;
		  /* 82269AECh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82269AECh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82269AECh case    1:*/		return 0x82269AF0;
		  /* 82269AF0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82269AF0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82269AF0h case    2:*/		return 0x82269AF4;
		  /* 82269AF4h */ case    3:  		/* stwu R1, <#[R1 - 128]> */
		/* 82269AF4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82269AF4h case    3:*/		return 0x82269AF8;
		  /* 82269AF8h */ case    4:  		/* lwz R11, <#[R3 + 8]> */
		/* 82269AF8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 82269AF8h case    4:*/		return 0x82269AFC;
		  /* 82269AFCh */ case    5:  		/* mr R31, R3 */
		/* 82269AFCh case    5:*/		regs.R31 = regs.R3;
		/* 82269AFCh case    5:*/		return 0x82269B00;
		  /* 82269B00h */ case    6:  		/* mr R5, R4 */
		/* 82269B00h case    6:*/		regs.R5 = regs.R4;
		/* 82269B00h case    6:*/		return 0x82269B04;
		  /* 82269B04h */ case    7:  		/* rlwinm. R11, R11, 0, 27, 27 */
		/* 82269B04h case    7:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R11);
		/* 82269B04h case    7:*/		return 0x82269B08;
		  /* 82269B08h */ case    8:  		/* bc 12, CR0_EQ, 32 */
		/* 82269B08h case    8:*/		if ( regs.CR[0].eq ) { return 0x82269B28;  }
		/* 82269B08h case    8:*/		return 0x82269B0C;
		  /* 82269B0Ch */ case    9:  		/* li R11, 0 */
		/* 82269B0Ch case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 82269B0Ch case    9:*/		return 0x82269B10;
		  /* 82269B10h */ case   10:  		/* lis R10, -32255 */
		/* 82269B10h case   10:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 82269B10h case   10:*/		return 0x82269B14;
		  /* 82269B14h */ case   11:  		/* stb R11, <#[R3 + 8233]> */
		/* 82269B14h case   11:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R3 + 0x00002029) );
		/* 82269B14h case   11:*/		return 0x82269B18;
		  /* 82269B18h */ case   12:  		/* addi R4, R10, -10432 */
		/* 82269B18h case   12:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0xFFFFD740);
		/* 82269B18h case   12:*/		return 0x82269B1C;
		  /* 82269B1Ch */ case   13:  		/* bl -316 */
		/* 82269B1Ch case   13:*/		regs.LR = 0x82269B20; return 0x822699E0;
		/* 82269B1Ch case   13:*/		return 0x82269B20;
		  /* 82269B20h */ case   14:  		/* li R11, 1 */
		/* 82269B20h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82269B20h case   14:*/		return 0x82269B24;
		  /* 82269B24h */ case   15:  		/* stb R11, <#[R31 + 8233]> */
		/* 82269B24h case   15:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00002029) );
		/* 82269B24h case   15:*/		return 0x82269B28;
	}
	return 0x82269B28;
} // Block from 82269AE8h-82269B28h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82269B28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269B28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269B28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269B28);
		  /* 82269B28h */ case    0:  		/* addi R1, R1, 128 */
		/* 82269B28h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82269B28h case    0:*/		return 0x82269B2C;
		  /* 82269B2Ch */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82269B2Ch case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82269B2Ch case    1:*/		return 0x82269B30;
		  /* 82269B30h */ case    2:  		/* mtspr LR, R12 */
		/* 82269B30h case    2:*/		regs.LR = regs.R12;
		/* 82269B30h case    2:*/		return 0x82269B34;
		  /* 82269B34h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 82269B34h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82269B34h case    3:*/		return 0x82269B38;
		  /* 82269B38h */ case    4:  		/* bclr 20, CR0_LT */
		/* 82269B38h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82269B38h case    4:*/		return 0x82269B3C;
	}
	return 0x82269B3C;
} // Block from 82269B28h-82269B3Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82269B3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269B3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269B3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269B3C);
		  /* 82269B3Ch */ case    0:  		/* nop */
		/* 82269B3Ch case    0:*/		cpu::op::nop();
		/* 82269B3Ch case    0:*/		return 0x82269B40;
	}
	return 0x82269B40;
} // Block from 82269B3Ch-82269B40h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82269B40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269B40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269B40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269B40);
		  /* 82269B40h */ case    0:  		/* mfspr R12, LR */
		/* 82269B40h case    0:*/		regs.R12 = regs.LR;
		/* 82269B40h case    0:*/		return 0x82269B44;
		  /* 82269B44h */ case    1:  		/* bl -1935592 */
		/* 82269B44h case    1:*/		regs.LR = 0x82269B48; return 0x8209125C;
		/* 82269B44h case    1:*/		return 0x82269B48;
		  /* 82269B48h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 82269B48h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 82269B48h case    2:*/		return 0x82269B4C;
		  /* 82269B4Ch */ case    3:  		/* lis R11, -32253 */
		/* 82269B4Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 82269B4Ch case    3:*/		return 0x82269B50;
		  /* 82269B50h */ case    4:  		/* mr R30, R4 */
		/* 82269B50h case    4:*/		regs.R30 = regs.R4;
		/* 82269B50h case    4:*/		return 0x82269B54;
		  /* 82269B54h */ case    5:  		/* addi R4, R11, 28340 */
		/* 82269B54h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x6EB4);
		/* 82269B54h case    5:*/		return 0x82269B58;
		  /* 82269B58h */ case    6:  		/* mr R31, R3 */
		/* 82269B58h case    6:*/		regs.R31 = regs.R3;
		/* 82269B58h case    6:*/		return 0x82269B5C;
		  /* 82269B5Ch */ case    7:  		/* mr R29, R5 */
		/* 82269B5Ch case    7:*/		regs.R29 = regs.R5;
		/* 82269B5Ch case    7:*/		return 0x82269B60;
		  /* 82269B60h */ case    8:  		/* bl -120 */
		/* 82269B60h case    8:*/		regs.LR = 0x82269B64; return 0x82269AE8;
		/* 82269B60h case    8:*/		return 0x82269B64;
		  /* 82269B64h */ case    9:  		/* rlwinm. R11, R29, 0, 24, 31 */
		/* 82269B64h case    9:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R29);
		/* 82269B64h case    9:*/		return 0x82269B68;
		  /* 82269B68h */ case   10:  		/* bc 12, CR0_EQ, 16 */
		/* 82269B68h case   10:*/		if ( regs.CR[0].eq ) { return 0x82269B78;  }
		/* 82269B68h case   10:*/		return 0x82269B6C;
		  /* 82269B6Ch */ case   11:  		/* lis R11, -32251 */
		/* 82269B6Ch case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82269B6Ch case   11:*/		return 0x82269B70;
		  /* 82269B70h */ case   12:  		/* addi R6, R11, -16336 */
		/* 82269B70h case   12:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFC030);
		/* 82269B70h case   12:*/		return 0x82269B74;
		  /* 82269B74h */ case   13:  		/* b 12 */
		/* 82269B74h case   13:*/		return 0x82269B80;
		/* 82269B74h case   13:*/		return 0x82269B78;
	}
	return 0x82269B78;
} // Block from 82269B40h-82269B78h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82269B78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269B78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269B78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269B78);
		  /* 82269B78h */ case    0:  		/* lis R11, -32256 */
		/* 82269B78h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82269B78h case    0:*/		return 0x82269B7C;
		  /* 82269B7Ch */ case    1:  		/* addi R6, R11, 4485 */
		/* 82269B7Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0x1185);
		/* 82269B7Ch case    1:*/		return 0x82269B80;
	}
	return 0x82269B80;
} // Block from 82269B78h-82269B80h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82269B80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269B80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269B80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269B80);
		  /* 82269B80h */ case    0:  		/* lis R11, -32255 */
		/* 82269B80h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82269B80h case    0:*/		return 0x82269B84;
		  /* 82269B84h */ case    1:  		/* mr R5, R30 */
		/* 82269B84h case    1:*/		regs.R5 = regs.R30;
		/* 82269B84h case    1:*/		return 0x82269B88;
		  /* 82269B88h */ case    2:  		/* addi R4, R11, -10152 */
		/* 82269B88h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFD858);
		/* 82269B88h case    2:*/		return 0x82269B8C;
		  /* 82269B8Ch */ case    3:  		/* mr R3, R31 */
		/* 82269B8Ch case    3:*/		regs.R3 = regs.R31;
		/* 82269B8Ch case    3:*/		return 0x82269B90;
		  /* 82269B90h */ case    4:  		/* bl -432 */
		/* 82269B90h case    4:*/		regs.LR = 0x82269B94; return 0x822699E0;
		/* 82269B90h case    4:*/		return 0x82269B94;
		  /* 82269B94h */ case    5:  		/* lis R11, -32253 */
		/* 82269B94h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 82269B94h case    5:*/		return 0x82269B98;
		  /* 82269B98h */ case    6:  		/* mr R3, R31 */
		/* 82269B98h case    6:*/		regs.R3 = regs.R31;
		/* 82269B98h case    6:*/		return 0x82269B9C;
		  /* 82269B9Ch */ case    7:  		/* addi R4, R11, 28348 */
		/* 82269B9Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x6EBC);
		/* 82269B9Ch case    7:*/		return 0x82269BA0;
		  /* 82269BA0h */ case    8:  		/* bl -184 */
		/* 82269BA0h case    8:*/		regs.LR = 0x82269BA4; return 0x82269AE8;
		/* 82269BA0h case    8:*/		return 0x82269BA4;
		  /* 82269BA4h */ case    9:  		/* addi R1, R1, 144 */
		/* 82269BA4h case    9:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 82269BA4h case    9:*/		return 0x82269BA8;
		  /* 82269BA8h */ case   10:  		/* b -1935612 */
		/* 82269BA8h case   10:*/		return 0x820912AC;
		/* 82269BA8h case   10:*/		return 0x82269BAC;
		  /* 82269BACh */ case   11:  		/* nop */
		/* 82269BACh case   11:*/		cpu::op::nop();
		/* 82269BACh case   11:*/		return 0x82269BB0;
	}
	return 0x82269BB0;
} // Block from 82269B80h-82269BB0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 82269BB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269BB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269BB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269BB0);
		  /* 82269BB0h */ case    0:  		/* mfspr R12, LR */
		/* 82269BB0h case    0:*/		regs.R12 = regs.LR;
		/* 82269BB0h case    0:*/		return 0x82269BB4;
		  /* 82269BB4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82269BB4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82269BB4h case    1:*/		return 0x82269BB8;
		  /* 82269BB8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 82269BB8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82269BB8h case    2:*/		return 0x82269BBC;
		  /* 82269BBCh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 82269BBCh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82269BBCh case    3:*/		return 0x82269BC0;
		  /* 82269BC0h */ case    4:  		/* stwu R1, <#[R1 - 128]> */
		/* 82269BC0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82269BC0h case    4:*/		return 0x82269BC4;
		  /* 82269BC4h */ case    5:  		/* lis R11, -32251 */
		/* 82269BC4h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82269BC4h case    5:*/		return 0x82269BC8;
		  /* 82269BC8h */ case    6:  		/* mr R30, R4 */
		/* 82269BC8h case    6:*/		regs.R30 = regs.R4;
		/* 82269BC8h case    6:*/		return 0x82269BCC;
		  /* 82269BCCh */ case    7:  		/* addi R4, R11, -16328 */
		/* 82269BCCh case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFC038);
		/* 82269BCCh case    7:*/		return 0x82269BD0;
		  /* 82269BD0h */ case    8:  		/* mr R31, R3 */
		/* 82269BD0h case    8:*/		regs.R31 = regs.R3;
		/* 82269BD0h case    8:*/		return 0x82269BD4;
		  /* 82269BD4h */ case    9:  		/* bl -236 */
		/* 82269BD4h case    9:*/		regs.LR = 0x82269BD8; return 0x82269AE8;
		/* 82269BD4h case    9:*/		return 0x82269BD8;
		  /* 82269BD8h */ case   10:  		/* lis R11, -32255 */
		/* 82269BD8h case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82269BD8h case   10:*/		return 0x82269BDC;
		  /* 82269BDCh */ case   11:  		/* mr R3, R31 */
		/* 82269BDCh case   11:*/		regs.R3 = regs.R31;
		/* 82269BDCh case   11:*/		return 0x82269BE0;
		  /* 82269BE0h */ case   12:  		/* addi R4, R11, -10432 */
		/* 82269BE0h case   12:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFD740);
		/* 82269BE0h case   12:*/		return 0x82269BE4;
		  /* 82269BE4h */ case   13:  		/* mr R5, R30 */
		/* 82269BE4h case   13:*/		regs.R5 = regs.R30;
		/* 82269BE4h case   13:*/		return 0x82269BE8;
		  /* 82269BE8h */ case   14:  		/* bl -520 */
		/* 82269BE8h case   14:*/		regs.LR = 0x82269BEC; return 0x822699E0;
		/* 82269BE8h case   14:*/		return 0x82269BEC;
		  /* 82269BECh */ case   15:  		/* lis R11, -32253 */
		/* 82269BECh case   15:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 82269BECh case   15:*/		return 0x82269BF0;
	}
	return 0x82269BF0;
} // Block from 82269BB0h-82269BF0h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82269BF0h
// Function 'setjmp'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269BF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269BF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269BF0);
		  /* 82269BF0h */ case    0:  		/* mr R3, R31 */
		/* 82269BF0h case    0:*/		regs.R3 = regs.R31;
		/* 82269BF0h case    0:*/		return 0x82269BF4;
		  /* 82269BF4h */ case    1:  		/* addi R4, R11, 28348 */
		/* 82269BF4h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x6EBC);
		/* 82269BF4h case    1:*/		return 0x82269BF8;
		  /* 82269BF8h */ case    2:  		/* bl -272 */
		/* 82269BF8h case    2:*/		regs.LR = 0x82269BFC; return 0x82269AE8;
		/* 82269BF8h case    2:*/		return 0x82269BFC;
		  /* 82269BFCh */ case    3:  		/* addi R1, R1, 128 */
		/* 82269BFCh case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82269BFCh case    3:*/		return 0x82269C00;
		  /* 82269C00h */ case    4:  		/* lwz R12, <#[R1 - 8]> */
		/* 82269C00h case    4:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82269C00h case    4:*/		return 0x82269C04;
		  /* 82269C04h */ case    5:  		/* mtspr LR, R12 */
		/* 82269C04h case    5:*/		regs.LR = regs.R12;
		/* 82269C04h case    5:*/		return 0x82269C08;
		  /* 82269C08h */ case    6:  		/* ld R30, <#[R1 - 24]> */
		/* 82269C08h case    6:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 82269C08h case    6:*/		return 0x82269C0C;
		  /* 82269C0Ch */ case    7:  		/* ld R31, <#[R1 - 16]> */
		/* 82269C0Ch case    7:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82269C0Ch case    7:*/		return 0x82269C10;
		  /* 82269C10h */ case    8:  		/* bclr 20, CR0_LT */
		/* 82269C10h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82269C10h case    8:*/		return 0x82269C14;
	}
	return 0x82269C14;
} // Block from 82269BF0h-82269C14h (9 instructions)

//////////////////////////////////////////////////////
// Block at 82269C14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269C14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269C14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269C14);
		  /* 82269C14h */ case    0:  		/* nop */
		/* 82269C14h case    0:*/		cpu::op::nop();
		/* 82269C14h case    0:*/		return 0x82269C18;
	}
	return 0x82269C18;
} // Block from 82269C14h-82269C18h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82269C18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269C18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269C18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269C18);
		  /* 82269C18h */ case    0:  		/* mfspr R12, LR */
		/* 82269C18h case    0:*/		regs.R12 = regs.LR;
		/* 82269C18h case    0:*/		return 0x82269C1C;
		  /* 82269C1Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82269C1Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82269C1Ch case    1:*/		return 0x82269C20;
		  /* 82269C20h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 82269C20h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 82269C20h case    2:*/		return 0x82269C24;
		  /* 82269C24h */ case    3:  		/* lwz R10, <#[R3 + 8]> */
		/* 82269C24h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 82269C24h case    3:*/		return 0x82269C28;
		  /* 82269C28h */ case    4:  		/* mr R11, R4 */
		/* 82269C28h case    4:*/		regs.R11 = regs.R4;
		/* 82269C28h case    4:*/		return 0x82269C2C;
		  /* 82269C2Ch */ case    5:  		/* rlwinm. R10, R10, 0, 26, 26 */
		/* 82269C2Ch case    5:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R10,regs.R10);
		/* 82269C2Ch case    5:*/		return 0x82269C30;
		  /* 82269C30h */ case    6:  		/* bc 12, CR0_EQ, 40 */
		/* 82269C30h case    6:*/		if ( regs.CR[0].eq ) { return 0x82269C58;  }
		/* 82269C30h case    6:*/		return 0x82269C34;
		  /* 82269C34h */ case    7:  		/* srawi R10, R4, 1 */
		/* 82269C34h case    7:*/		cpu::op::srawi<0,1>(regs,&regs.R10,regs.R4);
		/* 82269C34h case    7:*/		return 0x82269C38;
		  /* 82269C38h */ case    8:  		/* lis R9, -32251 */
		/* 82269C38h case    8:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8205);
		/* 82269C38h case    8:*/		return 0x82269C3C;
		  /* 82269C3Ch */ case    9:  		/* addze R10, R10 */
		/* 82269C3Ch case    9:*/		cpu::op::addze<0>(regs,&regs.R10,regs.R10);
		/* 82269C3Ch case    9:*/		return 0x82269C40;
		  /* 82269C40h */ case   10:  		/* srawi R8, R4, 1 */
		/* 82269C40h case   10:*/		cpu::op::srawi<0,1>(regs,&regs.R8,regs.R4);
		/* 82269C40h case   10:*/		return 0x82269C44;
		  /* 82269C44h */ case   11:  		/* rlwinm R10, R10, 1, 0, 30 */
		/* 82269C44h case   11:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R10);
		/* 82269C44h case   11:*/		return 0x82269C48;
		  /* 82269C48h */ case   12:  		/* addi R4, R9, -16320 */
		/* 82269C48h case   12:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0xFFFFC040);
		/* 82269C48h case   12:*/		return 0x82269C4C;
		  /* 82269C4Ch */ case   13:  		/* addze R5, R8 */
		/* 82269C4Ch case   13:*/		cpu::op::addze<0>(regs,&regs.R5,regs.R8);
		/* 82269C4Ch case   13:*/		return 0x82269C50;
		  /* 82269C50h */ case   14:  		/* subf R6, R10, R11 */
		/* 82269C50h case   14:*/		cpu::op::subf<0>(regs,&regs.R6,regs.R10,regs.R11);
		/* 82269C50h case   14:*/		return 0x82269C54;
		  /* 82269C54h */ case   15:  		/* bl -628 */
		/* 82269C54h case   15:*/		regs.LR = 0x82269C58; return 0x822699E0;
		/* 82269C54h case   15:*/		return 0x82269C58;
	}
	return 0x82269C58;
} // Block from 82269C18h-82269C58h (16 instructions)

//////////////////////////////////////////////////////
// Block at 82269C58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269C58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269C58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269C58);
		  /* 82269C58h */ case    0:  		/* addi R1, R1, 128 */
		/* 82269C58h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 82269C58h case    0:*/		return 0x82269C5C;
		  /* 82269C5Ch */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 82269C5Ch case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82269C5Ch case    1:*/		return 0x82269C60;
		  /* 82269C60h */ case    2:  		/* mtspr LR, R12 */
		/* 82269C60h case    2:*/		regs.LR = regs.R12;
		/* 82269C60h case    2:*/		return 0x82269C64;
		  /* 82269C64h */ case    3:  		/* bclr 20, CR0_LT */
		/* 82269C64h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82269C64h case    3:*/		return 0x82269C68;
	}
	return 0x82269C68;
} // Block from 82269C58h-82269C68h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82269C68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269C68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269C68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269C68);
		  /* 82269C68h */ case    0:  		/* mfspr R12, LR */
		/* 82269C68h case    0:*/		regs.R12 = regs.LR;
		/* 82269C68h case    0:*/		return 0x82269C6C;
		  /* 82269C6Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 82269C6Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82269C6Ch case    1:*/		return 0x82269C70;
		  /* 82269C70h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 82269C70h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82269C70h case    2:*/		return 0x82269C74;
		  /* 82269C74h */ case    3:  		/* stwu R1, <#[R1 - 112]> */
		/* 82269C74h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 82269C74h case    3:*/		return 0x82269C78;
		  /* 82269C78h */ case    4:  		/* lis R11, -32253 */
		/* 82269C78h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 82269C78h case    4:*/		return 0x82269C7C;
		  /* 82269C7Ch */ case    5:  		/* mr R31, R3 */
		/* 82269C7Ch case    5:*/		regs.R31 = regs.R3;
		/* 82269C7Ch case    5:*/		return 0x82269C80;
		  /* 82269C80h */ case    6:  		/* addi R4, R11, 28356 */
		/* 82269C80h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x6EC4);
		/* 82269C80h case    6:*/		return 0x82269C84;
		  /* 82269C84h */ case    7:  		/* bl -412 */
		/* 82269C84h case    7:*/		regs.LR = 0x82269C88; return 0x82269AE8;
		/* 82269C84h case    7:*/		return 0x82269C88;
		  /* 82269C88h */ case    8:  		/* lis R11, -32251 */
		/* 82269C88h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82269C88h case    8:*/		return 0x82269C8C;
		  /* 82269C8Ch */ case    9:  		/* mr R3, R31 */
		/* 82269C8Ch case    9:*/		regs.R3 = regs.R31;
		/* 82269C8Ch case    9:*/		return 0x82269C90;
		  /* 82269C90h */ case   10:  		/* addi R4, R11, -16272 */
		/* 82269C90h case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFC070);
		/* 82269C90h case   10:*/		return 0x82269C94;
		  /* 82269C94h */ case   11:  		/* bl -692 */
		/* 82269C94h case   11:*/		regs.LR = 0x82269C98; return 0x822699E0;
		/* 82269C94h case   11:*/		return 0x82269C98;
		  /* 82269C98h */ case   12:  		/* addi R1, R1, 112 */
		/* 82269C98h case   12:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 82269C98h case   12:*/		return 0x82269C9C;
		  /* 82269C9Ch */ case   13:  		/* lwz R12, <#[R1 - 8]> */
		/* 82269C9Ch case   13:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 82269C9Ch case   13:*/		return 0x82269CA0;
		  /* 82269CA0h */ case   14:  		/* mtspr LR, R12 */
		/* 82269CA0h case   14:*/		regs.LR = regs.R12;
		/* 82269CA0h case   14:*/		return 0x82269CA4;
		  /* 82269CA4h */ case   15:  		/* ld R31, <#[R1 - 16]> */
		/* 82269CA4h case   15:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 82269CA4h case   15:*/		return 0x82269CA8;
		  /* 82269CA8h */ case   16:  		/* bclr 20, CR0_LT */
		/* 82269CA8h case   16:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 82269CA8h case   16:*/		return 0x82269CAC;
	}
	return 0x82269CAC;
} // Block from 82269C68h-82269CACh (17 instructions)

//////////////////////////////////////////////////////
// Block at 82269CACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269CAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269CAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269CAC);
		  /* 82269CACh */ case    0:  		/* nop */
		/* 82269CACh case    0:*/		cpu::op::nop();
		/* 82269CACh case    0:*/		return 0x82269CB0;
	}
	return 0x82269CB0;
} // Block from 82269CACh-82269CB0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82269CB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269CB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269CB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269CB0);
		  /* 82269CB0h */ case    0:  		/* mfspr R12, LR */
		/* 82269CB0h case    0:*/		regs.R12 = regs.LR;
		/* 82269CB0h case    0:*/		return 0x82269CB4;
		  /* 82269CB4h */ case    1:  		/* bl -1935992 */
		/* 82269CB4h case    1:*/		regs.LR = 0x82269CB8; return 0x8209123C;
		/* 82269CB4h case    1:*/		return 0x82269CB8;
		  /* 82269CB8h */ case    2:  		/* stwu R1, <#[R1 - 256]> */
		/* 82269CB8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF00) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF00);
		/* 82269CB8h case    2:*/		return 0x82269CBC;
		  /* 82269CBCh */ case    3:  		/* lis R10, -32255 */
		/* 82269CBCh case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 82269CBCh case    3:*/		return 0x82269CC0;
		  /* 82269CC0h */ case    4:  		/* mr R11, R4 */
		/* 82269CC0h case    4:*/		regs.R11 = regs.R4;
		/* 82269CC0h case    4:*/		return 0x82269CC4;
		  /* 82269CC4h */ case    5:  		/* addi R4, R10, -15864 */
		/* 82269CC4h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0xFFFFC208);
		/* 82269CC4h case    5:*/		return 0x82269CC8;
		  /* 82269CC8h */ case    6:  		/* mr R25, R3 */
		/* 82269CC8h case    6:*/		regs.R25 = regs.R3;
		/* 82269CC8h case    6:*/		return 0x82269CCC;
		  /* 82269CCCh */ case    7:  		/* mr R24, R5 */
		/* 82269CCCh case    7:*/		regs.R24 = regs.R5;
		/* 82269CCCh case    7:*/		return 0x82269CD0;
		  /* 82269CD0h */ case    8:  		/* mr R29, R6 */
		/* 82269CD0h case    8:*/		regs.R29 = regs.R6;
		/* 82269CD0h case    8:*/		return 0x82269CD4;
		  /* 82269CD4h */ case    9:  		/* mr R26, R7 */
		/* 82269CD4h case    9:*/		regs.R26 = regs.R7;
		/* 82269CD4h case    9:*/		return 0x82269CD8;
		  /* 82269CD8h */ case   10:  		/* mr R22, R8 */
		/* 82269CD8h case   10:*/		regs.R22 = regs.R8;
		/* 82269CD8h case   10:*/		return 0x82269CDC;
		  /* 82269CDCh */ case   11:  		/* mr R23, R9 */
		/* 82269CDCh case   11:*/		regs.R23 = regs.R9;
		/* 82269CDCh case   11:*/		return 0x82269CE0;
		  /* 82269CE0h */ case   12:  		/* rlwinm R31, R11, 0, 26, 31 */
		/* 82269CE0h case   12:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R31,regs.R11);
		/* 82269CE0h case   12:*/		return 0x82269CE4;
		  /* 82269CE4h */ case   13:  		/* bl -772 */
		/* 82269CE4h case   13:*/		regs.LR = 0x82269CE8; return 0x822699E0;
		/* 82269CE4h case   13:*/		return 0x82269CE8;
		  /* 82269CE8h */ case   14:  		/* li R21, 0 */
		/* 82269CE8h case   14:*/		cpu::op::li<0>(regs,&regs.R21,0x0);
		/* 82269CE8h case   14:*/		return 0x82269CEC;
		  /* 82269CECh */ case   15:  		/* cmpwi CR6, R29, 0 */
		/* 82269CECh case   15:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 82269CECh case   15:*/		return 0x82269CF0;
		  /* 82269CF0h */ case   16:  		/* bc 4, CR6_EQ, 16 */
		/* 82269CF0h case   16:*/		if ( !regs.CR[6].eq ) { return 0x82269D00;  }
		/* 82269CF0h case   16:*/		return 0x82269CF4;
		  /* 82269CF4h */ case   17:  		/* cmpwi CR6, R26, 0 */
		/* 82269CF4h case   17:*/		cpu::op::cmpwi<6>(regs,regs.R26,0x00000000);
		/* 82269CF4h case   17:*/		return 0x82269CF8;
		  /* 82269CF8h */ case   18:  		/* li R11, 1 */
		/* 82269CF8h case   18:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82269CF8h case   18:*/		return 0x82269CFC;
		  /* 82269CFCh */ case   19:  		/* bc 4, CR6_EQ, 8 */
		/* 82269CFCh case   19:*/		if ( !regs.CR[6].eq ) { return 0x82269D04;  }
		/* 82269CFCh case   19:*/		return 0x82269D00;
	}
	return 0x82269D00;
} // Block from 82269CB0h-82269D00h (20 instructions)

//////////////////////////////////////////////////////
// Block at 82269D00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269D00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269D00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269D00);
		  /* 82269D00h */ case    0:  		/* mr R11, R21 */
		/* 82269D00h case    0:*/		regs.R11 = regs.R21;
		/* 82269D00h case    0:*/		return 0x82269D04;
	}
	return 0x82269D04;
} // Block from 82269D00h-82269D04h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82269D04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269D04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269D04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269D04);
		  /* 82269D04h */ case    0:  		/* rlwinm R28, R11, 0, 24, 31 */
		/* 82269D04h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R28,regs.R11);
		/* 82269D04h case    0:*/		return 0x82269D08;
		  /* 82269D08h */ case    1:  		/* cmpwi CR6, R24, 0 */
		/* 82269D08h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 82269D08h case    1:*/		return 0x82269D0C;
		  /* 82269D0Ch */ case    2:  		/* bc 4, CR6_EQ, 28 */
		/* 82269D0Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x82269D28;  }
		/* 82269D0Ch case    2:*/		return 0x82269D10;
		  /* 82269D10h */ case    3:  		/* cmpwi CR6, R29, 0 */
		/* 82269D10h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 82269D10h case    3:*/		return 0x82269D14;
		  /* 82269D14h */ case    4:  		/* bc 12, CR6_EQ, 12 */
		/* 82269D14h case    4:*/		if ( regs.CR[6].eq ) { return 0x82269D20;  }
		/* 82269D14h case    4:*/		return 0x82269D18;
		  /* 82269D18h */ case    5:  		/* cmpwi CR6, R22, 0 */
		/* 82269D18h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R22,0x00000000);
		/* 82269D18h case    5:*/		return 0x82269D1C;
		  /* 82269D1Ch */ case    6:  		/* bc 4, CR6_EQ, 12 */
		/* 82269D1Ch case    6:*/		if ( !regs.CR[6].eq ) { return 0x82269D28;  }
		/* 82269D1Ch case    6:*/		return 0x82269D20;
	}
	return 0x82269D20;
} // Block from 82269D04h-82269D20h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82269D20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269D20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269D20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269D20);
		  /* 82269D20h */ case    0:  		/* li R11, 1 */
		/* 82269D20h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82269D20h case    0:*/		return 0x82269D24;
		  /* 82269D24h */ case    1:  		/* b 8 */
		/* 82269D24h case    1:*/		return 0x82269D2C;
		/* 82269D24h case    1:*/		return 0x82269D28;
	}
	return 0x82269D28;
} // Block from 82269D20h-82269D28h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82269D28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269D28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269D28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269D28);
		  /* 82269D28h */ case    0:  		/* mr R11, R21 */
		/* 82269D28h case    0:*/		regs.R11 = regs.R21;
		/* 82269D28h case    0:*/		return 0x82269D2C;
	}
	return 0x82269D2C;
} // Block from 82269D28h-82269D2Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 82269D2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269D2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269D2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269D2C);
		  /* 82269D2Ch */ case    0:  		/* rlwinm R27, R11, 0, 24, 31 */
		/* 82269D2Ch case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R27,regs.R11);
		/* 82269D2Ch case    0:*/		return 0x82269D30;
		  /* 82269D30h */ case    1:  		/* li R30, -1 */
		/* 82269D30h case    1:*/		cpu::op::li<0>(regs,&regs.R30,0xFFFFFFFF);
		/* 82269D30h case    1:*/		return 0x82269D34;
		  /* 82269D34h */ case    2:  		/* cmpwi CR6, R29, 0 */
		/* 82269D34h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 82269D34h case    2:*/		return 0x82269D38;
		  /* 82269D38h */ case    3:  		/* bc 12, CR6_EQ, 172 */
		/* 82269D38h case    3:*/		if ( regs.CR[6].eq ) { return 0x82269DE4;  }
		/* 82269D38h case    3:*/		return 0x82269D3C;
		  /* 82269D3Ch */ case    4:  		/* cmpwi CR6, R31, 32 */
		/* 82269D3Ch case    4:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000020);
		/* 82269D3Ch case    4:*/		return 0x82269D40;
		  /* 82269D40h */ case    5:  		/* bc 12, CR6_EQ, 152 */
		/* 82269D40h case    5:*/		if ( regs.CR[6].eq ) { return 0x82269DD8;  }
		/* 82269D40h case    5:*/		return 0x82269D44;
		  /* 82269D44h */ case    6:  		/* bc 4, CR6_GT, 68 */
		/* 82269D44h case    6:*/		if ( !regs.CR[6].gt ) { return 0x82269D88;  }
		/* 82269D44h case    6:*/		return 0x82269D48;
		  /* 82269D48h */ case    7:  		/* cmpwi CR6, R31, 37 */
		/* 82269D48h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x00000025);
		/* 82269D48h case    7:*/		return 0x82269D4C;
		  /* 82269D4Ch */ case    8:  		/* bc 4, CR6_GT, 44 */
		/* 82269D4Ch case    8:*/		if ( !regs.CR[6].gt ) { return 0x82269D78;  }
		/* 82269D4Ch case    8:*/		return 0x82269D50;
		  /* 82269D50h */ case    9:  		/* cmpwi CR6, R31, 62 */
		/* 82269D50h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x0000003E);
		/* 82269D50h case    9:*/		return 0x82269D54;
		  /* 82269D54h */ case   10:  		/* bc 12, CR6_EQ, 24 */
		/* 82269D54h case   10:*/		if ( regs.CR[6].eq ) { return 0x82269D6C;  }
		/* 82269D54h case   10:*/		return 0x82269D58;
		  /* 82269D58h */ case   11:  		/* cmpwi CR6, R31, 63 */
		/* 82269D58h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x0000003F);
		/* 82269D58h case   11:*/		return 0x82269D5C;
		  /* 82269D5Ch */ case   12:  		/* bc 4, CR6_EQ, 44 */
		/* 82269D5Ch case   12:*/		if ( !regs.CR[6].eq ) { return 0x82269D88;  }
		/* 82269D5Ch case   12:*/		return 0x82269D60;
		  /* 82269D60h */ case   13:  		/* lis R11, -32255 */
		/* 82269D60h case   13:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82269D60h case   13:*/		return 0x82269D64;
		  /* 82269D64h */ case   14:  		/* addi R5, R11, -8760 */
		/* 82269D64h case   14:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFDDC8);
		/* 82269D64h case   14:*/		return 0x82269D68;
		  /* 82269D68h */ case   15:  		/* b 136 */
		/* 82269D68h case   15:*/		return 0x82269DF0;
		/* 82269D68h case   15:*/		return 0x82269D6C;
	}
	return 0x82269D6C;
} // Block from 82269D2Ch-82269D6Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 82269D6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269D6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269D6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269D6C);
		  /* 82269D6Ch */ case    0:  		/* lis R11, -32255 */
		/* 82269D6Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82269D6Ch case    0:*/		return 0x82269D70;
		  /* 82269D70h */ case    1:  		/* addi R5, R11, -8752 */
		/* 82269D70h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFDDD0);
		/* 82269D70h case    1:*/		return 0x82269D74;
		  /* 82269D74h */ case    2:  		/* b 124 */
		/* 82269D74h case    2:*/		return 0x82269DF0;
		/* 82269D74h case    2:*/		return 0x82269D78;
	}
	return 0x82269D78;
} // Block from 82269D6Ch-82269D78h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82269D78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269D78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269D78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269D78);
		  /* 82269D78h */ case    0:  		/* lis R11, -32255 */
		/* 82269D78h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82269D78h case    0:*/		return 0x82269D7C;
		  /* 82269D7Ch */ case    1:  		/* addi R30, R31, -33 */
		/* 82269D7Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0xFFFFFFDF);
		/* 82269D7Ch case    1:*/		return 0x82269D80;
		  /* 82269D80h */ case    2:  		/* addi R5, R11, 12840 */
		/* 82269D80h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x3228);
		/* 82269D80h case    2:*/		return 0x82269D84;
		  /* 82269D84h */ case    3:  		/* b 108 */
		/* 82269D84h case    3:*/		return 0x82269DF0;
		/* 82269D84h case    3:*/		return 0x82269D88;
	}
	return 0x82269D88;
} // Block from 82269D78h-82269D88h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82269D88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269D88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269D88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269D88);
		  /* 82269D88h */ case    0:  		/* lwz R11, <#[R25 + 8]> */
		/* 82269D88h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 82269D88h case    0:*/		return 0x82269D8C;
		  /* 82269D8Ch */ case    1:  		/* rlwinm. R11, R11, 29, 31, 31 */
		/* 82269D8Ch case    1:*/		cpu::op::rlwinm<1,29,31,31>(regs,&regs.R11,regs.R11);
		/* 82269D8Ch case    1:*/		return 0x82269D90;
		  /* 82269D90h */ case    2:  		/* bc 12, CR0_EQ, 60 */
		/* 82269D90h case    2:*/		if ( regs.CR[0].eq ) { return 0x82269DCC;  }
		/* 82269D90h case    2:*/		return 0x82269D94;
		  /* 82269D94h */ case    3:  		/* lwz R11, <#[R25]> */
		/* 82269D94h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 82269D94h case    3:*/		return 0x82269D98;
		  /* 82269D98h */ case    4:  		/* rlwinm R10, R11, 4, 29, 31 */
		/* 82269D98h case    4:*/		cpu::op::rlwinm<0,4,29,31>(regs,&regs.R10,regs.R11);
		/* 82269D98h case    4:*/		return 0x82269D9C;
		  /* 82269D9Ch */ case    5:  		/* cmpw CR6, R31, R10 */
		/* 82269D9Ch case    5:*/		cpu::op::cmpw<6>(regs,regs.R31,regs.R10);
		/* 82269D9Ch case    5:*/		return 0x82269DA0;
		  /* 82269DA0h */ case    6:  		/* bc 4, CR6_LT, 16 */
		/* 82269DA0h case    6:*/		if ( !regs.CR[6].lt ) { return 0x82269DB0;  }
		/* 82269DA0h case    6:*/		return 0x82269DA4;
		  /* 82269DA4h */ case    7:  		/* lis R11, -32255 */
		/* 82269DA4h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82269DA4h case    7:*/		return 0x82269DA8;
		  /* 82269DA8h */ case    8:  		/* addi R5, R11, -8784 */
		/* 82269DA8h case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFDDB0);
		/* 82269DA8h case    8:*/		return 0x82269DAC;
		  /* 82269DACh */ case    9:  		/* b 64 */
		/* 82269DACh case    9:*/		return 0x82269DEC;
		/* 82269DACh case    9:*/		return 0x82269DB0;
	}
	return 0x82269DB0;
} // Block from 82269D88h-82269DB0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82269DB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269DB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269DB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269DB0);
		  /* 82269DB0h */ case    0:  		/* cmpwi CR6, R31, 61 */
		/* 82269DB0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R31,0x0000003D);
		/* 82269DB0h case    0:*/		return 0x82269DB4;
		  /* 82269DB4h */ case    1:  		/* bc 4, CR6_EQ, 24 */
		/* 82269DB4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82269DCC;  }
		/* 82269DB4h case    1:*/		return 0x82269DB8;
		  /* 82269DB8h */ case    2:  		/* rlwinm. R11, R11, 0, 4, 4 */
		/* 82269DB8h case    2:*/		cpu::op::rlwinm<1,0,4,4>(regs,&regs.R11,regs.R11);
		/* 82269DB8h case    2:*/		return 0x82269DBC;
		  /* 82269DBCh */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 82269DBCh case    3:*/		if ( regs.CR[0].eq ) { return 0x82269DCC;  }
		/* 82269DBCh case    3:*/		return 0x82269DC0;
		  /* 82269DC0h */ case    4:  		/* lis R11, -32255 */
		/* 82269DC0h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82269DC0h case    4:*/		return 0x82269DC4;
		  /* 82269DC4h */ case    5:  		/* addi R5, R11, -8792 */
		/* 82269DC4h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFDDA8);
		/* 82269DC4h case    5:*/		return 0x82269DC8;
		  /* 82269DC8h */ case    6:  		/* b 40 */
		/* 82269DC8h case    6:*/		return 0x82269DF0;
		/* 82269DC8h case    6:*/		return 0x82269DCC;
	}
	return 0x82269DCC;
} // Block from 82269DB0h-82269DCCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 82269DCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269DCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269DCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269DCC);
		  /* 82269DCCh */ case    0:  		/* lis R11, -32255 */
		/* 82269DCCh case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82269DCCh case    0:*/		return 0x82269DD0;
		  /* 82269DD0h */ case    1:  		/* addi R5, R11, -8832 */
		/* 82269DD0h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFDD80);
		/* 82269DD0h case    1:*/		return 0x82269DD4;
		  /* 82269DD4h */ case    2:  		/* b 24 */
		/* 82269DD4h case    2:*/		return 0x82269DEC;
		/* 82269DD4h case    2:*/		return 0x82269DD8;
	}
	return 0x82269DD8;
} // Block from 82269DCCh-82269DD8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82269DD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269DD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269DD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269DD8);
		  /* 82269DD8h */ case    0:  		/* lis R11, -32255 */
		/* 82269DD8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82269DD8h case    0:*/		return 0x82269DDC;
		  /* 82269DDCh */ case    1:  		/* addi R5, R11, 12844 */
		/* 82269DDCh case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x322C);
		/* 82269DDCh case    1:*/		return 0x82269DE0;
		  /* 82269DE0h */ case    2:  		/* b 16 */
		/* 82269DE0h case    2:*/		return 0x82269DF0;
		/* 82269DE0h case    2:*/		return 0x82269DE4;
	}
	return 0x82269DE4;
} // Block from 82269DD8h-82269DE4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 82269DE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269DE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269DE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269DE4);
		  /* 82269DE4h */ case    0:  		/* lis R11, -32255 */
		/* 82269DE4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82269DE4h case    0:*/		return 0x82269DE8;
		  /* 82269DE8h */ case    1:  		/* addi R5, R11, -8732 */
		/* 82269DE8h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFDDE4);
		/* 82269DE8h case    1:*/		return 0x82269DEC;
	}
	return 0x82269DEC;
} // Block from 82269DE4h-82269DECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 82269DECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269DEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269DEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269DEC);
		  /* 82269DECh */ case    0:  		/* mr R30, R31 */
		/* 82269DECh case    0:*/		regs.R30 = regs.R31;
		/* 82269DECh case    0:*/		return 0x82269DF0;
	}
	return 0x82269DF0;
} // Block from 82269DECh-82269DF0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82269DF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269DF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269DF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269DF0);
		  /* 82269DF0h */ case    0:  		/* lis R11, -32255 */
		/* 82269DF0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82269DF0h case    0:*/		return 0x82269DF4;
		  /* 82269DF4h */ case    1:  		/* mr R3, R25 */
		/* 82269DF4h case    1:*/		regs.R3 = regs.R25;
		/* 82269DF4h case    1:*/		return 0x82269DF8;
		  /* 82269DF8h */ case    2:  		/* addi R4, R11, -10432 */
		/* 82269DF8h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFD740);
		/* 82269DF8h case    2:*/		return 0x82269DFC;
		  /* 82269DFCh */ case    3:  		/* bl -1052 */
		/* 82269DFCh case    3:*/		regs.LR = 0x82269E00; return 0x822699E0;
		/* 82269DFCh case    3:*/		return 0x82269E00;
		  /* 82269E00h */ case    4:  		/* rlwinm. R31, R28, 0, 24, 31 */
		/* 82269E00h case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R31,regs.R28);
		/* 82269E00h case    4:*/		return 0x82269E04;
		  /* 82269E04h */ case    5:  		/* bc 12, CR0_EQ, 20 */
		/* 82269E04h case    5:*/		if ( regs.CR[0].eq ) { return 0x82269E18;  }
		/* 82269E04h case    5:*/		return 0x82269E08;
		  /* 82269E08h */ case    6:  		/* lis R11, -32252 */
		/* 82269E08h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82269E08h case    6:*/		return 0x82269E0C;
		  /* 82269E0Ch */ case    7:  		/* mr R3, R25 */
		/* 82269E0Ch case    7:*/		regs.R3 = regs.R25;
		/* 82269E0Ch case    7:*/		return 0x82269E10;
		  /* 82269E10h */ case    8:  		/* addi R4, R11, -23676 */
		/* 82269E10h case    8:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFA384);
		/* 82269E10h case    8:*/		return 0x82269E14;
		  /* 82269E14h */ case    9:  		/* bl -1076 */
		/* 82269E14h case    9:*/		regs.LR = 0x82269E18; return 0x822699E0;
		/* 82269E14h case    9:*/		return 0x82269E18;
	}
	return 0x82269E18;
} // Block from 82269DF0h-82269E18h (10 instructions)

//////////////////////////////////////////////////////
// Block at 82269E18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269E18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269E18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269E18);
		  /* 82269E18h */ case    0:  		/* cmpwi CR6, R29, 0 */
		/* 82269E18h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 82269E18h case    0:*/		return 0x82269E1C;
		  /* 82269E1Ch */ case    1:  		/* bc 4, CR6_EQ, 28 */
		/* 82269E1Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x82269E38;  }
		/* 82269E1Ch case    1:*/		return 0x82269E20;
		  /* 82269E20h */ case    2:  		/* cmpwi CR6, R26, 0 */
		/* 82269E20h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R26,0x00000000);
		/* 82269E20h case    2:*/		return 0x82269E24;
		  /* 82269E24h */ case    3:  		/* bc 12, CR6_EQ, 20 */
		/* 82269E24h case    3:*/		if ( regs.CR[6].eq ) { return 0x82269E38;  }
		/* 82269E24h case    3:*/		return 0x82269E28;
		  /* 82269E28h */ case    4:  		/* lis R11, -32251 */
		/* 82269E28h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82269E28h case    4:*/		return 0x82269E2C;
		  /* 82269E2Ch */ case    5:  		/* mr R3, R25 */
		/* 82269E2Ch case    5:*/		regs.R3 = regs.R25;
		/* 82269E2Ch case    5:*/		return 0x82269E30;
		  /* 82269E30h */ case    6:  		/* addi R4, R11, -16256 */
		/* 82269E30h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFC080);
		/* 82269E30h case    6:*/		return 0x82269E34;
		  /* 82269E34h */ case    7:  		/* bl -1108 */
		/* 82269E34h case    7:*/		regs.LR = 0x82269E38; return 0x822699E0;
		/* 82269E34h case    7:*/		return 0x82269E38;
	}
	return 0x82269E38;
} // Block from 82269E18h-82269E38h (8 instructions)

//////////////////////////////////////////////////////
// Block at 82269E38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269E38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269E38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269E38);
		  /* 82269E38h */ case    0:  		/* cmpwi CR6, R30, 0 */
		/* 82269E38h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 82269E38h case    0:*/		return 0x82269E3C;
		  /* 82269E3Ch */ case    1:  		/* bc 12, CR6_LT, 24 */
		/* 82269E3Ch case    1:*/		if ( regs.CR[6].lt ) { return 0x82269E54;  }
		/* 82269E3Ch case    1:*/		return 0x82269E40;
		  /* 82269E40h */ case    2:  		/* lis R11, -32253 */
		/* 82269E40h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 82269E40h case    2:*/		return 0x82269E44;
		  /* 82269E44h */ case    3:  		/* mr R5, R30 */
		/* 82269E44h case    3:*/		regs.R5 = regs.R30;
		/* 82269E44h case    3:*/		return 0x82269E48;
		  /* 82269E48h */ case    4:  		/* addi R4, R11, 26668 */
		/* 82269E48h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x682C);
		/* 82269E48h case    4:*/		return 0x82269E4C;
		  /* 82269E4Ch */ case    5:  		/* mr R3, R25 */
		/* 82269E4Ch case    5:*/		regs.R3 = regs.R25;
		/* 82269E4Ch case    5:*/		return 0x82269E50;
		  /* 82269E50h */ case    6:  		/* bl -1136 */
		/* 82269E50h case    6:*/		regs.LR = 0x82269E54; return 0x822699E0;
		/* 82269E50h case    6:*/		return 0x82269E54;
	}
	return 0x82269E54;
} // Block from 82269E38h-82269E54h (7 instructions)

//////////////////////////////////////////////////////
// Block at 82269E54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269E54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269E54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269E54);
		  /* 82269E54h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 82269E54h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 82269E54h case    0:*/		return 0x82269E58;
		  /* 82269E58h */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 82269E58h case    1:*/		if ( regs.CR[6].eq ) { return 0x82269E6C;  }
		/* 82269E58h case    1:*/		return 0x82269E5C;
		  /* 82269E5Ch */ case    2:  		/* lis R11, -32252 */
		/* 82269E5Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 82269E5Ch case    2:*/		return 0x82269E60;
		  /* 82269E60h */ case    3:  		/* mr R3, R25 */
		/* 82269E60h case    3:*/		regs.R3 = regs.R25;
		/* 82269E60h case    3:*/		return 0x82269E64;
		  /* 82269E64h */ case    4:  		/* addi R4, R11, -23684 */
		/* 82269E64h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFA37C);
		/* 82269E64h case    4:*/		return 0x82269E68;
		  /* 82269E68h */ case    5:  		/* bl -1160 */
		/* 82269E68h case    5:*/		regs.LR = 0x82269E6C; return 0x822699E0;
		/* 82269E68h case    5:*/		return 0x82269E6C;
	}
	return 0x82269E6C;
} // Block from 82269E54h-82269E6Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 82269E6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269E6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269E6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269E6C);
		  /* 82269E6Ch */ case    0:  		/* rlwinm. R11, R27, 0, 24, 31 */
		/* 82269E6Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R27);
		/* 82269E6Ch case    0:*/		return 0x82269E70;
		  /* 82269E70h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 82269E70h case    1:*/		if ( regs.CR[0].eq ) { return 0x82269E80;  }
		/* 82269E70h case    1:*/		return 0x82269E74;
		  /* 82269E74h */ case    2:  		/* lis R11, -32251 */
		/* 82269E74h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82269E74h case    2:*/		return 0x82269E78;
		  /* 82269E78h */ case    3:  		/* addi R4, R11, -16260 */
		/* 82269E78h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFC07C);
		/* 82269E78h case    3:*/		return 0x82269E7C;
		  /* 82269E7Ch */ case    4:  		/* b 412 */
		/* 82269E7Ch case    4:*/		return 0x8226A018;
		/* 82269E7Ch case    4:*/		return 0x82269E80;
	}
	return 0x82269E80;
} // Block from 82269E6Ch-82269E80h (5 instructions)

//////////////////////////////////////////////////////
// Block at 82269E80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269E80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269E80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269E80);
		  /* 82269E80h */ case    0:  		/* cmpwi CR6, R29, 0 */
		/* 82269E80h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000000);
		/* 82269E80h case    0:*/		return 0x82269E84;
		  /* 82269E84h */ case    1:  		/* bc 4, CR6_EQ, 120 */
		/* 82269E84h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82269EFC;  }
		/* 82269E84h case    1:*/		return 0x82269E88;
		  /* 82269E88h */ case    2:  		/* cmpwi CR6, R24, 15 */
		/* 82269E88h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x0000000F);
		/* 82269E88h case    2:*/		return 0x82269E8C;
		  /* 82269E8Ch */ case    3:  		/* bc 12, CR6_EQ, 404 */
		/* 82269E8Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x8226A020;  }
		/* 82269E8Ch case    3:*/		return 0x82269E90;
		  /* 82269E90h */ case    4:  		/* lis R11, -32256 */
		/* 82269E90h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82269E90h case    4:*/		return 0x82269E94;
		  /* 82269E94h */ case    5:  		/* mr R3, R25 */
		/* 82269E94h case    5:*/		regs.R3 = regs.R25;
		/* 82269E94h case    5:*/		return 0x82269E98;
		  /* 82269E98h */ case    6:  		/* addi R4, R11, 20592 */
		/* 82269E98h case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x5070);
		/* 82269E98h case    6:*/		return 0x82269E9C;
		  /* 82269E9Ch */ case    7:  		/* bl -1212 */
		/* 82269E9Ch case    7:*/		regs.LR = 0x82269EA0; return 0x822699E0;
		/* 82269E9Ch case    7:*/		return 0x82269EA0;
		  /* 82269EA0h */ case    8:  		/* rlwinm. R11, R24, 0, 31, 31 */
		/* 82269EA0h case    8:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R24);
		/* 82269EA0h case    8:*/		return 0x82269EA4;
		  /* 82269EA4h */ case    9:  		/* bc 12, CR0_EQ, 20 */
		/* 82269EA4h case    9:*/		if ( regs.CR[0].eq ) { return 0x82269EB8;  }
		/* 82269EA4h case    9:*/		return 0x82269EA8;
		  /* 82269EA8h */ case   10:  		/* lis R11, -32255 */
		/* 82269EA8h case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82269EA8h case   10:*/		return 0x82269EAC;
		  /* 82269EACh */ case   11:  		/* mr R3, R25 */
		/* 82269EACh case   11:*/		regs.R3 = regs.R25;
		/* 82269EACh case   11:*/		return 0x82269EB0;
		  /* 82269EB0h */ case   12:  		/* addi R4, R11, 12560 */
		/* 82269EB0h case   12:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x3110);
		/* 82269EB0h case   12:*/		return 0x82269EB4;
		  /* 82269EB4h */ case   13:  		/* bl -1236 */
		/* 82269EB4h case   13:*/		regs.LR = 0x82269EB8; return 0x822699E0;
		/* 82269EB4h case   13:*/		return 0x82269EB8;
	}
	return 0x82269EB8;
} // Block from 82269E80h-82269EB8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 82269EB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269EB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269EB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269EB8);
		  /* 82269EB8h */ case    0:  		/* rlwinm. R11, R24, 0, 30, 30 */
		/* 82269EB8h case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R24);
		/* 82269EB8h case    0:*/		return 0x82269EBC;
		  /* 82269EBCh */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 82269EBCh case    1:*/		if ( regs.CR[0].eq ) { return 0x82269ED0;  }
		/* 82269EBCh case    1:*/		return 0x82269EC0;
	}
	return 0x82269EC0;
} // Block from 82269EB8h-82269EC0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82269EC0h
// Function 'modf'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269EC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269EC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269EC0);
		  /* 82269EC0h */ case    0:  		/* lis R11, -32255 */
		/* 82269EC0h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82269EC0h case    0:*/		return 0x82269EC4;
		  /* 82269EC4h */ case    1:  		/* mr R3, R25 */
		/* 82269EC4h case    1:*/		regs.R3 = regs.R25;
		/* 82269EC4h case    1:*/		return 0x82269EC8;
		  /* 82269EC8h */ case    2:  		/* addi R4, R11, 12556 */
		/* 82269EC8h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x310C);
		/* 82269EC8h case    2:*/		return 0x82269ECC;
		  /* 82269ECCh */ case    3:  		/* bl -1260 */
		/* 82269ECCh case    3:*/		regs.LR = 0x82269ED0; return 0x822699E0;
		/* 82269ECCh case    3:*/		return 0x82269ED0;
	}
	return 0x82269ED0;
} // Block from 82269EC0h-82269ED0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82269ED0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269ED0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269ED0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269ED0);
		  /* 82269ED0h */ case    0:  		/* rlwinm. R11, R24, 0, 29, 29 */
		/* 82269ED0h case    0:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R24);
		/* 82269ED0h case    0:*/		return 0x82269ED4;
		  /* 82269ED4h */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 82269ED4h case    1:*/		if ( regs.CR[0].eq ) { return 0x82269EE8;  }
		/* 82269ED4h case    1:*/		return 0x82269ED8;
		  /* 82269ED8h */ case    2:  		/* lis R11, -32255 */
		/* 82269ED8h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82269ED8h case    2:*/		return 0x82269EDC;
		  /* 82269EDCh */ case    3:  		/* mr R3, R25 */
		/* 82269EDCh case    3:*/		regs.R3 = regs.R25;
		/* 82269EDCh case    3:*/		return 0x82269EE0;
		  /* 82269EE0h */ case    4:  		/* addi R4, R11, 12548 */
		/* 82269EE0h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x3104);
		/* 82269EE0h case    4:*/		return 0x82269EE4;
		  /* 82269EE4h */ case    5:  		/* bl -1284 */
		/* 82269EE4h case    5:*/		regs.LR = 0x82269EE8; return 0x822699E0;
		/* 82269EE4h case    5:*/		return 0x82269EE8;
	}
	return 0x82269EE8;
} // Block from 82269ED0h-82269EE8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 82269EE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269EE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269EE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269EE8);
		  /* 82269EE8h */ case    0:  		/* rlwinm. R11, R24, 0, 28, 28 */
		/* 82269EE8h case    0:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R24);
		/* 82269EE8h case    0:*/		return 0x82269EEC;
		  /* 82269EECh */ case    1:  		/* bc 12, CR0_EQ, 308 */
		/* 82269EECh case    1:*/		if ( regs.CR[0].eq ) { return 0x8226A020;  }
		/* 82269EECh case    1:*/		return 0x82269EF0;
		  /* 82269EF0h */ case    2:  		/* lis R11, -32255 */
		/* 82269EF0h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 82269EF0h case    2:*/		return 0x82269EF4;
		  /* 82269EF4h */ case    3:  		/* addi R4, R11, 12532 */
		/* 82269EF4h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x30F4);
		/* 82269EF4h case    3:*/		return 0x82269EF8;
		  /* 82269EF8h */ case    4:  		/* b 288 */
		/* 82269EF8h case    4:*/		return 0x8226A018;
		/* 82269EF8h case    4:*/		return 0x82269EFC;
	}
	return 0x82269EFC;
} // Block from 82269EE8h-82269EFCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 82269EFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269EFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269EFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269EFC);
		  /* 82269EFCh */ case    0:  		/* cmpwi CR6, R24, 15 */
		/* 82269EFCh case    0:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x0000000F);
		/* 82269EFCh case    0:*/		return 0x82269F00;
		  /* 82269F00h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 82269F00h case    1:*/		if ( !regs.CR[6].eq ) { return 0x82269F0C;  }
		/* 82269F00h case    1:*/		return 0x82269F04;
		  /* 82269F04h */ case    2:  		/* cmpwi CR6, R23, 0 */
		/* 82269F04h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R23,0x00000000);
		/* 82269F04h case    2:*/		return 0x82269F08;
		  /* 82269F08h */ case    3:  		/* bc 12, CR6_EQ, 280 */
		/* 82269F08h case    3:*/		if ( regs.CR[6].eq ) { return 0x8226A020;  }
		/* 82269F08h case    3:*/		return 0x82269F0C;
	}
	return 0x82269F0C;
} // Block from 82269EFCh-82269F0Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 82269F0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269F0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269F0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269F0C);
		  /* 82269F0Ch */ case    0:  		/* lis R11, -32256 */
		/* 82269F0Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 82269F0Ch case    0:*/		return 0x82269F10;
		  /* 82269F10h */ case    1:  		/* mr R3, R25 */
		/* 82269F10h case    1:*/		regs.R3 = regs.R25;
		/* 82269F10h case    1:*/		return 0x82269F14;
		  /* 82269F14h */ case    2:  		/* addi R4, R11, 20592 */
		/* 82269F14h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x5070);
		/* 82269F14h case    2:*/		return 0x82269F18;
		  /* 82269F18h */ case    3:  		/* bl -1336 */
		/* 82269F18h case    3:*/		regs.LR = 0x82269F1C; return 0x822699E0;
		/* 82269F18h case    3:*/		return 0x82269F1C;
		  /* 82269F1Ch */ case    4:  		/* li R11, 4 */
		/* 82269F1Ch case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x4);
		/* 82269F1Ch case    4:*/		return 0x82269F20;
		  /* 82269F20h */ case    5:  		/* mr R10, R21 */
		/* 82269F20h case    5:*/		regs.R10 = regs.R21;
		/* 82269F20h case    5:*/		return 0x82269F24;
		  /* 82269F24h */ case    6:  		/* mtspr CTR, R11 */
		/* 82269F24h case    6:*/		regs.CTR = regs.R11;
		/* 82269F24h case    6:*/		return 0x82269F28;
		  /* 82269F28h */ case    7:  		/* lis R11, -32251 */
		/* 82269F28h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 82269F28h case    7:*/		return 0x82269F2C;
		  /* 82269F2Ch */ case    8:  		/* addi R9, R11, -16264 */
		/* 82269F2Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFC078);
		/* 82269F2Ch case    8:*/		return 0x82269F30;
		  /* 82269F30h */ case    9:  		/* li R11, 1 */
		/* 82269F30h case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 82269F30h case    9:*/		return 0x82269F34;
		  /* 82269F34h */ case   10:  		/* slw R11, R11, R10 */
		/* 82269F34h case   10:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 82269F34h case   10:*/		return 0x82269F38;
		  /* 82269F38h */ case   11:  		/* and. R8, R11, R24 */
		/* 82269F38h case   11:*/		cpu::op::and<1>(regs,&regs.R8,regs.R11,regs.R24);
		/* 82269F38h case   11:*/		return 0x82269F3C;
		  /* 82269F3Ch */ case   12:  		/* bc 12, CR0_EQ, 28 */
		/* 82269F3Ch case   12:*/		if ( regs.CR[0].eq ) { return 0x82269F58;  }
		/* 82269F3Ch case   12:*/		return 0x82269F40;
		  /* 82269F40h */ case   13:  		/* and. R11, R11, R23 */
		/* 82269F40h case   13:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R23);
		/* 82269F40h case   13:*/		return 0x82269F44;
		  /* 82269F44h */ case   14:  		/* bc 12, CR0_EQ, 12 */
		/* 82269F44h case   14:*/		if ( regs.CR[0].eq ) { return 0x82269F50;  }
		/* 82269F44h case   14:*/		return 0x82269F48;
		  /* 82269F48h */ case   15:  		/* li R11, 49 */
		/* 82269F48h case   15:*/		cpu::op::li<0>(regs,&regs.R11,0x31);
		/* 82269F48h case   15:*/		return 0x82269F4C;
		  /* 82269F4Ch */ case   16:  		/* b 48 */
		/* 82269F4Ch case   16:*/		return 0x82269F7C;
		/* 82269F4Ch case   16:*/		return 0x82269F50;
	}
	return 0x82269F50;
} // Block from 82269F0Ch-82269F50h (17 instructions)

//////////////////////////////////////////////////////
// Block at 82269F50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269F50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269F50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269F50);
		  /* 82269F50h */ case    0:  		/* lbzx R11, <#[R10 + R9]> */
		/* 82269F50h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 82269F50h case    0:*/		return 0x82269F54;
		  /* 82269F54h */ case    1:  		/* b 40 */
		/* 82269F54h case    1:*/		return 0x82269F7C;
		/* 82269F54h case    1:*/		return 0x82269F58;
	}
	return 0x82269F58;
} // Block from 82269F50h-82269F58h (2 instructions)

//////////////////////////////////////////////////////
// Block at 82269F58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269F58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269F58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269F58);
		  /* 82269F58h */ case    0:  		/* and. R11, R11, R23 */
		/* 82269F58h case    0:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R23);
		/* 82269F58h case    0:*/		return 0x82269F5C;
		  /* 82269F5Ch */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 82269F5Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x82269F68;  }
		/* 82269F5Ch case    1:*/		return 0x82269F60;
		  /* 82269F60h */ case    2:  		/* li R11, 95 */
		/* 82269F60h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x5F);
		/* 82269F60h case    2:*/		return 0x82269F64;
		  /* 82269F64h */ case    3:  		/* b 24 */
		/* 82269F64h case    3:*/		return 0x82269F7C;
		/* 82269F64h case    3:*/		return 0x82269F68;
	}
	return 0x82269F68;
} // Block from 82269F58h-82269F68h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82269F68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269F68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269F68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269F68);
		  /* 82269F68h */ case    0:  		/* subfic R11, R22, 0 */
		/* 82269F68h case    0:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R22,0x0);
		/* 82269F68h case    0:*/		return 0x82269F6C;
		  /* 82269F6Ch */ case    1:  		/* subfe R11, R11, R11 */
		/* 82269F6Ch case    1:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 82269F6Ch case    1:*/		return 0x82269F70;
		  /* 82269F70h */ case    2:  		/* rlwinm R11, R11, 0, 31, 27 */
		/* 82269F70h case    2:*/		cpu::op::rlwinm<0,0,31,27>(regs,&regs.R11,regs.R11);
		/* 82269F70h case    2:*/		return 0x82269F74;
		  /* 82269F74h */ case    3:  		/* rlwinm R11, R11, 0, 27, 25 */
		/* 82269F74h case    3:*/		cpu::op::rlwinm<0,0,27,25>(regs,&regs.R11,regs.R11);
		/* 82269F74h case    3:*/		return 0x82269F78;
		  /* 82269F78h */ case    4:  		/* addi R11, R11, 95 */
		/* 82269F78h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x5F);
		/* 82269F78h case    4:*/		return 0x82269F7C;
	}
	return 0x82269F7C;
} // Block from 82269F68h-82269F7Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 82269F7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269F7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269F7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269F7C);
		  /* 82269F7Ch */ case    0:  		/* addi R8, R1, 144 */
		/* 82269F7Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x90);
		/* 82269F7Ch case    0:*/		return 0x82269F80;
		  /* 82269F80h */ case    1:  		/* stbx R11, <#[R10 + R8]> */
		/* 82269F80h case    1:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 82269F80h case    1:*/		return 0x82269F84;
		  /* 82269F84h */ case    2:  		/* addi R10, R10, 1 */
		/* 82269F84h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82269F84h case    2:*/		return 0x82269F88;
		  /* 82269F88h */ case    3:  		/* bc 16, CR0_LT, -88 */
		/* 82269F88h case    3:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x82269F30;  }
		/* 82269F88h case    3:*/		return 0x82269F8C;
		  /* 82269F8Ch */ case    4:  		/* li R7, 1 */
		/* 82269F8Ch case    4:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 82269F8Ch case    4:*/		return 0x82269F90;
		  /* 82269F90h */ case    5:  		/* addi R8, R1, 152 */
		/* 82269F90h case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x98);
		/* 82269F90h case    5:*/		return 0x82269F94;
		  /* 82269F94h */ case    6:  		/* mr R10, R21 */
		/* 82269F94h case    6:*/		regs.R10 = regs.R21;
		/* 82269F94h case    6:*/		return 0x82269F98;
		  /* 82269F98h */ case    7:  		/* addi R11, R1, 144 */
		/* 82269F98h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x90);
		/* 82269F98h case    7:*/		return 0x82269F9C;
		  /* 82269F9Ch */ case    8:  		/* lbzx R9, <#[R10 + R11]> */
		/* 82269F9Ch case    8:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 82269F9Ch case    8:*/		return 0x82269FA0;
		  /* 82269FA0h */ case    9:  		/* extsb R11, R9 */
		/* 82269FA0h case    9:*/		cpu::op::extsb<0>(regs,&regs.R11,regs.R9);
		/* 82269FA0h case    9:*/		return 0x82269FA4;
		  /* 82269FA4h */ case   10:  		/* cmpwi CR6, R11, 48 */
		/* 82269FA4h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000030);
		/* 82269FA4h case   10:*/		return 0x82269FA8;
		  /* 82269FA8h */ case   11:  		/* bc 12, CR6_EQ, 44 */
		/* 82269FA8h case   11:*/		if ( regs.CR[6].eq ) { return 0x82269FD4;  }
		/* 82269FA8h case   11:*/		return 0x82269FAC;
		  /* 82269FACh */ case   12:  		/* cmpwi CR6, R11, 49 */
		/* 82269FACh case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000031);
		/* 82269FACh case   12:*/		return 0x82269FB0;
		  /* 82269FB0h */ case   13:  		/* bc 12, CR6_EQ, 36 */
		/* 82269FB0h case   13:*/		if ( regs.CR[6].eq ) { return 0x82269FD4;  }
		/* 82269FB0h case   13:*/		return 0x82269FB4;
		  /* 82269FB4h */ case   14:  		/* cmpwi CR6, R11, 95 */
		/* 82269FB4h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000005F);
		/* 82269FB4h case   14:*/		return 0x82269FB8;
		  /* 82269FB8h */ case   15:  		/* bc 12, CR6_EQ, 12 */
		/* 82269FB8h case   15:*/		if ( regs.CR[6].eq ) { return 0x82269FC4;  }
		/* 82269FB8h case   15:*/		return 0x82269FBC;
		  /* 82269FBCh */ case   16:  		/* stb R9, <#[R8]> */
		/* 82269FBCh case   16:*/		cpu::mem::store8( regs, regs.R9, (uint32)(regs.R8 + 0x00000000) );
		/* 82269FBCh case   16:*/		return 0x82269FC0;
		  /* 82269FC0h */ case   17:  		/* addi R8, R8, 1 */
		/* 82269FC0h case   17:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 82269FC0h case   17:*/		return 0x82269FC4;
	}
	return 0x82269FC4;
} // Block from 82269F7Ch-82269FC4h (18 instructions)

//////////////////////////////////////////////////////
// Block at 82269FC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269FC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269FC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269FC4);
		  /* 82269FC4h */ case    0:  		/* addi R10, R10, 1 */
		/* 82269FC4h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 82269FC4h case    0:*/		return 0x82269FC8;
		  /* 82269FC8h */ case    1:  		/* cmpwi CR6, R10, 4 */
		/* 82269FC8h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000004);
		/* 82269FC8h case    1:*/		return 0x82269FCC;
		  /* 82269FCCh */ case    2:  		/* bc 12, CR6_LT, -52 */
		/* 82269FCCh case    2:*/		if ( regs.CR[6].lt ) { return 0x82269F98;  }
		/* 82269FCCh case    2:*/		return 0x82269FD0;
		  /* 82269FD0h */ case    3:  		/* b 8 */
		/* 82269FD0h case    3:*/		return 0x82269FD8;
		/* 82269FD0h case    3:*/		return 0x82269FD4;
	}
	return 0x82269FD4;
} // Block from 82269FC4h-82269FD4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 82269FD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269FD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269FD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269FD4);
		  /* 82269FD4h */ case    0:  		/* mr R7, R21 */
		/* 82269FD4h case    0:*/		regs.R7 = regs.R21;
		/* 82269FD4h case    0:*/		return 0x82269FD8;
	}
	return 0x82269FD8;
} // Block from 82269FD4h-82269FD8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82269FD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269FD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269FD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269FD8);
		  /* 82269FD8h */ case    0:  		/* rlwinm. R11, R7, 0, 24, 31 */
		/* 82269FD8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R7);
		/* 82269FD8h case    0:*/		return 0x82269FDC;
		  /* 82269FDCh */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 82269FDCh case    1:*/		if ( regs.CR[0].eq ) { return 0x82269FEC;  }
		/* 82269FDCh case    1:*/		return 0x82269FE0;
		  /* 82269FE0h */ case    2:  		/* stb R21, <#[R8]> */
		/* 82269FE0h case    2:*/		cpu::mem::store8( regs, regs.R21, (uint32)(regs.R8 + 0x00000000) );
		/* 82269FE0h case    2:*/		return 0x82269FE4;
		  /* 82269FE4h */ case    3:  		/* addi R4, R1, 152 */
		/* 82269FE4h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x98);
		/* 82269FE4h case    3:*/		return 0x82269FE8;
		  /* 82269FE8h */ case    4:  		/* b 48 */
		/* 82269FE8h case    4:*/		return 0x8226A018;
		/* 82269FE8h case    4:*/		return 0x82269FEC;
	}
	return 0x82269FEC;
} // Block from 82269FD8h-82269FECh (5 instructions)

//////////////////////////////////////////////////////
// Block at 82269FECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269FEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269FEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269FEC);
		  /* 82269FECh */ case    0:  		/* li R11, 3 */
		/* 82269FECh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 82269FECh case    0:*/		return 0x82269FF0;
	}
	return 0x82269FF0;
} // Block from 82269FECh-82269FF0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 82269FF0h
// Function '__ascii_strnicmp'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block82269FF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x82269FF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x82269FF0);
		  /* 82269FF0h */ case    0:  		/* stb R21, <#[R1 + 148]> */
		/* 82269FF0h case    0:*/		cpu::mem::store8( regs, regs.R21, (uint32)(regs.R1 + 0x00000094) );
		/* 82269FF0h case    0:*/		return 0x82269FF4;
		  /* 82269FF4h */ case    1:  		/* addi R10, R1, 144 */
		/* 82269FF4h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x90);
		/* 82269FF4h case    1:*/		return 0x82269FF8;
		  /* 82269FF8h */ case    2:  		/* add R10, R11, R10 */
		/* 82269FF8h case    2:*/		cpu::op::add<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 82269FF8h case    2:*/		return 0x82269FFC;
		  /* 82269FFCh */ case    3:  		/* lbz R9, <#[R10]> */
		/* 82269FFCh case    3:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 82269FFCh case    3:*/		return 0x8226A000;
		  /* 8226A000h */ case    4:  		/* cmplwi CR6, R9, 95 */
		/* 8226A000h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x0000005F);
		/* 8226A000h case    4:*/		return 0x8226A004;
		  /* 8226A004h */ case    5:  		/* bc 4, CR6_EQ, 16 */
		/* 8226A004h case    5:*/		if ( !regs.CR[6].eq ) { return 0x8226A014;  }
		/* 8226A004h case    5:*/		return 0x8226A008;
		  /* 8226A008h */ case    6:  		/* addic. R11, R11, -1 */
		/* 8226A008h case    6:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8226A008h case    6:*/		return 0x8226A00C;
		  /* 8226A00Ch */ case    7:  		/* stb R21, <#[R10]> */
		/* 8226A00Ch case    7:*/		cpu::mem::store8( regs, regs.R21, (uint32)(regs.R10 + 0x00000000) );
		/* 8226A00Ch case    7:*/		return 0x8226A010;
		  /* 8226A010h */ case    8:  		/* bc 12, CR0_GT, -28 */
		/* 8226A010h case    8:*/		if ( regs.CR[0].gt ) { return 0x82269FF4;  }
		/* 8226A010h case    8:*/		return 0x8226A014;
	}
	return 0x8226A014;
} // Block from 82269FF0h-8226A014h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8226A014h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A014( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A014) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A014);
		  /* 8226A014h */ case    0:  		/* addi R4, R1, 144 */
		/* 8226A014h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x90);
		/* 8226A014h case    0:*/		return 0x8226A018;
	}
	return 0x8226A018;
} // Block from 8226A014h-8226A018h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226A018h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A018( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A018) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A018);
		  /* 8226A018h */ case    0:  		/* mr R3, R25 */
		/* 8226A018h case    0:*/		regs.R3 = regs.R25;
		/* 8226A018h case    0:*/		return 0x8226A01C;
		  /* 8226A01Ch */ case    1:  		/* bl -1596 */
		/* 8226A01Ch case    1:*/		regs.LR = 0x8226A020; return 0x822699E0;
		/* 8226A01Ch case    1:*/		return 0x8226A020;
	}
	return 0x8226A020;
} // Block from 8226A018h-8226A020h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226A020h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A020( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A020) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A020);
		  /* 8226A020h */ case    0:  		/* addi R1, R1, 256 */
		/* 8226A020h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x100);
		/* 8226A020h case    0:*/		return 0x8226A024;
		  /* 8226A024h */ case    1:  		/* b -1936792 */
		/* 8226A024h case    1:*/		return 0x8209128C;
		/* 8226A024h case    1:*/		return 0x8226A028;
	}
	return 0x8226A028;
} // Block from 8226A020h-8226A028h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226A028h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A028( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A028) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A028);
		  /* 8226A028h */ case    0:  		/* mfspr R12, LR */
		/* 8226A028h case    0:*/		regs.R12 = regs.LR;
		/* 8226A028h case    0:*/		return 0x8226A02C;
		  /* 8226A02Ch */ case    1:  		/* bl -1936880 */
		/* 8226A02Ch case    1:*/		regs.LR = 0x8226A030; return 0x8209123C;
		/* 8226A02Ch case    1:*/		return 0x8226A030;
		  /* 8226A030h */ case    2:  		/* stwu R1, <#[R1 - 256]> */
		/* 8226A030h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF00) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF00);
		/* 8226A030h case    2:*/		return 0x8226A034;
		  /* 8226A034h */ case    3:  		/* mr R31, R3 */
		/* 8226A034h case    3:*/		regs.R31 = regs.R3;
		/* 8226A034h case    3:*/		return 0x8226A038;
		  /* 8226A038h */ case    4:  		/* mr R30, R4 */
		/* 8226A038h case    4:*/		regs.R30 = regs.R4;
		/* 8226A038h case    4:*/		return 0x8226A03C;
		  /* 8226A03Ch */ case    5:  		/* mr R22, R7 */
		/* 8226A03Ch case    5:*/		regs.R22 = regs.R7;
		/* 8226A03Ch case    5:*/		return 0x8226A040;
		  /* 8226A040h */ case    6:  		/* mr R28, R10 */
		/* 8226A040h case    6:*/		regs.R28 = regs.R10;
		/* 8226A040h case    6:*/		return 0x8226A044;
		  /* 8226A044h */ case    7:  		/* cmpwi CR6, R4, 0 */
		/* 8226A044h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000000);
		/* 8226A044h case    7:*/		return 0x8226A048;
		  /* 8226A048h */ case    8:  		/* bc 4, CR6_EQ, 12 */
		/* 8226A048h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8226A054;  }
		/* 8226A048h case    8:*/		return 0x8226A04C;
		  /* 8226A04Ch */ case    9:  		/* cmpwi CR6, R8, 0 */
		/* 8226A04Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R8,0x00000000);
		/* 8226A04Ch case    9:*/		return 0x8226A050;
		  /* 8226A050h */ case   10:  		/* bc 4, CR6_EQ, 20 */
		/* 8226A050h case   10:*/		if ( !regs.CR[6].eq ) { return 0x8226A064;  }
		/* 8226A050h case   10:*/		return 0x8226A054;
	}
	return 0x8226A054;
} // Block from 8226A028h-8226A054h (11 instructions)

//////////////////////////////////////////////////////
// Block at 8226A054h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A054( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A054) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A054);
		  /* 8226A054h */ case    0:  		/* cmpwi CR6, R30, 1 */
		/* 8226A054h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000001);
		/* 8226A054h case    0:*/		return 0x8226A058;
	}
	return 0x8226A058;
} // Block from 8226A054h-8226A058h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226A058h
// Function '_strnicmp'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A058( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A058) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A058);
		  /* 8226A058h */ case    0:  		/* bc 4, CR6_EQ, 20 */
		/* 8226A058h case    0:*/		if ( !regs.CR[6].eq ) { return 0x8226A06C;  }
		/* 8226A058h case    0:*/		return 0x8226A05C;
		  /* 8226A05Ch */ case    1:  		/* rlwinm. R11, R5, 0, 24, 24 */
		/* 8226A05Ch case    1:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R11,regs.R5);
		/* 8226A05Ch case    1:*/		return 0x8226A060;
		  /* 8226A060h */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 8226A060h case    2:*/		if ( regs.CR[0].eq ) { return 0x8226A06C;  }
		/* 8226A060h case    2:*/		return 0x8226A064;
	}
	return 0x8226A064;
} // Block from 8226A058h-8226A064h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8226A064h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A064( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A064) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A064);
		  /* 8226A064h */ case    0:  		/* li R21, 1 */
		/* 8226A064h case    0:*/		cpu::op::li<0>(regs,&regs.R21,0x1);
		/* 8226A064h case    0:*/		return 0x8226A068;
		  /* 8226A068h */ case    1:  		/* b 8 */
		/* 8226A068h case    1:*/		return 0x8226A070;
		/* 8226A068h case    1:*/		return 0x8226A06C;
	}
	return 0x8226A06C;
} // Block from 8226A064h-8226A06Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226A06Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A06C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A06C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A06C);
		  /* 8226A06Ch */ case    0:  		/* li R21, 0 */
		/* 8226A06Ch case    0:*/		cpu::op::li<0>(regs,&regs.R21,0x0);
		/* 8226A06Ch case    0:*/		return 0x8226A070;
	}
	return 0x8226A070;
} // Block from 8226A06Ch-8226A070h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226A070h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A070( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A070) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A070);
		  /* 8226A070h */ case    0:  		/* srawi R11, R5, 6 */
		/* 8226A070h case    0:*/		cpu::op::srawi<0,6>(regs,&regs.R11,regs.R5);
		/* 8226A070h case    0:*/		return 0x8226A074;
		  /* 8226A074h */ case    1:  		/* subfic R10, R30, 0 */
		/* 8226A074h case    1:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R30,0x0);
		/* 8226A074h case    1:*/		return 0x8226A078;
		  /* 8226A078h */ case    2:  		/* and R7, R11, R30 */
		/* 8226A078h case    2:*/		cpu::op::and<0>(regs,&regs.R7,regs.R11,regs.R30);
		/* 8226A078h case    2:*/		return 0x8226A07C;
		  /* 8226A07Ch */ case    3:  		/* subfe R10, R10, R10 */
		/* 8226A07Ch case    3:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8226A07Ch case    3:*/		return 0x8226A080;
		  /* 8226A080h */ case    4:  		/* cntlzw R8, R30 */
		/* 8226A080h case    4:*/		cpu::op::cntlzw<0>(regs,&regs.R8,regs.R30);
		/* 8226A080h case    4:*/		return 0x8226A084;
		  /* 8226A084h */ case    5:  		/* rlwinm R11, R10, 0, 0, 25 */
		/* 8226A084h case    5:*/		cpu::op::rlwinm<0,0,0,25>(regs,&regs.R11,regs.R10);
		/* 8226A084h case    5:*/		return 0x8226A088;
		  /* 8226A088h */ case    6:  		/* rlwinm R10, R8, 27, 31, 31 */
		/* 8226A088h case    6:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R10,regs.R8);
		/* 8226A088h case    6:*/		return 0x8226A08C;
		  /* 8226A08Ch */ case    7:  		/* rlwinm R11, R11, 0, 25, 23 */
		/* 8226A08Ch case    7:*/		cpu::op::rlwinm<0,0,25,23>(regs,&regs.R11,regs.R11);
		/* 8226A08Ch case    7:*/		return 0x8226A090;
		  /* 8226A090h */ case    8:  		/* rlwinm R27, R7, 0, 31, 31 */
		/* 8226A090h case    8:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R27,regs.R7);
		/* 8226A090h case    8:*/		return 0x8226A094;
		  /* 8226A094h */ case    9:  		/* addi R11, R11, 255 */
		/* 8226A094h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFF);
		/* 8226A094h case    9:*/		return 0x8226A098;
		  /* 8226A098h */ case   10:  		/* and R23, R10, R6 */
		/* 8226A098h case   10:*/		cpu::op::and<0>(regs,&regs.R23,regs.R10,regs.R6);
		/* 8226A098h case   10:*/		return 0x8226A09C;
		  /* 8226A09Ch */ case   11:  		/* and R24, R11, R5 */
		/* 8226A09Ch case   11:*/		cpu::op::and<0>(regs,&regs.R24,regs.R11,regs.R5);
		/* 8226A09Ch case   11:*/		return 0x8226A0A0;
		  /* 8226A0A0h */ case   12:  		/* cmpwi CR6, R9, 0 */
		/* 8226A0A0h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 8226A0A0h case   12:*/		return 0x8226A0A4;
		  /* 8226A0A4h */ case   13:  		/* bc 12, CR6_EQ, 20 */
		/* 8226A0A4h case   13:*/		if ( regs.CR[6].eq ) { return 0x8226A0B8;  }
		/* 8226A0A4h case   13:*/		return 0x8226A0A8;
		  /* 8226A0A8h */ case   14:  		/* lis R11, -32255 */
		/* 8226A0A8h case   14:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8226A0A8h case   14:*/		return 0x8226A0AC;
		  /* 8226A0ACh */ case   15:  		/* mr R3, R31 */
		/* 8226A0ACh case   15:*/		regs.R3 = regs.R31;
		/* 8226A0ACh case   15:*/		return 0x8226A0B0;
		  /* 8226A0B0h */ case   16:  		/* addi R4, R11, -16532 */
		/* 8226A0B0h case   16:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFBF6C);
		/* 8226A0B0h case   16:*/		return 0x8226A0B4;
		  /* 8226A0B4h */ case   17:  		/* bl -1748 */
		/* 8226A0B4h case   17:*/		regs.LR = 0x8226A0B8; return 0x822699E0;
		/* 8226A0B4h case   17:*/		return 0x8226A0B8;
	}
	return 0x8226A0B8;
} // Block from 8226A070h-8226A0B8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8226A0B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A0B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A0B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A0B8);
		  /* 8226A0B8h */ case    0:  		/* cmpwi CR6, R27, 0 */
		/* 8226A0B8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 8226A0B8h case    0:*/		return 0x8226A0BC;
		  /* 8226A0BCh */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 8226A0BCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x8226A0CC;  }
		/* 8226A0BCh case    1:*/		return 0x8226A0C0;
		  /* 8226A0C0h */ case    2:  		/* cmpwi CR6, R23, 0 */
		/* 8226A0C0h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R23,0x00000000);
		/* 8226A0C0h case    2:*/		return 0x8226A0C4;
		  /* 8226A0C4h */ case    3:  		/* li R10, 0 */
		/* 8226A0C4h case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8226A0C4h case    3:*/		return 0x8226A0C8;
		  /* 8226A0C8h */ case    4:  		/* bc 12, CR6_EQ, 8 */
		/* 8226A0C8h case    4:*/		if ( regs.CR[6].eq ) { return 0x8226A0D0;  }
		/* 8226A0C8h case    4:*/		return 0x8226A0CC;
	}
	return 0x8226A0CC;
} // Block from 8226A0B8h-8226A0CCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 8226A0CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A0CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A0CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A0CC);
		  /* 8226A0CCh */ case    0:  		/* li R10, 1 */
		/* 8226A0CCh case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8226A0CCh case    0:*/		return 0x8226A0D0;
	}
	return 0x8226A0D0;
} // Block from 8226A0CCh-8226A0D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226A0D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A0D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A0D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A0D0);
		  /* 8226A0D0h */ case    0:  		/* subfic R9, R30, 0 */
		/* 8226A0D0h case    0:*/		cpu::op::subfic<0>(regs,&regs.R9,regs.R30,0x0);
		/* 8226A0D0h case    0:*/		return 0x8226A0D4;
		  /* 8226A0D4h */ case    1:  		/* lis R11, -32253 */
		/* 8226A0D4h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 8226A0D4h case    1:*/		return 0x8226A0D8;
	}
	return 0x8226A0D8;
} // Block from 8226A0D0h-8226A0D8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226A0D8h
// Function '_fltin2'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A0D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A0D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A0D8);
		  /* 8226A0D8h */ case    0:  		/* subfe R9, R9, R9 */
		/* 8226A0D8h case    0:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 8226A0D8h case    0:*/		return 0x8226A0DC;
		  /* 8226A0DCh */ case    1:  		/* addi R26, R11, 25796 */
		/* 8226A0DCh case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R11,0x64C4);
		/* 8226A0DCh case    1:*/		return 0x8226A0E0;
		  /* 8226A0E0h */ case    2:  		/* rlwinm R11, R9, 0, 28, 31 */
		/* 8226A0E0h case    2:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R11,regs.R9);
		/* 8226A0E0h case    2:*/		return 0x8226A0E4;
		  /* 8226A0E4h */ case    3:  		/* mr R4, R26 */
		/* 8226A0E4h case    3:*/		regs.R4 = regs.R26;
		/* 8226A0E4h case    3:*/		return 0x8226A0E8;
		  /* 8226A0E8h */ case    4:  		/* mr R3, R31 */
		/* 8226A0E8h case    4:*/		regs.R3 = regs.R31;
		/* 8226A0E8h case    4:*/		return 0x8226A0EC;
		  /* 8226A0ECh */ case    5:  		/* addi R5, R11, 99 */
		/* 8226A0ECh case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x63);
		/* 8226A0ECh case    5:*/		return 0x8226A0F0;
		  /* 8226A0F0h */ case    6:  		/* rlwinm R30, R10, 0, 24, 31 */
		/* 8226A0F0h case    6:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R30,regs.R10);
		/* 8226A0F0h case    6:*/		return 0x8226A0F4;
		  /* 8226A0F4h */ case    7:  		/* bl -1812 */
		/* 8226A0F4h case    7:*/		regs.LR = 0x8226A0F8; return 0x822699E0;
		/* 8226A0F4h case    7:*/		return 0x8226A0F8;
		  /* 8226A0F8h */ case    8:  		/* lis R11, -32251 */
		/* 8226A0F8h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8226A0F8h case    8:*/		return 0x8226A0FC;
		  /* 8226A0FCh */ case    9:  		/* mr R25, R30 */
		/* 8226A0FCh case    9:*/		regs.R25 = regs.R30;
		/* 8226A0FCh case    9:*/		return 0x8226A100;
		  /* 8226A100h */ case   10:  		/* cmplwi CR0, R30, 0 */
		/* 8226A100h case   10:*/		cpu::op::cmplwi<0>(regs,regs.R30,0x00000000);
		/* 8226A100h case   10:*/		return 0x8226A104;
		  /* 8226A104h */ case   11:  		/* addi R29, R11, -16252 */
		/* 8226A104h case   11:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0xFFFFC084);
		/* 8226A104h case   11:*/		return 0x8226A108;
		  /* 8226A108h */ case   12:  		/* bc 12, CR0_EQ, 40 */
		/* 8226A108h case   12:*/		if ( regs.CR[0].eq ) { return 0x8226A130;  }
		/* 8226A108h case   12:*/		return 0x8226A10C;
		  /* 8226A10Ch */ case   13:  		/* cmpwi CR6, R21, 0 */
		/* 8226A10Ch case   13:*/		cpu::op::cmpwi<6>(regs,regs.R21,0x00000000);
		/* 8226A10Ch case   13:*/		return 0x8226A110;
		  /* 8226A110h */ case   14:  		/* bc 12, CR6_EQ, 16 */
		/* 8226A110h case   14:*/		if ( regs.CR[6].eq ) { return 0x8226A120;  }
		/* 8226A110h case   14:*/		return 0x8226A114;
		  /* 8226A114h */ case   15:  		/* mr R4, R29 */
		/* 8226A114h case   15:*/		regs.R4 = regs.R29;
		/* 8226A114h case   15:*/		return 0x8226A118;
		  /* 8226A118h */ case   16:  		/* mr R3, R31 */
		/* 8226A118h case   16:*/		regs.R3 = regs.R31;
		/* 8226A118h case   16:*/		return 0x8226A11C;
		  /* 8226A11Ch */ case   17:  		/* bl -1852 */
		/* 8226A11Ch case   17:*/		regs.LR = 0x8226A120; return 0x822699E0;
		/* 8226A11Ch case   17:*/		return 0x8226A120;
	}
	return 0x8226A120;
} // Block from 8226A0D8h-8226A120h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8226A120h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A120( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A120) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A120);
		  /* 8226A120h */ case    0:  		/* lis R11, -32252 */
		/* 8226A120h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8226A120h case    0:*/		return 0x8226A124;
		  /* 8226A124h */ case    1:  		/* mr R3, R31 */
		/* 8226A124h case    1:*/		regs.R3 = regs.R31;
		/* 8226A124h case    1:*/		return 0x8226A128;
		  /* 8226A128h */ case    2:  		/* addi R4, R11, -23676 */
		/* 8226A128h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFA384);
		/* 8226A128h case    2:*/		return 0x8226A12C;
		  /* 8226A12Ch */ case    3:  		/* bl -1868 */
		/* 8226A12Ch case    3:*/		regs.LR = 0x8226A130; return 0x822699E0;
		/* 8226A12Ch case    3:*/		return 0x8226A130;
	}
	return 0x8226A130;
} // Block from 8226A120h-8226A130h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226A130h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A130( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A130) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A130);
		  /* 8226A130h */ case    0:  		/* lis R11, -32253 */
		/* 8226A130h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 8226A130h case    0:*/		return 0x8226A134;
		  /* 8226A134h */ case    1:  		/* mr R5, R24 */
		/* 8226A134h case    1:*/		regs.R5 = regs.R24;
		/* 8226A134h case    1:*/		return 0x8226A138;
		  /* 8226A138h */ case    2:  		/* addi R4, R11, 26668 */
		/* 8226A138h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x682C);
		/* 8226A138h case    2:*/		return 0x8226A13C;
		  /* 8226A13Ch */ case    3:  		/* mr R3, R31 */
		/* 8226A13Ch case    3:*/		regs.R3 = regs.R31;
		/* 8226A13Ch case    3:*/		return 0x8226A140;
		  /* 8226A140h */ case    4:  		/* bl -1888 */
		/* 8226A140h case    4:*/		regs.LR = 0x8226A144; return 0x822699E0;
		/* 8226A140h case    4:*/		return 0x8226A144;
		  /* 8226A144h */ case    5:  		/* lis R11, -32252 */
		/* 8226A144h case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8226A144h case    5:*/		return 0x8226A148;
		  /* 8226A148h */ case    6:  		/* cmpwi CR6, R27, 0 */
		/* 8226A148h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 8226A148h case    6:*/		return 0x8226A14C;
		  /* 8226A14Ch */ case    7:  		/* addi R30, R11, -23672 */
		/* 8226A14Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0xFFFFA388);
		/* 8226A14Ch case    7:*/		return 0x8226A150;
		  /* 8226A150h */ case    8:  		/* bc 12, CR6_EQ, 16 */
		/* 8226A150h case    8:*/		if ( regs.CR[6].eq ) { return 0x8226A160;  }
		/* 8226A150h case    8:*/		return 0x8226A154;
		  /* 8226A154h */ case    9:  		/* mr R4, R30 */
		/* 8226A154h case    9:*/		regs.R4 = regs.R30;
		/* 8226A154h case    9:*/		return 0x8226A158;
		  /* 8226A158h */ case   10:  		/* mr R3, R31 */
		/* 8226A158h case   10:*/		regs.R3 = regs.R31;
		/* 8226A158h case   10:*/		return 0x8226A15C;
		  /* 8226A15Ch */ case   11:  		/* bl -1916 */
		/* 8226A15Ch case   11:*/		regs.LR = 0x8226A160; return 0x822699E0;
		/* 8226A15Ch case   11:*/		return 0x8226A160;
	}
	return 0x8226A160;
} // Block from 8226A130h-8226A160h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8226A160h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A160( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A160) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A160);
		  /* 8226A160h */ case    0:  		/* cmpwi CR6, R23, 0 */
		/* 8226A160h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R23,0x00000000);
		/* 8226A160h case    0:*/		return 0x8226A164;
		  /* 8226A164h */ case    1:  		/* bc 12, CR6_EQ, 36 */
		/* 8226A164h case    1:*/		if ( regs.CR[6].eq ) { return 0x8226A188;  }
		/* 8226A164h case    1:*/		return 0x8226A168;
		  /* 8226A168h */ case    2:  		/* cmpwi CR6, R22, 0 */
		/* 8226A168h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R22,0x00000000);
		/* 8226A168h case    2:*/		return 0x8226A16C;
		  /* 8226A16Ch */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 8226A16Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x8226A17C;  }
		/* 8226A16Ch case    3:*/		return 0x8226A170;
		  /* 8226A170h */ case    4:  		/* lis R11, -32252 */
		/* 8226A170h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8226A170h case    4:*/		return 0x8226A174;
		  /* 8226A174h */ case    5:  		/* addi R4, R11, -23680 */
		/* 8226A174h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFA380);
		/* 8226A174h case    5:*/		return 0x8226A178;
		  /* 8226A178h */ case    6:  		/* b 8 */
		/* 8226A178h case    6:*/		return 0x8226A180;
		/* 8226A178h case    6:*/		return 0x8226A17C;
	}
	return 0x8226A17C;
} // Block from 8226A160h-8226A17Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 8226A17Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A17C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A17C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A17C);
		  /* 8226A17Ch */ case    0:  		/* mr R4, R30 */
		/* 8226A17Ch case    0:*/		regs.R4 = regs.R30;
		/* 8226A17Ch case    0:*/		return 0x8226A180;
	}
	return 0x8226A180;
} // Block from 8226A17Ch-8226A180h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226A180h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A180( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A180) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A180);
		  /* 8226A180h */ case    0:  		/* mr R3, R31 */
		/* 8226A180h case    0:*/		regs.R3 = regs.R31;
		/* 8226A180h case    0:*/		return 0x8226A184;
		  /* 8226A184h */ case    1:  		/* bl -1956 */
		/* 8226A184h case    1:*/		regs.LR = 0x8226A188; return 0x822699E0;
		/* 8226A184h case    1:*/		return 0x8226A188;
	}
	return 0x8226A188;
} // Block from 8226A180h-8226A188h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226A188h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A188( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A188) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A188);
		  /* 8226A188h */ case    0:  		/* cmplwi CR6, R25, 0 */
		/* 8226A188h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 8226A188h case    0:*/		return 0x8226A18C;
		  /* 8226A18Ch */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 8226A18Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8226A19C;  }
		/* 8226A18Ch case    1:*/		return 0x8226A190;
	}
	return 0x8226A190;
} // Block from 8226A188h-8226A190h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226A190h
// Function '_frnd'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A190( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A190) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A190);
		  /* 8226A190h */ case    0:  		/* lis R11, -32252 */
		/* 8226A190h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8226A190h case    0:*/		return 0x8226A194;
		  /* 8226A194h */ case    1:  		/* addi R4, R11, -23684 */
		/* 8226A194h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFA37C);
		/* 8226A194h case    1:*/		return 0x8226A198;
		  /* 8226A198h */ case    2:  		/* b 16 */
		/* 8226A198h case    2:*/		return 0x8226A1A8;
		/* 8226A198h case    2:*/		return 0x8226A19C;
	}
	return 0x8226A19C;
} // Block from 8226A190h-8226A19Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8226A19Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A19C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A19C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A19C);
		  /* 8226A19Ch */ case    0:  		/* cmpwi CR6, R21, 0 */
		/* 8226A19Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R21,0x00000000);
		/* 8226A19Ch case    0:*/		return 0x8226A1A0;
		  /* 8226A1A0h */ case    1:  		/* bc 12, CR6_EQ, 16 */
		/* 8226A1A0h case    1:*/		if ( regs.CR[6].eq ) { return 0x8226A1B0;  }
		/* 8226A1A0h case    1:*/		return 0x8226A1A4;
		  /* 8226A1A4h */ case    2:  		/* mr R4, R29 */
		/* 8226A1A4h case    2:*/		regs.R4 = regs.R29;
		/* 8226A1A4h case    2:*/		return 0x8226A1A8;
	}
	return 0x8226A1A8;
} // Block from 8226A19Ch-8226A1A8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8226A1A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A1A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A1A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A1A8);
		  /* 8226A1A8h */ case    0:  		/* mr R3, R31 */
		/* 8226A1A8h case    0:*/		regs.R3 = regs.R31;
		/* 8226A1A8h case    0:*/		return 0x8226A1AC;
		  /* 8226A1ACh */ case    1:  		/* bl -1996 */
		/* 8226A1ACh case    1:*/		regs.LR = 0x8226A1B0; return 0x822699E0;
		/* 8226A1ACh case    1:*/		return 0x8226A1B0;
	}
	return 0x8226A1B0;
} // Block from 8226A1A8h-8226A1B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226A1B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A1B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A1B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A1B0);
		  /* 8226A1B0h */ case    0:  		/* lwz R29, <#[R1 + 340]> */
		/* 8226A1B0h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000154) );
		/* 8226A1B0h case    0:*/		return 0x8226A1B4;
		  /* 8226A1B4h */ case    1:  		/* cmpwi CR6, R29, 4 */
		/* 8226A1B4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000004);
		/* 8226A1B4h case    1:*/		return 0x8226A1B8;
		  /* 8226A1B8h */ case    2:  		/* bc 4, CR6_LT, 108 */
		/* 8226A1B8h case    2:*/		if ( !regs.CR[6].lt ) { return 0x8226A224;  }
		/* 8226A1B8h case    2:*/		return 0x8226A1BC;
		  /* 8226A1BCh */ case    3:  		/* lis R11, -32256 */
		/* 8226A1BCh case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8226A1BCh case    3:*/		return 0x8226A1C0;
		  /* 8226A1C0h */ case    4:  		/* mr R3, R31 */
		/* 8226A1C0h case    4:*/		regs.R3 = regs.R31;
		/* 8226A1C0h case    4:*/		return 0x8226A1C4;
		  /* 8226A1C4h */ case    5:  		/* addi R4, R11, 20592 */
		/* 8226A1C4h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x5070);
		/* 8226A1C4h case    5:*/		return 0x8226A1C8;
		  /* 8226A1C8h */ case    6:  		/* bl -2024 */
		/* 8226A1C8h case    6:*/		regs.LR = 0x8226A1CC; return 0x822699E0;
		/* 8226A1C8h case    6:*/		return 0x8226A1CC;
		  /* 8226A1CCh */ case    7:  		/* srawi R11, R28, 6 */
		/* 8226A1CCh case    7:*/		cpu::op::srawi<0,6>(regs,&regs.R11,regs.R28);
		/* 8226A1CCh case    7:*/		return 0x8226A1D0;
		  /* 8226A1D0h */ case    8:  		/* lis R10, -32255 */
		/* 8226A1D0h case    8:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 8226A1D0h case    8:*/		return 0x8226A1D4;
		  /* 8226A1D4h */ case    9:  		/* addi R11, R11, -1 */
		/* 8226A1D4h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8226A1D4h case    9:*/		return 0x8226A1D8;
		  /* 8226A1D8h */ case   10:  		/* addi R30, R10, 12500 */
		/* 8226A1D8h case   10:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R10,0x30D4);
		/* 8226A1D8h case   10:*/		return 0x8226A1DC;
		  /* 8226A1DCh */ case   11:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 8226A1DCh case   11:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 8226A1DCh case   11:*/		return 0x8226A1E0;
	}
	return 0x8226A1E0;
} // Block from 8226A1B0h-8226A1E0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8226A1E0h
// Function '_NLG_Notify'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A1E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A1E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A1E0);
		  /* 8226A1E0h */ case    0:  		/* mr R4, R26 */
		/* 8226A1E0h case    0:*/		regs.R4 = regs.R26;
		/* 8226A1E0h case    0:*/		return 0x8226A1E4;
		  /* 8226A1E4h */ case    1:  		/* mr R3, R31 */
		/* 8226A1E4h case    1:*/		regs.R3 = regs.R31;
		/* 8226A1E4h case    1:*/		return 0x8226A1E8;
		  /* 8226A1E8h */ case    2:  		/* lbzx R11, <#[R11 + R30]> */
		/* 8226A1E8h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 8226A1E8h case    2:*/		return 0x8226A1EC;
		  /* 8226A1ECh */ case    3:  		/* extsb R5, R11 */
		/* 8226A1ECh case    3:*/		cpu::op::extsb<0>(regs,&regs.R5,regs.R11);
		/* 8226A1ECh case    3:*/		return 0x8226A1F0;
		  /* 8226A1F0h */ case    4:  		/* bl -2064 */
		/* 8226A1F0h case    4:*/		regs.LR = 0x8226A1F4; return 0x822699E0;
		/* 8226A1F0h case    4:*/		return 0x8226A1F4;
		  /* 8226A1F4h */ case    5:  		/* cmpwi CR6, R29, 1 */
		/* 8226A1F4h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R29,0x00000001);
		/* 8226A1F4h case    5:*/		return 0x8226A1F8;
		  /* 8226A1F8h */ case    6:  		/* bc 4, CR6_GT, 244 */
		/* 8226A1F8h case    6:*/		if ( !regs.CR[6].gt ) { return 0x8226A2EC;  }
		/* 8226A1F8h case    6:*/		return 0x8226A1FC;
		  /* 8226A1FCh */ case    7:  		/* lbz R11, <#[R1 + 351]> */
		/* 8226A1FCh case    7:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000015F) );
		/* 8226A1FCh case    7:*/		return 0x8226A200;
	}
	return 0x8226A200;
} // Block from 8226A1E0h-8226A200h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8226A200h
// Function '__u64tod'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A200( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A200) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A200);
		  /* 8226A200h */ case    0:  		/* cmplwi CR0, R11, 0 */
		/* 8226A200h case    0:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8226A200h case    0:*/		return 0x8226A204;
		  /* 8226A204h */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 8226A204h case    1:*/		if ( regs.CR[0].eq ) { return 0x8226A218;  }
		/* 8226A204h case    1:*/		return 0x8226A208;
		  /* 8226A208h */ case    2:  		/* srawi R11, R28, 4 */
		/* 8226A208h case    2:*/		cpu::op::srawi<0,4>(regs,&regs.R11,regs.R28);
		/* 8226A208h case    2:*/		return 0x8226A20C;
		  /* 8226A20Ch */ case    3:  		/* addi R11, R11, -2 */
		/* 8226A20Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFE);
		/* 8226A20Ch case    3:*/		return 0x8226A210;
		  /* 8226A210h */ case    4:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 8226A210h case    4:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 8226A210h case    4:*/		return 0x8226A214;
		  /* 8226A214h */ case    5:  		/* b 8 */
		/* 8226A214h case    5:*/		return 0x8226A21C;
		/* 8226A214h case    5:*/		return 0x8226A218;
	}
	return 0x8226A218;
} // Block from 8226A200h-8226A218h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8226A218h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A218( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A218) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A218);
		  /* 8226A218h */ case    0:  		/* rlwinm R11, R28, 0, 30, 31 */
		/* 8226A218h case    0:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R28);
		/* 8226A218h case    0:*/		return 0x8226A21C;
	}
	return 0x8226A21C;
} // Block from 8226A218h-8226A21Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226A21Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A21C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A21C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A21C);
		  /* 8226A21Ch */ case    0:  		/* lbzx R11, <#[R11 + R30]> */
		/* 8226A21Ch case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 8226A21Ch case    0:*/		return 0x8226A220;
		  /* 8226A220h */ case    1:  		/* b 188 */
		/* 8226A220h case    1:*/		return 0x8226A2DC;
		/* 8226A220h case    1:*/		return 0x8226A224;
	}
	return 0x8226A224;
} // Block from 8226A21Ch-8226A224h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226A224h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A224( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A224) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A224);
		  /* 8226A224h */ case    0:  		/* cmpwi CR6, R28, 0 */
		/* 8226A224h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R28,0x00000000);
		/* 8226A224h case    0:*/		return 0x8226A228;
		  /* 8226A228h */ case    1:  		/* bc 12, CR6_EQ, 196 */
		/* 8226A228h case    1:*/		if ( regs.CR[6].eq ) { return 0x8226A2EC;  }
		/* 8226A228h case    1:*/		return 0x8226A22C;
		  /* 8226A22Ch */ case    2:  		/* lis R11, -32256 */
		/* 8226A22Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8226A22Ch case    2:*/		return 0x8226A230;
	}
	return 0x8226A230;
} // Block from 8226A224h-8226A230h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8226A230h
// Function '__savevmx'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A230( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A230) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A230);
		  /* 8226A230h */ case    0:  		/* mr R3, R31 */
		/* 8226A230h case    0:*/		regs.R3 = regs.R31;
		/* 8226A230h case    0:*/		return 0x8226A234;
		  /* 8226A234h */ case    1:  		/* addi R4, R11, 20592 */
		/* 8226A234h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x5070);
		/* 8226A234h case    1:*/		return 0x8226A238;
		  /* 8226A238h */ case    2:  		/* bl -2136 */
		/* 8226A238h case    2:*/		regs.LR = 0x8226A23C; return 0x822699E0;
		/* 8226A238h case    2:*/		return 0x8226A23C;
		  /* 8226A23Ch */ case    3:  		/* lis R11, -32255 */
		/* 8226A23Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8226A23Ch case    3:*/		return 0x8226A240;
		  /* 8226A240h */ case    4:  		/* srawi R9, R28, 2 */
		/* 8226A240h case    4:*/		cpu::op::srawi<0,2>(regs,&regs.R9,regs.R28);
		/* 8226A240h case    4:*/		return 0x8226A244;
		  /* 8226A244h */ case    5:  		/* addi R29, R11, 12500 */
		/* 8226A244h case    5:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x30D4);
		/* 8226A244h case    5:*/		return 0x8226A248;
		  /* 8226A248h */ case    6:  		/* srawi R10, R28, 4 */
		/* 8226A248h case    6:*/		cpu::op::srawi<0,4>(regs,&regs.R10,regs.R28);
		/* 8226A248h case    6:*/		return 0x8226A24C;
		  /* 8226A24Ch */ case    7:  		/* srawi R11, R28, 6 */
		/* 8226A24Ch case    7:*/		cpu::op::srawi<0,6>(regs,&regs.R11,regs.R28);
		/* 8226A24Ch case    7:*/		return 0x8226A250;
		  /* 8226A250h */ case    8:  		/* rlwinm R30, R28, 0, 30, 31 */
		/* 8226A250h case    8:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R30,regs.R28);
		/* 8226A250h case    8:*/		return 0x8226A254;
		  /* 8226A254h */ case    9:  		/* addi R11, R11, -1 */
		/* 8226A254h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8226A254h case    9:*/		return 0x8226A258;
		  /* 8226A258h */ case   10:  		/* addi R9, R9, 1 */
		/* 8226A258h case   10:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 8226A258h case   10:*/		return 0x8226A25C;
		  /* 8226A25Ch */ case   11:  		/* rlwinm R25, R11, 0, 30, 31 */
		/* 8226A25Ch case   11:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R25,regs.R11);
		/* 8226A25Ch case   11:*/		return 0x8226A260;
		  /* 8226A260h */ case   12:  		/* addi R10, R10, -2 */
		/* 8226A260h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFE);
		/* 8226A260h case   12:*/		return 0x8226A264;
		  /* 8226A264h */ case   13:  		/* mr R4, R26 */
		/* 8226A264h case   13:*/		regs.R4 = regs.R26;
		/* 8226A264h case   13:*/		return 0x8226A268;
		  /* 8226A268h */ case   14:  		/* mr R3, R31 */
		/* 8226A268h case   14:*/		regs.R3 = regs.R31;
		/* 8226A268h case   14:*/		return 0x8226A26C;
		  /* 8226A26Ch */ case   15:  		/* rlwinm R28, R9, 0, 30, 31 */
		/* 8226A26Ch case   15:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R28,regs.R9);
		/* 8226A26Ch case   15:*/		return 0x8226A270;
		  /* 8226A270h */ case   16:  		/* rlwinm R27, R10, 0, 30, 31 */
		/* 8226A270h case   16:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R27,regs.R10);
		/* 8226A270h case   16:*/		return 0x8226A274;
		  /* 8226A274h */ case   17:  		/* lbzx R11, <#[R30 + R29]> */
		/* 8226A274h case   17:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R30 + regs.R29 + 0x00000000) );
		/* 8226A274h case   17:*/		return 0x8226A278;
		  /* 8226A278h */ case   18:  		/* extsb R5, R11 */
		/* 8226A278h case   18:*/		cpu::op::extsb<0>(regs,&regs.R5,regs.R11);
		/* 8226A278h case   18:*/		return 0x8226A27C;
		  /* 8226A27Ch */ case   19:  		/* bl -2204 */
		/* 8226A27Ch case   19:*/		regs.LR = 0x8226A280; return 0x822699E0;
		/* 8226A27Ch case   19:*/		return 0x8226A280;
		  /* 8226A280h */ case   20:  		/* cmpw CR6, R28, R30 */
		/* 8226A280h case   20:*/		cpu::op::cmpw<6>(regs,regs.R28,regs.R30);
		/* 8226A280h case   20:*/		return 0x8226A284;
		  /* 8226A284h */ case   21:  		/* bc 4, CR6_EQ, 20 */
		/* 8226A284h case   21:*/		if ( !regs.CR[6].eq ) { return 0x8226A298;  }
		/* 8226A284h case   21:*/		return 0x8226A288;
		  /* 8226A288h */ case   22:  		/* cmpw CR6, R27, R30 */
		/* 8226A288h case   22:*/		cpu::op::cmpw<6>(regs,regs.R27,regs.R30);
		/* 8226A288h case   22:*/		return 0x8226A28C;
		  /* 8226A28Ch */ case   23:  		/* bc 4, CR6_EQ, 12 */
		/* 8226A28Ch case   23:*/		if ( !regs.CR[6].eq ) { return 0x8226A298;  }
		/* 8226A28Ch case   23:*/		return 0x8226A290;
		  /* 8226A290h */ case   24:  		/* cmpw CR6, R25, R30 */
		/* 8226A290h case   24:*/		cpu::op::cmpw<6>(regs,regs.R25,regs.R30);
		/* 8226A290h case   24:*/		return 0x8226A294;
		  /* 8226A294h */ case   25:  		/* bc 12, CR6_EQ, 88 */
		/* 8226A294h case   25:*/		if ( regs.CR[6].eq ) { return 0x8226A2EC;  }
		/* 8226A294h case   25:*/		return 0x8226A298;
	}
	return 0x8226A298;
} // Block from 8226A230h-8226A298h (26 instructions)

//////////////////////////////////////////////////////
// Block at 8226A298h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A298( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A298) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A298);
		  /* 8226A298h */ case    0:  		/* lbzx R11, <#[R28 + R29]> */
		/* 8226A298h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R28 + regs.R29 + 0x00000000) );
		/* 8226A298h case    0:*/		return 0x8226A29C;
		  /* 8226A29Ch */ case    1:  		/* mr R4, R26 */
		/* 8226A29Ch case    1:*/		regs.R4 = regs.R26;
		/* 8226A29Ch case    1:*/		return 0x8226A2A0;
		  /* 8226A2A0h */ case    2:  		/* mr R3, R31 */
		/* 8226A2A0h case    2:*/		regs.R3 = regs.R31;
		/* 8226A2A0h case    2:*/		return 0x8226A2A4;
		  /* 8226A2A4h */ case    3:  		/* extsb R5, R11 */
		/* 8226A2A4h case    3:*/		cpu::op::extsb<0>(regs,&regs.R5,regs.R11);
		/* 8226A2A4h case    3:*/		return 0x8226A2A8;
		  /* 8226A2A8h */ case    4:  		/* bl -2248 */
		/* 8226A2A8h case    4:*/		regs.LR = 0x8226A2AC; return 0x822699E0;
		/* 8226A2A8h case    4:*/		return 0x8226A2AC;
		  /* 8226A2ACh */ case    5:  		/* cmpw CR6, R27, R28 */
		/* 8226A2ACh case    5:*/		cpu::op::cmpw<6>(regs,regs.R27,regs.R28);
		/* 8226A2ACh case    5:*/		return 0x8226A2B0;
		  /* 8226A2B0h */ case    6:  		/* bc 4, CR6_EQ, 12 */
		/* 8226A2B0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8226A2BC;  }
		/* 8226A2B0h case    6:*/		return 0x8226A2B4;
		  /* 8226A2B4h */ case    7:  		/* cmpw CR6, R25, R28 */
		/* 8226A2B4h case    7:*/		cpu::op::cmpw<6>(regs,regs.R25,regs.R28);
		/* 8226A2B4h case    7:*/		return 0x8226A2B8;
		  /* 8226A2B8h */ case    8:  		/* bc 12, CR6_EQ, 52 */
		/* 8226A2B8h case    8:*/		if ( regs.CR[6].eq ) { return 0x8226A2EC;  }
		/* 8226A2B8h case    8:*/		return 0x8226A2BC;
	}
	return 0x8226A2BC;
} // Block from 8226A298h-8226A2BCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 8226A2BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A2BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A2BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A2BC);
		  /* 8226A2BCh */ case    0:  		/* lbzx R11, <#[R27 + R29]> */
		/* 8226A2BCh case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R27 + regs.R29 + 0x00000000) );
		/* 8226A2BCh case    0:*/		return 0x8226A2C0;
		  /* 8226A2C0h */ case    1:  		/* mr R4, R26 */
		/* 8226A2C0h case    1:*/		regs.R4 = regs.R26;
		/* 8226A2C0h case    1:*/		return 0x8226A2C4;
		  /* 8226A2C4h */ case    2:  		/* mr R3, R31 */
		/* 8226A2C4h case    2:*/		regs.R3 = regs.R31;
		/* 8226A2C4h case    2:*/		return 0x8226A2C8;
		  /* 8226A2C8h */ case    3:  		/* extsb R5, R11 */
		/* 8226A2C8h case    3:*/		cpu::op::extsb<0>(regs,&regs.R5,regs.R11);
		/* 8226A2C8h case    3:*/		return 0x8226A2CC;
		  /* 8226A2CCh */ case    4:  		/* bl -2284 */
		/* 8226A2CCh case    4:*/		regs.LR = 0x8226A2D0; return 0x822699E0;
		/* 8226A2CCh case    4:*/		return 0x8226A2D0;
		  /* 8226A2D0h */ case    5:  		/* cmpw CR6, R25, R27 */
		/* 8226A2D0h case    5:*/		cpu::op::cmpw<6>(regs,regs.R25,regs.R27);
		/* 8226A2D0h case    5:*/		return 0x8226A2D4;
		  /* 8226A2D4h */ case    6:  		/* bc 12, CR6_EQ, 24 */
		/* 8226A2D4h case    6:*/		if ( regs.CR[6].eq ) { return 0x8226A2EC;  }
		/* 8226A2D4h case    6:*/		return 0x8226A2D8;
		  /* 8226A2D8h */ case    7:  		/* lbzx R11, <#[R25 + R29]> */
		/* 8226A2D8h case    7:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R25 + regs.R29 + 0x00000000) );
		/* 8226A2D8h case    7:*/		return 0x8226A2DC;
	}
	return 0x8226A2DC;
} // Block from 8226A2BCh-8226A2DCh (8 instructions)

//////////////////////////////////////////////////////
// Block at 8226A2DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A2DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A2DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A2DC);
		  /* 8226A2DCh */ case    0:  		/* extsb R5, R11 */
		/* 8226A2DCh case    0:*/		cpu::op::extsb<0>(regs,&regs.R5,regs.R11);
		/* 8226A2DCh case    0:*/		return 0x8226A2E0;
		  /* 8226A2E0h */ case    1:  		/* mr R4, R26 */
		/* 8226A2E0h case    1:*/		regs.R4 = regs.R26;
		/* 8226A2E0h case    1:*/		return 0x8226A2E4;
		  /* 8226A2E4h */ case    2:  		/* mr R3, R31 */
		/* 8226A2E4h case    2:*/		regs.R3 = regs.R31;
		/* 8226A2E4h case    2:*/		return 0x8226A2E8;
		  /* 8226A2E8h */ case    3:  		/* bl -2312 */
		/* 8226A2E8h case    3:*/		regs.LR = 0x8226A2EC; return 0x822699E0;
		/* 8226A2E8h case    3:*/		return 0x8226A2EC;
	}
	return 0x8226A2EC;
} // Block from 8226A2DCh-8226A2ECh (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226A2ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A2EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A2EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A2EC);
		  /* 8226A2ECh */ case    0:  		/* addi R1, R1, 256 */
		/* 8226A2ECh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x100);
		/* 8226A2ECh case    0:*/		return 0x8226A2F0;
		  /* 8226A2F0h */ case    1:  		/* b -1937508 */
		/* 8226A2F0h case    1:*/		return 0x8209128C;
		/* 8226A2F0h case    1:*/		return 0x8226A2F4;
		  /* 8226A2F4h */ case    2:  		/* nop */
		/* 8226A2F4h case    2:*/		cpu::op::nop();
		/* 8226A2F4h case    2:*/		return 0x8226A2F8;
	}
	return 0x8226A2F8;
} // Block from 8226A2ECh-8226A2F8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8226A2F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A2F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A2F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A2F8);
		  /* 8226A2F8h */ case    0:  		/* mfspr R12, LR */
		/* 8226A2F8h case    0:*/		regs.R12 = regs.LR;
		/* 8226A2F8h case    0:*/		return 0x8226A2FC;
		  /* 8226A2FCh */ case    1:  		/* bl -1937576 */
		/* 8226A2FCh case    1:*/		regs.LR = 0x8226A300; return 0x82091254;
		/* 8226A2FCh case    1:*/		return 0x8226A300;
		  /* 8226A300h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 8226A300h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 8226A300h case    2:*/		return 0x8226A304;
		  /* 8226A304h */ case    3:  		/* srawi R11, R4, 7 */
		/* 8226A304h case    3:*/		cpu::op::srawi<0,7>(regs,&regs.R11,regs.R4);
		/* 8226A304h case    3:*/		return 0x8226A308;
		  /* 8226A308h */ case    4:  		/* mr R31, R3 */
		/* 8226A308h case    4:*/		regs.R31 = regs.R3;
		/* 8226A308h case    4:*/		return 0x8226A30C;
		  /* 8226A30Ch */ case    5:  		/* mr R30, R6 */
		/* 8226A30Ch case    5:*/		regs.R30 = regs.R6;
		/* 8226A30Ch case    5:*/		return 0x8226A310;
		  /* 8226A310h */ case    6:  		/* rlwinm R28, R4, 0, 26, 31 */
		/* 8226A310h case    6:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R28,regs.R4);
		/* 8226A310h case    6:*/		return 0x8226A314;
		  /* 8226A314h */ case    7:  		/* rlwinm R27, R11, 0, 31, 31 */
		/* 8226A314h case    7:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R27,regs.R11);
		/* 8226A314h case    7:*/		return 0x8226A318;
		  /* 8226A318h */ case    8:  		/* cmpwi CR6, R5, 0 */
		/* 8226A318h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 8226A318h case    8:*/		return 0x8226A31C;
		  /* 8226A31Ch */ case    9:  		/* bc 12, CR6_EQ, 16 */
		/* 8226A31Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x8226A32C;  }
		/* 8226A31Ch case    9:*/		return 0x8226A320;
		  /* 8226A320h */ case   10:  		/* lis R11, -32255 */
		/* 8226A320h case   10:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8226A320h case   10:*/		return 0x8226A324;
		  /* 8226A324h */ case   11:  		/* addi R4, R11, -16532 */
		/* 8226A324h case   11:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFBF6C);
		/* 8226A324h case   11:*/		return 0x8226A328;
		  /* 8226A328h */ case   12:  		/* bl -2376 */
		/* 8226A328h case   12:*/		regs.LR = 0x8226A32C; return 0x822699E0;
		/* 8226A328h case   12:*/		return 0x8226A32C;
	}
	return 0x8226A32C;
} // Block from 8226A2F8h-8226A32Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8226A32Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A32C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A32C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A32C);
		  /* 8226A32Ch */ case    0:  		/* lis R11, -32255 */
		/* 8226A32Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8226A32Ch case    0:*/		return 0x8226A330;
		  /* 8226A330h */ case    1:  		/* cmpwi CR6, R27, 0 */
		/* 8226A330h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 8226A330h case    1:*/		return 0x8226A334;
		  /* 8226A334h */ case    2:  		/* addi R29, R11, -16588 */
		/* 8226A334h case    2:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0xFFFFBF34);
		/* 8226A334h case    2:*/		return 0x8226A338;
		  /* 8226A338h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 8226A338h case    3:*/		if ( regs.CR[6].eq ) { return 0x8226A348;  }
		/* 8226A338h case    3:*/		return 0x8226A33C;
		  /* 8226A33Ch */ case    4:  		/* mr R4, R29 */
		/* 8226A33Ch case    4:*/		regs.R4 = regs.R29;
		/* 8226A33Ch case    4:*/		return 0x8226A340;
		  /* 8226A340h */ case    5:  		/* mr R3, R31 */
		/* 8226A340h case    5:*/		regs.R3 = regs.R31;
		/* 8226A340h case    5:*/		return 0x8226A344;
		  /* 8226A344h */ case    6:  		/* bl -2404 */
		/* 8226A344h case    6:*/		regs.LR = 0x8226A348; return 0x822699E0;
		/* 8226A344h case    6:*/		return 0x8226A348;
	}
	return 0x8226A348;
} // Block from 8226A32Ch-8226A348h (7 instructions)

//////////////////////////////////////////////////////
// Block at 8226A348h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A348( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A348) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A348);
		  /* 8226A348h */ case    0:  		/* lis R11, -32252 */
		/* 8226A348h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8226A348h case    0:*/		return 0x8226A34C;
		  /* 8226A34Ch */ case    1:  		/* mr R5, R28 */
		/* 8226A34Ch case    1:*/		regs.R5 = regs.R28;
		/* 8226A34Ch case    1:*/		return 0x8226A350;
		  /* 8226A350h */ case    2:  		/* addi R4, R11, -23644 */
		/* 8226A350h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFA3A4);
		/* 8226A350h case    2:*/		return 0x8226A354;
		  /* 8226A354h */ case    3:  		/* mr R3, R31 */
		/* 8226A354h case    3:*/		regs.R3 = regs.R31;
		/* 8226A354h case    3:*/		return 0x8226A358;
		  /* 8226A358h */ case    4:  		/* bl -2424 */
		/* 8226A358h case    4:*/		regs.LR = 0x8226A35C; return 0x822699E0;
		/* 8226A358h case    4:*/		return 0x8226A35C;
		  /* 8226A35Ch */ case    5:  		/* lis R11, -32252 */
		/* 8226A35Ch case    5:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8226A35Ch case    5:*/		return 0x8226A360;
		  /* 8226A360h */ case    6:  		/* mr R3, R31 */
		/* 8226A360h case    6:*/		regs.R3 = regs.R31;
		/* 8226A360h case    6:*/		return 0x8226A364;
		  /* 8226A364h */ case    7:  		/* addi R4, R11, -23684 */
		/* 8226A364h case    7:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFA37C);
		/* 8226A364h case    7:*/		return 0x8226A368;
		  /* 8226A368h */ case    8:  		/* bl -2440 */
		/* 8226A368h case    8:*/		regs.LR = 0x8226A36C; return 0x822699E0;
		/* 8226A368h case    8:*/		return 0x8226A36C;
		  /* 8226A36Ch */ case    9:  		/* cmpwi CR6, R30, 0 */
		/* 8226A36Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000000);
		/* 8226A36Ch case    9:*/		return 0x8226A370;
		  /* 8226A370h */ case   10:  		/* bc 12, CR6_EQ, 168 */
		/* 8226A370h case   10:*/		if ( regs.CR[6].eq ) { return 0x8226A418;  }
		/* 8226A370h case   10:*/		return 0x8226A374;
		  /* 8226A374h */ case   11:  		/* lis R11, -32256 */
		/* 8226A374h case   11:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8226A374h case   11:*/		return 0x8226A378;
		  /* 8226A378h */ case   12:  		/* mr R3, R31 */
		/* 8226A378h case   12:*/		regs.R3 = regs.R31;
		/* 8226A378h case   12:*/		return 0x8226A37C;
		  /* 8226A37Ch */ case   13:  		/* addi R4, R11, 20592 */
		/* 8226A37Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x5070);
		/* 8226A37Ch case   13:*/		return 0x8226A380;
		  /* 8226A380h */ case   14:  		/* bl -2464 */
		/* 8226A380h case   14:*/		regs.LR = 0x8226A384; return 0x822699E0;
		/* 8226A380h case   14:*/		return 0x8226A384;
		  /* 8226A384h */ case   15:  		/* lis R11, -32255 */
		/* 8226A384h case   15:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8226A384h case   15:*/		return 0x8226A388;
		  /* 8226A388h */ case   16:  		/* rlwinm R10, R30, 0, 30, 31 */
		/* 8226A388h case   16:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R10,regs.R30);
		/* 8226A388h case   16:*/		return 0x8226A38C;
		  /* 8226A38Ch */ case   17:  		/* addi R11, R11, 12500 */
		/* 8226A38Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x30D4);
		/* 8226A38Ch case   17:*/		return 0x8226A390;
		  /* 8226A390h */ case   18:  		/* lis R9, -32253 */
		/* 8226A390h case   18:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8203);
		/* 8226A390h case   18:*/		return 0x8226A394;
		  /* 8226A394h */ case   19:  		/* mr R3, R31 */
		/* 8226A394h case   19:*/		regs.R3 = regs.R31;
		/* 8226A394h case   19:*/		return 0x8226A398;
		  /* 8226A398h */ case   20:  		/* addi R28, R9, 25796 */
		/* 8226A398h case   20:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R9,0x64C4);
		/* 8226A398h case   20:*/		return 0x8226A39C;
		  /* 8226A39Ch */ case   21:  		/* mr R4, R28 */
		/* 8226A39Ch case   21:*/		regs.R4 = regs.R28;
		/* 8226A39Ch case   21:*/		return 0x8226A3A0;
		  /* 8226A3A0h */ case   22:  		/* lbzx R11, <#[R10 + R11]> */
		/* 8226A3A0h case   22:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8226A3A0h case   22:*/		return 0x8226A3A4;
		  /* 8226A3A4h */ case   23:  		/* extsb R5, R11 */
		/* 8226A3A4h case   23:*/		cpu::op::extsb<0>(regs,&regs.R5,regs.R11);
		/* 8226A3A4h case   23:*/		return 0x8226A3A8;
		  /* 8226A3A8h */ case   24:  		/* bl -2504 */
		/* 8226A3A8h case   24:*/		regs.LR = 0x8226A3AC; return 0x822699E0;
		/* 8226A3A8h case   24:*/		return 0x8226A3AC;
		  /* 8226A3ACh */ case   25:  		/* srawi R11, R30, 2 */
		/* 8226A3ACh case   25:*/		cpu::op::srawi<0,2>(regs,&regs.R11,regs.R30);
		/* 8226A3ACh case   25:*/		return 0x8226A3B0;
		  /* 8226A3B0h */ case   26:  		/* lis R10, -32252 */
		/* 8226A3B0h case   26:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8226A3B0h case   26:*/		return 0x8226A3B4;
		  /* 8226A3B4h */ case   27:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 8226A3B4h case   27:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 8226A3B4h case   27:*/		return 0x8226A3B8;
		  /* 8226A3B8h */ case   28:  		/* addi R10, R10, -23652 */
		/* 8226A3B8h case   28:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFA39C);
		/* 8226A3B8h case   28:*/		return 0x8226A3BC;
		  /* 8226A3BCh */ case   29:  		/* mr R4, R28 */
		/* 8226A3BCh case   29:*/		regs.R4 = regs.R28;
		/* 8226A3BCh case   29:*/		return 0x8226A3C0;
		  /* 8226A3C0h */ case   30:  		/* mr R3, R31 */
		/* 8226A3C0h case   30:*/		regs.R3 = regs.R31;
		/* 8226A3C0h case   30:*/		return 0x8226A3C4;
		  /* 8226A3C4h */ case   31:  		/* lbzx R11, <#[R11 + R10]> */
		/* 8226A3C4h case   31:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8226A3C4h case   31:*/		return 0x8226A3C8;
		  /* 8226A3C8h */ case   32:  		/* extsb R5, R11 */
		/* 8226A3C8h case   32:*/		cpu::op::extsb<0>(regs,&regs.R5,regs.R11);
		/* 8226A3C8h case   32:*/		return 0x8226A3CC;
		  /* 8226A3CCh */ case   33:  		/* bl -2540 */
		/* 8226A3CCh case   33:*/		regs.LR = 0x8226A3D0; return 0x822699E0;
		/* 8226A3CCh case   33:*/		return 0x8226A3D0;
		  /* 8226A3D0h */ case   34:  		/* srawi R11, R30, 4 */
		/* 8226A3D0h case   34:*/		cpu::op::srawi<0,4>(regs,&regs.R11,regs.R30);
		/* 8226A3D0h case   34:*/		return 0x8226A3D4;
		  /* 8226A3D4h */ case   35:  		/* lis R10, -32252 */
		/* 8226A3D4h case   35:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8226A3D4h case   35:*/		return 0x8226A3D8;
		  /* 8226A3D8h */ case   36:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 8226A3D8h case   36:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 8226A3D8h case   36:*/		return 0x8226A3DC;
		  /* 8226A3DCh */ case   37:  		/* addi R10, R10, -23660 */
		/* 8226A3DCh case   37:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFA394);
		/* 8226A3DCh case   37:*/		return 0x8226A3E0;
		  /* 8226A3E0h */ case   38:  		/* mr R4, R28 */
		/* 8226A3E0h case   38:*/		regs.R4 = regs.R28;
		/* 8226A3E0h case   38:*/		return 0x8226A3E4;
		  /* 8226A3E4h */ case   39:  		/* mr R3, R31 */
		/* 8226A3E4h case   39:*/		regs.R3 = regs.R31;
		/* 8226A3E4h case   39:*/		return 0x8226A3E8;
		  /* 8226A3E8h */ case   40:  		/* lbzx R11, <#[R11 + R10]> */
		/* 8226A3E8h case   40:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8226A3E8h case   40:*/		return 0x8226A3EC;
		  /* 8226A3ECh */ case   41:  		/* extsb R5, R11 */
		/* 8226A3ECh case   41:*/		cpu::op::extsb<0>(regs,&regs.R5,regs.R11);
		/* 8226A3ECh case   41:*/		return 0x8226A3F0;
		  /* 8226A3F0h */ case   42:  		/* bl -2576 */
		/* 8226A3F0h case   42:*/		regs.LR = 0x8226A3F4; return 0x822699E0;
		/* 8226A3F0h case   42:*/		return 0x8226A3F4;
		  /* 8226A3F4h */ case   43:  		/* srawi R11, R30, 6 */
		/* 8226A3F4h case   43:*/		cpu::op::srawi<0,6>(regs,&regs.R11,regs.R30);
		/* 8226A3F4h case   43:*/		return 0x8226A3F8;
		  /* 8226A3F8h */ case   44:  		/* lis R10, -32252 */
		/* 8226A3F8h case   44:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 8226A3F8h case   44:*/		return 0x8226A3FC;
		  /* 8226A3FCh */ case   45:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 8226A3FCh case   45:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 8226A3FCh case   45:*/		return 0x8226A400;
		  /* 8226A400h */ case   46:  		/* addi R10, R10, -23668 */
		/* 8226A400h case   46:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFA38C);
		/* 8226A400h case   46:*/		return 0x8226A404;
		  /* 8226A404h */ case   47:  		/* mr R4, R28 */
		/* 8226A404h case   47:*/		regs.R4 = regs.R28;
		/* 8226A404h case   47:*/		return 0x8226A408;
		  /* 8226A408h */ case   48:  		/* mr R3, R31 */
		/* 8226A408h case   48:*/		regs.R3 = regs.R31;
		/* 8226A408h case   48:*/		return 0x8226A40C;
		  /* 8226A40Ch */ case   49:  		/* lbzx R11, <#[R11 + R10]> */
		/* 8226A40Ch case   49:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8226A40Ch case   49:*/		return 0x8226A410;
		  /* 8226A410h */ case   50:  		/* extsb R5, R11 */
		/* 8226A410h case   50:*/		cpu::op::extsb<0>(regs,&regs.R5,regs.R11);
		/* 8226A410h case   50:*/		return 0x8226A414;
		  /* 8226A414h */ case   51:  		/* bl -2612 */
		/* 8226A414h case   51:*/		regs.LR = 0x8226A418; return 0x822699E0;
		/* 8226A414h case   51:*/		return 0x8226A418;
	}
	return 0x8226A418;
} // Block from 8226A348h-8226A418h (52 instructions)

//////////////////////////////////////////////////////
// Block at 8226A418h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A418( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A418) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A418);
		  /* 8226A418h */ case    0:  		/* cmpwi CR6, R27, 0 */
		/* 8226A418h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R27,0x00000000);
		/* 8226A418h case    0:*/		return 0x8226A41C;
		  /* 8226A41Ch */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 8226A41Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8226A428;  }
		/* 8226A41Ch case    1:*/		return 0x8226A420;
		  /* 8226A420h */ case    2:  		/* mr R4, R29 */
		/* 8226A420h case    2:*/		regs.R4 = regs.R29;
		/* 8226A420h case    2:*/		return 0x8226A424;
		  /* 8226A424h */ case    3:  		/* b 12 */
		/* 8226A424h case    3:*/		return 0x8226A430;
		/* 8226A424h case    3:*/		return 0x8226A428;
	}
	return 0x8226A428;
} // Block from 8226A418h-8226A428h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226A428h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A428( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A428) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A428);
		  /* 8226A428h */ case    0:  		/* lis R11, -32256 */
		/* 8226A428h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8226A428h case    0:*/		return 0x8226A42C;
		  /* 8226A42Ch */ case    1:  		/* addi R4, R11, 4485 */
		/* 8226A42Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x1185);
		/* 8226A42Ch case    1:*/		return 0x8226A430;
	}
	return 0x8226A430;
} // Block from 8226A428h-8226A430h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226A430h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A430( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A430) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A430);
		  /* 8226A430h */ case    0:  		/* mr R3, R31 */
		/* 8226A430h case    0:*/		regs.R3 = regs.R31;
		/* 8226A430h case    0:*/		return 0x8226A434;
		  /* 8226A434h */ case    1:  		/* bl -2644 */
		/* 8226A434h case    1:*/		regs.LR = 0x8226A438; return 0x822699E0;
		/* 8226A434h case    1:*/		return 0x8226A438;
		  /* 8226A438h */ case    2:  		/* addi R1, R1, 160 */
		/* 8226A438h case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 8226A438h case    2:*/		return 0x8226A43C;
		  /* 8226A43Ch */ case    3:  		/* b -1937816 */
		/* 8226A43Ch case    3:*/		return 0x820912A4;
		/* 8226A43Ch case    3:*/		return 0x8226A440;
	}
	return 0x8226A440;
} // Block from 8226A430h-8226A440h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226A440h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A440( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A440) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A440);
		  /* 8226A440h */ case    0:  		/* mfspr R12, LR */
		/* 8226A440h case    0:*/		regs.R12 = regs.LR;
		/* 8226A440h case    0:*/		return 0x8226A444;
		  /* 8226A444h */ case    1:  		/* bl -1937916 */
		/* 8226A444h case    1:*/		regs.LR = 0x8226A448; return 0x82091248;
		/* 8226A444h case    1:*/		return 0x8226A448;
		  /* 8226A448h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 8226A448h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 8226A448h case    2:*/		return 0x8226A44C;
		  /* 8226A44Ch */ case    3:  		/* mr R30, R3 */
		/* 8226A44Ch case    3:*/		regs.R30 = regs.R3;
		/* 8226A44Ch case    3:*/		return 0x8226A450;
		  /* 8226A450h */ case    4:  		/* li R26, 0 */
		/* 8226A450h case    4:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 8226A450h case    4:*/		return 0x8226A454;
		  /* 8226A454h */ case    5:  		/* mr R3, R4 */
		/* 8226A454h case    5:*/		regs.R3 = regs.R4;
		/* 8226A454h case    5:*/		return 0x8226A458;
		  /* 8226A458h */ case    6:  		/* mr R31, R4 */
		/* 8226A458h case    6:*/		regs.R31 = regs.R4;
		/* 8226A458h case    6:*/		return 0x8226A45C;
		  /* 8226A45Ch */ case    7:  		/* mr R24, R26 */
		/* 8226A45Ch case    7:*/		regs.R24 = regs.R26;
		/* 8226A45Ch case    7:*/		return 0x8226A460;
		  /* 8226A460h */ case    8:  		/* mr R25, R26 */
		/* 8226A460h case    8:*/		regs.R25 = regs.R26;
		/* 8226A460h case    8:*/		return 0x8226A464;
		  /* 8226A464h */ case    9:  		/* bl -3060 */
		/* 8226A464h case    9:*/		regs.LR = 0x8226A468; return 0x82269870;
		/* 8226A464h case    9:*/		return 0x8226A468;
		  /* 8226A468h */ case   10:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 8226A468h case   10:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 8226A468h case   10:*/		return 0x8226A46C;
		  /* 8226A46Ch */ case   11:  		/* bc 12, CR0_EQ, 28 */
		/* 8226A46Ch case   11:*/		if ( regs.CR[0].eq ) { return 0x8226A488;  }
		/* 8226A46Ch case   11:*/		return 0x8226A470;
		  /* 8226A470h */ case   12:  		/* lis R11, -32255 */
		/* 8226A470h case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8226A470h case   12:*/		return 0x8226A474;
		  /* 8226A474h */ case   13:  		/* li R5, 0 */
		/* 8226A474h case   13:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8226A474h case   13:*/		return 0x8226A478;
		  /* 8226A478h */ case   14:  		/* addi R4, R11, -8160 */
		/* 8226A478h case   14:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFE020);
		/* 8226A478h case   14:*/		return 0x8226A47C;
		  /* 8226A47Ch */ case   15:  		/* mr R3, R30 */
		/* 8226A47Ch case   15:*/		regs.R3 = regs.R30;
		/* 8226A47Ch case   15:*/		return 0x8226A480;
		  /* 8226A480h */ case   16:  		/* bl -2368 */
		/* 8226A480h case   16:*/		regs.LR = 0x8226A484; return 0x82269B40;
		/* 8226A480h case   16:*/		return 0x8226A484;
		  /* 8226A484h */ case   17:  		/* b 916 */
		/* 8226A484h case   17:*/		return 0x8226A818;
		/* 8226A484h case   17:*/		return 0x8226A488;
	}
	return 0x8226A488;
} // Block from 8226A440h-8226A488h (18 instructions)

//////////////////////////////////////////////////////
// Block at 8226A488h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A488( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A488) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A488);
		  /* 8226A488h */ case    0:  		/* lbz R11, <#[R31 + 8]> */
		/* 8226A488h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8226A488h case    0:*/		return 0x8226A48C;
		  /* 8226A48Ch */ case    1:  		/* lis R10, -32251 */
		/* 8226A48Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 8226A48Ch case    1:*/		return 0x8226A490;
		  /* 8226A490h */ case    2:  		/* lis R9, -32768 */
		/* 8226A490h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8000);
		/* 8226A490h case    2:*/		return 0x8226A494;
	}
	return 0x8226A494;
} // Block from 8226A488h-8226A494h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8226A494h
// Function '__savevmx_122'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A494( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A494) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A494);
		  /* 8226A494h */ case    0:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 8226A494h case    0:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8226A494h case    0:*/		return 0x8226A498;
		  /* 8226A498h */ case    1:  		/* addi R10, R10, -16600 */
		/* 8226A498h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFBF28);
		/* 8226A498h case    1:*/		return 0x8226A49C;
		  /* 8226A49Ch */ case    2:  		/* cmplwi CR6, R11, 2 */
		/* 8226A49Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 8226A49Ch case    2:*/		return 0x8226A4A0;
		  /* 8226A4A0h */ case    3:  		/* lbzx R27, <#[R11 + R10]> */
		/* 8226A4A0h case    3:*/		cpu::mem::load8z( regs, &regs.R27, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8226A4A0h case    3:*/		return 0x8226A4A4;
		  /* 8226A4A4h */ case    4:  		/* bc 4, CR6_EQ, 120 */
		/* 8226A4A4h case    4:*/		if ( !regs.CR[6].eq ) { return 0x8226A51C;  }
		/* 8226A4A4h case    4:*/		return 0x8226A4A8;
		  /* 8226A4A8h */ case    5:  		/* lwz R11, <#[R31 + 4]> */
		/* 8226A4A8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8226A4A8h case    5:*/		return 0x8226A4AC;
		  /* 8226A4ACh */ case    6:  		/* rlwinm R10, R11, 31, 1, 31 */
		/* 8226A4ACh case    6:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R10,regs.R11);
		/* 8226A4ACh case    6:*/		return 0x8226A4B0;
		  /* 8226A4B0h */ case    7:  		/* xor R11, R10, R11 */
		/* 8226A4B0h case    7:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8226A4B0h case    7:*/		return 0x8226A4B4;
		  /* 8226A4B4h */ case    8:  		/* rlwinm. R11, R11, 0, 6, 6 */
		/* 8226A4B4h case    8:*/		cpu::op::rlwinm<1,0,6,6>(regs,&regs.R11,regs.R11);
		/* 8226A4B4h case    8:*/		return 0x8226A4B8;
		  /* 8226A4B8h */ case    9:  		/* bc 4, CR0_EQ, 100 */
		/* 8226A4B8h case    9:*/		if ( !regs.CR[0].eq ) { return 0x8226A51C;  }
		/* 8226A4B8h case    9:*/		return 0x8226A4BC;
		  /* 8226A4BCh */ case   10:  		/* lbz R11, <#[R31 + 10]> */
		/* 8226A4BCh case   10:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000A) );
		/* 8226A4BCh case   10:*/		return 0x8226A4C0;
		  /* 8226A4C0h */ case   11:  		/* lbz R10, <#[R31 + 9]> */
		/* 8226A4C0h case   11:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000009) );
		/* 8226A4C0h case   11:*/		return 0x8226A4C4;
		  /* 8226A4C4h */ case   12:  		/* cmplw CR6, R10, R11 */
		/* 8226A4C4h case   12:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8226A4C4h case   12:*/		return 0x8226A4C8;
	}
	return 0x8226A4C8;
} // Block from 8226A494h-8226A4C8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8226A4C8h
// Function '__restvmx'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A4C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A4C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A4C8);
		  /* 8226A4C8h */ case    0:  		/* bc 4, CR6_EQ, 84 */
		/* 8226A4C8h case    0:*/		if ( !regs.CR[6].eq ) { return 0x8226A51C;  }
		/* 8226A4C8h case    0:*/		return 0x8226A4CC;
		  /* 8226A4CCh */ case    1:  		/* lwz R11, <#[R31 + 8]> */
		/* 8226A4CCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8226A4CCh case    1:*/		return 0x8226A4D0;
		  /* 8226A4D0h */ case    2:  		/* rlwinm R10, R11, 31, 1, 31 */
		/* 8226A4D0h case    2:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R10,regs.R11);
		/* 8226A4D0h case    2:*/		return 0x8226A4D4;
		  /* 8226A4D4h */ case    3:  		/* xor R11, R10, R11 */
		/* 8226A4D4h case    3:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8226A4D4h case    3:*/		return 0x8226A4D8;
		  /* 8226A4D8h */ case    4:  		/* rlwinm. R11, R11, 0, 1, 1 */
		/* 8226A4D8h case    4:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R11);
		/* 8226A4D8h case    4:*/		return 0x8226A4DC;
		  /* 8226A4DCh */ case    5:  		/* bc 4, CR0_EQ, 64 */
		/* 8226A4DCh case    5:*/		if ( !regs.CR[0].eq ) { return 0x8226A51C;  }
		/* 8226A4DCh case    5:*/		return 0x8226A4E0;
		  /* 8226A4E0h */ case    6:  		/* lbz R11, <#[R31 + 6]> */
		/* 8226A4E0h case    6:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000006) );
		/* 8226A4E0h case    6:*/		return 0x8226A4E4;
		  /* 8226A4E4h */ case    7:  		/* lbz R10, <#[R31 + 5]> */
		/* 8226A4E4h case    7:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000005) );
		/* 8226A4E4h case    7:*/		return 0x8226A4E8;
		  /* 8226A4E8h */ case    8:  		/* cmplw CR6, R10, R11 */
		/* 8226A4E8h case    8:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 8226A4E8h case    8:*/		return 0x8226A4EC;
		  /* 8226A4ECh */ case    9:  		/* bc 4, CR6_EQ, 48 */
		/* 8226A4ECh case    9:*/		if ( !regs.CR[6].eq ) { return 0x8226A51C;  }
		/* 8226A4ECh case    9:*/		return 0x8226A4F0;
		  /* 8226A4F0h */ case   10:  		/* lwz R11, <#[R31 + 8]> */
		/* 8226A4F0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8226A4F0h case   10:*/		return 0x8226A4F4;
		  /* 8226A4F4h */ case   11:  		/* rlwinm R11, R11, 0, 0, 0 */
		/* 8226A4F4h case   11:*/		cpu::op::rlwinm<0,0,0,0>(regs,&regs.R11,regs.R11);
		/* 8226A4F4h case   11:*/		return 0x8226A4F8;
		  /* 8226A4F8h */ case   12:  		/* cmplw CR6, R11, R9 */
		/* 8226A4F8h case   12:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8226A4F8h case   12:*/		return 0x8226A4FC;
		  /* 8226A4FCh */ case   13:  		/* bc 12, CR6_EQ, 24 */
		/* 8226A4FCh case   13:*/		if ( regs.CR[6].eq ) { return 0x8226A514;  }
		/* 8226A4FCh case   13:*/		return 0x8226A500;
		  /* 8226A500h */ case   14:  		/* lwz R11, <#[R31 + 4]> */
		/* 8226A500h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8226A500h case   14:*/		return 0x8226A504;
		  /* 8226A504h */ case   15:  		/* rlwinm R10, R11, 31, 1, 31 */
		/* 8226A504h case   15:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R10,regs.R11);
		/* 8226A504h case   15:*/		return 0x8226A508;
		  /* 8226A508h */ case   16:  		/* xor R11, R10, R11 */
		/* 8226A508h case   16:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8226A508h case   16:*/		return 0x8226A50C;
		  /* 8226A50Ch */ case   17:  		/* rlwinm. R11, R11, 0, 1, 1 */
		/* 8226A50Ch case   17:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R11);
		/* 8226A50Ch case   17:*/		return 0x8226A510;
		  /* 8226A510h */ case   18:  		/* bc 4, CR0_EQ, 12 */
		/* 8226A510h case   18:*/		if ( !regs.CR[0].eq ) { return 0x8226A51C;  }
		/* 8226A510h case   18:*/		return 0x8226A514;
	}
	return 0x8226A514;
} // Block from 8226A4C8h-8226A514h (19 instructions)

//////////////////////////////////////////////////////
// Block at 8226A514h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A514( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A514) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A514);
		  /* 8226A514h */ case    0:  		/* li R11, 1 */
		/* 8226A514h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8226A514h case    0:*/		return 0x8226A518;
		  /* 8226A518h */ case    1:  		/* b 8 */
		/* 8226A518h case    1:*/		return 0x8226A520;
		/* 8226A518h case    1:*/		return 0x8226A51C;
	}
	return 0x8226A51C;
} // Block from 8226A514h-8226A51Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226A51Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A51C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A51C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A51C);
		  /* 8226A51Ch */ case    0:  		/* mr R11, R26 */
		/* 8226A51Ch case    0:*/		regs.R11 = regs.R26;
		/* 8226A51Ch case    0:*/		return 0x8226A520;
	}
	return 0x8226A520;
} // Block from 8226A51Ch-8226A520h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226A520h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A520( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A520) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A520);
		  /* 8226A520h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8226A520h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8226A520h case    0:*/		return 0x8226A524;
		  /* 8226A524h */ case    1:  		/* bc 12, CR0_EQ, 28 */
		/* 8226A524h case    1:*/		if ( regs.CR[0].eq ) { return 0x8226A540;  }
		/* 8226A524h case    1:*/		return 0x8226A528;
		  /* 8226A528h */ case    2:  		/* lis R10, -32255 */
		/* 8226A528h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 8226A528h case    2:*/		return 0x8226A52C;
		  /* 8226A52Ch */ case    3:  		/* addi R4, R10, -8164 */
		/* 8226A52Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0xFFFFE01C);
		/* 8226A52Ch case    3:*/		return 0x8226A530;
		  /* 8226A530h */ case    4:  		/* lbz R11, <#[R31]> */
		/* 8226A530h case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8226A530h case    4:*/		return 0x8226A534;
		  /* 8226A534h */ case    5:  		/* li R27, 1 */
		/* 8226A534h case    5:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 8226A534h case    5:*/		return 0x8226A538;
		  /* 8226A538h */ case    6:  		/* rlwinm R5, R11, 0, 31, 31 */
		/* 8226A538h case    6:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R5,regs.R11);
		/* 8226A538h case    6:*/		return 0x8226A53C;
		  /* 8226A53Ch */ case    7:  		/* b 180 */
		/* 8226A53Ch case    7:*/		return 0x8226A5F0;
		/* 8226A53Ch case    7:*/		return 0x8226A540;
	}
	return 0x8226A540;
} // Block from 8226A520h-8226A540h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8226A540h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A540( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A540) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A540);
		  /* 8226A540h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 8226A540h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8226A540h case    0:*/		return 0x8226A544;
		  /* 8226A544h */ case    1:  		/* rlwinm R10, R11, 8, 27, 31 */
		/* 8226A544h case    1:*/		cpu::op::rlwinm<0,8,27,31>(regs,&regs.R10,regs.R11);
		/* 8226A544h case    1:*/		return 0x8226A548;
		  /* 8226A548h */ case    2:  		/* cmplwi CR6, R10, 29 */
		/* 8226A548h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000001D);
		/* 8226A548h case    2:*/		return 0x8226A54C;
		  /* 8226A54Ch */ case    3:  		/* bc 4, CR6_EQ, 116 */
		/* 8226A54Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x8226A5C0;  }
		/* 8226A54Ch case    3:*/		return 0x8226A550;
		  /* 8226A550h */ case    4:  		/* lwz R8, <#[R31 + 4]> */
		/* 8226A550h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000004) );
		/* 8226A550h case    4:*/		return 0x8226A554;
		  /* 8226A554h */ case    5:  		/* rlwinm R7, R8, 31, 1, 31 */
		/* 8226A554h case    5:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R7,regs.R8);
		/* 8226A554h case    5:*/		return 0x8226A558;
		  /* 8226A558h */ case    6:  		/* xor R8, R7, R8 */
		/* 8226A558h case    6:*/		cpu::op::xor<0>(regs,&regs.R8,regs.R7,regs.R8);
		/* 8226A558h case    6:*/		return 0x8226A55C;
		  /* 8226A55Ch */ case    7:  		/* rlwinm. R8, R8, 0, 6, 6 */
		/* 8226A55Ch case    7:*/		cpu::op::rlwinm<1,0,6,6>(regs,&regs.R8,regs.R8);
		/* 8226A55Ch case    7:*/		return 0x8226A560;
		  /* 8226A560h */ case    8:  		/* bc 4, CR0_EQ, 96 */
		/* 8226A560h case    8:*/		if ( !regs.CR[0].eq ) { return 0x8226A5C0;  }
		/* 8226A560h case    8:*/		return 0x8226A564;
		  /* 8226A564h */ case    9:  		/* lbz R8, <#[R31 + 10]> */
		/* 8226A564h case    9:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R31 + 0x0000000A) );
		/* 8226A564h case    9:*/		return 0x8226A568;
		  /* 8226A568h */ case   10:  		/* lbz R7, <#[R31 + 9]> */
		/* 8226A568h case   10:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000009) );
		/* 8226A568h case   10:*/		return 0x8226A56C;
		  /* 8226A56Ch */ case   11:  		/* cmplw CR6, R7, R8 */
		/* 8226A56Ch case   11:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R8);
		/* 8226A56Ch case   11:*/		return 0x8226A570;
		  /* 8226A570h */ case   12:  		/* bc 4, CR6_EQ, 80 */
		/* 8226A570h case   12:*/		if ( !regs.CR[6].eq ) { return 0x8226A5C0;  }
		/* 8226A570h case   12:*/		return 0x8226A574;
		  /* 8226A574h */ case   13:  		/* rlwinm R8, R11, 0, 0, 31 */
		/* 8226A574h case   13:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R8,regs.R11);
		/* 8226A574h case   13:*/		return 0x8226A578;
		  /* 8226A578h */ case   14:  		/* rlwinm R7, R8, 31, 1, 31 */
		/* 8226A578h case   14:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R7,regs.R8);
		/* 8226A578h case   14:*/		return 0x8226A57C;
		  /* 8226A57Ch */ case   15:  		/* xor R8, R7, R8 */
		/* 8226A57Ch case   15:*/		cpu::op::xor<0>(regs,&regs.R8,regs.R7,regs.R8);
		/* 8226A57Ch case   15:*/		return 0x8226A580;
		  /* 8226A580h */ case   16:  		/* rlwinm. R8, R8, 0, 1, 1 */
		/* 8226A580h case   16:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R8,regs.R8);
		/* 8226A580h case   16:*/		return 0x8226A584;
		  /* 8226A584h */ case   17:  		/* bc 4, CR0_EQ, 60 */
		/* 8226A584h case   17:*/		if ( !regs.CR[0].eq ) { return 0x8226A5C0;  }
		/* 8226A584h case   17:*/		return 0x8226A588;
		  /* 8226A588h */ case   18:  		/* lbz R8, <#[R31 + 6]> */
		/* 8226A588h case   18:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000006) );
		/* 8226A588h case   18:*/		return 0x8226A58C;
		  /* 8226A58Ch */ case   19:  		/* lbz R7, <#[R31 + 5]> */
		/* 8226A58Ch case   19:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000005) );
		/* 8226A58Ch case   19:*/		return 0x8226A590;
		  /* 8226A590h */ case   20:  		/* cmplw CR6, R7, R8 */
		/* 8226A590h case   20:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R8);
		/* 8226A590h case   20:*/		return 0x8226A594;
		  /* 8226A594h */ case   21:  		/* bc 4, CR6_EQ, 44 */
		/* 8226A594h case   21:*/		if ( !regs.CR[6].eq ) { return 0x8226A5C0;  }
		/* 8226A594h case   21:*/		return 0x8226A598;
		  /* 8226A598h */ case   22:  		/* rlwinm R11, R11, 0, 0, 0 */
		/* 8226A598h case   22:*/		cpu::op::rlwinm<0,0,0,0>(regs,&regs.R11,regs.R11);
		/* 8226A598h case   22:*/		return 0x8226A59C;
		  /* 8226A59Ch */ case   23:  		/* cmplw CR6, R11, R9 */
		/* 8226A59Ch case   23:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 8226A59Ch case   23:*/		return 0x8226A5A0;
		  /* 8226A5A0h */ case   24:  		/* bc 12, CR6_EQ, 24 */
		/* 8226A5A0h case   24:*/		if ( regs.CR[6].eq ) { return 0x8226A5B8;  }
		/* 8226A5A0h case   24:*/		return 0x8226A5A4;
		  /* 8226A5A4h */ case   25:  		/* lwz R11, <#[R31 + 4]> */
		/* 8226A5A4h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8226A5A4h case   25:*/		return 0x8226A5A8;
		  /* 8226A5A8h */ case   26:  		/* rlwinm R9, R11, 31, 1, 31 */
		/* 8226A5A8h case   26:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R9,regs.R11);
		/* 8226A5A8h case   26:*/		return 0x8226A5AC;
		  /* 8226A5ACh */ case   27:  		/* xor R11, R9, R11 */
		/* 8226A5ACh case   27:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 8226A5ACh case   27:*/		return 0x8226A5B0;
		  /* 8226A5B0h */ case   28:  		/* rlwinm. R11, R11, 0, 1, 1 */
		/* 8226A5B0h case   28:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R11);
		/* 8226A5B0h case   28:*/		return 0x8226A5B4;
		  /* 8226A5B4h */ case   29:  		/* bc 4, CR0_EQ, 12 */
		/* 8226A5B4h case   29:*/		if ( !regs.CR[0].eq ) { return 0x8226A5C0;  }
		/* 8226A5B4h case   29:*/		return 0x8226A5B8;
	}
	return 0x8226A5B8;
} // Block from 8226A540h-8226A5B8h (30 instructions)

//////////////////////////////////////////////////////
// Block at 8226A5B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A5B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A5B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A5B8);
		  /* 8226A5B8h */ case    0:  		/* li R11, 1 */
		/* 8226A5B8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8226A5B8h case    0:*/		return 0x8226A5BC;
		  /* 8226A5BCh */ case    1:  		/* b 8 */
		/* 8226A5BCh case    1:*/		return 0x8226A5C4;
		/* 8226A5BCh case    1:*/		return 0x8226A5C0;
	}
	return 0x8226A5C0;
} // Block from 8226A5B8h-8226A5C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226A5C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A5C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A5C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A5C0);
		  /* 8226A5C0h */ case    0:  		/* mr R11, R26 */
		/* 8226A5C0h case    0:*/		regs.R11 = regs.R26;
		/* 8226A5C0h case    0:*/		return 0x8226A5C4;
	}
	return 0x8226A5C4;
} // Block from 8226A5C0h-8226A5C4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226A5C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A5C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A5C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A5C4);
		  /* 8226A5C4h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 8226A5C4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 8226A5C4h case    0:*/		return 0x8226A5C8;
		  /* 8226A5C8h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 8226A5C8h case    1:*/		if ( regs.CR[0].eq ) { return 0x8226A5D8;  }
		/* 8226A5C8h case    1:*/		return 0x8226A5CC;
		  /* 8226A5CCh */ case    2:  		/* lis R10, -32255 */
		/* 8226A5CCh case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 8226A5CCh case    2:*/		return 0x8226A5D0;
		  /* 8226A5D0h */ case    3:  		/* addi R4, R10, -8376 */
		/* 8226A5D0h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0xFFFFDF48);
		/* 8226A5D0h case    3:*/		return 0x8226A5D4;
		  /* 8226A5D4h */ case    4:  		/* b -164 */
		/* 8226A5D4h case    4:*/		return 0x8226A530;
		/* 8226A5D4h case    4:*/		return 0x8226A5D8;
	}
	return 0x8226A5D8;
} // Block from 8226A5C4h-8226A5D8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8226A5D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A5D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A5D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A5D8);
		  /* 8226A5D8h */ case    0:  		/* lis R11, -32216 */
		/* 8226A5D8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8228);
		/* 8226A5D8h case    0:*/		return 0x8226A5DC;
		  /* 8226A5DCh */ case    1:  		/* lbz R9, <#[R31]> */
		/* 8226A5DCh case    1:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 8226A5DCh case    1:*/		return 0x8226A5E0;
		  /* 8226A5E0h */ case    2:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 8226A5E0h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 8226A5E0h case    2:*/		return 0x8226A5E4;
		  /* 8226A5E4h */ case    3:  		/* addi R11, R11, 27680 */
		/* 8226A5E4h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x6C20);
		/* 8226A5E4h case    3:*/		return 0x8226A5E8;
		  /* 8226A5E8h */ case    4:  		/* rlwinm R5, R9, 0, 31, 31 */
		/* 8226A5E8h case    4:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R5,regs.R9);
		/* 8226A5E8h case    4:*/		return 0x8226A5EC;
		  /* 8226A5ECh */ case    5:  		/* lwzx R4, <#[R10 + R11]> */
		/* 8226A5ECh case    5:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8226A5ECh case    5:*/		return 0x8226A5F0;
	}
	return 0x8226A5F0;
} // Block from 8226A5D8h-8226A5F0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8226A5F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A5F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A5F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A5F0);
		  /* 8226A5F0h */ case    0:  		/* mr R3, R30 */
		/* 8226A5F0h case    0:*/		regs.R3 = regs.R30;
		/* 8226A5F0h case    0:*/		return 0x8226A5F4;
		  /* 8226A5F4h */ case    1:  		/* bl -2740 */
		/* 8226A5F4h case    1:*/		regs.LR = 0x8226A5F8; return 0x82269B40;
		/* 8226A5F4h case    1:*/		return 0x8226A5F8;
		  /* 8226A5F8h */ case    2:  		/* lwz R11, <#[R31]> */
		/* 8226A5F8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8226A5F8h case    2:*/		return 0x8226A5FC;
		  /* 8226A5FCh */ case    3:  		/* li R10, 1 */
		/* 8226A5FCh case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8226A5FCh case    3:*/		return 0x8226A600;
		  /* 8226A600h */ case    4:  		/* mr R3, R30 */
		/* 8226A600h case    4:*/		regs.R3 = regs.R30;
		/* 8226A600h case    4:*/		return 0x8226A604;
		  /* 8226A604h */ case    5:  		/* rlwinm R9, R11, 12, 28, 31 */
		/* 8226A604h case    5:*/		cpu::op::rlwinm<0,12,28,31>(regs,&regs.R9,regs.R11);
		/* 8226A604h case    5:*/		return 0x8226A608;
		  /* 8226A608h */ case    6:  		/* rlwinm R8, R11, 18, 31, 31 */
		/* 8226A608h case    6:*/		cpu::op::rlwinm<0,18,31,31>(regs,&regs.R8,regs.R11);
		/* 8226A608h case    6:*/		return 0x8226A60C;
		  /* 8226A60Ch */ case    7:  		/* rlwinm R7, R11, 26, 31, 31 */
		/* 8226A60Ch case    7:*/		cpu::op::rlwinm<0,26,31,31>(regs,&regs.R7,regs.R11);
		/* 8226A60Ch case    7:*/		return 0x8226A610;
		  /* 8226A610h */ case    8:  		/* rlwinm R6, R11, 17, 31, 31 */
		/* 8226A610h case    8:*/		cpu::op::rlwinm<0,17,31,31>(regs,&regs.R6,regs.R11);
		/* 8226A610h case    8:*/		return 0x8226A614;
		  /* 8226A614h */ case    9:  		/* rlwinm R5, R11, 16, 28, 31 */
		/* 8226A614h case    9:*/		cpu::op::rlwinm<0,16,28,31>(regs,&regs.R5,regs.R11);
		/* 8226A614h case    9:*/		return 0x8226A618;
		  /* 8226A618h */ case   10:  		/* rlwinm R4, R11, 0, 26, 31 */
		/* 8226A618h case   10:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R4,regs.R11);
		/* 8226A618h case   10:*/		return 0x8226A61C;
		  /* 8226A61Ch */ case   11:  		/* bl -2412 */
		/* 8226A61Ch case   11:*/		regs.LR = 0x8226A620; return 0x82269CB0;
		/* 8226A61Ch case   11:*/		return 0x8226A620;
		  /* 8226A620h */ case   12:  		/* lis R11, -32256 */
		/* 8226A620h case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8226A620h case   12:*/		return 0x8226A624;
		  /* 8226A624h */ case   13:  		/* mr R3, R30 */
		/* 8226A624h case   13:*/		regs.R3 = regs.R30;
		/* 8226A624h case   13:*/		return 0x8226A628;
		  /* 8226A628h */ case   14:  		/* addi R29, R11, 17860 */
		/* 8226A628h case   14:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x45C4);
		/* 8226A628h case   14:*/		return 0x8226A62C;
		  /* 8226A62Ch */ case   15:  		/* mr R4, R29 */
		/* 8226A62Ch case   15:*/		regs.R4 = regs.R29;
		/* 8226A62Ch case   15:*/		return 0x8226A630;
		  /* 8226A630h */ case   16:  		/* bl -3152 */
		/* 8226A630h case   16:*/		regs.LR = 0x8226A634; return 0x822699E0;
		/* 8226A630h case   16:*/		return 0x8226A634;
		  /* 8226A634h */ case   17:  		/* lwz R11, <#[R31 + 4]> */
		/* 8226A634h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8226A634h case   17:*/		return 0x8226A638;
		  /* 8226A638h */ case   18:  		/* rlwinm. R10, R11, 0, 0, 0 */
		/* 8226A638h case   18:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R10,regs.R11);
		/* 8226A638h case   18:*/		return 0x8226A63C;
		  /* 8226A63Ch */ case   19:  		/* bc 4, CR0_EQ, 24 */
		/* 8226A63Ch case   19:*/		if ( !regs.CR[0].eq ) { return 0x8226A654;  }
		/* 8226A63Ch case   19:*/		return 0x8226A640;
		  /* 8226A640h */ case   20:  		/* rlwinm. R10, R11, 0, 1, 1 */
		/* 8226A640h case   20:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R11);
		/* 8226A640h case   20:*/		return 0x8226A644;
		  /* 8226A644h */ case   21:  		/* bc 4, CR0_EQ, 16 */
		/* 8226A644h case   21:*/		if ( !regs.CR[0].eq ) { return 0x8226A654;  }
		/* 8226A644h case   21:*/		return 0x8226A648;
		  /* 8226A648h */ case   22:  		/* rlwinm. R11, R11, 0, 2, 2 */
		/* 8226A648h case   22:*/		cpu::op::rlwinm<1,0,2,2>(regs,&regs.R11,regs.R11);
		/* 8226A648h case   22:*/		return 0x8226A64C;
		  /* 8226A64Ch */ case   23:  		/* bc 12, CR0_EQ, 8 */
		/* 8226A64Ch case   23:*/		if ( regs.CR[0].eq ) { return 0x8226A654;  }
		/* 8226A64Ch case   23:*/		return 0x8226A650;
		  /* 8226A650h */ case   24:  		/* li R24, 1 */
		/* 8226A650h case   24:*/		cpu::op::li<0>(regs,&regs.R24,0x1);
		/* 8226A650h case   24:*/		return 0x8226A654;
	}
	return 0x8226A654;
} // Block from 8226A5F0h-8226A654h (25 instructions)

//////////////////////////////////////////////////////
// Block at 8226A654h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A654( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A654) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A654);
		  /* 8226A654h */ case    0:  		/* li R28, 4 */
		/* 8226A654h case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x4);
		/* 8226A654h case    0:*/		return 0x8226A658;
		  /* 8226A658h */ case    1:  		/* cmplwi CR6, R27, 1 */
		/* 8226A658h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000001);
		/* 8226A658h case    1:*/		return 0x8226A65C;
		  /* 8226A65Ch */ case    2:  		/* bc 12, CR6_LT, 116 */
		/* 8226A65Ch case    2:*/		if ( regs.CR[6].lt ) { return 0x8226A6D0;  }
		/* 8226A65Ch case    2:*/		return 0x8226A660;
		  /* 8226A660h */ case    3:  		/* lwz R11, <#[R31 + 8]> */
		/* 8226A660h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8226A660h case    3:*/		return 0x8226A664;
		  /* 8226A664h */ case    4:  		/* rlwinm. R11, R11, 1, 31, 31 */
		/* 8226A664h case    4:*/		cpu::op::rlwinm<1,1,31,31>(regs,&regs.R11,regs.R11);
		/* 8226A664h case    4:*/		return 0x8226A668;
		  /* 8226A668h */ case    5:  		/* nor R10, R11, R11 */
		/* 8226A668h case    5:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R11,regs.R11);
		/* 8226A668h case    5:*/		return 0x8226A66C;
		  /* 8226A66Ch */ case    6:  		/* rlwinm R25, R10, 0, 31, 31 */
		/* 8226A66Ch case    6:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R25,regs.R10);
		/* 8226A66Ch case    6:*/		return 0x8226A670;
		  /* 8226A670h */ case    7:  		/* bc 4, CR0_EQ, 40 */
		/* 8226A670h case    7:*/		if ( !regs.CR[0].eq ) { return 0x8226A698;  }
		/* 8226A670h case    7:*/		return 0x8226A674;
		  /* 8226A674h */ case    8:  		/* cmpwi CR6, R24, 0 */
		/* 8226A674h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 8226A674h case    8:*/		return 0x8226A678;
		  /* 8226A678h */ case    9:  		/* bc 12, CR6_EQ, 32 */
		/* 8226A678h case    9:*/		if ( regs.CR[6].eq ) { return 0x8226A698;  }
		/* 8226A678h case    9:*/		return 0x8226A67C;
		  /* 8226A67Ch */ case   10:  		/* lwz R11, <#[R31 + 4]> */
		/* 8226A67Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8226A67Ch case   10:*/		return 0x8226A680;
		  /* 8226A680h */ case   11:  		/* mr R3, R30 */
		/* 8226A680h case   11:*/		regs.R3 = regs.R30;
		/* 8226A680h case   11:*/		return 0x8226A684;
		  /* 8226A684h */ case   12:  		/* lbz R6, <#[R31 + 5]> */
		/* 8226A684h case   12:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000005) );
		/* 8226A684h case   12:*/		return 0x8226A688;
		  /* 8226A688h */ case   13:  		/* rlwinm R5, R11, 6, 31, 31 */
		/* 8226A688h case   13:*/		cpu::op::rlwinm<0,6,31,31>(regs,&regs.R5,regs.R11);
		/* 8226A688h case   13:*/		return 0x8226A68C;
		  /* 8226A68Ch */ case   14:  		/* lbz R4, <#[R31 + 9]> */
		/* 8226A68Ch case   14:*/		cpu::mem::load8z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000009) );
		/* 8226A68Ch case   14:*/		return 0x8226A690;
		  /* 8226A690h */ case   15:  		/* bl -920 */
		/* 8226A690h case   15:*/		regs.LR = 0x8226A694; return 0x8226A2F8;
		/* 8226A690h case   15:*/		return 0x8226A694;
		  /* 8226A694h */ case   16:  		/* b 60 */
		/* 8226A694h case   16:*/		return 0x8226A6D0;
		/* 8226A694h case   16:*/		return 0x8226A698;
	}
	return 0x8226A698;
} // Block from 8226A654h-8226A698h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8226A698h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A698( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A698) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A698);
		  /* 8226A698h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 8226A698h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8226A698h case    0:*/		return 0x8226A69C;
		  /* 8226A69Ch */ case    1:  		/* mr R3, R30 */
		/* 8226A69Ch case    1:*/		regs.R3 = regs.R30;
		/* 8226A69Ch case    1:*/		return 0x8226A6A0;
		  /* 8226A6A0h */ case    2:  		/* lwz R10, <#[R31]> */
		/* 8226A6A0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8226A6A0h case    2:*/		return 0x8226A6A4;
		  /* 8226A6A4h */ case    3:  		/* lwz R4, <#[R31 + 8]> */
		/* 8226A6A4h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000008) );
		/* 8226A6A4h case    3:*/		return 0x8226A6A8;
		  /* 8226A6A8h */ case    4:  		/* rlwinm R9, R11, 6, 31, 31 */
		/* 8226A6A8h case    4:*/		cpu::op::rlwinm<0,6,31,31>(regs,&regs.R9,regs.R11);
		/* 8226A6A8h case    4:*/		return 0x8226A6AC;
		  /* 8226A6ACh */ case    5:  		/* rlwinm R8, R10, 25, 31, 31 */
		/* 8226A6ACh case    5:*/		cpu::op::rlwinm<0,25,31,31>(regs,&regs.R8,regs.R10);
		/* 8226A6ACh case    5:*/		return 0x8226A6B0;
		  /* 8226A6B0h */ case    6:  		/* lbz R10, <#[R31 + 5]> */
		/* 8226A6B0h case    6:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000005) );
		/* 8226A6B0h case    6:*/		return 0x8226A6B4;
		  /* 8226A6B4h */ case    7:  		/* rlwinm R7, R11, 3, 31, 31 */
		/* 8226A6B4h case    7:*/		cpu::op::rlwinm<0,3,31,31>(regs,&regs.R7,regs.R11);
		/* 8226A6B4h case    7:*/		return 0x8226A6B8;
		  /* 8226A6B8h */ case    8:  		/* lbz R5, <#[R31 + 9]> */
		/* 8226A6B8h case    8:*/		cpu::mem::load8z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000009) );
		/* 8226A6B8h case    8:*/		return 0x8226A6BC;
		  /* 8226A6BCh */ case    9:  		/* rlwinm R6, R11, 1, 31, 31 */
		/* 8226A6BCh case    9:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R6,regs.R11);
		/* 8226A6BCh case    9:*/		return 0x8226A6C0;
		  /* 8226A6C0h */ case   10:  		/* stb R26, <#[R1 + 95]> */
		/* 8226A6C0h case   10:*/		cpu::mem::store8( regs, regs.R26, (uint32)(regs.R1 + 0x0000005F) );
		/* 8226A6C0h case   10:*/		return 0x8226A6C4;
		  /* 8226A6C4h */ case   11:  		/* rlwinm R4, R4, 1, 31, 31 */
		/* 8226A6C4h case   11:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R4,regs.R4);
		/* 8226A6C4h case   11:*/		return 0x8226A6C8;
		  /* 8226A6C8h */ case   12:  		/* stw R28, <#[R1 + 84]> */
		/* 8226A6C8h case   12:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000054) );
		/* 8226A6C8h case   12:*/		return 0x8226A6CC;
		  /* 8226A6CCh */ case   13:  		/* bl -1700 */
		/* 8226A6CCh case   13:*/		regs.LR = 0x8226A6D0; return 0x8226A028;
		/* 8226A6CCh case   13:*/		return 0x8226A6D0;
	}
	return 0x8226A6D0;
} // Block from 8226A698h-8226A6D0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8226A6D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A6D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A6D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A6D0);
		  /* 8226A6D0h */ case    0:  		/* cmplwi CR6, R27, 2 */
		/* 8226A6D0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000002);
		/* 8226A6D0h case    0:*/		return 0x8226A6D4;
		  /* 8226A6D4h */ case    1:  		/* bc 12, CR6_LT, 160 */
		/* 8226A6D4h case    1:*/		if ( regs.CR[6].lt ) { return 0x8226A774;  }
		/* 8226A6D4h case    1:*/		return 0x8226A6D8;
		  /* 8226A6D8h */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 8226A6D8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8226A6D8h case    2:*/		return 0x8226A6DC;
		  /* 8226A6DCh */ case    3:  		/* rlwinm. R11, R11, 0, 1, 1 */
		/* 8226A6DCh case    3:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R11);
		/* 8226A6DCh case    3:*/		return 0x8226A6E0;
		  /* 8226A6E0h */ case    4:  		/* bc 4, CR0_EQ, 16 */
		/* 8226A6E0h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8226A6F0;  }
		/* 8226A6E0h case    4:*/		return 0x8226A6E4;
		  /* 8226A6E4h */ case    5:  		/* cmpwi CR6, R25, 0 */
		/* 8226A6E4h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 8226A6E4h case    5:*/		return 0x8226A6E8;
		  /* 8226A6E8h */ case    6:  		/* bc 4, CR6_EQ, 8 */
		/* 8226A6E8h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8226A6F0;  }
		/* 8226A6E8h case    6:*/		return 0x8226A6EC;
		  /* 8226A6ECh */ case    7:  		/* li R25, 2 */
		/* 8226A6ECh case    7:*/		cpu::op::li<0>(regs,&regs.R25,0x2);
		/* 8226A6ECh case    7:*/		return 0x8226A6F0;
	}
	return 0x8226A6F0;
} // Block from 8226A6D0h-8226A6F0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8226A6F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A6F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A6F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A6F0);
		  /* 8226A6F0h */ case    0:  		/* mr R4, R29 */
		/* 8226A6F0h case    0:*/		regs.R4 = regs.R29;
		/* 8226A6F0h case    0:*/		return 0x8226A6F4;
		  /* 8226A6F4h */ case    1:  		/* mr R3, R30 */
		/* 8226A6F4h case    1:*/		regs.R3 = regs.R30;
		/* 8226A6F4h case    1:*/		return 0x8226A6F8;
		  /* 8226A6F8h */ case    2:  		/* bl -3352 */
		/* 8226A6F8h case    2:*/		regs.LR = 0x8226A6FC; return 0x822699E0;
		/* 8226A6F8h case    2:*/		return 0x8226A6FC;
		  /* 8226A6FCh */ case    3:  		/* lwz R11, <#[R31 + 8]> */
		/* 8226A6FCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8226A6FCh case    3:*/		return 0x8226A700;
		  /* 8226A700h */ case    4:  		/* rlwinm. R11, R11, 0, 1, 1 */
		/* 8226A700h case    4:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R11);
		/* 8226A700h case    4:*/		return 0x8226A704;
		  /* 8226A704h */ case    5:  		/* bc 4, CR0_EQ, 40 */
		/* 8226A704h case    5:*/		if ( !regs.CR[0].eq ) { return 0x8226A72C;  }
		/* 8226A704h case    5:*/		return 0x8226A708;
		  /* 8226A708h */ case    6:  		/* cmpwi CR6, R24, 0 */
		/* 8226A708h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 8226A708h case    6:*/		return 0x8226A70C;
		  /* 8226A70Ch */ case    7:  		/* bc 12, CR6_EQ, 32 */
		/* 8226A70Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x8226A72C;  }
		/* 8226A70Ch case    7:*/		return 0x8226A710;
		  /* 8226A710h */ case    8:  		/* lwz R11, <#[R31 + 4]> */
		/* 8226A710h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8226A710h case    8:*/		return 0x8226A714;
		  /* 8226A714h */ case    9:  		/* mr R3, R30 */
		/* 8226A714h case    9:*/		regs.R3 = regs.R30;
		/* 8226A714h case    9:*/		return 0x8226A718;
		  /* 8226A718h */ case   10:  		/* lbz R6, <#[R31 + 6]> */
		/* 8226A718h case   10:*/		cpu::mem::load8z( regs, &regs.R6, (uint32)(regs.R31 + 0x00000006) );
		/* 8226A718h case   10:*/		return 0x8226A71C;
		  /* 8226A71Ch */ case   11:  		/* rlwinm R5, R11, 7, 31, 31 */
		/* 8226A71Ch case   11:*/		cpu::op::rlwinm<0,7,31,31>(regs,&regs.R5,regs.R11);
		/* 8226A71Ch case   11:*/		return 0x8226A720;
		  /* 8226A720h */ case   12:  		/* lbz R4, <#[R31 + 10]> */
		/* 8226A720h case   12:*/		cpu::mem::load8z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000A) );
		/* 8226A720h case   12:*/		return 0x8226A724;
		  /* 8226A724h */ case   13:  		/* bl -1068 */
		/* 8226A724h case   13:*/		regs.LR = 0x8226A728; return 0x8226A2F8;
		/* 8226A724h case   13:*/		return 0x8226A728;
		  /* 8226A728h */ case   14:  		/* b 76 */
		/* 8226A728h case   14:*/		return 0x8226A774;
		/* 8226A728h case   14:*/		return 0x8226A72C;
	}
	return 0x8226A72C;
} // Block from 8226A6F0h-8226A72Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8226A72Ch
// Function '__restvmx_122'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A72C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A72C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A72C);
		  /* 8226A72Ch */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 8226A72Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8226A72Ch case    0:*/		return 0x8226A730;
		  /* 8226A730h */ case    1:  		/* cmpwi CR6, R25, 2 */
		/* 8226A730h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000002);
		/* 8226A730h case    1:*/		return 0x8226A734;
		  /* 8226A734h */ case    2:  		/* rlwinm R6, R11, 1, 31, 31 */
		/* 8226A734h case    2:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R6,regs.R11);
		/* 8226A734h case    2:*/		return 0x8226A738;
		  /* 8226A738h */ case    3:  		/* bc 12, CR6_EQ, 8 */
		/* 8226A738h case    3:*/		if ( regs.CR[6].eq ) { return 0x8226A740;  }
		/* 8226A738h case    3:*/		return 0x8226A73C;
		  /* 8226A73Ch */ case    4:  		/* rlwinm R6, R11, 2, 31, 31 */
		/* 8226A73Ch case    4:*/		cpu::op::rlwinm<0,2,31,31>(regs,&regs.R6,regs.R11);
		/* 8226A73Ch case    4:*/		return 0x8226A740;
	}
	return 0x8226A740;
} // Block from 8226A72Ch-8226A740h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8226A740h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A740( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A740) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A740);
		  /* 8226A740h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 8226A740h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8226A740h case    0:*/		return 0x8226A744;
		  /* 8226A744h */ case    1:  		/* mr R3, R30 */
		/* 8226A744h case    1:*/		regs.R3 = regs.R30;
		/* 8226A744h case    1:*/		return 0x8226A748;
		  /* 8226A748h */ case    2:  		/* lwz R10, <#[R31]> */
		/* 8226A748h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8226A748h case    2:*/		return 0x8226A74C;
		  /* 8226A74Ch */ case    3:  		/* lwz R4, <#[R31 + 8]> */
		/* 8226A74Ch case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000008) );
		/* 8226A74Ch case    3:*/		return 0x8226A750;
		  /* 8226A750h */ case    4:  		/* rlwinm R9, R11, 7, 31, 31 */
		/* 8226A750h case    4:*/		cpu::op::rlwinm<0,7,31,31>(regs,&regs.R9,regs.R11);
		/* 8226A750h case    4:*/		return 0x8226A754;
		  /* 8226A754h */ case    5:  		/* rlwinm R8, R10, 25, 31, 31 */
		/* 8226A754h case    5:*/		cpu::op::rlwinm<0,25,31,31>(regs,&regs.R8,regs.R10);
		/* 8226A754h case    5:*/		return 0x8226A758;
		  /* 8226A758h */ case    6:  		/* lbz R10, <#[R31 + 6]> */
		/* 8226A758h case    6:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000006) );
		/* 8226A758h case    6:*/		return 0x8226A75C;
		  /* 8226A75Ch */ case    7:  		/* rlwinm R7, R11, 3, 31, 31 */
		/* 8226A75Ch case    7:*/		cpu::op::rlwinm<0,3,31,31>(regs,&regs.R7,regs.R11);
		/* 8226A75Ch case    7:*/		return 0x8226A760;
	}
	return 0x8226A760;
} // Block from 8226A740h-8226A760h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8226A760h
// Function '??__Eg_RGBScaledToYUV601@D3D@@YAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A760( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A760) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A760);
		  /* 8226A760h */ case    0:  		/* lbz R5, <#[R31 + 10]> */
		/* 8226A760h case    0:*/		cpu::mem::load8z( regs, &regs.R5, (uint32)(regs.R31 + 0x0000000A) );
		/* 8226A760h case    0:*/		return 0x8226A764;
		  /* 8226A764h */ case    1:  		/* rlwinm R4, R4, 2, 31, 31 */
		/* 8226A764h case    1:*/		cpu::op::rlwinm<0,2,31,31>(regs,&regs.R4,regs.R4);
		/* 8226A764h case    1:*/		return 0x8226A768;
		  /* 8226A768h */ case    2:  		/* stb R26, <#[R1 + 95]> */
		/* 8226A768h case    2:*/		cpu::mem::store8( regs, regs.R26, (uint32)(regs.R1 + 0x0000005F) );
		/* 8226A768h case    2:*/		return 0x8226A76C;
		  /* 8226A76Ch */ case    3:  		/* stw R28, <#[R1 + 84]> */
		/* 8226A76Ch case    3:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000054) );
		/* 8226A76Ch case    3:*/		return 0x8226A770;
		  /* 8226A770h */ case    4:  		/* bl -1864 */
		/* 8226A770h case    4:*/		regs.LR = 0x8226A774; return 0x8226A028;
		/* 8226A770h case    4:*/		return 0x8226A774;
	}
	return 0x8226A774;
} // Block from 8226A760h-8226A774h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8226A774h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A774( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A774) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A774);
		  /* 8226A774h */ case    0:  		/* cmplwi CR6, R27, 3 */
		/* 8226A774h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000003);
		/* 8226A774h case    0:*/		return 0x8226A778;
		  /* 8226A778h */ case    1:  		/* bc 12, CR6_LT, 160 */
		/* 8226A778h case    1:*/		if ( regs.CR[6].lt ) { return 0x8226A818;  }
		/* 8226A778h case    1:*/		return 0x8226A77C;
		  /* 8226A77Ch */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 8226A77Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8226A77Ch case    2:*/		return 0x8226A780;
		  /* 8226A780h */ case    3:  		/* rlwinm. R11, R11, 0, 2, 2 */
		/* 8226A780h case    3:*/		cpu::op::rlwinm<1,0,2,2>(regs,&regs.R11,regs.R11);
		/* 8226A780h case    3:*/		return 0x8226A784;
		  /* 8226A784h */ case    4:  		/* bc 4, CR0_EQ, 16 */
		/* 8226A784h case    4:*/		if ( !regs.CR[0].eq ) { return 0x8226A794;  }
		/* 8226A784h case    4:*/		return 0x8226A788;
		  /* 8226A788h */ case    5:  		/* cmpwi CR6, R25, 0 */
		/* 8226A788h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000000);
		/* 8226A788h case    5:*/		return 0x8226A78C;
		  /* 8226A78Ch */ case    6:  		/* bc 4, CR6_EQ, 8 */
		/* 8226A78Ch case    6:*/		if ( !regs.CR[6].eq ) { return 0x8226A794;  }
		/* 8226A78Ch case    6:*/		return 0x8226A790;
		  /* 8226A790h */ case    7:  		/* li R25, 3 */
		/* 8226A790h case    7:*/		cpu::op::li<0>(regs,&regs.R25,0x3);
		/* 8226A790h case    7:*/		return 0x8226A794;
	}
	return 0x8226A794;
} // Block from 8226A774h-8226A794h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8226A794h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A794( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A794) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A794);
		  /* 8226A794h */ case    0:  		/* mr R4, R29 */
		/* 8226A794h case    0:*/		regs.R4 = regs.R29;
		/* 8226A794h case    0:*/		return 0x8226A798;
		  /* 8226A798h */ case    1:  		/* mr R3, R30 */
		/* 8226A798h case    1:*/		regs.R3 = regs.R30;
		/* 8226A798h case    1:*/		return 0x8226A79C;
		  /* 8226A79Ch */ case    2:  		/* bl -3516 */
		/* 8226A79Ch case    2:*/		regs.LR = 0x8226A7A0; return 0x822699E0;
		/* 8226A79Ch case    2:*/		return 0x8226A7A0;
		  /* 8226A7A0h */ case    3:  		/* lwz R11, <#[R31 + 8]> */
		/* 8226A7A0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8226A7A0h case    3:*/		return 0x8226A7A4;
		  /* 8226A7A4h */ case    4:  		/* rlwinm. R10, R11, 0, 2, 2 */
		/* 8226A7A4h case    4:*/		cpu::op::rlwinm<1,0,2,2>(regs,&regs.R10,regs.R11);
		/* 8226A7A4h case    4:*/		return 0x8226A7A8;
		  /* 8226A7A8h */ case    5:  		/* bc 4, CR0_EQ, 40 */
		/* 8226A7A8h case    5:*/		if ( !regs.CR[0].eq ) { return 0x8226A7D0;  }
		/* 8226A7A8h case    5:*/		return 0x8226A7AC;
		  /* 8226A7ACh */ case    6:  		/* cmpwi CR6, R24, 0 */
		/* 8226A7ACh case    6:*/		cpu::op::cmpwi<6>(regs,regs.R24,0x00000000);
		/* 8226A7ACh case    6:*/		return 0x8226A7B0;
		  /* 8226A7B0h */ case    7:  		/* bc 12, CR6_EQ, 32 */
		/* 8226A7B0h case    7:*/		if ( regs.CR[6].eq ) { return 0x8226A7D0;  }
		/* 8226A7B0h case    7:*/		return 0x8226A7B4;
		  /* 8226A7B4h */ case    8:  		/* lwz R10, <#[R31 + 4]> */
		/* 8226A7B4h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8226A7B4h case    8:*/		return 0x8226A7B8;
		  /* 8226A7B8h */ case    9:  		/* rlwinm R4, R11, 0, 24, 31 */
		/* 8226A7B8h case    9:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R4,regs.R11);
		/* 8226A7B8h case    9:*/		return 0x8226A7BC;
		  /* 8226A7BCh */ case   10:  		/* mr R3, R30 */
		/* 8226A7BCh case   10:*/		regs.R3 = regs.R30;
		/* 8226A7BCh case   10:*/		return 0x8226A7C0;
		  /* 8226A7C0h */ case   11:  		/* rlwinm R6, R10, 0, 24, 31 */
		/* 8226A7C0h case   11:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R6,regs.R10);
		/* 8226A7C0h case   11:*/		return 0x8226A7C4;
		  /* 8226A7C4h */ case   12:  		/* rlwinm R5, R10, 8, 31, 31 */
		/* 8226A7C4h case   12:*/		cpu::op::rlwinm<0,8,31,31>(regs,&regs.R5,regs.R10);
		/* 8226A7C4h case   12:*/		return 0x8226A7C8;
		  /* 8226A7C8h */ case   13:  		/* bl -1232 */
		/* 8226A7C8h case   13:*/		regs.LR = 0x8226A7CC; return 0x8226A2F8;
		/* 8226A7C8h case   13:*/		return 0x8226A7CC;
		  /* 8226A7CCh */ case   14:  		/* b 76 */
		/* 8226A7CCh case   14:*/		return 0x8226A818;
		/* 8226A7CCh case   14:*/		return 0x8226A7D0;
	}
	return 0x8226A7D0;
} // Block from 8226A794h-8226A7D0h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8226A7D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A7D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A7D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A7D0);
		  /* 8226A7D0h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 8226A7D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8226A7D0h case    0:*/		return 0x8226A7D4;
		  /* 8226A7D4h */ case    1:  		/* cmpwi CR6, R25, 3 */
		/* 8226A7D4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R25,0x00000003);
		/* 8226A7D4h case    1:*/		return 0x8226A7D8;
		  /* 8226A7D8h */ case    2:  		/* rlwinm R6, R11, 1, 31, 31 */
		/* 8226A7D8h case    2:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R6,regs.R11);
		/* 8226A7D8h case    2:*/		return 0x8226A7DC;
		  /* 8226A7DCh */ case    3:  		/* bc 12, CR6_EQ, 8 */
		/* 8226A7DCh case    3:*/		if ( regs.CR[6].eq ) { return 0x8226A7E4;  }
		/* 8226A7DCh case    3:*/		return 0x8226A7E0;
		  /* 8226A7E0h */ case    4:  		/* rlwinm R6, R11, 2, 31, 31 */
		/* 8226A7E0h case    4:*/		cpu::op::rlwinm<0,2,31,31>(regs,&regs.R6,regs.R11);
		/* 8226A7E0h case    4:*/		return 0x8226A7E4;
	}
	return 0x8226A7E4;
} // Block from 8226A7D0h-8226A7E4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8226A7E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A7E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A7E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A7E4);
		  /* 8226A7E4h */ case    0:  		/* stw R28, <#[R1 + 84]> */
		/* 8226A7E4h case    0:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R1 + 0x00000054) );
		/* 8226A7E4h case    0:*/		return 0x8226A7E8;
		  /* 8226A7E8h */ case    1:  		/* mr R3, R30 */
		/* 8226A7E8h case    1:*/		regs.R3 = regs.R30;
		/* 8226A7E8h case    1:*/		return 0x8226A7EC;
		  /* 8226A7ECh */ case    2:  		/* lwz R4, <#[R31 + 8]> */
		/* 8226A7ECh case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000008) );
		/* 8226A7ECh case    2:*/		return 0x8226A7F0;
		  /* 8226A7F0h */ case    3:  		/* lwz R11, <#[R31 + 4]> */
		/* 8226A7F0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8226A7F0h case    3:*/		return 0x8226A7F4;
		  /* 8226A7F4h */ case    4:  		/* lwz R8, <#[R31]> */
		/* 8226A7F4h case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 8226A7F4h case    4:*/		return 0x8226A7F8;
	}
	return 0x8226A7F8;
} // Block from 8226A7E4h-8226A7F8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8226A7F8h
// Function '??__Eg_RGBScaledToYUV709@D3D@@YAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A7F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A7F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A7F8);
		  /* 8226A7F8h */ case    0:  		/* rlwinm R5, R4, 0, 24, 31 */
		/* 8226A7F8h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R5,regs.R4);
		/* 8226A7F8h case    0:*/		return 0x8226A7FC;
		  /* 8226A7FCh */ case    1:  		/* rlwinm R10, R11, 0, 24, 31 */
		/* 8226A7FCh case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R11);
		/* 8226A7FCh case    1:*/		return 0x8226A800;
		  /* 8226A800h */ case    2:  		/* stb R26, <#[R1 + 95]> */
		/* 8226A800h case    2:*/		cpu::mem::store8( regs, regs.R26, (uint32)(regs.R1 + 0x0000005F) );
		/* 8226A800h case    2:*/		return 0x8226A804;
		  /* 8226A804h */ case    3:  		/* rlwinm R9, R11, 8, 31, 31 */
		/* 8226A804h case    3:*/		cpu::op::rlwinm<0,8,31,31>(regs,&regs.R9,regs.R11);
		/* 8226A804h case    3:*/		return 0x8226A808;
		  /* 8226A808h */ case    4:  		/* rlwinm R7, R11, 3, 31, 31 */
		/* 8226A808h case    4:*/		cpu::op::rlwinm<0,3,31,31>(regs,&regs.R7,regs.R11);
		/* 8226A808h case    4:*/		return 0x8226A80C;
		  /* 8226A80Ch */ case    5:  		/* rlwinm R8, R8, 25, 31, 31 */
		/* 8226A80Ch case    5:*/		cpu::op::rlwinm<0,25,31,31>(regs,&regs.R8,regs.R8);
		/* 8226A80Ch case    5:*/		return 0x8226A810;
		  /* 8226A810h */ case    6:  		/* rlwinm R4, R4, 3, 31, 31 */
		/* 8226A810h case    6:*/		cpu::op::rlwinm<0,3,31,31>(regs,&regs.R4,regs.R4);
		/* 8226A810h case    6:*/		return 0x8226A814;
		  /* 8226A814h */ case    7:  		/* bl -2028 */
		/* 8226A814h case    7:*/		regs.LR = 0x8226A818; return 0x8226A028;
		/* 8226A814h case    7:*/		return 0x8226A818;
	}
	return 0x8226A818;
} // Block from 8226A7F8h-8226A818h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8226A818h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A818( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A818) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A818);
		  /* 8226A818h */ case    0:  		/* addi R1, R1, 176 */
		/* 8226A818h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 8226A818h case    0:*/		return 0x8226A81C;
		  /* 8226A81Ch */ case    1:  		/* b -1938820 */
		/* 8226A81Ch case    1:*/		return 0x82091298;
		/* 8226A81Ch case    1:*/		return 0x8226A820;
	}
	return 0x8226A820;
} // Block from 8226A818h-8226A820h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226A820h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A820( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A820) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A820);
		  /* 8226A820h */ case    0:  		/* mfspr R12, LR */
		/* 8226A820h case    0:*/		regs.R12 = regs.LR;
		/* 8226A820h case    0:*/		return 0x8226A824;
		  /* 8226A824h */ case    1:  		/* bl -1938912 */
		/* 8226A824h case    1:*/		regs.LR = 0x8226A828; return 0x82091244;
		/* 8226A824h case    1:*/		return 0x8226A828;
		  /* 8226A828h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 8226A828h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 8226A828h case    2:*/		return 0x8226A82C;
		  /* 8226A82Ch */ case    3:  		/* lwz R11, <#[R4 + 4]> */
		/* 8226A82Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 8226A82Ch case    3:*/		return 0x8226A830;
		  /* 8226A830h */ case    4:  		/* li R25, 0 */
		/* 8226A830h case    4:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 8226A830h case    4:*/		return 0x8226A834;
		  /* 8226A834h */ case    5:  		/* mr R27, R3 */
		/* 8226A834h case    5:*/		regs.R27 = regs.R3;
		/* 8226A834h case    5:*/		return 0x8226A838;
		  /* 8226A838h */ case    6:  		/* mr R31, R4 */
		/* 8226A838h case    6:*/		regs.R31 = regs.R4;
		/* 8226A838h case    6:*/		return 0x8226A83C;
		  /* 8226A83Ch */ case    7:  		/* rlwinm. R10, R11, 0, 0, 0 */
		/* 8226A83Ch case    7:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R10,regs.R11);
		/* 8226A83Ch case    7:*/		return 0x8226A840;
		  /* 8226A840h */ case    8:  		/* mr R23, R25 */
		/* 8226A840h case    8:*/		regs.R23 = regs.R25;
		/* 8226A840h case    8:*/		return 0x8226A844;
		  /* 8226A844h */ case    9:  		/* bc 4, CR0_EQ, 24 */
		/* 8226A844h case    9:*/		if ( !regs.CR[0].eq ) { return 0x8226A85C;  }
		/* 8226A844h case    9:*/		return 0x8226A848;
		  /* 8226A848h */ case   10:  		/* rlwinm. R10, R11, 0, 1, 1 */
		/* 8226A848h case   10:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R11);
		/* 8226A848h case   10:*/		return 0x8226A84C;
		  /* 8226A84Ch */ case   11:  		/* bc 4, CR0_EQ, 16 */
		/* 8226A84Ch case   11:*/		if ( !regs.CR[0].eq ) { return 0x8226A85C;  }
		/* 8226A84Ch case   11:*/		return 0x8226A850;
		  /* 8226A850h */ case   12:  		/* rlwinm. R11, R11, 0, 2, 2 */
		/* 8226A850h case   12:*/		cpu::op::rlwinm<1,0,2,2>(regs,&regs.R11,regs.R11);
		/* 8226A850h case   12:*/		return 0x8226A854;
		  /* 8226A854h */ case   13:  		/* bc 12, CR0_EQ, 8 */
		/* 8226A854h case   13:*/		if ( regs.CR[0].eq ) { return 0x8226A85C;  }
		/* 8226A854h case   13:*/		return 0x8226A858;
		  /* 8226A858h */ case   14:  		/* li R23, 1 */
		/* 8226A858h case   14:*/		cpu::op::li<0>(regs,&regs.R23,0x1);
		/* 8226A858h case   14:*/		return 0x8226A85C;
	}
	return 0x8226A85C;
} // Block from 8226A820h-8226A85Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8226A85Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A85C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A85C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A85C);
		  /* 8226A85Ch */ case    0:  		/* lbz R11, <#[R31 + 8]> */
		/* 8226A85Ch case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8226A85Ch case    0:*/		return 0x8226A860;
		  /* 8226A860h */ case    1:  		/* mr R24, R25 */
		/* 8226A860h case    1:*/		regs.R24 = regs.R25;
		/* 8226A860h case    1:*/		return 0x8226A864;
		  /* 8226A864h */ case    2:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 8226A864h case    2:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8226A864h case    2:*/		return 0x8226A868;
		  /* 8226A868h */ case    3:  		/* cmplwi CR6, R11, 11 */
		/* 8226A868h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000B);
		/* 8226A868h case    3:*/		return 0x8226A86C;
		  /* 8226A86Ch */ case    4:  		/* bc 12, CR6_LT, 16 */
		/* 8226A86Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x8226A87C;  }
		/* 8226A86Ch case    4:*/		return 0x8226A870;
		  /* 8226A870h */ case    5:  		/* cmplwi CR6, R11, 14 */
		/* 8226A870h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000000E);
		/* 8226A870h case    5:*/		return 0x8226A874;
		  /* 8226A874h */ case    6:  		/* bc 12, CR6_GT, 8 */
		/* 8226A874h case    6:*/		if ( regs.CR[6].gt ) { return 0x8226A87C;  }
		/* 8226A874h case    6:*/		return 0x8226A878;
		  /* 8226A878h */ case    7:  		/* li R24, 1 */
		/* 8226A878h case    7:*/		cpu::op::li<0>(regs,&regs.R24,0x1);
		/* 8226A878h case    7:*/		return 0x8226A87C;
	}
	return 0x8226A87C;
} // Block from 8226A85Ch-8226A87Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8226A87Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A87C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A87C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A87C);
		  /* 8226A87Ch */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 8226A87Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8226A87Ch case    0:*/		return 0x8226A880;
		  /* 8226A880h */ case    1:  		/* rlwinm. R9, R24, 0, 24, 31 */
		/* 8226A880h case    1:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R9,regs.R24);
		/* 8226A880h case    1:*/		return 0x8226A884;
		  /* 8226A884h */ case    2:  		/* rlwinm R10, R11, 26, 6, 31 */
		/* 8226A884h case    2:*/		cpu::op::rlwinm<0,26,6,31>(regs,&regs.R10,regs.R11);
		/* 8226A884h case    2:*/		return 0x8226A888;
		  /* 8226A888h */ case    3:  		/* addi R10, R10, -1 */
		/* 8226A888h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 8226A888h case    3:*/		return 0x8226A88C;
		  /* 8226A88Ch */ case    4:  		/* rlwinm R10, R10, 0, 30, 31 */
		/* 8226A88Ch case    4:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R10,regs.R10);
		/* 8226A88Ch case    4:*/		return 0x8226A890;
	}
	return 0x8226A890;
} // Block from 8226A87Ch-8226A890h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8226A890h
// Function '??__Eg_RGBOneNinthScaledToYUV601@D3D@@YAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A890( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A890) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A890);
		  /* 8226A890h */ case    0:  		/* bc 12, CR0_EQ, 12 */
		/* 8226A890h case    0:*/		if ( regs.CR[0].eq ) { return 0x8226A89C;  }
		/* 8226A890h case    0:*/		return 0x8226A894;
		  /* 8226A894h */ case    1:  		/* rlwinm R11, R11, 28, 4, 31 */
		/* 8226A894h case    1:*/		cpu::op::rlwinm<0,28,4,31>(regs,&regs.R11,regs.R11);
		/* 8226A894h case    1:*/		return 0x8226A898;
		  /* 8226A898h */ case    2:  		/* addi R11, R11, -2 */
		/* 8226A898h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFE);
		/* 8226A898h case    2:*/		return 0x8226A89C;
	}
	return 0x8226A89C;
} // Block from 8226A890h-8226A89Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8226A89Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A89C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A89C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A89C);
		  /* 8226A89Ch */ case    0:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 8226A89Ch case    0:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 8226A89Ch case    0:*/		return 0x8226A8A0;
		  /* 8226A8A0h */ case    1:  		/* li R26, 1 */
		/* 8226A8A0h case    1:*/		cpu::op::li<0>(regs,&regs.R26,0x1);
		/* 8226A8A0h case    1:*/		return 0x8226A8A4;
		  /* 8226A8A4h */ case    2:  		/* subf R11, R11, R10 */
		/* 8226A8A4h case    2:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 8226A8A4h case    2:*/		return 0x8226A8A8;
		  /* 8226A8A8h */ case    3:  		/* cntlzw R11, R11 */
		/* 8226A8A8h case    3:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 8226A8A8h case    3:*/		return 0x8226A8AC;
		  /* 8226A8ACh */ case    4:  		/* rlwinm. R11, R11, 27, 31, 31 */
		/* 8226A8ACh case    4:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R11,regs.R11);
		/* 8226A8ACh case    4:*/		return 0x8226A8B0;
		  /* 8226A8B0h */ case    5:  		/* mr R10, R11 */
		/* 8226A8B0h case    5:*/		regs.R10 = regs.R11;
		/* 8226A8B0h case    5:*/		return 0x8226A8B4;
		  /* 8226A8B4h */ case    6:  		/* bc 12, CR0_EQ, 36 */
		/* 8226A8B4h case    6:*/		if ( regs.CR[0].eq ) { return 0x8226A8D8;  }
		/* 8226A8B4h case    6:*/		return 0x8226A8B8;
		  /* 8226A8B8h */ case    7:  		/* lwz R11, <#[R31]> */
		/* 8226A8B8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8226A8B8h case    7:*/		return 0x8226A8BC;
		  /* 8226A8BCh */ case    8:  		/* lis R9, 5120 */
		/* 8226A8BCh case    8:*/		cpu::op::lis<0>(regs,&regs.R9,0x1400);
		/* 8226A8BCh case    8:*/		return 0x8226A8C0;
		  /* 8226A8C0h */ case    9:  		/* rlwinm R8, R11, 0, 0, 5 */
		/* 8226A8C0h case    9:*/		cpu::op::rlwinm<0,0,0,5>(regs,&regs.R8,regs.R11);
		/* 8226A8C0h case    9:*/		return 0x8226A8C4;
		  /* 8226A8C4h */ case   10:  		/* cmplw CR6, R8, R9 */
		/* 8226A8C4h case   10:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 8226A8C4h case   10:*/		return 0x8226A8C8;
		  /* 8226A8C8h */ case   11:  		/* bc 4, CR6_EQ, 16 */
		/* 8226A8C8h case   11:*/		if ( !regs.CR[6].eq ) { return 0x8226A8D8;  }
		/* 8226A8C8h case   11:*/		return 0x8226A8CC;
		  /* 8226A8CCh */ case   12:  		/* lis R10, -32255 */
		/* 8226A8CCh case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 8226A8CCh case   12:*/		return 0x8226A8D0;
		  /* 8226A8D0h */ case   13:  		/* addi R4, R10, 13288 */
		/* 8226A8D0h case   13:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0x33E8);
		/* 8226A8D0h case   13:*/		return 0x8226A8D4;
		  /* 8226A8D4h */ case   14:  		/* b 80 */
		/* 8226A8D4h case   14:*/		return 0x8226A924;
		/* 8226A8D4h case   14:*/		return 0x8226A8D8;
	}
	return 0x8226A8D8;
} // Block from 8226A89Ch-8226A8D8h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8226A8D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A8D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A8D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A8D8);
		  /* 8226A8D8h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 8226A8D8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8226A8D8h case    0:*/		return 0x8226A8DC;
		  /* 8226A8DCh */ case    1:  		/* bc 12, CR6_EQ, 88 */
		/* 8226A8DCh case    1:*/		if ( regs.CR[6].eq ) { return 0x8226A934;  }
		/* 8226A8DCh case    1:*/		return 0x8226A8E0;
		  /* 8226A8E0h */ case    2:  		/* lwz R11, <#[R31]> */
		/* 8226A8E0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8226A8E0h case    2:*/		return 0x8226A8E4;
		  /* 8226A8E4h */ case    3:  		/* lis R9, 23552 */
		/* 8226A8E4h case    3:*/		cpu::op::lis<0>(regs,&regs.R9,0x5C00);
		/* 8226A8E4h case    3:*/		return 0x8226A8E8;
		  /* 8226A8E8h */ case    4:  		/* rlwinm R8, R11, 0, 0, 5 */
		/* 8226A8E8h case    4:*/		cpu::op::rlwinm<0,0,0,5>(regs,&regs.R8,regs.R11);
		/* 8226A8E8h case    4:*/		return 0x8226A8EC;
		  /* 8226A8ECh */ case    5:  		/* cmplw CR6, R8, R9 */
		/* 8226A8ECh case    5:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 8226A8ECh case    5:*/		return 0x8226A8F0;
		  /* 8226A8F0h */ case    6:  		/* bc 4, CR6_EQ, 16 */
		/* 8226A8F0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8226A900;  }
		/* 8226A8F0h case    6:*/		return 0x8226A8F4;
		  /* 8226A8F4h */ case    7:  		/* lis R10, -32255 */
		/* 8226A8F4h case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 8226A8F4h case    7:*/		return 0x8226A8F8;
		  /* 8226A8F8h */ case    8:  		/* addi R4, R10, 13280 */
		/* 8226A8F8h case    8:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0x33E0);
		/* 8226A8F8h case    8:*/		return 0x8226A8FC;
		  /* 8226A8FCh */ case    9:  		/* b 40 */
		/* 8226A8FCh case    9:*/		return 0x8226A924;
		/* 8226A8FCh case    9:*/		return 0x8226A900;
	}
	return 0x8226A900;
} // Block from 8226A8D8h-8226A900h (10 instructions)

//////////////////////////////////////////////////////
// Block at 8226A900h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A900( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A900) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A900);
		  /* 8226A900h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 8226A900h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 8226A900h case    0:*/		return 0x8226A904;
		  /* 8226A904h */ case    1:  		/* bc 12, CR6_EQ, 48 */
		/* 8226A904h case    1:*/		if ( regs.CR[6].eq ) { return 0x8226A934;  }
		/* 8226A904h case    1:*/		return 0x8226A908;
		  /* 8226A908h */ case    2:  		/* lwz R11, <#[R31]> */
		/* 8226A908h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8226A908h case    2:*/		return 0x8226A90C;
		  /* 8226A90Ch */ case    3:  		/* lis R10, 24576 */
		/* 8226A90Ch case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x6000);
		/* 8226A90Ch case    3:*/		return 0x8226A910;
		  /* 8226A910h */ case    4:  		/* rlwinm R9, R11, 0, 0, 5 */
		/* 8226A910h case    4:*/		cpu::op::rlwinm<0,0,0,5>(regs,&regs.R9,regs.R11);
		/* 8226A910h case    4:*/		return 0x8226A914;
		  /* 8226A914h */ case    5:  		/* cmplw CR6, R9, R10 */
		/* 8226A914h case    5:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R10);
		/* 8226A914h case    5:*/		return 0x8226A918;
		  /* 8226A918h */ case    6:  		/* bc 4, CR6_EQ, 28 */
		/* 8226A918h case    6:*/		if ( !regs.CR[6].eq ) { return 0x8226A934;  }
		/* 8226A918h case    6:*/		return 0x8226A91C;
		  /* 8226A91Ch */ case    7:  		/* lis R10, -32255 */
		/* 8226A91Ch case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 8226A91Ch case    7:*/		return 0x8226A920;
		  /* 8226A920h */ case    8:  		/* addi R4, R10, 13272 */
		/* 8226A920h case    8:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0x33D8);
		/* 8226A920h case    8:*/		return 0x8226A924;
	}
	return 0x8226A924;
} // Block from 8226A900h-8226A924h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8226A924h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A924( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A924) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A924);
		  /* 8226A924h */ case    0:  		/* rlwinm R5, R11, 7, 31, 31 */
		/* 8226A924h case    0:*/		cpu::op::rlwinm<0,7,31,31>(regs,&regs.R5,regs.R11);
		/* 8226A924h case    0:*/		return 0x8226A928;
	}
	return 0x8226A928;
} // Block from 8226A924h-8226A928h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226A928h
// Function '??__Eg_RGBOneNinthScaledToYUV709@D3D@@YAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A928( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A928) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A928);
		  /* 8226A928h */ case    0:  		/* mr R3, R27 */
		/* 8226A928h case    0:*/		regs.R3 = regs.R27;
		/* 8226A928h case    0:*/		return 0x8226A92C;
		  /* 8226A92Ch */ case    1:  		/* bl -3564 */
		/* 8226A92Ch case    1:*/		regs.LR = 0x8226A930; return 0x82269B40;
		/* 8226A92Ch case    1:*/		return 0x8226A930;
		  /* 8226A930h */ case    2:  		/* b 40 */
		/* 8226A930h case    2:*/		return 0x8226A958;
		/* 8226A930h case    2:*/		return 0x8226A934;
	}
	return 0x8226A934;
} // Block from 8226A928h-8226A934h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8226A934h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A934( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A934) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A934);
		  /* 8226A934h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 8226A934h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8226A934h case    0:*/		return 0x8226A938;
		  /* 8226A938h */ case    1:  		/* lis R10, -32216 */
		/* 8226A938h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8228);
		/* 8226A938h case    1:*/		return 0x8226A93C;
		  /* 8226A93Ch */ case    2:  		/* mr R3, R27 */
		/* 8226A93Ch case    2:*/		regs.R3 = regs.R27;
		/* 8226A93Ch case    2:*/		return 0x8226A940;
		  /* 8226A940h */ case    3:  		/* addi R10, R10, 27808 */
		/* 8226A940h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x6CA0);
		/* 8226A940h case    3:*/		return 0x8226A944;
		  /* 8226A944h */ case    4:  		/* rlwinm R9, R11, 8, 24, 29 */
		/* 8226A944h case    4:*/		cpu::op::rlwinm<0,8,24,29>(regs,&regs.R9,regs.R11);
		/* 8226A944h case    4:*/		return 0x8226A948;
		  /* 8226A948h */ case    5:  		/* rlwinm R5, R11, 7, 31, 31 */
		/* 8226A948h case    5:*/		cpu::op::rlwinm<0,7,31,31>(regs,&regs.R5,regs.R11);
		/* 8226A948h case    5:*/		return 0x8226A94C;
		  /* 8226A94Ch */ case    6:  		/* lwzx R4, <#[R9 + R10]> */
		/* 8226A94Ch case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 8226A94Ch case    6:*/		return 0x8226A950;
		  /* 8226A950h */ case    7:  		/* bl -3600 */
		/* 8226A950h case    7:*/		regs.LR = 0x8226A954; return 0x82269B40;
		/* 8226A950h case    7:*/		return 0x8226A954;
		  /* 8226A954h */ case    8:  		/* mr R26, R25 */
		/* 8226A954h case    8:*/		regs.R26 = regs.R25;
		/* 8226A954h case    8:*/		return 0x8226A958;
	}
	return 0x8226A958;
} // Block from 8226A934h-8226A958h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8226A958h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A958( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A958) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A958);
		  /* 8226A958h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 8226A958h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8226A958h case    0:*/		return 0x8226A95C;
		  /* 8226A95Ch */ case    1:  		/* rlwinm. R6, R11, 17, 31, 31 */
		/* 8226A95Ch case    1:*/		cpu::op::rlwinm<1,17,31,31>(regs,&regs.R6,regs.R11);
		/* 8226A95Ch case    1:*/		return 0x8226A960;
		  /* 8226A960h */ case    2:  		/* rlwinm R7, R11, 26, 31, 31 */
		/* 8226A960h case    2:*/		cpu::op::rlwinm<0,26,31,31>(regs,&regs.R7,regs.R11);
		/* 8226A960h case    2:*/		return 0x8226A964;
		  /* 8226A964h */ case    3:  		/* bc 4, CR0_EQ, 8 */
		/* 8226A964h case    3:*/		if ( !regs.CR[0].eq ) { return 0x8226A96C;  }
		/* 8226A964h case    3:*/		return 0x8226A968;
		  /* 8226A968h */ case    4:  		/* rlwinm R7, R11, 18, 31, 31 */
		/* 8226A968h case    4:*/		cpu::op::rlwinm<0,18,31,31>(regs,&regs.R7,regs.R11);
		/* 8226A968h case    4:*/		return 0x8226A96C;
	}
	return 0x8226A96C;
} // Block from 8226A958h-8226A96Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8226A96Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A96C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A96C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A96C);
		  /* 8226A96Ch */ case    0:  		/* cmplwi CR6, R6, 0 */
		/* 8226A96Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 8226A96Ch case    0:*/		return 0x8226A970;
		  /* 8226A970h */ case    1:  		/* rlwinm R4, R11, 0, 26, 31 */
		/* 8226A970h case    1:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R4,regs.R11);
		/* 8226A970h case    1:*/		return 0x8226A974;
		  /* 8226A974h */ case    2:  		/* bc 4, CR6_EQ, 8 */
		/* 8226A974h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8226A97C;  }
		/* 8226A974h case    2:*/		return 0x8226A978;
		  /* 8226A978h */ case    3:  		/* rlwinm R4, R11, 24, 26, 31 */
		/* 8226A978h case    3:*/		cpu::op::rlwinm<0,24,26,31>(regs,&regs.R4,regs.R11);
		/* 8226A978h case    3:*/		return 0x8226A97C;
	}
	return 0x8226A97C;
} // Block from 8226A96Ch-8226A97Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226A97Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A97C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A97C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A97C);
		  /* 8226A97Ch */ case    0:  		/* li R10, 0 */
		/* 8226A97Ch case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8226A97Ch case    0:*/		return 0x8226A980;
		  /* 8226A980h */ case    1:  		/* rlwinm R9, R11, 16, 28, 31 */
		/* 8226A980h case    1:*/		cpu::op::rlwinm<0,16,28,31>(regs,&regs.R9,regs.R11);
		/* 8226A980h case    1:*/		return 0x8226A984;
		  /* 8226A984h */ case    2:  		/* rlwinm R8, R11, 18, 31, 31 */
		/* 8226A984h case    2:*/		cpu::op::rlwinm<0,18,31,31>(regs,&regs.R8,regs.R11);
		/* 8226A984h case    2:*/		return 0x8226A988;
		  /* 8226A988h */ case    3:  		/* rlwinm R5, R11, 12, 28, 31 */
		/* 8226A988h case    3:*/		cpu::op::rlwinm<0,12,28,31>(regs,&regs.R5,regs.R11);
		/* 8226A988h case    3:*/		return 0x8226A98C;
		  /* 8226A98Ch */ case    4:  		/* mr R3, R27 */
		/* 8226A98Ch case    4:*/		regs.R3 = regs.R27;
		/* 8226A98Ch case    4:*/		return 0x8226A990;
		  /* 8226A990h */ case    5:  		/* bl -3296 */
		/* 8226A990h case    5:*/		regs.LR = 0x8226A994; return 0x82269CB0;
		/* 8226A990h case    5:*/		return 0x8226A994;
		  /* 8226A994h */ case    6:  		/* lis R10, -32256 */
		/* 8226A994h case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 8226A994h case    6:*/		return 0x8226A998;
		  /* 8226A998h */ case    7:  		/* lis R11, -32251 */
		/* 8226A998h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8226A998h case    7:*/		return 0x8226A99C;
		  /* 8226A99Ch */ case    8:  		/* addi R29, R10, 17860 */
		/* 8226A99Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R10,0x45C4);
		/* 8226A99Ch case    8:*/		return 0x8226A9A0;
		  /* 8226A9A0h */ case    9:  		/* addi R28, R11, -16504 */
		/* 8226A9A0h case    9:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R11,0xFFFFBF88);
		/* 8226A9A0h case    9:*/		return 0x8226A9A4;
		  /* 8226A9A4h */ case   10:  		/* addi R11, R28, -64 */
		/* 8226A9A4h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R28,0xFFFFFFC0);
		/* 8226A9A4h case   10:*/		return 0x8226A9A8;
		  /* 8226A9A8h */ case   11:  		/* lwz R10, <#[R31]> */
		/* 8226A9A8h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 8226A9A8h case   11:*/		return 0x8226A9AC;
		  /* 8226A9ACh */ case   12:  		/* rlwinm R10, R10, 6, 26, 31 */
		/* 8226A9ACh case   12:*/		cpu::op::rlwinm<0,6,26,31>(regs,&regs.R10,regs.R10);
		/* 8226A9ACh case   12:*/		return 0x8226A9B0;
		  /* 8226A9B0h */ case   13:  		/* lbzx R30, <#[R10 + R11]> */
		/* 8226A9B0h case   13:*/		cpu::mem::load8z( regs, &regs.R30, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 8226A9B0h case   13:*/		return 0x8226A9B4;
		  /* 8226A9B4h */ case   14:  		/* cmpwi CR0, R30, 0 */
		/* 8226A9B4h case   14:*/		cpu::op::cmpwi<0>(regs,regs.R30,0x00000000);
		/* 8226A9B4h case   14:*/		return 0x8226A9B8;
		  /* 8226A9B8h */ case   15:  		/* bc 4, CR0_GT, 16 */
		/* 8226A9B8h case   15:*/		if ( !regs.CR[0].gt ) { return 0x8226A9C8;  }
		/* 8226A9B8h case   15:*/		return 0x8226A9BC;
		  /* 8226A9BCh */ case   16:  		/* mr R4, R29 */
		/* 8226A9BCh case   16:*/		regs.R4 = regs.R29;
		/* 8226A9BCh case   16:*/		return 0x8226A9C0;
	}
	return 0x8226A9C0;
} // Block from 8226A97Ch-8226A9C0h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8226A9C0h
// Function '??__Eg_instrNeverIssue@D3DXShader@@YAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A9C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A9C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A9C0);
		  /* 8226A9C0h */ case    0:  		/* mr R3, R27 */
		/* 8226A9C0h case    0:*/		regs.R3 = regs.R27;
		/* 8226A9C0h case    0:*/		return 0x8226A9C4;
		  /* 8226A9C4h */ case    1:  		/* bl -4068 */
		/* 8226A9C4h case    1:*/		regs.LR = 0x8226A9C8; return 0x822699E0;
		/* 8226A9C4h case    1:*/		return 0x8226A9C8;
	}
	return 0x8226A9C8;
} // Block from 8226A9C0h-8226A9C8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226A9C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A9C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A9C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A9C8);
		  /* 8226A9C8h */ case    0:  		/* cmpwi CR6, R30, 1 */
		/* 8226A9C8h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000001);
		/* 8226A9C8h case    0:*/		return 0x8226A9CC;
		  /* 8226A9CCh */ case    1:  		/* bc 4, CR6_EQ, 228 */
		/* 8226A9CCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x8226AAB0;  }
		/* 8226A9CCh case    1:*/		return 0x8226A9D0;
	}
	return 0x8226A9D0;
} // Block from 8226A9C8h-8226A9D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226A9D0h
// Function '??__Eg_depNeverIssue@D3DXShader@@YAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A9D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A9D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A9D0);
		  /* 8226A9D0h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 8226A9D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8226A9D0h case    0:*/		return 0x8226A9D4;
		  /* 8226A9D4h */ case    1:  		/* rlwinm. R11, R11, 0, 0, 0 */
		/* 8226A9D4h case    1:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R11,regs.R11);
		/* 8226A9D4h case    1:*/		return 0x8226A9D8;
		  /* 8226A9D8h */ case    2:  		/* bc 4, CR0_EQ, 12 */
		/* 8226A9D8h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8226A9E4;  }
		/* 8226A9D8h case    2:*/		return 0x8226A9DC;
		  /* 8226A9DCh */ case    3:  		/* li R10, 1 */
		/* 8226A9DCh case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 8226A9DCh case    3:*/		return 0x8226A9E0;
		  /* 8226A9E0h */ case    4:  		/* b 44 */
		/* 8226A9E0h case    4:*/		return 0x8226AA0C;
		/* 8226A9E0h case    4:*/		return 0x8226A9E4;
	}
	return 0x8226A9E4;
} // Block from 8226A9D0h-8226A9E4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8226A9E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A9E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A9E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A9E4);
		  /* 8226A9E4h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 8226A9E4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8226A9E4h case    0:*/		return 0x8226A9E8;
	}
	return 0x8226A9E8;
} // Block from 8226A9E4h-8226A9E8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226A9E8h
// Function '??__Fm_VertexDecls@?1??CreatePooledVertexDeclaration@ATG@@YAJPBU_D3DVERTEXELEMENT9@@PAPAUD3DVertexDeclaration@@@Z@YAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A9E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A9E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A9E8);
		  /* 8226A9E8h */ case    0:  		/* rlwinm. R10, R11, 0, 1, 1 */
		/* 8226A9E8h case    0:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R11);
		/* 8226A9E8h case    0:*/		return 0x8226A9EC;
		  /* 8226A9ECh */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 8226A9ECh case    1:*/		if ( !regs.CR[0].eq ) { return 0x8226A9F8;  }
		/* 8226A9ECh case    1:*/		return 0x8226A9F0;
		  /* 8226A9F0h */ case    2:  		/* li R10, 2 */
		/* 8226A9F0h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x2);
		/* 8226A9F0h case    2:*/		return 0x8226A9F4;
		  /* 8226A9F4h */ case    3:  		/* b 24 */
		/* 8226A9F4h case    3:*/		return 0x8226AA0C;
		/* 8226A9F4h case    3:*/		return 0x8226A9F8;
	}
	return 0x8226A9F8;
} // Block from 8226A9E8h-8226A9F8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226A9F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226A9F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226A9F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226A9F8);
		  /* 8226A9F8h */ case    0:  		/* rlwinm R11, R11, 0, 2, 2 */
		/* 8226A9F8h case    0:*/		cpu::op::rlwinm<0,0,2,2>(regs,&regs.R11,regs.R11);
		/* 8226A9F8h case    0:*/		return 0x8226A9FC;
		  /* 8226A9FCh */ case    1:  		/* li R10, 3 */
		/* 8226A9FCh case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 8226A9FCh case    1:*/		return 0x8226AA00;
		  /* 8226AA00h */ case    2:  		/* addic R11, R11, -1 */
		/* 8226AA00h case    2:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 8226AA00h case    2:*/		return 0x8226AA04;
		  /* 8226AA04h */ case    3:  		/* subfe R11, R11, R11 */
		/* 8226AA04h case    3:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 8226AA04h case    3:*/		return 0x8226AA08;
		  /* 8226AA08h */ case    4:  		/* and R10, R11, R10 */
		/* 8226AA08h case    4:*/		cpu::op::and<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 8226AA08h case    4:*/		return 0x8226AA0C;
	}
	return 0x8226AA0C;
} // Block from 8226A9F8h-8226AA0Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8226AA0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AA0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AA0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AA0C);
		  /* 8226AA0Ch */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 8226AA0Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8226AA0Ch case    0:*/		return 0x8226AA10;
		  /* 8226AA10h */ case    1:  		/* rlwinm. R9, R11, 0, 2, 2 */
		/* 8226AA10h case    1:*/		cpu::op::rlwinm<1,0,2,2>(regs,&regs.R9,regs.R11);
		/* 8226AA10h case    1:*/		return 0x8226AA14;
		  /* 8226AA14h */ case    2:  		/* bc 4, CR0_EQ, 40 */
		/* 8226AA14h case    2:*/		if ( !regs.CR[0].eq ) { return 0x8226AA3C;  }
		/* 8226AA14h case    2:*/		return 0x8226AA18;
		  /* 8226AA18h */ case    3:  		/* cmpwi CR6, R23, 0 */
		/* 8226AA18h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R23,0x00000000);
		/* 8226AA18h case    3:*/		return 0x8226AA1C;
		  /* 8226AA1Ch */ case    4:  		/* bc 12, CR6_EQ, 32 */
		/* 8226AA1Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x8226AA3C;  }
		/* 8226AA1Ch case    4:*/		return 0x8226AA20;
		  /* 8226AA20h */ case    5:  		/* lwz R10, <#[R31 + 4]> */
		/* 8226AA20h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8226AA20h case    5:*/		return 0x8226AA24;
		  /* 8226AA24h */ case    6:  		/* rlwinm R4, R11, 0, 24, 31 */
		/* 8226AA24h case    6:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R4,regs.R11);
		/* 8226AA24h case    6:*/		return 0x8226AA28;
		  /* 8226AA28h */ case    7:  		/* mr R3, R27 */
		/* 8226AA28h case    7:*/		regs.R3 = regs.R27;
		/* 8226AA28h case    7:*/		return 0x8226AA2C;
		  /* 8226AA2Ch */ case    8:  		/* rlwinm R6, R10, 0, 24, 31 */
		/* 8226AA2Ch case    8:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R6,regs.R10);
		/* 8226AA2Ch case    8:*/		return 0x8226AA30;
		  /* 8226AA30h */ case    9:  		/* rlwinm R5, R10, 8, 31, 31 */
		/* 8226AA30h case    9:*/		cpu::op::rlwinm<0,8,31,31>(regs,&regs.R5,regs.R10);
		/* 8226AA30h case    9:*/		return 0x8226AA34;
		  /* 8226AA34h */ case   10:  		/* bl -1852 */
		/* 8226AA34h case   10:*/		regs.LR = 0x8226AA38; return 0x8226A2F8;
		/* 8226AA34h case   10:*/		return 0x8226AA38;
		  /* 8226AA38h */ case   11:  		/* b 368 */
		/* 8226AA38h case   11:*/		return 0x8226ABA8;
		/* 8226AA38h case   11:*/		return 0x8226AA3C;
	}
	return 0x8226AA3C;
} // Block from 8226AA0Ch-8226AA3Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 8226AA3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AA3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AA3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AA3C);
		  /* 8226AA3Ch */ case    0:  		/* rlwinm. R11, R26, 0, 24, 31 */
		/* 8226AA3Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R26);
		/* 8226AA3Ch case    0:*/		return 0x8226AA40;
	}
	return 0x8226AA40;
} // Block from 8226AA3Ch-8226AA40h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226AA40h
// Function '??__Fnomem@?5???2@YAPAXI@Z@YAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AA40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AA40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AA40);
		  /* 8226AA40h */ case    0:  		/* bc 12, CR0_EQ, 12 */
		/* 8226AA40h case    0:*/		if ( regs.CR[0].eq ) { return 0x8226AA4C;  }
		/* 8226AA40h case    0:*/		return 0x8226AA44;
		  /* 8226AA44h */ case    1:  		/* li R11, 1 */
		/* 8226AA44h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8226AA44h case    1:*/		return 0x8226AA48;
		  /* 8226AA48h */ case    2:  		/* b 16 */
		/* 8226AA48h case    2:*/		return 0x8226AA58;
		/* 8226AA48h case    2:*/		return 0x8226AA4C;
	}
	return 0x8226AA4C;
} // Block from 8226AA40h-8226AA4Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 8226AA4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AA4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AA4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AA4C);
		  /* 8226AA4Ch */ case    0:  		/* lwz R11, <#[R31]> */
		/* 8226AA4Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8226AA4Ch case    0:*/		return 0x8226AA50;
		  /* 8226AA50h */ case    1:  		/* rlwinm R11, R11, 6, 26, 31 */
		/* 8226AA50h case    1:*/		cpu::op::rlwinm<0,6,26,31>(regs,&regs.R11,regs.R11);
		/* 8226AA50h case    1:*/		return 0x8226AA54;
		  /* 8226AA54h */ case    2:  		/* lbzx R11, <#[R11 + R28]> */
		/* 8226AA54h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 8226AA54h case    2:*/		return 0x8226AA58;
	}
	return 0x8226AA58;
} // Block from 8226AA4Ch-8226AA58h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8226AA58h
// Function 'XamShowMessageBoxUIEx'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AA58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AA58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AA58);
		  /* 8226AA58h */ case    0:  		/* cmpwi CR6, R10, 3 */
		/* 8226AA58h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000003);
		/* 8226AA58h case    0:*/		return 0x8226AA5C;
		  /* 8226AA5Ch */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 8226AA5Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x8226AA6C;  }
		/* 8226AA5Ch case    1:*/		return 0x8226AA60;
		  /* 8226AA60h */ case    2:  		/* lwz R10, <#[R31 + 4]> */
		/* 8226AA60h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8226AA60h case    2:*/		return 0x8226AA64;
		  /* 8226AA64h */ case    3:  		/* rlwinm R6, R10, 1, 31, 31 */
		/* 8226AA64h case    3:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R6,regs.R10);
		/* 8226AA64h case    3:*/		return 0x8226AA68;
	}
	return 0x8226AA68;
} // Block from 8226AA58h-8226AA68h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AA68h
// Function 'XGetLanguage'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AA68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AA68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AA68);
		  /* 8226AA68h */ case    0:  		/* b 16 */
		/* 8226AA68h case    0:*/		return 0x8226AA78;
		/* 8226AA68h case    0:*/		return 0x8226AA6C;
	}
	return 0x8226AA6C;
} // Block from 8226AA68h-8226AA6Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226AA6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AA6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AA6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AA6C);
		  /* 8226AA6Ch */ case    0:  		/* cmpwi CR6, R10, 2 */
		/* 8226AA6Ch case    0:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000002);
		/* 8226AA6Ch case    0:*/		return 0x8226AA70;
		  /* 8226AA70h */ case    1:  		/* lwz R10, <#[R31 + 4]> */
		/* 8226AA70h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 8226AA70h case    1:*/		return 0x8226AA74;
		  /* 8226AA74h */ case    2:  		/* rlwinm R6, R10, 2, 31, 31 */
		/* 8226AA74h case    2:*/		cpu::op::rlwinm<0,2,31,31>(regs,&regs.R6,regs.R10);
		/* 8226AA74h case    2:*/		return 0x8226AA78;
	}
	return 0x8226AA78;
} // Block from 8226AA6Ch-8226AA78h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8226AA78h
// Function 'XGetAVPack'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AA78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AA78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AA78);
		  /* 8226AA78h */ case    0:  		/* lwz R7, <#[R31 + 4]> */
		/* 8226AA78h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000004) );
		/* 8226AA78h case    0:*/		return 0x8226AA7C;
		  /* 8226AA7Ch */ case    1:  		/* mr R3, R27 */
		/* 8226AA7Ch case    1:*/		regs.R3 = regs.R27;
		/* 8226AA7Ch case    1:*/		return 0x8226AA80;
		  /* 8226AA80h */ case    2:  		/* lwz R4, <#[R31 + 8]> */
		/* 8226AA80h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000008) );
		/* 8226AA80h case    2:*/		return 0x8226AA84;
		  /* 8226AA84h */ case    3:  		/* lwz R8, <#[R31]> */
		/* 8226AA84h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 8226AA84h case    3:*/		return 0x8226AA88;
	}
	return 0x8226AA88;
} // Block from 8226AA78h-8226AA88h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AA88h
// Function 'XamTerminateTitle'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AA88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AA88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AA88);
		  /* 8226AA88h */ case    0:  		/* rlwinm R10, R7, 0, 24, 31 */
		/* 8226AA88h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R7);
		/* 8226AA88h case    0:*/		return 0x8226AA8C;
		  /* 8226AA8Ch */ case    1:  		/* rlwinm R9, R7, 8, 31, 31 */
		/* 8226AA8Ch case    1:*/		cpu::op::rlwinm<0,8,31,31>(regs,&regs.R9,regs.R7);
		/* 8226AA8Ch case    1:*/		return 0x8226AA90;
		  /* 8226AA90h */ case    2:  		/* stb R24, <#[R1 + 95]> */
		/* 8226AA90h case    2:*/		cpu::mem::store8( regs, regs.R24, (uint32)(regs.R1 + 0x0000005F) );
		/* 8226AA90h case    2:*/		return 0x8226AA94;
		  /* 8226AA94h */ case    3:  		/* rlwinm R5, R4, 0, 24, 31 */
		/* 8226AA94h case    3:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R5,regs.R4);
		/* 8226AA94h case    3:*/		return 0x8226AA98;
	}
	return 0x8226AA98;
} // Block from 8226AA88h-8226AA98h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AA98h
// Function 'KeGetCurrentProcessType'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AA98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AA98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AA98);
		  /* 8226AA98h */ case    0:  		/* stw R11, <#[R1 + 84]> */
		/* 8226AA98h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8226AA98h case    0:*/		return 0x8226AA9C;
		  /* 8226AA9Ch */ case    1:  		/* rlwinm R8, R8, 25, 31, 31 */
		/* 8226AA9Ch case    1:*/		cpu::op::rlwinm<0,25,31,31>(regs,&regs.R8,regs.R8);
		/* 8226AA9Ch case    1:*/		return 0x8226AAA0;
		  /* 8226AAA0h */ case    2:  		/* rlwinm R7, R7, 3, 31, 31 */
		/* 8226AAA0h case    2:*/		cpu::op::rlwinm<0,3,31,31>(regs,&regs.R7,regs.R7);
		/* 8226AAA0h case    2:*/		return 0x8226AAA4;
		  /* 8226AAA4h */ case    3:  		/* rlwinm R4, R4, 3, 31, 31 */
		/* 8226AAA4h case    3:*/		cpu::op::rlwinm<0,3,31,31>(regs,&regs.R4,regs.R4);
		/* 8226AAA4h case    3:*/		return 0x8226AAA8;
	}
	return 0x8226AAA8;
} // Block from 8226AA98h-8226AAA8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AAA8h
// Function 'KfAcquireSpinLock'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AAA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AAA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AAA8);
		  /* 8226AAA8h */ case    0:  		/* bl -2688 */
		/* 8226AAA8h case    0:*/		regs.LR = 0x8226AAAC; return 0x8226A028;
		/* 8226AAA8h case    0:*/		return 0x8226AAAC;
		  /* 8226AAACh */ case    1:  		/* b 252 */
		/* 8226AAACh case    1:*/		return 0x8226ABA8;
		/* 8226AAACh case    1:*/		return 0x8226AAB0;
	}
	return 0x8226AAB0;
} // Block from 8226AAA8h-8226AAB0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226AAB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AAB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AAB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AAB0);
		  /* 8226AAB0h */ case    0:  		/* cmpwi CR6, R30, 2 */
		/* 8226AAB0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000002);
		/* 8226AAB0h case    0:*/		return 0x8226AAB4;
		  /* 8226AAB4h */ case    1:  		/* bc 4, CR6_EQ, 244 */
		/* 8226AAB4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8226ABA8;  }
		/* 8226AAB4h case    1:*/		return 0x8226AAB8;
	}
	return 0x8226AAB8;
} // Block from 8226AAB0h-8226AAB8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226AAB8h
// Function 'RtlSnprintf'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AAB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AAB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AAB8);
		  /* 8226AAB8h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 8226AAB8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8226AAB8h case    0:*/		return 0x8226AABC;
		  /* 8226AABCh */ case    1:  		/* rlwinm. R10, R11, 1, 31, 31 */
		/* 8226AABCh case    1:*/		cpu::op::rlwinm<1,1,31,31>(regs,&regs.R10,regs.R11);
		/* 8226AABCh case    1:*/		return 0x8226AAC0;
		  /* 8226AAC0h */ case    2:  		/* rlwinm R11, R11, 2, 31, 31 */
		/* 8226AAC0h case    2:*/		cpu::op::rlwinm<0,2,31,31>(regs,&regs.R11,regs.R11);
		/* 8226AAC0h case    2:*/		return 0x8226AAC4;
		  /* 8226AAC4h */ case    3:  		/* subf R11, R10, R11 */
		/* 8226AAC4h case    3:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 8226AAC4h case    3:*/		return 0x8226AAC8;
	}
	return 0x8226AAC8;
} // Block from 8226AAB8h-8226AAC8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AAC8h
// Function 'MmFreePhysicalMemory'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AAC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AAC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AAC8);
		  /* 8226AAC8h */ case    0:  		/* addi R11, R11, 4 */
		/* 8226AAC8h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 8226AAC8h case    0:*/		return 0x8226AACC;
		  /* 8226AACCh */ case    1:  		/* bc 12, CR0_EQ, 40 */
		/* 8226AACCh case    1:*/		if ( regs.CR[0].eq ) { return 0x8226AAF4;  }
		/* 8226AACCh case    1:*/		return 0x8226AAD0;
		  /* 8226AAD0h */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 8226AAD0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8226AAD0h case    2:*/		return 0x8226AAD4;
		  /* 8226AAD4h */ case    3:  		/* rlwinm R10, R10, 2, 30, 31 */
		/* 8226AAD4h case    3:*/		cpu::op::rlwinm<0,2,30,31>(regs,&regs.R10,regs.R10);
		/* 8226AAD4h case    3:*/		return 0x8226AAD8;
	}
	return 0x8226AAD8;
} // Block from 8226AAC8h-8226AAD8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AAD8h
// Function 'KfReleaseSpinLock'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AAD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AAD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AAD8);
		  /* 8226AAD8h */ case    0:  		/* nor R10, R10, R10 */
		/* 8226AAD8h case    0:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 8226AAD8h case    0:*/		return 0x8226AADC;
		  /* 8226AADCh */ case    1:  		/* rlwinm R10, R10, 1, 30, 30 */
		/* 8226AADCh case    1:*/		cpu::op::rlwinm<0,1,30,30>(regs,&regs.R10,regs.R10);
		/* 8226AADCh case    1:*/		return 0x8226AAE0;
		  /* 8226AAE0h */ case    2:  		/* cmpwi CR6, R10, 3 */
		/* 8226AAE0h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000003);
		/* 8226AAE0h case    2:*/		return 0x8226AAE4;
		  /* 8226AAE4h */ case    3:  		/* bc 4, CR6_EQ, 16 */
		/* 8226AAE4h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8226AAF4;  }
		/* 8226AAE4h case    3:*/		return 0x8226AAE8;
	}
	return 0x8226AAE8;
} // Block from 8226AAD8h-8226AAE8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AAE8h
// Function 'KeSetEvent'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AAE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AAE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AAE8);
		  /* 8226AAE8h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 8226AAE8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8226AAE8h case    0:*/		return 0x8226AAEC;
		  /* 8226AAECh */ case    1:  		/* rlwinm R6, R11, 1, 31, 31 */
		/* 8226AAECh case    1:*/		cpu::op::rlwinm<0,1,31,31>(regs,&regs.R6,regs.R11);
		/* 8226AAECh case    1:*/		return 0x8226AAF0;
		  /* 8226AAF0h */ case    2:  		/* b 16 */
		/* 8226AAF0h case    2:*/		return 0x8226AB00;
		/* 8226AAF0h case    2:*/		return 0x8226AAF4;
	}
	return 0x8226AAF4;
} // Block from 8226AAE8h-8226AAF4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8226AAF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AAF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AAF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AAF4);
		  /* 8226AAF4h */ case    0:  		/* cmpwi CR6, R11, 2 */
		/* 8226AAF4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 8226AAF4h case    0:*/		return 0x8226AAF8;
	}
	return 0x8226AAF8;
} // Block from 8226AAF4h-8226AAF8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226AAF8h
// Function 'KeQueryPerformanceFrequency'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AAF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AAF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AAF8);
		  /* 8226AAF8h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 8226AAF8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8226AAF8h case    0:*/		return 0x8226AAFC;
		  /* 8226AAFCh */ case    1:  		/* rlwinm R6, R11, 2, 31, 31 */
		/* 8226AAFCh case    1:*/		cpu::op::rlwinm<0,2,31,31>(regs,&regs.R6,regs.R11);
		/* 8226AAFCh case    1:*/		return 0x8226AB00;
	}
	return 0x8226AB00;
} // Block from 8226AAF8h-8226AB00h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226AB00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AB00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AB00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AB00);
		  /* 8226AB00h */ case    0:  		/* lwz R11, <#[R31]> */
		/* 8226AB00h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8226AB00h case    0:*/		return 0x8226AB04;
		  /* 8226AB04h */ case    1:  		/* li R4, 0 */
		/* 8226AB04h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 8226AB04h case    1:*/		return 0x8226AB08;
	}
	return 0x8226AB08;
} // Block from 8226AB00h-8226AB08h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226AB08h
// Function 'VdPersistDisplay'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AB08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AB08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AB08);
		  /* 8226AB08h */ case    0:  		/* lwz R7, <#[R31 + 4]> */
		/* 8226AB08h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R31 + 0x00000004) );
		/* 8226AB08h case    0:*/		return 0x8226AB0C;
		  /* 8226AB0Ch */ case    1:  		/* rlwinm R5, R11, 6, 26, 31 */
		/* 8226AB0Ch case    1:*/		cpu::op::rlwinm<0,6,26,31>(regs,&regs.R5,regs.R11);
		/* 8226AB0Ch case    1:*/		return 0x8226AB10;
		  /* 8226AB10h */ case    2:  		/* lwz R3, <#[R31 + 8]> */
		/* 8226AB10h case    2:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000008) );
		/* 8226AB10h case    2:*/		return 0x8226AB14;
		  /* 8226AB14h */ case    3:  		/* rlwinm R8, R11, 25, 31, 31 */
		/* 8226AB14h case    3:*/		cpu::op::rlwinm<0,25,31,31>(regs,&regs.R8,regs.R11);
		/* 8226AB14h case    3:*/		return 0x8226AB18;
	}
	return 0x8226AB18;
} // Block from 8226AB08h-8226AB18h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AB18h
// Function 'VdSwap'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AB18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AB18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AB18);
		  /* 8226AB18h */ case    0:  		/* stb R25, <#[R1 + 95]> */
		/* 8226AB18h case    0:*/		cpu::mem::store8( regs, regs.R25, (uint32)(regs.R1 + 0x0000005F) );
		/* 8226AB18h case    0:*/		return 0x8226AB1C;
		  /* 8226AB1Ch */ case    1:  		/* rlwinm R10, R7, 0, 24, 31 */
		/* 8226AB1Ch case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R7);
		/* 8226AB1Ch case    1:*/		return 0x8226AB20;
		  /* 8226AB20h */ case    2:  		/* rlwinm R9, R7, 8, 31, 31 */
		/* 8226AB20h case    2:*/		cpu::op::rlwinm<0,8,31,31>(regs,&regs.R9,regs.R7);
		/* 8226AB20h case    2:*/		return 0x8226AB24;
		  /* 8226AB24h */ case    3:  		/* rlwinm R7, R7, 3, 31, 31 */
		/* 8226AB24h case    3:*/		cpu::op::rlwinm<0,3,31,31>(regs,&regs.R7,regs.R7);
		/* 8226AB24h case    3:*/		return 0x8226AB28;
	}
	return 0x8226AB28;
} // Block from 8226AB18h-8226AB28h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AB28h
// Function 'VdGetSystemCommandBuffer'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AB28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AB28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AB28);
		  /* 8226AB28h */ case    0:  		/* lbzx R11, <#[R5 + R28]> */
		/* 8226AB28h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R5 + regs.R28 + 0x00000000) );
		/* 8226AB28h case    0:*/		return 0x8226AB2C;
		  /* 8226AB2Ch */ case    1:  		/* rlwinm R5, R3, 0, 24, 31 */
		/* 8226AB2Ch case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R5,regs.R3);
		/* 8226AB2Ch case    1:*/		return 0x8226AB30;
		  /* 8226AB30h */ case    2:  		/* mr R3, R27 */
		/* 8226AB30h case    2:*/		regs.R3 = regs.R27;
		/* 8226AB30h case    2:*/		return 0x8226AB34;
		  /* 8226AB34h */ case    3:  		/* stw R11, <#[R1 + 84]> */
		/* 8226AB34h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8226AB34h case    3:*/		return 0x8226AB38;
	}
	return 0x8226AB38;
} // Block from 8226AB28h-8226AB38h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AB38h
// Function 'VdEnableDisableClockGating'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AB38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AB38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AB38);
		  /* 8226AB38h */ case    0:  		/* bl -2832 */
		/* 8226AB38h case    0:*/		regs.LR = 0x8226AB3C; return 0x8226A028;
		/* 8226AB38h case    0:*/		return 0x8226AB3C;
		  /* 8226AB3Ch */ case    1:  		/* mr R4, R29 */
		/* 8226AB3Ch case    1:*/		regs.R4 = regs.R29;
		/* 8226AB3Ch case    1:*/		return 0x8226AB40;
		  /* 8226AB40h */ case    2:  		/* mr R3, R27 */
		/* 8226AB40h case    2:*/		regs.R3 = regs.R27;
		/* 8226AB40h case    2:*/		return 0x8226AB44;
		  /* 8226AB44h */ case    3:  		/* bl -4452 */
		/* 8226AB44h case    3:*/		regs.LR = 0x8226AB48; return 0x822699E0;
		/* 8226AB44h case    3:*/		return 0x8226AB48;
	}
	return 0x8226AB48;
} // Block from 8226AB38h-8226AB48h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AB48h
// Function 'RtlEnterCriticalSection'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AB48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AB48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AB48);
		  /* 8226AB48h */ case    0:  		/* lwz R11, <#[R31 + 4]> */
		/* 8226AB48h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 8226AB48h case    0:*/		return 0x8226AB4C;
		  /* 8226AB4Ch */ case    1:  		/* lwz R8, <#[R31 + 8]> */
		/* 8226AB4Ch case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000008) );
		/* 8226AB4Ch case    1:*/		return 0x8226AB50;
		  /* 8226AB50h */ case    2:  		/* mr R9, R11 */
		/* 8226AB50h case    2:*/		regs.R9 = regs.R11;
		/* 8226AB50h case    2:*/		return 0x8226AB54;
		  /* 8226AB54h */ case    3:  		/* addi R11, R11, 1 */
		/* 8226AB54h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 8226AB54h case    3:*/		return 0x8226AB58;
	}
	return 0x8226AB58;
} // Block from 8226AB48h-8226AB58h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AB58h
// Function 'RtlSprintf'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AB58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AB58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AB58);
		  /* 8226AB58h */ case    0:  		/* rlwinm R10, R11, 6, 24, 25 */
		/* 8226AB58h case    0:*/		cpu::op::rlwinm<0,6,24,25>(regs,&regs.R10,regs.R11);
		/* 8226AB58h case    0:*/		return 0x8226AB5C;
		  /* 8226AB5Ch */ case    1:  		/* lwz R11, <#[R31]> */
		/* 8226AB5Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 8226AB5Ch case    1:*/		return 0x8226AB60;
		  /* 8226AB60h */ case    2:  		/* mr R7, R11 */
		/* 8226AB60h case    2:*/		regs.R7 = regs.R11;
		/* 8226AB60h case    2:*/		return 0x8226AB64;
		  /* 8226AB64h */ case    3:  		/* rlwinm. R11, R11, 0, 24, 24 */
		/* 8226AB64h case    3:*/		cpu::op::rlwinm<1,0,24,24>(regs,&regs.R11,regs.R11);
		/* 8226AB64h case    3:*/		return 0x8226AB68;
	}
	return 0x8226AB68;
} // Block from 8226AB58h-8226AB68h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AB68h
// Function 'RtlLeaveCriticalSection'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AB68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AB68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AB68);
		  /* 8226AB68h */ case    0:  		/* rlwimi R7, R8, 30, 4, 4 */
		/* 8226AB68h case    0:*/		cpu::op::rlwimi<0,30,4,4>(regs,&regs.R7,regs.R8);
		/* 8226AB68h case    0:*/		return 0x8226AB6C;
		  /* 8226AB6Ch */ case    1:  		/* rlwimi R9, R7, 6, 30, 31 */
		/* 8226AB6Ch case    1:*/		cpu::op::rlwimi<0,6,30,31>(regs,&regs.R9,regs.R7);
		/* 8226AB6Ch case    1:*/		return 0x8226AB70;
		  /* 8226AB70h */ case    2:  		/* rlwinm R5, R9, 0, 26, 31 */
		/* 8226AB70h case    2:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R5,regs.R9);
		/* 8226AB70h case    2:*/		return 0x8226AB74;
		  /* 8226AB74h */ case    3:  		/* bc 12, CR0_EQ, 8 */
		/* 8226AB74h case    3:*/		if ( regs.CR[0].eq ) { return 0x8226AB7C;  }
		/* 8226AB74h case    3:*/		return 0x8226AB78;
	}
	return 0x8226AB78;
} // Block from 8226AB68h-8226AB78h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AB78h
// Function 'VdSetSystemCommandBufferGpuIdentifierAddress'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AB78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AB78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AB78);
		  /* 8226AB78h */ case    0:  		/* ori R5, R5, 128 */
		/* 8226AB78h case    0:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R5,0x80);
		/* 8226AB78h case    0:*/		return 0x8226AB7C;
	}
	return 0x8226AB7C;
} // Block from 8226AB78h-8226AB7Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226AB7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AB7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AB7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AB7C);
		  /* 8226AB7Ch */ case    0:  		/* lbz R9, <#[R31 + 4]> */
		/* 8226AB7Ch case    0:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000004) );
		/* 8226AB7Ch case    0:*/		return 0x8226AB80;
		  /* 8226AB80h */ case    1:  		/* li R11, 1 */
		/* 8226AB80h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8226AB80h case    1:*/		return 0x8226AB84;
		  /* 8226AB84h */ case    2:  		/* li R8, 0 */
		/* 8226AB84h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8226AB84h case    2:*/		return 0x8226AB88;
	}
	return 0x8226AB88;
} // Block from 8226AB7Ch-8226AB88h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8226AB88h
// Function 'VdVerifyMEInitCommand'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AB88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AB88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AB88);
		  /* 8226AB88h */ case    0:  		/* stb R25, <#[R1 + 95]> */
		/* 8226AB88h case    0:*/		cpu::mem::store8( regs, regs.R25, (uint32)(regs.R1 + 0x0000005F) );
		/* 8226AB88h case    0:*/		return 0x8226AB8C;
		  /* 8226AB8Ch */ case    1:  		/* rlwinm R9, R9, 0, 31, 31 */
		/* 8226AB8Ch case    1:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R9,regs.R9);
		/* 8226AB8Ch case    1:*/		return 0x8226AB90;
		  /* 8226AB90h */ case    2:  		/* stw R11, <#[R1 + 84]> */
		/* 8226AB90h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8226AB90h case    2:*/		return 0x8226AB94;
		  /* 8226AB94h */ case    3:  		/* li R7, 0 */
		/* 8226AB94h case    3:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8226AB94h case    3:*/		return 0x8226AB98;
	}
	return 0x8226AB98;
} // Block from 8226AB88h-8226AB98h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AB98h
// Function 'MmGetPhysicalAddress'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AB98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AB98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AB98);
		  /* 8226AB98h */ case    0:  		/* li R6, 0 */
		/* 8226AB98h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8226AB98h case    0:*/		return 0x8226AB9C;
		  /* 8226AB9Ch */ case    1:  		/* li R4, 1 */
		/* 8226AB9Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8226AB9Ch case    1:*/		return 0x8226ABA0;
		  /* 8226ABA0h */ case    2:  		/* mr R3, R27 */
		/* 8226ABA0h case    2:*/		regs.R3 = regs.R27;
		/* 8226ABA0h case    2:*/		return 0x8226ABA4;
		  /* 8226ABA4h */ case    3:  		/* bl -2940 */
		/* 8226ABA4h case    3:*/		regs.LR = 0x8226ABA8; return 0x8226A028;
		/* 8226ABA4h case    3:*/		return 0x8226ABA8;
	}
	return 0x8226ABA8;
} // Block from 8226AB98h-8226ABA8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226ABA8h
// Function 'KeReleaseSpinLockFromRaisedIrql'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226ABA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226ABA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226ABA8);
		  /* 8226ABA8h */ case    0:  		/* addi R1, R1, 176 */
		/* 8226ABA8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 8226ABA8h case    0:*/		return 0x8226ABAC;
		  /* 8226ABACh */ case    1:  		/* b -1939736 */
		/* 8226ABACh case    1:*/		return 0x82091294;
		/* 8226ABACh case    1:*/		return 0x8226ABB0;
	}
	return 0x8226ABB0;
} // Block from 8226ABA8h-8226ABB0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226ABB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226ABB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226ABB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226ABB0);
		  /* 8226ABB0h */ case    0:  		/* mfspr R12, LR */
		/* 8226ABB0h case    0:*/		regs.R12 = regs.LR;
		/* 8226ABB0h case    0:*/		return 0x8226ABB4;
		  /* 8226ABB4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8226ABB4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8226ABB4h case    1:*/		return 0x8226ABB8;
	}
	return 0x8226ABB8;
} // Block from 8226ABB0h-8226ABB8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226ABB8h
// Function 'KeInsertQueueDpc'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226ABB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226ABB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226ABB8);
		  /* 8226ABB8h */ case    0:  		/* stwu R1, <#[R1 - 128]> */
		/* 8226ABB8h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 8226ABB8h case    0:*/		return 0x8226ABBC;
		  /* 8226ABBCh */ case    1:  		/* lis R10, -32255 */
		/* 8226ABBCh case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 8226ABBCh case    1:*/		return 0x8226ABC0;
		  /* 8226ABC0h */ case    2:  		/* lwz R11, <#[R3 + 8]> */
		/* 8226ABC0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8226ABC0h case    2:*/		return 0x8226ABC4;
		  /* 8226ABC4h */ case    3:  		/* lis R9, -32255 */
		/* 8226ABC4h case    3:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 8226ABC4h case    3:*/		return 0x8226ABC8;
	}
	return 0x8226ABC8;
} // Block from 8226ABB8h-8226ABC8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226ABC8h
// Function 'VdEnableRingBufferRPtrWriteBack'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226ABC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226ABC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226ABC8);
		  /* 8226ABC8h */ case    0:  		/* addi R10, R10, 5216 */
		/* 8226ABC8h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1460);
		/* 8226ABC8h case    0:*/		return 0x8226ABCC;
		  /* 8226ABCCh */ case    1:  		/* addi R9, R9, 5224 */
		/* 8226ABCCh case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1468);
		/* 8226ABCCh case    1:*/		return 0x8226ABD0;
		  /* 8226ABD0h */ case    2:  		/* rlwinm. R11, R11, 26, 31, 31 */
		/* 8226ABD0h case    2:*/		cpu::op::rlwinm<1,26,31,31>(regs,&regs.R11,regs.R11);
		/* 8226ABD0h case    2:*/		return 0x8226ABD4;
		  /* 8226ABD4h */ case    3:  		/* stw R10, <#[R1 + 112]> */
		/* 8226ABD4h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000070) );
		/* 8226ABD4h case    3:*/		return 0x8226ABD8;
	}
	return 0x8226ABD8;
} // Block from 8226ABC8h-8226ABD8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226ABD8h
// Function 'VdInitializeRingBuffer'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226ABD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226ABD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226ABD8);
		  /* 8226ABD8h */ case    0:  		/* stw R9, <#[R1 + 116]> */
		/* 8226ABD8h case    0:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000074) );
		/* 8226ABD8h case    0:*/		return 0x8226ABDC;
		  /* 8226ABDCh */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 8226ABDCh case    1:*/		if ( !regs.CR[0].eq ) { return 0x8226ABE8;  }
		/* 8226ABDCh case    1:*/		return 0x8226ABE0;
		  /* 8226ABE0h */ case    2:  		/* cmplw CR6, R5, R6 */
		/* 8226ABE0h case    2:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R6);
		/* 8226ABE0h case    2:*/		return 0x8226ABE4;
		  /* 8226ABE4h */ case    3:  		/* bc 12, CR6_EQ, 32 */
		/* 8226ABE4h case    3:*/		if ( regs.CR[6].eq ) { return 0x8226AC04;  }
		/* 8226ABE4h case    3:*/		return 0x8226ABE8;
	}
	return 0x8226ABE8;
} // Block from 8226ABD8h-8226ABE8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226ABE8h
// Function 'KeAcquireSpinLockAtRaisedIrql'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226ABE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226ABE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226ABE8);
		  /* 8226ABE8h */ case    0:  		/* rlwinm R11, R5, 2, 0, 29 */
		/* 8226ABE8h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R5);
		/* 8226ABE8h case    0:*/		return 0x8226ABEC;
		  /* 8226ABECh */ case    1:  		/* addi R10, R1, 112 */
		/* 8226ABECh case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x70);
		/* 8226ABECh case    1:*/		return 0x8226ABF0;
		  /* 8226ABF0h */ case    2:  		/* lis R9, -32251 */
		/* 8226ABF0h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8205);
		/* 8226ABF0h case    2:*/		return 0x8226ABF4;
		  /* 8226ABF4h */ case    3:  		/* mr R5, R4 */
		/* 8226ABF4h case    3:*/		regs.R5 = regs.R4;
		/* 8226ABF4h case    3:*/		return 0x8226ABF8;
	}
	return 0x8226ABF8;
} // Block from 8226ABE8h-8226ABF8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226ABF8h
// Function 'VdGetCurrentDisplayGamma'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226ABF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226ABF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226ABF8);
		  /* 8226ABF8h */ case    0:  		/* addi R4, R9, -16244 */
		/* 8226ABF8h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0xFFFFC08C);
		/* 8226ABF8h case    0:*/		return 0x8226ABFC;
		  /* 8226ABFCh */ case    1:  		/* lwzx R6, <#[R11 + R10]> */
		/* 8226ABFCh case    1:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8226ABFCh case    1:*/		return 0x8226AC00;
		  /* 8226AC00h */ case    2:  		/* bl -4640 */
		/* 8226AC00h case    2:*/		regs.LR = 0x8226AC04; return 0x822699E0;
		/* 8226AC00h case    2:*/		return 0x8226AC04;
	}
	return 0x8226AC04;
} // Block from 8226ABF8h-8226AC04h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8226AC04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AC04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AC04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AC04);
		  /* 8226AC04h */ case    0:  		/* addi R1, R1, 128 */
		/* 8226AC04h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 8226AC04h case    0:*/		return 0x8226AC08;
	}
	return 0x8226AC08;
} // Block from 8226AC04h-8226AC08h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226AC08h
// Function 'KeBugCheck'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AC08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AC08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AC08);
		  /* 8226AC08h */ case    0:  		/* lwz R12, <#[R1 - 8]> */
		/* 8226AC08h case    0:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8226AC08h case    0:*/		return 0x8226AC0C;
		  /* 8226AC0Ch */ case    1:  		/* mtspr LR, R12 */
		/* 8226AC0Ch case    1:*/		regs.LR = regs.R12;
		/* 8226AC0Ch case    1:*/		return 0x8226AC10;
		  /* 8226AC10h */ case    2:  		/* bclr 20, CR0_LT */
		/* 8226AC10h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8226AC10h case    2:*/		return 0x8226AC14;
	}
	return 0x8226AC14;
} // Block from 8226AC08h-8226AC14h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8226AC14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AC14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AC14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AC14);
		  /* 8226AC14h */ case    0:  		/* nop */
		/* 8226AC14h case    0:*/		cpu::op::nop();
		/* 8226AC14h case    0:*/		return 0x8226AC18;
	}
	return 0x8226AC18;
} // Block from 8226AC14h-8226AC18h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226AC18h
// Function 'RtlInitializeCriticalSection'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AC18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AC18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AC18);
		  /* 8226AC18h */ case    0:  		/* mfspr R12, LR */
		/* 8226AC18h case    0:*/		regs.R12 = regs.LR;
		/* 8226AC18h case    0:*/		return 0x8226AC1C;
		  /* 8226AC1Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8226AC1Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8226AC1Ch case    1:*/		return 0x8226AC20;
		  /* 8226AC20h */ case    2:  		/* std R5, <#[R1 + 32]> */
		/* 8226AC20h case    2:*/		cpu::mem::store64( regs, regs.R5, (uint32)(regs.R1 + 0x00000020) );
		/* 8226AC20h case    2:*/		return 0x8226AC24;
		  /* 8226AC24h */ case    3:  		/* std R6, <#[R1 + 40]> */
		/* 8226AC24h case    3:*/		cpu::mem::store64( regs, regs.R6, (uint32)(regs.R1 + 0x00000028) );
		/* 8226AC24h case    3:*/		return 0x8226AC28;
	}
	return 0x8226AC28;
} // Block from 8226AC18h-8226AC28h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AC28h
// Function 'KeResetEvent'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AC28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AC28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AC28);
		  /* 8226AC28h */ case    0:  		/* std R7, <#[R1 + 48]> */
		/* 8226AC28h case    0:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R1 + 0x00000030) );
		/* 8226AC28h case    0:*/		return 0x8226AC2C;
		  /* 8226AC2Ch */ case    1:  		/* std R8, <#[R1 + 56]> */
		/* 8226AC2Ch case    1:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R1 + 0x00000038) );
		/* 8226AC2Ch case    1:*/		return 0x8226AC30;
		  /* 8226AC30h */ case    2:  		/* std R9, <#[R1 + 64]> */
		/* 8226AC30h case    2:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000040) );
		/* 8226AC30h case    2:*/		return 0x8226AC34;
		  /* 8226AC34h */ case    3:  		/* std R10, <#[R1 + 72]> */
		/* 8226AC34h case    3:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000048) );
		/* 8226AC34h case    3:*/		return 0x8226AC38;
	}
	return 0x8226AC38;
} // Block from 8226AC28h-8226AC38h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AC38h
// Function 'KeWaitForSingleObject'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AC38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AC38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AC38);
		  /* 8226AC38h */ case    0:  		/* stwu R1, <#[R1 - 96]> */
		/* 8226AC38h case    0:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8226AC38h case    0:*/		return 0x8226AC3C;
		  /* 8226AC3Ch */ case    1:  		/* stw R4, <#[R1 + 124]> */
		/* 8226AC3Ch case    1:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000007C) );
		/* 8226AC3Ch case    1:*/		return 0x8226AC40;
		  /* 8226AC40h */ case    2:  		/* addi R11, R1, 80 */
		/* 8226AC40h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 8226AC40h case    2:*/		return 0x8226AC44;
		  /* 8226AC44h */ case    3:  		/* addi R10, R1, 128 */
		/* 8226AC44h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x80);
		/* 8226AC44h case    3:*/		return 0x8226AC48;
	}
	return 0x8226AC48;
} // Block from 8226AC38h-8226AC48h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AC48h
// Function 'VdQueryVideoMode'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AC48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AC48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AC48);
		  /* 8226AC48h */ case    0:  		/* stw R10, <#[R11]> */
		/* 8226AC48h case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8226AC48h case    0:*/		return 0x8226AC4C;
		  /* 8226AC4Ch */ case    1:  		/* lwz R5, <#[R1 + 80]> */
		/* 8226AC4Ch case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000050) );
		/* 8226AC4Ch case    1:*/		return 0x8226AC50;
		  /* 8226AC50h */ case    2:  		/* bl -4976 */
		/* 8226AC50h case    2:*/		regs.LR = 0x8226AC54; return 0x822698E0;
		/* 8226AC50h case    2:*/		return 0x8226AC54;
		  /* 8226AC54h */ case    3:  		/* addi R1, R1, 96 */
		/* 8226AC54h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8226AC54h case    3:*/		return 0x8226AC58;
	}
	return 0x8226AC58;
} // Block from 8226AC48h-8226AC58h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AC58h
// Function 'VdInitializeScalerCommandBuffer'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AC58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AC58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AC58);
		  /* 8226AC58h */ case    0:  		/* lwz R12, <#[R1 - 8]> */
		/* 8226AC58h case    0:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8226AC58h case    0:*/		return 0x8226AC5C;
		  /* 8226AC5Ch */ case    1:  		/* mtspr LR, R12 */
		/* 8226AC5Ch case    1:*/		regs.LR = regs.R12;
		/* 8226AC5Ch case    1:*/		return 0x8226AC60;
		  /* 8226AC60h */ case    2:  		/* bclr 20, CR0_LT */
		/* 8226AC60h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8226AC60h case    2:*/		return 0x8226AC64;
	}
	return 0x8226AC64;
} // Block from 8226AC58h-8226AC64h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8226AC64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AC64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AC64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AC64);
		  /* 8226AC64h */ case    0:  		/* nop */
		/* 8226AC64h case    0:*/		cpu::op::nop();
		/* 8226AC64h case    0:*/		return 0x8226AC68;
	}
	return 0x8226AC68;
} // Block from 8226AC64h-8226AC68h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226AC68h
// Function 'VdQueryVideoFlags'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AC68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AC68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AC68);
		  /* 8226AC68h */ case    0:  		/* mfspr R12, LR */
		/* 8226AC68h case    0:*/		regs.R12 = regs.LR;
		/* 8226AC68h case    0:*/		return 0x8226AC6C;
		  /* 8226AC6Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8226AC6Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8226AC6Ch case    1:*/		return 0x8226AC70;
		  /* 8226AC70h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 8226AC70h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8226AC70h case    2:*/		return 0x8226AC74;
		  /* 8226AC74h */ case    3:  		/* stwu R1, <#[R1 - 112]> */
		/* 8226AC74h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8226AC74h case    3:*/		return 0x8226AC78;
	}
	return 0x8226AC78;
} // Block from 8226AC68h-8226AC78h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AC78h
// Function 'RtlFillMemoryUlong'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AC78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AC78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AC78);
		  /* 8226AC78h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 8226AC78h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 8226AC78h case    0:*/		return 0x8226AC7C;
		  /* 8226AC7Ch */ case    1:  		/* mr R31, R3 */
		/* 8226AC7Ch case    1:*/		regs.R31 = regs.R3;
		/* 8226AC7Ch case    1:*/		return 0x8226AC80;
		  /* 8226AC80h */ case    2:  		/* rlwinm. R11, R11, 0, 27, 27 */
		/* 8226AC80h case    2:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R11);
		/* 8226AC80h case    2:*/		return 0x8226AC84;
		  /* 8226AC84h */ case    3:  		/* bc 12, CR0_EQ, 20 */
		/* 8226AC84h case    3:*/		if ( regs.CR[0].eq ) { return 0x8226AC98;  }
		/* 8226AC84h case    3:*/		return 0x8226AC88;
	}
	return 0x8226AC88;
} // Block from 8226AC78h-8226AC88h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AC88h
// Function 'VdCallGraphicsNotificationRoutines'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AC88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AC88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AC88);
		  /* 8226AC88h */ case    0:  		/* lis R11, -32253 */
		/* 8226AC88h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 8226AC88h case    0:*/		return 0x8226AC8C;
		  /* 8226AC8Ch */ case    1:  		/* addi R4, R11, 28332 */
		/* 8226AC8Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x6EAC);
		/* 8226AC8Ch case    1:*/		return 0x8226AC90;
		  /* 8226AC90h */ case    2:  		/* bl -4520 */
		/* 8226AC90h case    2:*/		regs.LR = 0x8226AC94; return 0x82269AE8;
		/* 8226AC90h case    2:*/		return 0x8226AC94;
		  /* 8226AC94h */ case    3:  		/* b 16 */
		/* 8226AC94h case    3:*/		return 0x8226ACA4;
		/* 8226AC94h case    3:*/		return 0x8226AC98;
	}
	return 0x8226AC98;
} // Block from 8226AC88h-8226AC98h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AC98h
// Function 'ObDeleteSymbolicLink'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AC98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AC98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AC98);
		  /* 8226AC98h */ case    0:  		/* lis R11, -32256 */
		/* 8226AC98h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8226AC98h case    0:*/		return 0x8226AC9C;
		  /* 8226AC9Ch */ case    1:  		/* addi R4, R11, 17768 */
		/* 8226AC9Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x4568);
		/* 8226AC9Ch case    1:*/		return 0x8226ACA0;
		  /* 8226ACA0h */ case    2:  		/* bl -136 */
		/* 8226ACA0h case    2:*/		regs.LR = 0x8226ACA4; return 0x8226AC18;
		/* 8226ACA0h case    2:*/		return 0x8226ACA4;
	}
	return 0x8226ACA4;
} // Block from 8226AC98h-8226ACA4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8226ACA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226ACA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226ACA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226ACA4);
		  /* 8226ACA4h */ case    0:  		/* li R11, 1 */
		/* 8226ACA4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8226ACA4h case    0:*/		return 0x8226ACA8;
	}
	return 0x8226ACA8;
} // Block from 8226ACA4h-8226ACA8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226ACA8h
// Function 'RtlInitAnsiString'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226ACA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226ACA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226ACA8);
		  /* 8226ACA8h */ case    0:  		/* stb R11, <#[R31 + 8232]> */
		/* 8226ACA8h case    0:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R31 + 0x00002028) );
		/* 8226ACA8h case    0:*/		return 0x8226ACAC;
		  /* 8226ACACh */ case    1:  		/* addi R1, R1, 112 */
		/* 8226ACACh case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8226ACACh case    1:*/		return 0x8226ACB0;
		  /* 8226ACB0h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 8226ACB0h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8226ACB0h case    2:*/		return 0x8226ACB4;
		  /* 8226ACB4h */ case    3:  		/* mtspr LR, R12 */
		/* 8226ACB4h case    3:*/		regs.LR = regs.R12;
		/* 8226ACB4h case    3:*/		return 0x8226ACB8;
	}
	return 0x8226ACB8;
} // Block from 8226ACA8h-8226ACB8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226ACB8h
// Function 'VdGetCurrentDisplayInformation'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226ACB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226ACB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226ACB8);
		  /* 8226ACB8h */ case    0:  		/* ld R31, <#[R1 - 16]> */
		/* 8226ACB8h case    0:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8226ACB8h case    0:*/		return 0x8226ACBC;
		  /* 8226ACBCh */ case    1:  		/* bclr 20, CR0_LT */
		/* 8226ACBCh case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8226ACBCh case    1:*/		return 0x8226ACC0;
	}
	return 0x8226ACC0;
} // Block from 8226ACB8h-8226ACC0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226ACC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226ACC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226ACC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226ACC0);
		  /* 8226ACC0h */ case    0:  		/* mfspr R12, LR */
		/* 8226ACC0h case    0:*/		regs.R12 = regs.LR;
		/* 8226ACC0h case    0:*/		return 0x8226ACC4;
		  /* 8226ACC4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8226ACC4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8226ACC4h case    1:*/		return 0x8226ACC8;
	}
	return 0x8226ACC8;
} // Block from 8226ACC0h-8226ACC8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226ACC8h
// Function 'ObCreateSymbolicLink'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226ACC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226ACC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226ACC8);
		  /* 8226ACC8h */ case    0:  		/* std R31, <#[R1 - 16]> */
		/* 8226ACC8h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8226ACC8h case    0:*/		return 0x8226ACCC;
		  /* 8226ACCCh */ case    1:  		/* stwu R1, <#[R1 - 112]> */
		/* 8226ACCCh case    1:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8226ACCCh case    1:*/		return 0x8226ACD0;
		  /* 8226ACD0h */ case    2:  		/* lbz R11, <#[R3 + 8232]> */
		/* 8226ACD0h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002028) );
		/* 8226ACD0h case    2:*/		return 0x8226ACD4;
		  /* 8226ACD4h */ case    3:  		/* mr R31, R3 */
		/* 8226ACD4h case    3:*/		regs.R31 = regs.R3;
		/* 8226ACD4h case    3:*/		return 0x8226ACD8;
	}
	return 0x8226ACD8;
} // Block from 8226ACC8h-8226ACD8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226ACD8h
// Function 'MmAllocatePhysicalMemoryEx'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226ACD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226ACD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226ACD8);
		  /* 8226ACD8h */ case    0:  		/* cmplwi CR0, R11, 0 */
		/* 8226ACD8h case    0:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8226ACD8h case    0:*/		return 0x8226ACDC;
		  /* 8226ACDCh */ case    1:  		/* bc 4, CR0_EQ, 8 */
		/* 8226ACDCh case    1:*/		if ( !regs.CR[0].eq ) { return 0x8226ACE4;  }
		/* 8226ACDCh case    1:*/		return 0x8226ACE0;
		  /* 8226ACE0h */ case    2:  		/* bl -120 */
		/* 8226ACE0h case    2:*/		regs.LR = 0x8226ACE4; return 0x8226AC68;
		/* 8226ACE0h case    2:*/		return 0x8226ACE4;
	}
	return 0x8226ACE4;
} // Block from 8226ACD8h-8226ACE4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8226ACE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226ACE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226ACE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226ACE4);
		  /* 8226ACE4h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 8226ACE4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8226ACE4h case    0:*/		return 0x8226ACE8;
	}
	return 0x8226ACE8;
} // Block from 8226ACE4h-8226ACE8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226ACE8h
// Function 'VdSetDisplayMode'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226ACE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226ACE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226ACE8);
		  /* 8226ACE8h */ case    0:  		/* rlwinm. R10, R11, 25, 31, 31 */
		/* 8226ACE8h case    0:*/		cpu::op::rlwinm<1,25,31,31>(regs,&regs.R10,regs.R11);
		/* 8226ACE8h case    0:*/		return 0x8226ACEC;
		  /* 8226ACECh */ case    1:  		/* bc 12, CR0_EQ, 44 */
		/* 8226ACECh case    1:*/		if ( regs.CR[0].eq ) { return 0x8226AD18;  }
		/* 8226ACECh case    1:*/		return 0x8226ACF0;
		  /* 8226ACF0h */ case    2:  		/* rlwinm. R11, R11, 0, 27, 27 */
		/* 8226ACF0h case    2:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R11);
		/* 8226ACF0h case    2:*/		return 0x8226ACF4;
		  /* 8226ACF4h */ case    3:  		/* mr R3, R31 */
		/* 8226ACF4h case    3:*/		regs.R3 = regs.R31;
		/* 8226ACF4h case    3:*/		return 0x8226ACF8;
	}
	return 0x8226ACF8;
} // Block from 8226ACE8h-8226ACF8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226ACF8h
// Function 'VdSetGraphicsInterruptCallback'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226ACF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226ACF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226ACF8);
		  /* 8226ACF8h */ case    0:  		/* bc 12, CR0_EQ, 20 */
		/* 8226ACF8h case    0:*/		if ( regs.CR[0].eq ) { return 0x8226AD0C;  }
		/* 8226ACF8h case    0:*/		return 0x8226ACFC;
		  /* 8226ACFCh */ case    1:  		/* lis R11, -32253 */
		/* 8226ACFCh case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 8226ACFCh case    1:*/		return 0x8226AD00;
		  /* 8226AD00h */ case    2:  		/* addi R4, R11, 28332 */
		/* 8226AD00h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x6EAC);
		/* 8226AD00h case    2:*/		return 0x8226AD04;
		  /* 8226AD04h */ case    3:  		/* bl -4636 */
		/* 8226AD04h case    3:*/		regs.LR = 0x8226AD08; return 0x82269AE8;
		/* 8226AD04h case    3:*/		return 0x8226AD08;
	}
	return 0x8226AD08;
} // Block from 8226ACF8h-8226AD08h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AD08h
// Function 'VdSetDisplayModeOverride'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AD08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AD08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AD08);
		  /* 8226AD08h */ case    0:  		/* b 16 */
		/* 8226AD08h case    0:*/		return 0x8226AD18;
		/* 8226AD08h case    0:*/		return 0x8226AD0C;
	}
	return 0x8226AD0C;
} // Block from 8226AD08h-8226AD0Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226AD0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AD0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AD0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AD0C);
		  /* 8226AD0Ch */ case    0:  		/* lis R11, -32251 */
		/* 8226AD0Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8226AD0Ch case    0:*/		return 0x8226AD10;
		  /* 8226AD10h */ case    1:  		/* addi R4, R11, -16236 */
		/* 8226AD10h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFC094);
		/* 8226AD10h case    1:*/		return 0x8226AD14;
		  /* 8226AD14h */ case    2:  		/* bl -252 */
		/* 8226AD14h case    2:*/		regs.LR = 0x8226AD18; return 0x8226AC18;
		/* 8226AD14h case    2:*/		return 0x8226AD18;
	}
	return 0x8226AD18;
} // Block from 8226AD0Ch-8226AD18h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8226AD18h
// Function 'VdInitializeEngines'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AD18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AD18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AD18);
		  /* 8226AD18h */ case    0:  		/* addi R1, R1, 112 */
		/* 8226AD18h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8226AD18h case    0:*/		return 0x8226AD1C;
		  /* 8226AD1Ch */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 8226AD1Ch case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8226AD1Ch case    1:*/		return 0x8226AD20;
		  /* 8226AD20h */ case    2:  		/* mtspr LR, R12 */
		/* 8226AD20h case    2:*/		regs.LR = regs.R12;
		/* 8226AD20h case    2:*/		return 0x8226AD24;
		  /* 8226AD24h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 8226AD24h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8226AD24h case    3:*/		return 0x8226AD28;
	}
	return 0x8226AD28;
} // Block from 8226AD18h-8226AD28h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AD28h
// Function 'ExGetXConfigSetting'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AD28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AD28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AD28);
		  /* 8226AD28h */ case    0:  		/* bclr 20, CR0_LT */
		/* 8226AD28h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8226AD28h case    0:*/		return 0x8226AD2C;
	}
	return 0x8226AD2C;
} // Block from 8226AD28h-8226AD2Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226AD2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AD2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AD2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AD2C);
		  /* 8226AD2Ch */ case    0:  		/* nop */
		/* 8226AD2Ch case    0:*/		cpu::op::nop();
		/* 8226AD2Ch case    0:*/		return 0x8226AD30;
	}
	return 0x8226AD30;
} // Block from 8226AD2Ch-8226AD30h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226AD30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AD30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AD30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AD30);
		  /* 8226AD30h */ case    0:  		/* mfspr R12, LR */
		/* 8226AD30h case    0:*/		regs.R12 = regs.LR;
		/* 8226AD30h case    0:*/		return 0x8226AD34;
		  /* 8226AD34h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8226AD34h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8226AD34h case    1:*/		return 0x8226AD38;
	}
	return 0x8226AD38;
} // Block from 8226AD30h-8226AD38h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226AD38h
// Function 'VdIsHSIOTrainingSucceeded'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AD38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AD38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AD38);
		  /* 8226AD38h */ case    0:  		/* std R31, <#[R1 - 16]> */
		/* 8226AD38h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8226AD38h case    0:*/		return 0x8226AD3C;
		  /* 8226AD3Ch */ case    1:  		/* stwu R1, <#[R1 - 96]> */
		/* 8226AD3Ch case    1:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 8226AD3Ch case    1:*/		return 0x8226AD40;
		  /* 8226AD40h */ case    2:  		/* lis R11, -32253 */
		/* 8226AD40h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 8226AD40h case    2:*/		return 0x8226AD44;
		  /* 8226AD44h */ case    3:  		/* mr R31, R3 */
		/* 8226AD44h case    3:*/		regs.R31 = regs.R3;
		/* 8226AD44h case    3:*/		return 0x8226AD48;
	}
	return 0x8226AD48;
} // Block from 8226AD38h-8226AD48h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AD48h
// Function 'VdShutdownEngines'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AD48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AD48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AD48);
		  /* 8226AD48h */ case    0:  		/* addi R4, R11, 28348 */
		/* 8226AD48h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x6EBC);
		/* 8226AD48h case    0:*/		return 0x8226AD4C;
		  /* 8226AD4Ch */ case    1:  		/* bl -4708 */
		/* 8226AD4Ch case    1:*/		regs.LR = 0x8226AD50; return 0x82269AE8;
		/* 8226AD4Ch case    1:*/		return 0x8226AD50;
		  /* 8226AD50h */ case    2:  		/* lbz R11, <#[R31 + 8232]> */
		/* 8226AD50h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002028) );
		/* 8226AD50h case    2:*/		return 0x8226AD54;
		  /* 8226AD54h */ case    3:  		/* cmplwi CR0, R11, 0 */
		/* 8226AD54h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8226AD54h case    3:*/		return 0x8226AD58;
	}
	return 0x8226AD58;
} // Block from 8226AD48h-8226AD58h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AD58h
// Function 'ExRegisterTitleTerminateNotification'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AD58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AD58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AD58);
		  /* 8226AD58h */ case    0:  		/* bc 4, CR0_EQ, 12 */
		/* 8226AD58h case    0:*/		if ( !regs.CR[0].eq ) { return 0x8226AD64;  }
		/* 8226AD58h case    0:*/		return 0x8226AD5C;
		  /* 8226AD5Ch */ case    1:  		/* mr R3, R31 */
		/* 8226AD5Ch case    1:*/		regs.R3 = regs.R31;
		/* 8226AD5Ch case    1:*/		return 0x8226AD60;
		  /* 8226AD60h */ case    2:  		/* bl -248 */
		/* 8226AD60h case    2:*/		regs.LR = 0x8226AD64; return 0x8226AC68;
		/* 8226AD60h case    2:*/		return 0x8226AD64;
	}
	return 0x8226AD64;
} // Block from 8226AD58h-8226AD64h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8226AD64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AD64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AD64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AD64);
		  /* 8226AD64h */ case    0:  		/* addi R1, R1, 96 */
		/* 8226AD64h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 8226AD64h case    0:*/		return 0x8226AD68;
	}
	return 0x8226AD68;
} // Block from 8226AD64h-8226AD68h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226AD68h
// Function 'RtlVsnprintf'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AD68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AD68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AD68);
		  /* 8226AD68h */ case    0:  		/* lwz R12, <#[R1 - 8]> */
		/* 8226AD68h case    0:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8226AD68h case    0:*/		return 0x8226AD6C;
		  /* 8226AD6Ch */ case    1:  		/* mtspr LR, R12 */
		/* 8226AD6Ch case    1:*/		regs.LR = regs.R12;
		/* 8226AD6Ch case    1:*/		return 0x8226AD70;
		  /* 8226AD70h */ case    2:  		/* ld R31, <#[R1 - 16]> */
		/* 8226AD70h case    2:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8226AD70h case    2:*/		return 0x8226AD74;
		  /* 8226AD74h */ case    3:  		/* bclr 20, CR0_LT */
		/* 8226AD74h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8226AD74h case    3:*/		return 0x8226AD78;
	}
	return 0x8226AD78;
} // Block from 8226AD68h-8226AD78h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AD78h
// Function 'KeLeaveCriticalRegion'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AD78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AD78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AD78);
		  /* 8226AD78h */ case    0:  		/* mfspr R12, LR */
		/* 8226AD78h case    0:*/		regs.R12 = regs.LR;
		/* 8226AD78h case    0:*/		return 0x8226AD7C;
		  /* 8226AD7Ch */ case    1:  		/* bl -1940256 */
		/* 8226AD7Ch case    1:*/		regs.LR = 0x8226AD80; return 0x8209125C;
		/* 8226AD7Ch case    1:*/		return 0x8226AD80;
		  /* 8226AD80h */ case    2:  		/* std R7, <#[R1 + 48]> */
		/* 8226AD80h case    2:*/		cpu::mem::store64( regs, regs.R7, (uint32)(regs.R1 + 0x00000030) );
		/* 8226AD80h case    2:*/		return 0x8226AD84;
		  /* 8226AD84h */ case    3:  		/* std R8, <#[R1 + 56]> */
		/* 8226AD84h case    3:*/		cpu::mem::store64( regs, regs.R8, (uint32)(regs.R1 + 0x00000038) );
		/* 8226AD84h case    3:*/		return 0x8226AD88;
	}
	return 0x8226AD88;
} // Block from 8226AD78h-8226AD88h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AD88h
// Function 'KeEnterCriticalRegion'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AD88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AD88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AD88);
		  /* 8226AD88h */ case    0:  		/* std R9, <#[R1 + 64]> */
		/* 8226AD88h case    0:*/		cpu::mem::store64( regs, regs.R9, (uint32)(regs.R1 + 0x00000040) );
		/* 8226AD88h case    0:*/		return 0x8226AD8C;
		  /* 8226AD8Ch */ case    1:  		/* std R10, <#[R1 + 72]> */
		/* 8226AD8Ch case    1:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000048) );
		/* 8226AD8Ch case    1:*/		return 0x8226AD90;
		  /* 8226AD90h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 8226AD90h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 8226AD90h case    2:*/		return 0x8226AD94;
		  /* 8226AD94h */ case    3:  		/* lbz R11, <#[R3 + 8232]> */
		/* 8226AD94h case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R3 + 0x00002028) );
		/* 8226AD94h case    3:*/		return 0x8226AD98;
	}
	return 0x8226AD98;
} // Block from 8226AD88h-8226AD98h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AD98h
// Function 'VdRetrainEDRAM'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AD98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AD98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AD98);
		  /* 8226AD98h */ case    0:  		/* mr R31, R3 */
		/* 8226AD98h case    0:*/		regs.R31 = regs.R3;
		/* 8226AD98h case    0:*/		return 0x8226AD9C;
		  /* 8226AD9Ch */ case    1:  		/* mr R29, R4 */
		/* 8226AD9Ch case    1:*/		regs.R29 = regs.R4;
		/* 8226AD9Ch case    1:*/		return 0x8226ADA0;
		  /* 8226ADA0h */ case    2:  		/* stw R6, <#[R1 + 204]> */
		/* 8226ADA0h case    2:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x000000CC) );
		/* 8226ADA0h case    2:*/		return 0x8226ADA4;
		  /* 8226ADA4h */ case    3:  		/* mr R30, R5 */
		/* 8226ADA4h case    3:*/		regs.R30 = regs.R5;
		/* 8226ADA4h case    3:*/		return 0x8226ADA8;
	}
	return 0x8226ADA8;
} // Block from 8226AD98h-8226ADA8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226ADA8h
// Function 'VdRetrainEDRAMWorker'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226ADA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226ADA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226ADA8);
		  /* 8226ADA8h */ case    0:  		/* cmplwi CR0, R11, 0 */
		/* 8226ADA8h case    0:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8226ADA8h case    0:*/		return 0x8226ADAC;
		  /* 8226ADACh */ case    1:  		/* bc 4, CR0_EQ, 8 */
		/* 8226ADACh case    1:*/		if ( !regs.CR[0].eq ) { return 0x8226ADB4;  }
		/* 8226ADACh case    1:*/		return 0x8226ADB0;
		  /* 8226ADB0h */ case    2:  		/* bl -328 */
		/* 8226ADB0h case    2:*/		regs.LR = 0x8226ADB4; return 0x8226AC68;
		/* 8226ADB0h case    2:*/		return 0x8226ADB4;
	}
	return 0x8226ADB4;
} // Block from 8226ADA8h-8226ADB4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8226ADB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226ADB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226ADB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226ADB4);
		  /* 8226ADB4h */ case    0:  		/* mr R3, R31 */
		/* 8226ADB4h case    0:*/		regs.R3 = regs.R31;
		/* 8226ADB4h case    0:*/		return 0x8226ADB8;
	}
	return 0x8226ADB8;
} // Block from 8226ADB4h-8226ADB8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226ADB8h
// Function 'KeInitializeDpc'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226ADB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226ADB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226ADB8);
		  /* 8226ADB8h */ case    0:  		/* bl -4432 */
		/* 8226ADB8h case    0:*/		regs.LR = 0x8226ADBC; return 0x82269C68;
		/* 8226ADB8h case    0:*/		return 0x8226ADBC;
		  /* 8226ADBCh */ case    1:  		/* rlwinm. R11, R29, 0, 24, 31 */
		/* 8226ADBCh case    1:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R29);
		/* 8226ADBCh case    1:*/		return 0x8226ADC0;
		  /* 8226ADC0h */ case    2:  		/* mr R3, R31 */
		/* 8226ADC0h case    2:*/		regs.R3 = regs.R31;
		/* 8226ADC0h case    2:*/		return 0x8226ADC4;
		  /* 8226ADC4h */ case    3:  		/* bc 12, CR0_EQ, 24 */
		/* 8226ADC4h case    3:*/		if ( regs.CR[0].eq ) { return 0x8226ADDC;  }
		/* 8226ADC4h case    3:*/		return 0x8226ADC8;
	}
	return 0x8226ADC8;
} // Block from 8226ADB8h-8226ADC8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226ADC8h
// Function 'KeSetBasePriorityThread'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226ADC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226ADC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226ADC8);
		  /* 8226ADC8h */ case    0:  		/* lis R11, -32251 */
		/* 8226ADC8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8226ADC8h case    0:*/		return 0x8226ADCC;
		  /* 8226ADCCh */ case    1:  		/* mr R5, R30 */
		/* 8226ADCCh case    1:*/		regs.R5 = regs.R30;
		/* 8226ADCCh case    1:*/		return 0x8226ADD0;
		  /* 8226ADD0h */ case    2:  		/* addi R4, R11, -16212 */
		/* 8226ADD0h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFC0AC);
		/* 8226ADD0h case    2:*/		return 0x8226ADD4;
		  /* 8226ADD4h */ case    3:  		/* bl -5108 */
		/* 8226ADD4h case    3:*/		regs.LR = 0x8226ADD8; return 0x822699E0;
		/* 8226ADD4h case    3:*/		return 0x8226ADD8;
	}
	return 0x8226ADD8;
} // Block from 8226ADC8h-8226ADD8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226ADD8h
// Function 'KeLockL2'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226ADD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226ADD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226ADD8);
		  /* 8226ADD8h */ case    0:  		/* b 40 */
		/* 8226ADD8h case    0:*/		return 0x8226AE00;
		/* 8226ADD8h case    0:*/		return 0x8226ADDC;
	}
	return 0x8226ADDC;
} // Block from 8226ADD8h-8226ADDCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226ADDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226ADDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226ADDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226ADDC);
		  /* 8226ADDCh */ case    0:  		/* srawi R11, R30, 1 */
		/* 8226ADDCh case    0:*/		cpu::op::srawi<0,1>(regs,&regs.R11,regs.R30);
		/* 8226ADDCh case    0:*/		return 0x8226ADE0;
		  /* 8226ADE0h */ case    1:  		/* lis R10, -32251 */
		/* 8226ADE0h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 8226ADE0h case    1:*/		return 0x8226ADE4;
		  /* 8226ADE4h */ case    2:  		/* addze R11, R11 */
		/* 8226ADE4h case    2:*/		cpu::op::addze<0>(regs,&regs.R11,regs.R11);
		/* 8226ADE4h case    2:*/		return 0x8226ADE8;
	}
	return 0x8226ADE8;
} // Block from 8226ADDCh-8226ADE8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8226ADE8h
// Function 'KeUnlockL2'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226ADE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226ADE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226ADE8);
		  /* 8226ADE8h */ case    0:  		/* srawi R9, R30, 1 */
		/* 8226ADE8h case    0:*/		cpu::op::srawi<0,1>(regs,&regs.R9,regs.R30);
		/* 8226ADE8h case    0:*/		return 0x8226ADEC;
		  /* 8226ADECh */ case    1:  		/* rlwinm R11, R11, 1, 0, 30 */
		/* 8226ADECh case    1:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R11);
		/* 8226ADECh case    1:*/		return 0x8226ADF0;
		  /* 8226ADF0h */ case    2:  		/* addi R4, R10, -16220 */
		/* 8226ADF0h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0xFFFFC0A4);
		/* 8226ADF0h case    2:*/		return 0x8226ADF4;
		  /* 8226ADF4h */ case    3:  		/* addze R5, R9 */
		/* 8226ADF4h case    3:*/		cpu::op::addze<0>(regs,&regs.R5,regs.R9);
		/* 8226ADF4h case    3:*/		return 0x8226ADF8;
	}
	return 0x8226ADF8;
} // Block from 8226ADE8h-8226ADF8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226ADF8h
// Function 'ObReferenceObjectByHandle'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226ADF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226ADF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226ADF8);
		  /* 8226ADF8h */ case    0:  		/* subf R6, R11, R30 */
		/* 8226ADF8h case    0:*/		cpu::op::subf<0>(regs,&regs.R6,regs.R11,regs.R30);
		/* 8226ADF8h case    0:*/		return 0x8226ADFC;
		  /* 8226ADFCh */ case    1:  		/* bl -5148 */
		/* 8226ADFCh case    1:*/		regs.LR = 0x8226AE00; return 0x822699E0;
		/* 8226ADFCh case    1:*/		return 0x8226AE00;
	}
	return 0x8226AE00;
} // Block from 8226ADF8h-8226AE00h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226AE00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AE00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AE00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AE00);
		  /* 8226AE00h */ case    0:  		/* lis R11, -32251 */
		/* 8226AE00h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8226AE00h case    0:*/		return 0x8226AE04;
		  /* 8226AE04h */ case    1:  		/* mr R3, R31 */
		/* 8226AE04h case    1:*/		regs.R3 = regs.R31;
		/* 8226AE04h case    1:*/		return 0x8226AE08;
	}
	return 0x8226AE08;
} // Block from 8226AE00h-8226AE08h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226AE08h
// Function 'ObDereferenceObject'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AE08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AE08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AE08);
		  /* 8226AE08h */ case    0:  		/* addi R4, R11, -16232 */
		/* 8226AE08h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFC098);
		/* 8226AE08h case    0:*/		return 0x8226AE0C;
		  /* 8226AE0Ch */ case    1:  		/* bl -5164 */
		/* 8226AE0Ch case    1:*/		regs.LR = 0x8226AE10; return 0x822699E0;
		/* 8226AE0Ch case    1:*/		return 0x8226AE10;
		  /* 8226AE10h */ case    2:  		/* addi R11, R1, 112 */
		/* 8226AE10h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 8226AE10h case    2:*/		return 0x8226AE14;
		  /* 8226AE14h */ case    3:  		/* addi R10, R1, 208 */
		/* 8226AE14h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0xD0);
		/* 8226AE14h case    3:*/		return 0x8226AE18;
	}
	return 0x8226AE18;
} // Block from 8226AE08h-8226AE18h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AE18h
// Function 'DbgPrint'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AE18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AE18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AE18);
		  /* 8226AE18h */ case    0:  		/* lwz R4, <#[R1 + 204]> */
		/* 8226AE18h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x000000CC) );
		/* 8226AE18h case    0:*/		return 0x8226AE1C;
		  /* 8226AE1Ch */ case    1:  		/* mr R3, R31 */
		/* 8226AE1Ch case    1:*/		regs.R3 = regs.R31;
		/* 8226AE1Ch case    1:*/		return 0x8226AE20;
		  /* 8226AE20h */ case    2:  		/* stw R10, <#[R11]> */
		/* 8226AE20h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 8226AE20h case    2:*/		return 0x8226AE24;
		  /* 8226AE24h */ case    3:  		/* lwz R5, <#[R1 + 112]> */
		/* 8226AE24h case    3:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000070) );
		/* 8226AE24h case    3:*/		return 0x8226AE28;
	}
	return 0x8226AE28;
} // Block from 8226AE18h-8226AE28h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AE28h
// Function 'KeSetCurrentProcessType'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AE28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AE28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AE28);
		  /* 8226AE28h */ case    0:  		/* bl -5448 */
		/* 8226AE28h case    0:*/		regs.LR = 0x8226AE2C; return 0x822698E0;
		/* 8226AE28h case    0:*/		return 0x8226AE2C;
		  /* 8226AE2Ch */ case    1:  		/* mr R3, R31 */
		/* 8226AE2Ch case    1:*/		regs.R3 = regs.R31;
		/* 8226AE2Ch case    1:*/		return 0x8226AE30;
		  /* 8226AE30h */ case    2:  		/* bl -256 */
		/* 8226AE30h case    2:*/		regs.LR = 0x8226AE34; return 0x8226AD30;
		/* 8226AE30h case    2:*/		return 0x8226AE34;
		  /* 8226AE34h */ case    3:  		/* addi R1, R1, 160 */
		/* 8226AE34h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 8226AE34h case    3:*/		return 0x8226AE38;
	}
	return 0x8226AE38;
} // Block from 8226AE28h-8226AE38h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AE38h
// Function 'NtClose'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AE38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AE38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AE38);
		  /* 8226AE38h */ case    0:  		/* b -1940364 */
		/* 8226AE38h case    0:*/		return 0x820912AC;
		/* 8226AE38h case    0:*/		return 0x8226AE3C;
		  /* 8226AE3Ch */ case    1:  		/* nop */
		/* 8226AE3Ch case    1:*/		cpu::op::nop();
		/* 8226AE3Ch case    1:*/		return 0x8226AE40;
	}
	return 0x8226AE40;
} // Block from 8226AE38h-8226AE40h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226AE40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AE40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AE40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AE40);
		  /* 8226AE40h */ case    0:  		/* mfspr R12, LR */
		/* 8226AE40h case    0:*/		regs.R12 = regs.LR;
		/* 8226AE40h case    0:*/		return 0x8226AE44;
		  /* 8226AE44h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 8226AE44h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8226AE44h case    1:*/		return 0x8226AE48;
	}
	return 0x8226AE48;
} // Block from 8226AE40h-8226AE48h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226AE48h
// Function 'NtCreateEvent'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AE48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AE48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AE48);
		  /* 8226AE48h */ case    0:  		/* std R31, <#[R1 - 16]> */
		/* 8226AE48h case    0:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8226AE48h case    0:*/		return 0x8226AE4C;
		  /* 8226AE4Ch */ case    1:  		/* stwu R1, <#[R1 - 112]> */
		/* 8226AE4Ch case    1:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 8226AE4Ch case    1:*/		return 0x8226AE50;
		  /* 8226AE50h */ case    2:  		/* lis R11, -32256 */
		/* 8226AE50h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8226AE50h case    2:*/		return 0x8226AE54;
		  /* 8226AE54h */ case    3:  		/* mr R31, R3 */
		/* 8226AE54h case    3:*/		regs.R31 = regs.R3;
		/* 8226AE54h case    3:*/		return 0x8226AE58;
	}
	return 0x8226AE58;
} // Block from 8226AE48h-8226AE58h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AE58h
// Function 'XexCheckExecutablePrivilege'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AE58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AE58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AE58);
		  /* 8226AE58h */ case    0:  		/* addi R4, R11, 17860 */
		/* 8226AE58h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x45C4);
		/* 8226AE58h case    0:*/		return 0x8226AE5C;
		  /* 8226AE5Ch */ case    1:  		/* bl -5244 */
		/* 8226AE5Ch case    1:*/		regs.LR = 0x8226AE60; return 0x822699E0;
		/* 8226AE5Ch case    1:*/		return 0x8226AE60;
		  /* 8226AE60h */ case    2:  		/* lbz R11, <#[R31 + 8232]> */
		/* 8226AE60h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002028) );
		/* 8226AE60h case    2:*/		return 0x8226AE64;
		  /* 8226AE64h */ case    3:  		/* cmplwi CR0, R11, 0 */
		/* 8226AE64h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 8226AE64h case    3:*/		return 0x8226AE68;
	}
	return 0x8226AE68;
} // Block from 8226AE58h-8226AE68h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AE68h
// Function '__C_specific_handler'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AE68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AE68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AE68);
		  /* 8226AE68h */ case    0:  		/* bc 4, CR0_EQ, 12 */
		/* 8226AE68h case    0:*/		if ( !regs.CR[0].eq ) { return 0x8226AE74;  }
		/* 8226AE68h case    0:*/		return 0x8226AE6C;
		  /* 8226AE6Ch */ case    1:  		/* mr R3, R31 */
		/* 8226AE6Ch case    1:*/		regs.R3 = regs.R31;
		/* 8226AE6Ch case    1:*/		return 0x8226AE70;
		  /* 8226AE70h */ case    2:  		/* bl -520 */
		/* 8226AE70h case    2:*/		regs.LR = 0x8226AE74; return 0x8226AC68;
		/* 8226AE70h case    2:*/		return 0x8226AE74;
	}
	return 0x8226AE74;
} // Block from 8226AE68h-8226AE74h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8226AE74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AE74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AE74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AE74);
		  /* 8226AE74h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 8226AE74h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8226AE74h case    0:*/		return 0x8226AE78;
	}
	return 0x8226AE78;
} // Block from 8226AE74h-8226AE78h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226AE78h
// Function 'KeDelayExecutionThread'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AE78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AE78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AE78);
		  /* 8226AE78h */ case    0:  		/* rlwinm. R11, R11, 0, 26, 26 */
		/* 8226AE78h case    0:*/		cpu::op::rlwinm<1,0,26,26>(regs,&regs.R11,regs.R11);
		/* 8226AE78h case    0:*/		return 0x8226AE7C;
		  /* 8226AE7Ch */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 8226AE7Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x8226AE90;  }
		/* 8226AE7Ch case    1:*/		return 0x8226AE80;
		  /* 8226AE80h */ case    2:  		/* lis R11, -32251 */
		/* 8226AE80h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8226AE80h case    2:*/		return 0x8226AE84;
		  /* 8226AE84h */ case    3:  		/* mr R3, R31 */
		/* 8226AE84h case    3:*/		regs.R3 = regs.R31;
		/* 8226AE84h case    3:*/		return 0x8226AE88;
	}
	return 0x8226AE88;
} // Block from 8226AE78h-8226AE88h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AE88h
// Function 'NtSetInformationFile'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AE88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AE88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AE88);
		  /* 8226AE88h */ case    0:  		/* addi R4, R11, -16288 */
		/* 8226AE88h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFC060);
		/* 8226AE88h case    0:*/		return 0x8226AE8C;
		  /* 8226AE8Ch */ case    1:  		/* bl -5292 */
		/* 8226AE8Ch case    1:*/		regs.LR = 0x8226AE90; return 0x822699E0;
		/* 8226AE8Ch case    1:*/		return 0x8226AE90;
	}
	return 0x8226AE90;
} // Block from 8226AE88h-8226AE90h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226AE90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AE90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AE90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AE90);
		  /* 8226AE90h */ case    0:  		/* lis R11, -32252 */
		/* 8226AE90h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8226AE90h case    0:*/		return 0x8226AE94;
		  /* 8226AE94h */ case    1:  		/* mr R3, R31 */
		/* 8226AE94h case    1:*/		regs.R3 = regs.R31;
		/* 8226AE94h case    1:*/		return 0x8226AE98;
	}
	return 0x8226AE98;
} // Block from 8226AE90h-8226AE98h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226AE98h
// Function 'NtQueryInformationFile'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AE98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AE98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AE98);
		  /* 8226AE98h */ case    0:  		/* addi R4, R11, -23328 */
		/* 8226AE98h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFA4E0);
		/* 8226AE98h case    0:*/		return 0x8226AE9C;
		  /* 8226AE9Ch */ case    1:  		/* bl -5308 */
		/* 8226AE9Ch case    1:*/		regs.LR = 0x8226AEA0; return 0x822699E0;
		/* 8226AE9Ch case    1:*/		return 0x8226AEA0;
		  /* 8226AEA0h */ case    2:  		/* addi R1, R1, 112 */
		/* 8226AEA0h case    2:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 8226AEA0h case    2:*/		return 0x8226AEA4;
		  /* 8226AEA4h */ case    3:  		/* lwz R12, <#[R1 - 8]> */
		/* 8226AEA4h case    3:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 8226AEA4h case    3:*/		return 0x8226AEA8;
	}
	return 0x8226AEA8;
} // Block from 8226AE98h-8226AEA8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AEA8h
// Function 'NtWaitForSingleObjectEx'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AEA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AEA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AEA8);
		  /* 8226AEA8h */ case    0:  		/* mtspr LR, R12 */
		/* 8226AEA8h case    0:*/		regs.LR = regs.R12;
		/* 8226AEA8h case    0:*/		return 0x8226AEAC;
		  /* 8226AEACh */ case    1:  		/* ld R31, <#[R1 - 16]> */
		/* 8226AEACh case    1:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 8226AEACh case    1:*/		return 0x8226AEB0;
		  /* 8226AEB0h */ case    2:  		/* bclr 20, CR0_LT */
		/* 8226AEB0h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 8226AEB0h case    2:*/		return 0x8226AEB4;
	}
	return 0x8226AEB4;
} // Block from 8226AEA8h-8226AEB4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8226AEB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AEB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AEB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AEB4);
		  /* 8226AEB4h */ case    0:  		/* nop */
		/* 8226AEB4h case    0:*/		cpu::op::nop();
		/* 8226AEB4h case    0:*/		return 0x8226AEB8;
	}
	return 0x8226AEB8;
} // Block from 8226AEB4h-8226AEB8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226AEB8h
// Function 'NtWriteFile'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AEB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AEB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AEB8);
		  /* 8226AEB8h */ case    0:  		/* mfspr R12, LR */
		/* 8226AEB8h case    0:*/		regs.R12 = regs.LR;
		/* 8226AEB8h case    0:*/		return 0x8226AEBC;
		  /* 8226AEBCh */ case    1:  		/* bl -1940600 */
		/* 8226AEBCh case    1:*/		regs.LR = 0x8226AEC0; return 0x82091244;
		/* 8226AEBCh case    1:*/		return 0x8226AEC0;
		  /* 8226AEC0h */ case    2:  		/* stfd FR31, <#[R1 - 88]> */
		/* 8226AEC0h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFA8) );
		/* 8226AEC0h case    2:*/		return 0x8226AEC4;
		  /* 8226AEC4h */ case    3:  		/* stwu R1, <#[R1 - 224]> */
		/* 8226AEC4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF20) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF20);
		/* 8226AEC4h case    3:*/		return 0x8226AEC8;
	}
	return 0x8226AEC8;
} // Block from 8226AEB8h-8226AEC8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AEC8h
// Function 'NtQueryVolumeInformationFile'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AEC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AEC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AEC8);
		  /* 8226AEC8h */ case    0:  		/* lwz R11, <#[R4 + 4]> */
		/* 8226AEC8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 8226AEC8h case    0:*/		return 0x8226AECC;
		  /* 8226AECCh */ case    1:  		/* lis R10, -32768 */
		/* 8226AECCh case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8000);
		/* 8226AECCh case    1:*/		return 0x8226AED0;
		  /* 8226AED0h */ case    2:  		/* mr R31, R3 */
		/* 8226AED0h case    2:*/		regs.R31 = regs.R3;
		/* 8226AED0h case    2:*/		return 0x8226AED4;
		  /* 8226AED4h */ case    3:  		/* rlwinm R11, R11, 0, 0, 0 */
		/* 8226AED4h case    3:*/		cpu::op::rlwinm<0,0,0,0>(regs,&regs.R11,regs.R11);
		/* 8226AED4h case    3:*/		return 0x8226AED8;
	}
	return 0x8226AED8;
} // Block from 8226AEC8h-8226AED8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AED8h
// Function 'NtOpenFile'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AED8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AED8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AED8);
		  /* 8226AED8h */ case    0:  		/* mr R29, R4 */
		/* 8226AED8h case    0:*/		regs.R29 = regs.R4;
		/* 8226AED8h case    0:*/		return 0x8226AEDC;
		  /* 8226AEDCh */ case    1:  		/* mr R23, R5 */
		/* 8226AEDCh case    1:*/		regs.R23 = regs.R5;
		/* 8226AEDCh case    1:*/		return 0x8226AEE0;
		  /* 8226AEE0h */ case    2:  		/* mr R30, R6 */
		/* 8226AEE0h case    2:*/		regs.R30 = regs.R6;
		/* 8226AEE0h case    2:*/		return 0x8226AEE4;
		  /* 8226AEE4h */ case    3:  		/* cmplw CR6, R11, R10 */
		/* 8226AEE4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 8226AEE4h case    3:*/		return 0x8226AEE8;
	}
	return 0x8226AEE8;
} // Block from 8226AED8h-8226AEE8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AEE8h
// Function 'RtlRaiseException'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AEE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AEE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AEE8);
		  /* 8226AEE8h */ case    0:  		/* bc 4, CR6_EQ, 44 */
		/* 8226AEE8h case    0:*/		if ( !regs.CR[6].eq ) { return 0x8226AF14;  }
		/* 8226AEE8h case    0:*/		return 0x8226AEEC;
		  /* 8226AEECh */ case    1:  		/* lwz R11, <#[R4 + 8]> */
		/* 8226AEECh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 8226AEECh case    1:*/		return 0x8226AEF0;
		  /* 8226AEF0h */ case    2:  		/* rlwinm. R11, R11, 0, 0, 0 */
		/* 8226AEF0h case    2:*/		cpu::op::rlwinm<1,0,0,0>(regs,&regs.R11,regs.R11);
		/* 8226AEF0h case    2:*/		return 0x8226AEF4;
		  /* 8226AEF4h */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 8226AEF4h case    3:*/		if ( regs.CR[0].eq ) { return 0x8226AF04;  }
		/* 8226AEF4h case    3:*/		return 0x8226AEF8;
	}
	return 0x8226AEF8;
} // Block from 8226AEE8h-8226AEF8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AEF8h
// Function 'XexUnloadImage'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AEF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AEF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AEF8);
		  /* 8226AEF8h */ case    0:  		/* lis R11, -32251 */
		/* 8226AEF8h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8226AEF8h case    0:*/		return 0x8226AEFC;
		  /* 8226AEFCh */ case    1:  		/* addi R4, R11, -16344 */
		/* 8226AEFCh case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFC028);
		/* 8226AEFCh case    1:*/		return 0x8226AF00;
		  /* 8226AF00h */ case    2:  		/* b 12 */
		/* 8226AF00h case    2:*/		return 0x8226AF0C;
		/* 8226AF00h case    2:*/		return 0x8226AF04;
	}
	return 0x8226AF04;
} // Block from 8226AEF8h-8226AF04h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8226AF04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AF04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AF04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AF04);
		  /* 8226AF04h */ case    0:  		/* lis R11, -32251 */
		/* 8226AF04h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8226AF04h case    0:*/		return 0x8226AF08;
	}
	return 0x8226AF08;
} // Block from 8226AF04h-8226AF08h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226AF08h
// Function 'XexGetProcedureAddress'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AF08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AF08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AF08);
		  /* 8226AF08h */ case    0:  		/* addi R4, R11, -16352 */
		/* 8226AF08h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFC020);
		/* 8226AF08h case    0:*/		return 0x8226AF0C;
	}
	return 0x8226AF0C;
} // Block from 8226AF08h-8226AF0Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226AF0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AF0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AF0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AF0C);
		  /* 8226AF0Ch */ case    0:  		/* mr R3, R31 */
		/* 8226AF0Ch case    0:*/		regs.R3 = regs.R31;
		/* 8226AF0Ch case    0:*/		return 0x8226AF10;
		  /* 8226AF10h */ case    1:  		/* bl -5424 */
		/* 8226AF10h case    1:*/		regs.LR = 0x8226AF14; return 0x822699E0;
		/* 8226AF10h case    1:*/		return 0x8226AF14;
	}
	return 0x8226AF14;
} // Block from 8226AF0Ch-8226AF14h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226AF14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AF14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AF14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AF14);
		  /* 8226AF14h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 8226AF14h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8226AF14h case    0:*/		return 0x8226AF18;
	}
	return 0x8226AF18;
} // Block from 8226AF14h-8226AF18h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226AF18h
// Function 'XexLoadImage'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AF18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AF18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AF18);
		  /* 8226AF18h */ case    0:  		/* cmpwi CR6, R23, 0 */
		/* 8226AF18h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R23,0x00000000);
		/* 8226AF18h case    0:*/		return 0x8226AF1C;
		  /* 8226AF1Ch */ case    1:  		/* rlwinm R5, R11, 0, 27, 31 */
		/* 8226AF1Ch case    1:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R5,regs.R11);
		/* 8226AF1Ch case    1:*/		return 0x8226AF20;
		  /* 8226AF20h */ case    2:  		/* bc 4, CR6_EQ, 2104 */
		/* 8226AF20h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8226B758;  }
		/* 8226AF20h case    2:*/		return 0x8226AF24;
		  /* 8226AF24h */ case    3:  		/* cmpwi CR6, R5, 0 */
		/* 8226AF24h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 8226AF24h case    3:*/		return 0x8226AF28;
	}
	return 0x8226AF28;
} // Block from 8226AF18h-8226AF28h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AF28h
// Function 'KeSetAffinityThread'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AF28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AF28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AF28);
		  /* 8226AF28h */ case    0:  		/* bc 12, CR6_EQ, 2124 */
		/* 8226AF28h case    0:*/		if ( regs.CR[6].eq ) { return 0x8226B774;  }
		/* 8226AF28h case    0:*/		return 0x8226AF2C;
		  /* 8226AF2Ch */ case    1:  		/* cmpwi CR6, R5, 1 */
		/* 8226AF2Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000001);
		/* 8226AF2Ch case    1:*/		return 0x8226AF30;
		  /* 8226AF30h */ case    2:  		/* bc 12, CR6_EQ, 48 */
		/* 8226AF30h case    2:*/		if ( regs.CR[6].eq ) { return 0x8226AF60;  }
		/* 8226AF30h case    2:*/		return 0x8226AF34;
		  /* 8226AF34h */ case    3:  		/* cmpwi CR6, R5, 15 */
		/* 8226AF34h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x0000000F);
		/* 8226AF34h case    3:*/		return 0x8226AF38;
	}
	return 0x8226AF38;
} // Block from 8226AF28h-8226AF38h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AF38h
// Function 'RtlImageXexHeaderField'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AF38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AF38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AF38);
		  /* 8226AF38h */ case    0:  		/* bc 4, CR6_GT, 28 */
		/* 8226AF38h case    0:*/		if ( !regs.CR[6].gt ) { return 0x8226AF54;  }
		/* 8226AF38h case    0:*/		return 0x8226AF3C;
		  /* 8226AF3Ch */ case    1:  		/* cmpwi CR6, R5, 19 */
		/* 8226AF3Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000013);
		/* 8226AF3Ch case    1:*/		return 0x8226AF40;
		  /* 8226AF40h */ case    2:  		/* bc 4, CR6_GT, 32 */
		/* 8226AF40h case    2:*/		if ( !regs.CR[6].gt ) { return 0x8226AF60;  }
		/* 8226AF40h case    2:*/		return 0x8226AF44;
		  /* 8226AF44h */ case    3:  		/* cmpwi CR6, R5, 23 */
		/* 8226AF44h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000017);
		/* 8226AF44h case    3:*/		return 0x8226AF48;
	}
	return 0x8226AF48;
} // Block from 8226AF38h-8226AF48h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AF48h
// Function 'HalReturnToFirmware'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AF48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AF48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AF48);
		  /* 8226AF48h */ case    0:  		/* bc 4, CR6_GT, 12 */
		/* 8226AF48h case    0:*/		if ( !regs.CR[6].gt ) { return 0x8226AF54;  }
		/* 8226AF48h case    0:*/		return 0x8226AF4C;
		  /* 8226AF4Ch */ case    1:  		/* cmpwi CR6, R5, 26 */
		/* 8226AF4Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x0000001A);
		/* 8226AF4Ch case    1:*/		return 0x8226AF50;
		  /* 8226AF50h */ case    2:  		/* bc 4, CR6_GT, 16 */
		/* 8226AF50h case    2:*/		if ( !regs.CR[6].gt ) { return 0x8226AF60;  }
		/* 8226AF50h case    2:*/		return 0x8226AF54;
	}
	return 0x8226AF54;
} // Block from 8226AF48h-8226AF54h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8226AF54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AF54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AF54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AF54);
		  /* 8226AF54h */ case    0:  		/* lis R11, -32251 */
		/* 8226AF54h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8226AF54h case    0:*/		return 0x8226AF58;
	}
	return 0x8226AF58;
} // Block from 8226AF54h-8226AF58h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226AF58h
// Function 'NtQueryFullAttributesFile'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AF58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AF58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AF58);
		  /* 8226AF58h */ case    0:  		/* addi R4, R11, -15952 */
		/* 8226AF58h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFC1B0);
		/* 8226AF58h case    0:*/		return 0x8226AF5C;
		  /* 8226AF5Ch */ case    1:  		/* b 2060 */
		/* 8226AF5Ch case    1:*/		return 0x8226B768;
		/* 8226AF5Ch case    1:*/		return 0x8226AF60;
	}
	return 0x8226AF60;
} // Block from 8226AF58h-8226AF60h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226AF60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AF60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AF60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AF60);
		  /* 8226AF60h */ case    0:  		/* lis R11, -32252 */
		/* 8226AF60h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8226AF60h case    0:*/		return 0x8226AF64;
		  /* 8226AF64h */ case    1:  		/* cmplwi CR6, R5, 19 */
		/* 8226AF64h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000013);
		/* 8226AF64h case    1:*/		return 0x8226AF68;
	}
	return 0x8226AF68;
} // Block from 8226AF60h-8226AF68h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226AF68h
// Function 'NtQueryDirectoryFile'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AF68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AF68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AF68);
		  /* 8226AF68h */ case    0:  		/* addi R4, R11, -22820 */
		/* 8226AF68h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFA6DC);
		/* 8226AF68h case    0:*/		return 0x8226AF6C;
		  /* 8226AF6Ch */ case    1:  		/* bc 12, CR6_GT, 112 */
		/* 8226AF6Ch case    1:*/		if ( regs.CR[6].gt ) { return 0x8226AFDC;  }
		/* 8226AF6Ch case    1:*/		return 0x8226AF70;
		  /* 8226AF70h */ case    2:  		/* bc 12, CR6_EQ, 96 */
		/* 8226AF70h case    2:*/		if ( regs.CR[6].eq ) { return 0x8226AFD0;  }
		/* 8226AF70h case    2:*/		return 0x8226AF74;
		  /* 8226AF74h */ case    3:  		/* cmplwi CR6, R5, 1 */
		/* 8226AF74h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000001);
		/* 8226AF74h case    3:*/		return 0x8226AF78;
	}
	return 0x8226AF78;
} // Block from 8226AF68h-8226AF78h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AF78h
// Function 'NtReadFileScatter'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AF78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AF78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AF78);
		  /* 8226AF78h */ case    0:  		/* bc 12, CR6_EQ, 64 */
		/* 8226AF78h case    0:*/		if ( regs.CR[6].eq ) { return 0x8226AFB8;  }
		/* 8226AF78h case    0:*/		return 0x8226AF7C;
		  /* 8226AF7Ch */ case    1:  		/* cmplwi CR6, R5, 16 */
		/* 8226AF7Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000010);
		/* 8226AF7Ch case    1:*/		return 0x8226AF80;
		  /* 8226AF80h */ case    2:  		/* bc 12, CR6_EQ, 44 */
		/* 8226AF80h case    2:*/		if ( regs.CR[6].eq ) { return 0x8226AFAC;  }
		/* 8226AF80h case    2:*/		return 0x8226AF84;
		  /* 8226AF84h */ case    3:  		/* cmplwi CR6, R5, 17 */
		/* 8226AF84h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000011);
		/* 8226AF84h case    3:*/		return 0x8226AF88;
	}
	return 0x8226AF88;
} // Block from 8226AF78h-8226AF88h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AF88h
// Function 'NtReadFile'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AF88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AF88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AF88);
		  /* 8226AF88h */ case    0:  		/* bc 12, CR6_EQ, 24 */
		/* 8226AF88h case    0:*/		if ( regs.CR[6].eq ) { return 0x8226AFA0;  }
		/* 8226AF88h case    0:*/		return 0x8226AF8C;
		  /* 8226AF8Ch */ case    1:  		/* cmplwi CR6, R5, 18 */
		/* 8226AF8Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000012);
		/* 8226AF8Ch case    1:*/		return 0x8226AF90;
		  /* 8226AF90h */ case    2:  		/* bc 4, CR6_EQ, 132 */
		/* 8226AF90h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8226B014;  }
		/* 8226AF90h case    2:*/		return 0x8226AF94;
		  /* 8226AF94h */ case    3:  		/* lis R11, -32255 */
		/* 8226AF94h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8226AF94h case    3:*/		return 0x8226AF98;
	}
	return 0x8226AF98;
} // Block from 8226AF88h-8226AF98h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AF98h
// Function 'NtCreateFile'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AF98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AF98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AF98);
		  /* 8226AF98h */ case    0:  		/* addi R4, R11, 13060 */
		/* 8226AF98h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x3304);
		/* 8226AF98h case    0:*/		return 0x8226AF9C;
		  /* 8226AF9Ch */ case    1:  		/* b 120 */
		/* 8226AF9Ch case    1:*/		return 0x8226B014;
		/* 8226AF9Ch case    1:*/		return 0x8226AFA0;
	}
	return 0x8226AFA0;
} // Block from 8226AF98h-8226AFA0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226AFA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AFA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AFA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AFA0);
		  /* 8226AFA0h */ case    0:  		/* lis R10, -32216 */
		/* 8226AFA0h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8228);
		/* 8226AFA0h case    0:*/		return 0x8226AFA4;
		  /* 8226AFA4h */ case    1:  		/* addi R10, R10, 28608 */
		/* 8226AFA4h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x6FC0);
		/* 8226AFA4h case    1:*/		return 0x8226AFA8;
	}
	return 0x8226AFA8;
} // Block from 8226AFA0h-8226AFA8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226AFA8h
// Function 'NtDuplicateObject'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AFA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AFA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AFA8);
		  /* 8226AFA8h */ case    0:  		/* b 24 */
		/* 8226AFA8h case    0:*/		return 0x8226AFC0;
		/* 8226AFA8h case    0:*/		return 0x8226AFAC;
	}
	return 0x8226AFAC;
} // Block from 8226AFA8h-8226AFACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226AFACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AFAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AFAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AFAC);
		  /* 8226AFACh */ case    0:  		/* lis R10, -32216 */
		/* 8226AFACh case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8228);
		/* 8226AFACh case    0:*/		return 0x8226AFB0;
		  /* 8226AFB0h */ case    1:  		/* addi R10, R10, 28592 */
		/* 8226AFB0h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x6FB0);
		/* 8226AFB0h case    1:*/		return 0x8226AFB4;
		  /* 8226AFB4h */ case    2:  		/* b 12 */
		/* 8226AFB4h case    2:*/		return 0x8226AFC0;
		/* 8226AFB4h case    2:*/		return 0x8226AFB8;
	}
	return 0x8226AFB8;
} // Block from 8226AFACh-8226AFB8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8226AFB8h
// Function 'RtlNtStatusToDosError'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AFB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AFB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AFB8);
		  /* 8226AFB8h */ case    0:  		/* lis R10, -32216 */
		/* 8226AFB8h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8228);
		/* 8226AFB8h case    0:*/		return 0x8226AFBC;
		  /* 8226AFBCh */ case    1:  		/* addi R10, R10, 28576 */
		/* 8226AFBCh case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x6FA0);
		/* 8226AFBCh case    1:*/		return 0x8226AFC0;
	}
	return 0x8226AFC0;
} // Block from 8226AFB8h-8226AFC0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226AFC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AFC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AFC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AFC0);
		  /* 8226AFC0h */ case    0:  		/* lwz R11, <#[R29 + 8]> */
		/* 8226AFC0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8226AFC0h case    0:*/		return 0x8226AFC4;
		  /* 8226AFC4h */ case    1:  		/* rlwinm R11, R11, 20, 28, 29 */
		/* 8226AFC4h case    1:*/		cpu::op::rlwinm<0,20,28,29>(regs,&regs.R11,regs.R11);
		/* 8226AFC4h case    1:*/		return 0x8226AFC8;
	}
	return 0x8226AFC8;
} // Block from 8226AFC0h-8226AFC8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226AFC8h
// Function 'ExCreateThread'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AFC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AFC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AFC8);
		  /* 8226AFC8h */ case    0:  		/* lwzx R4, <#[R11 + R10]> */
		/* 8226AFC8h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8226AFC8h case    0:*/		return 0x8226AFCC;
		  /* 8226AFCCh */ case    1:  		/* b 72 */
		/* 8226AFCCh case    1:*/		return 0x8226B014;
		/* 8226AFCCh case    1:*/		return 0x8226AFD0;
	}
	return 0x8226AFD0;
} // Block from 8226AFC8h-8226AFD0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226AFD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AFD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AFD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AFD0);
		  /* 8226AFD0h */ case    0:  		/* lis R10, -32216 */
		/* 8226AFD0h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8228);
		/* 8226AFD0h case    0:*/		return 0x8226AFD4;
		  /* 8226AFD4h */ case    1:  		/* addi R10, R10, 28560 */
		/* 8226AFD4h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x6F90);
		/* 8226AFD4h case    1:*/		return 0x8226AFD8;
	}
	return 0x8226AFD8;
} // Block from 8226AFD0h-8226AFD8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226AFD8h
// Function 'NtAllocateVirtualMemory'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AFD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AFD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AFD8);
		  /* 8226AFD8h */ case    0:  		/* b -24 */
		/* 8226AFD8h case    0:*/		return 0x8226AFC0;
		/* 8226AFD8h case    0:*/		return 0x8226AFDC;
	}
	return 0x8226AFDC;
} // Block from 8226AFD8h-8226AFDCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226AFDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AFDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AFDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AFDC);
		  /* 8226AFDCh */ case    0:  		/* cmplwi CR6, R5, 24 */
		/* 8226AFDCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000018);
		/* 8226AFDCh case    0:*/		return 0x8226AFE0;
		  /* 8226AFE0h */ case    1:  		/* bc 12, CR6_EQ, 44 */
		/* 8226AFE0h case    1:*/		if ( regs.CR[6].eq ) { return 0x8226B00C;  }
		/* 8226AFE0h case    1:*/		return 0x8226AFE4;
		  /* 8226AFE4h */ case    2:  		/* cmplwi CR6, R5, 25 */
		/* 8226AFE4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000019);
		/* 8226AFE4h case    2:*/		return 0x8226AFE8;
	}
	return 0x8226AFE8;
} // Block from 8226AFDCh-8226AFE8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8226AFE8h
// Function 'KeBugCheckEx'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AFE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AFE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AFE8);
		  /* 8226AFE8h */ case    0:  		/* bc 12, CR6_EQ, 24 */
		/* 8226AFE8h case    0:*/		if ( regs.CR[6].eq ) { return 0x8226B000;  }
		/* 8226AFE8h case    0:*/		return 0x8226AFEC;
		  /* 8226AFECh */ case    1:  		/* cmplwi CR6, R5, 26 */
		/* 8226AFECh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x0000001A);
		/* 8226AFECh case    1:*/		return 0x8226AFF0;
		  /* 8226AFF0h */ case    2:  		/* bc 4, CR6_EQ, 36 */
		/* 8226AFF0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8226B014;  }
		/* 8226AFF0h case    2:*/		return 0x8226AFF4;
		  /* 8226AFF4h */ case    3:  		/* lis R11, -32255 */
		/* 8226AFF4h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8226AFF4h case    3:*/		return 0x8226AFF8;
	}
	return 0x8226AFF8;
} // Block from 8226AFE8h-8226AFF8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226AFF8h
// Function 'NtFreeVirtualMemory'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226AFF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226AFF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226AFF8);
		  /* 8226AFF8h */ case    0:  		/* addi R4, R11, 12952 */
		/* 8226AFF8h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x3298);
		/* 8226AFF8h case    0:*/		return 0x8226AFFC;
		  /* 8226AFFCh */ case    1:  		/* b 24 */
		/* 8226AFFCh case    1:*/		return 0x8226B014;
		/* 8226AFFCh case    1:*/		return 0x8226B000;
	}
	return 0x8226B000;
} // Block from 8226AFF8h-8226B000h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226B000h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B000( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B000) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B000);
		  /* 8226B000h */ case    0:  		/* lis R11, -32255 */
		/* 8226B000h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8226B000h case    0:*/		return 0x8226B004;
		  /* 8226B004h */ case    1:  		/* addi R4, R11, 12968 */
		/* 8226B004h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x32A8);
		/* 8226B004h case    1:*/		return 0x8226B008;
	}
	return 0x8226B008;
} // Block from 8226B000h-8226B008h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226B008h
// Function 'RtlCompareMemoryUlong'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B008( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B008) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B008);
		  /* 8226B008h */ case    0:  		/* b 12 */
		/* 8226B008h case    0:*/		return 0x8226B014;
		/* 8226B008h case    0:*/		return 0x8226B00C;
	}
	return 0x8226B00C;
} // Block from 8226B008h-8226B00Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226B00Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B00C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B00C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B00C);
		  /* 8226B00Ch */ case    0:  		/* lis R11, -32255 */
		/* 8226B00Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8226B00Ch case    0:*/		return 0x8226B010;
		  /* 8226B010h */ case    1:  		/* addi R4, R11, 12984 */
		/* 8226B010h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x32B8);
		/* 8226B010h case    1:*/		return 0x8226B014;
	}
	return 0x8226B014;
} // Block from 8226B00Ch-8226B014h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226B014h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B014( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B014) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B014);
		  /* 8226B014h */ case    0:  		/* li R5, 0 */
		/* 8226B014h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8226B014h case    0:*/		return 0x8226B018;
	}
	return 0x8226B018;
} // Block from 8226B014h-8226B018h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226B018h
// Function 'NtQueryVirtualMemory'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B018( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B018) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B018);
		  /* 8226B018h */ case    0:  		/* mr R3, R31 */
		/* 8226B018h case    0:*/		regs.R3 = regs.R31;
		/* 8226B018h case    0:*/		return 0x8226B01C;
		  /* 8226B01Ch */ case    1:  		/* bl -5340 */
		/* 8226B01Ch case    1:*/		regs.LR = 0x8226B020; return 0x82269B40;
		/* 8226B01Ch case    1:*/		return 0x8226B020;
		  /* 8226B020h */ case    2:  		/* lis R11, -32255 */
		/* 8226B020h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8226B020h case    2:*/		return 0x8226B024;
		  /* 8226B024h */ case    3:  		/* mr R3, R31 */
		/* 8226B024h case    3:*/		regs.R3 = regs.R31;
		/* 8226B024h case    3:*/		return 0x8226B028;
	}
	return 0x8226B028;
} // Block from 8226B018h-8226B028h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226B028h
// Function 'ExTerminateThread'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B028( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B028) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B028);
		  /* 8226B028h */ case    0:  		/* addi R4, R11, -15864 */
		/* 8226B028h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFC208);
		/* 8226B028h case    0:*/		return 0x8226B02C;
		  /* 8226B02Ch */ case    1:  		/* bl -5708 */
		/* 8226B02Ch case    1:*/		regs.LR = 0x8226B030; return 0x822699E0;
		/* 8226B02Ch case    1:*/		return 0x8226B030;
		  /* 8226B030h */ case    2:  		/* lis R11, -32253 */
		/* 8226B030h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 8226B030h case    2:*/		return 0x8226B034;
		  /* 8226B034h */ case    3:  		/* lis R10, -32216 */
		/* 8226B034h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8228);
		/* 8226B034h case    3:*/		return 0x8226B038;
	}
	return 0x8226B038;
} // Block from 8226B028h-8226B038h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226B038h
// Function 'XGetVideoMode'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B038( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B038) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B038);
		  /* 8226B038h */ case    0:  		/* addi R30, R11, 25796 */
		/* 8226B038h case    0:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0x64C4);
		/* 8226B038h case    0:*/		return 0x8226B03C;
		  /* 8226B03Ch */ case    1:  		/* addi R28, R10, 27664 */
		/* 8226B03Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R10,0x6C10);
		/* 8226B03Ch case    1:*/		return 0x8226B040;
		  /* 8226B040h */ case    2:  		/* lis R9, -32256 */
		/* 8226B040h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 8226B040h case    2:*/		return 0x8226B044;
		  /* 8226B044h */ case    3:  		/* addi R27, R9, 20592 */
		/* 8226B044h case    3:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R9,0x5070);
		/* 8226B044h case    3:*/		return 0x8226B048;
	}
	return 0x8226B048;
} // Block from 8226B038h-8226B048h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226B048h
// Function 'XamInputGetCapabilities'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B048( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B048) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B048);
		  /* 8226B048h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 8226B048h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8226B048h case    0:*/		return 0x8226B04C;
		  /* 8226B04Ch */ case    1:  		/* rlwinm R10, R11, 0, 27, 31 */
		/* 8226B04Ch case    1:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R11);
		/* 8226B04Ch case    1:*/		return 0x8226B050;
		  /* 8226B050h */ case    2:  		/* cmplwi CR6, R10, 19 */
		/* 8226B050h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000013);
		/* 8226B050h case    2:*/		return 0x8226B054;
		  /* 8226B054h */ case    3:  		/* bc 12, CR6_GT, 232 */
		/* 8226B054h case    3:*/		if ( regs.CR[6].gt ) { return 0x8226B13C;  }
		/* 8226B054h case    3:*/		return 0x8226B058;
	}
	return 0x8226B058;
} // Block from 8226B048h-8226B058h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226B058h
// Function 'XamInputGetState'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B058( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B058) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B058);
		  /* 8226B058h */ case    0:  		/* rlwinm. R10, R11, 0, 13, 13 */
		/* 8226B058h case    0:*/		cpu::op::rlwinm<1,0,13,13>(regs,&regs.R10,regs.R11);
		/* 8226B058h case    0:*/		return 0x8226B05C;
		  /* 8226B05Ch */ case    1:  		/* rlwinm R5, R11, 20, 26, 31 */
		/* 8226B05Ch case    1:*/		cpu::op::rlwinm<0,20,26,31>(regs,&regs.R5,regs.R11);
		/* 8226B05Ch case    1:*/		return 0x8226B060;
		  /* 8226B060h */ case    2:  		/* mr R3, R31 */
		/* 8226B060h case    2:*/		regs.R3 = regs.R31;
		/* 8226B060h case    2:*/		return 0x8226B064;
		  /* 8226B064h */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 8226B064h case    3:*/		if ( regs.CR[0].eq ) { return 0x8226B074;  }
		/* 8226B064h case    3:*/		return 0x8226B068;
	}
	return 0x8226B068;
} // Block from 8226B058h-8226B068h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226B068h
// Function 'XamLaunchNewImage'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B068( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B068) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B068);
		  /* 8226B068h */ case    0:  		/* lis R11, -32252 */
		/* 8226B068h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8226B068h case    0:*/		return 0x8226B06C;
		  /* 8226B06Ch */ case    1:  		/* addi R4, R11, -23632 */
		/* 8226B06Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFA3B0);
		/* 8226B06Ch case    1:*/		return 0x8226B070;
		  /* 8226B070h */ case    2:  		/* b 12 */
		/* 8226B070h case    2:*/		return 0x8226B07C;
		/* 8226B070h case    2:*/		return 0x8226B074;
	}
	return 0x8226B074;
} // Block from 8226B068h-8226B074h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8226B074h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B074( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B074) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B074);
		  /* 8226B074h */ case    0:  		/* lis R11, -32252 */
		/* 8226B074h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8226B074h case    0:*/		return 0x8226B078;
	}
	return 0x8226B078;
} // Block from 8226B074h-8226B078h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226B078h
// Function 'TlsGetValue'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B078);
		  /* 8226B078h */ case    0:  		/* addi R4, R11, -23636 */
		/* 8226B078h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFA3AC);
		/* 8226B078h case    0:*/		return 0x8226B07C;
	}
	return 0x8226B07C;
} // Block from 8226B078h-8226B07Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226B07Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B07C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B07C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B07C);
		  /* 8226B07Ch */ case    0:  		/* bl -5788 */
		/* 8226B07Ch case    0:*/		regs.LR = 0x8226B080; return 0x822699E0;
		/* 8226B07Ch case    0:*/		return 0x8226B080;
		  /* 8226B080h */ case    1:  		/* lwz R11, <#[R29 + 4]> */
		/* 8226B080h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 8226B080h case    1:*/		return 0x8226B084;
		  /* 8226B084h */ case    2:  		/* rlwinm. R10, R11, 0, 29, 31 */
		/* 8226B084h case    2:*/		cpu::op::rlwinm<1,0,29,31>(regs,&regs.R10,regs.R11);
		/* 8226B084h case    2:*/		return 0x8226B088;
	}
	return 0x8226B088;
} // Block from 8226B07Ch-8226B088h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8226B088h
// Function 'TlsSetValue'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B088( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B088) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B088);
		  /* 8226B088h */ case    0:  		/* bc 4, CR0_EQ, 40 */
		/* 8226B088h case    0:*/		if ( !regs.CR[0].eq ) { return 0x8226B0B0;  }
		/* 8226B088h case    0:*/		return 0x8226B08C;
		  /* 8226B08Ch */ case    1:  		/* rlwinm R10, R11, 0, 26, 28 */
		/* 8226B08Ch case    1:*/		cpu::op::rlwinm<0,0,26,28>(regs,&regs.R10,regs.R11);
		/* 8226B08Ch case    1:*/		return 0x8226B090;
		  /* 8226B090h */ case    2:  		/* cmplwi CR6, R10, 8 */
		/* 8226B090h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000008);
		/* 8226B090h case    2:*/		return 0x8226B094;
		  /* 8226B094h */ case    3:  		/* bc 4, CR6_EQ, 28 */
		/* 8226B094h case    3:*/		if ( !regs.CR[6].eq ) { return 0x8226B0B0;  }
		/* 8226B094h case    3:*/		return 0x8226B098;
	}
	return 0x8226B098;
} // Block from 8226B088h-8226B098h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226B098h
// Function 'TlsFree'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B098( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B098) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B098);
		  /* 8226B098h */ case    0:  		/* rlwinm R10, R11, 0, 23, 25 */
		/* 8226B098h case    0:*/		cpu::op::rlwinm<0,0,23,25>(regs,&regs.R10,regs.R11);
		/* 8226B098h case    0:*/		return 0x8226B09C;
		  /* 8226B09Ch */ case    1:  		/* cmplwi CR6, R10, 128 */
		/* 8226B09Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000080);
		/* 8226B09Ch case    1:*/		return 0x8226B0A0;
		  /* 8226B0A0h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 8226B0A0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x8226B0B0;  }
		/* 8226B0A0h case    2:*/		return 0x8226B0A4;
		  /* 8226B0A4h */ case    3:  		/* rlwinm R11, R11, 0, 20, 22 */
		/* 8226B0A4h case    3:*/		cpu::op::rlwinm<0,0,20,22>(regs,&regs.R11,regs.R11);
		/* 8226B0A4h case    3:*/		return 0x8226B0A8;
	}
	return 0x8226B0A8;
} // Block from 8226B098h-8226B0A8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226B0A8h
// Function 'TlsAlloc'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B0A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B0A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B0A8);
		  /* 8226B0A8h */ case    0:  		/* cmplwi CR6, R11, 1536 */
		/* 8226B0A8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000600);
		/* 8226B0A8h case    0:*/		return 0x8226B0AC;
		  /* 8226B0ACh */ case    1:  		/* bc 12, CR6_EQ, 128 */
		/* 8226B0ACh case    1:*/		if ( regs.CR[6].eq ) { return 0x8226B12C;  }
		/* 8226B0ACh case    1:*/		return 0x8226B0B0;
	}
	return 0x8226B0B0;
} // Block from 8226B0A8h-8226B0B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226B0B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B0B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B0B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B0B0);
		  /* 8226B0B0h */ case    0:  		/* mr R4, R27 */
		/* 8226B0B0h case    0:*/		regs.R4 = regs.R27;
		/* 8226B0B0h case    0:*/		return 0x8226B0B4;
		  /* 8226B0B4h */ case    1:  		/* mr R3, R31 */
		/* 8226B0B4h case    1:*/		regs.R3 = regs.R31;
		/* 8226B0B4h case    1:*/		return 0x8226B0B8;
	}
	return 0x8226B0B8;
} // Block from 8226B0B0h-8226B0B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226B0B8h
// Function 'RtlInitializeCriticalSectionAndSpinCount'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B0B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B0B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B0B8);
		  /* 8226B0B8h */ case    0:  		/* bl -5848 */
		/* 8226B0B8h case    0:*/		regs.LR = 0x8226B0BC; return 0x822699E0;
		/* 8226B0B8h case    0:*/		return 0x8226B0BC;
		  /* 8226B0BCh */ case    1:  		/* lwz R11, <#[R29 + 4]> */
		/* 8226B0BCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 8226B0BCh case    1:*/		return 0x8226B0C0;
		  /* 8226B0C0h */ case    2:  		/* mr R4, R30 */
		/* 8226B0C0h case    2:*/		regs.R4 = regs.R30;
		/* 8226B0C0h case    2:*/		return 0x8226B0C4;
		  /* 8226B0C4h */ case    3:  		/* rlwinm R11, R11, 0, 29, 31 */
		/* 8226B0C4h case    3:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R11,regs.R11);
		/* 8226B0C4h case    3:*/		return 0x8226B0C8;
	}
	return 0x8226B0C8;
} // Block from 8226B0B8h-8226B0C8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226B0C8h
// Function 'KeEnableFpuExceptions'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B0C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B0C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B0C8);
		  /* 8226B0C8h */ case    0:  		/* mr R3, R31 */
		/* 8226B0C8h case    0:*/		regs.R3 = regs.R31;
		/* 8226B0C8h case    0:*/		return 0x8226B0CC;
		  /* 8226B0CCh */ case    1:  		/* lbzx R11, <#[R11 + R28]> */
		/* 8226B0CCh case    1:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 8226B0CCh case    1:*/		return 0x8226B0D0;
		  /* 8226B0D0h */ case    2:  		/* extsb R5, R11 */
		/* 8226B0D0h case    2:*/		cpu::op::extsb<0>(regs,&regs.R5,regs.R11);
		/* 8226B0D0h case    2:*/		return 0x8226B0D4;
		  /* 8226B0D4h */ case    3:  		/* bl -5876 */
		/* 8226B0D4h case    3:*/		regs.LR = 0x8226B0D8; return 0x822699E0;
		/* 8226B0D4h case    3:*/		return 0x8226B0D8;
	}
	return 0x8226B0D8;
} // Block from 8226B0C8h-8226B0D8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226B0D8h
// Function 'RtlUnwind'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B0D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B0D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B0D8);
		  /* 8226B0D8h */ case    0:  		/* lwz R11, <#[R29 + 4]> */
		/* 8226B0D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 8226B0D8h case    0:*/		return 0x8226B0DC;
		  /* 8226B0DCh */ case    1:  		/* mr R4, R30 */
		/* 8226B0DCh case    1:*/		regs.R4 = regs.R30;
		/* 8226B0DCh case    1:*/		return 0x8226B0E0;
		  /* 8226B0E0h */ case    2:  		/* rlwinm R11, R11, 29, 29, 31 */
		/* 8226B0E0h case    2:*/		cpu::op::rlwinm<0,29,29,31>(regs,&regs.R11,regs.R11);
		/* 8226B0E0h case    2:*/		return 0x8226B0E4;
		  /* 8226B0E4h */ case    3:  		/* mr R3, R31 */
		/* 8226B0E4h case    3:*/		regs.R3 = regs.R31;
		/* 8226B0E4h case    3:*/		return 0x8226B0E8;
	}
	return 0x8226B0E8;
} // Block from 8226B0D8h-8226B0E8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226B0E8h
// Function 'DbgBreakPoint'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B0E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B0E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B0E8);
		  /* 8226B0E8h */ case    0:  		/* lbzx R11, <#[R11 + R28]> */
		/* 8226B0E8h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 8226B0E8h case    0:*/		return 0x8226B0EC;
		  /* 8226B0ECh */ case    1:  		/* extsb R5, R11 */
		/* 8226B0ECh case    1:*/		cpu::op::extsb<0>(regs,&regs.R5,regs.R11);
		/* 8226B0ECh case    1:*/		return 0x8226B0F0;
		  /* 8226B0F0h */ case    2:  		/* bl -5904 */
		/* 8226B0F0h case    2:*/		regs.LR = 0x8226B0F4; return 0x822699E0;
		/* 8226B0F0h case    2:*/		return 0x8226B0F4;
		  /* 8226B0F4h */ case    3:  		/* lwz R11, <#[R29 + 4]> */
		/* 8226B0F4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 8226B0F4h case    3:*/		return 0x8226B0F8;
	}
	return 0x8226B0F8;
} // Block from 8226B0E8h-8226B0F8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226B0F8h
// Function 'RtlFreeAnsiString'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B0F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B0F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B0F8);
		  /* 8226B0F8h */ case    0:  		/* mr R4, R30 */
		/* 8226B0F8h case    0:*/		regs.R4 = regs.R30;
		/* 8226B0F8h case    0:*/		return 0x8226B0FC;
		  /* 8226B0FCh */ case    1:  		/* rlwinm R11, R11, 26, 29, 31 */
		/* 8226B0FCh case    1:*/		cpu::op::rlwinm<0,26,29,31>(regs,&regs.R11,regs.R11);
		/* 8226B0FCh case    1:*/		return 0x8226B100;
		  /* 8226B100h */ case    2:  		/* mr R3, R31 */
		/* 8226B100h case    2:*/		regs.R3 = regs.R31;
		/* 8226B100h case    2:*/		return 0x8226B104;
		  /* 8226B104h */ case    3:  		/* lbzx R11, <#[R11 + R28]> */
		/* 8226B104h case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 8226B104h case    3:*/		return 0x8226B108;
	}
	return 0x8226B108;
} // Block from 8226B0F8h-8226B108h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226B108h
// Function 'RtlUnicodeStringToAnsiString'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B108( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B108) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B108);
		  /* 8226B108h */ case    0:  		/* extsb R5, R11 */
		/* 8226B108h case    0:*/		cpu::op::extsb<0>(regs,&regs.R5,regs.R11);
		/* 8226B108h case    0:*/		return 0x8226B10C;
		  /* 8226B10Ch */ case    1:  		/* bl -5932 */
		/* 8226B10Ch case    1:*/		regs.LR = 0x8226B110; return 0x822699E0;
		/* 8226B10Ch case    1:*/		return 0x8226B110;
		  /* 8226B110h */ case    2:  		/* lwz R11, <#[R29 + 4]> */
		/* 8226B110h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 8226B110h case    2:*/		return 0x8226B114;
		  /* 8226B114h */ case    3:  		/* mr R4, R30 */
		/* 8226B114h case    3:*/		regs.R4 = regs.R30;
		/* 8226B114h case    3:*/		return 0x8226B118;
	}
	return 0x8226B118;
} // Block from 8226B108h-8226B118h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226B118h
// Function 'RtlInitUnicodeString'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B118( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B118) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B118);
		  /* 8226B118h */ case    0:  		/* rlwinm R11, R11, 23, 29, 31 */
		/* 8226B118h case    0:*/		cpu::op::rlwinm<0,23,29,31>(regs,&regs.R11,regs.R11);
		/* 8226B118h case    0:*/		return 0x8226B11C;
		  /* 8226B11Ch */ case    1:  		/* mr R3, R31 */
		/* 8226B11Ch case    1:*/		regs.R3 = regs.R31;
		/* 8226B11Ch case    1:*/		return 0x8226B120;
		  /* 8226B120h */ case    2:  		/* lbzx R11, <#[R11 + R28]> */
		/* 8226B120h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 8226B120h case    2:*/		return 0x8226B124;
		  /* 8226B124h */ case    3:  		/* extsb R5, R11 */
		/* 8226B124h case    3:*/		cpu::op::extsb<0>(regs,&regs.R5,regs.R11);
		/* 8226B124h case    3:*/		return 0x8226B128;
	}
	return 0x8226B128;
} // Block from 8226B118h-8226B128h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226B128h
// Function 'NtFlushBuffersFile'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B128( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B128) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B128);
		  /* 8226B128h */ case    0:  		/* bl -5960 */
		/* 8226B128h case    0:*/		regs.LR = 0x8226B12C; return 0x822699E0;
		/* 8226B128h case    0:*/		return 0x8226B12C;
	}
	return 0x8226B12C;
} // Block from 8226B128h-8226B12Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226B12Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B12C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B12C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B12C);
		  /* 8226B12Ch */ case    0:  		/* lis R11, -32256 */
		/* 8226B12Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8226B12Ch case    0:*/		return 0x8226B130;
		  /* 8226B130h */ case    1:  		/* mr R3, R31 */
		/* 8226B130h case    1:*/		regs.R3 = regs.R31;
		/* 8226B130h case    1:*/		return 0x8226B134;
		  /* 8226B134h */ case    2:  		/* addi R4, R11, 17860 */
		/* 8226B134h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x45C4);
		/* 8226B134h case    2:*/		return 0x8226B138;
	}
	return 0x8226B138;
} // Block from 8226B12Ch-8226B138h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8226B138h
// Function 'RtlUnicodeToMultiByteN'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B138( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B138) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B138);
		  /* 8226B138h */ case    0:  		/* bl -5976 */
		/* 8226B138h case    0:*/		regs.LR = 0x8226B13C; return 0x822699E0;
		/* 8226B138h case    0:*/		return 0x8226B13C;
	}
	return 0x8226B13C;
} // Block from 8226B138h-8226B13Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226B13Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B13C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B13C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B13C);
		  /* 8226B13Ch */ case    0:  		/* lwz R11, <#[R29]> */
		/* 8226B13Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8226B13Ch case    0:*/		return 0x8226B140;
		  /* 8226B140h */ case    1:  		/* li R9, 4 */
		/* 8226B140h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 8226B140h case    1:*/		return 0x8226B144;
		  /* 8226B144h */ case    2:  		/* li R10, 0 */
		/* 8226B144h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8226B144h case    2:*/		return 0x8226B148;
	}
	return 0x8226B148;
} // Block from 8226B13Ch-8226B148h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8226B148h
// Function 'RtlMultiByteToUnicodeN'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B148( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B148) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B148);
		  /* 8226B148h */ case    0:  		/* rlwinm R5, R11, 27, 25, 25 */
		/* 8226B148h case    0:*/		cpu::op::rlwinm<0,27,25,25>(regs,&regs.R5,regs.R11);
		/* 8226B148h case    0:*/		return 0x8226B14C;
		  /* 8226B14Ch */ case    1:  		/* stw R9, <#[R1 + 84]> */
		/* 8226B14Ch case    1:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000054) );
		/* 8226B14Ch case    1:*/		return 0x8226B150;
		  /* 8226B150h */ case    2:  		/* rlwinm R11, R11, 27, 26, 31 */
		/* 8226B150h case    2:*/		cpu::op::rlwinm<0,27,26,31>(regs,&regs.R11,regs.R11);
		/* 8226B150h case    2:*/		return 0x8226B154;
		  /* 8226B154h */ case    3:  		/* stb R10, <#[R1 + 95]> */
		/* 8226B154h case    3:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R1 + 0x0000005F) );
		/* 8226B154h case    3:*/		return 0x8226B158;
		  /* 8226B158h */ case    4:  		/* li R9, 0 */
		/* 8226B158h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8226B158h case    4:*/		return 0x8226B15C;
		  /* 8226B15Ch */ case    5:  		/* li R8, 0 */
		/* 8226B15Ch case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8226B15Ch case    5:*/		return 0x8226B160;
		  /* 8226B160h */ case    6:  		/* li R7, 0 */
		/* 8226B160h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8226B160h case    6:*/		return 0x8226B164;
		  /* 8226B164h */ case    7:  		/* li R6, 0 */
		/* 8226B164h case    7:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8226B164h case    7:*/		return 0x8226B168;
		  /* 8226B168h */ case    8:  		/* or R5, R5, R11 */
		/* 8226B168h case    8:*/		cpu::op::or<0>(regs,&regs.R5,regs.R5,regs.R11);
		/* 8226B168h case    8:*/		return 0x8226B16C;
		  /* 8226B16Ch */ case    9:  		/* li R4, 1 */
		/* 8226B16Ch case    9:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8226B16Ch case    9:*/		return 0x8226B170;
		  /* 8226B170h */ case   10:  		/* mr R3, R31 */
		/* 8226B170h case   10:*/		regs.R3 = regs.R31;
		/* 8226B170h case   10:*/		return 0x8226B174;
		  /* 8226B174h */ case   11:  		/* bl -4428 */
		/* 8226B174h case   11:*/		regs.LR = 0x8226B178; return 0x8226A028;
		/* 8226B174h case   11:*/		return 0x8226B178;
		  /* 8226B178h */ case   12:  		/* mr R4, R27 */
		/* 8226B178h case   12:*/		regs.R4 = regs.R27;
		/* 8226B178h case   12:*/		return 0x8226B17C;
		  /* 8226B17Ch */ case   13:  		/* mr R3, R31 */
		/* 8226B17Ch case   13:*/		regs.R3 = regs.R31;
		/* 8226B17Ch case   13:*/		return 0x8226B180;
		  /* 8226B180h */ case   14:  		/* bl -6048 */
		/* 8226B180h case   14:*/		regs.LR = 0x8226B184; return 0x822699E0;
		/* 8226B180h case   14:*/		return 0x8226B184;
		  /* 8226B184h */ case   15:  		/* lwz R11, <#[R29]> */
		/* 8226B184h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8226B184h case   15:*/		return 0x8226B188;
		  /* 8226B188h */ case   16:  		/* rlwinm R10, R11, 0, 27, 31 */
		/* 8226B188h case   16:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R11);
		/* 8226B188h case   16:*/		return 0x8226B18C;
		  /* 8226B18Ch */ case   17:  		/* cmplwi CR6, R10, 1 */
		/* 8226B18Ch case   17:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 8226B18Ch case   17:*/		return 0x8226B190;
		  /* 8226B190h */ case   18:  		/* bc 12, CR6_EQ, 84 */
		/* 8226B190h case   18:*/		if ( regs.CR[6].eq ) { return 0x8226B1E4;  }
		/* 8226B190h case   18:*/		return 0x8226B194;
		  /* 8226B194h */ case   19:  		/* rlwinm R11, R11, 6, 30, 31 */
		/* 8226B194h case   19:*/		cpu::op::rlwinm<0,6,30,31>(regs,&regs.R11,regs.R11);
		/* 8226B194h case   19:*/		return 0x8226B198;
		  /* 8226B198h */ case   20:  		/* cmplwi CR6, R10, 18 */
		/* 8226B198h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000012);
		/* 8226B198h case   20:*/		return 0x8226B19C;
		  /* 8226B19Ch */ case   21:  		/* mr R4, R30 */
		/* 8226B19Ch case   21:*/		regs.R4 = regs.R30;
		/* 8226B19Ch case   21:*/		return 0x8226B1A0;
		  /* 8226B1A0h */ case   22:  		/* mr R3, R31 */
		/* 8226B1A0h case   22:*/		regs.R3 = regs.R31;
		/* 8226B1A0h case   22:*/		return 0x8226B1A4;
		  /* 8226B1A4h */ case   23:  		/* lbzx R11, <#[R11 + R28]> */
		/* 8226B1A4h case   23:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 8226B1A4h case   23:*/		return 0x8226B1A8;
		  /* 8226B1A8h */ case   24:  		/* extsb R5, R11 */
		/* 8226B1A8h case   24:*/		cpu::op::extsb<0>(regs,&regs.R5,regs.R11);
		/* 8226B1A8h case   24:*/		return 0x8226B1AC;
		  /* 8226B1ACh */ case   25:  		/* bc 12, CR6_EQ, 128 */
		/* 8226B1ACh case   25:*/		if ( regs.CR[6].eq ) { return 0x8226B22C;  }
		/* 8226B1ACh case   25:*/		return 0x8226B1B0;
		  /* 8226B1B0h */ case   26:  		/* cmplwi CR6, R10, 24 */
		/* 8226B1B0h case   26:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000018);
		/* 8226B1B0h case   26:*/		return 0x8226B1B4;
		  /* 8226B1B4h */ case   27:  		/* bc 12, CR6_EQ, 156 */
		/* 8226B1B4h case   27:*/		if ( regs.CR[6].eq ) { return 0x8226B250;  }
		/* 8226B1B4h case   27:*/		return 0x8226B1B8;
		  /* 8226B1B8h */ case   28:  		/* bl -6104 */
		/* 8226B1B8h case   28:*/		regs.LR = 0x8226B1BC; return 0x822699E0;
		/* 8226B1B8h case   28:*/		return 0x8226B1BC;
		  /* 8226B1BCh */ case   29:  		/* lwz R11, <#[R29]> */
		/* 8226B1BCh case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8226B1BCh case   29:*/		return 0x8226B1C0;
		  /* 8226B1C0h */ case   30:  		/* mr R4, R30 */
		/* 8226B1C0h case   30:*/		regs.R4 = regs.R30;
		/* 8226B1C0h case   30:*/		return 0x8226B1C4;
		  /* 8226B1C4h */ case   31:  		/* rlwinm R11, R11, 4, 30, 31 */
		/* 8226B1C4h case   31:*/		cpu::op::rlwinm<0,4,30,31>(regs,&regs.R11,regs.R11);
		/* 8226B1C4h case   31:*/		return 0x8226B1C8;
		  /* 8226B1C8h */ case   32:  		/* mr R3, R31 */
		/* 8226B1C8h case   32:*/		regs.R3 = regs.R31;
		/* 8226B1C8h case   32:*/		return 0x8226B1CC;
		  /* 8226B1CCh */ case   33:  		/* lbzx R11, <#[R11 + R28]> */
		/* 8226B1CCh case   33:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 8226B1CCh case   33:*/		return 0x8226B1D0;
		  /* 8226B1D0h */ case   34:  		/* extsb R5, R11 */
		/* 8226B1D0h case   34:*/		cpu::op::extsb<0>(regs,&regs.R5,regs.R11);
		/* 8226B1D0h case   34:*/		return 0x8226B1D4;
		  /* 8226B1D4h */ case   35:  		/* bl -6132 */
		/* 8226B1D4h case   35:*/		regs.LR = 0x8226B1D8; return 0x822699E0;
		/* 8226B1D4h case   35:*/		return 0x8226B1D8;
		  /* 8226B1D8h */ case   36:  		/* lwz R11, <#[R29]> */
		/* 8226B1D8h case   36:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8226B1D8h case   36:*/		return 0x8226B1DC;
		  /* 8226B1DCh */ case   37:  		/* rlwinm R11, R11, 2, 30, 31 */
		/* 8226B1DCh case   37:*/		cpu::op::rlwinm<0,2,30,31>(regs,&regs.R11,regs.R11);
		/* 8226B1DCh case   37:*/		return 0x8226B1E0;
		  /* 8226B1E0h */ case   38:  		/* b 96 */
		/* 8226B1E0h case   38:*/		return 0x8226B240;
		/* 8226B1E0h case   38:*/		return 0x8226B1E4;
	}
	return 0x8226B1E4;
} // Block from 8226B148h-8226B1E4h (39 instructions)

//////////////////////////////////////////////////////
// Block at 8226B1E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B1E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B1E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B1E4);
		  /* 8226B1E4h */ case    0:  		/* lwz R10, <#[R29 + 8]> */
		/* 8226B1E4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000008) );
		/* 8226B1E4h case    0:*/		return 0x8226B1E8;
		  /* 8226B1E8h */ case    1:  		/* rlwinm R10, R10, 18, 30, 31 */
		/* 8226B1E8h case    1:*/		cpu::op::rlwinm<0,18,30,31>(regs,&regs.R10,regs.R10);
		/* 8226B1E8h case    1:*/		return 0x8226B1EC;
		  /* 8226B1ECh */ case    2:  		/* cmplwi CR6, R10, 1 */
		/* 8226B1ECh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 8226B1ECh case    2:*/		return 0x8226B1F0;
		  /* 8226B1F0h */ case    3:  		/* bc 12, CR6_LT, 76 */
		/* 8226B1F0h case    3:*/		if ( regs.CR[6].lt ) { return 0x8226B23C;  }
		/* 8226B1F0h case    3:*/		return 0x8226B1F4;
		  /* 8226B1F4h */ case    4:  		/* bc 12, CR6_EQ, 36 */
		/* 8226B1F4h case    4:*/		if ( regs.CR[6].eq ) { return 0x8226B218;  }
		/* 8226B1F4h case    4:*/		return 0x8226B1F8;
		  /* 8226B1F8h */ case    5:  		/* cmplwi CR6, R10, 4 */
		/* 8226B1F8h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000004);
		/* 8226B1F8h case    5:*/		return 0x8226B1FC;
		  /* 8226B1FCh */ case    6:  		/* bc 4, CR6_LT, 88 */
		/* 8226B1FCh case    6:*/		if ( !regs.CR[6].lt ) { return 0x8226B254;  }
		/* 8226B1FCh case    6:*/		return 0x8226B200;
		  /* 8226B200h */ case    7:  		/* rlwinm R11, R11, 6, 30, 31 */
		/* 8226B200h case    7:*/		cpu::op::rlwinm<0,6,30,31>(regs,&regs.R11,regs.R11);
		/* 8226B200h case    7:*/		return 0x8226B204;
		  /* 8226B204h */ case    8:  		/* mr R4, R30 */
		/* 8226B204h case    8:*/		regs.R4 = regs.R30;
		/* 8226B204h case    8:*/		return 0x8226B208;
		  /* 8226B208h */ case    9:  		/* mr R3, R31 */
		/* 8226B208h case    9:*/		regs.R3 = regs.R31;
		/* 8226B208h case    9:*/		return 0x8226B20C;
		  /* 8226B20Ch */ case   10:  		/* lbzx R11, <#[R11 + R28]> */
		/* 8226B20Ch case   10:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 8226B20Ch case   10:*/		return 0x8226B210;
		  /* 8226B210h */ case   11:  		/* extsb R5, R11 */
		/* 8226B210h case   11:*/		cpu::op::extsb<0>(regs,&regs.R5,regs.R11);
		/* 8226B210h case   11:*/		return 0x8226B214;
		  /* 8226B214h */ case   12:  		/* b -92 */
		/* 8226B214h case   12:*/		return 0x8226B1B8;
		/* 8226B214h case   12:*/		return 0x8226B218;
	}
	return 0x8226B218;
} // Block from 8226B1E4h-8226B218h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8226B218h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B218( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B218) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B218);
		  /* 8226B218h */ case    0:  		/* rlwinm R11, R11, 6, 30, 31 */
		/* 8226B218h case    0:*/		cpu::op::rlwinm<0,6,30,31>(regs,&regs.R11,regs.R11);
		/* 8226B218h case    0:*/		return 0x8226B21C;
		  /* 8226B21Ch */ case    1:  		/* mr R4, R30 */
		/* 8226B21Ch case    1:*/		regs.R4 = regs.R30;
		/* 8226B21Ch case    1:*/		return 0x8226B220;
		  /* 8226B220h */ case    2:  		/* mr R3, R31 */
		/* 8226B220h case    2:*/		regs.R3 = regs.R31;
		/* 8226B220h case    2:*/		return 0x8226B224;
		  /* 8226B224h */ case    3:  		/* lbzx R11, <#[R11 + R28]> */
		/* 8226B224h case    3:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 8226B224h case    3:*/		return 0x8226B228;
		  /* 8226B228h */ case    4:  		/* extsb R5, R11 */
		/* 8226B228h case    4:*/		cpu::op::extsb<0>(regs,&regs.R5,regs.R11);
		/* 8226B228h case    4:*/		return 0x8226B22C;
	}
	return 0x8226B22C;
} // Block from 8226B218h-8226B22Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 8226B22Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B22C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B22C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B22C);
		  /* 8226B22Ch */ case    0:  		/* bl -6220 */
		/* 8226B22Ch case    0:*/		regs.LR = 0x8226B230; return 0x822699E0;
		/* 8226B22Ch case    0:*/		return 0x8226B230;
		  /* 8226B230h */ case    1:  		/* lwz R11, <#[R29]> */
		/* 8226B230h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8226B230h case    1:*/		return 0x8226B234;
		  /* 8226B234h */ case    2:  		/* rlwinm R11, R11, 4, 30, 31 */
		/* 8226B234h case    2:*/		cpu::op::rlwinm<0,4,30,31>(regs,&regs.R11,regs.R11);
		/* 8226B234h case    2:*/		return 0x8226B238;
		  /* 8226B238h */ case    3:  		/* b 8 */
		/* 8226B238h case    3:*/		return 0x8226B240;
		/* 8226B238h case    3:*/		return 0x8226B23C;
	}
	return 0x8226B23C;
} // Block from 8226B22Ch-8226B23Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226B23Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B23C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B23C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B23C);
		  /* 8226B23Ch */ case    0:  		/* rlwinm R11, R11, 6, 30, 31 */
		/* 8226B23Ch case    0:*/		cpu::op::rlwinm<0,6,30,31>(regs,&regs.R11,regs.R11);
		/* 8226B23Ch case    0:*/		return 0x8226B240;
	}
	return 0x8226B240;
} // Block from 8226B23Ch-8226B240h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226B240h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B240( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B240) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B240);
		  /* 8226B240h */ case    0:  		/* lbzx R11, <#[R11 + R28]> */
		/* 8226B240h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 8226B240h case    0:*/		return 0x8226B244;
		  /* 8226B244h */ case    1:  		/* mr R3, R31 */
		/* 8226B244h case    1:*/		regs.R3 = regs.R31;
		/* 8226B244h case    1:*/		return 0x8226B248;
		  /* 8226B248h */ case    2:  		/* mr R4, R30 */
		/* 8226B248h case    2:*/		regs.R4 = regs.R30;
		/* 8226B248h case    2:*/		return 0x8226B24C;
		  /* 8226B24Ch */ case    3:  		/* extsb R5, R11 */
		/* 8226B24Ch case    3:*/		cpu::op::extsb<0>(regs,&regs.R5,regs.R11);
		/* 8226B24Ch case    3:*/		return 0x8226B250;
	}
	return 0x8226B250;
} // Block from 8226B240h-8226B250h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226B250h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B250( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B250) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B250);
		  /* 8226B250h */ case    0:  		/* bl -6256 */
		/* 8226B250h case    0:*/		regs.LR = 0x8226B254; return 0x822699E0;
		/* 8226B250h case    0:*/		return 0x8226B254;
	}
	return 0x8226B254;
} // Block from 8226B250h-8226B254h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226B254h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B254( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B254) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B254);
		  /* 8226B254h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 8226B254h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8226B254h case    0:*/		return 0x8226B258;
		  /* 8226B258h */ case    1:  		/* rlwinm R10, R11, 0, 27, 31 */
		/* 8226B258h case    1:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R11);
		/* 8226B258h case    1:*/		return 0x8226B25C;
		  /* 8226B25Ch */ case    2:  		/* cmplwi CR6, R10, 19 */
		/* 8226B25Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000013);
		/* 8226B25Ch case    2:*/		return 0x8226B260;
		  /* 8226B260h */ case    3:  		/* bc 12, CR6_GT, 24 */
		/* 8226B260h case    3:*/		if ( regs.CR[6].gt ) { return 0x8226B278;  }
		/* 8226B260h case    3:*/		return 0x8226B264;
		  /* 8226B264h */ case    4:  		/* lis R10, -32251 */
		/* 8226B264h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 8226B264h case    4:*/		return 0x8226B268;
		  /* 8226B268h */ case    5:  		/* rlwinm R5, R11, 12, 27, 31 */
		/* 8226B268h case    5:*/		cpu::op::rlwinm<0,12,27,31>(regs,&regs.R5,regs.R11);
		/* 8226B268h case    5:*/		return 0x8226B26C;
		  /* 8226B26Ch */ case    6:  		/* addi R4, R10, -15960 */
		/* 8226B26Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0xFFFFC1A8);
		/* 8226B26Ch case    6:*/		return 0x8226B270;
		  /* 8226B270h */ case    7:  		/* mr R3, R31 */
		/* 8226B270h case    7:*/		regs.R3 = regs.R31;
		/* 8226B270h case    7:*/		return 0x8226B274;
		  /* 8226B274h */ case    8:  		/* bl -6292 */
		/* 8226B274h case    8:*/		regs.LR = 0x8226B278; return 0x822699E0;
		/* 8226B274h case    8:*/		return 0x8226B278;
	}
	return 0x8226B278;
} // Block from 8226B254h-8226B278h (9 instructions)

//////////////////////////////////////////////////////
// Block at 8226B278h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B278( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B278) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B278);
		  /* 8226B278h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 8226B278h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8226B278h case    0:*/		return 0x8226B27C;
		  /* 8226B27Ch */ case    1:  		/* lis R10, -32255 */
		/* 8226B27Ch case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 8226B27Ch case    1:*/		return 0x8226B280;
		  /* 8226B280h */ case    2:  		/* li R6, 1 */
		/* 8226B280h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8226B280h case    2:*/		return 0x8226B284;
		  /* 8226B284h */ case    3:  		/* addi R4, R10, 11748 */
		/* 8226B284h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0x2DE4);
		/* 8226B284h case    3:*/		return 0x8226B288;
		  /* 8226B288h */ case    4:  		/* rlwinm R5, R11, 13, 31, 31 */
		/* 8226B288h case    4:*/		cpu::op::rlwinm<0,13,31,31>(regs,&regs.R5,regs.R11);
		/* 8226B288h case    4:*/		return 0x8226B28C;
		  /* 8226B28Ch */ case    5:  		/* mr R3, R31 */
		/* 8226B28Ch case    5:*/		regs.R3 = regs.R31;
		/* 8226B28Ch case    5:*/		return 0x8226B290;
		  /* 8226B290h */ case    6:  		/* bl -1760 */
		/* 8226B290h case    6:*/		regs.LR = 0x8226B294; return 0x8226ABB0;
		/* 8226B290h case    6:*/		return 0x8226B294;
		  /* 8226B294h */ case    7:  		/* lis R11, -32255 */
		/* 8226B294h case    7:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8226B294h case    7:*/		return 0x8226B298;
		  /* 8226B298h */ case    8:  		/* addi R27, R11, 22352 */
		/* 8226B298h case    8:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R11,0x5750);
		/* 8226B298h case    8:*/		return 0x8226B29C;
		  /* 8226B29Ch */ case    9:  		/* lwz R11, <#[R29]> */
		/* 8226B29Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8226B29Ch case    9:*/		return 0x8226B2A0;
		  /* 8226B2A0h */ case   10:  		/* rlwinm R10, R11, 0, 27, 31 */
		/* 8226B2A0h case   10:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R11);
		/* 8226B2A0h case   10:*/		return 0x8226B2A4;
		  /* 8226B2A4h */ case   11:  		/* lbzx R10, <#[R10 + R27]> */
		/* 8226B2A4h case   11:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R10 + regs.R27 + 0x00000000) );
		/* 8226B2A4h case   11:*/		return 0x8226B2A8;
		  /* 8226B2A8h */ case   12:  		/* andi. R10, R10, 23 */
		/* 8226B2A8h case   12:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R10,0x17);
		/* 8226B2A8h case   12:*/		return 0x8226B2AC;
		  /* 8226B2ACh */ case   13:  		/* cmpwi CR0, R10, 0 */
		/* 8226B2ACh case   13:*/		cpu::op::cmpwi<0>(regs,regs.R10,0x00000000);
		/* 8226B2ACh case   13:*/		return 0x8226B2B0;
		  /* 8226B2B0h */ case   14:  		/* bc 12, CR0_EQ, 28 */
		/* 8226B2B0h case   14:*/		if ( regs.CR[0].eq ) { return 0x8226B2CC;  }
		/* 8226B2B0h case   14:*/		return 0x8226B2B4;
		  /* 8226B2B4h */ case   15:  		/* lis R10, -32255 */
		/* 8226B2B4h case   15:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 8226B2B4h case   15:*/		return 0x8226B2B8;
		  /* 8226B2B8h */ case   16:  		/* li R6, 0 */
		/* 8226B2B8h case   16:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8226B2B8h case   16:*/		return 0x8226B2BC;
		  /* 8226B2BCh */ case   17:  		/* addi R4, R10, 11764 */
		/* 8226B2BCh case   17:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0x2DF4);
		/* 8226B2BCh case   17:*/		return 0x8226B2C0;
		  /* 8226B2C0h */ case   18:  		/* rlwinm R5, R11, 7, 31, 31 */
		/* 8226B2C0h case   18:*/		cpu::op::rlwinm<0,7,31,31>(regs,&regs.R5,regs.R11);
		/* 8226B2C0h case   18:*/		return 0x8226B2C4;
		  /* 8226B2C4h */ case   19:  		/* mr R3, R31 */
		/* 8226B2C4h case   19:*/		regs.R3 = regs.R31;
		/* 8226B2C4h case   19:*/		return 0x8226B2C8;
		  /* 8226B2C8h */ case   20:  		/* bl -1816 */
		/* 8226B2C8h case   20:*/		regs.LR = 0x8226B2CC; return 0x8226ABB0;
		/* 8226B2C8h case   20:*/		return 0x8226B2CC;
	}
	return 0x8226B2CC;
} // Block from 8226B278h-8226B2CCh (21 instructions)

//////////////////////////////////////////////////////
// Block at 8226B2CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B2CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B2CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B2CC);
		  /* 8226B2CCh */ case    0:  		/* lwz R10, <#[R29]> */
		/* 8226B2CCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 8226B2CCh case    0:*/		return 0x8226B2D0;
		  /* 8226B2D0h */ case    1:  		/* lis R11, -32251 */
		/* 8226B2D0h case    1:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8226B2D0h case    1:*/		return 0x8226B2D4;
		  /* 8226B2D4h */ case    2:  		/* rlwinm R10, R10, 0, 27, 31 */
		/* 8226B2D4h case    2:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R10);
		/* 8226B2D4h case    2:*/		return 0x8226B2D8;
		  /* 8226B2D8h */ case    3:  		/* addi R30, R11, -16244 */
		/* 8226B2D8h case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R11,0xFFFFC08C);
		/* 8226B2D8h case    3:*/		return 0x8226B2DC;
		  /* 8226B2DCh */ case    4:  		/* lbzx R11, <#[R10 + R27]> */
		/* 8226B2DCh case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R10 + regs.R27 + 0x00000000) );
		/* 8226B2DCh case    4:*/		return 0x8226B2E0;
		  /* 8226B2E0h */ case    5:  		/* andi. R11, R11, 19 */
		/* 8226B2E0h case    5:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x13);
		/* 8226B2E0h case    5:*/		return 0x8226B2E4;
		  /* 8226B2E4h */ case    6:  		/* cmpwi CR0, R11, 0 */
		/* 8226B2E4h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 8226B2E4h case    6:*/		return 0x8226B2E8;
		  /* 8226B2E8h */ case    7:  		/* bc 12, CR0_EQ, 64 */
		/* 8226B2E8h case    7:*/		if ( regs.CR[0].eq ) { return 0x8226B328;  }
		/* 8226B2E8h case    7:*/		return 0x8226B2EC;
		  /* 8226B2ECh */ case    8:  		/* lwz R11, <#[R31 + 8]> */
		/* 8226B2ECh case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8226B2ECh case    8:*/		return 0x8226B2F0;
		  /* 8226B2F0h */ case    9:  		/* lwz R10, <#[R29 + 4]> */
		/* 8226B2F0h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000004) );
		/* 8226B2F0h case    9:*/		return 0x8226B2F4;
		  /* 8226B2F4h */ case   10:  		/* rlwinm. R9, R11, 26, 31, 31 */
		/* 8226B2F4h case   10:*/		cpu::op::rlwinm<1,26,31,31>(regs,&regs.R9,regs.R11);
		/* 8226B2F4h case   10:*/		return 0x8226B2F8;
		  /* 8226B2F8h */ case   11:  		/* rlwinm R11, R10, 20, 30, 31 */
		/* 8226B2F8h case   11:*/		cpu::op::rlwinm<0,20,30,31>(regs,&regs.R11,regs.R10);
		/* 8226B2F8h case   11:*/		return 0x8226B2FC;
		  /* 8226B2FCh */ case   12:  		/* bc 4, CR0_EQ, 12 */
		/* 8226B2FCh case   12:*/		if ( !regs.CR[0].eq ) { return 0x8226B308;  }
		/* 8226B2FCh case   12:*/		return 0x8226B300;
		  /* 8226B300h */ case   13:  		/* cmplwi CR6, R11, 3 */
		/* 8226B300h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 8226B300h case   13:*/		return 0x8226B304;
		  /* 8226B304h */ case   14:  		/* bc 12, CR6_EQ, 36 */
		/* 8226B304h case   14:*/		if ( regs.CR[6].eq ) { return 0x8226B328;  }
		/* 8226B304h case   14:*/		return 0x8226B308;
	}
	return 0x8226B308;
} // Block from 8226B2CCh-8226B308h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8226B308h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B308( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B308) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B308);
		  /* 8226B308h */ case    0:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8226B308h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8226B308h case    0:*/		return 0x8226B30C;
		  /* 8226B30Ch */ case    1:  		/* addi R10, R28, 400 */
		/* 8226B30Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R28,0x190);
		/* 8226B30Ch case    1:*/		return 0x8226B310;
		  /* 8226B310h */ case    2:  		/* lis R9, -32255 */
		/* 8226B310h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 8226B310h case    2:*/		return 0x8226B314;
		  /* 8226B314h */ case    3:  		/* mr R4, R30 */
		/* 8226B314h case    3:*/		regs.R4 = regs.R30;
		/* 8226B314h case    3:*/		return 0x8226B318;
		  /* 8226B318h */ case    4:  		/* addi R5, R9, 11736 */
		/* 8226B318h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R9,0x2DD8);
		/* 8226B318h case    4:*/		return 0x8226B31C;
		  /* 8226B31Ch */ case    5:  		/* mr R3, R31 */
		/* 8226B31Ch case    5:*/		regs.R3 = regs.R31;
		/* 8226B31Ch case    5:*/		return 0x8226B320;
		  /* 8226B320h */ case    6:  		/* lwzx R6, <#[R11 + R10]> */
		/* 8226B320h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8226B320h case    6:*/		return 0x8226B324;
		  /* 8226B324h */ case    7:  		/* bl -6468 */
		/* 8226B324h case    7:*/		regs.LR = 0x8226B328; return 0x822699E0;
		/* 8226B324h case    7:*/		return 0x8226B328;
	}
	return 0x8226B328;
} // Block from 8226B308h-8226B328h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8226B328h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B328( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B328) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B328);
		  /* 8226B328h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 8226B328h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8226B328h case    0:*/		return 0x8226B32C;
		  /* 8226B32Ch */ case    1:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 8226B32Ch case    1:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8226B32Ch case    1:*/		return 0x8226B330;
		  /* 8226B330h */ case    2:  		/* lbzx R11, <#[R11 + R27]> */
		/* 8226B330h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 8226B330h case    2:*/		return 0x8226B334;
		  /* 8226B334h */ case    3:  		/* andi. R11, R11, 19 */
		/* 8226B334h case    3:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x13);
		/* 8226B334h case    3:*/		return 0x8226B338;
		  /* 8226B338h */ case    4:  		/* cmpwi CR0, R11, 0 */
		/* 8226B338h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 8226B338h case    4:*/		return 0x8226B33C;
		  /* 8226B33Ch */ case    5:  		/* bc 12, CR0_EQ, 64 */
		/* 8226B33Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x8226B37C;  }
		/* 8226B33Ch case    5:*/		return 0x8226B340;
		  /* 8226B340h */ case    6:  		/* lwz R11, <#[R31 + 8]> */
		/* 8226B340h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8226B340h case    6:*/		return 0x8226B344;
		  /* 8226B344h */ case    7:  		/* lwz R10, <#[R29 + 4]> */
		/* 8226B344h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000004) );
		/* 8226B344h case    7:*/		return 0x8226B348;
		  /* 8226B348h */ case    8:  		/* rlwinm. R9, R11, 26, 31, 31 */
		/* 8226B348h case    8:*/		cpu::op::rlwinm<1,26,31,31>(regs,&regs.R9,regs.R11);
		/* 8226B348h case    8:*/		return 0x8226B34C;
		  /* 8226B34Ch */ case    9:  		/* rlwinm R11, R10, 18, 30, 31 */
		/* 8226B34Ch case    9:*/		cpu::op::rlwinm<0,18,30,31>(regs,&regs.R11,regs.R10);
		/* 8226B34Ch case    9:*/		return 0x8226B350;
		  /* 8226B350h */ case   10:  		/* bc 4, CR0_EQ, 12 */
		/* 8226B350h case   10:*/		if ( !regs.CR[0].eq ) { return 0x8226B35C;  }
		/* 8226B350h case   10:*/		return 0x8226B354;
		  /* 8226B354h */ case   11:  		/* cmplwi CR6, R11, 3 */
		/* 8226B354h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 8226B354h case   11:*/		return 0x8226B358;
		  /* 8226B358h */ case   12:  		/* bc 12, CR6_EQ, 36 */
		/* 8226B358h case   12:*/		if ( regs.CR[6].eq ) { return 0x8226B37C;  }
		/* 8226B358h case   12:*/		return 0x8226B35C;
	}
	return 0x8226B35C;
} // Block from 8226B328h-8226B35Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 8226B35Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B35C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B35C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B35C);
		  /* 8226B35Ch */ case    0:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8226B35Ch case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8226B35Ch case    0:*/		return 0x8226B360;
		  /* 8226B360h */ case    1:  		/* addi R10, R28, 416 */
		/* 8226B360h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R28,0x1A0);
		/* 8226B360h case    1:*/		return 0x8226B364;
		  /* 8226B364h */ case    2:  		/* lis R9, -32255 */
		/* 8226B364h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 8226B364h case    2:*/		return 0x8226B368;
		  /* 8226B368h */ case    3:  		/* mr R4, R30 */
		/* 8226B368h case    3:*/		regs.R4 = regs.R30;
		/* 8226B368h case    3:*/		return 0x8226B36C;
		  /* 8226B36Ch */ case    4:  		/* addi R5, R9, 11724 */
		/* 8226B36Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R9,0x2DCC);
		/* 8226B36Ch case    4:*/		return 0x8226B370;
		  /* 8226B370h */ case    5:  		/* mr R3, R31 */
		/* 8226B370h case    5:*/		regs.R3 = regs.R31;
		/* 8226B370h case    5:*/		return 0x8226B374;
		  /* 8226B374h */ case    6:  		/* lwzx R6, <#[R11 + R10]> */
		/* 8226B374h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8226B374h case    6:*/		return 0x8226B378;
		  /* 8226B378h */ case    7:  		/* bl -6552 */
		/* 8226B378h case    7:*/		regs.LR = 0x8226B37C; return 0x822699E0;
		/* 8226B378h case    7:*/		return 0x8226B37C;
	}
	return 0x8226B37C;
} // Block from 8226B35Ch-8226B37Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 8226B37Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B37C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B37C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B37C);
		  /* 8226B37Ch */ case    0:  		/* lwz R11, <#[R29]> */
		/* 8226B37Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8226B37Ch case    0:*/		return 0x8226B380;
		  /* 8226B380h */ case    1:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 8226B380h case    1:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8226B380h case    1:*/		return 0x8226B384;
		  /* 8226B384h */ case    2:  		/* lbzx R11, <#[R11 + R27]> */
		/* 8226B384h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 8226B384h case    2:*/		return 0x8226B388;
		  /* 8226B388h */ case    3:  		/* andi. R11, R11, 19 */
		/* 8226B388h case    3:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x13);
		/* 8226B388h case    3:*/		return 0x8226B38C;
		  /* 8226B38Ch */ case    4:  		/* cmpwi CR0, R11, 0 */
		/* 8226B38Ch case    4:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 8226B38Ch case    4:*/		return 0x8226B390;
		  /* 8226B390h */ case    5:  		/* bc 12, CR0_EQ, 64 */
		/* 8226B390h case    5:*/		if ( regs.CR[0].eq ) { return 0x8226B3D0;  }
		/* 8226B390h case    5:*/		return 0x8226B394;
		  /* 8226B394h */ case    6:  		/* lwz R11, <#[R31 + 8]> */
		/* 8226B394h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8226B394h case    6:*/		return 0x8226B398;
		  /* 8226B398h */ case    7:  		/* lhz R10, <#[R29 + 4]> */
		/* 8226B398h case    7:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000004) );
		/* 8226B398h case    7:*/		return 0x8226B39C;
		  /* 8226B39Ch */ case    8:  		/* rlwinm. R9, R11, 26, 31, 31 */
		/* 8226B39Ch case    8:*/		cpu::op::rlwinm<1,26,31,31>(regs,&regs.R9,regs.R11);
		/* 8226B39Ch case    8:*/		return 0x8226B3A0;
		  /* 8226B3A0h */ case    9:  		/* rlwinm R11, R10, 0, 30, 31 */
		/* 8226B3A0h case    9:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R10);
		/* 8226B3A0h case    9:*/		return 0x8226B3A4;
		  /* 8226B3A4h */ case   10:  		/* bc 4, CR0_EQ, 12 */
		/* 8226B3A4h case   10:*/		if ( !regs.CR[0].eq ) { return 0x8226B3B0;  }
		/* 8226B3A4h case   10:*/		return 0x8226B3A8;
		  /* 8226B3A8h */ case   11:  		/* cmplwi CR6, R11, 3 */
		/* 8226B3A8h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 8226B3A8h case   11:*/		return 0x8226B3AC;
		  /* 8226B3ACh */ case   12:  		/* bc 12, CR6_EQ, 36 */
		/* 8226B3ACh case   12:*/		if ( regs.CR[6].eq ) { return 0x8226B3D0;  }
		/* 8226B3ACh case   12:*/		return 0x8226B3B0;
	}
	return 0x8226B3B0;
} // Block from 8226B37Ch-8226B3B0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8226B3B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B3B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B3B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B3B0);
		  /* 8226B3B0h */ case    0:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8226B3B0h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8226B3B0h case    0:*/		return 0x8226B3B4;
		  /* 8226B3B4h */ case    1:  		/* addi R10, R28, 432 */
		/* 8226B3B4h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R28,0x1B0);
		/* 8226B3B4h case    1:*/		return 0x8226B3B8;
		  /* 8226B3B8h */ case    2:  		/* lis R9, -32255 */
		/* 8226B3B8h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 8226B3B8h case    2:*/		return 0x8226B3BC;
		  /* 8226B3BCh */ case    3:  		/* mr R4, R30 */
		/* 8226B3BCh case    3:*/		regs.R4 = regs.R30;
		/* 8226B3BCh case    3:*/		return 0x8226B3C0;
		  /* 8226B3C0h */ case    4:  		/* addi R5, R9, 11712 */
		/* 8226B3C0h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R9,0x2DC0);
		/* 8226B3C0h case    4:*/		return 0x8226B3C4;
		  /* 8226B3C4h */ case    5:  		/* mr R3, R31 */
		/* 8226B3C4h case    5:*/		regs.R3 = regs.R31;
		/* 8226B3C4h case    5:*/		return 0x8226B3C8;
		  /* 8226B3C8h */ case    6:  		/* lwzx R6, <#[R11 + R10]> */
		/* 8226B3C8h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8226B3C8h case    6:*/		return 0x8226B3CC;
		  /* 8226B3CCh */ case    7:  		/* bl -6636 */
		/* 8226B3CCh case    7:*/		regs.LR = 0x8226B3D0; return 0x822699E0;
		/* 8226B3CCh case    7:*/		return 0x8226B3D0;
	}
	return 0x8226B3D0;
} // Block from 8226B3B0h-8226B3D0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8226B3D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B3D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B3D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B3D0);
		  /* 8226B3D0h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 8226B3D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8226B3D0h case    0:*/		return 0x8226B3D4;
		  /* 8226B3D4h */ case    1:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 8226B3D4h case    1:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8226B3D4h case    1:*/		return 0x8226B3D8;
		  /* 8226B3D8h */ case    2:  		/* lbzx R11, <#[R11 + R27]> */
		/* 8226B3D8h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 8226B3D8h case    2:*/		return 0x8226B3DC;
		  /* 8226B3DCh */ case    3:  		/* andi. R11, R11, 23 */
		/* 8226B3DCh case    3:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x17);
		/* 8226B3DCh case    3:*/		return 0x8226B3E0;
		  /* 8226B3E0h */ case    4:  		/* cmpwi CR0, R11, 0 */
		/* 8226B3E0h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 8226B3E0h case    4:*/		return 0x8226B3E4;
		  /* 8226B3E4h */ case    5:  		/* bc 12, CR0_EQ, 64 */
		/* 8226B3E4h case    5:*/		if ( regs.CR[0].eq ) { return 0x8226B424;  }
		/* 8226B3E4h case    5:*/		return 0x8226B3E8;
		  /* 8226B3E8h */ case    6:  		/* lwz R11, <#[R31 + 8]> */
		/* 8226B3E8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8226B3E8h case    6:*/		return 0x8226B3EC;
		  /* 8226B3ECh */ case    7:  		/* lwz R10, <#[R29 + 4]> */
		/* 8226B3ECh case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000004) );
		/* 8226B3ECh case    7:*/		return 0x8226B3F0;
		  /* 8226B3F0h */ case    8:  		/* rlwinm. R9, R11, 26, 31, 31 */
		/* 8226B3F0h case    8:*/		cpu::op::rlwinm<1,26,31,31>(regs,&regs.R9,regs.R11);
		/* 8226B3F0h case    8:*/		return 0x8226B3F4;
		  /* 8226B3F4h */ case    9:  		/* rlwinm R11, R10, 14, 29, 31 */
		/* 8226B3F4h case    9:*/		cpu::op::rlwinm<0,14,29,31>(regs,&regs.R11,regs.R10);
		/* 8226B3F4h case    9:*/		return 0x8226B3F8;
		  /* 8226B3F8h */ case   10:  		/* bc 4, CR0_EQ, 12 */
		/* 8226B3F8h case   10:*/		if ( !regs.CR[0].eq ) { return 0x8226B404;  }
		/* 8226B3F8h case   10:*/		return 0x8226B3FC;
		  /* 8226B3FCh */ case   11:  		/* cmplwi CR6, R11, 7 */
		/* 8226B3FCh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000007);
		/* 8226B3FCh case   11:*/		return 0x8226B400;
		  /* 8226B400h */ case   12:  		/* bc 12, CR6_EQ, 36 */
		/* 8226B400h case   12:*/		if ( regs.CR[6].eq ) { return 0x8226B424;  }
		/* 8226B400h case   12:*/		return 0x8226B404;
	}
	return 0x8226B404;
} // Block from 8226B3D0h-8226B404h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8226B404h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B404( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B404) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B404);
		  /* 8226B404h */ case    0:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8226B404h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8226B404h case    0:*/		return 0x8226B408;
		  /* 8226B408h */ case    1:  		/* addi R10, R28, 448 */
		/* 8226B408h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R28,0x1C0);
		/* 8226B408h case    1:*/		return 0x8226B40C;
		  /* 8226B40Ch */ case    2:  		/* lis R9, -32255 */
		/* 8226B40Ch case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 8226B40Ch case    2:*/		return 0x8226B410;
		  /* 8226B410h */ case    3:  		/* mr R4, R30 */
		/* 8226B410h case    3:*/		regs.R4 = regs.R30;
		/* 8226B410h case    3:*/		return 0x8226B414;
		  /* 8226B414h */ case    4:  		/* addi R5, R9, 11700 */
		/* 8226B414h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R9,0x2DB4);
		/* 8226B414h case    4:*/		return 0x8226B418;
		  /* 8226B418h */ case    5:  		/* mr R3, R31 */
		/* 8226B418h case    5:*/		regs.R3 = regs.R31;
		/* 8226B418h case    5:*/		return 0x8226B41C;
		  /* 8226B41Ch */ case    6:  		/* lwzx R6, <#[R11 + R10]> */
		/* 8226B41Ch case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8226B41Ch case    6:*/		return 0x8226B420;
		  /* 8226B420h */ case    7:  		/* bl -6720 */
		/* 8226B420h case    7:*/		regs.LR = 0x8226B424; return 0x822699E0;
		/* 8226B420h case    7:*/		return 0x8226B424;
	}
	return 0x8226B424;
} // Block from 8226B404h-8226B424h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8226B424h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B424( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B424) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B424);
		  /* 8226B424h */ case    0:  		/* lwz R11, <#[R29 + 8]> */
		/* 8226B424h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8226B424h case    0:*/		return 0x8226B428;
		  /* 8226B428h */ case    1:  		/* rlwinm R11, R11, 0, 16, 17 */
		/* 8226B428h case    1:*/		cpu::op::rlwinm<0,0,16,17>(regs,&regs.R11,regs.R11);
		/* 8226B428h case    1:*/		return 0x8226B42C;
		  /* 8226B42Ch */ case    2:  		/* cmplwi CR6, R11, 32768 */
		/* 8226B42Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00008000);
		/* 8226B42Ch case    2:*/		return 0x8226B430;
		  /* 8226B430h */ case    3:  		/* bc 12, CR6_LT, 88 */
		/* 8226B430h case    3:*/		if ( regs.CR[6].lt ) { return 0x8226B488;  }
		/* 8226B430h case    3:*/		return 0x8226B434;
		  /* 8226B434h */ case    4:  		/* lwz R11, <#[R29]> */
		/* 8226B434h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8226B434h case    4:*/		return 0x8226B438;
		  /* 8226B438h */ case    5:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 8226B438h case    5:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8226B438h case    5:*/		return 0x8226B43C;
		  /* 8226B43Ch */ case    6:  		/* lbzx R11, <#[R11 + R27]> */
		/* 8226B43Ch case    6:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 8226B43Ch case    6:*/		return 0x8226B440;
		  /* 8226B440h */ case    7:  		/* andi. R11, R11, 23 */
		/* 8226B440h case    7:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x17);
		/* 8226B440h case    7:*/		return 0x8226B444;
		  /* 8226B444h */ case    8:  		/* cmpwi CR0, R11, 0 */
		/* 8226B444h case    8:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 8226B444h case    8:*/		return 0x8226B448;
		  /* 8226B448h */ case    9:  		/* bc 12, CR0_EQ, 64 */
		/* 8226B448h case    9:*/		if ( regs.CR[0].eq ) { return 0x8226B488;  }
		/* 8226B448h case    9:*/		return 0x8226B44C;
		  /* 8226B44Ch */ case   10:  		/* lwz R11, <#[R31 + 8]> */
		/* 8226B44Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8226B44Ch case   10:*/		return 0x8226B450;
		  /* 8226B450h */ case   11:  		/* lbz R10, <#[R29 + 4]> */
		/* 8226B450h case   11:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000004) );
		/* 8226B450h case   11:*/		return 0x8226B454;
		  /* 8226B454h */ case   12:  		/* rlwinm. R9, R11, 26, 31, 31 */
		/* 8226B454h case   12:*/		cpu::op::rlwinm<1,26,31,31>(regs,&regs.R9,regs.R11);
		/* 8226B454h case   12:*/		return 0x8226B458;
		  /* 8226B458h */ case   13:  		/* rlwinm R11, R10, 0, 30, 31 */
		/* 8226B458h case   13:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R10);
		/* 8226B458h case   13:*/		return 0x8226B45C;
		  /* 8226B45Ch */ case   14:  		/* bc 4, CR0_EQ, 12 */
		/* 8226B45Ch case   14:*/		if ( !regs.CR[0].eq ) { return 0x8226B468;  }
		/* 8226B45Ch case   14:*/		return 0x8226B460;
		  /* 8226B460h */ case   15:  		/* cmplwi CR6, R11, 3 */
		/* 8226B460h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 8226B460h case   15:*/		return 0x8226B464;
		  /* 8226B464h */ case   16:  		/* bc 12, CR6_EQ, 36 */
		/* 8226B464h case   16:*/		if ( regs.CR[6].eq ) { return 0x8226B488;  }
		/* 8226B464h case   16:*/		return 0x8226B468;
	}
	return 0x8226B468;
} // Block from 8226B424h-8226B468h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8226B468h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B468( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B468) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B468);
		  /* 8226B468h */ case    0:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8226B468h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8226B468h case    0:*/		return 0x8226B46C;
		  /* 8226B46Ch */ case    1:  		/* addi R10, R28, 480 */
		/* 8226B46Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R28,0x1E0);
		/* 8226B46Ch case    1:*/		return 0x8226B470;
		  /* 8226B470h */ case    2:  		/* lis R9, -32255 */
		/* 8226B470h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 8226B470h case    2:*/		return 0x8226B474;
		  /* 8226B474h */ case    3:  		/* mr R4, R30 */
		/* 8226B474h case    3:*/		regs.R4 = regs.R30;
		/* 8226B474h case    3:*/		return 0x8226B478;
		  /* 8226B478h */ case    4:  		/* addi R5, R9, 11684 */
		/* 8226B478h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R9,0x2DA4);
		/* 8226B478h case    4:*/		return 0x8226B47C;
		  /* 8226B47Ch */ case    5:  		/* mr R3, R31 */
		/* 8226B47Ch case    5:*/		regs.R3 = regs.R31;
		/* 8226B47Ch case    5:*/		return 0x8226B480;
		  /* 8226B480h */ case    6:  		/* lwzx R6, <#[R11 + R10]> */
		/* 8226B480h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8226B480h case    6:*/		return 0x8226B484;
		  /* 8226B484h */ case    7:  		/* bl -6820 */
		/* 8226B484h case    7:*/		regs.LR = 0x8226B488; return 0x822699E0;
		/* 8226B484h case    7:*/		return 0x8226B488;
	}
	return 0x8226B488;
} // Block from 8226B468h-8226B488h (8 instructions)

//////////////////////////////////////////////////////
// Block at 8226B488h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B488( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B488) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B488);
		  /* 8226B488h */ case    0:  		/* lwz R11, <#[R29 + 8]> */
		/* 8226B488h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8226B488h case    0:*/		return 0x8226B48C;
		  /* 8226B48Ch */ case    1:  		/* rlwinm R11, R11, 0, 16, 17 */
		/* 8226B48Ch case    1:*/		cpu::op::rlwinm<0,0,16,17>(regs,&regs.R11,regs.R11);
		/* 8226B48Ch case    1:*/		return 0x8226B490;
		  /* 8226B490h */ case    2:  		/* cmplwi CR6, R11, 32768 */
		/* 8226B490h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00008000);
		/* 8226B490h case    2:*/		return 0x8226B494;
		  /* 8226B494h */ case    3:  		/* bc 12, CR6_LT, 88 */
		/* 8226B494h case    3:*/		if ( regs.CR[6].lt ) { return 0x8226B4EC;  }
		/* 8226B494h case    3:*/		return 0x8226B498;
		  /* 8226B498h */ case    4:  		/* lwz R11, <#[R29]> */
		/* 8226B498h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8226B498h case    4:*/		return 0x8226B49C;
		  /* 8226B49Ch */ case    5:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 8226B49Ch case    5:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8226B49Ch case    5:*/		return 0x8226B4A0;
		  /* 8226B4A0h */ case    6:  		/* lbzx R11, <#[R11 + R27]> */
		/* 8226B4A0h case    6:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 8226B4A0h case    6:*/		return 0x8226B4A4;
		  /* 8226B4A4h */ case    7:  		/* andi. R11, R11, 23 */
		/* 8226B4A4h case    7:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x17);
		/* 8226B4A4h case    7:*/		return 0x8226B4A8;
		  /* 8226B4A8h */ case    8:  		/* cmpwi CR0, R11, 0 */
		/* 8226B4A8h case    8:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 8226B4A8h case    8:*/		return 0x8226B4AC;
		  /* 8226B4ACh */ case    9:  		/* bc 12, CR0_EQ, 64 */
		/* 8226B4ACh case    9:*/		if ( regs.CR[0].eq ) { return 0x8226B4EC;  }
		/* 8226B4ACh case    9:*/		return 0x8226B4B0;
		  /* 8226B4B0h */ case   10:  		/* lwz R11, <#[R31 + 8]> */
		/* 8226B4B0h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8226B4B0h case   10:*/		return 0x8226B4B4;
		  /* 8226B4B4h */ case   11:  		/* lwz R10, <#[R29 + 4]> */
		/* 8226B4B4h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000004) );
		/* 8226B4B4h case   11:*/		return 0x8226B4B8;
		  /* 8226B4B8h */ case   12:  		/* rlwinm. R9, R11, 26, 31, 31 */
		/* 8226B4B8h case   12:*/		cpu::op::rlwinm<1,26,31,31>(regs,&regs.R9,regs.R11);
		/* 8226B4B8h case   12:*/		return 0x8226B4BC;
		  /* 8226B4BCh */ case   13:  		/* rlwinm R11, R10, 6, 30, 31 */
		/* 8226B4BCh case   13:*/		cpu::op::rlwinm<0,6,30,31>(regs,&regs.R11,regs.R10);
		/* 8226B4BCh case   13:*/		return 0x8226B4C0;
		  /* 8226B4C0h */ case   14:  		/* bc 4, CR0_EQ, 12 */
		/* 8226B4C0h case   14:*/		if ( !regs.CR[0].eq ) { return 0x8226B4CC;  }
		/* 8226B4C0h case   14:*/		return 0x8226B4C4;
		  /* 8226B4C4h */ case   15:  		/* cmplwi CR6, R11, 3 */
		/* 8226B4C4h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 8226B4C4h case   15:*/		return 0x8226B4C8;
		  /* 8226B4C8h */ case   16:  		/* bc 12, CR6_EQ, 36 */
		/* 8226B4C8h case   16:*/		if ( regs.CR[6].eq ) { return 0x8226B4EC;  }
		/* 8226B4C8h case   16:*/		return 0x8226B4CC;
	}
	return 0x8226B4CC;
} // Block from 8226B488h-8226B4CCh (17 instructions)

//////////////////////////////////////////////////////
// Block at 8226B4CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B4CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B4CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B4CC);
		  /* 8226B4CCh */ case    0:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 8226B4CCh case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 8226B4CCh case    0:*/		return 0x8226B4D0;
		  /* 8226B4D0h */ case    1:  		/* addi R10, R28, 496 */
		/* 8226B4D0h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R28,0x1F0);
		/* 8226B4D0h case    1:*/		return 0x8226B4D4;
		  /* 8226B4D4h */ case    2:  		/* lis R9, -32255 */
		/* 8226B4D4h case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8201);
		/* 8226B4D4h case    2:*/		return 0x8226B4D8;
		  /* 8226B4D8h */ case    3:  		/* mr R4, R30 */
		/* 8226B4D8h case    3:*/		regs.R4 = regs.R30;
		/* 8226B4D8h case    3:*/		return 0x8226B4DC;
		  /* 8226B4DCh */ case    4:  		/* addi R5, R9, 11668 */
		/* 8226B4DCh case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R9,0x2D94);
		/* 8226B4DCh case    4:*/		return 0x8226B4E0;
		  /* 8226B4E0h */ case    5:  		/* mr R3, R31 */
		/* 8226B4E0h case    5:*/		regs.R3 = regs.R31;
		/* 8226B4E0h case    5:*/		return 0x8226B4E4;
		  /* 8226B4E4h */ case    6:  		/* lwzx R6, <#[R11 + R10]> */
		/* 8226B4E4h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 8226B4E4h case    6:*/		return 0x8226B4E8;
		  /* 8226B4E8h */ case    7:  		/* bl -6920 */
		/* 8226B4E8h case    7:*/		regs.LR = 0x8226B4EC; return 0x822699E0;
		/* 8226B4E8h case    7:*/		return 0x8226B4EC;
	}
	return 0x8226B4EC;
} // Block from 8226B4CCh-8226B4ECh (8 instructions)

//////////////////////////////////////////////////////
// Block at 8226B4ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B4EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B4EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B4EC);
		  /* 8226B4ECh */ case    0:  		/* lwz R11, <#[R29]> */
		/* 8226B4ECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8226B4ECh case    0:*/		return 0x8226B4F0;
		  /* 8226B4F0h */ case    1:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 8226B4F0h case    1:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8226B4F0h case    1:*/		return 0x8226B4F4;
		  /* 8226B4F4h */ case    2:  		/* lbzx R11, <#[R11 + R27]> */
		/* 8226B4F4h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 8226B4F4h case    2:*/		return 0x8226B4F8;
		  /* 8226B4F8h */ case    3:  		/* andi. R11, R11, 23 */
		/* 8226B4F8h case    3:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x17);
		/* 8226B4F8h case    3:*/		return 0x8226B4FC;
		  /* 8226B4FCh */ case    4:  		/* cmpwi CR0, R11, 0 */
		/* 8226B4FCh case    4:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 8226B4FCh case    4:*/		return 0x8226B500;
		  /* 8226B500h */ case    5:  		/* bc 12, CR0_EQ, 32 */
		/* 8226B500h case    5:*/		if ( regs.CR[0].eq ) { return 0x8226B520;  }
		/* 8226B500h case    5:*/		return 0x8226B504;
		  /* 8226B504h */ case    6:  		/* lwz R11, <#[R29 + 4]> */
		/* 8226B504h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 8226B504h case    6:*/		return 0x8226B508;
		  /* 8226B508h */ case    7:  		/* lis R10, -32255 */
		/* 8226B508h case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 8226B508h case    7:*/		return 0x8226B50C;
		  /* 8226B50Ch */ case    8:  		/* li R6, 1 */
		/* 8226B50Ch case    8:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 8226B50Ch case    8:*/		return 0x8226B510;
		  /* 8226B510h */ case    9:  		/* addi R4, R10, 11652 */
		/* 8226B510h case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0x2D84);
		/* 8226B510h case    9:*/		return 0x8226B514;
		  /* 8226B514h */ case   10:  		/* rlwinm R5, R11, 4, 31, 31 */
		/* 8226B514h case   10:*/		cpu::op::rlwinm<0,4,31,31>(regs,&regs.R5,regs.R11);
		/* 8226B514h case   10:*/		return 0x8226B518;
		  /* 8226B518h */ case   11:  		/* mr R3, R31 */
		/* 8226B518h case   11:*/		regs.R3 = regs.R31;
		/* 8226B518h case   11:*/		return 0x8226B51C;
		  /* 8226B51Ch */ case   12:  		/* bl -2412 */
		/* 8226B51Ch case   12:*/		regs.LR = 0x8226B520; return 0x8226ABB0;
		/* 8226B51Ch case   12:*/		return 0x8226B520;
	}
	return 0x8226B520;
} // Block from 8226B4ECh-8226B520h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8226B520h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B520( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B520) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B520);
		  /* 8226B520h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 8226B520h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8226B520h case    0:*/		return 0x8226B524;
		  /* 8226B524h */ case    1:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 8226B524h case    1:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8226B524h case    1:*/		return 0x8226B528;
		  /* 8226B528h */ case    2:  		/* lbzx R11, <#[R11 + R27]> */
		/* 8226B528h case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 8226B528h case    2:*/		return 0x8226B52C;
		  /* 8226B52Ch */ case    3:  		/* andi. R11, R11, 23 */
		/* 8226B52Ch case    3:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x17);
		/* 8226B52Ch case    3:*/		return 0x8226B530;
		  /* 8226B530h */ case    4:  		/* cmpwi CR0, R11, 0 */
		/* 8226B530h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 8226B530h case    4:*/		return 0x8226B534;
		  /* 8226B534h */ case    5:  		/* bc 12, CR0_EQ, 32 */
		/* 8226B534h case    5:*/		if ( regs.CR[0].eq ) { return 0x8226B554;  }
		/* 8226B534h case    5:*/		return 0x8226B538;
		  /* 8226B538h */ case    6:  		/* lwz R11, <#[R29 + 4]> */
		/* 8226B538h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 8226B538h case    6:*/		return 0x8226B53C;
		  /* 8226B53Ch */ case    7:  		/* lis R10, -32255 */
		/* 8226B53Ch case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 8226B53Ch case    7:*/		return 0x8226B540;
		  /* 8226B540h */ case    8:  		/* li R6, 0 */
		/* 8226B540h case    8:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8226B540h case    8:*/		return 0x8226B544;
		  /* 8226B544h */ case    9:  		/* addi R4, R10, 11636 */
		/* 8226B544h case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0x2D74);
		/* 8226B544h case    9:*/		return 0x8226B548;
		  /* 8226B548h */ case   10:  		/* rlwinm R5, R11, 3, 30, 31 */
		/* 8226B548h case   10:*/		cpu::op::rlwinm<0,3,30,31>(regs,&regs.R5,regs.R11);
		/* 8226B548h case   10:*/		return 0x8226B54C;
		  /* 8226B54Ch */ case   11:  		/* mr R3, R31 */
		/* 8226B54Ch case   11:*/		regs.R3 = regs.R31;
		/* 8226B54Ch case   11:*/		return 0x8226B550;
		  /* 8226B550h */ case   12:  		/* bl -2464 */
		/* 8226B550h case   12:*/		regs.LR = 0x8226B554; return 0x8226ABB0;
		/* 8226B550h case   12:*/		return 0x8226B554;
	}
	return 0x8226B554;
} // Block from 8226B520h-8226B554h (13 instructions)

//////////////////////////////////////////////////////
// Block at 8226B554h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B554( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B554) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B554);
		  /* 8226B554h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 8226B554h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8226B554h case    0:*/		return 0x8226B558;
		  /* 8226B558h */ case    1:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 8226B558h case    1:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8226B558h case    1:*/		return 0x8226B55C;
		  /* 8226B55Ch */ case    2:  		/* lbzx R11, <#[R11 + R27]> */
		/* 8226B55Ch case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 8226B55Ch case    2:*/		return 0x8226B560;
		  /* 8226B560h */ case    3:  		/* rlwinm. R11, R11, 0, 27, 31 */
		/* 8226B560h case    3:*/		cpu::op::rlwinm<1,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8226B560h case    3:*/		return 0x8226B564;
		  /* 8226B564h */ case    4:  		/* bc 12, CR0_EQ, 32 */
		/* 8226B564h case    4:*/		if ( regs.CR[0].eq ) { return 0x8226B584;  }
		/* 8226B564h case    4:*/		return 0x8226B568;
		  /* 8226B568h */ case    5:  		/* lwz R11, <#[R29 + 8]> */
		/* 8226B568h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8226B568h case    5:*/		return 0x8226B56C;
		  /* 8226B56Ch */ case    6:  		/* lis R10, -32255 */
		/* 8226B56Ch case    6:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8201);
		/* 8226B56Ch case    6:*/		return 0x8226B570;
		  /* 8226B570h */ case    7:  		/* li R6, 0 */
		/* 8226B570h case    7:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8226B570h case    7:*/		return 0x8226B574;
		  /* 8226B574h */ case    8:  		/* addi R4, R10, 11612 */
		/* 8226B574h case    8:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0x2D5C);
		/* 8226B574h case    8:*/		return 0x8226B578;
		  /* 8226B578h */ case    9:  		/* rlwinm R5, R11, 0, 31, 31 */
		/* 8226B578h case    9:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R5,regs.R11);
		/* 8226B578h case    9:*/		return 0x8226B57C;
		  /* 8226B57Ch */ case   10:  		/* mr R3, R31 */
		/* 8226B57Ch case   10:*/		regs.R3 = regs.R31;
		/* 8226B57Ch case   10:*/		return 0x8226B580;
		  /* 8226B580h */ case   11:  		/* bl -2512 */
		/* 8226B580h case   11:*/		regs.LR = 0x8226B584; return 0x8226ABB0;
		/* 8226B580h case   11:*/		return 0x8226B584;
	}
	return 0x8226B584;
} // Block from 8226B554h-8226B584h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8226B584h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B584( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B584) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B584);
		  /* 8226B584h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 8226B584h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8226B584h case    0:*/		return 0x8226B588;
		  /* 8226B588h */ case    1:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 8226B588h case    1:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8226B588h case    1:*/		return 0x8226B58C;
		  /* 8226B58Ch */ case    2:  		/* lbzx R11, <#[R11 + R27]> */
		/* 8226B58Ch case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 8226B58Ch case    2:*/		return 0x8226B590;
		  /* 8226B590h */ case    3:  		/* andi. R11, R11, 19 */
		/* 8226B590h case    3:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x13);
		/* 8226B590h case    3:*/		return 0x8226B594;
		  /* 8226B594h */ case    4:  		/* cmpwi CR0, R11, 0 */
		/* 8226B594h case    4:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 8226B594h case    4:*/		return 0x8226B598;
		  /* 8226B598h */ case    5:  		/* bc 12, CR0_EQ, 96 */
		/* 8226B598h case    5:*/		if ( regs.CR[0].eq ) { return 0x8226B5F8;  }
		/* 8226B598h case    5:*/		return 0x8226B59C;
		  /* 8226B59Ch */ case    6:  		/* lwz R11, <#[R31 + 8]> */
		/* 8226B59Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8226B59Ch case    6:*/		return 0x8226B5A0;
		  /* 8226B5A0h */ case    7:  		/* rlwinm. R11, R11, 26, 31, 31 */
		/* 8226B5A0h case    7:*/		cpu::op::rlwinm<1,26,31,31>(regs,&regs.R11,regs.R11);
		/* 8226B5A0h case    7:*/		return 0x8226B5A4;
		  /* 8226B5A4h */ case    8:  		/* bc 4, CR0_EQ, 16 */
		/* 8226B5A4h case    8:*/		if ( !regs.CR[0].eq ) { return 0x8226B5B4;  }
		/* 8226B5A4h case    8:*/		return 0x8226B5A8;
		  /* 8226B5A8h */ case    9:  		/* lwz R11, <#[R29 + 8]> */
		/* 8226B5A8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8226B5A8h case    9:*/		return 0x8226B5AC;
		  /* 8226B5ACh */ case   10:  		/* rlwinm. R11, R11, 0, 23, 29 */
		/* 8226B5ACh case   10:*/		cpu::op::rlwinm<1,0,23,29>(regs,&regs.R11,regs.R11);
		/* 8226B5ACh case   10:*/		return 0x8226B5B0;
		  /* 8226B5B0h */ case   11:  		/* bc 12, CR0_EQ, 72 */
		/* 8226B5B0h case   11:*/		if ( regs.CR[0].eq ) { return 0x8226B5F8;  }
		/* 8226B5B0h case   11:*/		return 0x8226B5B4;
	}
	return 0x8226B5B4;
} // Block from 8226B584h-8226B5B4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 8226B5B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B5B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B5B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B5B4);
		  /* 8226B5B4h */ case    0:  		/* lwz R11, <#[R29 + 8]> */
		/* 8226B5B4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8226B5B4h case    0:*/		return 0x8226B5B8;
		  /* 8226B5B8h */ case    1:  		/* lis R10, -32256 */
		/* 8226B5B8h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 8226B5B8h case    1:*/		return 0x8226B5BC;
		  /* 8226B5BCh */ case    2:  		/* lis R9, -32251 */
		/* 8226B5BCh case    2:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8205);
		/* 8226B5BCh case    2:*/		return 0x8226B5C0;
		  /* 8226B5C0h */ case    3:  		/* rlwinm R11, R11, 23, 0, 8 */
		/* 8226B5C0h case    3:*/		cpu::op::rlwinm<0,23,0,8>(regs,&regs.R11,regs.R11);
		/* 8226B5C0h case    3:*/		return 0x8226B5C4;
		  /* 8226B5C4h */ case    4:  		/* addi R4, R9, -15976 */
		/* 8226B5C4h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R9,0xFFFFC198);
		/* 8226B5C4h case    4:*/		return 0x8226B5C8;
		  /* 8226B5C8h */ case    5:  		/* srawi R11, R11, 25 */
		/* 8226B5C8h case    5:*/		cpu::op::srawi<0,25>(regs,&regs.R11,regs.R11);
		/* 8226B5C8h case    5:*/		return 0x8226B5CC;
		  /* 8226B5CCh */ case    6:  		/* lfs FR0, <#[R10 + 2980]> */
		/* 8226B5CCh case    6:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000BA4) );
		/* 8226B5CCh case    6:*/		return 0x8226B5D0;
		  /* 8226B5D0h */ case    7:  		/* mr R3, R31 */
		/* 8226B5D0h case    7:*/		regs.R3 = regs.R31;
		/* 8226B5D0h case    7:*/		return 0x8226B5D4;
		  /* 8226B5D4h */ case    8:  		/* extsw R11, R11 */
		/* 8226B5D4h case    8:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R11);
		/* 8226B5D4h case    8:*/		return 0x8226B5D8;
		  /* 8226B5D8h */ case    9:  		/* std R11, <#[R1 + 120]> */
		/* 8226B5D8h case    9:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000078) );
		/* 8226B5D8h case    9:*/		return 0x8226B5DC;
		  /* 8226B5DCh */ case   10:  		/* lfd FR13, <#[R1 + 120]> */
		/* 8226B5DCh case   10:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000078) );
		/* 8226B5DCh case   10:*/		return 0x8226B5E0;
		  /* 8226B5E0h */ case   11:  		/* fcfid FR13, FR13 */
		/* 8226B5E0h case   11:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 8226B5E0h case   11:*/		return 0x8226B5E4;
		  /* 8226B5E4h */ case   12:  		/* frsp FR13, FR13 */
		/* 8226B5E4h case   12:*/		cpu::op::frsp<0>(regs,&regs.FR13,regs.FR13);
		/* 8226B5E4h case   12:*/		return 0x8226B5E8;
		  /* 8226B5E8h */ case   13:  		/* fmuls FR1, FR13, FR0 */
		/* 8226B5E8h case   13:*/		cpu::op::fmuls<0>(regs,&regs.FR1,regs.FR13,regs.FR0);
		/* 8226B5E8h case   13:*/		return 0x8226B5EC;
		  /* 8226B5ECh */ case   14:  		/* stfd FR1, <#[R1 + 32]> */
		/* 8226B5ECh case   14:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000020) );
		/* 8226B5ECh case   14:*/		return 0x8226B5F0;
		  /* 8226B5F0h */ case   15:  		/* ld R5, <#[R1 + 32]> */
		/* 8226B5F0h case   15:*/		cpu::mem::load64( regs, &regs.R5, (uint32)(regs.R1 + 0x00000020) );
		/* 8226B5F0h case   15:*/		return 0x8226B5F4;
		  /* 8226B5F4h */ case   16:  		/* bl -7188 */
		/* 8226B5F4h case   16:*/		regs.LR = 0x8226B5F8; return 0x822699E0;
		/* 8226B5F4h case   16:*/		return 0x8226B5F8;
	}
	return 0x8226B5F8;
} // Block from 8226B5B4h-8226B5F8h (17 instructions)

//////////////////////////////////////////////////////
// Block at 8226B5F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B5F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B5F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B5F8);
		  /* 8226B5F8h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 8226B5F8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8226B5F8h case    0:*/		return 0x8226B5FC;
		  /* 8226B5FCh */ case    1:  		/* lis R10, -32256 */
		/* 8226B5FCh case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 8226B5FCh case    1:*/		return 0x8226B600;
		  /* 8226B600h */ case    2:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 8226B600h case    2:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 8226B600h case    2:*/		return 0x8226B604;
		  /* 8226B604h */ case    3:  		/* lfs FR31, <#[R10 + 1820]> */
		/* 8226B604h case    3:*/		cpu::mem::load32f( regs, &regs.FR31, (uint32)(regs.R10 + 0x0000071C) );
		/* 8226B604h case    3:*/		return 0x8226B608;
		  /* 8226B608h */ case    4:  		/* lbzx R11, <#[R11 + R27]> */
		/* 8226B608h case    4:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R27 + 0x00000000) );
		/* 8226B608h case    4:*/		return 0x8226B60C;
		  /* 8226B60Ch */ case    5:  		/* andi. R11, R11, 19 */
		/* 8226B60Ch case    5:*/		cpu::op::andi<1>(regs,&regs.R11,regs.R11,0x13);
		/* 8226B60Ch case    5:*/		return 0x8226B610;
		  /* 8226B610h */ case    6:  		/* cmpwi CR0, R11, 0 */
		/* 8226B610h case    6:*/		cpu::op::cmpwi<0>(regs,regs.R11,0x00000000);
		/* 8226B610h case    6:*/		return 0x8226B614;
		  /* 8226B614h */ case    7:  		/* bc 12, CR0_EQ, 88 */
		/* 8226B614h case    7:*/		if ( regs.CR[0].eq ) { return 0x8226B66C;  }
		/* 8226B614h case    7:*/		return 0x8226B618;
		  /* 8226B618h */ case    8:  		/* lwz R11, <#[R31 + 8]> */
		/* 8226B618h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8226B618h case    8:*/		return 0x8226B61C;
		  /* 8226B61Ch */ case    9:  		/* rlwinm. R11, R11, 26, 31, 31 */
		/* 8226B61Ch case    9:*/		cpu::op::rlwinm<1,26,31,31>(regs,&regs.R11,regs.R11);
		/* 8226B61Ch case    9:*/		return 0x8226B620;
		  /* 8226B620h */ case   10:  		/* bc 4, CR0_EQ, 16 */
		/* 8226B620h case   10:*/		if ( !regs.CR[0].eq ) { return 0x8226B630;  }
		/* 8226B620h case   10:*/		return 0x8226B624;
		  /* 8226B624h */ case   11:  		/* lwz R11, <#[R29 + 8]> */
		/* 8226B624h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8226B624h case   11:*/		return 0x8226B628;
		  /* 8226B628h */ case   12:  		/* rlwinm. R11, R11, 0, 11, 15 */
		/* 8226B628h case   12:*/		cpu::op::rlwinm<1,0,11,15>(regs,&regs.R11,regs.R11);
		/* 8226B628h case   12:*/		return 0x8226B62C;
		  /* 8226B62Ch */ case   13:  		/* bc 12, CR0_EQ, 64 */
		/* 8226B62Ch case   13:*/		if ( regs.CR[0].eq ) { return 0x8226B66C;  }
		/* 8226B62Ch case   13:*/		return 0x8226B630;
	}
	return 0x8226B630;
} // Block from 8226B5F8h-8226B630h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8226B630h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B630( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B630) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B630);
		  /* 8226B630h */ case    0:  		/* lwz R11, <#[R29 + 8]> */
		/* 8226B630h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8226B630h case    0:*/		return 0x8226B634;
		  /* 8226B634h */ case    1:  		/* lis R10, -32251 */
		/* 8226B634h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 8226B634h case    1:*/		return 0x8226B638;
		  /* 8226B638h */ case    2:  		/* mr R3, R31 */
		/* 8226B638h case    2:*/		regs.R3 = regs.R31;
		/* 8226B638h case    2:*/		return 0x8226B63C;
		  /* 8226B63Ch */ case    3:  		/* rlwinm R11, R11, 11, 0, 20 */
		/* 8226B63Ch case    3:*/		cpu::op::rlwinm<0,11,0,20>(regs,&regs.R11,regs.R11);
		/* 8226B63Ch case    3:*/		return 0x8226B640;
		  /* 8226B640h */ case    4:  		/* addi R4, R10, -15992 */
		/* 8226B640h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0xFFFFC188);
		/* 8226B640h case    4:*/		return 0x8226B644;
		  /* 8226B644h */ case    5:  		/* srawi R11, R11, 27 */
		/* 8226B644h case    5:*/		cpu::op::srawi<0,27>(regs,&regs.R11,regs.R11);
		/* 8226B644h case    5:*/		return 0x8226B648;
		  /* 8226B648h */ case    6:  		/* extsw R11, R11 */
		/* 8226B648h case    6:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R11);
		/* 8226B648h case    6:*/		return 0x8226B64C;
		  /* 8226B64Ch */ case    7:  		/* std R11, <#[R1 + 120]> */
		/* 8226B64Ch case    7:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000078) );
		/* 8226B64Ch case    7:*/		return 0x8226B650;
		  /* 8226B650h */ case    8:  		/* lfd FR0, <#[R1 + 120]> */
		/* 8226B650h case    8:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000078) );
		/* 8226B650h case    8:*/		return 0x8226B654;
		  /* 8226B654h */ case    9:  		/* fcfid FR0, FR0 */
		/* 8226B654h case    9:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 8226B654h case    9:*/		return 0x8226B658;
		  /* 8226B658h */ case   10:  		/* frsp FR0, FR0 */
		/* 8226B658h case   10:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 8226B658h case   10:*/		return 0x8226B65C;
		  /* 8226B65Ch */ case   11:  		/* fmuls FR1, FR0, FR31 */
		/* 8226B65Ch case   11:*/		cpu::op::fmuls<0>(regs,&regs.FR1,regs.FR0,regs.FR31);
		/* 8226B65Ch case   11:*/		return 0x8226B660;
		  /* 8226B660h */ case   12:  		/* stfd FR1, <#[R1 + 32]> */
		/* 8226B660h case   12:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000020) );
		/* 8226B660h case   12:*/		return 0x8226B664;
		  /* 8226B664h */ case   13:  		/* ld R5, <#[R1 + 32]> */
		/* 8226B664h case   13:*/		cpu::mem::load64( regs, &regs.R5, (uint32)(regs.R1 + 0x00000020) );
		/* 8226B664h case   13:*/		return 0x8226B668;
		  /* 8226B668h */ case   14:  		/* bl -7304 */
		/* 8226B668h case   14:*/		regs.LR = 0x8226B66C; return 0x822699E0;
		/* 8226B668h case   14:*/		return 0x8226B66C;
	}
	return 0x8226B66C;
} // Block from 8226B630h-8226B66Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8226B66Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B66C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B66C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B66C);
		  /* 8226B66Ch */ case    0:  		/* lwz R11, <#[R29 + 8]> */
		/* 8226B66Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8226B66Ch case    0:*/		return 0x8226B670;
		  /* 8226B670h */ case    1:  		/* rlwinm R10, R11, 0, 16, 17 */
		/* 8226B670h case    1:*/		cpu::op::rlwinm<0,0,16,17>(regs,&regs.R10,regs.R11);
		/* 8226B670h case    1:*/		return 0x8226B674;
		  /* 8226B674h */ case    2:  		/* cmplwi CR6, R10, 16384 */
		/* 8226B674h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00004000);
		/* 8226B674h case    2:*/		return 0x8226B678;
		  /* 8226B678h */ case    3:  		/* bc 12, CR6_LT, 104 */
		/* 8226B678h case    3:*/		if ( regs.CR[6].lt ) { return 0x8226B6E0;  }
		/* 8226B678h case    3:*/		return 0x8226B67C;
		  /* 8226B67Ch */ case    4:  		/* lwz R10, <#[R29]> */
		/* 8226B67Ch case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 8226B67Ch case    4:*/		return 0x8226B680;
		  /* 8226B680h */ case    5:  		/* rlwinm R10, R10, 0, 27, 31 */
		/* 8226B680h case    5:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R10);
		/* 8226B680h case    5:*/		return 0x8226B684;
		  /* 8226B684h */ case    6:  		/* lbzx R10, <#[R10 + R27]> */
		/* 8226B684h case    6:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R10 + regs.R27 + 0x00000000) );
		/* 8226B684h case    6:*/		return 0x8226B688;
		  /* 8226B688h */ case    7:  		/* andi. R10, R10, 19 */
		/* 8226B688h case    7:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R10,0x13);
		/* 8226B688h case    7:*/		return 0x8226B68C;
		  /* 8226B68Ch */ case    8:  		/* cmpwi CR0, R10, 0 */
		/* 8226B68Ch case    8:*/		cpu::op::cmpwi<0>(regs,regs.R10,0x00000000);
		/* 8226B68Ch case    8:*/		return 0x8226B690;
		  /* 8226B690h */ case    9:  		/* bc 12, CR0_EQ, 80 */
		/* 8226B690h case    9:*/		if ( regs.CR[0].eq ) { return 0x8226B6E0;  }
		/* 8226B690h case    9:*/		return 0x8226B694;
		  /* 8226B694h */ case   10:  		/* lwz R10, <#[R31 + 8]> */
		/* 8226B694h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8226B694h case   10:*/		return 0x8226B698;
		  /* 8226B698h */ case   11:  		/* rlwinm. R10, R10, 26, 31, 31 */
		/* 8226B698h case   11:*/		cpu::op::rlwinm<1,26,31,31>(regs,&regs.R10,regs.R10);
		/* 8226B698h case   11:*/		return 0x8226B69C;
		  /* 8226B69Ch */ case   12:  		/* bc 4, CR0_EQ, 12 */
		/* 8226B69Ch case   12:*/		if ( !regs.CR[0].eq ) { return 0x8226B6A8;  }
		/* 8226B69Ch case   12:*/		return 0x8226B6A0;
		  /* 8226B6A0h */ case   13:  		/* rlwinm. R10, R11, 0, 6, 10 */
		/* 8226B6A0h case   13:*/		cpu::op::rlwinm<1,0,6,10>(regs,&regs.R10,regs.R11);
		/* 8226B6A0h case   13:*/		return 0x8226B6A4;
		  /* 8226B6A4h */ case   14:  		/* bc 12, CR0_EQ, 60 */
		/* 8226B6A4h case   14:*/		if ( regs.CR[0].eq ) { return 0x8226B6E0;  }
		/* 8226B6A4h case   14:*/		return 0x8226B6A8;
	}
	return 0x8226B6A8;
} // Block from 8226B66Ch-8226B6A8h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8226B6A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B6A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B6A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B6A8);
		  /* 8226B6A8h */ case    0:  		/* rlwinm R11, R11, 6, 0, 25 */
		/* 8226B6A8h case    0:*/		cpu::op::rlwinm<0,6,0,25>(regs,&regs.R11,regs.R11);
		/* 8226B6A8h case    0:*/		return 0x8226B6AC;
		  /* 8226B6ACh */ case    1:  		/* lis R10, -32251 */
		/* 8226B6ACh case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 8226B6ACh case    1:*/		return 0x8226B6B0;
		  /* 8226B6B0h */ case    2:  		/* srawi R11, R11, 27 */
		/* 8226B6B0h case    2:*/		cpu::op::srawi<0,27>(regs,&regs.R11,regs.R11);
		/* 8226B6B0h case    2:*/		return 0x8226B6B4;
		  /* 8226B6B4h */ case    3:  		/* addi R4, R10, -16008 */
		/* 8226B6B4h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0xFFFFC178);
		/* 8226B6B4h case    3:*/		return 0x8226B6B8;
		  /* 8226B6B8h */ case    4:  		/* extsw R11, R11 */
		/* 8226B6B8h case    4:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R11);
		/* 8226B6B8h case    4:*/		return 0x8226B6BC;
		  /* 8226B6BCh */ case    5:  		/* mr R3, R31 */
		/* 8226B6BCh case    5:*/		regs.R3 = regs.R31;
		/* 8226B6BCh case    5:*/		return 0x8226B6C0;
		  /* 8226B6C0h */ case    6:  		/* std R11, <#[R1 + 120]> */
		/* 8226B6C0h case    6:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000078) );
		/* 8226B6C0h case    6:*/		return 0x8226B6C4;
		  /* 8226B6C4h */ case    7:  		/* lfd FR0, <#[R1 + 120]> */
		/* 8226B6C4h case    7:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000078) );
		/* 8226B6C4h case    7:*/		return 0x8226B6C8;
		  /* 8226B6C8h */ case    8:  		/* fcfid FR0, FR0 */
		/* 8226B6C8h case    8:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 8226B6C8h case    8:*/		return 0x8226B6CC;
		  /* 8226B6CCh */ case    9:  		/* frsp FR0, FR0 */
		/* 8226B6CCh case    9:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 8226B6CCh case    9:*/		return 0x8226B6D0;
		  /* 8226B6D0h */ case   10:  		/* fmuls FR1, FR0, FR31 */
		/* 8226B6D0h case   10:*/		cpu::op::fmuls<0>(regs,&regs.FR1,regs.FR0,regs.FR31);
		/* 8226B6D0h case   10:*/		return 0x8226B6D4;
		  /* 8226B6D4h */ case   11:  		/* stfd FR1, <#[R1 + 32]> */
		/* 8226B6D4h case   11:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000020) );
		/* 8226B6D4h case   11:*/		return 0x8226B6D8;
		  /* 8226B6D8h */ case   12:  		/* ld R5, <#[R1 + 32]> */
		/* 8226B6D8h case   12:*/		cpu::mem::load64( regs, &regs.R5, (uint32)(regs.R1 + 0x00000020) );
		/* 8226B6D8h case   12:*/		return 0x8226B6DC;
		  /* 8226B6DCh */ case   13:  		/* bl -7420 */
		/* 8226B6DCh case   13:*/		regs.LR = 0x8226B6E0; return 0x822699E0;
		/* 8226B6DCh case   13:*/		return 0x8226B6E0;
	}
	return 0x8226B6E0;
} // Block from 8226B6A8h-8226B6E0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 8226B6E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B6E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B6E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B6E0);
		  /* 8226B6E0h */ case    0:  		/* lwz R11, <#[R29 + 8]> */
		/* 8226B6E0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 8226B6E0h case    0:*/		return 0x8226B6E4;
		  /* 8226B6E4h */ case    1:  		/* rlwinm R10, R11, 0, 16, 17 */
		/* 8226B6E4h case    1:*/		cpu::op::rlwinm<0,0,16,17>(regs,&regs.R10,regs.R11);
		/* 8226B6E4h case    1:*/		return 0x8226B6E8;
		  /* 8226B6E8h */ case    2:  		/* cmplwi CR6, R10, 32768 */
		/* 8226B6E8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00008000);
		/* 8226B6E8h case    2:*/		return 0x8226B6EC;
		  /* 8226B6ECh */ case    3:  		/* bc 12, CR6_LT, 1464 */
		/* 8226B6ECh case    3:*/		if ( regs.CR[6].lt ) { return 0x8226BCA4;  }
		/* 8226B6ECh case    3:*/		return 0x8226B6F0;
		  /* 8226B6F0h */ case    4:  		/* lwz R10, <#[R29]> */
		/* 8226B6F0h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 8226B6F0h case    4:*/		return 0x8226B6F4;
		  /* 8226B6F4h */ case    5:  		/* rlwinm R10, R10, 0, 27, 31 */
		/* 8226B6F4h case    5:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R10);
		/* 8226B6F4h case    5:*/		return 0x8226B6F8;
		  /* 8226B6F8h */ case    6:  		/* lbzx R10, <#[R10 + R27]> */
		/* 8226B6F8h case    6:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R10 + regs.R27 + 0x00000000) );
		/* 8226B6F8h case    6:*/		return 0x8226B6FC;
		  /* 8226B6FCh */ case    7:  		/* andi. R10, R10, 19 */
		/* 8226B6FCh case    7:*/		cpu::op::andi<1>(regs,&regs.R10,regs.R10,0x13);
		/* 8226B6FCh case    7:*/		return 0x8226B700;
		  /* 8226B700h */ case    8:  		/* cmpwi CR0, R10, 0 */
		/* 8226B700h case    8:*/		cpu::op::cmpwi<0>(regs,regs.R10,0x00000000);
		/* 8226B700h case    8:*/		return 0x8226B704;
		  /* 8226B704h */ case    9:  		/* bc 12, CR0_EQ, 1440 */
		/* 8226B704h case    9:*/		if ( regs.CR[0].eq ) { return 0x8226BCA4;  }
		/* 8226B704h case    9:*/		return 0x8226B708;
		  /* 8226B708h */ case   10:  		/* lwz R10, <#[R31 + 8]> */
		/* 8226B708h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 8226B708h case   10:*/		return 0x8226B70C;
		  /* 8226B70Ch */ case   11:  		/* rlwinm. R10, R10, 26, 31, 31 */
		/* 8226B70Ch case   11:*/		cpu::op::rlwinm<1,26,31,31>(regs,&regs.R10,regs.R10);
		/* 8226B70Ch case   11:*/		return 0x8226B710;
		  /* 8226B710h */ case   12:  		/* bc 4, CR0_EQ, 12 */
		/* 8226B710h case   12:*/		if ( !regs.CR[0].eq ) { return 0x8226B71C;  }
		/* 8226B710h case   12:*/		return 0x8226B714;
		  /* 8226B714h */ case   13:  		/* rlwinm. R10, R11, 0, 1, 5 */
		/* 8226B714h case   13:*/		cpu::op::rlwinm<1,0,1,5>(regs,&regs.R10,regs.R11);
		/* 8226B714h case   13:*/		return 0x8226B718;
		  /* 8226B718h */ case   14:  		/* bc 12, CR0_EQ, 1420 */
		/* 8226B718h case   14:*/		if ( regs.CR[0].eq ) { return 0x8226BCA4;  }
		/* 8226B718h case   14:*/		return 0x8226B71C;
	}
	return 0x8226B71C;
} // Block from 8226B6E0h-8226B71Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8226B71Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B71C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B71C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B71C);
		  /* 8226B71Ch */ case    0:  		/* rlwinm R11, R11, 1, 0, 30 */
		/* 8226B71Ch case    0:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R11);
		/* 8226B71Ch case    0:*/		return 0x8226B720;
		  /* 8226B720h */ case    1:  		/* lis R10, -32251 */
		/* 8226B720h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 8226B720h case    1:*/		return 0x8226B724;
		  /* 8226B724h */ case    2:  		/* srawi R11, R11, 27 */
		/* 8226B724h case    2:*/		cpu::op::srawi<0,27>(regs,&regs.R11,regs.R11);
		/* 8226B724h case    2:*/		return 0x8226B728;
		  /* 8226B728h */ case    3:  		/* addi R4, R10, -16024 */
		/* 8226B728h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0xFFFFC168);
		/* 8226B728h case    3:*/		return 0x8226B72C;
		  /* 8226B72Ch */ case    4:  		/* extsw R11, R11 */
		/* 8226B72Ch case    4:*/		cpu::op::extsw<0>(regs,&regs.R11,regs.R11);
		/* 8226B72Ch case    4:*/		return 0x8226B730;
		  /* 8226B730h */ case    5:  		/* mr R3, R31 */
		/* 8226B730h case    5:*/		regs.R3 = regs.R31;
		/* 8226B730h case    5:*/		return 0x8226B734;
		  /* 8226B734h */ case    6:  		/* std R11, <#[R1 + 120]> */
		/* 8226B734h case    6:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000078) );
		/* 8226B734h case    6:*/		return 0x8226B738;
		  /* 8226B738h */ case    7:  		/* lfd FR0, <#[R1 + 120]> */
		/* 8226B738h case    7:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000078) );
		/* 8226B738h case    7:*/		return 0x8226B73C;
		  /* 8226B73Ch */ case    8:  		/* fcfid FR0, FR0 */
		/* 8226B73Ch case    8:*/		cpu::op::fcfid<0>(regs,&regs.FR0,regs.FR0);
		/* 8226B73Ch case    8:*/		return 0x8226B740;
		  /* 8226B740h */ case    9:  		/* frsp FR0, FR0 */
		/* 8226B740h case    9:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR0);
		/* 8226B740h case    9:*/		return 0x8226B744;
		  /* 8226B744h */ case   10:  		/* fmuls FR1, FR0, FR31 */
		/* 8226B744h case   10:*/		cpu::op::fmuls<0>(regs,&regs.FR1,regs.FR0,regs.FR31);
		/* 8226B744h case   10:*/		return 0x8226B748;
		  /* 8226B748h */ case   11:  		/* stfd FR1, <#[R1 + 32]> */
		/* 8226B748h case   11:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000020) );
		/* 8226B748h case   11:*/		return 0x8226B74C;
		  /* 8226B74Ch */ case   12:  		/* ld R5, <#[R1 + 32]> */
		/* 8226B74Ch case   12:*/		cpu::mem::load64( regs, &regs.R5, (uint32)(regs.R1 + 0x00000020) );
		/* 8226B74Ch case   12:*/		return 0x8226B750;
		  /* 8226B750h */ case   13:  		/* bl -7536 */
		/* 8226B750h case   13:*/		regs.LR = 0x8226B754; return 0x822699E0;
		/* 8226B750h case   13:*/		return 0x8226B754;
		  /* 8226B754h */ case   14:  		/* b 1360 */
		/* 8226B754h case   14:*/		return 0x8226BCA4;
		/* 8226B754h case   14:*/		return 0x8226B758;
	}
	return 0x8226B758;
} // Block from 8226B71Ch-8226B758h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8226B758h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B758( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B758) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B758);
		  /* 8226B758h */ case    0:  		/* cmpwi CR6, R5, 0 */
		/* 8226B758h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R5,0x00000000);
		/* 8226B758h case    0:*/		return 0x8226B75C;
		  /* 8226B75Ch */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 8226B75Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x8226B774;  }
		/* 8226B75Ch case    1:*/		return 0x8226B760;
		  /* 8226B760h */ case    2:  		/* lis R11, -32251 */
		/* 8226B760h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8205);
		/* 8226B760h case    2:*/		return 0x8226B764;
		  /* 8226B764h */ case    3:  		/* addi R4, R11, -16056 */
		/* 8226B764h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFC148);
		/* 8226B764h case    3:*/		return 0x8226B768;
	}
	return 0x8226B768;
} // Block from 8226B758h-8226B768h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226B768h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B768( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B768) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B768);
		  /* 8226B768h */ case    0:  		/* mr R3, R31 */
		/* 8226B768h case    0:*/		regs.R3 = regs.R31;
		/* 8226B768h case    0:*/		return 0x8226B76C;
		  /* 8226B76Ch */ case    1:  		/* bl -7564 */
		/* 8226B76Ch case    1:*/		regs.LR = 0x8226B770; return 0x822699E0;
		/* 8226B76Ch case    1:*/		return 0x8226B770;
		  /* 8226B770h */ case    2:  		/* b 1332 */
		/* 8226B770h case    2:*/		return 0x8226BCA4;
		/* 8226B770h case    2:*/		return 0x8226B774;
	}
	return 0x8226B774;
} // Block from 8226B768h-8226B774h (3 instructions)

//////////////////////////////////////////////////////
// Block at 8226B774h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B774( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B774) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B774);
		  /* 8226B774h */ case    0:  		/* lwz R11, <#[R29 + 4]> */
		/* 8226B774h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 8226B774h case    0:*/		return 0x8226B778;
		  /* 8226B778h */ case    1:  		/* li R27, 0 */
		/* 8226B778h case    1:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 8226B778h case    1:*/		return 0x8226B77C;
		  /* 8226B77Ch */ case    2:  		/* rlwinm. R11, R11, 2, 31, 31 */
		/* 8226B77Ch case    2:*/		cpu::op::rlwinm<1,2,31,31>(regs,&regs.R11,regs.R11);
		/* 8226B77Ch case    2:*/		return 0x8226B780;
		  /* 8226B780h */ case    3:  		/* stb R27, <#[R1 + 112]> */
		/* 8226B780h case    3:*/		cpu::mem::store8( regs, regs.R27, (uint32)(regs.R1 + 0x00000070) );
		/* 8226B780h case    3:*/		return 0x8226B784;
		  /* 8226B784h */ case    4:  		/* mr R26, R27 */
		/* 8226B784h case    4:*/		regs.R26 = regs.R27;
		/* 8226B784h case    4:*/		return 0x8226B788;
		  /* 8226B788h */ case    5:  		/* mr R25, R11 */
		/* 8226B788h case    5:*/		regs.R25 = regs.R11;
		/* 8226B788h case    5:*/		return 0x8226B78C;
		  /* 8226B78Ch */ case    6:  		/* bc 4, CR0_EQ, 68 */
		/* 8226B78Ch case    6:*/		if ( !regs.CR[0].eq ) { return 0x8226B7D0;  }
		/* 8226B78Ch case    6:*/		return 0x8226B790;
		  /* 8226B790h */ case    7:  		/* lwz R11, <#[R31 + 8]> */
		/* 8226B790h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 8226B790h case    7:*/		return 0x8226B794;
		  /* 8226B794h */ case    8:  		/* rlwinm. R11, R11, 0, 30, 30 */
		/* 8226B794h case    8:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R11,regs.R11);
		/* 8226B794h case    8:*/		return 0x8226B798;
		  /* 8226B798h */ case    9:  		/* bc 4, CR0_EQ, 56 */
		/* 8226B798h case    9:*/		if ( !regs.CR[0].eq ) { return 0x8226B7D0;  }
		/* 8226B798h case    9:*/		return 0x8226B79C;
		  /* 8226B79Ch */ case   10:  		/* lwz R11, <#[R31 + 8224]> */
		/* 8226B79Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00002020) );
		/* 8226B79Ch case   10:*/		return 0x8226B7A0;
		  /* 8226B7A0h */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 8226B7A0h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 8226B7A0h case   11:*/		return 0x8226B7A4;
		  /* 8226B7A4h */ case   12:  		/* bc 12, CR6_EQ, 44 */
		/* 8226B7A4h case   12:*/		if ( regs.CR[6].eq ) { return 0x8226B7D0;  }
		/* 8226B7A4h case   12:*/		return 0x8226B7A8;
		  /* 8226B7A8h */ case   13:  		/* li R7, 1 */
		/* 8226B7A8h case   13:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 8226B7A8h case   13:*/		return 0x8226B7AC;
		  /* 8226B7ACh */ case   14:  		/* lwz R3, <#[R31 + 8228]> */
		/* 8226B7ACh case   14:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00002024) );
		/* 8226B7ACh case   14:*/		return 0x8226B7B0;
		  /* 8226B7B0h */ case   15:  		/* addi R6, R1, 112 */
		/* 8226B7B0h case   15:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x70);
		/* 8226B7B0h case   15:*/		return 0x8226B7B4;
		  /* 8226B7B4h */ case   16:  		/* mtspr CTR, R11 */
		/* 8226B7B4h case   16:*/		regs.CTR = regs.R11;
		/* 8226B7B4h case   16:*/		return 0x8226B7B8;
		  /* 8226B7B8h */ case   17:  		/* mr R5, R30 */
		/* 8226B7B8h case   17:*/		regs.R5 = regs.R30;
		/* 8226B7B8h case   17:*/		return 0x8226B7BC;
		  /* 8226B7BCh */ case   18:  		/* li R4, 3 */
		/* 8226B7BCh case   18:*/		cpu::op::li<0>(regs,&regs.R4,0x3);
		/* 8226B7BCh case   18:*/		return 0x8226B7C0;
		  /* 8226B7C0h */ case   19:  		/* bcctrl 20, CR0_LT */
		/* 8226B7C0h case   19:*/		if ( 1 ) { regs.LR = 0x8226B7C4; return (uint32)regs.CTR; }
		/* 8226B7C0h case   19:*/		return 0x8226B7C4;
		  /* 8226B7C4h */ case   20:  		/* cmpwi CR0, R3, 0 */
		/* 8226B7C4h case   20:*/		cpu::op::cmpwi<0>(regs,regs.R3,0x00000000);
		/* 8226B7C4h case   20:*/		return 0x8226B7C8;
		  /* 8226B7C8h */ case   21:  		/* bc 4, CR0_EQ, 8 */
		/* 8226B7C8h case   21:*/		if ( !regs.CR[0].eq ) { return 0x8226B7D0;  }
		/* 8226B7C8h case   21:*/		return 0x8226B7CC;
		  /* 8226B7CCh */ case   22:  		/* li R26, 1 */
		/* 8226B7CCh case   22:*/		cpu::op::li<0>(regs,&regs.R26,0x1);
		/* 8226B7CCh case   22:*/		return 0x8226B7D0;
	}
	return 0x8226B7D0;
} // Block from 8226B774h-8226B7D0h (23 instructions)

//////////////////////////////////////////////////////
// Block at 8226B7D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B7D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B7D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B7D0);
		  /* 8226B7D0h */ case    0:  		/* cmplwi CR6, R25, 0 */
		/* 8226B7D0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 8226B7D0h case    0:*/		return 0x8226B7D4;
		  /* 8226B7D4h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 8226B7D4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x8226B7E4;  }
		/* 8226B7D4h case    1:*/		return 0x8226B7D8;
		  /* 8226B7D8h */ case    2:  		/* rlwinm. R11, R26, 0, 24, 31 */
		/* 8226B7D8h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R26);
		/* 8226B7D8h case    2:*/		return 0x8226B7DC;
		  /* 8226B7DCh */ case    3:  		/* li R11, 1 */
		/* 8226B7DCh case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 8226B7DCh case    3:*/		return 0x8226B7E0;
		  /* 8226B7E0h */ case    4:  		/* bc 12, CR0_EQ, 8 */
		/* 8226B7E0h case    4:*/		if ( regs.CR[0].eq ) { return 0x8226B7E8;  }
		/* 8226B7E0h case    4:*/		return 0x8226B7E4;
	}
	return 0x8226B7E4;
} // Block from 8226B7D0h-8226B7E4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8226B7E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B7E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B7E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B7E4);
		  /* 8226B7E4h */ case    0:  		/* mr R11, R27 */
		/* 8226B7E4h case    0:*/		regs.R11 = regs.R27;
		/* 8226B7E4h case    0:*/		return 0x8226B7E8;
	}
	return 0x8226B7E8;
} // Block from 8226B7E4h-8226B7E8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 8226B7E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B7E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B7E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B7E8);
		  /* 8226B7E8h */ case    0:  		/* rlwinm R30, R11, 0, 24, 31 */
		/* 8226B7E8h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R30,regs.R11);
		/* 8226B7E8h case    0:*/		return 0x8226B7EC;
		  /* 8226B7ECh */ case    1:  		/* cmplwi CR6, R25, 0 */
		/* 8226B7ECh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 8226B7ECh case    1:*/		return 0x8226B7F0;
		  /* 8226B7F0h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 8226B7F0h case    2:*/		if ( regs.CR[6].eq ) { return 0x8226B800;  }
		/* 8226B7F0h case    2:*/		return 0x8226B7F4;
		  /* 8226B7F4h */ case    3:  		/* lis R11, -32255 */
		/* 8226B7F4h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8226B7F4h case    3:*/		return 0x8226B7F8;
		  /* 8226B7F8h */ case    4:  		/* addi R4, R11, 13248 */
		/* 8226B7F8h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x33C0);
		/* 8226B7F8h case    4:*/		return 0x8226B7FC;
		  /* 8226B7FCh */ case    5:  		/* b 32 */
		/* 8226B7FCh case    5:*/		return 0x8226B81C;
		/* 8226B7FCh case    5:*/		return 0x8226B800;
	}
	return 0x8226B800;
} // Block from 8226B7E8h-8226B800h (6 instructions)

//////////////////////////////////////////////////////
// Block at 8226B800h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B800( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B800) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B800);
		  /* 8226B800h */ case    0:  		/* rlwinm. R11, R26, 0, 24, 31 */
		/* 8226B800h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R26);
		/* 8226B800h case    0:*/		return 0x8226B804;
		  /* 8226B804h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 8226B804h case    1:*/		if ( regs.CR[0].eq ) { return 0x8226B814;  }
		/* 8226B804h case    1:*/		return 0x8226B808;
		  /* 8226B808h */ case    2:  		/* lis R11, -32255 */
		/* 8226B808h case    2:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8226B808h case    2:*/		return 0x8226B80C;
		  /* 8226B80Ch */ case    3:  		/* addi R4, R11, 13240 */
		/* 8226B80Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x33B8);
		/* 8226B80Ch case    3:*/		return 0x8226B810;
		  /* 8226B810h */ case    4:  		/* b 12 */
		/* 8226B810h case    4:*/		return 0x8226B81C;
		/* 8226B810h case    4:*/		return 0x8226B814;
	}
	return 0x8226B814;
} // Block from 8226B800h-8226B814h (5 instructions)

//////////////////////////////////////////////////////
// Block at 8226B814h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B814( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B814) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B814);
		  /* 8226B814h */ case    0:  		/* lis R11, -32255 */
		/* 8226B814h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8226B814h case    0:*/		return 0x8226B818;
		  /* 8226B818h */ case    1:  		/* addi R4, R11, 13260 */
		/* 8226B818h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x33CC);
		/* 8226B818h case    1:*/		return 0x8226B81C;
	}
	return 0x8226B81C;
} // Block from 8226B814h-8226B81Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226B81Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B81C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B81C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B81C);
		  /* 8226B81Ch */ case    0:  		/* li R5, 0 */
		/* 8226B81Ch case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 8226B81Ch case    0:*/		return 0x8226B820;
		  /* 8226B820h */ case    1:  		/* mr R3, R31 */
		/* 8226B820h case    1:*/		regs.R3 = regs.R31;
		/* 8226B820h case    1:*/		return 0x8226B824;
		  /* 8226B824h */ case    2:  		/* bl -7396 */
		/* 8226B824h case    2:*/		regs.LR = 0x8226B828; return 0x82269B40;
		/* 8226B824h case    2:*/		return 0x8226B828;
		  /* 8226B828h */ case    3:  		/* lis R11, -32255 */
		/* 8226B828h case    3:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8201);
		/* 8226B828h case    3:*/		return 0x8226B82C;
		  /* 8226B82Ch */ case    4:  		/* mr R3, R31 */
		/* 8226B82Ch case    4:*/		regs.R3 = regs.R31;
		/* 8226B82Ch case    4:*/		return 0x8226B830;
		  /* 8226B830h */ case    5:  		/* addi R4, R11, -15864 */
		/* 8226B830h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFC208);
		/* 8226B830h case    5:*/		return 0x8226B834;
		  /* 8226B834h */ case    6:  		/* bl -7764 */
		/* 8226B834h case    6:*/		regs.LR = 0x8226B838; return 0x822699E0;
		/* 8226B834h case    6:*/		return 0x8226B838;
		  /* 8226B838h */ case    7:  		/* lwz R11, <#[R29]> */
		/* 8226B838h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8226B838h case    7:*/		return 0x8226B83C;
		  /* 8226B83Ch */ case    8:  		/* mr R3, R31 */
		/* 8226B83Ch case    8:*/		regs.R3 = regs.R31;
		/* 8226B83Ch case    8:*/		return 0x8226B840;
		  /* 8226B840h */ case    9:  		/* rlwinm. R10, R11, 0, 13, 13 */
		/* 8226B840h case    9:*/		cpu::op::rlwinm<1,0,13,13>(regs,&regs.R10,regs.R11);
		/* 8226B840h case    9:*/		return 0x8226B844;
		  /* 8226B844h */ case   10:  		/* rlwinm R5, R11, 20, 26, 31 */
		/* 8226B844h case   10:*/		cpu::op::rlwinm<0,20,26,31>(regs,&regs.R5,regs.R11);
		/* 8226B844h case   10:*/		return 0x8226B848;
		  /* 8226B848h */ case   11:  		/* bc 12, CR0_EQ, 16 */
		/* 8226B848h case   11:*/		if ( regs.CR[0].eq ) { return 0x8226B858;  }
		/* 8226B848h case   11:*/		return 0x8226B84C;
		  /* 8226B84Ch */ case   12:  		/* lis R11, -32252 */
		/* 8226B84Ch case   12:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8226B84Ch case   12:*/		return 0x8226B850;
		  /* 8226B850h */ case   13:  		/* addi R4, R11, -23632 */
		/* 8226B850h case   13:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFA3B0);
		/* 8226B850h case   13:*/		return 0x8226B854;
		  /* 8226B854h */ case   14:  		/* b 12 */
		/* 8226B854h case   14:*/		return 0x8226B860;
		/* 8226B854h case   14:*/		return 0x8226B858;
	}
	return 0x8226B858;
} // Block from 8226B81Ch-8226B858h (15 instructions)

//////////////////////////////////////////////////////
// Block at 8226B858h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B858( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B858) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B858);
		  /* 8226B858h */ case    0:  		/* lis R11, -32252 */
		/* 8226B858h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8226B858h case    0:*/		return 0x8226B85C;
		  /* 8226B85Ch */ case    1:  		/* addi R4, R11, -23636 */
		/* 8226B85Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFA3AC);
		/* 8226B85Ch case    1:*/		return 0x8226B860;
	}
	return 0x8226B860;
} // Block from 8226B858h-8226B860h (2 instructions)

//////////////////////////////////////////////////////
// Block at 8226B860h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B860( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B860) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B860);
		  /* 8226B860h */ case    0:  		/* bl -7808 */
		/* 8226B860h case    0:*/		regs.LR = 0x8226B864; return 0x822699E0;
		/* 8226B860h case    0:*/		return 0x8226B864;
		  /* 8226B864h */ case    1:  		/* lwz R11, <#[R29 + 4]> */
		/* 8226B864h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 8226B864h case    1:*/		return 0x8226B868;
		  /* 8226B868h */ case    2:  		/* lis R10, -32216 */
		/* 8226B868h case    2:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8228);
		/* 8226B868h case    2:*/		return 0x8226B86C;
		  /* 8226B86Ch */ case    3:  		/* rlwinm. R9, R11, 0, 29, 31 */
		/* 8226B86Ch case    3:*/		cpu::op::rlwinm<1,0,29,31>(regs,&regs.R9,regs.R11);
		/* 8226B86Ch case    3:*/		return 0x8226B870;
		  /* 8226B870h */ case    4:  		/* addi R28, R10, 27664 */
		/* 8226B870h case    4:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R10,0x6C10);
		/* 8226B870h case    4:*/		return 0x8226B874;
		  /* 8226B874h */ case    5:  		/* bc 4, CR0_EQ, 40 */
		/* 8226B874h case    5:*/		if ( !regs.CR[0].eq ) { return 0x8226B89C;  }
		/* 8226B874h case    5:*/		return 0x8226B878;
		  /* 8226B878h */ case    6:  		/* rlwinm R10, R11, 0, 26, 28 */
		/* 8226B878h case    6:*/		cpu::op::rlwinm<0,0,26,28>(regs,&regs.R10,regs.R11);
		/* 8226B878h case    6:*/		return 0x8226B87C;
		  /* 8226B87Ch */ case    7:  		/* cmplwi CR6, R10, 8 */
		/* 8226B87Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000008);
		/* 8226B87Ch case    7:*/		return 0x8226B880;
		  /* 8226B880h */ case    8:  		/* bc 4, CR6_EQ, 28 */
		/* 8226B880h case    8:*/		if ( !regs.CR[6].eq ) { return 0x8226B89C;  }
		/* 8226B880h case    8:*/		return 0x8226B884;
		  /* 8226B884h */ case    9:  		/* rlwinm R10, R11, 0, 23, 25 */
		/* 8226B884h case    9:*/		cpu::op::rlwinm<0,0,23,25>(regs,&regs.R10,regs.R11);
		/* 8226B884h case    9:*/		return 0x8226B888;
		  /* 8226B888h */ case   10:  		/* cmplwi CR6, R10, 128 */
		/* 8226B888h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000080);
		/* 8226B888h case   10:*/		return 0x8226B88C;
		  /* 8226B88Ch */ case   11:  		/* bc 4, CR6_EQ, 16 */
		/* 8226B88Ch case   11:*/		if ( !regs.CR[6].eq ) { return 0x8226B89C;  }
		/* 8226B88Ch case   11:*/		return 0x8226B890;
		  /* 8226B890h */ case   12:  		/* rlwinm R11, R11, 0, 20, 22 */
		/* 8226B890h case   12:*/		cpu::op::rlwinm<0,0,20,22>(regs,&regs.R11,regs.R11);
		/* 8226B890h case   12:*/		return 0x8226B894;
		  /* 8226B894h */ case   13:  		/* cmplwi CR6, R11, 1536 */
		/* 8226B894h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000600);
		/* 8226B894h case   13:*/		return 0x8226B898;
		  /* 8226B898h */ case   14:  		/* bc 12, CR6_EQ, 140 */
		/* 8226B898h case   14:*/		if ( regs.CR[6].eq ) { return 0x8226B924;  }
		/* 8226B898h case   14:*/		return 0x8226B89C;
	}
	return 0x8226B89C;
} // Block from 8226B860h-8226B89Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 8226B89Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B89C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B89C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B89C);
		  /* 8226B89Ch */ case    0:  		/* lis R11, -32256 */
		/* 8226B89Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8226B89Ch case    0:*/		return 0x8226B8A0;
		  /* 8226B8A0h */ case    1:  		/* mr R3, R31 */
		/* 8226B8A0h case    1:*/		regs.R3 = regs.R31;
		/* 8226B8A0h case    1:*/		return 0x8226B8A4;
		  /* 8226B8A4h */ case    2:  		/* addi R4, R11, 20592 */
		/* 8226B8A4h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x5070);
		/* 8226B8A4h case    2:*/		return 0x8226B8A8;
		  /* 8226B8A8h */ case    3:  		/* bl -7880 */
		/* 8226B8A8h case    3:*/		regs.LR = 0x8226B8AC; return 0x822699E0;
		/* 8226B8A8h case    3:*/		return 0x8226B8AC;
		  /* 8226B8ACh */ case    4:  		/* lis R11, -32253 */
		/* 8226B8ACh case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8203);
		/* 8226B8ACh case    4:*/		return 0x8226B8B0;
		  /* 8226B8B0h */ case    5:  		/* mr R3, R31 */
		/* 8226B8B0h case    5:*/		regs.R3 = regs.R31;
		/* 8226B8B0h case    5:*/		return 0x8226B8B4;
		  /* 8226B8B4h */ case    6:  		/* addi R24, R11, 25796 */
		/* 8226B8B4h case    6:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R11,0x64C4);
		/* 8226B8B4h case    6:*/		return 0x8226B8B8;
		  /* 8226B8B8h */ case    7:  		/* mr R4, R24 */
		/* 8226B8B8h case    7:*/		regs.R4 = regs.R24;
		/* 8226B8B8h case    7:*/		return 0x8226B8BC;
		  /* 8226B8BCh */ case    8:  		/* lwz R11, <#[R29 + 4]> */
		/* 8226B8BCh case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 8226B8BCh case    8:*/		return 0x8226B8C0;
		  /* 8226B8C0h */ case    9:  		/* rlwinm R11, R11, 0, 29, 31 */
		/* 8226B8C0h case    9:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R11,regs.R11);
		/* 8226B8C0h case    9:*/		return 0x8226B8C4;
		  /* 8226B8C4h */ case   10:  		/* lbzx R11, <#[R11 + R28]> */
		/* 8226B8C4h case   10:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 8226B8C4h case   10:*/		return 0x8226B8C8;
		  /* 8226B8C8h */ case   11:  		/* extsb R5, R11 */
		/* 8226B8C8h case   11:*/		cpu::op::extsb<0>(regs,&regs.R5,regs.R11);
		/* 8226B8C8h case   11:*/		return 0x8226B8CC;
		  /* 8226B8CCh */ case   12:  		/* bl -7916 */
		/* 8226B8CCh case   12:*/		regs.LR = 0x8226B8D0; return 0x822699E0;
		/* 8226B8CCh case   12:*/		return 0x8226B8D0;
		  /* 8226B8D0h */ case   13:  		/* lwz R11, <#[R29 + 4]> */
		/* 8226B8D0h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 8226B8D0h case   13:*/		return 0x8226B8D4;
		  /* 8226B8D4h */ case   14:  		/* mr R4, R24 */
		/* 8226B8D4h case   14:*/		regs.R4 = regs.R24;
		/* 8226B8D4h case   14:*/		return 0x8226B8D8;
		  /* 8226B8D8h */ case   15:  		/* rlwinm R11, R11, 29, 29, 31 */
		/* 8226B8D8h case   15:*/		cpu::op::rlwinm<0,29,29,31>(regs,&regs.R11,regs.R11);
		/* 8226B8D8h case   15:*/		return 0x8226B8DC;
		  /* 8226B8DCh */ case   16:  		/* mr R3, R31 */
		/* 8226B8DCh case   16:*/		regs.R3 = regs.R31;
		/* 8226B8DCh case   16:*/		return 0x8226B8E0;
		  /* 8226B8E0h */ case   17:  		/* lbzx R11, <#[R11 + R28]> */
		/* 8226B8E0h case   17:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 8226B8E0h case   17:*/		return 0x8226B8E4;
		  /* 8226B8E4h */ case   18:  		/* extsb R5, R11 */
		/* 8226B8E4h case   18:*/		cpu::op::extsb<0>(regs,&regs.R5,regs.R11);
		/* 8226B8E4h case   18:*/		return 0x8226B8E8;
		  /* 8226B8E8h */ case   19:  		/* bl -7944 */
		/* 8226B8E8h case   19:*/		regs.LR = 0x8226B8EC; return 0x822699E0;
		/* 8226B8E8h case   19:*/		return 0x8226B8EC;
		  /* 8226B8ECh */ case   20:  		/* lwz R11, <#[R29 + 4]> */
		/* 8226B8ECh case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 8226B8ECh case   20:*/		return 0x8226B8F0;
		  /* 8226B8F0h */ case   21:  		/* mr R4, R24 */
		/* 8226B8F0h case   21:*/		regs.R4 = regs.R24;
		/* 8226B8F0h case   21:*/		return 0x8226B8F4;
		  /* 8226B8F4h */ case   22:  		/* rlwinm R11, R11, 26, 29, 31 */
		/* 8226B8F4h case   22:*/		cpu::op::rlwinm<0,26,29,31>(regs,&regs.R11,regs.R11);
		/* 8226B8F4h case   22:*/		return 0x8226B8F8;
		  /* 8226B8F8h */ case   23:  		/* mr R3, R31 */
		/* 8226B8F8h case   23:*/		regs.R3 = regs.R31;
		/* 8226B8F8h case   23:*/		return 0x8226B8FC;
		  /* 8226B8FCh */ case   24:  		/* lbzx R11, <#[R11 + R28]> */
		/* 8226B8FCh case   24:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 8226B8FCh case   24:*/		return 0x8226B900;
		  /* 8226B900h */ case   25:  		/* extsb R5, R11 */
		/* 8226B900h case   25:*/		cpu::op::extsb<0>(regs,&regs.R5,regs.R11);
		/* 8226B900h case   25:*/		return 0x8226B904;
		  /* 8226B904h */ case   26:  		/* bl -7972 */
		/* 8226B904h case   26:*/		regs.LR = 0x8226B908; return 0x822699E0;
		/* 8226B904h case   26:*/		return 0x8226B908;
		  /* 8226B908h */ case   27:  		/* lwz R11, <#[R29 + 4]> */
		/* 8226B908h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 8226B908h case   27:*/		return 0x8226B90C;
		  /* 8226B90Ch */ case   28:  		/* mr R4, R24 */
		/* 8226B90Ch case   28:*/		regs.R4 = regs.R24;
		/* 8226B90Ch case   28:*/		return 0x8226B910;
		  /* 8226B910h */ case   29:  		/* rlwinm R11, R11, 23, 29, 31 */
		/* 8226B910h case   29:*/		cpu::op::rlwinm<0,23,29,31>(regs,&regs.R11,regs.R11);
		/* 8226B910h case   29:*/		return 0x8226B914;
		  /* 8226B914h */ case   30:  		/* mr R3, R31 */
		/* 8226B914h case   30:*/		regs.R3 = regs.R31;
		/* 8226B914h case   30:*/		return 0x8226B918;
		  /* 8226B918h */ case   31:  		/* lbzx R11, <#[R11 + R28]> */
		/* 8226B918h case   31:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 8226B918h case   31:*/		return 0x8226B91C;
		  /* 8226B91Ch */ case   32:  		/* extsb R5, R11 */
		/* 8226B91Ch case   32:*/		cpu::op::extsb<0>(regs,&regs.R5,regs.R11);
		/* 8226B91Ch case   32:*/		return 0x8226B920;
		  /* 8226B920h */ case   33:  		/* bl -8000 */
		/* 8226B920h case   33:*/		regs.LR = 0x8226B924; return 0x822699E0;
		/* 8226B920h case   33:*/		return 0x8226B924;
	}
	return 0x8226B924;
} // Block from 8226B89Ch-8226B924h (34 instructions)

//////////////////////////////////////////////////////
// Block at 8226B924h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B924( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B924) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B924);
		  /* 8226B924h */ case    0:  		/* rlwinm. R24, R30, 0, 24, 31 */
		/* 8226B924h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R24,regs.R30);
		/* 8226B924h case    0:*/		return 0x8226B928;
		  /* 8226B928h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 8226B928h case    1:*/		if ( !regs.CR[0].eq ) { return 0x8226B934;  }
		/* 8226B928h case    1:*/		return 0x8226B92C;
		  /* 8226B92Ch */ case    2:  		/* rlwinm. R11, R26, 0, 24, 31 */
		/* 8226B92Ch case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R26);
		/* 8226B92Ch case    2:*/		return 0x8226B930;
		  /* 8226B930h */ case    3:  		/* bc 12, CR0_EQ, 112 */
		/* 8226B930h case    3:*/		if ( regs.CR[0].eq ) { return 0x8226B9A0;  }
		/* 8226B930h case    3:*/		return 0x8226B934;
	}
	return 0x8226B934;
} // Block from 8226B924h-8226B934h (4 instructions)

//////////////////////////////////////////////////////
// Block at 8226B934h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B934( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B934) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B934);
		  /* 8226B934h */ case    0:  		/* lis R11, -32256 */
		/* 8226B934h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 8226B934h case    0:*/		return 0x8226B938;
		  /* 8226B938h */ case    1:  		/* mr R3, R31 */
		/* 8226B938h case    1:*/		regs.R3 = regs.R31;
		/* 8226B938h case    1:*/		return 0x8226B93C;
		  /* 8226B93Ch */ case    2:  		/* addi R4, R11, 17860 */
		/* 8226B93Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0x45C4);
		/* 8226B93Ch case    2:*/		return 0x8226B940;
		  /* 8226B940h */ case    3:  		/* bl -8032 */
		/* 8226B940h case    3:*/		regs.LR = 0x8226B944; return 0x822699E0;
		/* 8226B940h case    3:*/		return 0x8226B944;
		  /* 8226B944h */ case    4:  		/* li R11, 4 */
		/* 8226B944h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x4);
		/* 8226B944h case    4:*/		return 0x8226B948;
		  /* 8226B948h */ case    5:  		/* li R10, 0 */
		/* 8226B948h case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 8226B948h case    5:*/		return 0x8226B94C;
		  /* 8226B94Ch */ case    6:  		/* stb R27, <#[R1 + 95]> */
		/* 8226B94Ch case    6:*/		cpu::mem::store8( regs, regs.R27, (uint32)(regs.R1 + 0x0000005F) );
		/* 8226B94Ch case    6:*/		return 0x8226B950;
		  /* 8226B950h */ case    7:  		/* stw R11, <#[R1 + 84]> */
		/* 8226B950h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 8226B950h case    7:*/		return 0x8226B954;
		  /* 8226B954h */ case    8:  		/* li R9, 0 */
		/* 8226B954h case    8:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 8226B954h case    8:*/		return 0x8226B958;
		  /* 8226B958h */ case    9:  		/* li R8, 0 */
		/* 8226B958h case    9:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 8226B958h case    9:*/		return 0x8226B95C;
		  /* 8226B95Ch */ case   10:  		/* li R7, 0 */
		/* 8226B95Ch case   10:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 8226B95Ch case   10:*/		return 0x8226B960;
		  /* 8226B960h */ case   11:  		/* li R6, 0 */
		/* 8226B960h case   11:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 8226B960h case   11:*/		return 0x8226B964;
		  /* 8226B964h */ case   12:  		/* li R4, 1 */
		/* 8226B964h case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 8226B964h case   12:*/		return 0x8226B968;
		  /* 8226B968h */ case   13:  		/* mr R3, R31 */
		/* 8226B968h case   13:*/		regs.R3 = regs.R31;
		/* 8226B968h case   13:*/		return 0x8226B96C;
		  /* 8226B96Ch */ case   14:  		/* lwz R11, <#[R29]> */
		/* 8226B96Ch case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8226B96Ch case   14:*/		return 0x8226B970;
		  /* 8226B970h */ case   15:  		/* rlwinm R5, R11, 27, 25, 25 */
		/* 8226B970h case   15:*/		cpu::op::rlwinm<0,27,25,25>(regs,&regs.R5,regs.R11);
		/* 8226B970h case   15:*/		return 0x8226B974;
		  /* 8226B974h */ case   16:  		/* rlwinm R11, R11, 27, 26, 31 */
		/* 8226B974h case   16:*/		cpu::op::rlwinm<0,27,26,31>(regs,&regs.R11,regs.R11);
		/* 8226B974h case   16:*/		return 0x8226B978;
		  /* 8226B978h */ case   17:  		/* or R5, R5, R11 */
		/* 8226B978h case   17:*/		cpu::op::or<0>(regs,&regs.R5,regs.R5,regs.R11);
		/* 8226B978h case   17:*/		return 0x8226B97C;
		  /* 8226B97Ch */ case   18:  		/* bl -6484 */
		/* 8226B97Ch case   18:*/		regs.LR = 0x8226B980; return 0x8226A028;
		/* 8226B97Ch case   18:*/		return 0x8226B980;
		  /* 8226B980h */ case   19:  		/* lis R11, -32252 */
		/* 8226B980h case   19:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 8226B980h case   19:*/		return 0x8226B984;
		  /* 8226B984h */ case   20:  		/* mr R3, R31 */
		/* 8226B984h case   20:*/		regs.R3 = regs.R31;
		/* 8226B984h case   20:*/		return 0x8226B988;
		  /* 8226B988h */ case   21:  		/* addi R4, R11, -23304 */
		/* 8226B988h case   21:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFA4F8);
		/* 8226B988h case   21:*/		return 0x8226B98C;
		  /* 8226B98Ch */ case   22:  		/* lwz R11, <#[R29]> */
		/* 8226B98Ch case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8226B98Ch case   22:*/		return 0x8226B990;
		  /* 8226B990h */ case   23:  		/* rlwinm R11, R11, 2, 30, 31 */
		/* 8226B990h case   23:*/		cpu::op::rlwinm<0,2,30,31>(regs,&regs.R11,regs.R11);
		/* 8226B990h case   23:*/		return 0x8226B994;
		  /* 8226B994h */ case   24:  		/* lbzx R11, <#[R11 + R28]> */
		/* 8226B994h case   24:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 8226B994h case   24:*/		return 0x8226B998;
		  /* 8226B998h */ case   25:  		/* extsb R5, R11 */
		/* 8226B998h case   25:*/		cpu::op::extsb<0>(regs,&regs.R5,regs.R11);
		/* 8226B998h case   25:*/		return 0x8226B99C;
		  /* 8226B99Ch */ case   26:  		/* bl -8124 */
		/* 8226B99Ch case   26:*/		regs.LR = 0x8226B9A0; return 0x822699E0;
		/* 8226B99Ch case   26:*/		return 0x8226B9A0;
	}
	return 0x8226B9A0;
} // Block from 8226B934h-8226B9A0h (27 instructions)

//////////////////////////////////////////////////////
// Block at 8226B9A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block8226B9A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x8226B9A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x8226B9A0);
		  /* 8226B9A0h */ case    0:  		/* cmplwi CR6, R24, 0 */
		/* 8226B9A0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 8226B9A0h case    0:*/		return 0x8226B9A4;
		  /* 8226B9A4h */ case    1:  		/* bc 12, CR6_EQ, 44 */
		/* 8226B9A4h case    1:*/		if ( regs.CR[6].eq ) { return 0x8226B9D0;  }
		/* 8226B9A4h case    1:*/		return 0x8226B9A8;
		  /* 8226B9A8h */ case    2:  		/* lwz R11, <#[R29]> */
		/* 8226B9A8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 8226B9A8h case    2:*/		return 0x8226B9AC;
		  /* 8226B9ACh */ case    3:  		/* lis R10, -32251 */
		/* 8226B9ACh case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8205);
		/* 8226B9ACh case    3:*/		return 0x8226B9B0;
		  /* 8226B9B0h */ case    4:  		/* mr R3, R31 */
		/* 8226B9B0h case    4:*/		regs.R3 = regs.R31;
		/* 8226B9B0h case    4:*/		return 0x8226B9B4;
		  /* 8226B9B4h */ case    5:  		/* rlwinm R9, R11, 12, 27, 31 */
		/* 8226B9B4h case    5:*/		cpu::op::rlwinm<0,12,27,31>(regs,&regs.R9,regs.R11);
		/* 8226B9B4h case    5:*/		return 0x8226B9B8;
		  /* 8226B9B8h */ case    6:  		/* rlwinm R11, R11, 7, 30, 31 */
		/* 8226B9B8h case    6:*/		cpu::op::rlwinm<0,7,30,31>(regs,&regs.R11,regs.R11);
		/* 8226B9B8h case    6:*/		return 0x8226B9BC;
		  /* 8226B9BCh */ case    7:  		/* mulli R9, R9, 3 */
		/* 8226B9BCh case    7:*/		cpu::op::mulli<0>(regs,&regs.R9,regs.R9,0x3);
		/* 8226B9BCh case    7:*/		return 0x8226B9C0;
		  /* 8226B9C0h */ case    8:  		/* subfic R9, R9, 95 */
		/* 8226B9C0h case    8:*/		cpu::op::subfic<0>(regs,&regs.R9,regs.R9,0x5F);
		/* 8226B9C0h case    8:*/		return 0x8226B9C4;
		  /* 8226B9C4h */ case    9:  		/* addi R4, R10, -16064 */
		/* 8226B9C4h case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R10,0xFFFFC140);
		/* 8226B9C4h case    9:*/		return 0x8226B9C8;
		  /* 8226B9C8h */ case   10:  		/* subf R5, R11, R9 */
		/* 8226B9C8h case   10:*/		cpu::op::subf<0>(regs,&regs.R5,regs.R11,regs.R9);
		/* 8226B9C8h case   10:*/		return 0x8226B9CC;
		  /* 8226B9CCh */ case   11:  		/* bl -8172 */
		/* 8226B9CCh case   11:*/		regs.LR = 0x8226B9D0; return 0x822699E0;
		/* 8226B9CCh case   11:*/		return 0x8226B9D0;
	}
	return 0x8226B9D0;
} // Block from 8226B9A0h-8226B9D0h (12 instructions)

