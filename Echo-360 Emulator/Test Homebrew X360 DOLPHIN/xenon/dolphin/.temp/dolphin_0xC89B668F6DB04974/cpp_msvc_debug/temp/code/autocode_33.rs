#include "C:\Users\xdfah\Downloads\recompiler\Echo-360\Echo-360 0.0.1\../../dev/src/xenon_launcher/xenonCPU.h"

//////////////////////////////////////////////////////
// Block at 821B60ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B60EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B60EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B60EC);
		  /* 821B60ECh */ case    0:  		/* lwz R11, <#[R14 + 44]> */
		/* 821B60ECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x0000002C) );
		/* 821B60ECh case    0:*/		return 0x821B60F0;
		  /* 821B60F0h */ case    1:  		/* rlwinm. R10, R11, 0, 10, 10 */
		/* 821B60F0h case    1:*/		cpu::op::rlwinm<1,0,10,10>(regs,&regs.R10,regs.R11);
		/* 821B60F0h case    1:*/		return 0x821B60F4;
		  /* 821B60F4h */ case    2:  		/* bc 4, CR0_EQ, 20 */
		/* 821B60F4h case    2:*/		if ( !regs.CR[0].eq ) { return 0x821B6108;  }
		/* 821B60F4h case    2:*/		return 0x821B60F8;
		  /* 821B60F8h */ case    3:  		/* oris R11, R11, 32 */
		/* 821B60F8h case    3:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x20);
		/* 821B60F8h case    3:*/		return 0x821B60FC;
		  /* 821B60FCh */ case    4:  		/* mr R3, R14 */
		/* 821B60FCh case    4:*/		regs.R3 = regs.R14;
		/* 821B60FCh case    4:*/		return 0x821B6100;
		  /* 821B6100h */ case    5:  		/* stw R11, <#[R14 + 44]> */
		/* 821B6100h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R14 + 0x0000002C) );
		/* 821B6100h case    5:*/		return 0x821B6104;
		  /* 821B6104h */ case    6:  		/* bl -226444 */
		/* 821B6104h case    6:*/		regs.LR = 0x821B6108; return 0x8217EC78;
		/* 821B6104h case    6:*/		return 0x821B6108;
	}
	return 0x821B6108;
} // Block from 821B60ECh-821B6108h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821B6108h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6108( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6108) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6108);
		  /* 821B6108h */ case    0:  		/* lwz R30, <#[R1 + 100]> */
		/* 821B6108h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000064) );
		/* 821B6108h case    0:*/		return 0x821B610C;
		  /* 821B610Ch */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 821B610Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821B610Ch case    1:*/		return 0x821B6110;
		  /* 821B6110h */ case    2:  		/* bc 12, CR6_EQ, 136 */
		/* 821B6110h case    2:*/		if ( regs.CR[6].eq ) { return 0x821B6198;  }
		/* 821B6110h case    2:*/		return 0x821B6114;
		  /* 821B6114h */ case    3:  		/* lwz R11, <#[R30 + 4]> */
		/* 821B6114h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 821B6114h case    3:*/		return 0x821B6118;
		  /* 821B6118h */ case    4:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821B6118h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821B6118h case    4:*/		return 0x821B611C;
		  /* 821B611Ch */ case    5:  		/* bc 4, CR0_EQ, 124 */
		/* 821B611Ch case    5:*/		if ( !regs.CR[0].eq ) { return 0x821B6198;  }
		/* 821B611Ch case    5:*/		return 0x821B6120;
		  /* 821B6120h */ case    6:  		/* cmplwi CR0, R11, 0 */
		/* 821B6120h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821B6120h case    6:*/		return 0x821B6124;
		  /* 821B6124h */ case    7:  		/* bc 12, CR0_EQ, 116 */
		/* 821B6124h case    7:*/		if ( regs.CR[0].eq ) { return 0x821B6198;  }
		/* 821B6124h case    7:*/		return 0x821B6128;
		  /* 821B6128h */ case    8:  		/* lwz R11, <#[R30]> */
		/* 821B6128h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821B6128h case    8:*/		return 0x821B612C;
		  /* 821B612Ch */ case    9:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821B612Ch case    9:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821B612Ch case    9:*/		return 0x821B6130;
		  /* 821B6130h */ case   10:  		/* addi R4, R11, -4 */
		/* 821B6130h case   10:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFC);
		/* 821B6130h case   10:*/		return 0x821B6134;
		  /* 821B6134h */ case   11:  		/* lwz R11, <#[R11 + 4]> */
		/* 821B6134h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821B6134h case   11:*/		return 0x821B6138;
		  /* 821B6138h */ case   12:  		/* addi R10, R11, 3 */
		/* 821B6138h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x3);
		/* 821B6138h case   12:*/		return 0x821B613C;
		  /* 821B613Ch */ case   13:  		/* addic. R11, R11, -1 */
		/* 821B613Ch case   13:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 821B613Ch case   13:*/		return 0x821B6140;
		  /* 821B6140h */ case   14:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821B6140h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821B6140h case   14:*/		return 0x821B6144;
		  /* 821B6144h */ case   15:  		/* lwzx R31, <#[R10 + R4]> */
		/* 821B6144h case   15:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R4 + 0x00000000) );
		/* 821B6144h case   15:*/		return 0x821B6148;
		  /* 821B6148h */ case   16:  		/* stw R11, <#[R4 + 8]> */
		/* 821B6148h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821B6148h case   16:*/		return 0x821B614C;
		  /* 821B614Ch */ case   17:  		/* bc 4, CR0_EQ, 60 */
		/* 821B614Ch case   17:*/		if ( !regs.CR[0].eq ) { return 0x821B6188;  }
		/* 821B614Ch case   17:*/		return 0x821B6150;
		  /* 821B6150h */ case   18:  		/* rlwinm R11, R4, 0, 0, 30 */
		/* 821B6150h case   18:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R4);
		/* 821B6150h case   18:*/		return 0x821B6154;
		  /* 821B6154h */ case   19:  		/* mr R3, R30 */
		/* 821B6154h case   19:*/		regs.R3 = regs.R30;
		/* 821B6154h case   19:*/		return 0x821B6158;
		  /* 821B6158h */ case   20:  		/* lwz R10, <#[R11 + 4]> */
		/* 821B6158h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821B6158h case   20:*/		return 0x821B615C;
		  /* 821B615Ch */ case   21:  		/* lwz R9, <#[R11]> */
		/* 821B615Ch case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821B615Ch case   21:*/		return 0x821B6160;
		  /* 821B6160h */ case   22:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 821B6160h case   22:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 821B6160h case   22:*/		return 0x821B6164;
		  /* 821B6164h */ case   23:  		/* stw R9, <#[R10]> */
		/* 821B6164h case   23:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821B6164h case   23:*/		return 0x821B6168;
		  /* 821B6168h */ case   24:  		/* lwz R10, <#[R11]> */
		/* 821B6168h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821B6168h case   24:*/		return 0x821B616C;
		  /* 821B616Ch */ case   25:  		/* lwz R11, <#[R11 + 4]> */
		/* 821B616Ch case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821B616Ch case   25:*/		return 0x821B6170;
		  /* 821B6170h */ case   26:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 821B6170h case   26:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 821B6170h case   26:*/		return 0x821B6174;
		  /* 821B6174h */ case   27:  		/* stw R11, <#[R10]> */
		/* 821B6174h case   27:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 821B6174h case   27:*/		return 0x821B6178;
		  /* 821B6178h */ case   28:  		/* lwz R11, <#[R4 + 12]> */
		/* 821B6178h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 821B6178h case   28:*/		return 0x821B617C;
		  /* 821B617Ch */ case   29:  		/* addi R11, R11, 4 */
		/* 821B617Ch case   29:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821B617Ch case   29:*/		return 0x821B6180;
		  /* 821B6180h */ case   30:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 821B6180h case   30:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 821B6180h case   30:*/		return 0x821B6184;
		  /* 821B6184h */ case   31:  		/* bl -410492 */
		/* 821B6184h case   31:*/		regs.LR = 0x821B6188; return 0x82151E08;
		/* 821B6184h case   31:*/		return 0x821B6188;
	}
	return 0x821B6188;
} // Block from 821B6108h-821B6188h (32 instructions)

//////////////////////////////////////////////////////
// Block at 821B6188h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6188( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6188) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6188);
		  /* 821B6188h */ case    0:  		/* mr R4, R31 */
		/* 821B6188h case    0:*/		regs.R4 = regs.R31;
		/* 821B6188h case    0:*/		return 0x821B618C;
		  /* 821B618Ch */ case    1:  		/* mr R3, R14 */
		/* 821B618Ch case    1:*/		regs.R3 = regs.R14;
		/* 821B618Ch case    1:*/		return 0x821B6190;
		  /* 821B6190h */ case    2:  		/* bl 480448 */
		/* 821B6190h case    2:*/		regs.LR = 0x821B6194; return 0x8222B650;
		/* 821B6190h case    2:*/		return 0x821B6194;
		  /* 821B6194h */ case    3:  		/* b -128 */
		/* 821B6194h case    3:*/		return 0x821B6114;
		/* 821B6194h case    3:*/		return 0x821B6198;
	}
	return 0x821B6198;
} // Block from 821B6188h-821B6198h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821B6198h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6198( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6198) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6198);
		  /* 821B6198h */ case    0:  		/* lwz R11, <#[R14 + 44]> */
		/* 821B6198h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x0000002C) );
		/* 821B6198h case    0:*/		return 0x821B619C;
		  /* 821B619Ch */ case    1:  		/* li R29, 0 */
		/* 821B619Ch case    1:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 821B619Ch case    1:*/		return 0x821B61A0;
		  /* 821B61A0h */ case    2:  		/* lwz R10, <#[R14 + 4]> */
		/* 821B61A0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R14 + 0x00000004) );
		/* 821B61A0h case    2:*/		return 0x821B61A4;
		  /* 821B61A4h */ case    3:  		/* addis R11, R11, -8 */
		/* 821B61A4h case    3:*/		cpu::op::addis<0>(regs,&regs.R11,regs.R11,0xFFFFFFF8);
		/* 821B61A4h case    3:*/		return 0x821B61A8;
		  /* 821B61A8h */ case    4:  		/* rlwinm R9, R10, 0, 31, 31 */
		/* 821B61A8h case    4:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R9,regs.R10);
		/* 821B61A8h case    4:*/		return 0x821B61AC;
		  /* 821B61ACh */ case    5:  		/* stw R11, <#[R14 + 44]> */
		/* 821B61ACh case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R14 + 0x0000002C) );
		/* 821B61ACh case    5:*/		return 0x821B61B0;
		  /* 821B61B0h */ case    6:  		/* mr R30, R29 */
		/* 821B61B0h case    6:*/		regs.R30 = regs.R29;
		/* 821B61B0h case    6:*/		return 0x821B61B4;
		  /* 821B61B4h */ case    7:  		/* addic R11, R9, -1 */
		/* 821B61B4h case    7:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R9,0xFFFFFFFF);
		/* 821B61B4h case    7:*/		return 0x821B61B8;
		  /* 821B61B8h */ case    8:  		/* subfe R11, R11, R11 */
		/* 821B61B8h case    8:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 821B61B8h case    8:*/		return 0x821B61BC;
		  /* 821B61BCh */ case    9:  		/* and R11, R11, R10 */
		/* 821B61BCh case    9:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821B61BCh case    9:*/		return 0x821B61C0;
		  /* 821B61C0h */ case   10:  		/* lwz R31, <#[R11 + 20]> */
		/* 821B61C0h case   10:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000014) );
		/* 821B61C0h case   10:*/		return 0x821B61C4;
		  /* 821B61C4h */ case   11:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 821B61C4h case   11:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 821B61C4h case   11:*/		return 0x821B61C8;
		  /* 821B61C8h */ case   12:  		/* bc 4, CR0_EQ, 244 */
		/* 821B61C8h case   12:*/		if ( !regs.CR[0].eq ) { return 0x821B62BC;  }
		/* 821B61C8h case   12:*/		return 0x821B61CC;
		  /* 821B61CCh */ case   13:  		/* cmplwi CR0, R31, 0 */
		/* 821B61CCh case   13:*/		cpu::op::cmplwi<0>(regs,regs.R31,0x00000000);
		/* 821B61CCh case   13:*/		return 0x821B61D0;
		  /* 821B61D0h */ case   14:  		/* bc 12, CR0_EQ, 236 */
		/* 821B61D0h case   14:*/		if ( regs.CR[0].eq ) { return 0x821B62BC;  }
		/* 821B61D0h case   14:*/		return 0x821B61D4;
		  /* 821B61D4h */ case   15:  		/* mr R4, R14 */
		/* 821B61D4h case   15:*/		regs.R4 = regs.R14;
		/* 821B61D4h case   15:*/		return 0x821B61D8;
		  /* 821B61D8h */ case   16:  		/* mr R3, R31 */
		/* 821B61D8h case   16:*/		regs.R3 = regs.R31;
		/* 821B61D8h case   16:*/		return 0x821B61DC;
		  /* 821B61DCh */ case   17:  		/* bl -128564 */
		/* 821B61DCh case   17:*/		regs.LR = 0x821B61E0; return 0x82196BA8;
		/* 821B61DCh case   17:*/		return 0x821B61E0;
		  /* 821B61E0h */ case   18:  		/* lwz R11, <#[R31 + 8]> */
		/* 821B61E0h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821B61E0h case   18:*/		return 0x821B61E4;
		  /* 821B61E4h */ case   19:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821B61E4h case   19:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821B61E4h case   19:*/		return 0x821B61E8;
		  /* 821B61E8h */ case   20:  		/* cmplwi CR6, R11, 16000 */
		/* 821B61E8h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E80);
		/* 821B61E8h case   20:*/		return 0x821B61EC;
		  /* 821B61ECh */ case   21:  		/* bc 4, CR6_EQ, 40 */
		/* 821B61ECh case   21:*/		if ( !regs.CR[6].eq ) { return 0x821B6214;  }
		/* 821B61ECh case   21:*/		return 0x821B61F0;
		  /* 821B61F0h */ case   22:  		/* lwz R11, <#[R31 + 4]> */
		/* 821B61F0h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 821B61F0h case   22:*/		return 0x821B61F4;
		  /* 821B61F4h */ case   23:  		/* cmpwi CR6, R11, 0 */
		/* 821B61F4h case   23:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 821B61F4h case   23:*/		return 0x821B61F8;
		  /* 821B61F8h */ case   24:  		/* bc 4, CR6_EQ, 28 */
		/* 821B61F8h case   24:*/		if ( !regs.CR[6].eq ) { return 0x821B6214;  }
		/* 821B61F8h case   24:*/		return 0x821B61FC;
		  /* 821B61FCh */ case   25:  		/* li R6, 1 */
		/* 821B61FCh case   25:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821B61FCh case   25:*/		return 0x821B6200;
		  /* 821B6200h */ case   26:  		/* li R5, 0 */
		/* 821B6200h case   26:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821B6200h case   26:*/		return 0x821B6204;
		  /* 821B6204h */ case   27:  		/* mr R4, R31 */
		/* 821B6204h case   27:*/		regs.R4 = regs.R31;
		/* 821B6204h case   27:*/		return 0x821B6208;
		  /* 821B6208h */ case   28:  		/* mr R3, R14 */
		/* 821B6208h case   28:*/		regs.R3 = regs.R14;
		/* 821B6208h case   28:*/		return 0x821B620C;
		  /* 821B620Ch */ case   29:  		/* bl 479676 */
		/* 821B620Ch case   29:*/		regs.LR = 0x821B6210; return 0x8222B3C8;
		/* 821B620Ch case   29:*/		return 0x821B6210;
		  /* 821B6210h */ case   30:  		/* b 20 */
		/* 821B6210h case   30:*/		return 0x821B6224;
		/* 821B6210h case   30:*/		return 0x821B6214;
	}
	return 0x821B6214;
} // Block from 821B6198h-821B6214h (31 instructions)

//////////////////////////////////////////////////////
// Block at 821B6214h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6214( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6214) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6214);
		  /* 821B6214h */ case    0:  		/* mr R4, R31 */
		/* 821B6214h case    0:*/		regs.R4 = regs.R31;
		/* 821B6214h case    0:*/		return 0x821B6218;
		  /* 821B6218h */ case    1:  		/* lwz R5, <#[R14 + 660]> */
		/* 821B6218h case    1:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R14 + 0x00000294) );
		/* 821B6218h case    1:*/		return 0x821B621C;
		  /* 821B621Ch */ case    2:  		/* mr R3, R14 */
		/* 821B621Ch case    2:*/		regs.R3 = regs.R14;
		/* 821B621Ch case    2:*/		return 0x821B6220;
		  /* 821B6220h */ case    3:  		/* bl 26424 */
		/* 821B6220h case    3:*/		regs.LR = 0x821B6224; return 0x821BC958;
		/* 821B6220h case    3:*/		return 0x821B6224;
	}
	return 0x821B6224;
} // Block from 821B6214h-821B6224h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821B6224h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6224( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6224) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6224);
		  /* 821B6224h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 821B6224h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821B6224h case    0:*/		return 0x821B6228;
		  /* 821B6228h */ case    1:  		/* bc 12, CR6_EQ, 68 */
		/* 821B6228h case    1:*/		if ( regs.CR[6].eq ) { return 0x821B626C;  }
		/* 821B6228h case    1:*/		return 0x821B622C;
		  /* 821B622Ch */ case    2:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 821B622Ch case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 821B622Ch case    2:*/		return 0x821B6230;
		  /* 821B6230h */ case    3:  		/* lwz R11, <#[R11 + 40]> */
		/* 821B6230h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 821B6230h case    3:*/		return 0x821B6234;
		  /* 821B6234h */ case    4:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 821B6234h case    4:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821B6234h case    4:*/		return 0x821B6238;
		  /* 821B6238h */ case    5:  		/* addic R10, R10, -1 */
		/* 821B6238h case    5:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 821B6238h case    5:*/		return 0x821B623C;
		  /* 821B623Ch */ case    6:  		/* subfe R10, R10, R10 */
		/* 821B623Ch case    6:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 821B623Ch case    6:*/		return 0x821B6240;
		  /* 821B6240h */ case    7:  		/* and R10, R10, R11 */
		/* 821B6240h case    7:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 821B6240h case    7:*/		return 0x821B6244;
		  /* 821B6244h */ case    8:  		/* cmplw CR6, R31, R10 */
		/* 821B6244h case    8:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R10);
		/* 821B6244h case    8:*/		return 0x821B6248;
		  /* 821B6248h */ case    9:  		/* bc 4, CR6_EQ, 20 */
		/* 821B6248h case    9:*/		if ( !regs.CR[6].eq ) { return 0x821B625C;  }
		/* 821B6248h case    9:*/		return 0x821B624C;
		  /* 821B624Ch */ case   10:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821B624Ch case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821B624Ch case   10:*/		return 0x821B6250;
		  /* 821B6250h */ case   11:  		/* mr R30, R31 */
		/* 821B6250h case   11:*/		regs.R30 = regs.R31;
		/* 821B6250h case   11:*/		return 0x821B6254;
		  /* 821B6254h */ case   12:  		/* lwz R31, <#[R11 + 40]> */
		/* 821B6254h case   12:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000028) );
		/* 821B6254h case   12:*/		return 0x821B6258;
		  /* 821B6258h */ case   13:  		/* b 84 */
		/* 821B6258h case   13:*/		return 0x821B62AC;
		/* 821B6258h case   13:*/		return 0x821B625C;
	}
	return 0x821B625C;
} // Block from 821B6224h-821B625Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 821B625Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B625C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B625C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B625C);
		  /* 821B625Ch */ case    0:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821B625Ch case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821B625Ch case    0:*/		return 0x821B6260;
		  /* 821B6260h */ case    1:  		/* bc 4, CR0_EQ, 92 */
		/* 821B6260h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821B62BC;  }
		/* 821B6260h case    1:*/		return 0x821B6264;
		  /* 821B6264h */ case    2:  		/* mr R31, R11 */
		/* 821B6264h case    2:*/		regs.R31 = regs.R11;
		/* 821B6264h case    2:*/		return 0x821B6268;
		  /* 821B6268h */ case    3:  		/* b 76 */
		/* 821B6268h case    3:*/		return 0x821B62B4;
		/* 821B6268h case    3:*/		return 0x821B626C;
	}
	return 0x821B626C;
} // Block from 821B625Ch-821B626Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 821B626Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B626C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B626C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B626C);
		  /* 821B626Ch */ case    0:  		/* lwz R11, <#[R14 + 4]> */
		/* 821B626Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000004) );
		/* 821B626Ch case    0:*/		return 0x821B6270;
		  /* 821B6270h */ case    1:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 821B6270h case    1:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821B6270h case    1:*/		return 0x821B6274;
		  /* 821B6274h */ case    2:  		/* addic R9, R10, -1 */
		/* 821B6274h case    2:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R10,0xFFFFFFFF);
		/* 821B6274h case    2:*/		return 0x821B6278;
		  /* 821B6278h */ case    3:  		/* subfe R9, R9, R9 */
		/* 821B6278h case    3:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 821B6278h case    3:*/		return 0x821B627C;
		  /* 821B627Ch */ case    4:  		/* and R9, R9, R11 */
		/* 821B627Ch case    4:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 821B627Ch case    4:*/		return 0x821B6280;
		  /* 821B6280h */ case    5:  		/* lwz R9, <#[R9 + 20]> */
		/* 821B6280h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000014) );
		/* 821B6280h case    5:*/		return 0x821B6284;
		  /* 821B6284h */ case    6:  		/* rlwinm R8, R9, 0, 31, 31 */
		/* 821B6284h case    6:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R8,regs.R9);
		/* 821B6284h case    6:*/		return 0x821B6288;
		  /* 821B6288h */ case    7:  		/* addic R8, R8, -1 */
		/* 821B6288h case    7:*/		cpu::op::addic<0>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 821B6288h case    7:*/		return 0x821B628C;
		  /* 821B628Ch */ case    8:  		/* subfe R8, R8, R8 */
		/* 821B628Ch case    8:*/		cpu::op::subfe<0>(regs,&regs.R8,regs.R8,regs.R8);
		/* 821B628Ch case    8:*/		return 0x821B6290;
		  /* 821B6290h */ case    9:  		/* and R9, R8, R9 */
		/* 821B6290h case    9:*/		cpu::op::and<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 821B6290h case    9:*/		return 0x821B6294;
		  /* 821B6294h */ case   10:  		/* cmplw CR6, R31, R9 */
		/* 821B6294h case   10:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R9);
		/* 821B6294h case   10:*/		return 0x821B6298;
		  /* 821B6298h */ case   11:  		/* bc 12, CR6_EQ, -76 */
		/* 821B6298h case   11:*/		if ( regs.CR[6].eq ) { return 0x821B624C;  }
		/* 821B6298h case   11:*/		return 0x821B629C;
		  /* 821B629Ch */ case   12:  		/* addic R10, R10, -1 */
		/* 821B629Ch case   12:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 821B629Ch case   12:*/		return 0x821B62A0;
		  /* 821B62A0h */ case   13:  		/* subfe R10, R10, R10 */
		/* 821B62A0h case   13:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 821B62A0h case   13:*/		return 0x821B62A4;
		  /* 821B62A4h */ case   14:  		/* and R11, R10, R11 */
		/* 821B62A4h case   14:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821B62A4h case   14:*/		return 0x821B62A8;
		  /* 821B62A8h */ case   15:  		/* lwz R31, <#[R11 + 20]> */
		/* 821B62A8h case   15:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000014) );
		/* 821B62A8h case   15:*/		return 0x821B62AC;
	}
	return 0x821B62AC;
} // Block from 821B626Ch-821B62ACh (16 instructions)

//////////////////////////////////////////////////////
// Block at 821B62ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B62AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B62AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B62AC);
		  /* 821B62ACh */ case    0:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 821B62ACh case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 821B62ACh case    0:*/		return 0x821B62B0;
		  /* 821B62B0h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 821B62B0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821B62BC;  }
		/* 821B62B0h case    1:*/		return 0x821B62B4;
	}
	return 0x821B62B4;
} // Block from 821B62ACh-821B62B4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B62B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B62B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B62B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B62B4);
		  /* 821B62B4h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 821B62B4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821B62B4h case    0:*/		return 0x821B62B8;
		  /* 821B62B8h */ case    1:  		/* bc 4, CR6_EQ, -228 */
		/* 821B62B8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821B61D4;  }
		/* 821B62B8h case    1:*/		return 0x821B62BC;
	}
	return 0x821B62BC;
} // Block from 821B62B4h-821B62BCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B62BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B62BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B62BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B62BC);
		  /* 821B62BCh */ case    0:  		/* lwz R3, <#[R14 + 660]> */
		/* 821B62BCh case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R14 + 0x00000294) );
		/* 821B62BCh case    0:*/		return 0x821B62C0;
		  /* 821B62C0h */ case    1:  		/* lwz R11, <#[R3 + 4]> */
		/* 821B62C0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821B62C0h case    1:*/		return 0x821B62C4;
		  /* 821B62C4h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821B62C4h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821B62C4h case    2:*/		return 0x821B62C8;
		  /* 821B62C8h */ case    3:  		/* bc 4, CR0_EQ, 228 */
		/* 821B62C8h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821B63AC;  }
		/* 821B62C8h case    3:*/		return 0x821B62CC;
		  /* 821B62CCh */ case    4:  		/* cmplwi CR0, R11, 0 */
		/* 821B62CCh case    4:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821B62CCh case    4:*/		return 0x821B62D0;
		  /* 821B62D0h */ case    5:  		/* bc 12, CR0_EQ, 220 */
		/* 821B62D0h case    5:*/		if ( regs.CR[0].eq ) { return 0x821B63AC;  }
		/* 821B62D0h case    5:*/		return 0x821B62D4;
		  /* 821B62D4h */ case    6:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 821B62D4h case    6:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 821B62D4h case    6:*/		return 0x821B62D8;
		  /* 821B62D8h */ case    7:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821B62D8h case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821B62D8h case    7:*/		return 0x821B62DC;
		  /* 821B62DCh */ case    8:  		/* bc 12, CR0_EQ, 12 */
		/* 821B62DCh case    8:*/		if ( regs.CR[0].eq ) { return 0x821B62E8;  }
		/* 821B62DCh case    8:*/		return 0x821B62E0;
		  /* 821B62E0h */ case    9:  		/* mr R4, R29 */
		/* 821B62E0h case    9:*/		regs.R4 = regs.R29;
		/* 821B62E0h case    9:*/		return 0x821B62E4;
		  /* 821B62E4h */ case   10:  		/* b 16 */
		/* 821B62E4h case   10:*/		return 0x821B62F4;
		/* 821B62E4h case   10:*/		return 0x821B62E8;
	}
	return 0x821B62E8;
} // Block from 821B62BCh-821B62E8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821B62E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B62E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B62E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B62E8);
		  /* 821B62E8h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 821B62E8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821B62E8h case    0:*/		return 0x821B62EC;
		  /* 821B62ECh */ case    1:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821B62ECh case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821B62ECh case    1:*/		return 0x821B62F0;
		  /* 821B62F0h */ case    2:  		/* addi R4, R11, -4 */
		/* 821B62F0h case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R11,0xFFFFFFFC);
		/* 821B62F0h case    2:*/		return 0x821B62F4;
	}
	return 0x821B62F4;
} // Block from 821B62E8h-821B62F4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821B62F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B62F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B62F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B62F4);
		  /* 821B62F4h */ case    0:  		/* lwz R11, <#[R4 + 8]> */
		/* 821B62F4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821B62F4h case    0:*/		return 0x821B62F8;
		  /* 821B62F8h */ case    1:  		/* addi R10, R11, 3 */
		/* 821B62F8h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x3);
		/* 821B62F8h case    1:*/		return 0x821B62FC;
		  /* 821B62FCh */ case    2:  		/* addic. R11, R11, -1 */
		/* 821B62FCh case    2:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 821B62FCh case    2:*/		return 0x821B6300;
		  /* 821B6300h */ case    3:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821B6300h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821B6300h case    3:*/		return 0x821B6304;
		  /* 821B6304h */ case    4:  		/* lwzx R31, <#[R10 + R4]> */
		/* 821B6304h case    4:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R4 + 0x00000000) );
		/* 821B6304h case    4:*/		return 0x821B6308;
		  /* 821B6308h */ case    5:  		/* stw R11, <#[R4 + 8]> */
		/* 821B6308h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821B6308h case    5:*/		return 0x821B630C;
		  /* 821B630Ch */ case    6:  		/* bc 4, CR0_EQ, 56 */
		/* 821B630Ch case    6:*/		if ( !regs.CR[0].eq ) { return 0x821B6344;  }
		/* 821B630Ch case    6:*/		return 0x821B6310;
		  /* 821B6310h */ case    7:  		/* rlwinm R11, R4, 0, 0, 30 */
		/* 821B6310h case    7:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R4);
		/* 821B6310h case    7:*/		return 0x821B6314;
		  /* 821B6314h */ case    8:  		/* lwz R10, <#[R11 + 4]> */
		/* 821B6314h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821B6314h case    8:*/		return 0x821B6318;
		  /* 821B6318h */ case    9:  		/* lwz R9, <#[R11]> */
		/* 821B6318h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821B6318h case    9:*/		return 0x821B631C;
		  /* 821B631Ch */ case   10:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 821B631Ch case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 821B631Ch case   10:*/		return 0x821B6320;
		  /* 821B6320h */ case   11:  		/* stw R9, <#[R10]> */
		/* 821B6320h case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821B6320h case   11:*/		return 0x821B6324;
		  /* 821B6324h */ case   12:  		/* lwz R10, <#[R11]> */
		/* 821B6324h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821B6324h case   12:*/		return 0x821B6328;
		  /* 821B6328h */ case   13:  		/* lwz R11, <#[R11 + 4]> */
		/* 821B6328h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821B6328h case   13:*/		return 0x821B632C;
		  /* 821B632Ch */ case   14:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 821B632Ch case   14:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 821B632Ch case   14:*/		return 0x821B6330;
		  /* 821B6330h */ case   15:  		/* stw R11, <#[R10]> */
		/* 821B6330h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 821B6330h case   15:*/		return 0x821B6334;
		  /* 821B6334h */ case   16:  		/* lwz R11, <#[R4 + 12]> */
		/* 821B6334h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000000C) );
		/* 821B6334h case   16:*/		return 0x821B6338;
		  /* 821B6338h */ case   17:  		/* addi R11, R11, 4 */
		/* 821B6338h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821B6338h case   17:*/		return 0x821B633C;
		  /* 821B633Ch */ case   18:  		/* rlwinm R5, R11, 2, 0, 29 */
		/* 821B633Ch case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R11);
		/* 821B633Ch case   18:*/		return 0x821B6340;
		  /* 821B6340h */ case   19:  		/* bl -410936 */
		/* 821B6340h case   19:*/		regs.LR = 0x821B6344; return 0x82151E08;
		/* 821B6340h case   19:*/		return 0x821B6344;
	}
	return 0x821B6344;
} // Block from 821B62F4h-821B6344h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821B6344h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6344( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6344) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6344);
		  /* 821B6344h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 821B6344h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821B6344h case    0:*/		return 0x821B6348;
		  /* 821B6348h */ case    1:  		/* rlwinm R10, R11, 25, 25, 31 */
		/* 821B6348h case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R11);
		/* 821B6348h case    1:*/		return 0x821B634C;
		  /* 821B634Ch */ case    2:  		/* cmplwi CR6, R10, 115 */
		/* 821B634Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000073);
		/* 821B634Ch case    2:*/		return 0x821B6350;
		  /* 821B6350h */ case    3:  		/* bc 12, CR6_EQ, -148 */
		/* 821B6350h case    3:*/		if ( regs.CR[6].eq ) { return 0x821B62BC;  }
		/* 821B6350h case    3:*/		return 0x821B6354;
		  /* 821B6354h */ case    4:  		/* cmplwi CR6, R10, 112 */
		/* 821B6354h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000070);
		/* 821B6354h case    4:*/		return 0x821B6358;
		  /* 821B6358h */ case    5:  		/* bc 4, CR6_EQ, 56 */
		/* 821B6358h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821B6390;  }
		/* 821B6358h case    5:*/		return 0x821B635C;
		  /* 821B635Ch */ case    6:  		/* lwz R11, <#[R31 + 16]> */
		/* 821B635Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 821B635Ch case    6:*/		return 0x821B6360;
		  /* 821B6360h */ case    7:  		/* li R10, 1 */
		/* 821B6360h case    7:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 821B6360h case    7:*/		return 0x821B6364;
		  /* 821B6364h */ case    8:  		/* rlwimi R11, R10, 16, 13, 15 */
		/* 821B6364h case    8:*/		cpu::op::rlwimi<0,16,13,15>(regs,&regs.R11,regs.R10);
		/* 821B6364h case    8:*/		return 0x821B6368;
		  /* 821B6368h */ case    9:  		/* stw R11, <#[R31 + 16]> */
		/* 821B6368h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 821B6368h case    9:*/		return 0x821B636C;
		  /* 821B636Ch */ case   10:  		/* lwz R11, <#[R14 + 116]> */
		/* 821B636Ch case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000074) );
		/* 821B636Ch case   10:*/		return 0x821B6370;
		  /* 821B6370h */ case   11:  		/* lhz R10, <#[R31 + 16]> */
		/* 821B6370h case   11:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 821B6370h case   11:*/		return 0x821B6374;
		  /* 821B6374h */ case   12:  		/* addi R11, R11, 1 */
		/* 821B6374h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821B6374h case   12:*/		return 0x821B6378;
		  /* 821B6378h */ case   13:  		/* rlwinm R10, R10, 0, 29, 31 */
		/* 821B6378h case   13:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R10,regs.R10);
		/* 821B6378h case   13:*/		return 0x821B637C;
		  /* 821B637Ch */ case   14:  		/* sth R11, <#[R31 + 18]> */
		/* 821B637Ch case   14:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R31 + 0x00000012) );
		/* 821B637Ch case   14:*/		return 0x821B6380;
		  /* 821B6380h */ case   15:  		/* lwz R11, <#[R14 + 116]> */
		/* 821B6380h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000074) );
		/* 821B6380h case   15:*/		return 0x821B6384;
		  /* 821B6384h */ case   16:  		/* add R11, R10, R11 */
		/* 821B6384h case   16:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821B6384h case   16:*/		return 0x821B6388;
		  /* 821B6388h */ case   17:  		/* stw R11, <#[R14 + 116]> */
		/* 821B6388h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R14 + 0x00000074) );
		/* 821B6388h case   17:*/		return 0x821B638C;
		  /* 821B638Ch */ case   18:  		/* b -208 */
		/* 821B638Ch case   18:*/		return 0x821B62BC;
		/* 821B638Ch case   18:*/		return 0x821B6390;
	}
	return 0x821B6390;
} // Block from 821B6344h-821B6390h (19 instructions)

//////////////////////////////////////////////////////
// Block at 821B6390h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6390( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6390) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6390);
		  /* 821B6390h */ case    0:  		/* rlwinm R11, R11, 0, 9, 7 */
		/* 821B6390h case    0:*/		cpu::op::rlwinm<0,0,9,7>(regs,&regs.R11,regs.R11);
		/* 821B6390h case    0:*/		return 0x821B6394;
		  /* 821B6394h */ case    1:  		/* sth R29, <#[R31 + 18]> */
		/* 821B6394h case    1:*/		cpu::mem::store16( regs, regs.R29, (uint32)(regs.R31 + 0x00000012) );
		/* 821B6394h case    1:*/		return 0x821B6398;
		  /* 821B6398h */ case    2:  		/* mr R4, R31 */
		/* 821B6398h case    2:*/		regs.R4 = regs.R31;
		/* 821B6398h case    2:*/		return 0x821B639C;
		  /* 821B639Ch */ case    3:  		/* stw R11, <#[R31 + 8]> */
		/* 821B639Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821B639Ch case    3:*/		return 0x821B63A0;
		  /* 821B63A0h */ case    4:  		/* mr R3, R14 */
		/* 821B63A0h case    4:*/		regs.R3 = regs.R14;
		/* 821B63A0h case    4:*/		return 0x821B63A4;
		  /* 821B63A4h */ case    5:  		/* bl 1700 */
		/* 821B63A4h case    5:*/		regs.LR = 0x821B63A8; return 0x821B6A48;
		/* 821B63A4h case    5:*/		return 0x821B63A8;
		  /* 821B63A8h */ case    6:  		/* b -236 */
		/* 821B63A8h case    6:*/		return 0x821B62BC;
		/* 821B63A8h case    6:*/		return 0x821B63AC;
	}
	return 0x821B63AC;
} // Block from 821B6390h-821B63ACh (7 instructions)

//////////////////////////////////////////////////////
// Block at 821B63ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B63AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B63AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B63AC);
		  /* 821B63ACh */ case    0:  		/* stw R29, <#[R14 + 660]> */
		/* 821B63ACh case    0:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R14 + 0x00000294) );
		/* 821B63ACh case    0:*/		return 0x821B63B0;
		  /* 821B63B0h */ case    1:  		/* li R4, 0 */
		/* 821B63B0h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 821B63B0h case    1:*/		return 0x821B63B4;
		  /* 821B63B4h */ case    2:  		/* stw R29, <#[R14 + 708]> */
		/* 821B63B4h case    2:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R14 + 0x000002C4) );
		/* 821B63B4h case    2:*/		return 0x821B63B8;
		  /* 821B63B8h */ case    3:  		/* mr R3, R14 */
		/* 821B63B8h case    3:*/		regs.R3 = regs.R14;
		/* 821B63B8h case    3:*/		return 0x821B63BC;
		  /* 821B63BCh */ case    4:  		/* bl -333516 */
		/* 821B63BCh case    4:*/		regs.LR = 0x821B63C0; return 0x82164CF0;
		/* 821B63BCh case    4:*/		return 0x821B63C0;
		  /* 821B63C0h */ case    5:  		/* lwz R11, <#[R14 + 44]> */
		/* 821B63C0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x0000002C) );
		/* 821B63C0h case    5:*/		return 0x821B63C4;
		  /* 821B63C4h */ case    6:  		/* rlwinm. R10, R11, 0, 11, 11 */
		/* 821B63C4h case    6:*/		cpu::op::rlwinm<1,0,11,11>(regs,&regs.R10,regs.R11);
		/* 821B63C4h case    6:*/		return 0x821B63C8;
		  /* 821B63C8h */ case    7:  		/* bc 12, CR0_EQ, 16 */
		/* 821B63C8h case    7:*/		if ( regs.CR[0].eq ) { return 0x821B63D8;  }
		/* 821B63C8h case    7:*/		return 0x821B63CC;
		  /* 821B63CCh */ case    8:  		/* addis R11, R11, -16 */
		/* 821B63CCh case    8:*/		cpu::op::addis<0>(regs,&regs.R11,regs.R11,0xFFFFFFF0);
		/* 821B63CCh case    8:*/		return 0x821B63D0;
		  /* 821B63D0h */ case    9:  		/* stw R11, <#[R14 + 44]> */
		/* 821B63D0h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R14 + 0x0000002C) );
		/* 821B63D0h case    9:*/		return 0x821B63D4;
		  /* 821B63D4h */ case   10:  		/* b -19268 */
		/* 821B63D4h case   10:*/		return 0x821B1890;
		/* 821B63D4h case   10:*/		return 0x821B63D8;
	}
	return 0x821B63D8;
} // Block from 821B63ACh-821B63D8h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821B63D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B63D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B63D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B63D8);
		  /* 821B63D8h */ case    0:  		/* addi R1, R1, 464 */
		/* 821B63D8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x1D0);
		/* 821B63D8h case    0:*/		return 0x821B63DC;
		  /* 821B63DCh */ case    1:  		/* addi R12, R1, -152 */
		/* 821B63DCh case    1:*/		cpu::op::addi<0>(regs,&regs.R12,regs.R1,0xFFFFFF68);
		/* 821B63DCh case    1:*/		return 0x821B63E0;
		  /* 821B63E0h */ case    2:  		/* bl -1199996 */
		/* 821B63E0h case    2:*/		regs.LR = 0x821B63E4; return 0x82091464;
		/* 821B63E0h case    2:*/		return 0x821B63E4;
		  /* 821B63E4h */ case    3:  		/* b -1200500 */
		/* 821B63E4h case    3:*/		return 0x82091270;
		/* 821B63E4h case    3:*/		return 0x821B63E8;
	}
	return 0x821B63E8;
} // Block from 821B63D8h-821B63E8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821B63E8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B63E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B63E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B63E8);
		  /* 821B63E8h */ case    0:  		/* mfspr R12, LR */
		/* 821B63E8h case    0:*/		regs.R12 = regs.LR;
		/* 821B63E8h case    0:*/		return 0x821B63EC;
		  /* 821B63ECh */ case    1:  		/* bl -1200528 */
		/* 821B63ECh case    1:*/		regs.LR = 0x821B63F0; return 0x8209125C;
		/* 821B63ECh case    1:*/		return 0x821B63F0;
		  /* 821B63F0h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821B63F0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821B63F0h case    2:*/		return 0x821B63F4;
		  /* 821B63F4h */ case    3:  		/* lwz R8, <#[R4 + 8]> */
		/* 821B63F4h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R4 + 0x00000008) );
		/* 821B63F4h case    3:*/		return 0x821B63F8;
		  /* 821B63F8h */ case    4:  		/* li R5, 0 */
		/* 821B63F8h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821B63F8h case    4:*/		return 0x821B63FC;
		  /* 821B63FCh */ case    5:  		/* li R11, 0 */
		/* 821B63FCh case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821B63FCh case    5:*/		return 0x821B6400;
		  /* 821B6400h */ case    6:  		/* rlwinm. R10, R8, 0, 10, 12 */
		/* 821B6400h case    6:*/		cpu::op::rlwinm<1,0,10,12>(regs,&regs.R10,regs.R8);
		/* 821B6400h case    6:*/		return 0x821B6404;
		  /* 821B6404h */ case    7:  		/* bc 12, CR0_EQ, 128 */
		/* 821B6404h case    7:*/		if ( regs.CR[0].eq ) { return 0x821B6484;  }
		/* 821B6404h case    7:*/		return 0x821B6408;
		  /* 821B6408h */ case    8:  		/* rlwinm R10, R8, 0, 0, 31 */
		/* 821B6408h case    8:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R10,regs.R8);
		/* 821B6408h case    8:*/		return 0x821B640C;
		  /* 821B640Ch */ case    9:  		/* addi R31, R4, 44 */
		/* 821B640Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R4,0x2C);
		/* 821B640Ch case    9:*/		return 0x821B6410;
		  /* 821B6410h */ case   10:  		/* rlwinm R30, R10, 13, 29, 31 */
		/* 821B6410h case   10:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R30,regs.R10);
		/* 821B6410h case   10:*/		return 0x821B6414;
		  /* 821B6414h */ case   11:  		/* mr R7, R31 */
		/* 821B6414h case   11:*/		regs.R7 = regs.R31;
		/* 821B6414h case   11:*/		return 0x821B6418;
		  /* 821B6418h */ case   12:  		/* lwz R9, <#[R7]> */
		/* 821B6418h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R7 + 0x00000000) );
		/* 821B6418h case   12:*/		return 0x821B641C;
		  /* 821B641Ch */ case   13:  		/* li R10, 0 */
		/* 821B641Ch case   13:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821B641Ch case   13:*/		return 0x821B6420;
		  /* 821B6420h */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 821B6420h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821B6420h case   14:*/		return 0x821B6424;
		  /* 821B6424h */ case   15:  		/* lwz R6, <#[R9 + 12]> */
		/* 821B6424h case   15:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R9 + 0x0000000C) );
		/* 821B6424h case   15:*/		return 0x821B6428;
		  /* 821B6428h */ case   16:  		/* bc 12, CR6_EQ, 40 */
		/* 821B6428h case   16:*/		if ( regs.CR[6].eq ) { return 0x821B6450;  }
		/* 821B6428h case   16:*/		return 0x821B642C;
		  /* 821B642Ch */ case   17:  		/* mr R9, R31 */
		/* 821B642Ch case   17:*/		regs.R9 = regs.R31;
		/* 821B642Ch case   17:*/		return 0x821B6430;
		  /* 821B6430h */ case   18:  		/* lwz R29, <#[R9]> */
		/* 821B6430h case   18:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R9 + 0x00000000) );
		/* 821B6430h case   18:*/		return 0x821B6434;
		  /* 821B6434h */ case   19:  		/* lwz R29, <#[R29 + 12]> */
		/* 821B6434h case   19:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R29 + 0x0000000C) );
		/* 821B6434h case   19:*/		return 0x821B6438;
		  /* 821B6438h */ case   20:  		/* cmplw CR6, R6, R29 */
		/* 821B6438h case   20:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R29);
		/* 821B6438h case   20:*/		return 0x821B643C;
		  /* 821B643Ch */ case   21:  		/* bc 12, CR6_EQ, 20 */
		/* 821B643Ch case   21:*/		if ( regs.CR[6].eq ) { return 0x821B6450;  }
		/* 821B643Ch case   21:*/		return 0x821B6440;
		  /* 821B6440h */ case   22:  		/* addi R10, R10, 1 */
		/* 821B6440h case   22:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821B6440h case   22:*/		return 0x821B6444;
		  /* 821B6444h */ case   23:  		/* addi R9, R9, 4 */
		/* 821B6444h case   23:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 821B6444h case   23:*/		return 0x821B6448;
		  /* 821B6448h */ case   24:  		/* cmplw CR6, R10, R11 */
		/* 821B6448h case   24:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 821B6448h case   24:*/		return 0x821B644C;
		  /* 821B644Ch */ case   25:  		/* bc 12, CR6_LT, -28 */
		/* 821B644Ch case   25:*/		if ( regs.CR[6].lt ) { return 0x821B6430;  }
		/* 821B644Ch case   25:*/		return 0x821B6450;
	}
	return 0x821B6450;
} // Block from 821B63E8h-821B6450h (26 instructions)

//////////////////////////////////////////////////////
// Block at 821B6450h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6450( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6450) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6450);
		  /* 821B6450h */ case    0:  		/* cmplw CR6, R10, R11 */
		/* 821B6450h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 821B6450h case    0:*/		return 0x821B6454;
		  /* 821B6454h */ case    1:  		/* bc 4, CR6_EQ, 16 */
		/* 821B6454h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821B6464;  }
		/* 821B6454h case    1:*/		return 0x821B6458;
		  /* 821B6458h */ case    2:  		/* lwz R10, <#[R6 + 8]> */
		/* 821B6458h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R6 + 0x00000008) );
		/* 821B6458h case    2:*/		return 0x821B645C;
		  /* 821B645Ch */ case    3:  		/* rlwinm R10, R10, 18, 29, 31 */
		/* 821B645Ch case    3:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R10,regs.R10);
		/* 821B645Ch case    3:*/		return 0x821B6460;
		  /* 821B6460h */ case    4:  		/* add R5, R10, R5 */
		/* 821B6460h case    4:*/		cpu::op::add<0>(regs,&regs.R5,regs.R10,regs.R5);
		/* 821B6460h case    4:*/		return 0x821B6464;
	}
	return 0x821B6464;
} // Block from 821B6450h-821B6464h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821B6464h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6464( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6464) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6464);
		  /* 821B6464h */ case    0:  		/* addi R11, R11, 1 */
		/* 821B6464h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821B6464h case    0:*/		return 0x821B6468;
		  /* 821B6468h */ case    1:  		/* addi R7, R7, 4 */
		/* 821B6468h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 821B6468h case    1:*/		return 0x821B646C;
		  /* 821B646Ch */ case    2:  		/* cmplw CR6, R11, R30 */
		/* 821B646Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 821B646Ch case    2:*/		return 0x821B6470;
		  /* 821B6470h */ case    3:  		/* bc 12, CR6_LT, -88 */
		/* 821B6470h case    3:*/		if ( regs.CR[6].lt ) { return 0x821B6418;  }
		/* 821B6470h case    3:*/		return 0x821B6474;
		  /* 821B6474h */ case    4:  		/* cmplwi CR6, R5, 4 */
		/* 821B6474h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000004);
		/* 821B6474h case    4:*/		return 0x821B6478;
		  /* 821B6478h */ case    5:  		/* bc 4, CR6_GT, 12 */
		/* 821B6478h case    5:*/		if ( !regs.CR[6].gt ) { return 0x821B6484;  }
		/* 821B6478h case    5:*/		return 0x821B647C;
		  /* 821B647Ch */ case    6:  		/* li R4, 4800 */
		/* 821B647Ch case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 821B647Ch case    6:*/		return 0x821B6480;
		  /* 821B6480h */ case    7:  		/* bl -411160 */
		/* 821B6480h case    7:*/		regs.LR = 0x821B6484; return 0x82151E68;
		/* 821B6480h case    7:*/		return 0x821B6484;
	}
	return 0x821B6484;
} // Block from 821B6464h-821B6484h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821B6484h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6484( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6484) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6484);
		  /* 821B6484h */ case    0:  		/* li R11, 1 */
		/* 821B6484h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821B6484h case    0:*/		return 0x821B6488;
		  /* 821B6488h */ case    1:  		/* slw R11, R11, R5 */
		/* 821B6488h case    1:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R5);
		/* 821B6488h case    1:*/		return 0x821B648C;
		  /* 821B648Ch */ case    2:  		/* addi R11, R11, -1 */
		/* 821B648Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 821B648Ch case    2:*/		return 0x821B6490;
		  /* 821B6490h */ case    3:  		/* rlwimi R11, R5, 13, 16, 18 */
		/* 821B6490h case    3:*/		cpu::op::rlwimi<0,13,16,18>(regs,&regs.R11,regs.R5);
		/* 821B6490h case    3:*/		return 0x821B6494;
		  /* 821B6494h */ case    4:  		/* rlwimi R8, R11, 1, 27, 30 */
		/* 821B6494h case    4:*/		cpu::op::rlwimi<0,1,27,30>(regs,&regs.R8,regs.R11);
		/* 821B6494h case    4:*/		return 0x821B6498;
		  /* 821B6498h */ case    5:  		/* rlwimi R8, R11, 1, 15, 17 */
		/* 821B6498h case    5:*/		cpu::op::rlwimi<0,1,15,17>(regs,&regs.R8,regs.R11);
		/* 821B6498h case    5:*/		return 0x821B649C;
		  /* 821B649Ch */ case    6:  		/* stw R8, <#[R4 + 8]> */
		/* 821B649Ch case    6:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R4 + 0x00000008) );
		/* 821B649Ch case    6:*/		return 0x821B64A0;
		  /* 821B64A0h */ case    7:  		/* addi R1, R1, 112 */
		/* 821B64A0h case    7:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821B64A0h case    7:*/		return 0x821B64A4;
		  /* 821B64A4h */ case    8:  		/* b -1200632 */
		/* 821B64A4h case    8:*/		return 0x820912AC;
		/* 821B64A4h case    8:*/		return 0x821B64A8;
	}
	return 0x821B64A8;
} // Block from 821B6484h-821B64A8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821B64A8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B64A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B64A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B64A8);
		  /* 821B64A8h */ case    0:  		/* lwz R10, <#[R4 + 8]> */
		/* 821B64A8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000008) );
		/* 821B64A8h case    0:*/		return 0x821B64AC;
		  /* 821B64ACh */ case    1:  		/* rlwinm R11, R10, 25, 25, 31 */
		/* 821B64ACh case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R10);
		/* 821B64ACh case    1:*/		return 0x821B64B0;
		  /* 821B64B0h */ case    2:  		/* cmpwi CR6, R11, 109 */
		/* 821B64B0h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000006D);
		/* 821B64B0h case    2:*/		return 0x821B64B4;
		  /* 821B64B4h */ case    3:  		/* bc 12, CR6_GT, 148 */
		/* 821B64B4h case    3:*/		if ( regs.CR[6].gt ) { return 0x821B6548;  }
		/* 821B64B4h case    3:*/		return 0x821B64B8;
		  /* 821B64B8h */ case    4:  		/* cmpwi CR6, R11, 108 */
		/* 821B64B8h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000006C);
		/* 821B64B8h case    4:*/		return 0x821B64BC;
		  /* 821B64BCh */ case    5:  		/* bc 4, CR6_LT, 104 */
		/* 821B64BCh case    5:*/		if ( !regs.CR[6].lt ) { return 0x821B6524;  }
		/* 821B64BCh case    5:*/		return 0x821B64C0;
		  /* 821B64C0h */ case    6:  		/* cmpwi CR6, R11, 21 */
		/* 821B64C0h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000015);
		/* 821B64C0h case    6:*/		return 0x821B64C4;
		  /* 821B64C4h */ case    7:  		/* bc 12, CR6_LT, 156 */
		/* 821B64C4h case    7:*/		if ( regs.CR[6].lt ) { return 0x821B6560;  }
		/* 821B64C4h case    7:*/		return 0x821B64C8;
		  /* 821B64C8h */ case    8:  		/* cmpwi CR6, R11, 24 */
		/* 821B64C8h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000018);
		/* 821B64C8h case    8:*/		return 0x821B64CC;
		  /* 821B64CCh */ case    9:  		/* bc 4, CR6_GT, 88 */
		/* 821B64CCh case    9:*/		if ( !regs.CR[6].gt ) { return 0x821B6524;  }
		/* 821B64CCh case    9:*/		return 0x821B64D0;
		  /* 821B64D0h */ case   10:  		/* cmpwi CR6, R11, 62 */
		/* 821B64D0h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000003E);
		/* 821B64D0h case   10:*/		return 0x821B64D4;
		  /* 821B64D4h */ case   11:  		/* bc 4, CR6_GT, 140 */
		/* 821B64D4h case   11:*/		if ( !regs.CR[6].gt ) { return 0x821B6560;  }
		/* 821B64D4h case   11:*/		return 0x821B64D8;
		  /* 821B64D8h */ case   12:  		/* cmpwi CR6, R11, 66 */
		/* 821B64D8h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000042);
		/* 821B64D8h case   12:*/		return 0x821B64DC;
		  /* 821B64DCh */ case   13:  		/* bc 4, CR6_GT, 72 */
		/* 821B64DCh case   13:*/		if ( !regs.CR[6].gt ) { return 0x821B6524;  }
		/* 821B64DCh case   13:*/		return 0x821B64E0;
		  /* 821B64E0h */ case   14:  		/* cmpwi CR6, R11, 95 */
		/* 821B64E0h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000005F);
		/* 821B64E0h case   14:*/		return 0x821B64E4;
		  /* 821B64E4h */ case   15:  		/* bc 4, CR6_GT, 124 */
		/* 821B64E4h case   15:*/		if ( !regs.CR[6].gt ) { return 0x821B6560;  }
		/* 821B64E4h case   15:*/		return 0x821B64E8;
		  /* 821B64E8h */ case   16:  		/* cmpwi CR6, R11, 97 */
		/* 821B64E8h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000061);
		/* 821B64E8h case   16:*/		return 0x821B64EC;
		  /* 821B64ECh */ case   17:  		/* bc 12, CR6_GT, 116 */
		/* 821B64ECh case   17:*/		if ( regs.CR[6].gt ) { return 0x821B6560;  }
		/* 821B64ECh case   17:*/		return 0x821B64F0;
		  /* 821B64F0h */ case   18:  		/* lwz R11, <#[R4 + 16]> */
		/* 821B64F0h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000010) );
		/* 821B64F0h case   18:*/		return 0x821B64F4;
		  /* 821B64F4h */ case   19:  		/* li R10, 1 */
		/* 821B64F4h case   19:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 821B64F4h case   19:*/		return 0x821B64F8;
		  /* 821B64F8h */ case   20:  		/* rlwimi R11, R10, 18, 13, 15 */
		/* 821B64F8h case   20:*/		cpu::op::rlwimi<0,18,13,15>(regs,&regs.R11,regs.R10);
		/* 821B64F8h case   20:*/		return 0x821B64FC;
		  /* 821B64FCh */ case   21:  		/* stw R11, <#[R4 + 16]> */
		/* 821B64FCh case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000010) );
		/* 821B64FCh case   21:*/		return 0x821B6500;
		  /* 821B6500h */ case   22:  		/* lhz R10, <#[R4 + 16]> */
		/* 821B6500h case   22:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000010) );
		/* 821B6500h case   22:*/		return 0x821B6504;
		  /* 821B6504h */ case   23:  		/* lwz R11, <#[R3 + 116]> */
		/* 821B6504h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000074) );
		/* 821B6504h case   23:*/		return 0x821B6508;
		  /* 821B6508h */ case   24:  		/* rlwinm R10, R10, 0, 29, 31 */
		/* 821B6508h case   24:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R10,regs.R10);
		/* 821B6508h case   24:*/		return 0x821B650C;
		  /* 821B650Ch */ case   25:  		/* addi R11, R11, 1 */
		/* 821B650Ch case   25:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821B650Ch case   25:*/		return 0x821B6510;
		  /* 821B6510h */ case   26:  		/* add R10, R10, R11 */
		/* 821B6510h case   26:*/		cpu::op::add<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 821B6510h case   26:*/		return 0x821B6514;
		  /* 821B6514h */ case   27:  		/* cmplwi CR6, R10, 65535 */
		/* 821B6514h case   27:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000FFFF);
		/* 821B6514h case   27:*/		return 0x821B6518;
		  /* 821B6518h */ case   28:  		/* bc 4, CR6_GT, 152 */
		/* 821B6518h case   28:*/		if ( !regs.CR[6].gt ) { return 0x821B65B0;  }
		/* 821B6518h case   28:*/		return 0x821B651C;
		  /* 821B651Ch */ case   29:  		/* li R4, 3528 */
		/* 821B651Ch case   29:*/		cpu::op::li<0>(regs,&regs.R4,0xDC8);
		/* 821B651Ch case   29:*/		return 0x821B6520;
		  /* 821B6520h */ case   30:  		/* b -411320 */
		/* 821B6520h case   30:*/		return 0x82151E68;
		/* 821B6520h case   30:*/		return 0x821B6524;
	}
	return 0x821B6524;
} // Block from 821B64A8h-821B6524h (31 instructions)

//////////////////////////////////////////////////////
// Block at 821B6524h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6524( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6524) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6524);
		  /* 821B6524h */ case    0:  		/* rlwinm R11, R10, 0, 27, 30 */
		/* 821B6524h case    0:*/		cpu::op::rlwinm<0,0,27,30>(regs,&regs.R11,regs.R10);
		/* 821B6524h case    0:*/		return 0x821B6528;
		  /* 821B6528h */ case    1:  		/* cmplwi CR6, R11, 2 */
		/* 821B6528h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 821B6528h case    1:*/		return 0x821B652C;
		  /* 821B652Ch */ case    2:  		/* bc 4, CR6_GT, 12 */
		/* 821B652Ch case    2:*/		if ( !regs.CR[6].gt ) { return 0x821B6538;  }
		/* 821B652Ch case    2:*/		return 0x821B6530;
		  /* 821B6530h */ case    3:  		/* li R4, 4800 */
		/* 821B6530h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 821B6530h case    3:*/		return 0x821B6534;
		  /* 821B6534h */ case    4:  		/* b -411340 */
		/* 821B6534h case    4:*/		return 0x82151E68;
		/* 821B6534h case    4:*/		return 0x821B6538;
	}
	return 0x821B6538;
} // Block from 821B6524h-821B6538h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821B6538h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6538( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6538) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6538);
		  /* 821B6538h */ case    0:  		/* lwz R11, <#[R4 + 16]> */
		/* 821B6538h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000010) );
		/* 821B6538h case    0:*/		return 0x821B653C;
		  /* 821B653Ch */ case    1:  		/* li R10, 1 */
		/* 821B653Ch case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 821B653Ch case    1:*/		return 0x821B6540;
		  /* 821B6540h */ case    2:  		/* rlwimi R11, R10, 16, 13, 15 */
		/* 821B6540h case    2:*/		cpu::op::rlwimi<0,16,13,15>(regs,&regs.R11,regs.R10);
		/* 821B6540h case    2:*/		return 0x821B6544;
		  /* 821B6544h */ case    3:  		/* b -72 */
		/* 821B6544h case    3:*/		return 0x821B64FC;
		/* 821B6544h case    3:*/		return 0x821B6548;
	}
	return 0x821B6548;
} // Block from 821B6538h-821B6548h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821B6548h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6548( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6548) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6548);
		  /* 821B6548h */ case    0:  		/* cmpwi CR6, R11, 110 */
		/* 821B6548h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000006E);
		/* 821B6548h case    0:*/		return 0x821B654C;
		  /* 821B654Ch */ case    1:  		/* bc 12, CR6_EQ, -92 */
		/* 821B654Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x821B64F0;  }
		/* 821B654Ch case    1:*/		return 0x821B6550;
		  /* 821B6550h */ case    2:  		/* cmpwi CR6, R11, 113 */
		/* 821B6550h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000071);
		/* 821B6550h case    2:*/		return 0x821B6554;
		  /* 821B6554h */ case    3:  		/* bc 12, CR6_EQ, 84 */
		/* 821B6554h case    3:*/		if ( regs.CR[6].eq ) { return 0x821B65A8;  }
		/* 821B6554h case    3:*/		return 0x821B6558;
		  /* 821B6558h */ case    4:  		/* cmpwi CR6, R11, 124 */
		/* 821B6558h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000007C);
		/* 821B6558h case    4:*/		return 0x821B655C;
		  /* 821B655Ch */ case    5:  		/* bc 12, CR6_EQ, 76 */
		/* 821B655Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x821B65A8;  }
		/* 821B655Ch case    5:*/		return 0x821B6560;
	}
	return 0x821B6560;
} // Block from 821B6548h-821B6560h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821B6560h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6560( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6560) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6560);
		  /* 821B6560h */ case    0:  		/* cmplwi CR6, R11, 32 */
		/* 821B6560h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000020);
		/* 821B6560h case    0:*/		return 0x821B6564;
		  /* 821B6564h */ case    1:  		/* bc 12, CR6_LT, 16 */
		/* 821B6564h case    1:*/		if ( regs.CR[6].lt ) { return 0x821B6574;  }
		/* 821B6564h case    1:*/		return 0x821B6568;
		  /* 821B6568h */ case    2:  		/* cmplwi CR6, R11, 82 */
		/* 821B6568h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000052);
		/* 821B6568h case    2:*/		return 0x821B656C;
		  /* 821B656Ch */ case    3:  		/* li R11, 1 */
		/* 821B656Ch case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821B656Ch case    3:*/		return 0x821B6570;
		  /* 821B6570h */ case    4:  		/* bc 4, CR6_GT, 8 */
		/* 821B6570h case    4:*/		if ( !regs.CR[6].gt ) { return 0x821B6578;  }
		/* 821B6570h case    4:*/		return 0x821B6574;
	}
	return 0x821B6574;
} // Block from 821B6560h-821B6574h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821B6574h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6574( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6574) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6574);
		  /* 821B6574h */ case    0:  		/* li R11, 0 */
		/* 821B6574h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821B6574h case    0:*/		return 0x821B6578;
	}
	return 0x821B6578;
} // Block from 821B6574h-821B6578h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B6578h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6578( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6578) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6578);
		  /* 821B6578h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821B6578h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821B6578h case    0:*/		return 0x821B657C;
		  /* 821B657Ch */ case    1:  		/* bc 4, CR0_EQ, -140 */
		/* 821B657Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x821B64F0;  }
		/* 821B657Ch case    1:*/		return 0x821B6580;
		  /* 821B6580h */ case    2:  		/* rlwinm. R11, R10, 31, 28, 31 */
		/* 821B6580h case    2:*/		cpu::op::rlwinm<1,31,28,31>(regs,&regs.R11,regs.R10);
		/* 821B6580h case    2:*/		return 0x821B6584;
		  /* 821B6584h */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 821B6584h case    3:*/		if ( regs.CR[0].eq ) { return 0x821B6594;  }
		/* 821B6584h case    3:*/		return 0x821B6588;
		  /* 821B6588h */ case    4:  		/* cntlzw R11, R11 */
		/* 821B6588h case    4:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 821B6588h case    4:*/		return 0x821B658C;
		  /* 821B658Ch */ case    5:  		/* subfic R11, R11, 32 */
		/* 821B658Ch case    5:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x20);
		/* 821B658Ch case    5:*/		return 0x821B6590;
		  /* 821B6590h */ case    6:  		/* b 8 */
		/* 821B6590h case    6:*/		return 0x821B6598;
		/* 821B6590h case    6:*/		return 0x821B6594;
	}
	return 0x821B6594;
} // Block from 821B6578h-821B6594h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821B6594h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6594( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6594) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6594);
		  /* 821B6594h */ case    0:  		/* li R11, 0 */
		/* 821B6594h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821B6594h case    0:*/		return 0x821B6598;
	}
	return 0x821B6598;
} // Block from 821B6594h-821B6598h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B6598h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6598( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6598) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6598);
		  /* 821B6598h */ case    0:  		/* lwz R10, <#[R4 + 16]> */
		/* 821B6598h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000010) );
		/* 821B6598h case    0:*/		return 0x821B659C;
		  /* 821B659Ch */ case    1:  		/* rlwimi R10, R11, 16, 13, 15 */
		/* 821B659Ch case    1:*/		cpu::op::rlwimi<0,16,13,15>(regs,&regs.R10,regs.R11);
		/* 821B659Ch case    1:*/		return 0x821B65A0;
		  /* 821B65A0h */ case    2:  		/* stw R10, <#[R4 + 16]> */
		/* 821B65A0h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R4 + 0x00000010) );
		/* 821B65A0h case    2:*/		return 0x821B65A4;
		  /* 821B65A4h */ case    3:  		/* b -164 */
		/* 821B65A4h case    3:*/		return 0x821B6500;
		/* 821B65A4h case    3:*/		return 0x821B65A8;
	}
	return 0x821B65A8;
} // Block from 821B6598h-821B65A8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821B65A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B65A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B65A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B65A8);
		  /* 821B65A8h */ case    0:  		/* li R4, 4800 */
		/* 821B65A8h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 821B65A8h case    0:*/		return 0x821B65AC;
		  /* 821B65ACh */ case    1:  		/* b -411460 */
		/* 821B65ACh case    1:*/		return 0x82151E68;
		/* 821B65ACh case    1:*/		return 0x821B65B0;
	}
	return 0x821B65B0;
} // Block from 821B65A8h-821B65B0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B65B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B65B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B65B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B65B0);
		  /* 821B65B0h */ case    0:  		/* addi R10, R10, -1 */
		/* 821B65B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 821B65B0h case    0:*/		return 0x821B65B4;
		  /* 821B65B4h */ case    1:  		/* stw R10, <#[R3 + 116]> */
		/* 821B65B4h case    1:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000074) );
		/* 821B65B4h case    1:*/		return 0x821B65B8;
		  /* 821B65B8h */ case    2:  		/* lwz R10, <#[R4 + 8]> */
		/* 821B65B8h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000008) );
		/* 821B65B8h case    2:*/		return 0x821B65BC;
		  /* 821B65BCh */ case    3:  		/* oris R10, R10, 128 */
		/* 821B65BCh case    3:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x80);
		/* 821B65BCh case    3:*/		return 0x821B65C0;
		  /* 821B65C0h */ case    4:  		/* stw R10, <#[R4 + 8]> */
		/* 821B65C0h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R4 + 0x00000008) );
		/* 821B65C0h case    4:*/		return 0x821B65C4;
		  /* 821B65C4h */ case    5:  		/* sth R11, <#[R4 + 18]> */
		/* 821B65C4h case    5:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R4 + 0x00000012) );
		/* 821B65C4h case    5:*/		return 0x821B65C8;
		  /* 821B65C8h */ case    6:  		/* bclr 20, CR0_LT */
		/* 821B65C8h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821B65C8h case    6:*/		return 0x821B65CC;
	}
	return 0x821B65CC;
} // Block from 821B65B0h-821B65CCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 821B65CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B65CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B65CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B65CC);
		  /* 821B65CCh */ case    0:  		/* nop */
		/* 821B65CCh case    0:*/		cpu::op::nop();
		/* 821B65CCh case    0:*/		return 0x821B65D0;
	}
	return 0x821B65D0;
} // Block from 821B65CCh-821B65D0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B65D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B65D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B65D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B65D0);
		  /* 821B65D0h */ case    0:  		/* mfspr R12, LR */
		/* 821B65D0h case    0:*/		regs.R12 = regs.LR;
		/* 821B65D0h case    0:*/		return 0x821B65D4;
		  /* 821B65D4h */ case    1:  		/* bl -1201020 */
		/* 821B65D4h case    1:*/		regs.LR = 0x821B65D8; return 0x82091258;
		/* 821B65D4h case    1:*/		return 0x821B65D8;
		  /* 821B65D8h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821B65D8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821B65D8h case    2:*/		return 0x821B65DC;
		  /* 821B65DCh */ case    3:  		/* mr R11, R4 */
		/* 821B65DCh case    3:*/		regs.R11 = regs.R4;
		/* 821B65DCh case    3:*/		return 0x821B65E0;
		  /* 821B65E0h */ case    4:  		/* mr R29, R7 */
		/* 821B65E0h case    4:*/		regs.R29 = regs.R7;
		/* 821B65E0h case    4:*/		return 0x821B65E4;
		  /* 821B65E4h */ case    5:  		/* li R4, 0 */
		/* 821B65E4h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 821B65E4h case    5:*/		return 0x821B65E8;
		  /* 821B65E8h */ case    6:  		/* li R8, 1 */
		/* 821B65E8h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 821B65E8h case    6:*/		return 0x821B65EC;
		  /* 821B65ECh */ case    7:  		/* li R28, 0 */
		/* 821B65ECh case    7:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 821B65ECh case    7:*/		return 0x821B65F0;
		  /* 821B65F0h */ case    8:  		/* li R31, 0 */
		/* 821B65F0h case    8:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 821B65F0h case    8:*/		return 0x821B65F4;
		  /* 821B65F4h */ case    9:  		/* li R30, 0 */
		/* 821B65F4h case    9:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 821B65F4h case    9:*/		return 0x821B65F8;
		  /* 821B65F8h */ case   10:  		/* cmplwi CR6, R5, 0 */
		/* 821B65F8h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 821B65F8h case   10:*/		return 0x821B65FC;
		  /* 821B65FCh */ case   11:  		/* bc 12, CR6_EQ, 96 */
		/* 821B65FCh case   11:*/		if ( regs.CR[6].eq ) { return 0x821B665C;  }
		/* 821B65FCh case   11:*/		return 0x821B6600;
		  /* 821B6600h */ case   12:  		/* li R10, 0 */
		/* 821B6600h case   12:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821B6600h case   12:*/		return 0x821B6604;
		  /* 821B6604h */ case   13:  		/* mtspr CTR, R5 */
		/* 821B6604h case   13:*/		regs.CTR = regs.R5;
		/* 821B6604h case   13:*/		return 0x821B6608;
		  /* 821B6608h */ case   14:  		/* addi R9, R11, 44 */
		/* 821B6608h case   14:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x2C);
		/* 821B6608h case   14:*/		return 0x821B660C;
		  /* 821B660Ch */ case   15:  		/* and. R11, R8, R6 */
		/* 821B660Ch case   15:*/		cpu::op::and<1>(regs,&regs.R11,regs.R8,regs.R6);
		/* 821B660Ch case   15:*/		return 0x821B6610;
		  /* 821B6610h */ case   16:  		/* bc 12, CR0_EQ, 64 */
		/* 821B6610h case   16:*/		if ( regs.CR[0].eq ) { return 0x821B6650;  }
		/* 821B6610h case   16:*/		return 0x821B6614;
		  /* 821B6614h */ case   17:  		/* lwz R11, <#[R9]> */
		/* 821B6614h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 821B6614h case   17:*/		return 0x821B6618;
		  /* 821B6618h */ case   18:  		/* cmplwi CR6, R4, 0 */
		/* 821B6618h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 821B6618h case   18:*/		return 0x821B661C;
		  /* 821B661Ch */ case   19:  		/* bc 4, CR6_EQ, 16 */
		/* 821B661Ch case   19:*/		if ( !regs.CR[6].eq ) { return 0x821B662C;  }
		/* 821B661Ch case   19:*/		return 0x821B6620;
		  /* 821B6620h */ case   20:  		/* lwz R7, <#[R11]> */
		/* 821B6620h case   20:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821B6620h case   20:*/		return 0x821B6624;
		  /* 821B6624h */ case   21:  		/* lwz R4, <#[R11 + 12]> */
		/* 821B6624h case   21:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x0000000C) );
		/* 821B6624h case   21:*/		return 0x821B6628;
		  /* 821B6628h */ case   22:  		/* rlwinm R28, R7, 0, 27, 31 */
		/* 821B6628h case   22:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R28,regs.R7);
		/* 821B6628h case   22:*/		return 0x821B662C;
	}
	return 0x821B662C;
} // Block from 821B65D0h-821B662Ch (23 instructions)

//////////////////////////////////////////////////////
// Block at 821B662Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B662C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B662C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B662C);
		  /* 821B662Ch */ case    0:  		/* lwz R11, <#[R11]> */
		/* 821B662Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821B662Ch case    0:*/		return 0x821B6630;
		  /* 821B6630h */ case    1:  		/* li R7, 3 */
		/* 821B6630h case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x3);
		/* 821B6630h case    1:*/		return 0x821B6634;
		  /* 821B6634h */ case    2:  		/* addi R31, R31, 1 */
		/* 821B6634h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 821B6634h case    2:*/		return 0x821B6638;
		  /* 821B6638h */ case    3:  		/* slw R7, R7, R10 */
		/* 821B6638h case    3:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R7,regs.R10);
		/* 821B6638h case    3:*/		return 0x821B663C;
		  /* 821B663Ch */ case    4:  		/* rlwinm R11, R11, 27, 30, 31 */
		/* 821B663Ch case    4:*/		cpu::op::rlwinm<0,27,30,31>(regs,&regs.R11,regs.R11);
		/* 821B663Ch case    4:*/		return 0x821B6640;
		  /* 821B6640h */ case    5:  		/* andc R7, R30, R7 */
		/* 821B6640h case    5:*/		cpu::op::andc<0>(regs,&regs.R7,regs.R30,regs.R7);
		/* 821B6640h case    5:*/		return 0x821B6644;
		  /* 821B6644h */ case    6:  		/* slw R11, R11, R10 */
		/* 821B6644h case    6:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821B6644h case    6:*/		return 0x821B6648;
		  /* 821B6648h */ case    7:  		/* or R30, R7, R11 */
		/* 821B6648h case    7:*/		cpu::op::or<0>(regs,&regs.R30,regs.R7,regs.R11);
		/* 821B6648h case    7:*/		return 0x821B664C;
		  /* 821B664Ch */ case    8:  		/* addi R10, R10, 2 */
		/* 821B664Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 821B664Ch case    8:*/		return 0x821B6650;
	}
	return 0x821B6650;
} // Block from 821B662Ch-821B6650h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821B6650h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6650( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6650) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6650);
		  /* 821B6650h */ case    0:  		/* addi R9, R9, 4 */
		/* 821B6650h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 821B6650h case    0:*/		return 0x821B6654;
		  /* 821B6654h */ case    1:  		/* rlwinm R8, R8, 1, 0, 30 */
		/* 821B6654h case    1:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R8,regs.R8);
		/* 821B6654h case    1:*/		return 0x821B6658;
		  /* 821B6658h */ case    2:  		/* bc 16, CR0_LT, -76 */
		/* 821B6658h case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x821B660C;  }
		/* 821B6658h case    2:*/		return 0x821B665C;
	}
	return 0x821B665C;
} // Block from 821B6650h-821B665Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 821B665Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B665C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B665C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B665C);
		  /* 821B665Ch */ case    0:  		/* bl -255580 */
		/* 821B665Ch case    0:*/		regs.LR = 0x821B6660; return 0x82178000;
		/* 821B665Ch case    0:*/		return 0x821B6660;
		  /* 821B6660h */ case    1:  		/* lwz R10, <#[R3]> */
		/* 821B6660h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 821B6660h case    1:*/		return 0x821B6664;
		  /* 821B6664h */ case    2:  		/* add R11, R31, R29 */
		/* 821B6664h case    2:*/		cpu::op::add<0>(regs,&regs.R11,regs.R31,regs.R29);
		/* 821B6664h case    2:*/		return 0x821B6668;
		  /* 821B6668h */ case    3:  		/* cmplwi CR6, R29, 0 */
		/* 821B6668h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 821B6668h case    3:*/		return 0x821B666C;
		  /* 821B666Ch */ case    4:  		/* rlwimi R10, R11, 25, 4, 6 */
		/* 821B666Ch case    4:*/		cpu::op::rlwimi<0,25,4,6>(regs,&regs.R10,regs.R11);
		/* 821B666Ch case    4:*/		return 0x821B6670;
		  /* 821B6670h */ case    5:  		/* stw R10, <#[R3]> */
		/* 821B6670h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 821B6670h case    5:*/		return 0x821B6674;
		  /* 821B6674h */ case    6:  		/* bc 12, CR6_EQ, 16 */
		/* 821B6674h case    6:*/		if ( regs.CR[6].eq ) { return 0x821B6684;  }
		/* 821B6674h case    6:*/		return 0x821B6678;
		  /* 821B6678h */ case    7:  		/* mtspr CTR, R29 */
		/* 821B6678h case    7:*/		regs.CTR = regs.R29;
		/* 821B6678h case    7:*/		return 0x821B667C;
		  /* 821B667Ch */ case    8:  		/* rlwimi R30, R30, 2, 0, 29 */
		/* 821B667Ch case    8:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R30,regs.R30);
		/* 821B667Ch case    8:*/		return 0x821B6680;
		  /* 821B6680h */ case    9:  		/* bc 16, CR0_LT, -4 */
		/* 821B6680h case    9:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x821B667C;  }
		/* 821B6680h case    9:*/		return 0x821B6684;
	}
	return 0x821B6684;
} // Block from 821B665Ch-821B6684h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821B6684h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6684( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6684) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6684);
		  /* 821B6684h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 821B6684h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821B6684h case    0:*/		return 0x821B6688;
		  /* 821B6688h */ case    1:  		/* rlwimi R11, R30, 5, 19, 26 */
		/* 821B6688h case    1:*/		cpu::op::rlwimi<0,5,19,26>(regs,&regs.R11,regs.R30);
		/* 821B6688h case    1:*/		return 0x821B668C;
		  /* 821B668Ch */ case    2:  		/* rlwimi R11, R28, 0, 27, 31 */
		/* 821B668Ch case    2:*/		cpu::op::rlwimi<0,0,27,31>(regs,&regs.R11,regs.R28);
		/* 821B668Ch case    2:*/		return 0x821B6690;
		  /* 821B6690h */ case    3:  		/* stw R11, <#[R3]> */
		/* 821B6690h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821B6690h case    3:*/		return 0x821B6694;
		  /* 821B6694h */ case    4:  		/* addi R1, R1, 128 */
		/* 821B6694h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821B6694h case    4:*/		return 0x821B6698;
		  /* 821B6698h */ case    5:  		/* b -1201136 */
		/* 821B6698h case    5:*/		return 0x820912A8;
		/* 821B6698h case    5:*/		return 0x821B669C;
		  /* 821B669Ch */ case    6:  		/* nop */
		/* 821B669Ch case    6:*/		cpu::op::nop();
		/* 821B669Ch case    6:*/		return 0x821B66A0;
	}
	return 0x821B66A0;
} // Block from 821B6684h-821B66A0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821B66A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B66A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B66A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B66A0);
		  /* 821B66A0h */ case    0:  		/* mfspr R12, LR */
		/* 821B66A0h case    0:*/		regs.R12 = regs.LR;
		/* 821B66A0h case    0:*/		return 0x821B66A4;
		  /* 821B66A4h */ case    1:  		/* bl -1201228 */
		/* 821B66A4h case    1:*/		regs.LR = 0x821B66A8; return 0x82091258;
		/* 821B66A4h case    1:*/		return 0x821B66A8;
		  /* 821B66A8h */ case    2:  		/* lwz R11, <#[R5 + 8]> */
		/* 821B66A8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000008) );
		/* 821B66A8h case    2:*/		return 0x821B66AC;
		  /* 821B66ACh */ case    3:  		/* addi R29, R4, 4 */
		/* 821B66ACh case    3:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R4,0x4);
		/* 821B66ACh case    3:*/		return 0x821B66B0;
		  /* 821B66B0h */ case    4:  		/* rlwinm R30, R11, 13, 29, 31 */
		/* 821B66B0h case    4:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R30,regs.R11);
		/* 821B66B0h case    4:*/		return 0x821B66B4;
		  /* 821B66B4h */ case    5:  		/* lwz R11, <#[R29]> */
		/* 821B66B4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 821B66B4h case    5:*/		return 0x821B66B8;
		  /* 821B66B8h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 821B66B8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821B66B8h case    6:*/		return 0x821B66BC;
		  /* 821B66BCh */ case    7:  		/* bc 12, CR6_EQ, 248 */
		/* 821B66BCh case    7:*/		if ( regs.CR[6].eq ) { return 0x821B67B4;  }
		/* 821B66BCh case    7:*/		return 0x821B66C0;
		  /* 821B66C0h */ case    8:  		/* lwz R10, <#[R11 + 16]> */
		/* 821B66C0h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 821B66C0h case    8:*/		return 0x821B66C4;
		  /* 821B66C4h */ case    9:  		/* cmplwi CR6, R10, 0 */
		/* 821B66C4h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821B66C4h case    9:*/		return 0x821B66C8;
		  /* 821B66C8h */ case   10:  		/* bc 12, CR6_EQ, 216 */
		/* 821B66C8h case   10:*/		if ( regs.CR[6].eq ) { return 0x821B67A0;  }
		/* 821B66C8h case   10:*/		return 0x821B66CC;
		  /* 821B66CCh */ case   11:  		/* lwz R9, <#[R11]> */
		/* 821B66CCh case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821B66CCh case   11:*/		return 0x821B66D0;
		  /* 821B66D0h */ case   12:  		/* rlwinm. R10, R9, 7, 29, 31 */
		/* 821B66D0h case   12:*/		cpu::op::rlwinm<1,7,29,31>(regs,&regs.R10,regs.R9);
		/* 821B66D0h case   12:*/		return 0x821B66D4;
		  /* 821B66D4h */ case   13:  		/* rlwinm R31, R9, 27, 24, 31 */
		/* 821B66D4h case   13:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R31,regs.R9);
		/* 821B66D4h case   13:*/		return 0x821B66D8;
		  /* 821B66D8h */ case   14:  		/* bc 12, CR0_EQ, 132 */
		/* 821B66D8h case   14:*/		if ( regs.CR[0].eq ) { return 0x821B675C;  }
		/* 821B66D8h case   14:*/		return 0x821B66DC;
		  /* 821B66DCh */ case   15:  		/* li R9, 0 */
		/* 821B66DCh case   15:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821B66DCh case   15:*/		return 0x821B66E0;
		  /* 821B66E0h */ case   16:  		/* mtspr CTR, R10 */
		/* 821B66E0h case   16:*/		regs.CTR = regs.R10;
		/* 821B66E0h case   16:*/		return 0x821B66E4;
		  /* 821B66E4h */ case   17:  		/* srw R10, R31, R9 */
		/* 821B66E4h case   17:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R31,regs.R9);
		/* 821B66E4h case   17:*/		return 0x821B66E8;
		  /* 821B66E8h */ case   18:  		/* rlwinm R10, R10, 0, 30, 31 */
		/* 821B66E8h case   18:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R10,regs.R10);
		/* 821B66E8h case   18:*/		return 0x821B66EC;
		  /* 821B66ECh */ case   19:  		/* li R8, 0 */
		/* 821B66ECh case   19:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821B66ECh case   19:*/		return 0x821B66F0;
		  /* 821B66F0h */ case   20:  		/* addi R10, R10, 11 */
		/* 821B66F0h case   20:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xB);
		/* 821B66F0h case   20:*/		return 0x821B66F4;
		  /* 821B66F4h */ case   21:  		/* cmplwi CR6, R30, 0 */
		/* 821B66F4h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821B66F4h case   21:*/		return 0x821B66F8;
		  /* 821B66F8h */ case   22:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821B66F8h case   22:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821B66F8h case   22:*/		return 0x821B66FC;
		  /* 821B66FCh */ case   23:  		/* lwzx R6, <#[R10 + R4]> */
		/* 821B66FCh case   23:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + regs.R4 + 0x00000000) );
		/* 821B66FCh case   23:*/		return 0x821B6700;
		  /* 821B6700h */ case   24:  		/* bc 12, CR6_EQ, 64 */
		/* 821B6700h case   24:*/		if ( regs.CR[6].eq ) { return 0x821B6740;  }
		/* 821B6700h case   24:*/		return 0x821B6704;
		  /* 821B6704h */ case   25:  		/* lwz R3, <#[R6 + 12]> */
		/* 821B6704h case   25:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R6 + 0x0000000C) );
		/* 821B6704h case   25:*/		return 0x821B6708;
		  /* 821B6708h */ case   26:  		/* addi R10, R5, 44 */
		/* 821B6708h case   26:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R5,0x2C);
		/* 821B6708h case   26:*/		return 0x821B670C;
		  /* 821B670Ch */ case   27:  		/* lwz R7, <#[R10]> */
		/* 821B670Ch case   27:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821B670Ch case   27:*/		return 0x821B6710;
		  /* 821B6710h */ case   28:  		/* lwz R28, <#[R7 + 12]> */
		/* 821B6710h case   28:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R7 + 0x0000000C) );
		/* 821B6710h case   28:*/		return 0x821B6714;
		  /* 821B6714h */ case   29:  		/* cmpw CR6, R3, R28 */
		/* 821B6714h case   29:*/		cpu::op::cmpw<6>(regs,regs.R3,regs.R28);
		/* 821B6714h case   29:*/		return 0x821B6718;
		  /* 821B6718h */ case   30:  		/* bc 4, CR6_EQ, 24 */
		/* 821B6718h case   30:*/		if ( !regs.CR[6].eq ) { return 0x821B6730;  }
		/* 821B6718h case   30:*/		return 0x821B671C;
		  /* 821B671Ch */ case   31:  		/* lwz R7, <#[R7]> */
		/* 821B671Ch case   31:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000000) );
		/* 821B671Ch case   31:*/		return 0x821B6720;
		  /* 821B6720h */ case   32:  		/* lwz R28, <#[R6]> */
		/* 821B6720h case   32:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R6 + 0x00000000) );
		/* 821B6720h case   32:*/		return 0x821B6724;
		  /* 821B6724h */ case   33:  		/* xor R7, R7, R28 */
		/* 821B6724h case   33:*/		cpu::op::xor<0>(regs,&regs.R7,regs.R7,regs.R28);
		/* 821B6724h case   33:*/		return 0x821B6728;
		  /* 821B6728h */ case   34:  		/* rlwinm. R7, R7, 0, 25, 26 */
		/* 821B6728h case   34:*/		cpu::op::rlwinm<1,0,25,26>(regs,&regs.R7,regs.R7);
		/* 821B6728h case   34:*/		return 0x821B672C;
		  /* 821B672Ch */ case   35:  		/* bc 12, CR0_EQ, 20 */
		/* 821B672Ch case   35:*/		if ( regs.CR[0].eq ) { return 0x821B6740;  }
		/* 821B672Ch case   35:*/		return 0x821B6730;
	}
	return 0x821B6730;
} // Block from 821B66A0h-821B6730h (36 instructions)

//////////////////////////////////////////////////////
// Block at 821B6730h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6730( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6730) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6730);
		  /* 821B6730h */ case    0:  		/* addi R8, R8, 1 */
		/* 821B6730h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821B6730h case    0:*/		return 0x821B6734;
		  /* 821B6734h */ case    1:  		/* addi R10, R10, 4 */
		/* 821B6734h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821B6734h case    1:*/		return 0x821B6738;
		  /* 821B6738h */ case    2:  		/* cmplw CR6, R8, R30 */
		/* 821B6738h case    2:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R30);
		/* 821B6738h case    2:*/		return 0x821B673C;
		  /* 821B673Ch */ case    3:  		/* bc 12, CR6_LT, -48 */
		/* 821B673Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x821B670C;  }
		/* 821B673Ch case    3:*/		return 0x821B6740;
	}
	return 0x821B6740;
} // Block from 821B6730h-821B6740h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821B6740h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6740( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6740) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6740);
		  /* 821B6740h */ case    0:  		/* li R10, 3 */
		/* 821B6740h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 821B6740h case    0:*/		return 0x821B6744;
		  /* 821B6744h */ case    1:  		/* slw R8, R8, R9 */
		/* 821B6744h case    1:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R8,regs.R9);
		/* 821B6744h case    1:*/		return 0x821B6748;
		  /* 821B6748h */ case    2:  		/* slw R10, R10, R9 */
		/* 821B6748h case    2:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 821B6748h case    2:*/		return 0x821B674C;
		  /* 821B674Ch */ case    3:  		/* andc R10, R31, R10 */
		/* 821B674Ch case    3:*/		cpu::op::andc<0>(regs,&regs.R10,regs.R31,regs.R10);
		/* 821B674Ch case    3:*/		return 0x821B6750;
		  /* 821B6750h */ case    4:  		/* addi R9, R9, 2 */
		/* 821B6750h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x2);
		/* 821B6750h case    4:*/		return 0x821B6754;
		  /* 821B6754h */ case    5:  		/* or R31, R10, R8 */
		/* 821B6754h case    5:*/		cpu::op::or<0>(regs,&regs.R31,regs.R10,regs.R8);
		/* 821B6754h case    5:*/		return 0x821B6758;
		  /* 821B6758h */ case    6:  		/* bc 16, CR0_LT, -116 */
		/* 821B6758h case    6:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x821B66E4;  }
		/* 821B6758h case    6:*/		return 0x821B675C;
	}
	return 0x821B675C;
} // Block from 821B6740h-821B675Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 821B675Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B675C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B675C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B675C);
		  /* 821B675Ch */ case    0:  		/* lwz R10, <#[R11 + 12]> */
		/* 821B675Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 821B675Ch case    0:*/		return 0x821B6760;
		  /* 821B6760h */ case    1:  		/* addi R10, R10, 4 */
		/* 821B6760h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821B6760h case    1:*/		return 0x821B6764;
		  /* 821B6764h */ case    2:  		/* lwz R9, <#[R10]> */
		/* 821B6764h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821B6764h case    2:*/		return 0x821B6768;
		  /* 821B6768h */ case    3:  		/* b 12 */
		/* 821B6768h case    3:*/		return 0x821B6774;
		/* 821B6768h case    3:*/		return 0x821B676C;
		  /* 821B676Ch */ case    4:  		/* addi R10, R9, 8 */
		/* 821B676Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x8);
		/* 821B676Ch case    4:*/		return 0x821B6770;
		  /* 821B6770h */ case    5:  		/* lwz R9, <#[R9 + 8]> */
		/* 821B6770h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 821B6770h case    5:*/		return 0x821B6774;
	}
	return 0x821B6774;
} // Block from 821B675Ch-821B6774h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821B6774h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6774( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6774) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6774);
		  /* 821B6774h */ case    0:  		/* cmplw CR6, R9, R11 */
		/* 821B6774h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 821B6774h case    0:*/		return 0x821B6778;
		  /* 821B6778h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 821B6778h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821B676C;  }
		/* 821B6778h case    1:*/		return 0x821B677C;
		  /* 821B677Ch */ case    2:  		/* lwz R9, <#[R11 + 8]> */
		/* 821B677Ch case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 821B677Ch case    2:*/		return 0x821B6780;
		  /* 821B6780h */ case    3:  		/* stw R9, <#[R10]> */
		/* 821B6780h case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821B6780h case    3:*/		return 0x821B6784;
		  /* 821B6784h */ case    4:  		/* lwz R10, <#[R5 + 4]> */
		/* 821B6784h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000004) );
		/* 821B6784h case    4:*/		return 0x821B6788;
		  /* 821B6788h */ case    5:  		/* stw R10, <#[R11 + 8]> */
		/* 821B6788h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821B6788h case    5:*/		return 0x821B678C;
		  /* 821B678Ch */ case    6:  		/* stw R11, <#[R5 + 4]> */
		/* 821B678Ch case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R5 + 0x00000004) );
		/* 821B678Ch case    6:*/		return 0x821B6790;
		  /* 821B6790h */ case    7:  		/* lwz R10, <#[R11]> */
		/* 821B6790h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821B6790h case    7:*/		return 0x821B6794;
		  /* 821B6794h */ case    8:  		/* rlwimi R10, R31, 5, 19, 26 */
		/* 821B6794h case    8:*/		cpu::op::rlwimi<0,5,19,26>(regs,&regs.R10,regs.R31);
		/* 821B6794h case    8:*/		return 0x821B6798;
		  /* 821B6798h */ case    9:  		/* stw R5, <#[R11 + 12]> */
		/* 821B6798h case    9:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R11 + 0x0000000C) );
		/* 821B6798h case    9:*/		return 0x821B679C;
		  /* 821B679Ch */ case   10:  		/* stw R10, <#[R11]> */
		/* 821B679Ch case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821B679Ch case   10:*/		return 0x821B67A0;
	}
	return 0x821B67A0;
} // Block from 821B6774h-821B67A0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821B67A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B67A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B67A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B67A0);
		  /* 821B67A0h */ case    0:  		/* lwz R10, <#[R29]> */
		/* 821B67A0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 821B67A0h case    0:*/		return 0x821B67A4;
		  /* 821B67A4h */ case    1:  		/* cmplw CR6, R10, R11 */
		/* 821B67A4h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 821B67A4h case    1:*/		return 0x821B67A8;
		  /* 821B67A8h */ case    2:  		/* bc 4, CR6_EQ, -244 */
		/* 821B67A8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821B66B4;  }
		/* 821B67A8h case    2:*/		return 0x821B67AC;
		  /* 821B67ACh */ case    3:  		/* addi R29, R11, 8 */
		/* 821B67ACh case    3:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R11,0x8);
		/* 821B67ACh case    3:*/		return 0x821B67B0;
		  /* 821B67B0h */ case    4:  		/* b -252 */
		/* 821B67B0h case    4:*/		return 0x821B66B4;
		/* 821B67B0h case    4:*/		return 0x821B67B4;
	}
	return 0x821B67B4;
} // Block from 821B67A0h-821B67B4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821B67B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B67B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B67B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B67B4);
		  /* 821B67B4h */ case    0:  		/* b -1201420 */
		/* 821B67B4h case    0:*/		return 0x820912A8;
		/* 821B67B4h case    0:*/		return 0x821B67B8;
	}
	return 0x821B67B8;
} // Block from 821B67B4h-821B67B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B67B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B67B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B67B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B67B8);
		  /* 821B67B8h */ case    0:  		/* std R30, <#[R1 - 16]> */
		/* 821B67B8h case    0:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821B67B8h case    0:*/		return 0x821B67BC;
		  /* 821B67BCh */ case    1:  		/* std R31, <#[R1 - 8]> */
		/* 821B67BCh case    1:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821B67BCh case    1:*/		return 0x821B67C0;
		  /* 821B67C0h */ case    2:  		/* lwz R9, <#[R5 + 4]> */
		/* 821B67C0h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R5 + 0x00000004) );
		/* 821B67C0h case    2:*/		return 0x821B67C4;
		  /* 821B67C4h */ case    3:  		/* cmplwi CR6, R9, 0 */
		/* 821B67C4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 821B67C4h case    3:*/		return 0x821B67C8;
		  /* 821B67C8h */ case    4:  		/* bc 12, CR6_EQ, 180 */
		/* 821B67C8h case    4:*/		if ( regs.CR[6].eq ) { return 0x821B687C;  }
		/* 821B67C8h case    4:*/		return 0x821B67CC;
		  /* 821B67CCh */ case    5:  		/* lwz R3, <#[R9 + 16]> */
		/* 821B67CCh case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R9 + 0x00000010) );
		/* 821B67CCh case    5:*/		return 0x821B67D0;
		  /* 821B67D0h */ case    6:  		/* cmplwi CR6, R3, 0 */
		/* 821B67D0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 821B67D0h case    6:*/		return 0x821B67D4;
		  /* 821B67D4h */ case    7:  		/* bc 12, CR6_EQ, 160 */
		/* 821B67D4h case    7:*/		if ( regs.CR[6].eq ) { return 0x821B6874;  }
		/* 821B67D4h case    7:*/		return 0x821B67D8;
		  /* 821B67D8h */ case    8:  		/* lwz R10, <#[R9]> */
		/* 821B67D8h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 821B67D8h case    8:*/		return 0x821B67DC;
		  /* 821B67DCh */ case    9:  		/* rlwinm. R11, R10, 0, 4, 6 */
		/* 821B67DCh case    9:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R10);
		/* 821B67DCh case    9:*/		return 0x821B67E0;
		  /* 821B67E0h */ case   10:  		/* bc 12, CR0_EQ, 148 */
		/* 821B67E0h case   10:*/		if ( regs.CR[0].eq ) { return 0x821B6874;  }
		/* 821B67E0h case   10:*/		return 0x821B67E4;
		  /* 821B67E4h */ case   11:  		/* lwz R11, <#[R3 + 8]> */
		/* 821B67E4h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821B67E4h case   11:*/		return 0x821B67E8;
		  /* 821B67E8h */ case   12:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821B67E8h case   12:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821B67E8h case   12:*/		return 0x821B67EC;
		  /* 821B67ECh */ case   13:  		/* cmplwi CR6, R11, 14336 */
		/* 821B67ECh case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003800);
		/* 821B67ECh case   13:*/		return 0x821B67F0;
		  /* 821B67F0h */ case   14:  		/* bc 4, CR6_EQ, 132 */
		/* 821B67F0h case   14:*/		if ( !regs.CR[6].eq ) { return 0x821B6874;  }
		/* 821B67F0h case   14:*/		return 0x821B67F4;
		  /* 821B67F4h */ case   15:  		/* lwz R11, <#[R3 + 28]> */
		/* 821B67F4h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000001C) );
		/* 821B67F4h case   15:*/		return 0x821B67F8;
		  /* 821B67F8h */ case   16:  		/* cmplw CR6, R11, R4 */
		/* 821B67F8h case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R4);
		/* 821B67F8h case   16:*/		return 0x821B67FC;
		  /* 821B67FCh */ case   17:  		/* bc 4, CR6_EQ, 120 */
		/* 821B67FCh case   17:*/		if ( !regs.CR[6].eq ) { return 0x821B6874;  }
		/* 821B67FCh case   17:*/		return 0x821B6800;
		  /* 821B6800h */ case   18:  		/* lwz R11, <#[R5 + 28]> */
		/* 821B6800h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x0000001C) );
		/* 821B6800h case   18:*/		return 0x821B6804;
		  /* 821B6804h */ case   19:  		/* li R8, 1 */
		/* 821B6804h case   19:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 821B6804h case   19:*/		return 0x821B6808;
		  /* 821B6808h */ case   20:  		/* lwz R31, <#[R4 + 40]> */
		/* 821B6808h case   20:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R4 + 0x00000028) );
		/* 821B6808h case   20:*/		return 0x821B680C;
		  /* 821B680Ch */ case   21:  		/* lwz R11, <#[R11 + 48]> */
		/* 821B680Ch case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 821B680Ch case   21:*/		return 0x821B6810;
		  /* 821B6810h */ case   22:  		/* rlwinm R30, R11, 0, 13, 31 */
		/* 821B6810h case   22:*/		cpu::op::rlwinm<0,0,13,31>(regs,&regs.R30,regs.R11);
		/* 821B6810h case   22:*/		return 0x821B6814;
		  /* 821B6814h */ case   23:  		/* rlwinm R11, R30, 27, 5, 31 */
		/* 821B6814h case   23:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R30);
		/* 821B6814h case   23:*/		return 0x821B6818;
		  /* 821B6818h */ case   24:  		/* rlwinm R30, R30, 0, 27, 31 */
		/* 821B6818h case   24:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R30,regs.R30);
		/* 821B6818h case   24:*/		return 0x821B681C;
		  /* 821B681Ch */ case   25:  		/* addi R11, R11, 1 */
		/* 821B681Ch case   25:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821B681Ch case   25:*/		return 0x821B6820;
		  /* 821B6820h */ case   26:  		/* slw R8, R8, R30 */
		/* 821B6820h case   26:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R8,regs.R30);
		/* 821B6820h case   26:*/		return 0x821B6824;
		  /* 821B6824h */ case   27:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821B6824h case   27:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821B6824h case   27:*/		return 0x821B6828;
		  /* 821B6828h */ case   28:  		/* lwzx R11, <#[R11 + R31]> */
		/* 821B6828h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 821B6828h case   28:*/		return 0x821B682C;
		  /* 821B682Ch */ case   29:  		/* and. R11, R11, R8 */
		/* 821B682Ch case   29:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R8);
		/* 821B682Ch case   29:*/		return 0x821B6830;
		  /* 821B6830h */ case   30:  		/* bc 12, CR0_EQ, 44 */
		/* 821B6830h case   30:*/		if ( regs.CR[0].eq ) { return 0x821B685C;  }
		/* 821B6830h case   30:*/		return 0x821B6834;
		  /* 821B6834h */ case   31:  		/* lwz R11, <#[R3]> */
		/* 821B6834h case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821B6834h case   31:*/		return 0x821B6838;
		  /* 821B6838h */ case   32:  		/* cmplwi CR6, R11, 0 */
		/* 821B6838h case   32:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821B6838h case   32:*/		return 0x821B683C;
		  /* 821B683Ch */ case   33:  		/* bc 12, CR6_EQ, 20 */
		/* 821B683Ch case   33:*/		if ( regs.CR[6].eq ) { return 0x821B6850;  }
		/* 821B683Ch case   33:*/		return 0x821B6840;
		  /* 821B6840h */ case   34:  		/* lwz R11, <#[R11 + 4]> */
		/* 821B6840h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821B6840h case   34:*/		return 0x821B6844;
		  /* 821B6844h */ case   35:  		/* cmplwi CR6, R11, 0 */
		/* 821B6844h case   35:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821B6844h case   35:*/		return 0x821B6848;
		  /* 821B6848h */ case   36:  		/* li R11, 1 */
		/* 821B6848h case   36:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821B6848h case   36:*/		return 0x821B684C;
		  /* 821B684Ch */ case   37:  		/* bc 4, CR6_EQ, 8 */
		/* 821B684Ch case   37:*/		if ( !regs.CR[6].eq ) { return 0x821B6854;  }
		/* 821B684Ch case   37:*/		return 0x821B6850;
	}
	return 0x821B6850;
} // Block from 821B67B8h-821B6850h (38 instructions)

//////////////////////////////////////////////////////
// Block at 821B6850h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6850( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6850) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6850);
		  /* 821B6850h */ case    0:  		/* li R11, 0 */
		/* 821B6850h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821B6850h case    0:*/		return 0x821B6854;
	}
	return 0x821B6854;
} // Block from 821B6850h-821B6854h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B6854h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6854( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6854) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6854);
		  /* 821B6854h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821B6854h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821B6854h case    0:*/		return 0x821B6858;
		  /* 821B6858h */ case    1:  		/* bc 4, CR0_EQ, 28 */
		/* 821B6858h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821B6874;  }
		/* 821B6858h case    1:*/		return 0x821B685C;
	}
	return 0x821B685C;
} // Block from 821B6854h-821B685Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B685Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B685C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B685C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B685C);
		  /* 821B685Ch */ case    0:  		/* rlwinm R11, R10, 27, 30, 31 */
		/* 821B685Ch case    0:*/		cpu::op::rlwinm<0,27,30,31>(regs,&regs.R11,regs.R10);
		/* 821B685Ch case    0:*/		return 0x821B6860;
		  /* 821B6860h */ case    1:  		/* cmpw CR6, R11, R6 */
		/* 821B6860h case    1:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R6);
		/* 821B6860h case    1:*/		return 0x821B6864;
		  /* 821B6864h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 821B6864h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821B6874;  }
		/* 821B6864h case    2:*/		return 0x821B6868;
		  /* 821B6868h */ case    3:  		/* rlwinm R11, R10, 0, 27, 31 */
		/* 821B6868h case    3:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R10);
		/* 821B6868h case    3:*/		return 0x821B686C;
		  /* 821B686Ch */ case    4:  		/* cmplw CR6, R11, R7 */
		/* 821B686Ch case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R7);
		/* 821B686Ch case    4:*/		return 0x821B6870;
		  /* 821B6870h */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 821B6870h case    5:*/		if ( regs.CR[6].eq ) { return 0x821B6880;  }
		/* 821B6870h case    5:*/		return 0x821B6874;
	}
	return 0x821B6874;
} // Block from 821B685Ch-821B6874h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821B6874h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6874( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6874) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6874);
		  /* 821B6874h */ case    0:  		/* lwz R9, <#[R9 + 8]> */
		/* 821B6874h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 821B6874h case    0:*/		return 0x821B6878;
		  /* 821B6878h */ case    1:  		/* b -180 */
		/* 821B6878h case    1:*/		return 0x821B67C4;
		/* 821B6878h case    1:*/		return 0x821B687C;
	}
	return 0x821B687C;
} // Block from 821B6874h-821B687Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B687Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B687C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B687C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B687C);
		  /* 821B687Ch */ case    0:  		/* li R3, 0 */
		/* 821B687Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821B687Ch case    0:*/		return 0x821B6880;
	}
	return 0x821B6880;
} // Block from 821B687Ch-821B6880h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B6880h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6880( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6880) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6880);
		  /* 821B6880h */ case    0:  		/* ld R30, <#[R1 - 16]> */
		/* 821B6880h case    0:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821B6880h case    0:*/		return 0x821B6884;
		  /* 821B6884h */ case    1:  		/* ld R31, <#[R1 - 8]> */
		/* 821B6884h case    1:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821B6884h case    1:*/		return 0x821B6888;
		  /* 821B6888h */ case    2:  		/* bclr 20, CR0_LT */
		/* 821B6888h case    2:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821B6888h case    2:*/		return 0x821B688C;
	}
	return 0x821B688C;
} // Block from 821B6880h-821B688Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 821B688Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B688C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B688C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B688C);
		  /* 821B688Ch */ case    0:  		/* nop */
		/* 821B688Ch case    0:*/		cpu::op::nop();
		/* 821B688Ch case    0:*/		return 0x821B6890;
	}
	return 0x821B6890;
} // Block from 821B688Ch-821B6890h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B6890h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6890( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6890) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6890);
		  /* 821B6890h */ case    0:  		/* mfspr R12, LR */
		/* 821B6890h case    0:*/		regs.R12 = regs.LR;
		/* 821B6890h case    0:*/		return 0x821B6894;
		  /* 821B6894h */ case    1:  		/* bl -1201732 */
		/* 821B6894h case    1:*/		regs.LR = 0x821B6898; return 0x82091250;
		/* 821B6894h case    1:*/		return 0x821B6898;
		  /* 821B6898h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 821B6898h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 821B6898h case    2:*/		return 0x821B689C;
		  /* 821B689Ch */ case    3:  		/* mr R27, R3 */
		/* 821B689Ch case    3:*/		regs.R27 = regs.R3;
		/* 821B689Ch case    3:*/		return 0x821B68A0;
		  /* 821B68A0h */ case    4:  		/* mr R29, R5 */
		/* 821B68A0h case    4:*/		regs.R29 = regs.R5;
		/* 821B68A0h case    4:*/		return 0x821B68A4;
		  /* 821B68A4h */ case    5:  		/* mr R28, R6 */
		/* 821B68A4h case    5:*/		regs.R28 = regs.R6;
		/* 821B68A4h case    5:*/		return 0x821B68A8;
		  /* 821B68A8h */ case    6:  		/* mr R30, R7 */
		/* 821B68A8h case    6:*/		regs.R30 = regs.R7;
		/* 821B68A8h case    6:*/		return 0x821B68AC;
		  /* 821B68ACh */ case    7:  		/* rlwinm. R26, R8, 0, 24, 31 */
		/* 821B68ACh case    7:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R26,regs.R8);
		/* 821B68ACh case    7:*/		return 0x821B68B0;
		  /* 821B68B0h */ case    8:  		/* bc 12, CR0_EQ, 244 */
		/* 821B68B0h case    8:*/		if ( regs.CR[0].eq ) { return 0x821B69A4;  }
		/* 821B68B0h case    8:*/		return 0x821B68B4;
		  /* 821B68B4h */ case    9:  		/* lwz R11, <#[R5 + 8]> */
		/* 821B68B4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000008) );
		/* 821B68B4h case    9:*/		return 0x821B68B8;
		  /* 821B68B8h */ case   10:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821B68B8h case   10:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821B68B8h case   10:*/		return 0x821B68BC;
		  /* 821B68BCh */ case   11:  		/* cmplwi CR6, R11, 14080 */
		/* 821B68BCh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003700);
		/* 821B68BCh case   11:*/		return 0x821B68C0;
		  /* 821B68C0h */ case   12:  		/* bc 4, CR6_EQ, 228 */
		/* 821B68C0h case   12:*/		if ( !regs.CR[6].eq ) { return 0x821B69A4;  }
		/* 821B68C0h case   12:*/		return 0x821B68C4;
		  /* 821B68C4h */ case   13:  		/* addi R11, R6, 11 */
		/* 821B68C4h case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R6,0xB);
		/* 821B68C4h case   13:*/		return 0x821B68C8;
		  /* 821B68C8h */ case   14:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821B68C8h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821B68C8h case   14:*/		return 0x821B68CC;
		  /* 821B68CCh */ case   15:  		/* lwzx R6, <#[R11 + R5]> */
		/* 821B68CCh case   15:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R5 + 0x00000000) );
		/* 821B68CCh case   15:*/		return 0x821B68D0;
		  /* 821B68D0h */ case   16:  		/* lwz R7, <#[R6]> */
		/* 821B68D0h case   16:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R6 + 0x00000000) );
		/* 821B68D0h case   16:*/		return 0x821B68D4;
		  /* 821B68D4h */ case   17:  		/* rlwinm. R10, R7, 0, 27, 28 */
		/* 821B68D4h case   17:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R10,regs.R7);
		/* 821B68D4h case   17:*/		return 0x821B68D8;
		  /* 821B68D8h */ case   18:  		/* rlwinm R11, R7, 0, 27, 31 */
		/* 821B68D8h case   18:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R7);
		/* 821B68D8h case   18:*/		return 0x821B68DC;
		  /* 821B68DCh */ case   19:  		/* bc 12, CR0_EQ, 20 */
		/* 821B68DCh case   19:*/		if ( regs.CR[0].eq ) { return 0x821B68F0;  }
		/* 821B68DCh case   19:*/		return 0x821B68E0;
		  /* 821B68E0h */ case   20:  		/* rlwinm. R10, R30, 0, 27, 28 */
		/* 821B68E0h case   20:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R10,regs.R30);
		/* 821B68E0h case   20:*/		return 0x821B68E4;
		  /* 821B68E4h */ case   21:  		/* bc 12, CR0_EQ, 12 */
		/* 821B68E4h case   21:*/		if ( regs.CR[0].eq ) { return 0x821B68F0;  }
		/* 821B68E4h case   21:*/		return 0x821B68E8;
		  /* 821B68E8h */ case   22:  		/* li R10, 0 */
		/* 821B68E8h case   22:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821B68E8h case   22:*/		return 0x821B68EC;
		  /* 821B68ECh */ case   23:  		/* b 44 */
		/* 821B68ECh case   23:*/		return 0x821B6918;
		/* 821B68ECh case   23:*/		return 0x821B68F0;
	}
	return 0x821B68F0;
} // Block from 821B6890h-821B68F0h (24 instructions)

//////////////////////////////////////////////////////
// Block at 821B68F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B68F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B68F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B68F0);
		  /* 821B68F0h */ case    0:  		/* rlwinm. R10, R11, 0, 30, 30 */
		/* 821B68F0h case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R11);
		/* 821B68F0h case    0:*/		return 0x821B68F4;
		  /* 821B68F4h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 821B68F4h case    1:*/		if ( regs.CR[0].eq ) { return 0x821B6900;  }
		/* 821B68F4h case    1:*/		return 0x821B68F8;
		  /* 821B68F8h */ case    2:  		/* rlwinm. R10, R30, 0, 31, 31 */
		/* 821B68F8h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R30);
		/* 821B68F8h case    2:*/		return 0x821B68FC;
		  /* 821B68FCh */ case    3:  		/* bc 4, CR0_EQ, -20 */
		/* 821B68FCh case    3:*/		if ( !regs.CR[0].eq ) { return 0x821B68E8;  }
		/* 821B68FCh case    3:*/		return 0x821B6900;
	}
	return 0x821B6900;
} // Block from 821B68F0h-821B6900h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821B6900h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6900( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6900) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6900);
		  /* 821B6900h */ case    0:  		/* rlwinm. R10, R11, 0, 29, 29 */
		/* 821B6900h case    0:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R11);
		/* 821B6900h case    0:*/		return 0x821B6904;
		  /* 821B6904h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 821B6904h case    1:*/		if ( regs.CR[0].eq ) { return 0x821B6914;  }
		/* 821B6904h case    1:*/		return 0x821B6908;
		  /* 821B6908h */ case    2:  		/* rlwinm. R10, R30, 0, 31, 31 */
		/* 821B6908h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R30);
		/* 821B6908h case    2:*/		return 0x821B690C;
		  /* 821B690Ch */ case    3:  		/* li R10, 0 */
		/* 821B690Ch case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821B690Ch case    3:*/		return 0x821B6910;
		  /* 821B6910h */ case    4:  		/* bc 4, CR0_EQ, 8 */
		/* 821B6910h case    4:*/		if ( !regs.CR[0].eq ) { return 0x821B6918;  }
		/* 821B6910h case    4:*/		return 0x821B6914;
	}
	return 0x821B6914;
} // Block from 821B6900h-821B6914h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821B6914h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6914( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6914) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6914);
		  /* 821B6914h */ case    0:  		/* li R10, 1 */
		/* 821B6914h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 821B6914h case    0:*/		return 0x821B6918;
	}
	return 0x821B6918;
} // Block from 821B6914h-821B6918h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B6918h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6918( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6918) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6918);
		  /* 821B6918h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 821B6918h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 821B6918h case    0:*/		return 0x821B691C;
		  /* 821B691Ch */ case    1:  		/* bc 12, CR0_EQ, 136 */
		/* 821B691Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x821B69A4;  }
		/* 821B691Ch case    1:*/		return 0x821B6920;
		  /* 821B6920h */ case    2:  		/* rlwinm. R9, R11, 0, 29, 29 */
		/* 821B6920h case    2:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R9,regs.R11);
		/* 821B6920h case    2:*/		return 0x821B6924;
		  /* 821B6924h */ case    3:  		/* mr R10, R30 */
		/* 821B6924h case    3:*/		regs.R10 = regs.R30;
		/* 821B6924h case    3:*/		return 0x821B6928;
		  /* 821B6928h */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 821B6928h case    4:*/		if ( regs.CR[0].eq ) { return 0x821B6938;  }
		/* 821B6928h case    4:*/		return 0x821B692C;
		  /* 821B692Ch */ case    5:  		/* rlwinm. R9, R30, 0, 30, 30 */
		/* 821B692Ch case    5:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R30);
		/* 821B692Ch case    5:*/		return 0x821B6930;
		  /* 821B6930h */ case    6:  		/* bc 12, CR0_EQ, 8 */
		/* 821B6930h case    6:*/		if ( regs.CR[0].eq ) { return 0x821B6938;  }
		/* 821B6930h case    6:*/		return 0x821B6934;
		  /* 821B6934h */ case    7:  		/* addi R11, R11, -4 */
		/* 821B6934h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 821B6934h case    7:*/		return 0x821B6938;
	}
	return 0x821B6938;
} // Block from 821B6918h-821B6938h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821B6938h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6938( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6938) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6938);
		  /* 821B6938h */ case    0:  		/* and R9, R11, R30 */
		/* 821B6938h case    0:*/		cpu::op::and<0>(regs,&regs.R9,regs.R11,regs.R30);
		/* 821B6938h case    0:*/		return 0x821B693C;
		  /* 821B693Ch */ case    1:  		/* rlwinm. R9, R9, 0, 29, 29 */
		/* 821B693Ch case    1:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R9,regs.R9);
		/* 821B693Ch case    1:*/		return 0x821B6940;
		  /* 821B6940h */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 821B6940h case    2:*/		if ( regs.CR[0].eq ) { return 0x821B694C;  }
		/* 821B6940h case    2:*/		return 0x821B6944;
		  /* 821B6944h */ case    3:  		/* addi R11, R11, -4 */
		/* 821B6944h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 821B6944h case    3:*/		return 0x821B6948;
		  /* 821B6948h */ case    4:  		/* addi R10, R30, -4 */
		/* 821B6948h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0xFFFFFFFC);
		/* 821B6948h case    4:*/		return 0x821B694C;
	}
	return 0x821B694C;
} // Block from 821B6938h-821B694Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 821B694Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B694C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B694C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B694C);
		  /* 821B694Ch */ case    0:  		/* rlwinm. R9, R11, 0, 31, 31 */
		/* 821B694Ch case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R11);
		/* 821B694Ch case    0:*/		return 0x821B6950;
		  /* 821B6950h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 821B6950h case    1:*/		if ( regs.CR[0].eq ) { return 0x821B6960;  }
		/* 821B6950h case    1:*/		return 0x821B6954;
		  /* 821B6954h */ case    2:  		/* rlwinm. R9, R10, 0, 30, 30 */
		/* 821B6954h case    2:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R10);
		/* 821B6954h case    2:*/		return 0x821B6958;
		  /* 821B6958h */ case    3:  		/* bc 12, CR0_EQ, 8 */
		/* 821B6958h case    3:*/		if ( regs.CR[0].eq ) { return 0x821B6960;  }
		/* 821B6958h case    3:*/		return 0x821B695C;
		  /* 821B695Ch */ case    4:  		/* addi R10, R10, -2 */
		/* 821B695Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFE);
		/* 821B695Ch case    4:*/		return 0x821B6960;
	}
	return 0x821B6960;
} // Block from 821B694Ch-821B6960h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821B6960h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6960( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6960) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6960);
		  /* 821B6960h */ case    0:  		/* or R9, R11, R10 */
		/* 821B6960h case    0:*/		cpu::op::or<0>(regs,&regs.R9,regs.R11,regs.R10);
		/* 821B6960h case    0:*/		return 0x821B6964;
		  /* 821B6964h */ case    1:  		/* rlwinm. R11, R9, 0, 0, 30 */
		/* 821B6964h case    1:*/		cpu::op::rlwinm<1,0,0,30>(regs,&regs.R11,regs.R9);
		/* 821B6964h case    1:*/		return 0x821B6968;
		  /* 821B6968h */ case    2:  		/* bc 4, CR0_EQ, 60 */
		/* 821B6968h case    2:*/		if ( !regs.CR[0].eq ) { return 0x821B69A4;  }
		/* 821B6968h case    2:*/		return 0x821B696C;
		  /* 821B696Ch */ case    3:  		/* lwz R11, <#[R6 + 12]> */
		/* 821B696Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x0000000C) );
		/* 821B696Ch case    3:*/		return 0x821B6970;
		  /* 821B6970h */ case    4:  		/* lwz R10, <#[R11 + 8]> */
		/* 821B6970h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821B6970h case    4:*/		return 0x821B6974;
		  /* 821B6974h */ case    5:  		/* rlwinm R10, R10, 25, 25, 31 */
		/* 821B6974h case    5:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R10);
		/* 821B6974h case    5:*/		return 0x821B6978;
		  /* 821B6978h */ case    6:  		/* cmplwi CR6, R10, 125 */
		/* 821B6978h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000007D);
		/* 821B6978h case    6:*/		return 0x821B697C;
		  /* 821B697Ch */ case    7:  		/* bc 12, CR6_EQ, 16 */
		/* 821B697Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x821B698C;  }
		/* 821B697Ch case    7:*/		return 0x821B6980;
		  /* 821B6980h */ case    8:  		/* cmplwi CR6, R10, 124 */
		/* 821B6980h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000007C);
		/* 821B6980h case    8:*/		return 0x821B6984;
		  /* 821B6984h */ case    9:  		/* li R10, 0 */
		/* 821B6984h case    9:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821B6984h case    9:*/		return 0x821B6988;
		  /* 821B6988h */ case   10:  		/* bc 4, CR6_EQ, 8 */
		/* 821B6988h case   10:*/		if ( !regs.CR[6].eq ) { return 0x821B6990;  }
		/* 821B6988h case   10:*/		return 0x821B698C;
	}
	return 0x821B698C;
} // Block from 821B6960h-821B698Ch (11 instructions)

//////////////////////////////////////////////////////
// Block at 821B698Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B698C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B698C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B698C);
		  /* 821B698Ch */ case    0:  		/* li R10, 1 */
		/* 821B698Ch case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 821B698Ch case    0:*/		return 0x821B6990;
	}
	return 0x821B6990;
} // Block from 821B698Ch-821B6990h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B6990h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6990( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6990) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6990);
		  /* 821B6990h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 821B6990h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 821B6990h case    0:*/		return 0x821B6994;
		  /* 821B6994h */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 821B6994h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821B69A4;  }
		/* 821B6994h case    1:*/		return 0x821B6998;
		  /* 821B6998h */ case    2:  		/* mr R29, R11 */
		/* 821B6998h case    2:*/		regs.R29 = regs.R11;
		/* 821B6998h case    2:*/		return 0x821B699C;
		  /* 821B699Ch */ case    3:  		/* rlwinm R28, R7, 27, 30, 31 */
		/* 821B699Ch case    3:*/		cpu::op::rlwinm<0,27,30,31>(regs,&regs.R28,regs.R7);
		/* 821B699Ch case    3:*/		return 0x821B69A0;
		  /* 821B69A0h */ case    4:  		/* mr R30, R9 */
		/* 821B69A0h case    4:*/		regs.R30 = regs.R9;
		/* 821B69A0h case    4:*/		return 0x821B69A4;
	}
	return 0x821B69A4;
} // Block from 821B6990h-821B69A4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821B69A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B69A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B69A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B69A4);
		  /* 821B69A4h */ case    0:  		/* mr R7, R30 */
		/* 821B69A4h case    0:*/		regs.R7 = regs.R30;
		/* 821B69A4h case    0:*/		return 0x821B69A8;
		  /* 821B69A8h */ case    1:  		/* mr R6, R28 */
		/* 821B69A8h case    1:*/		regs.R6 = regs.R28;
		/* 821B69A8h case    1:*/		return 0x821B69AC;
		  /* 821B69ACh */ case    2:  		/* mr R5, R29 */
		/* 821B69ACh case    2:*/		regs.R5 = regs.R29;
		/* 821B69ACh case    2:*/		return 0x821B69B0;
		  /* 821B69B0h */ case    3:  		/* mr R3, R27 */
		/* 821B69B0h case    3:*/		regs.R3 = regs.R27;
		/* 821B69B0h case    3:*/		return 0x821B69B4;
		  /* 821B69B4h */ case    4:  		/* bl -508 */
		/* 821B69B4h case    4:*/		regs.LR = 0x821B69B8; return 0x821B67B8;
		/* 821B69B4h case    4:*/		return 0x821B69B8;
		  /* 821B69B8h */ case    5:  		/* cmplwi CR0, R3, 0 */
		/* 821B69B8h case    5:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 821B69B8h case    5:*/		return 0x821B69BC;
		  /* 821B69BCh */ case    6:  		/* bc 4, CR0_EQ, 124 */
		/* 821B69BCh case    6:*/		if ( !regs.CR[0].eq ) { return 0x821B6A38;  }
		/* 821B69BCh case    6:*/		return 0x821B69C0;
		  /* 821B69C0h */ case    7:  		/* mr R3, R27 */
		/* 821B69C0h case    7:*/		regs.R3 = regs.R27;
		/* 821B69C0h case    7:*/		return 0x821B69C4;
		  /* 821B69C4h */ case    8:  		/* bl 450684 */
		/* 821B69C4h case    8:*/		regs.LR = 0x821B69C8; return 0x82224A40;
		/* 821B69C4h case    8:*/		return 0x821B69C8;
		  /* 821B69C8h */ case    9:  		/* mr R31, R3 */
		/* 821B69C8h case    9:*/		regs.R31 = regs.R3;
		/* 821B69C8h case    9:*/		return 0x821B69CC;
		  /* 821B69CCh */ case   10:  		/* cmplwi CR6, R26, 0 */
		/* 821B69CCh case   10:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 821B69CCh case   10:*/		return 0x821B69D0;
		  /* 821B69D0h */ case   11:  		/* bc 12, CR6_EQ, 24 */
		/* 821B69D0h case   11:*/		if ( regs.CR[6].eq ) { return 0x821B69E8;  }
		/* 821B69D0h case   11:*/		return 0x821B69D4;
		  /* 821B69D4h */ case   12:  		/* lwz R11, <#[R3 + 8]> */
		/* 821B69D4h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821B69D4h case   12:*/		return 0x821B69D8;
		  /* 821B69D8h */ case   13:  		/* li R10, 513 */
		/* 821B69D8h case   13:*/		cpu::op::li<0>(regs,&regs.R10,0x201);
		/* 821B69D8h case   13:*/		return 0x821B69DC;
		  /* 821B69DCh */ case   14:  		/* rlwimi R11, R10, 24, 27, 30 */
		/* 821B69DCh case   14:*/		cpu::op::rlwimi<0,24,27,30>(regs,&regs.R11,regs.R10);
		/* 821B69DCh case   14:*/		return 0x821B69E0;
		  /* 821B69E0h */ case   15:  		/* rlwimi R11, R10, 24, 7, 7 */
		/* 821B69E0h case   15:*/		cpu::op::rlwimi<0,24,7,7>(regs,&regs.R11,regs.R10);
		/* 821B69E0h case   15:*/		return 0x821B69E4;
		  /* 821B69E4h */ case   16:  		/* stw R11, <#[R3 + 8]> */
		/* 821B69E4h case   16:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821B69E4h case   16:*/		return 0x821B69E8;
	}
	return 0x821B69E8;
} // Block from 821B69A4h-821B69E8h (17 instructions)

//////////////////////////////////////////////////////
// Block at 821B69E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B69E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B69E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B69E8);
		  /* 821B69E8h */ case    0:  		/* mr R4, R29 */
		/* 821B69E8h case    0:*/		regs.R4 = regs.R29;
		/* 821B69E8h case    0:*/		return 0x821B69EC;
		  /* 821B69ECh */ case    1:  		/* mr R3, R27 */
		/* 821B69ECh case    1:*/		regs.R3 = regs.R27;
		/* 821B69ECh case    1:*/		return 0x821B69F0;
		  /* 821B69F0h */ case    2:  		/* bl -256496 */
		/* 821B69F0h case    2:*/		regs.LR = 0x821B69F4; return 0x82178000;
		/* 821B69F0h case    2:*/		return 0x821B69F4;
		  /* 821B69F4h */ case    3:  		/* mr R4, R3 */
		/* 821B69F4h case    3:*/		regs.R4 = regs.R3;
		/* 821B69F4h case    3:*/		return 0x821B69F8;
		  /* 821B69F8h */ case    4:  		/* mr R3, R31 */
		/* 821B69F8h case    4:*/		regs.R3 = regs.R31;
		/* 821B69F8h case    4:*/		return 0x821B69FC;
		  /* 821B69FCh */ case    5:  		/* bl -256052 */
		/* 821B69FCh case    5:*/		regs.LR = 0x821B6A00; return 0x821781C8;
		/* 821B69FCh case    5:*/		return 0x821B6A00;
		  /* 821B6A00h */ case    6:  		/* mr R11, R3 */
		/* 821B6A00h case    6:*/		regs.R11 = regs.R3;
		/* 821B6A00h case    6:*/		return 0x821B6A04;
		  /* 821B6A04h */ case    7:  		/* rlwinm R10, R28, 5, 22, 26 */
		/* 821B6A04h case    7:*/		cpu::op::rlwinm<0,5,22,26>(regs,&regs.R10,regs.R28);
		/* 821B6A04h case    7:*/		return 0x821B6A08;
		  /* 821B6A08h */ case    8:  		/* lis R12, -3073 */
		/* 821B6A08h case    8:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFFF3FF);
		/* 821B6A08h case    8:*/		return 0x821B6A0C;
		  /* 821B6A0Ch */ case    9:  		/* rlwinm R10, R10, 0, 25, 23 */
		/* 821B6A0Ch case    9:*/		cpu::op::rlwinm<0,0,25,23>(regs,&regs.R10,regs.R10);
		/* 821B6A0Ch case    9:*/		return 0x821B6A10;
		  /* 821B6A10h */ case   10:  		/* ori R12, R12, 64640 */
		/* 821B6A10h case   10:*/		cpu::op::ori<0>(regs,&regs.R12,regs.R12,0xFC80);
		/* 821B6A10h case   10:*/		return 0x821B6A14;
		  /* 821B6A14h */ case   11:  		/* lwz R8, <#[R11]> */
		/* 821B6A14h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 821B6A14h case   11:*/		return 0x821B6A18;
		  /* 821B6A18h */ case   12:  		/* oris R10, R10, 512 */
		/* 821B6A18h case   12:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x200);
		/* 821B6A18h case   12:*/		return 0x821B6A1C;
		  /* 821B6A1Ch */ case   13:  		/* rlwinm R9, R30, 0, 27, 31 */
		/* 821B6A1Ch case   13:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R30);
		/* 821B6A1Ch case   13:*/		return 0x821B6A20;
		  /* 821B6A20h */ case   14:  		/* ori R10, R10, 7296 */
		/* 821B6A20h case   14:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1C80);
		/* 821B6A20h case   14:*/		return 0x821B6A24;
		  /* 821B6A24h */ case   15:  		/* and R8, R8, R12 */
		/* 821B6A24h case   15:*/		cpu::op::and<0>(regs,&regs.R8,regs.R8,regs.R12);
		/* 821B6A24h case   15:*/		return 0x821B6A28;
		  /* 821B6A28h */ case   16:  		/* mr R3, R31 */
		/* 821B6A28h case   16:*/		regs.R3 = regs.R31;
		/* 821B6A28h case   16:*/		return 0x821B6A2C;
		  /* 821B6A2Ch */ case   17:  		/* or R10, R10, R8 */
		/* 821B6A2Ch case   17:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 821B6A2Ch case   17:*/		return 0x821B6A30;
		  /* 821B6A30h */ case   18:  		/* or R10, R10, R9 */
		/* 821B6A30h case   18:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 821B6A30h case   18:*/		return 0x821B6A34;
		  /* 821B6A34h */ case   19:  		/* stw R10, <#[R11]> */
		/* 821B6A34h case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821B6A34h case   19:*/		return 0x821B6A38;
	}
	return 0x821B6A38;
} // Block from 821B69E8h-821B6A38h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821B6A38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6A38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6A38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6A38);
		  /* 821B6A38h */ case    0:  		/* addi R1, R1, 144 */
		/* 821B6A38h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 821B6A38h case    0:*/		return 0x821B6A3C;
		  /* 821B6A3Ch */ case    1:  		/* b -1202076 */
		/* 821B6A3Ch case    1:*/		return 0x820912A0;
		/* 821B6A3Ch case    1:*/		return 0x821B6A40;
		  /* 821B6A40h */ case    2:  		/* li R8, 0 */
		/* 821B6A40h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821B6A40h case    2:*/		return 0x821B6A44;
		  /* 821B6A44h */ case    3:  		/* b -436 */
		/* 821B6A44h case    3:*/		return 0x821B6890;
		/* 821B6A44h case    3:*/		return 0x821B6A48;
	}
	return 0x821B6A48;
} // Block from 821B6A38h-821B6A48h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821B6A48h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6A48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6A48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6A48);
		  /* 821B6A48h */ case    0:  		/* mfspr R12, LR */
		/* 821B6A48h case    0:*/		regs.R12 = regs.LR;
		/* 821B6A48h case    0:*/		return 0x821B6A4C;
		  /* 821B6A4Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821B6A4Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821B6A4Ch case    1:*/		return 0x821B6A50;
		  /* 821B6A50h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 821B6A50h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821B6A50h case    2:*/		return 0x821B6A54;
		  /* 821B6A54h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 821B6A54h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821B6A54h case    3:*/		return 0x821B6A58;
		  /* 821B6A58h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 821B6A58h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821B6A58h case    4:*/		return 0x821B6A5C;
		  /* 821B6A5Ch */ case    5:  		/* mr R30, R3 */
		/* 821B6A5Ch case    5:*/		regs.R30 = regs.R3;
		/* 821B6A5Ch case    5:*/		return 0x821B6A60;
		  /* 821B6A60h */ case    6:  		/* mr R31, R4 */
		/* 821B6A60h case    6:*/		regs.R31 = regs.R4;
		/* 821B6A60h case    6:*/		return 0x821B6A64;
		  /* 821B6A64h */ case    7:  		/* b 80 */
		/* 821B6A64h case    7:*/		return 0x821B6AB4;
		/* 821B6A64h case    7:*/		return 0x821B6A68;
		  /* 821B6A68h */ case    8:  		/* lwz R11, <#[R31 + 4]> */
		/* 821B6A68h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 821B6A68h case    8:*/		return 0x821B6A6C;
		  /* 821B6A6Ch */ case    9:  		/* cmplwi CR6, R11, 0 */
		/* 821B6A6Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821B6A6Ch case    9:*/		return 0x821B6A70;
		  /* 821B6A70h */ case   10:  		/* bc 12, CR6_EQ, 160 */
		/* 821B6A70h case   10:*/		if ( regs.CR[6].eq ) { return 0x821B6B10;  }
		/* 821B6A70h case   10:*/		return 0x821B6A74;
		  /* 821B6A74h */ case   11:  		/* lwz R31, <#[R11 + 16]> */
		/* 821B6A74h case   11:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000010) );
		/* 821B6A74h case   11:*/		return 0x821B6A78;
		  /* 821B6A78h */ case   12:  		/* cmplwi CR6, R31, 0 */
		/* 821B6A78h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821B6A78h case   12:*/		return 0x821B6A7C;
		  /* 821B6A7Ch */ case   13:  		/* bc 12, CR6_EQ, 32 */
		/* 821B6A7Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x821B6A9C;  }
		/* 821B6A7Ch case   13:*/		return 0x821B6A80;
		  /* 821B6A80h */ case   14:  		/* lwz R10, <#[R11]> */
		/* 821B6A80h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821B6A80h case   14:*/		return 0x821B6A84;
		  /* 821B6A84h */ case   15:  		/* rlwinm. R10, R10, 0, 4, 6 */
		/* 821B6A84h case   15:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R10);
		/* 821B6A84h case   15:*/		return 0x821B6A88;
		  /* 821B6A88h */ case   16:  		/* bc 12, CR0_EQ, 20 */
		/* 821B6A88h case   16:*/		if ( regs.CR[0].eq ) { return 0x821B6A9C;  }
		/* 821B6A88h case   16:*/		return 0x821B6A8C;
		  /* 821B6A8Ch */ case   17:  		/* lwz R10, <#[R31 + 8]> */
		/* 821B6A8Ch case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 821B6A8Ch case   17:*/		return 0x821B6A90;
		  /* 821B6A90h */ case   18:  		/* rlwinm R9, R10, 0, 18, 24 */
		/* 821B6A90h case   18:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R9,regs.R10);
		/* 821B6A90h case   18:*/		return 0x821B6A94;
		  /* 821B6A94h */ case   19:  		/* cmplwi CR6, R9, 14080 */
		/* 821B6A94h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00003700);
		/* 821B6A94h case   19:*/		return 0x821B6A98;
		  /* 821B6A98h */ case   20:  		/* bc 12, CR6_EQ, 12 */
		/* 821B6A98h case   20:*/		if ( regs.CR[6].eq ) { return 0x821B6AA4;  }
		/* 821B6A98h case   20:*/		return 0x821B6A9C;
	}
	return 0x821B6A9C;
} // Block from 821B6A48h-821B6A9Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 821B6A9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6A9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6A9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6A9C);
		  /* 821B6A9Ch */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 821B6A9Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821B6A9Ch case    0:*/		return 0x821B6AA0;
		  /* 821B6AA0h */ case    1:  		/* b -52 */
		/* 821B6AA0h case    1:*/		return 0x821B6A6C;
		/* 821B6AA0h case    1:*/		return 0x821B6AA4;
	}
	return 0x821B6AA4;
} // Block from 821B6A9Ch-821B6AA4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B6AA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6AA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6AA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6AA4);
		  /* 821B6AA4h */ case    0:  		/* rlwinm. R11, R10, 9, 31, 31 */
		/* 821B6AA4h case    0:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R10);
		/* 821B6AA4h case    0:*/		return 0x821B6AA8;
		  /* 821B6AA8h */ case    1:  		/* bc 4, CR0_EQ, 104 */
		/* 821B6AA8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821B6B10;  }
		/* 821B6AA8h case    1:*/		return 0x821B6AAC;
		  /* 821B6AACh */ case    2:  		/* rlwinm. R11, R10, 8, 31, 31 */
		/* 821B6AACh case    2:*/		cpu::op::rlwinm<1,8,31,31>(regs,&regs.R11,regs.R10);
		/* 821B6AACh case    2:*/		return 0x821B6AB0;
		  /* 821B6AB0h */ case    3:  		/* bc 12, CR0_EQ, 96 */
		/* 821B6AB0h case    3:*/		if ( regs.CR[0].eq ) { return 0x821B6B10;  }
		/* 821B6AB0h case    3:*/		return 0x821B6AB4;
	}
	return 0x821B6AB4;
} // Block from 821B6AA4h-821B6AB4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821B6AB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6AB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6AB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6AB4);
		  /* 821B6AB4h */ case    0:  		/* mr R4, R31 */
		/* 821B6AB4h case    0:*/		regs.R4 = regs.R31;
		/* 821B6AB4h case    0:*/		return 0x821B6AB8;
		  /* 821B6AB8h */ case    1:  		/* mr R3, R30 */
		/* 821B6AB8h case    1:*/		regs.R3 = regs.R30;
		/* 821B6AB8h case    1:*/		return 0x821B6ABC;
		  /* 821B6ABCh */ case    2:  		/* bl -1556 */
		/* 821B6ABCh case    2:*/		regs.LR = 0x821B6AC0; return 0x821B64A8;
		/* 821B6ABCh case    2:*/		return 0x821B6AC0;
		  /* 821B6AC0h */ case    3:  		/* lwz R11, <#[R31 + 8]> */
		/* 821B6AC0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821B6AC0h case    3:*/		return 0x821B6AC4;
		  /* 821B6AC4h */ case    4:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821B6AC4h case    4:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821B6AC4h case    4:*/		return 0x821B6AC8;
		  /* 821B6AC8h */ case    5:  		/* cmplwi CR6, R11, 14080 */
		/* 821B6AC8h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003700);
		/* 821B6AC8h case    5:*/		return 0x821B6ACC;
		  /* 821B6ACCh */ case    6:  		/* bc 4, CR6_EQ, -100 */
		/* 821B6ACCh case    6:*/		if ( !regs.CR[6].eq ) { return 0x821B6A68;  }
		/* 821B6ACCh case    6:*/		return 0x821B6AD0;
		  /* 821B6AD0h */ case    7:  		/* lwz R31, <#[R31]> */
		/* 821B6AD0h case    7:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000000) );
		/* 821B6AD0h case    7:*/		return 0x821B6AD4;
		  /* 821B6AD4h */ case    8:  		/* cmplwi CR6, R31, 0 */
		/* 821B6AD4h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821B6AD4h case    8:*/		return 0x821B6AD8;
		  /* 821B6AD8h */ case    9:  		/* bc 12, CR6_EQ, 56 */
		/* 821B6AD8h case    9:*/		if ( regs.CR[6].eq ) { return 0x821B6B10;  }
		/* 821B6AD8h case    9:*/		return 0x821B6ADC;
		  /* 821B6ADCh */ case   10:  		/* lwz R11, <#[R31]> */
		/* 821B6ADCh case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821B6ADCh case   10:*/		return 0x821B6AE0;
		  /* 821B6AE0h */ case   11:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 821B6AE0h case   11:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 821B6AE0h case   11:*/		return 0x821B6AE4;
		  /* 821B6AE4h */ case   12:  		/* bc 12, CR0_EQ, 36 */
		/* 821B6AE4h case   12:*/		if ( regs.CR[0].eq ) { return 0x821B6B08;  }
		/* 821B6AE4h case   12:*/		return 0x821B6AE8;
		  /* 821B6AE8h */ case   13:  		/* lwz R4, <#[R31 + 12]> */
		/* 821B6AE8h case   13:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 821B6AE8h case   13:*/		return 0x821B6AEC;
		  /* 821B6AECh */ case   14:  		/* lwz R11, <#[R4 + 8]> */
		/* 821B6AECh case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821B6AECh case   14:*/		return 0x821B6AF0;
		  /* 821B6AF0h */ case   15:  		/* rlwinm. R10, R11, 9, 31, 31 */
		/* 821B6AF0h case   15:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R10,regs.R11);
		/* 821B6AF0h case   15:*/		return 0x821B6AF4;
		  /* 821B6AF4h */ case   16:  		/* bc 4, CR0_EQ, 20 */
		/* 821B6AF4h case   16:*/		if ( !regs.CR[0].eq ) { return 0x821B6B08;  }
		/* 821B6AF4h case   16:*/		return 0x821B6AF8;
		  /* 821B6AF8h */ case   17:  		/* rlwinm. R11, R11, 8, 31, 31 */
		/* 821B6AF8h case   17:*/		cpu::op::rlwinm<1,8,31,31>(regs,&regs.R11,regs.R11);
		/* 821B6AF8h case   17:*/		return 0x821B6AFC;
		  /* 821B6AFCh */ case   18:  		/* bc 12, CR0_EQ, 12 */
		/* 821B6AFCh case   18:*/		if ( regs.CR[0].eq ) { return 0x821B6B08;  }
		/* 821B6AFCh case   18:*/		return 0x821B6B00;
		  /* 821B6B00h */ case   19:  		/* mr R3, R30 */
		/* 821B6B00h case   19:*/		regs.R3 = regs.R30;
		/* 821B6B00h case   19:*/		return 0x821B6B04;
		  /* 821B6B04h */ case   20:  		/* bl -1628 */
		/* 821B6B04h case   20:*/		regs.LR = 0x821B6B08; return 0x821B64A8;
		/* 821B6B04h case   20:*/		return 0x821B6B08;
	}
	return 0x821B6B08;
} // Block from 821B6AB4h-821B6B08h (21 instructions)

//////////////////////////////////////////////////////
// Block at 821B6B08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6B08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6B08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6B08);
		  /* 821B6B08h */ case    0:  		/* lwz R31, <#[R31 + 4]> */
		/* 821B6B08h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000004) );
		/* 821B6B08h case    0:*/		return 0x821B6B0C;
		  /* 821B6B0Ch */ case    1:  		/* b -56 */
		/* 821B6B0Ch case    1:*/		return 0x821B6AD4;
		/* 821B6B0Ch case    1:*/		return 0x821B6B10;
	}
	return 0x821B6B10;
} // Block from 821B6B08h-821B6B10h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B6B10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6B10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6B10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6B10);
		  /* 821B6B10h */ case    0:  		/* addi R1, R1, 112 */
		/* 821B6B10h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821B6B10h case    0:*/		return 0x821B6B14;
		  /* 821B6B14h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 821B6B14h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821B6B14h case    1:*/		return 0x821B6B18;
		  /* 821B6B18h */ case    2:  		/* mtspr LR, R12 */
		/* 821B6B18h case    2:*/		regs.LR = regs.R12;
		/* 821B6B18h case    2:*/		return 0x821B6B1C;
		  /* 821B6B1Ch */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 821B6B1Ch case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821B6B1Ch case    3:*/		return 0x821B6B20;
		  /* 821B6B20h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 821B6B20h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821B6B20h case    4:*/		return 0x821B6B24;
		  /* 821B6B24h */ case    5:  		/* bclr 20, CR0_LT */
		/* 821B6B24h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821B6B24h case    5:*/		return 0x821B6B28;
	}
	return 0x821B6B28;
} // Block from 821B6B10h-821B6B28h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821B6B28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6B28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6B28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6B28);
		  /* 821B6B28h */ case    0:  		/* mfspr R12, LR */
		/* 821B6B28h case    0:*/		regs.R12 = regs.LR;
		/* 821B6B28h case    0:*/		return 0x821B6B2C;
		  /* 821B6B2Ch */ case    1:  		/* bl -1202424 */
		/* 821B6B2Ch case    1:*/		regs.LR = 0x821B6B30; return 0x82091234;
		/* 821B6B2Ch case    1:*/		return 0x821B6B30;
		  /* 821B6B30h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 821B6B30h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 821B6B30h case    2:*/		return 0x821B6B34;
		  /* 821B6B34h */ case    3:  		/* lwz R11, <#[R4 + 8]> */
		/* 821B6B34h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821B6B34h case    3:*/		return 0x821B6B38;
		  /* 821B6B38h */ case    4:  		/* li R5, 0 */
		/* 821B6B38h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821B6B38h case    4:*/		return 0x821B6B3C;
		  /* 821B6B3Ch */ case    5:  		/* mr R31, R4 */
		/* 821B6B3Ch case    5:*/		regs.R31 = regs.R4;
		/* 821B6B3Ch case    5:*/		return 0x821B6B40;
		  /* 821B6B40h */ case    6:  		/* lwz R4, <#[R4 + 28]> */
		/* 821B6B40h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x0000001C) );
		/* 821B6B40h case    6:*/		return 0x821B6B44;
		  /* 821B6B44h */ case    7:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 821B6B44h case    7:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 821B6B44h case    7:*/		return 0x821B6B48;
		  /* 821B6B48h */ case    8:  		/* mr R23, R3 */
		/* 821B6B48h case    8:*/		regs.R23 = regs.R3;
		/* 821B6B48h case    8:*/		return 0x821B6B4C;
		  /* 821B6B4Ch */ case    9:  		/* bl 450484 */
		/* 821B6B4Ch case    9:*/		regs.LR = 0x821B6B50; return 0x82224B00;
		/* 821B6B4Ch case    9:*/		return 0x821B6B50;
		  /* 821B6B50h */ case   10:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821B6B50h case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821B6B50h case   10:*/		return 0x821B6B54;
		  /* 821B6B54h */ case   11:  		/* rlwinm R10, R3, 0, 0, 30 */
		/* 821B6B54h case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R3);
		/* 821B6B54h case   11:*/		return 0x821B6B58;
		  /* 821B6B58h */ case   12:  		/* addi R11, R11, 36 */
		/* 821B6B58h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821B6B58h case   12:*/		return 0x821B6B5C;
		  /* 821B6B5Ch */ case   13:  		/* addi R10, R10, 36 */
		/* 821B6B5Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 821B6B5Ch case   13:*/		return 0x821B6B60;
		  /* 821B6B60h */ case   14:  		/* addi R8, R11, -36 */
		/* 821B6B60h case   14:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821B6B60h case   14:*/		return 0x821B6B64;
		  /* 821B6B64h */ case   15:  		/* addi R6, R10, -36 */
		/* 821B6B64h case   15:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821B6B64h case   15:*/		return 0x821B6B68;
		  /* 821B6B68h */ case   16:  		/* addi R22, R31, 44 */
		/* 821B6B68h case   16:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R31,0x2C);
		/* 821B6B68h case   16:*/		return 0x821B6B6C;
		  /* 821B6B6Ch */ case   17:  		/* lwz R7, <#[R11]> */
		/* 821B6B6Ch case   17:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821B6B6Ch case   17:*/		return 0x821B6B70;
		  /* 821B6B70h */ case   18:  		/* addi R9, R10, 4 */
		/* 821B6B70h case   18:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 821B6B70h case   18:*/		return 0x821B6B74;
		  /* 821B6B74h */ case   19:  		/* mr R27, R3 */
		/* 821B6B74h case   19:*/		regs.R27 = regs.R3;
		/* 821B6B74h case   19:*/		return 0x821B6B78;
		  /* 821B6B78h */ case   20:  		/* li R24, 0 */
		/* 821B6B78h case   20:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 821B6B78h case   20:*/		return 0x821B6B7C;
		  /* 821B6B7Ch */ case   21:  		/* li R20, 0 */
		/* 821B6B7Ch case   21:*/		cpu::op::li<0>(regs,&regs.R20,0x0);
		/* 821B6B7Ch case   21:*/		return 0x821B6B80;
		  /* 821B6B80h */ case   22:  		/* mr R21, R22 */
		/* 821B6B80h case   22:*/		regs.R21 = regs.R22;
		/* 821B6B80h case   22:*/		return 0x821B6B84;
		  /* 821B6B84h */ case   23:  		/* stw R7, <#[R10]> */
		/* 821B6B84h case   23:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821B6B84h case   23:*/		return 0x821B6B88;
		  /* 821B6B88h */ case   24:  		/* lwz R7, <#[R11]> */
		/* 821B6B88h case   24:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821B6B88h case   24:*/		return 0x821B6B8C;
		  /* 821B6B8Ch */ case   25:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821B6B8Ch case   25:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821B6B8Ch case   25:*/		return 0x821B6B90;
		  /* 821B6B90h */ case   26:  		/* stw R6, <#[R7]> */
		/* 821B6B90h case   26:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R7 + 0x00000000) );
		/* 821B6B90h case   26:*/		return 0x821B6B94;
		  /* 821B6B94h */ case   27:  		/* stw R8, <#[R10 + 4]> */
		/* 821B6B94h case   27:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 821B6B94h case   27:*/		return 0x821B6B98;
		  /* 821B6B98h */ case   28:  		/* stw R9, <#[R11]> */
		/* 821B6B98h case   28:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821B6B98h case   28:*/		return 0x821B6B9C;
		  /* 821B6B9Ch */ case   29:  		/* lwz R11, <#[R31 + 8]> */
		/* 821B6B9Ch case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821B6B9Ch case   29:*/		return 0x821B6BA0;
		  /* 821B6BA0h */ case   30:  		/* rlwinm R8, R11, 13, 29, 31 */
		/* 821B6BA0h case   30:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R8,regs.R11);
		/* 821B6BA0h case   30:*/		return 0x821B6BA4;
		  /* 821B6BA4h */ case   31:  		/* cmplw CR6, R20, R8 */
		/* 821B6BA4h case   31:*/		cpu::op::cmplw<6>(regs,regs.R20,regs.R8);
		/* 821B6BA4h case   31:*/		return 0x821B6BA8;
		  /* 821B6BA8h */ case   32:  		/* bc 4, CR6_LT, 248 */
		/* 821B6BA8h case   32:*/		if ( !regs.CR[6].lt ) { return 0x821B6CA0;  }
		/* 821B6BA8h case   32:*/		return 0x821B6BAC;
		  /* 821B6BACh */ case   33:  		/* lwz R25, <#[R21]> */
		/* 821B6BACh case   33:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R21 + 0x00000000) );
		/* 821B6BACh case   33:*/		return 0x821B6BB0;
		  /* 821B6BB0h */ case   34:  		/* li R9, 0 */
		/* 821B6BB0h case   34:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821B6BB0h case   34:*/		return 0x821B6BB4;
		  /* 821B6BB4h */ case   35:  		/* mr R10, R22 */
		/* 821B6BB4h case   35:*/		regs.R10 = regs.R22;
		/* 821B6BB4h case   35:*/		return 0x821B6BB8;
		  /* 821B6BB8h */ case   36:  		/* lwz R26, <#[R25 + 12]> */
		/* 821B6BB8h case   36:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R25 + 0x0000000C) );
		/* 821B6BB8h case   36:*/		return 0x821B6BBC;
		  /* 821B6BBCh */ case   37:  		/* cmplw CR6, R9, R8 */
		/* 821B6BBCh case   37:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 821B6BBCh case   37:*/		return 0x821B6BC0;
		  /* 821B6BC0h */ case   38:  		/* bc 4, CR6_LT, 40 */
		/* 821B6BC0h case   38:*/		if ( !regs.CR[6].lt ) { return 0x821B6BE8;  }
		/* 821B6BC0h case   38:*/		return 0x821B6BC4;
		  /* 821B6BC4h */ case   39:  		/* lwz R11, <#[R10]> */
		/* 821B6BC4h case   39:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 821B6BC4h case   39:*/		return 0x821B6BC8;
		  /* 821B6BC8h */ case   40:  		/* cmplw CR6, R25, R11 */
		/* 821B6BC8h case   40:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R11);
		/* 821B6BC8h case   40:*/		return 0x821B6BCC;
		  /* 821B6BCCh */ case   41:  		/* bc 12, CR6_EQ, 40 */
		/* 821B6BCCh case   41:*/		if ( regs.CR[6].eq ) { return 0x821B6BF4;  }
		/* 821B6BCCh case   41:*/		return 0x821B6BD0;
		  /* 821B6BD0h */ case   42:  		/* lwz R7, <#[R11 + 12]> */
		/* 821B6BD0h case   42:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x0000000C) );
		/* 821B6BD0h case   42:*/		return 0x821B6BD4;
		  /* 821B6BD4h */ case   43:  		/* cmplw CR6, R26, R7 */
		/* 821B6BD4h case   43:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R7);
		/* 821B6BD4h case   43:*/		return 0x821B6BD8;
		  /* 821B6BD8h */ case   44:  		/* bc 12, CR6_EQ, 20 */
		/* 821B6BD8h case   44:*/		if ( regs.CR[6].eq ) { return 0x821B6BEC;  }
		/* 821B6BD8h case   44:*/		return 0x821B6BDC;
		  /* 821B6BDCh */ case   45:  		/* addi R9, R9, 1 */
		/* 821B6BDCh case   45:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 821B6BDCh case   45:*/		return 0x821B6BE0;
		  /* 821B6BE0h */ case   46:  		/* addi R10, R10, 4 */
		/* 821B6BE0h case   46:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821B6BE0h case   46:*/		return 0x821B6BE4;
		  /* 821B6BE4h */ case   47:  		/* b -40 */
		/* 821B6BE4h case   47:*/		return 0x821B6BBC;
		/* 821B6BE4h case   47:*/		return 0x821B6BE8;
	}
	return 0x821B6BE8;
} // Block from 821B6B28h-821B6BE8h (48 instructions)

//////////////////////////////////////////////////////
// Block at 821B6BE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6BE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6BE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6BE8);
		  /* 821B6BE8h */ case    0:  		/* li R11, 0 */
		/* 821B6BE8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821B6BE8h case    0:*/		return 0x821B6BEC;
	}
	return 0x821B6BEC;
} // Block from 821B6BE8h-821B6BECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B6BECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6BEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6BEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6BEC);
		  /* 821B6BECh */ case    0:  		/* cmplw CR6, R25, R11 */
		/* 821B6BECh case    0:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R11);
		/* 821B6BECh case    0:*/		return 0x821B6BF0;
		  /* 821B6BF0h */ case    1:  		/* bc 4, CR6_EQ, 164 */
		/* 821B6BF0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821B6C94;  }
		/* 821B6BF0h case    1:*/		return 0x821B6BF4;
	}
	return 0x821B6BF4;
} // Block from 821B6BECh-821B6BF4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B6BF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6BF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6BF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6BF4);
		  /* 821B6BF4h */ case    0:  		/* lwz R11, <#[R26 + 8]> */
		/* 821B6BF4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 821B6BF4h case    0:*/		return 0x821B6BF8;
		  /* 821B6BF8h */ case    1:  		/* li R29, 0 */
		/* 821B6BF8h case    1:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 821B6BF8h case    1:*/		return 0x821B6BFC;
		  /* 821B6BFCh */ case    2:  		/* rlwinm. R10, R11, 0, 15, 17 */
		/* 821B6BFCh case    2:*/		cpu::op::rlwinm<1,0,15,17>(regs,&regs.R10,regs.R11);
		/* 821B6BFCh case    2:*/		return 0x821B6C00;
		  /* 821B6C00h */ case    3:  		/* rlwinm R30, R11, 31, 28, 31 */
		/* 821B6C00h case    3:*/		cpu::op::rlwinm<0,31,28,31>(regs,&regs.R30,regs.R11);
		/* 821B6C00h case    3:*/		return 0x821B6C04;
		  /* 821B6C04h */ case    4:  		/* bc 12, CR0_EQ, 144 */
		/* 821B6C04h case    4:*/		if ( regs.CR[0].eq ) { return 0x821B6C94;  }
		/* 821B6C04h case    4:*/		return 0x821B6C08;
		  /* 821B6C08h */ case    5:  		/* addi R11, R24, 10 */
		/* 821B6C08h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R24,0xA);
		/* 821B6C08h case    5:*/		return 0x821B6C0C;
		  /* 821B6C0Ch */ case    6:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821B6C0Ch case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821B6C0Ch case    6:*/		return 0x821B6C10;
		  /* 821B6C10h */ case    7:  		/* add R28, R11, R27 */
		/* 821B6C10h case    7:*/		cpu::op::add<0>(regs,&regs.R28,regs.R11,regs.R27);
		/* 821B6C10h case    7:*/		return 0x821B6C14;
		  /* 821B6C14h */ case    8:  		/* addi R11, R30, -1 */
		/* 821B6C14h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xFFFFFFFF);
		/* 821B6C14h case    8:*/		return 0x821B6C18;
		  /* 821B6C18h */ case    9:  		/* mr R4, R26 */
		/* 821B6C18h case    9:*/		regs.R4 = regs.R26;
		/* 821B6C18h case    9:*/		return 0x821B6C1C;
		  /* 821B6C1Ch */ case   10:  		/* andc R19, R30, R11 */
		/* 821B6C1Ch case   10:*/		cpu::op::andc<0>(regs,&regs.R19,regs.R30,regs.R11);
		/* 821B6C1Ch case   10:*/		return 0x821B6C20;
		  /* 821B6C20h */ case   11:  		/* mr R3, R23 */
		/* 821B6C20h case   11:*/		regs.R3 = regs.R23;
		/* 821B6C20h case   11:*/		return 0x821B6C24;
		  /* 821B6C24h */ case   12:  		/* subf R30, R19, R30 */
		/* 821B6C24h case   12:*/		cpu::op::subf<0>(regs,&regs.R30,regs.R19,regs.R30);
		/* 821B6C24h case   12:*/		return 0x821B6C28;
		  /* 821B6C28h */ case   13:  		/* bl -257064 */
		/* 821B6C28h case   13:*/		regs.LR = 0x821B6C2C; return 0x82178000;
		/* 821B6C28h case   13:*/		return 0x821B6C2C;
		  /* 821B6C2Ch */ case   14:  		/* cntlzw R10, R19 */
		/* 821B6C2Ch case   14:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R19);
		/* 821B6C2Ch case   14:*/		return 0x821B6C30;
		  /* 821B6C30h */ case   15:  		/* mr R11, R3 */
		/* 821B6C30h case   15:*/		regs.R11 = regs.R3;
		/* 821B6C30h case   15:*/		return 0x821B6C34;
		  /* 821B6C34h */ case   16:  		/* subfic R10, R10, -1 */
		/* 821B6C34h case   16:*/		cpu::op::subfic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 821B6C34h case   16:*/		return 0x821B6C38;
		  /* 821B6C38h */ case   17:  		/* lis R12, -3073 */
		/* 821B6C38h case   17:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFFF3FF);
		/* 821B6C38h case   17:*/		return 0x821B6C3C;
		  /* 821B6C3Ch */ case   18:  		/* rlwinm R10, R10, 5, 22, 26 */
		/* 821B6C3Ch case   18:*/		cpu::op::rlwinm<0,5,22,26>(regs,&regs.R10,regs.R10);
		/* 821B6C3Ch case   18:*/		return 0x821B6C40;
		  /* 821B6C40h */ case   19:  		/* ori R12, R12, 64671 */
		/* 821B6C40h case   19:*/		cpu::op::ori<0>(regs,&regs.R12,regs.R12,0xFC9F);
		/* 821B6C40h case   19:*/		return 0x821B6C44;
		  /* 821B6C44h */ case   20:  		/* rlwinm R10, R10, 0, 25, 23 */
		/* 821B6C44h case   20:*/		cpu::op::rlwinm<0,0,25,23>(regs,&regs.R10,regs.R10);
		/* 821B6C44h case   20:*/		return 0x821B6C48;
		  /* 821B6C48h */ case   21:  		/* lwz R9, <#[R11]> */
		/* 821B6C48h case   21:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821B6C48h case   21:*/		return 0x821B6C4C;
		  /* 821B6C4Ch */ case   22:  		/* mr R3, R27 */
		/* 821B6C4Ch case   22:*/		regs.R3 = regs.R27;
		/* 821B6C4Ch case   22:*/		return 0x821B6C50;
		  /* 821B6C50h */ case   23:  		/* oris R10, R10, 512 */
		/* 821B6C50h case   23:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x200);
		/* 821B6C50h case   23:*/		return 0x821B6C54;
		  /* 821B6C54h */ case   24:  		/* and R9, R9, R12 */
		/* 821B6C54h case   24:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R12);
		/* 821B6C54h case   24:*/		return 0x821B6C58;
	}
	return 0x821B6C58;
} // Block from 821B6BF4h-821B6C58h (25 instructions)

//////////////////////////////////////////////////////
// Block at 821B6C58h
// Function '?ComputeMERGEWriteMask@Compiler@D3DXShader@@AAAXPAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6C58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6C58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6C58);
		  /* 821B6C58h */ case    0:  		/* ori R10, R10, 7296 */
		/* 821B6C58h case    0:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1C80);
		/* 821B6C58h case    0:*/		return 0x821B6C5C;
		  /* 821B6C5Ch */ case    1:  		/* mr R4, R11 */
		/* 821B6C5Ch case    1:*/		regs.R4 = regs.R11;
		/* 821B6C5Ch case    1:*/		return 0x821B6C60;
		  /* 821B6C60h */ case    2:  		/* or R10, R10, R9 */
		/* 821B6C60h case    2:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 821B6C60h case    2:*/		return 0x821B6C64;
		  /* 821B6C64h */ case    3:  		/* stw R10, <#[R11]> */
		/* 821B6C64h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821B6C64h case    3:*/		return 0x821B6C68;
		  /* 821B6C68h */ case    4:  		/* lwz R9, <#[R25]> */
		/* 821B6C68h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R25 + 0x00000000) );
		/* 821B6C68h case    4:*/		return 0x821B6C6C;
		  /* 821B6C6Ch */ case    5:  		/* rlwimi R9, R10, 0, 0, 26 */
		/* 821B6C6Ch case    5:*/		cpu::op::rlwimi<0,0,0,26>(regs,&regs.R9,regs.R10);
		/* 821B6C6Ch case    5:*/		return 0x821B6C70;
		  /* 821B6C70h */ case    6:  		/* stw R9, <#[R11]> */
		/* 821B6C70h case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821B6C70h case    6:*/		return 0x821B6C74;
		  /* 821B6C74h */ case    7:  		/* bl -256684 */
		/* 821B6C74h case    7:*/		regs.LR = 0x821B6C78; return 0x821781C8;
		/* 821B6C74h case    7:*/		return 0x821B6C78;
		  /* 821B6C78h */ case    8:  		/* stwu R3, <#[R28 + 4]> */
		/* 821B6C78h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R28 + 0x00000004) );
		regs.R28 = (uint32)(regs.R28 + 0x00000004);
		/* 821B6C78h case    8:*/		return 0x821B6C7C;
		  /* 821B6C7Ch */ case    9:  		/* lwz R11, <#[R26 + 8]> */
		/* 821B6C7Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 821B6C7Ch case    9:*/		return 0x821B6C80;
		  /* 821B6C80h */ case   10:  		/* addi R29, R29, 1 */
		/* 821B6C80h case   10:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 821B6C80h case   10:*/		return 0x821B6C84;
		  /* 821B6C84h */ case   11:  		/* rlwinm R11, R11, 18, 29, 31 */
		/* 821B6C84h case   11:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R11,regs.R11);
		/* 821B6C84h case   11:*/		return 0x821B6C88;
		  /* 821B6C88h */ case   12:  		/* addi R24, R24, 1 */
		/* 821B6C88h case   12:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x1);
		/* 821B6C88h case   12:*/		return 0x821B6C8C;
		  /* 821B6C8Ch */ case   13:  		/* cmplw CR6, R29, R11 */
		/* 821B6C8Ch case   13:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 821B6C8Ch case   13:*/		return 0x821B6C90;
		  /* 821B6C90h */ case   14:  		/* bc 12, CR6_LT, -124 */
		/* 821B6C90h case   14:*/		if ( regs.CR[6].lt ) { return 0x821B6C14;  }
		/* 821B6C90h case   14:*/		return 0x821B6C94;
	}
	return 0x821B6C94;
} // Block from 821B6C58h-821B6C94h (15 instructions)

//////////////////////////////////////////////////////
// Block at 821B6C94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6C94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6C94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6C94);
		  /* 821B6C94h */ case    0:  		/* addi R20, R20, 1 */
		/* 821B6C94h case    0:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R20,0x1);
		/* 821B6C94h case    0:*/		return 0x821B6C98;
		  /* 821B6C98h */ case    1:  		/* addi R21, R21, 4 */
		/* 821B6C98h case    1:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R21,0x4);
		/* 821B6C98h case    1:*/		return 0x821B6C9C;
		  /* 821B6C9Ch */ case    2:  		/* b -256 */
		/* 821B6C9Ch case    2:*/		return 0x821B6B9C;
		/* 821B6C9Ch case    2:*/		return 0x821B6CA0;
	}
	return 0x821B6CA0;
} // Block from 821B6C94h-821B6CA0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821B6CA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6CA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6CA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6CA0);
		  /* 821B6CA0h */ case    0:  		/* mr R5, R27 */
		/* 821B6CA0h case    0:*/		regs.R5 = regs.R27;
		/* 821B6CA0h case    0:*/		return 0x821B6CA4;
		  /* 821B6CA4h */ case    1:  		/* mr R4, R31 */
		/* 821B6CA4h case    1:*/		regs.R4 = regs.R31;
		/* 821B6CA4h case    1:*/		return 0x821B6CA8;
		  /* 821B6CA8h */ case    2:  		/* mr R3, R23 */
		/* 821B6CA8h case    2:*/		regs.R3 = regs.R23;
		/* 821B6CA8h case    2:*/		return 0x821B6CAC;
		  /* 821B6CACh */ case    3:  		/* bl -1548 */
		/* 821B6CACh case    3:*/		regs.LR = 0x821B6CB0; return 0x821B66A0;
		/* 821B6CACh case    3:*/		return 0x821B6CB0;
		  /* 821B6CB0h */ case    4:  		/* mr R3, R27 */
		/* 821B6CB0h case    4:*/		regs.R3 = regs.R27;
		/* 821B6CB0h case    4:*/		return 0x821B6CB4;
		  /* 821B6CB4h */ case    5:  		/* addi R1, R1, 192 */
		/* 821B6CB4h case    5:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 821B6CB4h case    5:*/		return 0x821B6CB8;
		  /* 821B6CB8h */ case    6:  		/* b -1202740 */
		/* 821B6CB8h case    6:*/		return 0x82091284;
		/* 821B6CB8h case    6:*/		return 0x821B6CBC;
		  /* 821B6CBCh */ case    7:  		/* nop */
		/* 821B6CBCh case    7:*/		cpu::op::nop();
		/* 821B6CBCh case    7:*/		return 0x821B6CC0;
	}
	return 0x821B6CC0;
} // Block from 821B6CA0h-821B6CC0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821B6CC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6CC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6CC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6CC0);
		  /* 821B6CC0h */ case    0:  		/* mfspr R12, LR */
		/* 821B6CC0h case    0:*/		regs.R12 = regs.LR;
		/* 821B6CC0h case    0:*/		return 0x821B6CC4;
		  /* 821B6CC4h */ case    1:  		/* bl -1202828 */
		/* 821B6CC4h case    1:*/		regs.LR = 0x821B6CC8; return 0x82091238;
		/* 821B6CC4h case    1:*/		return 0x821B6CC8;
		  /* 821B6CC8h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 821B6CC8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 821B6CC8h case    2:*/		return 0x821B6CCC;
		  /* 821B6CCCh */ case    3:  		/* addi R24, R6, 44 */
		/* 821B6CCCh case    3:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R6,0x2C);
		/* 821B6CCCh case    3:*/		return 0x821B6CD0;
		  /* 821B6CD0h */ case    4:  		/* mr R22, R3 */
		/* 821B6CD0h case    4:*/		regs.R22 = regs.R3;
		/* 821B6CD0h case    4:*/		return 0x821B6CD4;
		  /* 821B6CD4h */ case    5:  		/* mr R25, R4 */
		/* 821B6CD4h case    5:*/		regs.R25 = regs.R4;
		/* 821B6CD4h case    5:*/		return 0x821B6CD8;
		  /* 821B6CD8h */ case    6:  		/* mr R26, R5 */
		/* 821B6CD8h case    6:*/		regs.R26 = regs.R5;
		/* 821B6CD8h case    6:*/		return 0x821B6CDC;
		  /* 821B6CDCh */ case    7:  		/* mr R21, R6 */
		/* 821B6CDCh case    7:*/		regs.R21 = regs.R6;
		/* 821B6CDCh case    7:*/		return 0x821B6CE0;
		  /* 821B6CE0h */ case    8:  		/* li R20, 0 */
		/* 821B6CE0h case    8:*/		cpu::op::li<0>(regs,&regs.R20,0x0);
		/* 821B6CE0h case    8:*/		return 0x821B6CE4;
		  /* 821B6CE4h */ case    9:  		/* mr R23, R24 */
		/* 821B6CE4h case    9:*/		regs.R23 = regs.R24;
		/* 821B6CE4h case    9:*/		return 0x821B6CE8;
		  /* 821B6CE8h */ case   10:  		/* lwz R11, <#[R21 + 8]> */
		/* 821B6CE8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000008) );
		/* 821B6CE8h case   10:*/		return 0x821B6CEC;
		  /* 821B6CECh */ case   11:  		/* rlwinm R8, R11, 13, 29, 31 */
		/* 821B6CECh case   11:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R8,regs.R11);
		/* 821B6CECh case   11:*/		return 0x821B6CF0;
		  /* 821B6CF0h */ case   12:  		/* cmplw CR6, R20, R8 */
		/* 821B6CF0h case   12:*/		cpu::op::cmplw<6>(regs,regs.R20,regs.R8);
		/* 821B6CF0h case   12:*/		return 0x821B6CF4;
		  /* 821B6CF4h */ case   13:  		/* bc 4, CR6_LT, 268 */
		/* 821B6CF4h case   13:*/		if ( !regs.CR[6].lt ) { return 0x821B6E00;  }
		/* 821B6CF4h case   13:*/		return 0x821B6CF8;
		  /* 821B6CF8h */ case   14:  		/* lwz R27, <#[R23]> */
		/* 821B6CF8h case   14:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R23 + 0x00000000) );
		/* 821B6CF8h case   14:*/		return 0x821B6CFC;
		  /* 821B6CFCh */ case   15:  		/* li R9, 0 */
		/* 821B6CFCh case   15:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821B6CFCh case   15:*/		return 0x821B6D00;
		  /* 821B6D00h */ case   16:  		/* mr R10, R24 */
		/* 821B6D00h case   16:*/		regs.R10 = regs.R24;
		/* 821B6D00h case   16:*/		return 0x821B6D04;
		  /* 821B6D04h */ case   17:  		/* lwz R28, <#[R27 + 12]> */
		/* 821B6D04h case   17:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R27 + 0x0000000C) );
		/* 821B6D04h case   17:*/		return 0x821B6D08;
		  /* 821B6D08h */ case   18:  		/* cmplw CR6, R9, R8 */
		/* 821B6D08h case   18:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 821B6D08h case   18:*/		return 0x821B6D0C;
		  /* 821B6D0Ch */ case   19:  		/* bc 4, CR6_LT, 40 */
		/* 821B6D0Ch case   19:*/		if ( !regs.CR[6].lt ) { return 0x821B6D34;  }
		/* 821B6D0Ch case   19:*/		return 0x821B6D10;
		  /* 821B6D10h */ case   20:  		/* lwz R11, <#[R10]> */
		/* 821B6D10h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 821B6D10h case   20:*/		return 0x821B6D14;
		  /* 821B6D14h */ case   21:  		/* cmplw CR6, R27, R11 */
		/* 821B6D14h case   21:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 821B6D14h case   21:*/		return 0x821B6D18;
	}
	return 0x821B6D18;
} // Block from 821B6CC0h-821B6D18h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821B6D18h
// Function '?MarkGlobalDef@Compiler@D3DXShader@@AAAXPAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6D18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6D18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6D18);
		  /* 821B6D18h */ case    0:  		/* bc 12, CR6_EQ, 40 */
		/* 821B6D18h case    0:*/		if ( regs.CR[6].eq ) { return 0x821B6D40;  }
		/* 821B6D18h case    0:*/		return 0x821B6D1C;
		  /* 821B6D1Ch */ case    1:  		/* lwz R7, <#[R11 + 12]> */
		/* 821B6D1Ch case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x0000000C) );
		/* 821B6D1Ch case    1:*/		return 0x821B6D20;
		  /* 821B6D20h */ case    2:  		/* cmplw CR6, R7, R28 */
		/* 821B6D20h case    2:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R28);
		/* 821B6D20h case    2:*/		return 0x821B6D24;
		  /* 821B6D24h */ case    3:  		/* bc 12, CR6_EQ, 20 */
		/* 821B6D24h case    3:*/		if ( regs.CR[6].eq ) { return 0x821B6D38;  }
		/* 821B6D24h case    3:*/		return 0x821B6D28;
		  /* 821B6D28h */ case    4:  		/* addi R9, R9, 1 */
		/* 821B6D28h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 821B6D28h case    4:*/		return 0x821B6D2C;
		  /* 821B6D2Ch */ case    5:  		/* addi R10, R10, 4 */
		/* 821B6D2Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821B6D2Ch case    5:*/		return 0x821B6D30;
		  /* 821B6D30h */ case    6:  		/* b -40 */
		/* 821B6D30h case    6:*/		return 0x821B6D08;
		/* 821B6D30h case    6:*/		return 0x821B6D34;
	}
	return 0x821B6D34;
} // Block from 821B6D18h-821B6D34h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821B6D34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6D34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6D34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6D34);
		  /* 821B6D34h */ case    0:  		/* li R11, 0 */
		/* 821B6D34h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821B6D34h case    0:*/		return 0x821B6D38;
	}
	return 0x821B6D38;
} // Block from 821B6D34h-821B6D38h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B6D38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6D38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6D38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6D38);
		  /* 821B6D38h */ case    0:  		/* cmplw CR6, R27, R11 */
		/* 821B6D38h case    0:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R11);
		/* 821B6D38h case    0:*/		return 0x821B6D3C;
		  /* 821B6D3Ch */ case    1:  		/* bc 4, CR6_EQ, 184 */
		/* 821B6D3Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x821B6DF4;  }
		/* 821B6D3Ch case    1:*/		return 0x821B6D40;
	}
	return 0x821B6D40;
} // Block from 821B6D38h-821B6D40h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B6D40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6D40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6D40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6D40);
		  /* 821B6D40h */ case    0:  		/* lwz R11, <#[R25]> */
		/* 821B6D40h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 821B6D40h case    0:*/		return 0x821B6D44;
		  /* 821B6D44h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 821B6D44h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821B6D44h case    1:*/		return 0x821B6D48;
		  /* 821B6D48h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 821B6D48h case    2:*/		if ( regs.CR[6].eq ) { return 0x821B6D60;  }
		/* 821B6D48h case    2:*/		return 0x821B6D4C;
		  /* 821B6D4Ch */ case    3:  		/* lwz R10, <#[R11 + 12]> */
		/* 821B6D4Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 821B6D4Ch case    3:*/		return 0x821B6D50;
		  /* 821B6D50h */ case    4:  		/* cmplw CR6, R10, R28 */
		/* 821B6D50h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R28);
		/* 821B6D50h case    4:*/		return 0x821B6D54;
		  /* 821B6D54h */ case    5:  		/* bc 12, CR6_EQ, 160 */
		/* 821B6D54h case    5:*/		if ( regs.CR[6].eq ) { return 0x821B6DF4;  }
		/* 821B6D54h case    5:*/		return 0x821B6D58;
		  /* 821B6D58h */ case    6:  		/* lwz R11, <#[R11 + 4]> */
		/* 821B6D58h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821B6D58h case    6:*/		return 0x821B6D5C;
		  /* 821B6D5Ch */ case    7:  		/* b -24 */
		/* 821B6D5Ch case    7:*/		return 0x821B6D44;
		/* 821B6D5Ch case    7:*/		return 0x821B6D60;
	}
	return 0x821B6D60;
} // Block from 821B6D40h-821B6D60h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821B6D60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6D60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6D60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6D60);
		  /* 821B6D60h */ case    0:  		/* addi R11, R26, 10 */
		/* 821B6D60h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0xA);
		/* 821B6D60h case    0:*/		return 0x821B6D64;
		  /* 821B6D64h */ case    1:  		/* lwz R10, <#[R28 + 8]> */
		/* 821B6D64h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000008) );
		/* 821B6D64h case    1:*/		return 0x821B6D68;
		  /* 821B6D68h */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821B6D68h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821B6D68h case    2:*/		return 0x821B6D6C;
		  /* 821B6D6Ch */ case    3:  		/* rlwinm R31, R10, 31, 28, 31 */
		/* 821B6D6Ch case    3:*/		cpu::op::rlwinm<0,31,28,31>(regs,&regs.R31,regs.R10);
		/* 821B6D6Ch case    3:*/		return 0x821B6D70;
		  /* 821B6D70h */ case    4:  		/* add R30, R11, R25 */
		/* 821B6D70h case    4:*/		cpu::op::add<0>(regs,&regs.R30,regs.R11,regs.R25);
		/* 821B6D70h case    4:*/		return 0x821B6D74;
		  /* 821B6D74h */ case    5:  		/* cmplwi CR6, R31, 0 */
		/* 821B6D74h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821B6D74h case    5:*/		return 0x821B6D78;
		  /* 821B6D78h */ case    6:  		/* bc 12, CR6_EQ, 124 */
		/* 821B6D78h case    6:*/		if ( regs.CR[6].eq ) { return 0x821B6DF4;  }
		/* 821B6D78h case    6:*/		return 0x821B6D7C;
		  /* 821B6D7Ch */ case    7:  		/* addi R11, R31, -1 */
		/* 821B6D7Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFFF);
		/* 821B6D7Ch case    7:*/		return 0x821B6D80;
		  /* 821B6D80h */ case    8:  		/* mr R4, R28 */
		/* 821B6D80h case    8:*/		regs.R4 = regs.R28;
		/* 821B6D80h case    8:*/		return 0x821B6D84;
		  /* 821B6D84h */ case    9:  		/* andc R11, R31, R11 */
		/* 821B6D84h case    9:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R31,regs.R11);
		/* 821B6D84h case    9:*/		return 0x821B6D88;
		  /* 821B6D88h */ case   10:  		/* mr R3, R22 */
		/* 821B6D88h case   10:*/		regs.R3 = regs.R22;
		/* 821B6D88h case   10:*/		return 0x821B6D8C;
		  /* 821B6D8Ch */ case   11:  		/* cntlzw R11, R11 */
		/* 821B6D8Ch case   11:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 821B6D8Ch case   11:*/		return 0x821B6D90;
		  /* 821B6D90h */ case   12:  		/* subfic R29, R11, 31 */
		/* 821B6D90h case   12:*/		cpu::op::subfic<0>(regs,&regs.R29,regs.R11,0x1F);
		/* 821B6D90h case   12:*/		return 0x821B6D94;
		  /* 821B6D94h */ case   13:  		/* bl -257428 */
		/* 821B6D94h case   13:*/		regs.LR = 0x821B6D98; return 0x82178000;
		/* 821B6D94h case   13:*/		return 0x821B6D98;
		  /* 821B6D98h */ case   14:  		/* mr R11, R3 */
		/* 821B6D98h case   14:*/		regs.R11 = regs.R3;
		/* 821B6D98h case   14:*/		return 0x821B6D9C;
		  /* 821B6D9Ch */ case   15:  		/* rlwinm R10, R29, 5, 22, 26 */
		/* 821B6D9Ch case   15:*/		cpu::op::rlwinm<0,5,22,26>(regs,&regs.R10,regs.R29);
		/* 821B6D9Ch case   15:*/		return 0x821B6DA0;
		  /* 821B6DA0h */ case   16:  		/* lis R12, -3073 */
		/* 821B6DA0h case   16:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFFF3FF);
		/* 821B6DA0h case   16:*/		return 0x821B6DA4;
		  /* 821B6DA4h */ case   17:  		/* rlwinm R10, R10, 0, 25, 23 */
		/* 821B6DA4h case   17:*/		cpu::op::rlwinm<0,0,25,23>(regs,&regs.R10,regs.R10);
		/* 821B6DA4h case   17:*/		return 0x821B6DA8;
		  /* 821B6DA8h */ case   18:  		/* ori R12, R12, 64671 */
		/* 821B6DA8h case   18:*/		cpu::op::ori<0>(regs,&regs.R12,regs.R12,0xFC9F);
		/* 821B6DA8h case   18:*/		return 0x821B6DAC;
		  /* 821B6DACh */ case   19:  		/* lwz R9, <#[R11]> */
		/* 821B6DACh case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821B6DACh case   19:*/		return 0x821B6DB0;
		  /* 821B6DB0h */ case   20:  		/* oris R10, R10, 512 */
		/* 821B6DB0h case   20:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x200);
		/* 821B6DB0h case   20:*/		return 0x821B6DB4;
		  /* 821B6DB4h */ case   21:  		/* mr R3, R25 */
		/* 821B6DB4h case   21:*/		regs.R3 = regs.R25;
		/* 821B6DB4h case   21:*/		return 0x821B6DB8;
		  /* 821B6DB8h */ case   22:  		/* and R9, R9, R12 */
		/* 821B6DB8h case   22:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R12);
		/* 821B6DB8h case   22:*/		return 0x821B6DBC;
		  /* 821B6DBCh */ case   23:  		/* ori R10, R10, 7296 */
		/* 821B6DBCh case   23:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1C80);
		/* 821B6DBCh case   23:*/		return 0x821B6DC0;
		  /* 821B6DC0h */ case   24:  		/* mr R4, R11 */
		/* 821B6DC0h case   24:*/		regs.R4 = regs.R11;
		/* 821B6DC0h case   24:*/		return 0x821B6DC4;
		  /* 821B6DC4h */ case   25:  		/* or R10, R10, R9 */
		/* 821B6DC4h case   25:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 821B6DC4h case   25:*/		return 0x821B6DC8;
		  /* 821B6DC8h */ case   26:  		/* stw R10, <#[R11]> */
		/* 821B6DC8h case   26:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821B6DC8h case   26:*/		return 0x821B6DCC;
		  /* 821B6DCCh */ case   27:  		/* lwz R9, <#[R27]> */
		/* 821B6DCCh case   27:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000000) );
		/* 821B6DCCh case   27:*/		return 0x821B6DD0;
		  /* 821B6DD0h */ case   28:  		/* rlwimi R9, R10, 0, 0, 26 */
		/* 821B6DD0h case   28:*/		cpu::op::rlwimi<0,0,0,26>(regs,&regs.R9,regs.R10);
		/* 821B6DD0h case   28:*/		return 0x821B6DD4;
		  /* 821B6DD4h */ case   29:  		/* stw R9, <#[R11]> */
		/* 821B6DD4h case   29:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821B6DD4h case   29:*/		return 0x821B6DD8;
		  /* 821B6DD8h */ case   30:  		/* bl -257040 */
		/* 821B6DD8h case   30:*/		regs.LR = 0x821B6DDC; return 0x821781C8;
		/* 821B6DD8h case   30:*/		return 0x821B6DDC;
		  /* 821B6DDCh */ case   31:  		/* addi R11, R31, -1 */
		/* 821B6DDCh case   31:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFFF);
		/* 821B6DDCh case   31:*/		return 0x821B6DE0;
		  /* 821B6DE0h */ case   32:  		/* stwu R3, <#[R30 + 4]> */
		/* 821B6DE0h case   32:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000004) );
		regs.R30 = (uint32)(regs.R30 + 0x00000004);
		/* 821B6DE0h case   32:*/		return 0x821B6DE4;
		  /* 821B6DE4h */ case   33:  		/* addi R26, R26, 1 */
		/* 821B6DE4h case   33:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 821B6DE4h case   33:*/		return 0x821B6DE8;
		  /* 821B6DE8h */ case   34:  		/* andc R11, R31, R11 */
		/* 821B6DE8h case   34:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R31,regs.R11);
		/* 821B6DE8h case   34:*/		return 0x821B6DEC;
		  /* 821B6DECh */ case   35:  		/* subf R31, R11, R31 */
		/* 821B6DECh case   35:*/		cpu::op::subf<0>(regs,&regs.R31,regs.R11,regs.R31);
		/* 821B6DECh case   35:*/		return 0x821B6DF0;
		  /* 821B6DF0h */ case   36:  		/* b -124 */
		/* 821B6DF0h case   36:*/		return 0x821B6D74;
		/* 821B6DF0h case   36:*/		return 0x821B6DF4;
	}
	return 0x821B6DF4;
} // Block from 821B6D60h-821B6DF4h (37 instructions)

//////////////////////////////////////////////////////
// Block at 821B6DF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6DF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6DF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6DF4);
		  /* 821B6DF4h */ case    0:  		/* addi R20, R20, 1 */
		/* 821B6DF4h case    0:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R20,0x1);
		/* 821B6DF4h case    0:*/		return 0x821B6DF8;
		  /* 821B6DF8h */ case    1:  		/* addi R23, R23, 4 */
		/* 821B6DF8h case    1:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R23,0x4);
		/* 821B6DF8h case    1:*/		return 0x821B6DFC;
		  /* 821B6DFCh */ case    2:  		/* b -276 */
		/* 821B6DFCh case    2:*/		return 0x821B6CE8;
		/* 821B6DFCh case    2:*/		return 0x821B6E00;
	}
	return 0x821B6E00;
} // Block from 821B6DF4h-821B6E00h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821B6E00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6E00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6E00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6E00);
		  /* 821B6E00h */ case    0:  		/* mr R3, R26 */
		/* 821B6E00h case    0:*/		regs.R3 = regs.R26;
		/* 821B6E00h case    0:*/		return 0x821B6E04;
		  /* 821B6E04h */ case    1:  		/* addi R1, R1, 192 */
		/* 821B6E04h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 821B6E04h case    1:*/		return 0x821B6E08;
		  /* 821B6E08h */ case    2:  		/* b -1203072 */
		/* 821B6E08h case    2:*/		return 0x82091288;
		/* 821B6E08h case    2:*/		return 0x821B6E0C;
		  /* 821B6E0Ch */ case    3:  		/* nop */
		/* 821B6E0Ch case    3:*/		cpu::op::nop();
		/* 821B6E0Ch case    3:*/		return 0x821B6E10;
	}
	return 0x821B6E10;
} // Block from 821B6E00h-821B6E10h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821B6E10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6E10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6E10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6E10);
		  /* 821B6E10h */ case    0:  		/* mfspr R12, LR */
		/* 821B6E10h case    0:*/		regs.R12 = regs.LR;
		/* 821B6E10h case    0:*/		return 0x821B6E14;
		  /* 821B6E14h */ case    1:  		/* bl -1203136 */
		/* 821B6E14h case    1:*/		regs.LR = 0x821B6E18; return 0x82091254;
		/* 821B6E14h case    1:*/		return 0x821B6E18;
		  /* 821B6E18h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821B6E18h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821B6E18h case    2:*/		return 0x821B6E1C;
		  /* 821B6E1Ch */ case    3:  		/* mr R29, R5 */
		/* 821B6E1Ch case    3:*/		regs.R29 = regs.R5;
		/* 821B6E1Ch case    3:*/		return 0x821B6E20;
		  /* 821B6E20h */ case    4:  		/* mr R27, R6 */
		/* 821B6E20h case    4:*/		regs.R27 = regs.R6;
		/* 821B6E20h case    4:*/		return 0x821B6E24;
		  /* 821B6E24h */ case    5:  		/* li R8, 4 */
		/* 821B6E24h case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821B6E24h case    5:*/		return 0x821B6E28;
		  /* 821B6E28h */ case    6:  		/* li R7, 2 */
		/* 821B6E28h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821B6E28h case    6:*/		return 0x821B6E2C;
		  /* 821B6E2Ch */ case    7:  		/* li R6, 3 */
		/* 821B6E2Ch case    7:*/		cpu::op::li<0>(regs,&regs.R6,0x3);
		/* 821B6E2Ch case    7:*/		return 0x821B6E30;
		  /* 821B6E30h */ case    8:  		/* li R5, 0 */
		/* 821B6E30h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821B6E30h case    8:*/		return 0x821B6E34;
		  /* 821B6E34h */ case    9:  		/* mr R28, R3 */
		/* 821B6E34h case    9:*/		regs.R28 = regs.R3;
		/* 821B6E34h case    9:*/		return 0x821B6E38;
		  /* 821B6E38h */ case   10:  		/* mr R30, R4 */
		/* 821B6E38h case   10:*/		regs.R30 = regs.R4;
		/* 821B6E38h case   10:*/		return 0x821B6E3C;
		  /* 821B6E3Ch */ case   11:  		/* bl 449372 */
		/* 821B6E3Ch case   11:*/		regs.LR = 0x821B6E40; return 0x82224998;
		/* 821B6E3Ch case   11:*/		return 0x821B6E40;
	}
	return 0x821B6E40;
} // Block from 821B6E10h-821B6E40h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821B6E40h
// Function '?CollectComponentsNeeded@Compiler@D3DXShader@@AAAPAVDependency@2@PAVInstruction@2@III@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6E40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6E40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6E40);
		  /* 821B6E40h */ case    0:  		/* lwz R11, <#[R29 + 16]> */
		/* 821B6E40h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000010) );
		/* 821B6E40h case    0:*/		return 0x821B6E44;
		  /* 821B6E44h */ case    1:  		/* mr R31, R3 */
		/* 821B6E44h case    1:*/		regs.R31 = regs.R3;
		/* 821B6E44h case    1:*/		return 0x821B6E48;
		  /* 821B6E48h */ case    2:  		/* mr R4, R29 */
		/* 821B6E48h case    2:*/		regs.R4 = regs.R29;
		/* 821B6E48h case    2:*/		return 0x821B6E4C;
		  /* 821B6E4Ch */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 821B6E4Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821B6E4Ch case    3:*/		return 0x821B6E50;
		  /* 821B6E50h */ case    4:  		/* bc 12, CR6_EQ, 20 */
		/* 821B6E50h case    4:*/		if ( regs.CR[6].eq ) { return 0x821B6E64;  }
		/* 821B6E50h case    4:*/		return 0x821B6E54;
		  /* 821B6E54h */ case    5:  		/* mr R3, R28 */
		/* 821B6E54h case    5:*/		regs.R3 = regs.R28;
		/* 821B6E54h case    5:*/		return 0x821B6E58;
		  /* 821B6E58h */ case    6:  		/* lwz R5, <#[R29 + 12]> */
		/* 821B6E58h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821B6E58h case    6:*/		return 0x821B6E5C;
		  /* 821B6E5Ch */ case    7:  		/* bl -286060 */
		/* 821B6E5Ch case    7:*/		regs.LR = 0x821B6E60; return 0x821710F0;
		/* 821B6E5Ch case    7:*/		return 0x821B6E60;
		  /* 821B6E60h */ case    8:  		/* mr R4, R3 */
		/* 821B6E60h case    8:*/		regs.R4 = regs.R3;
		/* 821B6E60h case    8:*/		return 0x821B6E64;
	}
	return 0x821B6E64;
} // Block from 821B6E40h-821B6E64h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821B6E64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6E64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6E64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6E64);
		  /* 821B6E64h */ case    0:  		/* mr R3, R31 */
		/* 821B6E64h case    0:*/		regs.R3 = regs.R31;
		/* 821B6E64h case    0:*/		return 0x821B6E68;
		  /* 821B6E68h */ case    1:  		/* bl -257184 */
		/* 821B6E68h case    1:*/		regs.LR = 0x821B6E6C; return 0x821781C8;
		/* 821B6E68h case    1:*/		return 0x821B6E6C;
		  /* 821B6E6Ch */ case    2:  		/* stw R3, <#[R31 + 44]> */
		/* 821B6E6Ch case    2:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821B6E6Ch case    2:*/		return 0x821B6E70;
		  /* 821B6E70h */ case    3:  		/* lwz R11, <#[R27 + 16]> */
		/* 821B6E70h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000010) );
		/* 821B6E70h case    3:*/		return 0x821B6E74;
		  /* 821B6E74h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 821B6E74h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821B6E74h case    4:*/		return 0x821B6E78;
		  /* 821B6E78h */ case    5:  		/* mr R4, R27 */
		/* 821B6E78h case    5:*/		regs.R4 = regs.R27;
		/* 821B6E78h case    5:*/		return 0x821B6E7C;
		  /* 821B6E7Ch */ case    6:  		/* bc 12, CR6_EQ, 20 */
		/* 821B6E7Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x821B6E90;  }
		/* 821B6E7Ch case    6:*/		return 0x821B6E80;
		  /* 821B6E80h */ case    7:  		/* mr R3, R28 */
		/* 821B6E80h case    7:*/		regs.R3 = regs.R28;
		/* 821B6E80h case    7:*/		return 0x821B6E84;
		  /* 821B6E84h */ case    8:  		/* lwz R5, <#[R27 + 12]> */
		/* 821B6E84h case    8:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R27 + 0x0000000C) );
		/* 821B6E84h case    8:*/		return 0x821B6E88;
		  /* 821B6E88h */ case    9:  		/* bl -286104 */
		/* 821B6E88h case    9:*/		regs.LR = 0x821B6E8C; return 0x821710F0;
		/* 821B6E88h case    9:*/		return 0x821B6E8C;
		  /* 821B6E8Ch */ case   10:  		/* mr R4, R3 */
		/* 821B6E8Ch case   10:*/		regs.R4 = regs.R3;
		/* 821B6E8Ch case   10:*/		return 0x821B6E90;
	}
	return 0x821B6E90;
} // Block from 821B6E64h-821B6E90h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821B6E90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6E90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6E90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6E90);
		  /* 821B6E90h */ case    0:  		/* mr R3, R31 */
		/* 821B6E90h case    0:*/		regs.R3 = regs.R31;
		/* 821B6E90h case    0:*/		return 0x821B6E94;
		  /* 821B6E94h */ case    1:  		/* bl -257228 */
		/* 821B6E94h case    1:*/		regs.LR = 0x821B6E98; return 0x821781C8;
		/* 821B6E94h case    1:*/		return 0x821B6E98;
		  /* 821B6E98h */ case    2:  		/* lwz R9, <#[R31 + 44]> */
		/* 821B6E98h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000002C) );
		/* 821B6E98h case    2:*/		return 0x821B6E9C;
		  /* 821B6E9Ch */ case    3:  		/* stw R3, <#[R31 + 48]> */
		/* 821B6E9Ch case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821B6E9Ch case    3:*/		return 0x821B6EA0;
		  /* 821B6EA0h */ case    4:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821B6EA0h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821B6EA0h case    4:*/		return 0x821B6EA4;
		  /* 821B6EA4h */ case    5:  		/* lwz R8, <#[R31 + 8]> */
		/* 821B6EA4h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000008) );
		/* 821B6EA4h case    5:*/		return 0x821B6EA8;
		  /* 821B6EA8h */ case    6:  		/* addi R10, R30, 24 */
		/* 821B6EA8h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0x18);
		/* 821B6EA8h case    6:*/		return 0x821B6EAC;
		  /* 821B6EACh */ case    7:  		/* addi R11, R11, 36 */
		/* 821B6EACh case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821B6EACh case    7:*/		return 0x821B6EB0;
		  /* 821B6EB0h */ case    8:  		/* addi R10, R10, -36 */
		/* 821B6EB0h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFDC);
		/* 821B6EB0h case    8:*/		return 0x821B6EB4;
		  /* 821B6EB4h */ case    9:  		/* lwz R9, <#[R9]> */
		/* 821B6EB4h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000000) );
		/* 821B6EB4h case    9:*/		return 0x821B6EB8;
		  /* 821B6EB8h */ case   10:  		/* rlwinm R9, R9, 7, 29, 31 */
		/* 821B6EB8h case   10:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R9,regs.R9);
		/* 821B6EB8h case   10:*/		return 0x821B6EBC;
		  /* 821B6EBCh */ case   11:  		/* rlwimi R8, R9, 14, 15, 17 */
		/* 821B6EBCh case   11:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R8,regs.R9);
		/* 821B6EBCh case   11:*/		return 0x821B6EC0;
		  /* 821B6EC0h */ case   12:  		/* addi R9, R11, -36 */
		/* 821B6EC0h case   12:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFDC);
		/* 821B6EC0h case   12:*/		return 0x821B6EC4;
		  /* 821B6EC4h */ case   13:  		/* stw R8, <#[R31 + 8]> */
		/* 821B6EC4h case   13:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R31 + 0x00000008) );
		/* 821B6EC4h case   13:*/		return 0x821B6EC8;
		  /* 821B6EC8h */ case   14:  		/* ori R8, R10, 1 */
		/* 821B6EC8h case   14:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R10,0x1);
		/* 821B6EC8h case   14:*/		return 0x821B6ECC;
		  /* 821B6ECCh */ case   15:  		/* lwz R7, <#[R30 + 24]> */
		/* 821B6ECCh case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000018) );
		/* 821B6ECCh case   15:*/		return 0x821B6ED0;
		  /* 821B6ED0h */ case   16:  		/* addi R10, R11, 4 */
		/* 821B6ED0h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 821B6ED0h case   16:*/		return 0x821B6ED4;
		  /* 821B6ED4h */ case   17:  		/* stw R7, <#[R11]> */
		/* 821B6ED4h case   17:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821B6ED4h case   17:*/		return 0x821B6ED8;
		  /* 821B6ED8h */ case   18:  		/* mr R3, R31 */
		/* 821B6ED8h case   18:*/		regs.R3 = regs.R31;
		/* 821B6ED8h case   18:*/		return 0x821B6EDC;
		  /* 821B6EDCh */ case   19:  		/* lwz R7, <#[R30 + 24]> */
		/* 821B6EDCh case   19:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R30 + 0x00000018) );
		/* 821B6EDCh case   19:*/		return 0x821B6EE0;
		  /* 821B6EE0h */ case   20:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821B6EE0h case   20:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821B6EE0h case   20:*/		return 0x821B6EE4;
		  /* 821B6EE4h */ case   21:  		/* stw R9, <#[R7]> */
		/* 821B6EE4h case   21:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R7 + 0x00000000) );
		/* 821B6EE4h case   21:*/		return 0x821B6EE8;
		  /* 821B6EE8h */ case   22:  		/* stw R8, <#[R11 + 4]> */
		/* 821B6EE8h case   22:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 821B6EE8h case   22:*/		return 0x821B6EEC;
		  /* 821B6EECh */ case   23:  		/* stw R10, <#[R30 + 24]> */
		/* 821B6EECh case   23:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000018) );
		/* 821B6EECh case   23:*/		return 0x821B6EF0;
		  /* 821B6EF0h */ case   24:  		/* addi R1, R1, 128 */
		/* 821B6EF0h case   24:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821B6EF0h case   24:*/		return 0x821B6EF4;
		  /* 821B6EF4h */ case   25:  		/* b -1203280 */
		/* 821B6EF4h case   25:*/		return 0x820912A4;
		/* 821B6EF4h case   25:*/		return 0x821B6EF8;
	}
	return 0x821B6EF8;
} // Block from 821B6E90h-821B6EF8h (26 instructions)

//////////////////////////////////////////////////////
// Block at 821B6EF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6EF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6EF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6EF8);
		  /* 821B6EF8h */ case    0:  		/* mfspr R12, LR */
		/* 821B6EF8h case    0:*/		regs.R12 = regs.LR;
		/* 821B6EF8h case    0:*/		return 0x821B6EFC;
		  /* 821B6EFCh */ case    1:  		/* bl -1203368 */
		/* 821B6EFCh case    1:*/		regs.LR = 0x821B6F00; return 0x82091254;
		/* 821B6EFCh case    1:*/		return 0x821B6F00;
		  /* 821B6F00h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821B6F00h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821B6F00h case    2:*/		return 0x821B6F04;
		  /* 821B6F04h */ case    3:  		/* mr R31, R5 */
		/* 821B6F04h case    3:*/		regs.R31 = regs.R5;
		/* 821B6F04h case    3:*/		return 0x821B6F08;
		  /* 821B6F08h */ case    4:  		/* mr R28, R6 */
		/* 821B6F08h case    4:*/		regs.R28 = regs.R6;
		/* 821B6F08h case    4:*/		return 0x821B6F0C;
		  /* 821B6F0Ch */ case    5:  		/* mr R27, R7 */
		/* 821B6F0Ch case    5:*/		regs.R27 = regs.R7;
		/* 821B6F0Ch case    5:*/		return 0x821B6F10;
	}
	return 0x821B6F10;
} // Block from 821B6EF8h-821B6F10h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821B6F10h
// Function '?RewriteMERGEDependents@Compiler@D3DXShader@@AAAXPAVInstruction@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6F10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6F10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6F10);
		  /* 821B6F10h */ case    0:  		/* li R8, 4 */
		/* 821B6F10h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x4);
		/* 821B6F10h case    0:*/		return 0x821B6F14;
		  /* 821B6F14h */ case    1:  		/* li R7, 2 */
		/* 821B6F14h case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821B6F14h case    1:*/		return 0x821B6F18;
		  /* 821B6F18h */ case    2:  		/* li R6, 3 */
		/* 821B6F18h case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x3);
		/* 821B6F18h case    2:*/		return 0x821B6F1C;
		  /* 821B6F1Ch */ case    3:  		/* li R5, 0 */
		/* 821B6F1Ch case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821B6F1Ch case    3:*/		return 0x821B6F20;
		  /* 821B6F20h */ case    4:  		/* mr R29, R3 */
		/* 821B6F20h case    4:*/		regs.R29 = regs.R3;
		/* 821B6F20h case    4:*/		return 0x821B6F24;
		  /* 821B6F24h */ case    5:  		/* bl 449140 */
		/* 821B6F24h case    5:*/		regs.LR = 0x821B6F28; return 0x82224998;
		/* 821B6F24h case    5:*/		return 0x821B6F28;
		  /* 821B6F28h */ case    6:  		/* mr R30, R3 */
		/* 821B6F28h case    6:*/		regs.R30 = regs.R3;
		/* 821B6F28h case    6:*/		return 0x821B6F2C;
		  /* 821B6F2Ch */ case    7:  		/* mr R3, R29 */
		/* 821B6F2Ch case    7:*/		regs.R3 = regs.R29;
		/* 821B6F2Ch case    7:*/		return 0x821B6F30;
		  /* 821B6F30h */ case    8:  		/* mr R4, R28 */
		/* 821B6F30h case    8:*/		regs.R4 = regs.R28;
		/* 821B6F30h case    8:*/		return 0x821B6F34;
		  /* 821B6F34h */ case    9:  		/* bl -257844 */
		/* 821B6F34h case    9:*/		regs.LR = 0x821B6F38; return 0x82178000;
		/* 821B6F34h case    9:*/		return 0x821B6F38;
		  /* 821B6F38h */ case   10:  		/* mr R4, R3 */
		/* 821B6F38h case   10:*/		regs.R4 = regs.R3;
		/* 821B6F38h case   10:*/		return 0x821B6F3C;
		  /* 821B6F3Ch */ case   11:  		/* mr R3, R30 */
		/* 821B6F3Ch case   11:*/		regs.R3 = regs.R30;
		/* 821B6F3Ch case   11:*/		return 0x821B6F40;
		  /* 821B6F40h */ case   12:  		/* bl -257400 */
		/* 821B6F40h case   12:*/		regs.LR = 0x821B6F44; return 0x821781C8;
		/* 821B6F40h case   12:*/		return 0x821B6F44;
		  /* 821B6F44h */ case   13:  		/* stw R3, <#[R30 + 44]> */
		/* 821B6F44h case   13:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x0000002C) );
		/* 821B6F44h case   13:*/		return 0x821B6F48;
		  /* 821B6F48h */ case   14:  		/* mr R4, R27 */
		/* 821B6F48h case   14:*/		regs.R4 = regs.R27;
		/* 821B6F48h case   14:*/		return 0x821B6F4C;
		  /* 821B6F4Ch */ case   15:  		/* mr R3, R29 */
		/* 821B6F4Ch case   15:*/		regs.R3 = regs.R29;
		/* 821B6F4Ch case   15:*/		return 0x821B6F50;
		  /* 821B6F50h */ case   16:  		/* bl -257872 */
		/* 821B6F50h case   16:*/		regs.LR = 0x821B6F54; return 0x82178000;
		/* 821B6F50h case   16:*/		return 0x821B6F54;
		  /* 821B6F54h */ case   17:  		/* mr R4, R3 */
		/* 821B6F54h case   17:*/		regs.R4 = regs.R3;
		/* 821B6F54h case   17:*/		return 0x821B6F58;
		  /* 821B6F58h */ case   18:  		/* mr R3, R30 */
		/* 821B6F58h case   18:*/		regs.R3 = regs.R30;
		/* 821B6F58h case   18:*/		return 0x821B6F5C;
		  /* 821B6F5Ch */ case   19:  		/* bl -257428 */
		/* 821B6F5Ch case   19:*/		regs.LR = 0x821B6F60; return 0x821781C8;
		/* 821B6F5Ch case   19:*/		return 0x821B6F60;
		  /* 821B6F60h */ case   20:  		/* lwz R11, <#[R30 + 44]> */
		/* 821B6F60h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000002C) );
		/* 821B6F60h case   20:*/		return 0x821B6F64;
		  /* 821B6F64h */ case   21:  		/* stw R3, <#[R30 + 48]> */
		/* 821B6F64h case   21:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R30 + 0x00000030) );
		/* 821B6F64h case   21:*/		return 0x821B6F68;
		  /* 821B6F68h */ case   22:  		/* cmplwi CR6, R31, 0 */
		/* 821B6F68h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821B6F68h case   22:*/		return 0x821B6F6C;
		  /* 821B6F6Ch */ case   23:  		/* lwz R10, <#[R30 + 8]> */
		/* 821B6F6Ch case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 821B6F6Ch case   23:*/		return 0x821B6F70;
		  /* 821B6F70h */ case   24:  		/* lwz R11, <#[R11]> */
		/* 821B6F70h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821B6F70h case   24:*/		return 0x821B6F74;
		  /* 821B6F74h */ case   25:  		/* rlwinm R11, R11, 7, 29, 31 */
		/* 821B6F74h case   25:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R11,regs.R11);
		/* 821B6F74h case   25:*/		return 0x821B6F78;
		  /* 821B6F78h */ case   26:  		/* rlwimi R10, R11, 14, 15, 17 */
		/* 821B6F78h case   26:*/		cpu::op::rlwimi<0,14,15,17>(regs,&regs.R10,regs.R11);
		/* 821B6F78h case   26:*/		return 0x821B6F7C;
		  /* 821B6F7Ch */ case   27:  		/* stw R10, <#[R30 + 8]> */
		/* 821B6F7Ch case   27:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 821B6F7Ch case   27:*/		return 0x821B6F80;
		  /* 821B6F80h */ case   28:  		/* bc 12, CR6_EQ, 56 */
		/* 821B6F80h case   28:*/		if ( regs.CR[6].eq ) { return 0x821B6FB8;  }
		/* 821B6F80h case   28:*/		return 0x821B6F84;
		  /* 821B6F84h */ case   29:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 821B6F84h case   29:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 821B6F84h case   29:*/		return 0x821B6F88;
		  /* 821B6F88h */ case   30:  		/* lwz R9, <#[R31]> */
		/* 821B6F88h case   30:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 821B6F88h case   30:*/		return 0x821B6F8C;
		  /* 821B6F8Ch */ case   31:  		/* addi R10, R31, -36 */
		/* 821B6F8Ch case   31:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0xFFFFFFDC);
		/* 821B6F8Ch case   31:*/		return 0x821B6F90;
		  /* 821B6F90h */ case   32:  		/* addi R11, R11, 36 */
		/* 821B6F90h case   32:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821B6F90h case   32:*/		return 0x821B6F94;
		  /* 821B6F94h */ case   33:  		/* ori R8, R10, 1 */
		/* 821B6F94h case   33:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R10,0x1);
		/* 821B6F94h case   33:*/		return 0x821B6F98;
		  /* 821B6F98h */ case   34:  		/* addi R7, R11, -36 */
		/* 821B6F98h case   34:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFDC);
		/* 821B6F98h case   34:*/		return 0x821B6F9C;
		  /* 821B6F9Ch */ case   35:  		/* addi R10, R11, 4 */
		/* 821B6F9Ch case   35:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 821B6F9Ch case   35:*/		return 0x821B6FA0;
		  /* 821B6FA0h */ case   36:  		/* stw R9, <#[R11]> */
		/* 821B6FA0h case   36:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821B6FA0h case   36:*/		return 0x821B6FA4;
		  /* 821B6FA4h */ case   37:  		/* lwz R9, <#[R31]> */
		/* 821B6FA4h case   37:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 821B6FA4h case   37:*/		return 0x821B6FA8;
		  /* 821B6FA8h */ case   38:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 821B6FA8h case   38:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 821B6FA8h case   38:*/		return 0x821B6FAC;
		  /* 821B6FACh */ case   39:  		/* stw R7, <#[R9]> */
		/* 821B6FACh case   39:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + 0x00000000) );
		/* 821B6FACh case   39:*/		return 0x821B6FB0;
		  /* 821B6FB0h */ case   40:  		/* stw R8, <#[R11 + 4]> */
		/* 821B6FB0h case   40:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 821B6FB0h case   40:*/		return 0x821B6FB4;
		  /* 821B6FB4h */ case   41:  		/* stw R10, <#[R31]> */
		/* 821B6FB4h case   41:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 821B6FB4h case   41:*/		return 0x821B6FB8;
	}
	return 0x821B6FB8;
} // Block from 821B6F10h-821B6FB8h (42 instructions)

//////////////////////////////////////////////////////
// Block at 821B6FB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6FB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6FB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6FB8);
		  /* 821B6FB8h */ case    0:  		/* mr R3, R30 */
		/* 821B6FB8h case    0:*/		regs.R3 = regs.R30;
		/* 821B6FB8h case    0:*/		return 0x821B6FBC;
		  /* 821B6FBCh */ case    1:  		/* addi R1, R1, 128 */
		/* 821B6FBCh case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821B6FBCh case    1:*/		return 0x821B6FC0;
		  /* 821B6FC0h */ case    2:  		/* b -1203484 */
		/* 821B6FC0h case    2:*/		return 0x820912A4;
		/* 821B6FC0h case    2:*/		return 0x821B6FC4;
		  /* 821B6FC4h */ case    3:  		/* nop */
		/* 821B6FC4h case    3:*/		cpu::op::nop();
		/* 821B6FC4h case    3:*/		return 0x821B6FC8;
	}
	return 0x821B6FC8;
} // Block from 821B6FB8h-821B6FC8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821B6FC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B6FC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B6FC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B6FC8);
		  /* 821B6FC8h */ case    0:  		/* mfspr R12, LR */
		/* 821B6FC8h case    0:*/		regs.R12 = regs.LR;
		/* 821B6FC8h case    0:*/		return 0x821B6FCC;
		  /* 821B6FCCh */ case    1:  		/* bl -1203580 */
		/* 821B6FCCh case    1:*/		regs.LR = 0x821B6FD0; return 0x82091250;
		/* 821B6FCCh case    1:*/		return 0x821B6FD0;
		  /* 821B6FD0h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 821B6FD0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 821B6FD0h case    2:*/		return 0x821B6FD4;
		  /* 821B6FD4h */ case    3:  		/* mr R29, R3 */
		/* 821B6FD4h case    3:*/		regs.R29 = regs.R3;
		/* 821B6FD4h case    3:*/		return 0x821B6FD8;
		  /* 821B6FD8h */ case    4:  		/* mr R30, R4 */
		/* 821B6FD8h case    4:*/		regs.R30 = regs.R4;
		/* 821B6FD8h case    4:*/		return 0x821B6FDC;
		  /* 821B6FDCh */ case    5:  		/* mr R31, R5 */
		/* 821B6FDCh case    5:*/		regs.R31 = regs.R5;
		/* 821B6FDCh case    5:*/		return 0x821B6FE0;
		  /* 821B6FE0h */ case    6:  		/* mr R28, R6 */
		/* 821B6FE0h case    6:*/		regs.R28 = regs.R6;
		/* 821B6FE0h case    6:*/		return 0x821B6FE4;
		  /* 821B6FE4h */ case    7:  		/* cmplwi CR6, R6, 0 */
		/* 821B6FE4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 821B6FE4h case    7:*/		return 0x821B6FE8;
		  /* 821B6FE8h */ case    8:  		/* bc 4, CR6_EQ, 24 */
		/* 821B6FE8h case    8:*/		if ( !regs.CR[6].eq ) { return 0x821B7000;  }
		/* 821B6FE8h case    8:*/		return 0x821B6FEC;
		  /* 821B6FECh */ case    9:  		/* lwz R11, <#[R3 + 336]> */
		/* 821B6FECh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000150) );
		/* 821B6FECh case    9:*/		return 0x821B6FF0;
		  /* 821B6FF0h */ case   10:  		/* cmplwi CR6, R11, 0 */
		/* 821B6FF0h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821B6FF0h case   10:*/		return 0x821B6FF4;
		  /* 821B6FF4h */ case   11:  		/* bc 12, CR6_EQ, 24 */
		/* 821B6FF4h case   11:*/		if ( regs.CR[6].eq ) { return 0x821B700C;  }
		/* 821B6FF4h case   11:*/		return 0x821B6FF8;
		  /* 821B6FF8h */ case   12:  		/* li R4, 4541 */
		/* 821B6FF8h case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x11BD);
		/* 821B6FF8h case   12:*/		return 0x821B6FFC;
		  /* 821B6FFCh */ case   13:  		/* bl -414100 */
		/* 821B6FFCh case   13:*/		regs.LR = 0x821B7000; return 0x82151E68;
		/* 821B6FFCh case   13:*/		return 0x821B7000;
	}
	return 0x821B7000;
} // Block from 821B6FC8h-821B7000h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821B7000h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7000( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7000) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7000);
		  /* 821B7000h */ case    0:  		/* li R4, 3640 */
		/* 821B7000h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0xE38);
		/* 821B7000h case    0:*/		return 0x821B7004;
		  /* 821B7004h */ case    1:  		/* mr R3, R29 */
		/* 821B7004h case    1:*/		regs.R3 = regs.R29;
		/* 821B7004h case    1:*/		return 0x821B7008;
		  /* 821B7008h */ case    2:  		/* bl -414352 */
		/* 821B7008h case    2:*/		regs.LR = 0x821B700C; return 0x82151D78;
		/* 821B7008h case    2:*/		return 0x821B700C;
	}
	return 0x821B700C;
} // Block from 821B7000h-821B700Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 821B700Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B700C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B700C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B700C);
		  /* 821B700Ch */ case    0:  		/* lis R11, -28311 */
		/* 821B700Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF9169);
		/* 821B700Ch case    0:*/		return 0x821B7010;
		  /* 821B7010h */ case    1:  		/* lis R10, 0 */
		/* 821B7010h case    1:*/		cpu::op::lis<0>(regs,&regs.R10,0x0);
		/* 821B7010h case    1:*/		return 0x821B7014;
		  /* 821B7014h */ case    2:  		/* ori R11, R11, 5192 */
		/* 821B7014h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1448);
		/* 821B7014h case    2:*/		return 0x821B7018;
		  /* 821B7018h */ case    3:  		/* ori R10, R10, 36262 */
		/* 821B7018h case    3:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x8DA6);
		/* 821B7018h case    3:*/		return 0x821B701C;
		  /* 821B701Ch */ case    4:  		/* subfic R28, R28, 15 */
		/* 821B701Ch case    4:*/		cpu::op::subfic<0>(regs,&regs.R28,regs.R28,0xF);
		/* 821B701Ch case    4:*/		return 0x821B7020;
		  /* 821B7020h */ case    5:  		/* rldimi R11, R10, 32, 0 */
		/* 821B7020h case    5:*/		cpu::op::rldimi<0,32,0>(regs,&regs.R11,regs.R10);
		/* 821B7020h case    5:*/		return 0x821B7024;
		  /* 821B7024h */ case    6:  		/* rldicl R10, R28, 0, 32 */
		/* 821B7024h case    6:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R10,regs.R28);
		/* 821B7024h case    6:*/		return 0x821B7028;
	}
	return 0x821B7028;
} // Block from 821B700Ch-821B7028h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821B7028h
// Function '?FindPHIInBlock@Compiler@D3DXShader@@AAAPAVInstruction@2@PAVBlock@2@PAV32@W4Component@2@I_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7028( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7028) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7028);
		  /* 821B7028h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 821B7028h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821B7028h case    0:*/		return 0x821B702C;
		  /* 821B702Ch */ case    1:  		/* srd R11, R11, R10 */
		/* 821B702Ch case    1:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821B702Ch case    1:*/		return 0x821B7030;
		  /* 821B7030h */ case    2:  		/* srd R11, R11, R10 */
		/* 821B7030h case    2:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821B7030h case    2:*/		return 0x821B7034;
		  /* 821B7034h */ case    3:  		/* srd R11, R11, R10 */
		/* 821B7034h case    3:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821B7034h case    3:*/		return 0x821B7038;
		  /* 821B7038h */ case    4:  		/* rlwinm R27, R11, 0, 29, 31 */
		/* 821B7038h case    4:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R27,regs.R11);
		/* 821B7038h case    4:*/		return 0x821B703C;
		  /* 821B703Ch */ case    5:  		/* bc 4, CR6_EQ, 104 */
		/* 821B703Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x821B70A4;  }
		/* 821B703Ch case    5:*/		return 0x821B7040;
		  /* 821B7040h */ case    6:  		/* li R8, 0 */
		/* 821B7040h case    6:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821B7040h case    6:*/		return 0x821B7044;
		  /* 821B7044h */ case    7:  		/* li R7, 0 */
		/* 821B7044h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821B7044h case    7:*/		return 0x821B7048;
		  /* 821B7048h */ case    8:  		/* li R6, 117 */
		/* 821B7048h case    8:*/		cpu::op::li<0>(regs,&regs.R6,0x75);
		/* 821B7048h case    8:*/		return 0x821B704C;
		  /* 821B704Ch */ case    9:  		/* li R5, 0 */
		/* 821B704Ch case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821B704Ch case    9:*/		return 0x821B7050;
		  /* 821B7050h */ case   10:  		/* mr R4, R30 */
		/* 821B7050h case   10:*/		regs.R4 = regs.R30;
		/* 821B7050h case   10:*/		return 0x821B7054;
		  /* 821B7054h */ case   11:  		/* mr R3, R29 */
		/* 821B7054h case   11:*/		regs.R3 = regs.R29;
		/* 821B7054h case   11:*/		return 0x821B7058;
		  /* 821B7058h */ case   12:  		/* bl 448832 */
		/* 821B7058h case   12:*/		regs.LR = 0x821B705C; return 0x82224998;
		/* 821B7058h case   12:*/		return 0x821B705C;
		  /* 821B705Ch */ case   13:  		/* lwz R8, <#[R3 + 8]> */
		/* 821B705Ch case   13:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000008) );
		/* 821B705Ch case   13:*/		return 0x821B7060;
		  /* 821B7060h */ case   14:  		/* rlwinm R9, R3, 0, 0, 30 */
		/* 821B7060h case   14:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R3);
		/* 821B7060h case   14:*/		return 0x821B7064;
		  /* 821B7064h */ case   15:  		/* oris R8, R8, 512 */
		/* 821B7064h case   15:*/		cpu::op::oris<0>(regs,&regs.R8,regs.R8,0x200);
		/* 821B7064h case   15:*/		return 0x821B7068;
		  /* 821B7068h */ case   16:  		/* addi R11, R30, 32 */
		/* 821B7068h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x20);
		/* 821B7068h case   16:*/		return 0x821B706C;
		  /* 821B706Ch */ case   17:  		/* stw R8, <#[R3 + 8]> */
		/* 821B706Ch case   17:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000008) );
		/* 821B706Ch case   17:*/		return 0x821B7070;
		  /* 821B7070h */ case   18:  		/* mr R31, R3 */
		/* 821B7070h case   18:*/		regs.R31 = regs.R3;
		/* 821B7070h case   18:*/		return 0x821B7074;
		  /* 821B7074h */ case   19:  		/* lwz R8, <#[R30 + 36]> */
		/* 821B7074h case   19:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000024) );
		/* 821B7074h case   19:*/		return 0x821B7078;
		  /* 821B7078h */ case   20:  		/* addi R10, R11, 4 */
		/* 821B7078h case   20:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 821B7078h case   20:*/		return 0x821B707C;
		  /* 821B707Ch */ case   21:  		/* stw R8, <#[R9 + 40]> */
		/* 821B707Ch case   21:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + 0x00000028) );
		/* 821B707Ch case   21:*/		return 0x821B7080;
		  /* 821B7080h */ case   22:  		/* addi R11, R9, 36 */
		/* 821B7080h case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0x24);
		/* 821B7080h case   22:*/		return 0x821B7084;
		  /* 821B7084h */ case   23:  		/* lwz R8, <#[R30 + 36]> */
		/* 821B7084h case   23:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x00000024) );
		/* 821B7084h case   23:*/		return 0x821B7088;
		  /* 821B7088h */ case   24:  		/* rlwinm R8, R8, 0, 0, 30 */
		/* 821B7088h case   24:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R8,regs.R8);
		/* 821B7088h case   24:*/		return 0x821B708C;
		  /* 821B708Ch */ case   25:  		/* ori R7, R10, 1 */
		/* 821B708Ch case   25:*/		cpu::op::ori<0>(regs,&regs.R7,regs.R10,0x1);
		/* 821B708Ch case   25:*/		return 0x821B7090;
		  /* 821B7090h */ case   26:  		/* addi R10, R11, 4 */
		/* 821B7090h case   26:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 821B7090h case   26:*/		return 0x821B7094;
		  /* 821B7094h */ case   27:  		/* addi R11, R11, -36 */
		/* 821B7094h case   27:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFDC);
		/* 821B7094h case   27:*/		return 0x821B7098;
		  /* 821B7098h */ case   28:  		/* stw R10, <#[R8 + 36]> */
		/* 821B7098h case   28:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R8 + 0x00000024) );
		/* 821B7098h case   28:*/		return 0x821B709C;
		  /* 821B709Ch */ case   29:  		/* stw R7, <#[R9 + 36]> */
		/* 821B709Ch case   29:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + 0x00000024) );
		/* 821B709Ch case   29:*/		return 0x821B70A0;
		  /* 821B70A0h */ case   30:  		/* stw R11, <#[R30 + 36]> */
		/* 821B70A0h case   30:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000024) );
		/* 821B70A0h case   30:*/		return 0x821B70A4;
	}
	return 0x821B70A4;
} // Block from 821B7028h-821B70A4h (31 instructions)

//////////////////////////////////////////////////////
// Block at 821B70A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B70A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B70A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B70A4);
		  /* 821B70A4h */ case    0:  		/* lis R11, -32256 */
		/* 821B70A4h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 821B70A4h case    0:*/		return 0x821B70A8;
		  /* 821B70A8h */ case    1:  		/* li R4, 1 */
		/* 821B70A8h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 821B70A8h case    1:*/		return 0x821B70AC;
		  /* 821B70ACh */ case    2:  		/* mr R3, R29 */
		/* 821B70ACh case    2:*/		regs.R3 = regs.R29;
		/* 821B70ACh case    2:*/		return 0x821B70B0;
		  /* 821B70B0h */ case    3:  		/* lfs FR4, <#[R11 + 1816]> */
		/* 821B70B0h case    3:*/		cpu::mem::load32f( regs, &regs.FR4, (uint32)(regs.R11 + 0x00000718) );
		/* 821B70B0h case    3:*/		return 0x821B70B4;
		  /* 821B70B4h */ case    4:  		/* fmr FR3, FR4 */
		/* 821B70B4h case    4:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR4);
		/* 821B70B4h case    4:*/		return 0x821B70B8;
		  /* 821B70B8h */ case    5:  		/* fmr FR2, FR4 */
		/* 821B70B8h case    5:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR4);
		/* 821B70B8h case    5:*/		return 0x821B70BC;
		  /* 821B70BCh */ case    6:  		/* fmr FR1, FR4 */
		/* 821B70BCh case    6:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR4);
		/* 821B70BCh case    6:*/		return 0x821B70C0;
		  /* 821B70C0h */ case    7:  		/* bl 473752 */
		/* 821B70C0h case    7:*/		regs.LR = 0x821B70C4; return 0x8222AB58;
		/* 821B70C0h case    7:*/		return 0x821B70C4;
		  /* 821B70C4h */ case    8:  		/* mr R4, R3 */
		/* 821B70C4h case    8:*/		regs.R4 = regs.R3;
		/* 821B70C4h case    8:*/		return 0x821B70C8;
		  /* 821B70C8h */ case    9:  		/* mr R3, R29 */
		/* 821B70C8h case    9:*/		regs.R3 = regs.R29;
		/* 821B70C8h case    9:*/		return 0x821B70CC;
		  /* 821B70CCh */ case   10:  		/* bl -258252 */
		/* 821B70CCh case   10:*/		regs.LR = 0x821B70D0; return 0x82178000;
		/* 821B70CCh case   10:*/		return 0x821B70D0;
		  /* 821B70D0h */ case   11:  		/* lwz R11, <#[R3]> */
		/* 821B70D0h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821B70D0h case   11:*/		return 0x821B70D4;
		  /* 821B70D4h */ case   12:  		/* li R4, 0 */
		/* 821B70D4h case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 821B70D4h case   12:*/		return 0x821B70D8;
		  /* 821B70D8h */ case   13:  		/* rlwimi R11, R27, 25, 4, 6 */
		/* 821B70D8h case   13:*/		cpu::op::rlwimi<0,25,4,6>(regs,&regs.R11,regs.R27);
		/* 821B70D8h case   13:*/		return 0x821B70DC;
		  /* 821B70DCh */ case   14:  		/* mr R26, R3 */
		/* 821B70DCh case   14:*/		regs.R26 = regs.R3;
		/* 821B70DCh case   14:*/		return 0x821B70E0;
		  /* 821B70E0h */ case   15:  		/* stw R11, <#[R3]> */
		/* 821B70E0h case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821B70E0h case   15:*/		return 0x821B70E4;
		  /* 821B70E4h */ case   16:  		/* bl -259620 */
		/* 821B70E4h case   16:*/		regs.LR = 0x821B70E8; return 0x82177AC0;
		/* 821B70E4h case   16:*/		return 0x821B70E8;
		  /* 821B70E8h */ case   17:  		/* lwz R11, <#[R26]> */
		/* 821B70E8h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 821B70E8h case   17:*/		return 0x821B70EC;
		  /* 821B70ECh */ case   18:  		/* mr R6, R26 */
		/* 821B70ECh case   18:*/		regs.R6 = regs.R26;
		/* 821B70ECh case   18:*/		return 0x821B70F0;
		  /* 821B70F0h */ case   19:  		/* rlwinm R11, R11, 0, 27, 18 */
		/* 821B70F0h case   19:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R11,regs.R11);
		/* 821B70F0h case   19:*/		return 0x821B70F4;
		  /* 821B70F4h */ case   20:  		/* mr R4, R30 */
		/* 821B70F4h case   20:*/		regs.R4 = regs.R30;
		/* 821B70F4h case   20:*/		return 0x821B70F8;
		  /* 821B70F8h */ case   21:  		/* stw R11, <#[R26]> */
		/* 821B70F8h case   21:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 821B70F8h case   21:*/		return 0x821B70FC;
		  /* 821B70FCh */ case   22:  		/* mr R3, R29 */
		/* 821B70FCh case   22:*/		regs.R3 = regs.R29;
		/* 821B70FCh case   22:*/		return 0x821B7100;
	}
	return 0x821B7100;
} // Block from 821B70A4h-821B7100h (23 instructions)

//////////////////////////////////////////////////////
// Block at 821B7100h
// Function '?EnsurePHIInBlock@Compiler@D3DXShader@@AAAPAVInstruction@2@PAVBlock@2@PAV32@W4Component@2@I_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7100( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7100) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7100);
		  /* 821B7100h */ case    0:  		/* mr R5, R26 */
		/* 821B7100h case    0:*/		regs.R5 = regs.R26;
		/* 821B7100h case    0:*/		return 0x821B7104;
		  /* 821B7104h */ case    1:  		/* bl -756 */
		/* 821B7104h case    1:*/		regs.LR = 0x821B7108; return 0x821B6E10;
		/* 821B7104h case    1:*/		return 0x821B7108;
		  /* 821B7108h */ case    2:  		/* mr R30, R3 */
		/* 821B7108h case    2:*/		regs.R30 = regs.R3;
		/* 821B7108h case    2:*/		return 0x821B710C;
		  /* 821B710Ch */ case    3:  		/* mr R3, R29 */
		/* 821B710Ch case    3:*/		regs.R3 = regs.R29;
		/* 821B710Ch case    3:*/		return 0x821B7110;
		  /* 821B7110h */ case    4:  		/* mr R4, R30 */
		/* 821B7110h case    4:*/		regs.R4 = regs.R30;
		/* 821B7110h case    4:*/		return 0x821B7114;
		  /* 821B7114h */ case    5:  		/* bl -258324 */
		/* 821B7114h case    5:*/		regs.LR = 0x821B7118; return 0x82178000;
		/* 821B7114h case    5:*/		return 0x821B7118;
		  /* 821B7118h */ case    6:  		/* lwz R11, <#[R30 + 8]> */
		/* 821B7118h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821B7118h case    6:*/		return 0x821B711C;
		  /* 821B711Ch */ case    7:  		/* mr R10, R3 */
		/* 821B711Ch case    7:*/		regs.R10 = regs.R3;
		/* 821B711Ch case    7:*/		return 0x821B7120;
		  /* 821B7120h */ case    8:  		/* ori R11, R11, 32 */
		/* 821B7120h case    8:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x20);
		/* 821B7120h case    8:*/		return 0x821B7124;
		  /* 821B7124h */ case    9:  		/* lis R9, 16508 */
		/* 821B7124h case    9:*/		cpu::op::lis<0>(regs,&regs.R9,0x407C);
		/* 821B7124h case    9:*/		return 0x821B7128;
		  /* 821B7128h */ case   10:  		/* stw R11, <#[R30 + 8]> */
		/* 821B7128h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821B7128h case   10:*/		return 0x821B712C;
		  /* 821B712Ch */ case   11:  		/* mr R3, R31 */
		/* 821B712Ch case   11:*/		regs.R3 = regs.R31;
		/* 821B712Ch case   11:*/		return 0x821B7130;
		  /* 821B7130h */ case   12:  		/* rlwimi R9, R28, 13, 15, 18 */
		/* 821B7130h case   12:*/		cpu::op::rlwimi<0,13,15,18>(regs,&regs.R9,regs.R28);
		/* 821B7130h case   12:*/		return 0x821B7134;
		  /* 821B7134h */ case   13:  		/* lwz R11, <#[R10]> */
		/* 821B7134h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 821B7134h case   13:*/		return 0x821B7138;
		  /* 821B7138h */ case   14:  		/* rlwinm R11, R11, 0, 19, 13 */
		/* 821B7138h case   14:*/		cpu::op::rlwinm<0,0,19,13>(regs,&regs.R11,regs.R11);
		/* 821B7138h case   14:*/		return 0x821B713C;
		  /* 821B713Ch */ case   15:  		/* rlwinm R11, R11, 0, 9, 6 */
		/* 821B713Ch case   15:*/		cpu::op::rlwinm<0,0,9,6>(regs,&regs.R11,regs.R11);
		/* 821B713Ch case   15:*/		return 0x821B7140;
		  /* 821B7140h */ case   16:  		/* mr R4, R10 */
		/* 821B7140h case   16:*/		regs.R4 = regs.R10;
		/* 821B7140h case   16:*/		return 0x821B7144;
		  /* 821B7144h */ case   17:  		/* or R11, R9, R11 */
		/* 821B7144h case   17:*/		cpu::op::or<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 821B7144h case   17:*/		return 0x821B7148;
		  /* 821B7148h */ case   18:  		/* stw R11, <#[R10]> */
		/* 821B7148h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 821B7148h case   18:*/		return 0x821B714C;
		  /* 821B714Ch */ case   19:  		/* bl -257924 */
		/* 821B714Ch case   19:*/		regs.LR = 0x821B7150; return 0x821781C8;
		/* 821B714Ch case   19:*/		return 0x821B7150;
		  /* 821B7150h */ case   20:  		/* addi R1, R1, 144 */
		/* 821B7150h case   20:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 821B7150h case   20:*/		return 0x821B7154;
		  /* 821B7154h */ case   21:  		/* b -1203892 */
		/* 821B7154h case   21:*/		return 0x820912A0;
		/* 821B7154h case   21:*/		return 0x821B7158;
	}
	return 0x821B7158;
} // Block from 821B7100h-821B7158h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821B7158h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7158( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7158) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7158);
		  /* 821B7158h */ case    0:  		/* mfspr R12, LR */
		/* 821B7158h case    0:*/		regs.R12 = regs.LR;
		/* 821B7158h case    0:*/		return 0x821B715C;
		  /* 821B715Ch */ case    1:  		/* bl -1204012 */
		/* 821B715Ch case    1:*/		regs.LR = 0x821B7160; return 0x82091230;
		/* 821B715Ch case    1:*/		return 0x821B7160;
		  /* 821B7160h */ case    2:  		/* stwu R1, <#[R1 - 208]> */
		/* 821B7160h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 821B7160h case    2:*/		return 0x821B7164;
		  /* 821B7164h */ case    3:  		/* addi R21, R4, 48 */
		/* 821B7164h case    3:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R4,0x30);
		/* 821B7164h case    3:*/		return 0x821B7168;
		  /* 821B7168h */ case    4:  		/* lwz R11, <#[R4 + 48]> */
		/* 821B7168h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000030) );
		/* 821B7168h case    4:*/		return 0x821B716C;
		  /* 821B716Ch */ case    5:  		/* mr R29, R3 */
		/* 821B716Ch case    5:*/		regs.R29 = regs.R3;
		/* 821B716Ch case    5:*/		return 0x821B7170;
		  /* 821B7170h */ case    6:  		/* mr R23, R4 */
		/* 821B7170h case    6:*/		regs.R23 = regs.R4;
		/* 821B7170h case    6:*/		return 0x821B7174;
		  /* 821B7174h */ case    7:  		/* mr R19, R5 */
		/* 821B7174h case    7:*/		regs.R19 = regs.R5;
		/* 821B7174h case    7:*/		return 0x821B7178;
		  /* 821B7178h */ case    8:  		/* mr R18, R6 */
		/* 821B7178h case    8:*/		regs.R18 = regs.R6;
		/* 821B7178h case    8:*/		return 0x821B717C;
		  /* 821B717Ch */ case    9:  		/* mr R28, R4 */
		/* 821B717Ch case    9:*/		regs.R28 = regs.R4;
		/* 821B717Ch case    9:*/		return 0x821B7180;
		  /* 821B7180h */ case   10:  		/* mr R20, R21 */
		/* 821B7180h case   10:*/		regs.R20 = regs.R21;
		/* 821B7180h case   10:*/		return 0x821B7184;
		  /* 821B7184h */ case   11:  		/* b 24 */
		/* 821B7184h case   11:*/		return 0x821B719C;
		/* 821B7184h case   11:*/		return 0x821B7188;
		  /* 821B7188h */ case   12:  		/* lwz R28, <#[R28 + 52]> */
		/* 821B7188h case   12:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R28 + 0x00000034) );
		/* 821B7188h case   12:*/		return 0x821B718C;
		  /* 821B718Ch */ case   13:  		/* cmplwi CR6, R28, 0 */
		/* 821B718Ch case   13:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 821B718Ch case   13:*/		return 0x821B7190;
		  /* 821B7190h */ case   14:  		/* bc 12, CR6_EQ, 144 */
		/* 821B7190h case   14:*/		if ( regs.CR[6].eq ) { return 0x821B7220;  }
		/* 821B7190h case   14:*/		return 0x821B7194;
		  /* 821B7194h */ case   15:  		/* lwz R11, <#[R28 + 48]> */
		/* 821B7194h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000030) );
		/* 821B7194h case   15:*/		return 0x821B7198;
		  /* 821B7198h */ case   16:  		/* addi R20, R28, 48 */
		/* 821B7198h case   16:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R28,0x30);
		/* 821B7198h case   16:*/		return 0x821B719C;
	}
	return 0x821B719C;
} // Block from 821B7158h-821B719Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 821B719Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B719C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B719C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B719C);
		  /* 821B719Ch */ case    0:  		/* rlwinm. R11, R11, 2, 31, 31 */
		/* 821B719Ch case    0:*/		cpu::op::rlwinm<1,2,31,31>(regs,&regs.R11,regs.R11);
		/* 821B719Ch case    0:*/		return 0x821B71A0;
		  /* 821B71A0h */ case    1:  		/* bc 12, CR0_EQ, -24 */
		/* 821B71A0h case    1:*/		if ( regs.CR[0].eq ) { return 0x821B7188;  }
		/* 821B71A0h case    1:*/		return 0x821B71A4;
		  /* 821B71A4h */ case    2:  		/* lwz R11, <#[R28 + 36]> */
		/* 821B71A4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000024) );
		/* 821B71A4h case    2:*/		return 0x821B71A8;
		  /* 821B71A8h */ case    3:  		/* addi R27, R28, 32 */
		/* 821B71A8h case    3:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R28,0x20);
		/* 821B71A8h case    3:*/		return 0x821B71AC;
		  /* 821B71ACh */ case    4:  		/* li R22, 1 */
		/* 821B71ACh case    4:*/		cpu::op::li<0>(regs,&regs.R22,0x1);
		/* 821B71ACh case    4:*/		return 0x821B71B0;
		  /* 821B71B0h */ case    5:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821B71B0h case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821B71B0h case    5:*/		return 0x821B71B4;
		  /* 821B71B4h */ case    6:  		/* li R26, 0 */
		/* 821B71B4h case    6:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 821B71B4h case    6:*/		return 0x821B71B8;
		  /* 821B71B8h */ case    7:  		/* bc 4, CR0_EQ, 156 */
		/* 821B71B8h case    7:*/		if ( !regs.CR[0].eq ) { return 0x821B7254;  }
		/* 821B71B8h case    7:*/		return 0x821B71BC;
		  /* 821B71BCh */ case    8:  		/* mr R7, R11 */
		/* 821B71BCh case    8:*/		regs.R7 = regs.R11;
		/* 821B71BCh case    8:*/		return 0x821B71C0;
		  /* 821B71C0h */ case    9:  		/* cmplwi CR0, R11, 0 */
		/* 821B71C0h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821B71C0h case    9:*/		return 0x821B71C4;
		  /* 821B71C4h */ case   10:  		/* bc 12, CR0_EQ, 144 */
		/* 821B71C4h case   10:*/		if ( regs.CR[0].eq ) { return 0x821B7254;  }
		/* 821B71C4h case   10:*/		return 0x821B71C8;
		  /* 821B71C8h */ case   11:  		/* lwz R11, <#[R7 + 8]> */
		/* 821B71C8h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000008) );
		/* 821B71C8h case   11:*/		return 0x821B71CC;
		  /* 821B71CCh */ case   12:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821B71CCh case   12:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821B71CCh case   12:*/		return 0x821B71D0;
		  /* 821B71D0h */ case   13:  		/* cmplwi CR6, R11, 14976 */
		/* 821B71D0h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003A80);
		/* 821B71D0h case   13:*/		return 0x821B71D4;
		  /* 821B71D4h */ case   14:  		/* bc 4, CR6_EQ, 100 */
		/* 821B71D4h case   14:*/		if ( !regs.CR[6].eq ) { return 0x821B7238;  }
		/* 821B71D4h case   14:*/		return 0x821B71D8;
		  /* 821B71D8h */ case   15:  		/* lwz R9, <#[R7]> */
		/* 821B71D8h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R7 + 0x00000000) );
		/* 821B71D8h case   15:*/		return 0x821B71DC;
		  /* 821B71DCh */ case   16:  		/* cmplwi CR6, R9, 0 */
		/* 821B71DCh case   16:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 821B71DCh case   16:*/		return 0x821B71E0;
		  /* 821B71E0h */ case   17:  		/* bc 12, CR6_EQ, 80 */
		/* 821B71E0h case   17:*/		if ( regs.CR[6].eq ) { return 0x821B7230;  }
		/* 821B71E0h case   17:*/		return 0x821B71E4;
		  /* 821B71E4h */ case   18:  		/* lwz R8, <#[R9 + 12]> */
		/* 821B71E4h case   18:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x0000000C) );
		/* 821B71E4h case   18:*/		return 0x821B71E8;
		  /* 821B71E8h */ case   19:  		/* lwz R11, <#[R8 + 8]> */
		/* 821B71E8h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000008) );
		/* 821B71E8h case   19:*/		return 0x821B71EC;
		  /* 821B71ECh */ case   20:  		/* rlwinm R10, R11, 25, 25, 31 */
		/* 821B71ECh case   20:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R11);
		/* 821B71ECh case   20:*/		return 0x821B71F0;
		  /* 821B71F0h */ case   21:  		/* cmplwi CR6, R10, 91 */
		/* 821B71F0h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000005B);
		/* 821B71F0h case   21:*/		return 0x821B71F4;
		  /* 821B71F4h */ case   22:  		/* bc 12, CR6_LT, 16 */
		/* 821B71F4h case   22:*/		if ( regs.CR[6].lt ) { return 0x821B7204;  }
		/* 821B71F4h case   22:*/		return 0x821B71F8;
		  /* 821B71F8h */ case   23:  		/* cmplwi CR6, R10, 94 */
		/* 821B71F8h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000005E);
		/* 821B71F8h case   23:*/		return 0x821B71FC;
		  /* 821B71FCh */ case   24:  		/* mr R11, R22 */
		/* 821B71FCh case   24:*/		regs.R11 = regs.R22;
		/* 821B71FCh case   24:*/		return 0x821B7200;
		  /* 821B7200h */ case   25:  		/* bc 4, CR6_GT, 8 */
		/* 821B7200h case   25:*/		if ( !regs.CR[6].gt ) { return 0x821B7208;  }
		/* 821B7200h case   25:*/		return 0x821B7204;
	}
	return 0x821B7204;
} // Block from 821B719Ch-821B7204h (26 instructions)

//////////////////////////////////////////////////////
// Block at 821B7204h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7204( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7204) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7204);
		  /* 821B7204h */ case    0:  		/* li R11, 0 */
		/* 821B7204h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821B7204h case    0:*/		return 0x821B7208;
	}
	return 0x821B7208;
} // Block from 821B7204h-821B7208h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B7208h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7208( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7208) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7208);
		  /* 821B7208h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821B7208h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821B7208h case    0:*/		return 0x821B720C;
		  /* 821B720Ch */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 821B720Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x821B7218;  }
		/* 821B720Ch case    1:*/		return 0x821B7210;
		  /* 821B7210h */ case    2:  		/* cmplwi CR6, R10, 94 */
		/* 821B7210h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000005E);
		/* 821B7210h case    2:*/		return 0x821B7214;
		  /* 821B7214h */ case    3:  		/* bc 4, CR6_EQ, 24 */
		/* 821B7214h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821B722C;  }
		/* 821B7214h case    3:*/		return 0x821B7218;
	}
	return 0x821B7218;
} // Block from 821B7208h-821B7218h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821B7218h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7218( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7218) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7218);
		  /* 821B7218h */ case    0:  		/* lwz R9, <#[R9 + 4]> */
		/* 821B7218h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 821B7218h case    0:*/		return 0x821B721C;
		  /* 821B721Ch */ case    1:  		/* b -64 */
		/* 821B721Ch case    1:*/		return 0x821B71DC;
		/* 821B721Ch case    1:*/		return 0x821B7220;
	}
	return 0x821B7220;
} // Block from 821B7218h-821B7220h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B7220h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7220( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7220) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7220);
		  /* 821B7220h */ case    0:  		/* li R4, 4800 */
		/* 821B7220h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 821B7220h case    0:*/		return 0x821B7224;
		  /* 821B7224h */ case    1:  		/* mr R3, R29 */
		/* 821B7224h case    1:*/		regs.R3 = regs.R29;
		/* 821B7224h case    1:*/		return 0x821B7228;
		  /* 821B7228h */ case    2:  		/* bl -414656 */
		/* 821B7228h case    2:*/		regs.LR = 0x821B722C; return 0x82151E68;
		/* 821B7228h case    2:*/		return 0x821B722C;
	}
	return 0x821B722C;
} // Block from 821B7220h-821B722Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 821B722Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B722C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B722C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B722C);
		  /* 821B722Ch */ case    0:  		/* mr R26, R8 */
		/* 821B722Ch case    0:*/		regs.R26 = regs.R8;
		/* 821B722Ch case    0:*/		return 0x821B7230;
	}
	return 0x821B7230;
} // Block from 821B722Ch-821B7230h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B7230h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7230( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7230) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7230);
		  /* 821B7230h */ case    0:  		/* cmplwi CR6, R26, 0 */
		/* 821B7230h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 821B7230h case    0:*/		return 0x821B7234;
		  /* 821B7234h */ case    1:  		/* bc 4, CR6_EQ, 32 */
		/* 821B7234h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821B7254;  }
		/* 821B7234h case    1:*/		return 0x821B7238;
	}
	return 0x821B7238;
} // Block from 821B7230h-821B7238h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B7238h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7238( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7238) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7238);
		  /* 821B7238h */ case    0:  		/* rlwinm R11, R7, 0, 0, 30 */
		/* 821B7238h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R7);
		/* 821B7238h case    0:*/		return 0x821B723C;
		  /* 821B723Ch */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 821B723Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 821B723Ch case    1:*/		return 0x821B7240;
		  /* 821B7240h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821B7240h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821B7240h case    2:*/		return 0x821B7244;
		  /* 821B7244h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 821B7244h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821B7254;  }
		/* 821B7244h case    3:*/		return 0x821B7248;
		  /* 821B7248h */ case    4:  		/* mr R7, R11 */
		/* 821B7248h case    4:*/		regs.R7 = regs.R11;
		/* 821B7248h case    4:*/		return 0x821B724C;
		  /* 821B724Ch */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821B724Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821B724Ch case    5:*/		return 0x821B7250;
		  /* 821B7250h */ case    6:  		/* bc 4, CR6_EQ, -136 */
		/* 821B7250h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821B71C8;  }
		/* 821B7250h case    6:*/		return 0x821B7254;
	}
	return 0x821B7254;
} // Block from 821B7238h-821B7254h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821B7254h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7254( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7254) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7254);
		  /* 821B7254h */ case    0:  		/* lwz R11, <#[R29 + 48]> */
		/* 821B7254h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000030) );
		/* 821B7254h case    0:*/		return 0x821B7258;
		  /* 821B7258h */ case    1:  		/* li R24, 0 */
		/* 821B7258h case    1:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 821B7258h case    1:*/		return 0x821B725C;
		  /* 821B725Ch */ case    2:  		/* cmplwi CR6, R26, 0 */
		/* 821B725Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 821B725Ch case    2:*/		return 0x821B7260;
		  /* 821B7260h */ case    3:  		/* lis R25, -1 */
		/* 821B7260h case    3:*/		cpu::op::lis<0>(regs,&regs.R25,0xFFFFFFFF);
		/* 821B7260h case    3:*/		return 0x821B7264;
		  /* 821B7264h */ case    4:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 821B7264h case    4:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 821B7264h case    4:*/		return 0x821B7268;
		  /* 821B7268h */ case    5:  		/* bc 4, CR6_EQ, 640 */
		/* 821B7268h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821B74E8;  }
		/* 821B7268h case    5:*/		return 0x821B726C;
		  /* 821B726Ch */ case    6:  		/* cmplw CR6, R11, R25 */
		/* 821B726Ch case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R25);
		/* 821B726Ch case    6:*/		return 0x821B7270;
		  /* 821B7270h */ case    7:  		/* li R8, 0 */
		/* 821B7270h case    7:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821B7270h case    7:*/		return 0x821B7274;
		  /* 821B7274h */ case    8:  		/* li R7, 0 */
		/* 821B7274h case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821B7274h case    8:*/		return 0x821B7278;
		  /* 821B7278h */ case    9:  		/* li R5, 0 */
		/* 821B7278h case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821B7278h case    9:*/		return 0x821B727C;
		  /* 821B727Ch */ case   10:  		/* mr R4, R28 */
		/* 821B727Ch case   10:*/		regs.R4 = regs.R28;
		/* 821B727Ch case   10:*/		return 0x821B7280;
		  /* 821B7280h */ case   11:  		/* mr R3, R29 */
		/* 821B7280h case   11:*/		regs.R3 = regs.R29;
		/* 821B7280h case   11:*/		return 0x821B7284;
		  /* 821B7284h */ case   12:  		/* li R6, 93 */
		/* 821B7284h case   12:*/		cpu::op::li<0>(regs,&regs.R6,0x5D);
		/* 821B7284h case   12:*/		return 0x821B7288;
		  /* 821B7288h */ case   13:  		/* bc 12, CR6_EQ, 8 */
		/* 821B7288h case   13:*/		if ( regs.CR[6].eq ) { return 0x821B7290;  }
		/* 821B7288h case   13:*/		return 0x821B728C;
		  /* 821B728Ch */ case   14:  		/* li R6, 91 */
		/* 821B728Ch case   14:*/		cpu::op::li<0>(regs,&regs.R6,0x5B);
		/* 821B728Ch case   14:*/		return 0x821B7290;
	}
	return 0x821B7290;
} // Block from 821B7254h-821B7290h (15 instructions)

//////////////////////////////////////////////////////
// Block at 821B7290h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7290( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7290) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7290);
		  /* 821B7290h */ case    0:  		/* bl 448264 */
		/* 821B7290h case    0:*/		regs.LR = 0x821B7294; return 0x82224998;
		/* 821B7290h case    0:*/		return 0x821B7294;
		  /* 821B7294h */ case    1:  		/* rlwinm R10, R3, 0, 0, 30 */
		/* 821B7294h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R3);
		/* 821B7294h case    1:*/		return 0x821B7298;
		  /* 821B7298h */ case    2:  		/* lwz R9, <#[R28 + 28]> */
		/* 821B7298h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x0000001C) );
		/* 821B7298h case    2:*/		return 0x821B729C;
		  /* 821B729Ch */ case    3:  		/* addi R11, R28, 24 */
		/* 821B729Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R28,0x18);
		/* 821B729Ch case    3:*/		return 0x821B72A0;
		  /* 821B72A0h */ case    4:  		/* addi R31, R10, 36 */
		/* 821B72A0h case    4:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R10,0x24);
		/* 821B72A0h case    4:*/		return 0x821B72A4;
		  /* 821B72A4h */ case    5:  		/* addi R11, R11, 4 */
		/* 821B72A4h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821B72A4h case    5:*/		return 0x821B72A8;
		  /* 821B72A8h */ case    6:  		/* addi R10, R31, 4 */
		/* 821B72A8h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x4);
		/* 821B72A8h case    6:*/		return 0x821B72AC;
		  /* 821B72ACh */ case    7:  		/* ori R11, R11, 1 */
		/* 821B72ACh case    7:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821B72ACh case    7:*/		return 0x821B72B0;
	}
	return 0x821B72B0;
} // Block from 821B7290h-821B72B0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821B72B0h
// Function '?EnsurePHIInBlock_BeforeCleanPhase@Compiler@D3DXShader@@AAAPAVInstruction@2@PAVBlock@2@PAV32@W4Component@2@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B72B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B72B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B72B0);
		  /* 821B72B0h */ case    0:  		/* addi R8, R31, -36 */
		/* 821B72B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R31,0xFFFFFFDC);
		/* 821B72B0h case    0:*/		return 0x821B72B4;
		  /* 821B72B4h */ case    1:  		/* stw R9, <#[R31 + 4]> */
		/* 821B72B4h case    1:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R31 + 0x00000004) );
		/* 821B72B4h case    1:*/		return 0x821B72B8;
	}
	return 0x821B72B8;
} // Block from 821B72B0h-821B72B8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B72B8h
// Function '?MarkGlobalDef_PropagateThroughMERGE@Compiler@D3DXShader@@AAAXPAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B72B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B72B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B72B8);
		  /* 821B72B8h */ case    0:  		/* mr R26, R3 */
		/* 821B72B8h case    0:*/		regs.R26 = regs.R3;
		/* 821B72B8h case    0:*/		return 0x821B72BC;
		  /* 821B72BCh */ case    1:  		/* lwz R9, <#[R28 + 28]> */
		/* 821B72BCh case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R28 + 0x0000001C) );
		/* 821B72BCh case    1:*/		return 0x821B72C0;
		  /* 821B72C0h */ case    2:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 821B72C0h case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 821B72C0h case    2:*/		return 0x821B72C4;
		  /* 821B72C4h */ case    3:  		/* stw R10, <#[R9 + 36]> */
		/* 821B72C4h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000024) );
		/* 821B72C4h case    3:*/		return 0x821B72C8;
		  /* 821B72C8h */ case    4:  		/* mr R30, R3 */
		/* 821B72C8h case    4:*/		regs.R30 = regs.R3;
		/* 821B72C8h case    4:*/		return 0x821B72CC;
		  /* 821B72CCh */ case    5:  		/* stw R11, <#[R31]> */
		/* 821B72CCh case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821B72CCh case    5:*/		return 0x821B72D0;
		  /* 821B72D0h */ case    6:  		/* stw R8, <#[R28 + 28]> */
		/* 821B72D0h case    6:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R28 + 0x0000001C) );
		/* 821B72D0h case    6:*/		return 0x821B72D4;
		  /* 821B72D4h */ case    7:  		/* lwz R11, <#[R29 + 48]> */
		/* 821B72D4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000030) );
		/* 821B72D4h case    7:*/		return 0x821B72D8;
		  /* 821B72D8h */ case    8:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 821B72D8h case    8:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 821B72D8h case    8:*/		return 0x821B72DC;
		  /* 821B72DCh */ case    9:  		/* cmplw CR6, R11, R25 */
		/* 821B72DCh case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R25);
		/* 821B72DCh case    9:*/		return 0x821B72E0;
		  /* 821B72E0h */ case   10:  		/* bc 12, CR6_EQ, 100 */
		/* 821B72E0h case   10:*/		if ( regs.CR[6].eq ) { return 0x821B7344;  }
		/* 821B72E0h case   10:*/		return 0x821B72E4;
		  /* 821B72E4h */ case   11:  		/* li R8, 0 */
		/* 821B72E4h case   11:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821B72E4h case   11:*/		return 0x821B72E8;
		  /* 821B72E8h */ case   12:  		/* li R7, 0 */
		/* 821B72E8h case   12:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821B72E8h case   12:*/		return 0x821B72EC;
		  /* 821B72ECh */ case   13:  		/* li R6, 92 */
		/* 821B72ECh case   13:*/		cpu::op::li<0>(regs,&regs.R6,0x5C);
		/* 821B72ECh case   13:*/		return 0x821B72F0;
		  /* 821B72F0h */ case   14:  		/* li R5, 0 */
		/* 821B72F0h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821B72F0h case   14:*/		return 0x821B72F4;
		  /* 821B72F4h */ case   15:  		/* mr R4, R28 */
		/* 821B72F4h case   15:*/		regs.R4 = regs.R28;
		/* 821B72F4h case   15:*/		return 0x821B72F8;
		  /* 821B72F8h */ case   16:  		/* mr R3, R29 */
		/* 821B72F8h case   16:*/		regs.R3 = regs.R29;
		/* 821B72F8h case   16:*/		return 0x821B72FC;
		  /* 821B72FCh */ case   17:  		/* bl 448156 */
		/* 821B72FCh case   17:*/		regs.LR = 0x821B7300; return 0x82224998;
		/* 821B72FCh case   17:*/		return 0x821B7300;
		  /* 821B7300h */ case   18:  		/* rlwinm R11, R3, 0, 0, 30 */
		/* 821B7300h case   18:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R3);
		/* 821B7300h case   18:*/		return 0x821B7304;
		  /* 821B7304h */ case   19:  		/* lwz R8, <#[R31 + 4]> */
		/* 821B7304h case   19:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000004) );
		/* 821B7304h case   19:*/		return 0x821B7308;
		  /* 821B7308h */ case   20:  		/* addi R10, R31, 4 */
		/* 821B7308h case   20:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x4);
		/* 821B7308h case   20:*/		return 0x821B730C;
		  /* 821B730Ch */ case   21:  		/* addi R11, R11, 36 */
		/* 821B730Ch case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821B730Ch case   21:*/		return 0x821B7310;
		  /* 821B7310h */ case   22:  		/* mr R5, R29 */
		/* 821B7310h case   22:*/		regs.R5 = regs.R29;
		/* 821B7310h case   22:*/		return 0x821B7314;
		  /* 821B7314h */ case   23:  		/* addi R9, R11, 4 */
		/* 821B7314h case   23:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821B7314h case   23:*/		return 0x821B7318;
		  /* 821B7318h */ case   24:  		/* addi R7, R11, -36 */
		/* 821B7318h case   24:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFDC);
		/* 821B7318h case   24:*/		return 0x821B731C;
		  /* 821B731Ch */ case   25:  		/* mr R4, R30 */
		/* 821B731Ch case   25:*/		regs.R4 = regs.R30;
		/* 821B731Ch case   25:*/		return 0x821B7320;
		  /* 821B7320h */ case   26:  		/* stw R8, <#[R11 + 4]> */
		/* 821B7320h case   26:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 821B7320h case   26:*/		return 0x821B7324;
		  /* 821B7324h */ case   27:  		/* mr R24, R3 */
		/* 821B7324h case   27:*/		regs.R24 = regs.R3;
		/* 821B7324h case   27:*/		return 0x821B7328;
		  /* 821B7328h */ case   28:  		/* lwz R8, <#[R31 + 4]> */
		/* 821B7328h case   28:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000004) );
		/* 821B7328h case   28:*/		return 0x821B732C;
		  /* 821B732Ch */ case   29:  		/* rlwinm R8, R8, 0, 0, 30 */
		/* 821B732Ch case   29:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R8,regs.R8);
		/* 821B732Ch case   29:*/		return 0x821B7330;
		  /* 821B7330h */ case   30:  		/* stw R9, <#[R8 + 36]> */
		/* 821B7330h case   30:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R8 + 0x00000024) );
		/* 821B7330h case   30:*/		return 0x821B7334;
		  /* 821B7334h */ case   31:  		/* stw R10, <#[R11]> */
		/* 821B7334h case   31:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821B7334h case   31:*/		return 0x821B7338;
		  /* 821B7338h */ case   32:  		/* stw R7, <#[R31 + 4]> */
		/* 821B7338h case   32:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R31 + 0x00000004) );
		/* 821B7338h case   32:*/		return 0x821B733C;
		  /* 821B733Ch */ case   33:  		/* bl -258220 */
		/* 821B733Ch case   33:*/		regs.LR = 0x821B7340; return 0x82178290;
		/* 821B733Ch case   33:*/		return 0x821B7340;
		  /* 821B7340h */ case   34:  		/* mr R30, R24 */
		/* 821B7340h case   34:*/		regs.R30 = regs.R24;
		/* 821B7340h case   34:*/		return 0x821B7344;
	}
	return 0x821B7344;
} // Block from 821B72B8h-821B7344h (35 instructions)

//////////////////////////////////////////////////////
// Block at 821B7344h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7344( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7344) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7344);
		  /* 821B7344h */ case    0:  		/* li R8, 0 */
		/* 821B7344h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821B7344h case    0:*/		return 0x821B7348;
		  /* 821B7348h */ case    1:  		/* li R7, 0 */
		/* 821B7348h case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821B7348h case    1:*/		return 0x821B734C;
		  /* 821B734Ch */ case    2:  		/* li R6, 117 */
		/* 821B734Ch case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x75);
		/* 821B734Ch case    2:*/		return 0x821B7350;
		  /* 821B7350h */ case    3:  		/* li R5, 0 */
		/* 821B7350h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821B7350h case    3:*/		return 0x821B7354;
		  /* 821B7354h */ case    4:  		/* mr R4, R28 */
		/* 821B7354h case    4:*/		regs.R4 = regs.R28;
		/* 821B7354h case    4:*/		return 0x821B7358;
		  /* 821B7358h */ case    5:  		/* mr R3, R29 */
		/* 821B7358h case    5:*/		regs.R3 = regs.R29;
		/* 821B7358h case    5:*/		return 0x821B735C;
		  /* 821B735Ch */ case    6:  		/* bl 448060 */
		/* 821B735Ch case    6:*/		regs.LR = 0x821B7360; return 0x82224998;
		/* 821B735Ch case    6:*/		return 0x821B7360;
		  /* 821B7360h */ case    7:  		/* addi R11, R27, 4 */
		/* 821B7360h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R27,0x4);
		/* 821B7360h case    7:*/		return 0x821B7364;
		  /* 821B7364h */ case    8:  		/* rlwinm R10, R3, 0, 0, 30 */
		/* 821B7364h case    8:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R3);
		/* 821B7364h case    8:*/		return 0x821B7368;
		  /* 821B7368h */ case    9:  		/* lwz R9, <#[R27 + 4]> */
		/* 821B7368h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000004) );
		/* 821B7368h case    9:*/		return 0x821B736C;
		  /* 821B736Ch */ case   10:  		/* ori R8, R11, 1 */
		/* 821B736Ch case   10:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R11,0x1);
		/* 821B736Ch case   10:*/		return 0x821B7370;
		  /* 821B7370h */ case   11:  		/* addi R11, R10, 36 */
		/* 821B7370h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x24);
		/* 821B7370h case   11:*/		return 0x821B7374;
		  /* 821B7374h */ case   12:  		/* mr R31, R3 */
		/* 821B7374h case   12:*/		regs.R31 = regs.R3;
		/* 821B7374h case   12:*/		return 0x821B7378;
		  /* 821B7378h */ case   13:  		/* addi R10, R11, 4 */
		/* 821B7378h case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 821B7378h case   13:*/		return 0x821B737C;
		  /* 821B737Ch */ case   14:  		/* addi R7, R11, -36 */
		/* 821B737Ch case   14:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFDC);
		/* 821B737Ch case   14:*/		return 0x821B7380;
		  /* 821B7380h */ case   15:  		/* cmplw CR6, R28, R23 */
		/* 821B7380h case   15:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R23);
		/* 821B7380h case   15:*/		return 0x821B7384;
		  /* 821B7384h */ case   16:  		/* stw R9, <#[R11 + 4]> */
		/* 821B7384h case   16:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 821B7384h case   16:*/		return 0x821B7388;
		  /* 821B7388h */ case   17:  		/* mr R4, R30 */
		/* 821B7388h case   17:*/		regs.R4 = regs.R30;
		/* 821B7388h case   17:*/		return 0x821B738C;
		  /* 821B738Ch */ case   18:  		/* lwz R9, <#[R27 + 4]> */
		/* 821B738Ch case   18:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000004) );
		/* 821B738Ch case   18:*/		return 0x821B7390;
		  /* 821B7390h */ case   19:  		/* rlwinm R9, R9, 0, 0, 30 */
		/* 821B7390h case   19:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R9);
		/* 821B7390h case   19:*/		return 0x821B7394;
		  /* 821B7394h */ case   20:  		/* stw R10, <#[R9 + 36]> */
		/* 821B7394h case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000024) );
		/* 821B7394h case   20:*/		return 0x821B7398;
	}
	return 0x821B7398;
} // Block from 821B7344h-821B7398h (21 instructions)

//////////////////////////////////////////////////////
// Block at 821B7398h
// Function '?ExpandMerge@Compiler@D3DXShader@@AAAPAVInstruction@2@PAV32@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7398( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7398) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7398);
		  /* 821B7398h */ case    0:  		/* stw R8, <#[R11]> */
		/* 821B7398h case    0:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 821B7398h case    0:*/		return 0x821B739C;
		  /* 821B739Ch */ case    1:  		/* stw R7, <#[R27 + 4]> */
		/* 821B739Ch case    1:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R27 + 0x00000004) );
		/* 821B739Ch case    1:*/		return 0x821B73A0;
		  /* 821B73A0h */ case    2:  		/* lwz R11, <#[R3 + 8]> */
		/* 821B73A0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821B73A0h case    2:*/		return 0x821B73A4;
		  /* 821B73A4h */ case    3:  		/* oris R11, R11, 512 */
		/* 821B73A4h case    3:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x200);
		/* 821B73A4h case    3:*/		return 0x821B73A8;
		  /* 821B73A8h */ case    4:  		/* stw R11, <#[R3 + 8]> */
		/* 821B73A8h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821B73A8h case    4:*/		return 0x821B73AC;
		  /* 821B73ACh */ case    5:  		/* bc 12, CR6_EQ, 300 */
		/* 821B73ACh case    5:*/		if ( regs.CR[6].eq ) { return 0x821B74D8;  }
		/* 821B73ACh case    5:*/		return 0x821B73B0;
		  /* 821B73B0h */ case    6:  		/* li R5, 8 */
		/* 821B73B0h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x8);
		/* 821B73B0h case    6:*/		return 0x821B73B4;
		  /* 821B73B4h */ case    7:  		/* mr R3, R29 */
		/* 821B73B4h case    7:*/		regs.R3 = regs.R29;
		/* 821B73B4h case    7:*/		return 0x821B73B8;
		  /* 821B73B8h */ case    8:  		/* bl -289896 */
		/* 821B73B8h case    8:*/		regs.LR = 0x821B73BC; return 0x82170750;
		/* 821B73B8h case    8:*/		return 0x821B73BC;
		  /* 821B73BCh */ case    9:  		/* mr R4, R3 */
		/* 821B73BCh case    9:*/		regs.R4 = regs.R3;
		/* 821B73BCh case    9:*/		return 0x821B73C0;
		  /* 821B73C0h */ case   10:  		/* mr R3, R31 */
		/* 821B73C0h case   10:*/		regs.R3 = regs.R31;
		/* 821B73C0h case   10:*/		return 0x821B73C4;
		  /* 821B73C4h */ case   11:  		/* bl -258556 */
		/* 821B73C4h case   11:*/		regs.LR = 0x821B73C8; return 0x821781C8;
		/* 821B73C4h case   11:*/		return 0x821B73C8;
		  /* 821B73C8h */ case   12:  		/* lwz R11, <#[R29 + 48]> */
		/* 821B73C8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000030) );
		/* 821B73C8h case   12:*/		return 0x821B73CC;
		  /* 821B73CCh */ case   13:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 821B73CCh case   13:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 821B73CCh case   13:*/		return 0x821B73D0;
		  /* 821B73D0h */ case   14:  		/* cmplw CR6, R11, R25 */
		/* 821B73D0h case   14:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R25);
		/* 821B73D0h case   14:*/		return 0x821B73D4;
		  /* 821B73D4h */ case   15:  		/* bc 12, CR6_EQ, 32 */
		/* 821B73D4h case   15:*/		if ( regs.CR[6].eq ) { return 0x821B73F4;  }
		/* 821B73D4h case   15:*/		return 0x821B73D8;
		  /* 821B73D8h */ case   16:  		/* li R5, 5 */
		/* 821B73D8h case   16:*/		cpu::op::li<0>(regs,&regs.R5,0x5);
		/* 821B73D8h case   16:*/		return 0x821B73DC;
		  /* 821B73DCh */ case   17:  		/* mr R4, R30 */
		/* 821B73DCh case   17:*/		regs.R4 = regs.R30;
		/* 821B73DCh case   17:*/		return 0x821B73E0;
		  /* 821B73E0h */ case   18:  		/* mr R3, R29 */
		/* 821B73E0h case   18:*/		regs.R3 = regs.R29;
		/* 821B73E0h case   18:*/		return 0x821B73E4;
		  /* 821B73E4h */ case   19:  		/* bl -289940 */
		/* 821B73E4h case   19:*/		regs.LR = 0x821B73E8; return 0x82170750;
		/* 821B73E4h case   19:*/		return 0x821B73E8;
		  /* 821B73E8h */ case   20:  		/* mr R4, R3 */
		/* 821B73E8h case   20:*/		regs.R4 = regs.R3;
		/* 821B73E8h case   20:*/		return 0x821B73EC;
		  /* 821B73ECh */ case   21:  		/* mr R3, R31 */
		/* 821B73ECh case   21:*/		regs.R3 = regs.R31;
		/* 821B73ECh case   21:*/		return 0x821B73F0;
		  /* 821B73F0h */ case   22:  		/* bl -258600 */
		/* 821B73F0h case   22:*/		regs.LR = 0x821B73F4; return 0x821781C8;
		/* 821B73F0h case   22:*/		return 0x821B73F4;
	}
	return 0x821B73F4;
} // Block from 821B7398h-821B73F4h (23 instructions)

//////////////////////////////////////////////////////
// Block at 821B73F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B73F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B73F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B73F4);
		  /* 821B73F4h */ case    0:  		/* lwz R11, <#[R29 + 48]> */
		/* 821B73F4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000030) );
		/* 821B73F4h case    0:*/		return 0x821B73F8;
		  /* 821B73F8h */ case    1:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 821B73F8h case    1:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 821B73F8h case    1:*/		return 0x821B73FC;
		  /* 821B73FCh */ case    2:  		/* cmplw CR6, R11, R25 */
		/* 821B73FCh case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R25);
		/* 821B73FCh case    2:*/		return 0x821B7400;
		  /* 821B7400h */ case    3:  		/* bc 12, CR6_EQ, 196 */
		/* 821B7400h case    3:*/		if ( regs.CR[6].eq ) { return 0x821B74C4;  }
		/* 821B7400h case    3:*/		return 0x821B7404;
		  /* 821B7404h */ case    4:  		/* lwz R11, <#[R29 + 4]> */
		/* 821B7404h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 821B7404h case    4:*/		return 0x821B7408;
		  /* 821B7408h */ case    5:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821B7408h case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821B7408h case    5:*/		return 0x821B740C;
		  /* 821B740Ch */ case    6:  		/* bc 4, CR0_EQ, 184 */
		/* 821B740Ch case    6:*/		if ( !regs.CR[0].eq ) { return 0x821B74C4;  }
		/* 821B740Ch case    6:*/		return 0x821B7410;
		  /* 821B7410h */ case    7:  		/* cmplwi CR0, R11, 0 */
		/* 821B7410h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821B7410h case    7:*/		return 0x821B7414;
		  /* 821B7414h */ case    8:  		/* bc 12, CR0_EQ, 176 */
		/* 821B7414h case    8:*/		if ( regs.CR[0].eq ) { return 0x821B74C4;  }
		/* 821B7414h case    8:*/		return 0x821B7418;
		  /* 821B7418h */ case    9:  		/* cmplw CR6, R28, R11 */
		/* 821B7418h case    9:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R11);
		/* 821B7418h case    9:*/		return 0x821B741C;
		  /* 821B741Ch */ case   10:  		/* bc 12, CR6_EQ, 52 */
		/* 821B741Ch case   10:*/		if ( regs.CR[6].eq ) { return 0x821B7450;  }
		/* 821B741Ch case   10:*/		return 0x821B7420;
		  /* 821B7420h */ case   11:  		/* lwz R10, <#[R20]> */
		/* 821B7420h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R20 + 0x00000000) );
		/* 821B7420h case   11:*/		return 0x821B7424;
		  /* 821B7424h */ case   12:  		/* lwz R9, <#[R11 + 40]> */
		/* 821B7424h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000028) );
		/* 821B7424h case   12:*/		return 0x821B7428;
		  /* 821B7428h */ case   13:  		/* rlwinm R8, R10, 0, 13, 31 */
		/* 821B7428h case   13:*/		cpu::op::rlwinm<0,0,13,31>(regs,&regs.R8,regs.R10);
		/* 821B7428h case   13:*/		return 0x821B742C;
		  /* 821B742Ch */ case   14:  		/* rlwinm R10, R8, 27, 5, 31 */
		/* 821B742Ch case   14:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R8);
		/* 821B742Ch case   14:*/		return 0x821B7430;
		  /* 821B7430h */ case   15:  		/* rlwinm R8, R8, 0, 27, 31 */
		/* 821B7430h case   15:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R8,regs.R8);
		/* 821B7430h case   15:*/		return 0x821B7434;
		  /* 821B7434h */ case   16:  		/* addi R10, R10, 1 */
		/* 821B7434h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821B7434h case   16:*/		return 0x821B7438;
		  /* 821B7438h */ case   17:  		/* slw R8, R22, R8 */
		/* 821B7438h case   17:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R22,regs.R8);
		/* 821B7438h case   17:*/		return 0x821B743C;
		  /* 821B743Ch */ case   18:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821B743Ch case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821B743Ch case   18:*/		return 0x821B7440;
		  /* 821B7440h */ case   19:  		/* lwzx R10, <#[R10 + R9]> */
		/* 821B7440h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 821B7440h case   19:*/		return 0x821B7444;
		  /* 821B7444h */ case   20:  		/* and. R10, R10, R8 */
		/* 821B7444h case   20:*/		cpu::op::and<1>(regs,&regs.R10,regs.R10,regs.R8);
		/* 821B7444h case   20:*/		return 0x821B7448;
		  /* 821B7448h */ case   21:  		/* mr R10, R22 */
		/* 821B7448h case   21:*/		regs.R10 = regs.R22;
		/* 821B7448h case   21:*/		return 0x821B744C;
		  /* 821B744Ch */ case   22:  		/* bc 4, CR0_EQ, 8 */
		/* 821B744Ch case   22:*/		if ( !regs.CR[0].eq ) { return 0x821B7454;  }
		/* 821B744Ch case   22:*/		return 0x821B7450;
	}
	return 0x821B7450;
} // Block from 821B73F4h-821B7450h (23 instructions)

//////////////////////////////////////////////////////
// Block at 821B7450h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7450( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7450) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7450);
		  /* 821B7450h */ case    0:  		/* li R10, 0 */
		/* 821B7450h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821B7450h case    0:*/		return 0x821B7454;
	}
	return 0x821B7454;
} // Block from 821B7450h-821B7454h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B7454h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7454( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7454) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7454);
		  /* 821B7454h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 821B7454h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 821B7454h case    0:*/		return 0x821B7458;
		  /* 821B7458h */ case    1:  		/* bc 12, CR0_EQ, 84 */
		/* 821B7458h case    1:*/		if ( regs.CR[0].eq ) { return 0x821B74AC;  }
		/* 821B7458h case    1:*/		return 0x821B745C;
		  /* 821B745Ch */ case    2:  		/* cmplw CR6, R23, R11 */
		/* 821B745Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R23,regs.R11);
		/* 821B745Ch case    2:*/		return 0x821B7460;
		  /* 821B7460h */ case    3:  		/* bc 12, CR6_EQ, 52 */
		/* 821B7460h case    3:*/		if ( regs.CR[6].eq ) { return 0x821B7494;  }
		/* 821B7460h case    3:*/		return 0x821B7464;
		  /* 821B7464h */ case    4:  		/* lwz R10, <#[R21]> */
		/* 821B7464h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R21 + 0x00000000) );
		/* 821B7464h case    4:*/		return 0x821B7468;
		  /* 821B7468h */ case    5:  		/* lwz R9, <#[R11 + 40]> */
		/* 821B7468h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000028) );
		/* 821B7468h case    5:*/		return 0x821B746C;
		  /* 821B746Ch */ case    6:  		/* rlwinm R8, R10, 0, 13, 31 */
		/* 821B746Ch case    6:*/		cpu::op::rlwinm<0,0,13,31>(regs,&regs.R8,regs.R10);
		/* 821B746Ch case    6:*/		return 0x821B7470;
		  /* 821B7470h */ case    7:  		/* rlwinm R10, R8, 27, 5, 31 */
		/* 821B7470h case    7:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R8);
		/* 821B7470h case    7:*/		return 0x821B7474;
		  /* 821B7474h */ case    8:  		/* rlwinm R8, R8, 0, 27, 31 */
		/* 821B7474h case    8:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R8,regs.R8);
		/* 821B7474h case    8:*/		return 0x821B7478;
		  /* 821B7478h */ case    9:  		/* addi R10, R10, 1 */
		/* 821B7478h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821B7478h case    9:*/		return 0x821B747C;
		  /* 821B747Ch */ case   10:  		/* slw R8, R22, R8 */
		/* 821B747Ch case   10:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R22,regs.R8);
		/* 821B747Ch case   10:*/		return 0x821B7480;
		  /* 821B7480h */ case   11:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821B7480h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821B7480h case   11:*/		return 0x821B7484;
		  /* 821B7484h */ case   12:  		/* lwzx R10, <#[R10 + R9]> */
		/* 821B7484h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 821B7484h case   12:*/		return 0x821B7488;
		  /* 821B7488h */ case   13:  		/* and. R10, R10, R8 */
		/* 821B7488h case   13:*/		cpu::op::and<1>(regs,&regs.R10,regs.R10,regs.R8);
		/* 821B7488h case   13:*/		return 0x821B748C;
		  /* 821B748Ch */ case   14:  		/* mr R10, R22 */
		/* 821B748Ch case   14:*/		regs.R10 = regs.R22;
		/* 821B748Ch case   14:*/		return 0x821B7490;
		  /* 821B7490h */ case   15:  		/* bc 4, CR0_EQ, 8 */
		/* 821B7490h case   15:*/		if ( !regs.CR[0].eq ) { return 0x821B7498;  }
		/* 821B7490h case   15:*/		return 0x821B7494;
	}
	return 0x821B7494;
} // Block from 821B7454h-821B7494h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821B7494h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7494( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7494) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7494);
		  /* 821B7494h */ case    0:  		/* li R10, 0 */
		/* 821B7494h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821B7494h case    0:*/		return 0x821B7498;
	}
	return 0x821B7498;
} // Block from 821B7494h-821B7498h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B7498h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7498( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7498) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7498);
		  /* 821B7498h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 821B7498h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 821B7498h case    0:*/		return 0x821B749C;
		  /* 821B749Ch */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 821B749Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x821B74AC;  }
		/* 821B749Ch case    1:*/		return 0x821B74A0;
		  /* 821B74A0h */ case    2:  		/* lwz R10, <#[R11 + 48]> */
		/* 821B74A0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 821B74A0h case    2:*/		return 0x821B74A4;
		  /* 821B74A4h */ case    3:  		/* oris R10, R10, 512 */
		/* 821B74A4h case    3:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x200);
		/* 821B74A4h case    3:*/		return 0x821B74A8;
		  /* 821B74A8h */ case    4:  		/* stw R10, <#[R11 + 48]> */
		/* 821B74A8h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 821B74A8h case    4:*/		return 0x821B74AC;
	}
	return 0x821B74AC;
} // Block from 821B7498h-821B74ACh (5 instructions)

//////////////////////////////////////////////////////
// Block at 821B74ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B74AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B74AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B74AC);
		  /* 821B74ACh */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821B74ACh case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821B74ACh case    0:*/		return 0x821B74B0;
		  /* 821B74B0h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 821B74B0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821B74B0h case    1:*/		return 0x821B74B4;
		  /* 821B74B4h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821B74B4h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821B74B4h case    2:*/		return 0x821B74B8;
		  /* 821B74B8h */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 821B74B8h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821B74C4;  }
		/* 821B74B8h case    3:*/		return 0x821B74BC;
		  /* 821B74BCh */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 821B74BCh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821B74BCh case    4:*/		return 0x821B74C0;
		  /* 821B74C0h */ case    5:  		/* bc 4, CR6_EQ, -168 */
		/* 821B74C0h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821B7418;  }
		/* 821B74C0h case    5:*/		return 0x821B74C4;
	}
	return 0x821B74C4;
} // Block from 821B74ACh-821B74C4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821B74C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B74C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B74C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B74C4);
		  /* 821B74C4h */ case    0:  		/* stw R26, <#[R19]> */
		/* 821B74C4h case    0:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R19 + 0x00000000) );
		/* 821B74C4h case    0:*/		return 0x821B74C8;
		  /* 821B74C8h */ case    1:  		/* mr R3, R28 */
		/* 821B74C8h case    1:*/		regs.R3 = regs.R28;
		/* 821B74C8h case    1:*/		return 0x821B74CC;
		  /* 821B74CCh */ case    2:  		/* stw R24, <#[R18]> */
		/* 821B74CCh case    2:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R18 + 0x00000000) );
		/* 821B74CCh case    2:*/		return 0x821B74D0;
		  /* 821B74D0h */ case    3:  		/* addi R1, R1, 208 */
		/* 821B74D0h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 821B74D0h case    3:*/		return 0x821B74D4;
		  /* 821B74D4h */ case    4:  		/* b -1204820 */
		/* 821B74D4h case    4:*/		return 0x82091280;
		/* 821B74D4h case    4:*/		return 0x821B74D8;
	}
	return 0x821B74D8;
} // Block from 821B74C4h-821B74D8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821B74D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B74D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B74D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B74D8);
		  /* 821B74D8h */ case    0:  		/* mr R5, R29 */
		/* 821B74D8h case    0:*/		regs.R5 = regs.R29;
		/* 821B74D8h case    0:*/		return 0x821B74DC;
		  /* 821B74DCh */ case    1:  		/* mr R3, R31 */
		/* 821B74DCh case    1:*/		regs.R3 = regs.R31;
		/* 821B74DCh case    1:*/		return 0x821B74E0;
		  /* 821B74E0h */ case    2:  		/* bl -258640 */
		/* 821B74E0h case    2:*/		regs.LR = 0x821B74E4; return 0x82178290;
		/* 821B74E0h case    2:*/		return 0x821B74E4;
		  /* 821B74E4h */ case    3:  		/* b -240 */
		/* 821B74E4h case    3:*/		return 0x821B73F4;
		/* 821B74E4h case    3:*/		return 0x821B74E8;
	}
	return 0x821B74E8;
} // Block from 821B74D8h-821B74E8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821B74E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B74E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B74E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B74E8);
		  /* 821B74E8h */ case    0:  		/* cmplw CR6, R11, R25 */
		/* 821B74E8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R25);
		/* 821B74E8h case    0:*/		return 0x821B74EC;
		  /* 821B74ECh */ case    1:  		/* bc 12, CR6_EQ, -248 */
		/* 821B74ECh case    1:*/		if ( regs.CR[6].eq ) { return 0x821B73F4;  }
		/* 821B74ECh case    1:*/		return 0x821B74F0;
		  /* 821B74F0h */ case    2:  		/* lwz R9, <#[R26]> */
		/* 821B74F0h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000000) );
		/* 821B74F0h case    2:*/		return 0x821B74F4;
		  /* 821B74F4h */ case    3:  		/* mr R24, R26 */
		/* 821B74F4h case    3:*/		regs.R24 = regs.R26;
		/* 821B74F4h case    3:*/		return 0x821B74F8;
		  /* 821B74F8h */ case    4:  		/* cmplwi CR6, R9, 0 */
		/* 821B74F8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 821B74F8h case    4:*/		return 0x821B74FC;
		  /* 821B74FCh */ case    5:  		/* bc 12, CR6_EQ, 96 */
		/* 821B74FCh case    5:*/		if ( regs.CR[6].eq ) { return 0x821B755C;  }
		/* 821B74FCh case    5:*/		return 0x821B7500;
		  /* 821B7500h */ case    6:  		/* lwz R11, <#[R9]> */
		/* 821B7500h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 821B7500h case    6:*/		return 0x821B7504;
		  /* 821B7504h */ case    7:  		/* rlwinm. R10, R11, 0, 1, 1 */
		/* 821B7504h case    7:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R11);
		/* 821B7504h case    7:*/		return 0x821B7508;
		  /* 821B7508h */ case    8:  		/* bc 4, CR0_EQ, 16 */
		/* 821B7508h case    8:*/		if ( !regs.CR[0].eq ) { return 0x821B7518;  }
		/* 821B7508h case    8:*/		return 0x821B750C;
		  /* 821B750Ch */ case    9:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 821B750Ch case    9:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 821B750Ch case    9:*/		return 0x821B7510;
		  /* 821B7510h */ case   10:  		/* mr R11, R22 */
		/* 821B7510h case   10:*/		regs.R11 = regs.R22;
		/* 821B7510h case   10:*/		return 0x821B7514;
		  /* 821B7514h */ case   11:  		/* bc 12, CR0_EQ, 8 */
		/* 821B7514h case   11:*/		if ( regs.CR[0].eq ) { return 0x821B751C;  }
		/* 821B7514h case   11:*/		return 0x821B7518;
	}
	return 0x821B7518;
} // Block from 821B74E8h-821B7518h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821B7518h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7518( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7518) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7518);
		  /* 821B7518h */ case    0:  		/* li R11, 0 */
		/* 821B7518h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821B7518h case    0:*/		return 0x821B751C;
	}
	return 0x821B751C;
} // Block from 821B7518h-821B751Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B751Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B751C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B751C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B751C);
		  /* 821B751Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821B751Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821B751Ch case    0:*/		return 0x821B7520;
		  /* 821B7520h */ case    1:  		/* bc 12, CR0_EQ, 32 */
		/* 821B7520h case    1:*/		if ( regs.CR[0].eq ) { return 0x821B7540;  }
		/* 821B7520h case    1:*/		return 0x821B7524;
		  /* 821B7524h */ case    2:  		/* lwz R11, <#[R9 + 12]> */
		/* 821B7524h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x0000000C) );
		/* 821B7524h case    2:*/		return 0x821B7528;
		  /* 821B7528h */ case    3:  		/* lwz R10, <#[R11 + 8]> */
		/* 821B7528h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821B7528h case    3:*/		return 0x821B752C;
		  /* 821B752Ch */ case    4:  		/* rlwinm R10, R10, 25, 25, 31 */
		/* 821B752Ch case    4:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R10);
		/* 821B752Ch case    4:*/		return 0x821B7530;
	}
	return 0x821B7530;
} // Block from 821B751Ch-821B7530h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821B7530h
// Function '?CopyMERGEOperands@Compiler@D3DXShader@@AAAIPAVInstruction@2@I0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7530);
		  /* 821B7530h */ case    0:  		/* cmplwi CR6, R10, 91 */
		/* 821B7530h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000005B);
		/* 821B7530h case    0:*/		return 0x821B7534;
		  /* 821B7534h */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 821B7534h case    1:*/		if ( regs.CR[6].eq ) { return 0x821B7548;  }
		/* 821B7534h case    1:*/		return 0x821B7538;
		  /* 821B7538h */ case    2:  		/* cmplwi CR6, R10, 92 */
		/* 821B7538h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000005C);
		/* 821B7538h case    2:*/		return 0x821B753C;
		  /* 821B753Ch */ case    3:  		/* bc 12, CR6_EQ, 20 */
		/* 821B753Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x821B7550;  }
		/* 821B753Ch case    3:*/		return 0x821B7540;
	}
	return 0x821B7540;
} // Block from 821B7530h-821B7540h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821B7540h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7540( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7540) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7540);
		  /* 821B7540h */ case    0:  		/* lwz R9, <#[R9 + 4]> */
		/* 821B7540h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000004) );
		/* 821B7540h case    0:*/		return 0x821B7544;
		  /* 821B7544h */ case    1:  		/* b -76 */
		/* 821B7544h case    1:*/		return 0x821B74F8;
		/* 821B7544h case    1:*/		return 0x821B7548;
	}
	return 0x821B7548;
} // Block from 821B7540h-821B7548h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B7548h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7548( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7548) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7548);
		  /* 821B7548h */ case    0:  		/* mr R26, R11 */
		/* 821B7548h case    0:*/		regs.R26 = regs.R11;
		/* 821B7548h case    0:*/		return 0x821B754C;
		  /* 821B754Ch */ case    1:  		/* b 8 */
		/* 821B754Ch case    1:*/		return 0x821B7554;
		/* 821B754Ch case    1:*/		return 0x821B7550;
	}
	return 0x821B7550;
} // Block from 821B7548h-821B7550h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B7550h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7550( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7550) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7550);
		  /* 821B7550h */ case    0:  		/* mr R24, R11 */
		/* 821B7550h case    0:*/		regs.R24 = regs.R11;
		/* 821B7550h case    0:*/		return 0x821B7554;
	}
	return 0x821B7554;
} // Block from 821B7550h-821B7554h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B7554h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7554( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7554) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7554);
		  /* 821B7554h */ case    0:  		/* cmplwi CR6, R26, 0 */
		/* 821B7554h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 821B7554h case    0:*/		return 0x821B7558;
		  /* 821B7558h */ case    1:  		/* bc 4, CR6_EQ, -356 */
		/* 821B7558h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821B73F4;  }
		/* 821B7558h case    1:*/		return 0x821B755C;
	}
	return 0x821B755C;
} // Block from 821B7554h-821B755Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B755Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B755C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B755C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B755C);
		  /* 821B755Ch */ case    0:  		/* li R4, 4800 */
		/* 821B755Ch case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 821B755Ch case    0:*/		return 0x821B7560;
		  /* 821B7560h */ case    1:  		/* mr R3, R29 */
		/* 821B7560h case    1:*/		regs.R3 = regs.R29;
		/* 821B7560h case    1:*/		return 0x821B7564;
		  /* 821B7564h */ case    2:  		/* bl -415484 */
		/* 821B7564h case    2:*/		regs.LR = 0x821B7568; return 0x82151E68;
		/* 821B7564h case    2:*/		return 0x821B7568;
	}
	return 0x821B7568;
} // Block from 821B755Ch-821B7568h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821B7568h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7568( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7568) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7568);
		  /* 821B7568h */ case    0:  		/* mfspr R12, LR */
		/* 821B7568h case    0:*/		regs.R12 = regs.LR;
		/* 821B7568h case    0:*/		return 0x821B756C;
		  /* 821B756Ch */ case    1:  		/* bl -1205032 */
		/* 821B756Ch case    1:*/		regs.LR = 0x821B7570; return 0x82091244;
		/* 821B756Ch case    1:*/		return 0x821B7570;
		  /* 821B7570h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 821B7570h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 821B7570h case    2:*/		return 0x821B7574;
		  /* 821B7574h */ case    3:  		/* mr R28, R3 */
		/* 821B7574h case    3:*/		regs.R28 = regs.R3;
		/* 821B7574h case    3:*/		return 0x821B7578;
		  /* 821B7578h */ case    4:  		/* mr R30, R4 */
		/* 821B7578h case    4:*/		regs.R30 = regs.R4;
		/* 821B7578h case    4:*/		return 0x821B757C;
		  /* 821B757Ch */ case    5:  		/* mr R24, R6 */
		/* 821B757Ch case    5:*/		regs.R24 = regs.R6;
		/* 821B757Ch case    5:*/		return 0x821B7580;
		  /* 821B7580h */ case    6:  		/* mr R25, R7 */
		/* 821B7580h case    6:*/		regs.R25 = regs.R7;
		/* 821B7580h case    6:*/		return 0x821B7584;
		  /* 821B7584h */ case    7:  		/* mr R29, R8 */
		/* 821B7584h case    7:*/		regs.R29 = regs.R8;
		/* 821B7584h case    7:*/		return 0x821B7588;
		  /* 821B7588h */ case    8:  		/* li R26, 1 */
		/* 821B7588h case    8:*/		cpu::op::li<0>(regs,&regs.R26,0x1);
		/* 821B7588h case    8:*/		return 0x821B758C;
		  /* 821B758Ch */ case    9:  		/* cmplwi CR6, R5, 0 */
		/* 821B758Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 821B758Ch case    9:*/		return 0x821B7590;
		  /* 821B7590h */ case   10:  		/* bc 12, CR6_EQ, 128 */
		/* 821B7590h case   10:*/		if ( regs.CR[6].eq ) { return 0x821B7610;  }
		/* 821B7590h case   10:*/		return 0x821B7594;
		  /* 821B7594h */ case   11:  		/* addi R31, R4, 44 */
		/* 821B7594h case   11:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R4,0x2C);
		/* 821B7594h case   11:*/		return 0x821B7598;
		  /* 821B7598h */ case   12:  		/* mr R27, R5 */
		/* 821B7598h case   12:*/		regs.R27 = regs.R5;
		/* 821B7598h case   12:*/		return 0x821B759C;
		  /* 821B759Ch */ case   13:  		/* and. R11, R26, R24 */
		/* 821B759Ch case   13:*/		cpu::op::and<1>(regs,&regs.R11,regs.R26,regs.R24);
		/* 821B759Ch case   13:*/		return 0x821B75A0;
		  /* 821B75A0h */ case   14:  		/* bc 12, CR0_EQ, 96 */
		/* 821B75A0h case   14:*/		if ( regs.CR[0].eq ) { return 0x821B7600;  }
		/* 821B75A0h case   14:*/		return 0x821B75A4;
		  /* 821B75A4h */ case   15:  		/* mr R4, R25 */
		/* 821B75A4h case   15:*/		regs.R4 = regs.R25;
		/* 821B75A4h case   15:*/		return 0x821B75A8;
		  /* 821B75A8h */ case   16:  		/* mr R3, R28 */
		/* 821B75A8h case   16:*/		regs.R3 = regs.R28;
		/* 821B75A8h case   16:*/		return 0x821B75AC;
		  /* 821B75ACh */ case   17:  		/* bl -259500 */
		/* 821B75ACh case   17:*/		regs.LR = 0x821B75B0; return 0x82178000;
		/* 821B75ACh case   17:*/		return 0x821B75B0;
		  /* 821B75B0h */ case   18:  		/* mr R23, R3 */
		/* 821B75B0h case   18:*/		regs.R23 = regs.R3;
		/* 821B75B0h case   18:*/		return 0x821B75B4;
		  /* 821B75B4h */ case   19:  		/* rlwinm R11, R29, 5, 22, 26 */
		/* 821B75B4h case   19:*/		cpu::op::rlwinm<0,5,22,26>(regs,&regs.R11,regs.R29);
		/* 821B75B4h case   19:*/		return 0x821B75B8;
		  /* 821B75B8h */ case   20:  		/* lis R12, -3073 */
		/* 821B75B8h case   20:*/		cpu::op::lis<0>(regs,&regs.R12,0xFFFFF3FF);
		/* 821B75B8h case   20:*/		return 0x821B75BC;
		  /* 821B75BCh */ case   21:  		/* rlwinm R11, R11, 0, 25, 23 */
		/* 821B75BCh case   21:*/		cpu::op::rlwinm<0,0,25,23>(regs,&regs.R11,regs.R11);
		/* 821B75BCh case   21:*/		return 0x821B75C0;
		  /* 821B75C0h */ case   22:  		/* ori R12, R12, 64671 */
		/* 821B75C0h case   22:*/		cpu::op::ori<0>(regs,&regs.R12,regs.R12,0xFC9F);
		/* 821B75C0h case   22:*/		return 0x821B75C4;
		  /* 821B75C4h */ case   23:  		/* lwz R10, <#[R23]> */
		/* 821B75C4h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000000) );
		/* 821B75C4h case   23:*/		return 0x821B75C8;
		  /* 821B75C8h */ case   24:  		/* oris R11, R11, 512 */
		/* 821B75C8h case   24:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x200);
		/* 821B75C8h case   24:*/		return 0x821B75CC;
		  /* 821B75CCh */ case   25:  		/* mr R5, R28 */
		/* 821B75CCh case   25:*/		regs.R5 = regs.R28;
		/* 821B75CCh case   25:*/		return 0x821B75D0;
		  /* 821B75D0h */ case   26:  		/* ori R11, R11, 7296 */
		/* 821B75D0h case   26:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1C80);
		/* 821B75D0h case   26:*/		return 0x821B75D4;
		  /* 821B75D4h */ case   27:  		/* and R10, R10, R12 */
		/* 821B75D4h case   27:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R12);
		/* 821B75D4h case   27:*/		return 0x821B75D8;
		  /* 821B75D8h */ case   28:  		/* mr R3, R30 */
		/* 821B75D8h case   28:*/		regs.R3 = regs.R30;
		/* 821B75D8h case   28:*/		return 0x821B75DC;
		  /* 821B75DCh */ case   29:  		/* or R11, R11, R10 */
		/* 821B75DCh case   29:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821B75DCh case   29:*/		return 0x821B75E0;
		  /* 821B75E0h */ case   30:  		/* stw R11, <#[R23]> */
		/* 821B75E0h case   30:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 821B75E0h case   30:*/		return 0x821B75E4;
		  /* 821B75E4h */ case   31:  		/* lwz R4, <#[R31]> */
		/* 821B75E4h case   31:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000000) );
		/* 821B75E4h case   31:*/		return 0x821B75E8;
		  /* 821B75E8h */ case   32:  		/* bl -257240 */
		/* 821B75E8h case   32:*/		regs.LR = 0x821B75EC; return 0x82178910;
		/* 821B75E8h case   32:*/		return 0x821B75EC;
		  /* 821B75ECh */ case   33:  		/* mr R4, R23 */
		/* 821B75ECh case   33:*/		regs.R4 = regs.R23;
		/* 821B75ECh case   33:*/		return 0x821B75F0;
		  /* 821B75F0h */ case   34:  		/* mr R3, R30 */
		/* 821B75F0h case   34:*/		regs.R3 = regs.R30;
		/* 821B75F0h case   34:*/		return 0x821B75F4;
		  /* 821B75F4h */ case   35:  		/* bl -259116 */
		/* 821B75F4h case   35:*/		regs.LR = 0x821B75F8; return 0x821781C8;
		/* 821B75F4h case   35:*/		return 0x821B75F8;
		  /* 821B75F8h */ case   36:  		/* addi R29, R29, 1 */
		/* 821B75F8h case   36:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 821B75F8h case   36:*/		return 0x821B75FC;
		  /* 821B75FCh */ case   37:  		/* stw R3, <#[R31]> */
		/* 821B75FCh case   37:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 821B75FCh case   37:*/		return 0x821B7600;
	}
	return 0x821B7600;
} // Block from 821B7568h-821B7600h (38 instructions)

//////////////////////////////////////////////////////
// Block at 821B7600h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7600( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7600) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7600);
		  /* 821B7600h */ case    0:  		/* addic. R27, R27, -1 */
		/* 821B7600h case    0:*/		cpu::op::addic<1>(regs,&regs.R27,regs.R27,0xFFFFFFFF);
		/* 821B7600h case    0:*/		return 0x821B7604;
		  /* 821B7604h */ case    1:  		/* addi R31, R31, 4 */
		/* 821B7604h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 821B7604h case    1:*/		return 0x821B7608;
		  /* 821B7608h */ case    2:  		/* rlwinm R26, R26, 1, 0, 30 */
		/* 821B7608h case    2:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R26,regs.R26);
		/* 821B7608h case    2:*/		return 0x821B760C;
		  /* 821B760Ch */ case    3:  		/* bc 4, CR0_EQ, -112 */
		/* 821B760Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x821B759C;  }
		/* 821B760Ch case    3:*/		return 0x821B7610;
	}
	return 0x821B7610;
} // Block from 821B7600h-821B7610h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821B7610h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7610( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7610) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7610);
		  /* 821B7610h */ case    0:  		/* addi R1, R1, 160 */
		/* 821B7610h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 821B7610h case    0:*/		return 0x821B7614;
		  /* 821B7614h */ case    1:  		/* b -1205120 */
		/* 821B7614h case    1:*/		return 0x82091294;
		/* 821B7614h case    1:*/		return 0x821B7618;
	}
	return 0x821B7618;
} // Block from 821B7610h-821B7618h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B7618h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7618( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7618) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7618);
		  /* 821B7618h */ case    0:  		/* mfspr R12, LR */
		/* 821B7618h case    0:*/		regs.R12 = regs.LR;
		/* 821B7618h case    0:*/		return 0x821B761C;
		  /* 821B761Ch */ case    1:  		/* bl -1205216 */
		/* 821B761Ch case    1:*/		regs.LR = 0x821B7620; return 0x8209123C;
		/* 821B761Ch case    1:*/		return 0x821B7620;
		  /* 821B7620h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 821B7620h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 821B7620h case    2:*/		return 0x821B7624;
		  /* 821B7624h */ case    3:  		/* lwz R11, <#[R4]> */
		/* 821B7624h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 821B7624h case    3:*/		return 0x821B7628;
		  /* 821B7628h */ case    4:  		/* mr R25, R3 */
		/* 821B7628h case    4:*/		regs.R25 = regs.R3;
		/* 821B7628h case    4:*/		return 0x821B762C;
		  /* 821B762Ch */ case    5:  		/* lwz R27, <#[R4 + 16]> */
		/* 821B762Ch case    5:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R4 + 0x00000010) );
		/* 821B762Ch case    5:*/		return 0x821B7630;
		  /* 821B7630h */ case    6:  		/* mr R31, R4 */
		/* 821B7630h case    6:*/		regs.R31 = regs.R4;
		/* 821B7630h case    6:*/		return 0x821B7634;
		  /* 821B7634h */ case    7:  		/* rlwinm R28, R11, 7, 29, 31 */
		/* 821B7634h case    7:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R28,regs.R11);
		/* 821B7634h case    7:*/		return 0x821B7638;
		  /* 821B7638h */ case    8:  		/* lwz R22, <#[R4 + 12]> */
		/* 821B7638h case    8:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R4 + 0x0000000C) );
		/* 821B7638h case    8:*/		return 0x821B763C;
		  /* 821B763Ch */ case    9:  		/* andi. R21, R11, 25 */
		/* 821B763Ch case    9:*/		cpu::op::andi<1>(regs,&regs.R21,regs.R11,0x19);
		/* 821B763Ch case    9:*/		return 0x821B7640;
		  /* 821B7640h */ case   10:  		/* lwz R30, <#[R27 + 28]> */
		/* 821B7640h case   10:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R27 + 0x0000001C) );
		/* 821B7640h case   10:*/		return 0x821B7644;
		  /* 821B7644h */ case   11:  		/* mr R23, R5 */
		/* 821B7644h case   11:*/		regs.R23 = regs.R5;
		/* 821B7644h case   11:*/		return 0x821B7648;
		  /* 821B7648h */ case   12:  		/* li R8, 0 */
		/* 821B7648h case   12:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821B7648h case   12:*/		return 0x821B764C;
		  /* 821B764Ch */ case   13:  		/* li R10, 0 */
		/* 821B764Ch case   13:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821B764Ch case   13:*/		return 0x821B7650;
		  /* 821B7650h */ case   14:  		/* cmplwi CR0, R28, 0 */
		/* 821B7650h case   14:*/		cpu::op::cmplwi<0>(regs,regs.R28,0x00000000);
		/* 821B7650h case   14:*/		return 0x821B7654;
		  /* 821B7654h */ case   15:  		/* bc 12, CR0_EQ, 84 */
		/* 821B7654h case   15:*/		if ( regs.CR[0].eq ) { return 0x821B76A8;  }
		/* 821B7654h case   15:*/		return 0x821B7658;
		  /* 821B7658h */ case   16:  		/* rlwinm R6, R11, 0, 0, 31 */
		/* 821B7658h case   16:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R6,regs.R11);
		/* 821B7658h case   16:*/		return 0x821B765C;
		  /* 821B765Ch */ case   17:  		/* rlwinm R7, R11, 27, 24, 31 */
		/* 821B765Ch case   17:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R7,regs.R11);
		/* 821B765Ch case   17:*/		return 0x821B7660;
		  /* 821B7660h */ case   18:  		/* li R9, 0 */
		/* 821B7660h case   18:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821B7660h case   18:*/		return 0x821B7664;
		  /* 821B7664h */ case   19:  		/* rlwinm R6, R6, 7, 29, 31 */
		/* 821B7664h case   19:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R6,regs.R6);
		/* 821B7664h case   19:*/		return 0x821B7668;
		  /* 821B7668h */ case   20:  		/* srw R5, R7, R9 */
		/* 821B7668h case   20:*/		cpu::op::srw<0>(regs,&regs.R5,regs.R7,regs.R9);
		/* 821B7668h case   20:*/		return 0x821B766C;
		  /* 821B766Ch */ case   21:  		/* rlwinm R5, R5, 0, 30, 31 */
		/* 821B766Ch case   21:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R5,regs.R5);
		/* 821B766Ch case   21:*/		return 0x821B7670;
		  /* 821B7670h */ case   22:  		/* li R4, 1 */
		/* 821B7670h case   22:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 821B7670h case   22:*/		return 0x821B7674;
		  /* 821B7674h */ case   23:  		/* addi R10, R10, 1 */
		/* 821B7674h case   23:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821B7674h case   23:*/		return 0x821B7678;
		  /* 821B7678h */ case   24:  		/* slw R5, R4, R5 */
		/* 821B7678h case   24:*/		cpu::op::slw<0>(regs,&regs.R5,regs.R4,regs.R5);
		/* 821B7678h case   24:*/		return 0x821B767C;
		  /* 821B767Ch */ case   25:  		/* or R8, R5, R8 */
		/* 821B767Ch case   25:*/		cpu::op::or<0>(regs,&regs.R8,regs.R5,regs.R8);
		/* 821B767Ch case   25:*/		return 0x821B7680;
	}
	return 0x821B7680;
} // Block from 821B7618h-821B7680h (26 instructions)

//////////////////////////////////////////////////////
// Block at 821B7680h
// Function '?MakeInstr_V_MAX@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVBlock@2@PAVDependency@2@1@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7680( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7680) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7680);
		  /* 821B7680h */ case    0:  		/* addi R9, R9, 2 */
		/* 821B7680h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x2);
		/* 821B7680h case    0:*/		return 0x821B7684;
		  /* 821B7684h */ case    1:  		/* cmplw CR6, R10, R6 */
		/* 821B7684h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R6);
		/* 821B7684h case    1:*/		return 0x821B7688;
		  /* 821B7688h */ case    2:  		/* bc 12, CR6_LT, -32 */
		/* 821B7688h case    2:*/		if ( regs.CR[6].lt ) { return 0x821B7668;  }
		/* 821B7688h case    2:*/		return 0x821B768C;
		  /* 821B768Ch */ case    3:  		/* cmplwi CR6, R8, 0 */
		/* 821B768Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 821B768Ch case    3:*/		return 0x821B7690;
		  /* 821B7690h */ case    4:  		/* bc 12, CR6_EQ, 24 */
		/* 821B7690h case    4:*/		if ( regs.CR[6].eq ) { return 0x821B76A8;  }
		/* 821B7690h case    4:*/		return 0x821B7694;
		  /* 821B7694h */ case    5:  		/* addi R10, R8, -1 */
		/* 821B7694h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R8,0xFFFFFFFF);
		/* 821B7694h case    5:*/		return 0x821B7698;
		  /* 821B7698h */ case    6:  		/* andc R10, R8, R10 */
		/* 821B7698h case    6:*/		cpu::op::andc<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 821B7698h case    6:*/		return 0x821B769C;
		  /* 821B769Ch */ case    7:  		/* subf. R10, R10, R8 */
		/* 821B769Ch case    7:*/		cpu::op::subf<1>(regs,&regs.R10,regs.R10,regs.R8);
		/* 821B769Ch case    7:*/		return 0x821B76A0;
		  /* 821B76A0h */ case    8:  		/* li R10, 1 */
		/* 821B76A0h case    8:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 821B76A0h case    8:*/		return 0x821B76A4;
		  /* 821B76A4h */ case    9:  		/* bc 12, CR0_EQ, 8 */
		/* 821B76A4h case    9:*/		if ( regs.CR[0].eq ) { return 0x821B76AC;  }
		/* 821B76A4h case    9:*/		return 0x821B76A8;
	}
	return 0x821B76A8;
} // Block from 821B7680h-821B76A8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821B76A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B76A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B76A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B76A8);
		  /* 821B76A8h */ case    0:  		/* li R10, 0 */
		/* 821B76A8h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821B76A8h case    0:*/		return 0x821B76AC;
	}
	return 0x821B76AC;
} // Block from 821B76A8h-821B76ACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B76ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B76AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B76AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B76AC);
		  /* 821B76ACh */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 821B76ACh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 821B76ACh case    0:*/		return 0x821B76B0;
		  /* 821B76B0h */ case    1:  		/* mr R4, R30 */
		/* 821B76B0h case    1:*/		regs.R4 = regs.R30;
		/* 821B76B0h case    1:*/		return 0x821B76B4;
		  /* 821B76B4h */ case    2:  		/* mr R3, R25 */
		/* 821B76B4h case    2:*/		regs.R3 = regs.R25;
		/* 821B76B4h case    2:*/		return 0x821B76B8;
		  /* 821B76B8h */ case    3:  		/* bc 12, CR0_EQ, 404 */
		/* 821B76B8h case    3:*/		if ( regs.CR[0].eq ) { return 0x821B784C;  }
		/* 821B76B8h case    3:*/		return 0x821B76BC;
		  /* 821B76BCh */ case    4:  		/* rlwinm R6, R11, 27, 30, 31 */
		/* 821B76BCh case    4:*/		cpu::op::rlwinm<0,27,30,31>(regs,&regs.R6,regs.R11);
		/* 821B76BCh case    4:*/		return 0x821B76C0;
		  /* 821B76C0h */ case    5:  		/* mr R8, R23 */
		/* 821B76C0h case    5:*/		regs.R8 = regs.R23;
		/* 821B76C0h case    5:*/		return 0x821B76C4;
		  /* 821B76C4h */ case    6:  		/* mr R7, R21 */
		/* 821B76C4h case    6:*/		regs.R7 = regs.R21;
		/* 821B76C4h case    6:*/		return 0x821B76C8;
		  /* 821B76C8h */ case    7:  		/* mr R5, R22 */
		/* 821B76C8h case    7:*/		regs.R5 = regs.R22;
		/* 821B76C8h case    7:*/		return 0x821B76CC;
		  /* 821B76CCh */ case    8:  		/* bl -3644 */
		/* 821B76CCh case    8:*/		regs.LR = 0x821B76D0; return 0x821B6890;
		/* 821B76CCh case    8:*/		return 0x821B76D0;
		  /* 821B76D0h */ case    9:  		/* lwz R11, <#[R31 + 12]> */
		/* 821B76D0h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 821B76D0h case    9:*/		return 0x821B76D4;
		  /* 821B76D4h */ case   10:  		/* mr R29, R3 */
		/* 821B76D4h case   10:*/		regs.R29 = regs.R3;
		/* 821B76D4h case   10:*/		return 0x821B76D8;
		  /* 821B76D8h */ case   11:  		/* addi R11, R11, 4 */
		/* 821B76D8h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821B76D8h case   11:*/		return 0x821B76DC;
		  /* 821B76DCh */ case   12:  		/* lwz R10, <#[R11]> */
		/* 821B76DCh case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821B76DCh case   12:*/		return 0x821B76E0;
		  /* 821B76E0h */ case   13:  		/* b 12 */
		/* 821B76E0h case   13:*/		return 0x821B76EC;
		/* 821B76E0h case   13:*/		return 0x821B76E4;
		  /* 821B76E4h */ case   14:  		/* addi R11, R10, 8 */
		/* 821B76E4h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 821B76E4h case   14:*/		return 0x821B76E8;
		  /* 821B76E8h */ case   15:  		/* lwz R10, <#[R10 + 8]> */
		/* 821B76E8h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 821B76E8h case   15:*/		return 0x821B76EC;
	}
	return 0x821B76EC;
} // Block from 821B76ACh-821B76ECh (16 instructions)

//////////////////////////////////////////////////////
// Block at 821B76ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B76EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B76EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B76EC);
		  /* 821B76ECh */ case    0:  		/* cmplw CR6, R10, R31 */
		/* 821B76ECh case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 821B76ECh case    0:*/		return 0x821B76F0;
		  /* 821B76F0h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 821B76F0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821B76E4;  }
		/* 821B76F0h case    1:*/		return 0x821B76F4;
		  /* 821B76F4h */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 821B76F4h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 821B76F4h case    2:*/		return 0x821B76F8;
		  /* 821B76F8h */ case    3:  		/* stw R10, <#[R11]> */
		/* 821B76F8h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821B76F8h case    3:*/		return 0x821B76FC;
		  /* 821B76FCh */ case    4:  		/* lwz R11, <#[R29 + 4]> */
		/* 821B76FCh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 821B76FCh case    4:*/		return 0x821B7700;
		  /* 821B7700h */ case    5:  		/* stw R11, <#[R31 + 8]> */
		/* 821B7700h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821B7700h case    5:*/		return 0x821B7704;
		  /* 821B7704h */ case    6:  		/* stw R31, <#[R29 + 4]> */
		/* 821B7704h case    6:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R29 + 0x00000004) );
		/* 821B7704h case    6:*/		return 0x821B7708;
		  /* 821B7708h */ case    7:  		/* lwz R11, <#[R31]> */
		/* 821B7708h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821B7708h case    7:*/		return 0x821B770C;
		  /* 821B770Ch */ case    8:  		/* rlwinm R11, R11, 0, 27, 18 */
		/* 821B770Ch case    8:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R11,regs.R11);
		/* 821B770Ch case    8:*/		return 0x821B7710;
		  /* 821B7710h */ case    9:  		/* stw R11, <#[R31]> */
		/* 821B7710h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821B7710h case    9:*/		return 0x821B7714;
		  /* 821B7714h */ case   10:  		/* stw R29, <#[R31 + 12]> */
		/* 821B7714h case   10:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x0000000C) );
		/* 821B7714h case   10:*/		return 0x821B7718;
		  /* 821B7718h */ case   11:  		/* lwz R11, <#[R25 + 40]> */
		/* 821B7718h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000028) );
		/* 821B7718h case   11:*/		return 0x821B771C;
		  /* 821B771Ch */ case   12:  		/* rlwinm. R11, R11, 0, 12, 12 */
		/* 821B771Ch case   12:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R11,regs.R11);
		/* 821B771Ch case   12:*/		return 0x821B7720;
		  /* 821B7720h */ case   13:  		/* bc 12, CR0_EQ, 540 */
		/* 821B7720h case   13:*/		if ( regs.CR[0].eq ) { return 0x821B793C;  }
		/* 821B7720h case   13:*/		return 0x821B7724;
		  /* 821B7724h */ case   14:  		/* lwz R11, <#[R29 + 4]> */
		/* 821B7724h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 821B7724h case   14:*/		return 0x821B7728;
		  /* 821B7728h */ case   15:  		/* cmplwi CR6, R11, 0 */
		/* 821B7728h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821B7728h case   15:*/		return 0x821B772C;
		  /* 821B772Ch */ case   16:  		/* bc 12, CR6_EQ, 52 */
		/* 821B772Ch case   16:*/		if ( regs.CR[6].eq ) { return 0x821B7760;  }
		/* 821B772Ch case   16:*/		return 0x821B7730;
		  /* 821B7730h */ case   17:  		/* lwz R30, <#[R11 + 16]> */
		/* 821B7730h case   17:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000010) );
		/* 821B7730h case   17:*/		return 0x821B7734;
		  /* 821B7734h */ case   18:  		/* cmplwi CR6, R30, 0 */
		/* 821B7734h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821B7734h case   18:*/		return 0x821B7738;
		  /* 821B7738h */ case   19:  		/* bc 12, CR6_EQ, 32 */
		/* 821B7738h case   19:*/		if ( regs.CR[6].eq ) { return 0x821B7758;  }
		/* 821B7738h case   19:*/		return 0x821B773C;
		  /* 821B773Ch */ case   20:  		/* lwz R10, <#[R30 + 8]> */
		/* 821B773Ch case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 821B773Ch case   20:*/		return 0x821B7740;
		  /* 821B7740h */ case   21:  		/* rlwinm R10, R10, 0, 18, 24 */
		/* 821B7740h case   21:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R10);
		/* 821B7740h case   21:*/		return 0x821B7744;
		  /* 821B7744h */ case   22:  		/* cmplwi CR6, R10, 14080 */
		/* 821B7744h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003700);
		/* 821B7744h case   22:*/		return 0x821B7748;
		  /* 821B7748h */ case   23:  		/* bc 4, CR6_EQ, 16 */
		/* 821B7748h case   23:*/		if ( !regs.CR[6].eq ) { return 0x821B7758;  }
		/* 821B7748h case   23:*/		return 0x821B774C;
		  /* 821B774Ch */ case   24:  		/* lwz R10, <#[R11]> */
		/* 821B774Ch case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821B774Ch case   24:*/		return 0x821B7750;
		  /* 821B7750h */ case   25:  		/* rlwinm. R10, R10, 0, 4, 6 */
		/* 821B7750h case   25:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R10);
		/* 821B7750h case   25:*/		return 0x821B7754;
		  /* 821B7754h */ case   26:  		/* bc 4, CR0_EQ, 16 */
		/* 821B7754h case   26:*/		if ( !regs.CR[0].eq ) { return 0x821B7764;  }
		/* 821B7754h case   26:*/		return 0x821B7758;
	}
	return 0x821B7758;
} // Block from 821B76ECh-821B7758h (27 instructions)

//////////////////////////////////////////////////////
// Block at 821B7758h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7758( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7758) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7758);
		  /* 821B7758h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 821B7758h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821B7758h case    0:*/		return 0x821B775C;
		  /* 821B775Ch */ case    1:  		/* b -52 */
		/* 821B775Ch case    1:*/		return 0x821B7728;
		/* 821B775Ch case    1:*/		return 0x821B7760;
	}
	return 0x821B7760;
} // Block from 821B7758h-821B7760h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B7760h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7760( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7760) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7760);
		  /* 821B7760h */ case    0:  		/* li R30, 0 */
		/* 821B7760h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 821B7760h case    0:*/		return 0x821B7764;
	}
	return 0x821B7764;
} // Block from 821B7760h-821B7764h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B7764h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7764( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7764) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7764);
		  /* 821B7764h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 821B7764h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821B7764h case    0:*/		return 0x821B7768;
	}
	return 0x821B7768;
} // Block from 821B7764h-821B7768h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B7768h
// Function '?MakeInstr_V_MAX@Compiler@D3DXShader@@QAAPAVInstruction@2@PAVBlock@2@PAV?$DoubleLinkList@VInstruction@D3DXShader@@$0CE@@2@PAV32@2@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7768( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7768) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7768);
		  /* 821B7768h */ case    0:  		/* bc 12, CR6_EQ, 468 */
		/* 821B7768h case    0:*/		if ( regs.CR[6].eq ) { return 0x821B793C;  }
		/* 821B7768h case    0:*/		return 0x821B776C;
		  /* 821B776Ch */ case    1:  		/* mr R4, R30 */
		/* 821B776Ch case    1:*/		regs.R4 = regs.R30;
		/* 821B776Ch case    1:*/		return 0x821B7770;
		  /* 821B7770h */ case    2:  		/* mr R3, R27 */
		/* 821B7770h case    2:*/		regs.R3 = regs.R27;
		/* 821B7770h case    2:*/		return 0x821B7774;
		  /* 821B7774h */ case    3:  		/* bl 452940 */
		/* 821B7774h case    3:*/		regs.LR = 0x821B7778; return 0x822260C0;
		/* 821B7774h case    3:*/		return 0x821B7778;
		  /* 821B7778h */ case    4:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821B7778h case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821B7778h case    4:*/		return 0x821B777C;
		  /* 821B777Ch */ case    5:  		/* bc 12, CR0_EQ, 448 */
		/* 821B777Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x821B793C;  }
		/* 821B777Ch case    5:*/		return 0x821B7780;
		  /* 821B7780h */ case    6:  		/* lwz R11, <#[R31]> */
		/* 821B7780h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821B7780h case    6:*/		return 0x821B7784;
		  /* 821B7784h */ case    7:  		/* li R7, 0 */
		/* 821B7784h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821B7784h case    7:*/		return 0x821B7788;
		  /* 821B7788h */ case    8:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 821B7788h case    8:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 821B7788h case    8:*/		return 0x821B778C;
		  /* 821B778Ch */ case    9:  		/* bc 12, CR0_EQ, 132 */
		/* 821B778Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x821B7810;  }
		/* 821B778Ch case    9:*/		return 0x821B7790;
		  /* 821B7790h */ case   10:  		/* addi R8, R30, 44 */
		/* 821B7790h case   10:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R30,0x2C);
		/* 821B7790h case   10:*/		return 0x821B7794;
		  /* 821B7794h */ case   11:  		/* lwz R9, <#[R30 + 8]> */
		/* 821B7794h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x00000008) );
		/* 821B7794h case   11:*/		return 0x821B7798;
		  /* 821B7798h */ case   12:  		/* li R11, 0 */
		/* 821B7798h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821B7798h case   12:*/		return 0x821B779C;
		  /* 821B779Ch */ case   13:  		/* mr R10, R8 */
		/* 821B779Ch case   13:*/		regs.R10 = regs.R8;
		/* 821B779Ch case   13:*/		return 0x821B77A0;
		  /* 821B77A0h */ case   14:  		/* rlwinm R9, R9, 13, 29, 31 */
		/* 821B77A0h case   14:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R9,regs.R9);
		/* 821B77A0h case   14:*/		return 0x821B77A4;
		  /* 821B77A4h */ case   15:  		/* cmplw CR6, R11, R9 */
		/* 821B77A4h case   15:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 821B77A4h case   15:*/		return 0x821B77A8;
		  /* 821B77A8h */ case   16:  		/* bc 4, CR6_LT, 84 */
		/* 821B77A8h case   16:*/		if ( !regs.CR[6].lt ) { return 0x821B77FC;  }
		/* 821B77A8h case   16:*/		return 0x821B77AC;
		  /* 821B77ACh */ case   17:  		/* lwz R6, <#[R10]> */
		/* 821B77ACh case   17:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000000) );
		/* 821B77ACh case   17:*/		return 0x821B77B0;
		  /* 821B77B0h */ case   18:  		/* lwz R6, <#[R6 + 12]> */
		/* 821B77B0h case   18:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x0000000C) );
		/* 821B77B0h case   18:*/		return 0x821B77B4;
		  /* 821B77B4h */ case   19:  		/* cmplw CR6, R6, R29 */
		/* 821B77B4h case   19:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R29);
		/* 821B77B4h case   19:*/		return 0x821B77B8;
		  /* 821B77B8h */ case   20:  		/* bc 12, CR6_EQ, 16 */
		/* 821B77B8h case   20:*/		if ( regs.CR[6].eq ) { return 0x821B77C8;  }
		/* 821B77B8h case   20:*/		return 0x821B77BC;
		  /* 821B77BCh */ case   21:  		/* addi R11, R11, 1 */
		/* 821B77BCh case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821B77BCh case   21:*/		return 0x821B77C0;
		  /* 821B77C0h */ case   22:  		/* addi R10, R10, 4 */
		/* 821B77C0h case   22:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821B77C0h case   22:*/		return 0x821B77C4;
		  /* 821B77C4h */ case   23:  		/* b -32 */
		/* 821B77C4h case   23:*/		return 0x821B77A4;
		/* 821B77C4h case   23:*/		return 0x821B77C8;
	}
	return 0x821B77C8;
} // Block from 821B7768h-821B77C8h (24 instructions)

//////////////////////////////////////////////////////
// Block at 821B77C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B77C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B77C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B77C8);
		  /* 821B77C8h */ case    0:  		/* rlwinm R10, R11, 2, 0, 29 */
		/* 821B77C8h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R11);
		/* 821B77C8h case    0:*/		return 0x821B77CC;
		  /* 821B77CCh */ case    1:  		/* lwz R9, <#[R31]> */
		/* 821B77CCh case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 821B77CCh case    1:*/		return 0x821B77D0;
		  /* 821B77D0h */ case    2:  		/* rlwinm R6, R11, 0, 26, 31 */
		/* 821B77D0h case    2:*/		cpu::op::rlwinm<0,0,26,31>(regs,&regs.R6,regs.R11);
		/* 821B77D0h case    2:*/		return 0x821B77D4;
		  /* 821B77D4h */ case    3:  		/* or R10, R10, R11 */
		/* 821B77D4h case    3:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 821B77D4h case    3:*/		return 0x821B77D8;
		  /* 821B77D8h */ case    4:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 821B77D8h case    4:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821B77D8h case    4:*/		return 0x821B77DC;
		  /* 821B77DCh */ case    5:  		/* rlwinm R10, R10, 2, 26, 29 */
		/* 821B77DCh case    5:*/		cpu::op::rlwinm<0,2,26,29>(regs,&regs.R10,regs.R10);
		/* 821B77DCh case    5:*/		return 0x821B77E0;
		  /* 821B77E0h */ case    6:  		/* rlwinm R9, R9, 0, 27, 18 */
		/* 821B77E0h case    6:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R9,regs.R9);
		/* 821B77E0h case    6:*/		return 0x821B77E4;
		  /* 821B77E4h */ case    7:  		/* or R10, R10, R6 */
		/* 821B77E4h case    7:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R6);
		/* 821B77E4h case    7:*/		return 0x821B77E8;
		  /* 821B77E8h */ case    8:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821B77E8h case    8:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821B77E8h case    8:*/		return 0x821B77EC;
		  /* 821B77ECh */ case    9:  		/* or R11, R10, R11 */
		/* 821B77ECh case    9:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821B77ECh case    9:*/		return 0x821B77F0;
		  /* 821B77F0h */ case   10:  		/* rlwinm R11, R11, 5, 0, 26 */
		/* 821B77F0h case   10:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R11);
		/* 821B77F0h case   10:*/		return 0x821B77F4;
		  /* 821B77F4h */ case   11:  		/* or R11, R11, R9 */
		/* 821B77F4h case   11:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 821B77F4h case   11:*/		return 0x821B77F8;
		  /* 821B77F8h */ case   12:  		/* stw R11, <#[R31]> */
		/* 821B77F8h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821B77F8h case   12:*/		return 0x821B77FC;
	}
	return 0x821B77FC;
} // Block from 821B77C8h-821B77FCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 821B77FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B77FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B77FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B77FC);
		  /* 821B77FCh */ case    0:  		/* lwz R11, <#[R31]> */
		/* 821B77FCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821B77FCh case    0:*/		return 0x821B7800;
		  /* 821B7800h */ case    1:  		/* addi R7, R7, 1 */
		/* 821B7800h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 821B7800h case    1:*/		return 0x821B7804;
		  /* 821B7804h */ case    2:  		/* rlwinm R11, R11, 7, 29, 31 */
		/* 821B7804h case    2:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R11,regs.R11);
		/* 821B7804h case    2:*/		return 0x821B7808;
		  /* 821B7808h */ case    3:  		/* cmplw CR6, R7, R11 */
		/* 821B7808h case    3:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 821B7808h case    3:*/		return 0x821B780C;
		  /* 821B780Ch */ case    4:  		/* bc 12, CR6_LT, -120 */
		/* 821B780Ch case    4:*/		if ( regs.CR[6].lt ) { return 0x821B7794;  }
		/* 821B780Ch case    4:*/		return 0x821B7810;
	}
	return 0x821B7810;
} // Block from 821B77FCh-821B7810h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821B7810h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7810( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7810) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7810);
		  /* 821B7810h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 821B7810h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 821B7810h case    0:*/		return 0x821B7814;
		  /* 821B7814h */ case    1:  		/* addi R11, R11, 4 */
		/* 821B7814h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821B7814h case    1:*/		return 0x821B7818;
		  /* 821B7818h */ case    2:  		/* lwz R10, <#[R11]> */
		/* 821B7818h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821B7818h case    2:*/		return 0x821B781C;
		  /* 821B781Ch */ case    3:  		/* b 12 */
		/* 821B781Ch case    3:*/		return 0x821B7828;
		/* 821B781Ch case    3:*/		return 0x821B7820;
		  /* 821B7820h */ case    4:  		/* addi R11, R10, 8 */
		/* 821B7820h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 821B7820h case    4:*/		return 0x821B7824;
		  /* 821B7824h */ case    5:  		/* lwz R10, <#[R10 + 8]> */
		/* 821B7824h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 821B7824h case    5:*/		return 0x821B7828;
	}
	return 0x821B7828;
} // Block from 821B7810h-821B7828h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821B7828h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7828( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7828) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7828);
		  /* 821B7828h */ case    0:  		/* cmplw CR6, R10, R31 */
		/* 821B7828h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 821B7828h case    0:*/		return 0x821B782C;
		  /* 821B782Ch */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 821B782Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x821B7820;  }
		/* 821B782Ch case    1:*/		return 0x821B7830;
		  /* 821B7830h */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 821B7830h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 821B7830h case    2:*/		return 0x821B7834;
		  /* 821B7834h */ case    3:  		/* stw R10, <#[R11]> */
		/* 821B7834h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821B7834h case    3:*/		return 0x821B7838;
	}
	return 0x821B7838;
} // Block from 821B7828h-821B7838h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821B7838h
// Function '?AddAutomaticPositionExport@Compiler@D3DXShader@@AAAXPAVBlock@2@PAVInstruction@2@I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7838( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7838) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7838);
		  /* 821B7838h */ case    0:  		/* lwz R11, <#[R30 + 4]> */
		/* 821B7838h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 821B7838h case    0:*/		return 0x821B783C;
		  /* 821B783Ch */ case    1:  		/* stw R11, <#[R31 + 8]> */
		/* 821B783Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821B783Ch case    1:*/		return 0x821B7840;
		  /* 821B7840h */ case    2:  		/* stw R31, <#[R30 + 4]> */
		/* 821B7840h case    2:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000004) );
		/* 821B7840h case    2:*/		return 0x821B7844;
		  /* 821B7844h */ case    3:  		/* stw R30, <#[R31 + 12]> */
		/* 821B7844h case    3:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000000C) );
		/* 821B7844h case    3:*/		return 0x821B7848;
		  /* 821B7848h */ case    4:  		/* b 244 */
		/* 821B7848h case    4:*/		return 0x821B793C;
		/* 821B7848h case    4:*/		return 0x821B784C;
	}
	return 0x821B784C;
} // Block from 821B7838h-821B784Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 821B784Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B784C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B784C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B784C);
		  /* 821B784Ch */ case    0:  		/* mr R6, R28 */
		/* 821B784Ch case    0:*/		regs.R6 = regs.R28;
		/* 821B784Ch case    0:*/		return 0x821B7850;
		  /* 821B7850h */ case    1:  		/* li R5, 0 */
		/* 821B7850h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821B7850h case    1:*/		return 0x821B7854;
		  /* 821B7854h */ case    2:  		/* bl 447148 */
		/* 821B7854h case    2:*/		regs.LR = 0x821B7858; return 0x82224B00;
		/* 821B7854h case    2:*/		return 0x821B7858;
		  /* 821B7858h */ case    3:  		/* lwz R8, <#[R30 + 28]> */
		/* 821B7858h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x0000001C) );
		/* 821B7858h case    3:*/		return 0x821B785C;
		  /* 821B785Ch */ case    4:  		/* rlwinm R9, R3, 0, 0, 30 */
		/* 821B785Ch case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R9,regs.R3);
		/* 821B785Ch case    4:*/		return 0x821B7860;
		  /* 821B7860h */ case    5:  		/* addi R11, R30, 24 */
		/* 821B7860h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x18);
		/* 821B7860h case    5:*/		return 0x821B7864;
		  /* 821B7864h */ case    6:  		/* mr R29, R3 */
		/* 821B7864h case    6:*/		regs.R29 = regs.R3;
		/* 821B7864h case    6:*/		return 0x821B7868;
		  /* 821B7868h */ case    7:  		/* addi R10, R11, 4 */
		/* 821B7868h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 821B7868h case    7:*/		return 0x821B786C;
		  /* 821B786Ch */ case    8:  		/* addi R11, R9, 36 */
		/* 821B786Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0x24);
		/* 821B786Ch case    8:*/		return 0x821B7870;
		  /* 821B7870h */ case    9:  		/* stw R8, <#[R9 + 40]> */
		/* 821B7870h case    9:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + 0x00000028) );
		/* 821B7870h case    9:*/		return 0x821B7874;
		  /* 821B7874h */ case   10:  		/* ori R7, R10, 1 */
		/* 821B7874h case   10:*/		cpu::op::ori<0>(regs,&regs.R7,regs.R10,0x1);
		/* 821B7874h case   10:*/		return 0x821B7878;
		  /* 821B7878h */ case   11:  		/* lwz R8, <#[R30 + 28]> */
		/* 821B7878h case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x0000001C) );
		/* 821B7878h case   11:*/		return 0x821B787C;
		  /* 821B787Ch */ case   12:  		/* rlwinm R8, R8, 0, 0, 30 */
		/* 821B787Ch case   12:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R8,regs.R8);
		/* 821B787Ch case   12:*/		return 0x821B7880;
		  /* 821B7880h */ case   13:  		/* addi R10, R11, 4 */
		/* 821B7880h case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 821B7880h case   13:*/		return 0x821B7884;
		  /* 821B7884h */ case   14:  		/* addi R11, R11, -36 */
		/* 821B7884h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFDC);
		/* 821B7884h case   14:*/		return 0x821B7888;
		  /* 821B7888h */ case   15:  		/* stw R10, <#[R8 + 36]> */
		/* 821B7888h case   15:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R8 + 0x00000024) );
		/* 821B7888h case   15:*/		return 0x821B788C;
		  /* 821B788Ch */ case   16:  		/* stw R7, <#[R9 + 36]> */
		/* 821B788Ch case   16:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + 0x00000024) );
		/* 821B788Ch case   16:*/		return 0x821B7890;
		  /* 821B7890h */ case   17:  		/* stw R11, <#[R30 + 28]> */
		/* 821B7890h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 821B7890h case   17:*/		return 0x821B7894;
		  /* 821B7894h */ case   18:  		/* lwz R11, <#[R31 + 12]> */
		/* 821B7894h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 821B7894h case   18:*/		return 0x821B7898;
		  /* 821B7898h */ case   19:  		/* addi R11, R11, 4 */
		/* 821B7898h case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821B7898h case   19:*/		return 0x821B789C;
		  /* 821B789Ch */ case   20:  		/* lwz R10, <#[R11]> */
		/* 821B789Ch case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821B789Ch case   20:*/		return 0x821B78A0;
		  /* 821B78A0h */ case   21:  		/* b 12 */
		/* 821B78A0h case   21:*/		return 0x821B78AC;
		/* 821B78A0h case   21:*/		return 0x821B78A4;
		  /* 821B78A4h */ case   22:  		/* addi R11, R10, 8 */
		/* 821B78A4h case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 821B78A4h case   22:*/		return 0x821B78A8;
		  /* 821B78A8h */ case   23:  		/* lwz R10, <#[R10 + 8]> */
		/* 821B78A8h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 821B78A8h case   23:*/		return 0x821B78AC;
	}
	return 0x821B78AC;
} // Block from 821B784Ch-821B78ACh (24 instructions)

//////////////////////////////////////////////////////
// Block at 821B78ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B78AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B78AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B78AC);
		  /* 821B78ACh */ case    0:  		/* cmplw CR6, R10, R31 */
		/* 821B78ACh case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 821B78ACh case    0:*/		return 0x821B78B0;
		  /* 821B78B0h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 821B78B0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821B78A4;  }
		/* 821B78B0h case    1:*/		return 0x821B78B4;
		  /* 821B78B4h */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 821B78B4h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 821B78B4h case    2:*/		return 0x821B78B8;
		  /* 821B78B8h */ case    3:  		/* cmplwi CR6, R28, 0 */
		/* 821B78B8h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 821B78B8h case    3:*/		return 0x821B78BC;
		  /* 821B78BCh */ case    4:  		/* stw R10, <#[R11]> */
		/* 821B78BCh case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821B78BCh case    4:*/		return 0x821B78C0;
		  /* 821B78C0h */ case    5:  		/* lwz R11, <#[R29 + 4]> */
		/* 821B78C0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 821B78C0h case    5:*/		return 0x821B78C4;
		  /* 821B78C4h */ case    6:  		/* stw R11, <#[R31 + 8]> */
		/* 821B78C4h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821B78C4h case    6:*/		return 0x821B78C8;
		  /* 821B78C8h */ case    7:  		/* stw R31, <#[R29 + 4]> */
		/* 821B78C8h case    7:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R29 + 0x00000004) );
		/* 821B78C8h case    7:*/		return 0x821B78CC;
		  /* 821B78CCh */ case    8:  		/* lwz R11, <#[R31]> */
		/* 821B78CCh case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821B78CCh case    8:*/		return 0x821B78D0;
		  /* 821B78D0h */ case    9:  		/* rlwinm R24, R11, 27, 24, 31 */
		/* 821B78D0h case    9:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R24,regs.R11);
		/* 821B78D0h case    9:*/		return 0x821B78D4;
		  /* 821B78D4h */ case   10:  		/* stw R29, <#[R31 + 12]> */
		/* 821B78D4h case   10:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x0000000C) );
		/* 821B78D4h case   10:*/		return 0x821B78D8;
		  /* 821B78D8h */ case   11:  		/* bc 12, CR6_EQ, 84 */
		/* 821B78D8h case   11:*/		if ( regs.CR[6].eq ) { return 0x821B792C;  }
		/* 821B78D8h case   11:*/		return 0x821B78DC;
		  /* 821B78DCh */ case   12:  		/* li R27, 0 */
		/* 821B78DCh case   12:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 821B78DCh case   12:*/		return 0x821B78E0;
		  /* 821B78E0h */ case   13:  		/* addi R26, R29, 40 */
		/* 821B78E0h case   13:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R29,0x28);
		/* 821B78E0h case   13:*/		return 0x821B78E4;
		  /* 821B78E4h */ case   14:  		/* srw R11, R24, R27 */
		/* 821B78E4h case   14:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R24,regs.R27);
		/* 821B78E4h case   14:*/		return 0x821B78E8;
		  /* 821B78E8h */ case   15:  		/* mr R8, R23 */
		/* 821B78E8h case   15:*/		regs.R8 = regs.R23;
		/* 821B78E8h case   15:*/		return 0x821B78EC;
		  /* 821B78ECh */ case   16:  		/* mr R7, R21 */
		/* 821B78ECh case   16:*/		regs.R7 = regs.R21;
		/* 821B78ECh case   16:*/		return 0x821B78F0;
		  /* 821B78F0h */ case   17:  		/* rlwinm R6, R11, 0, 30, 31 */
		/* 821B78F0h case   17:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R6,regs.R11);
		/* 821B78F0h case   17:*/		return 0x821B78F4;
		  /* 821B78F4h */ case   18:  		/* mr R5, R22 */
		/* 821B78F4h case   18:*/		regs.R5 = regs.R22;
		/* 821B78F4h case   18:*/		return 0x821B78F8;
		  /* 821B78F8h */ case   19:  		/* mr R4, R30 */
		/* 821B78F8h case   19:*/		regs.R4 = regs.R30;
		/* 821B78F8h case   19:*/		return 0x821B78FC;
		  /* 821B78FCh */ case   20:  		/* mr R3, R25 */
		/* 821B78FCh case   20:*/		regs.R3 = regs.R25;
		/* 821B78FCh case   20:*/		return 0x821B7900;
		  /* 821B7900h */ case   21:  		/* bl -4208 */
		/* 821B7900h case   21:*/		regs.LR = 0x821B7904; return 0x821B6890;
		/* 821B7900h case   21:*/		return 0x821B7904;
		  /* 821B7904h */ case   22:  		/* mr R4, R3 */
		/* 821B7904h case   22:*/		regs.R4 = regs.R3;
		/* 821B7904h case   22:*/		return 0x821B7908;
		  /* 821B7908h */ case   23:  		/* mr R3, R25 */
		/* 821B7908h case   23:*/		regs.R3 = regs.R25;
		/* 821B7908h case   23:*/		return 0x821B790C;
		  /* 821B790Ch */ case   24:  		/* bl -260364 */
		/* 821B790Ch case   24:*/		regs.LR = 0x821B7910; return 0x82178000;
		/* 821B790Ch case   24:*/		return 0x821B7910;
		  /* 821B7910h */ case   25:  		/* mr R4, R3 */
		/* 821B7910h case   25:*/		regs.R4 = regs.R3;
		/* 821B7910h case   25:*/		return 0x821B7914;
		  /* 821B7914h */ case   26:  		/* mr R3, R29 */
		/* 821B7914h case   26:*/		regs.R3 = regs.R29;
		/* 821B7914h case   26:*/		return 0x821B7918;
		  /* 821B7918h */ case   27:  		/* bl -259920 */
		/* 821B7918h case   27:*/		regs.LR = 0x821B791C; return 0x821781C8;
		/* 821B7918h case   27:*/		return 0x821B791C;
		  /* 821B791Ch */ case   28:  		/* addic. R28, R28, -1 */
		/* 821B791Ch case   28:*/		cpu::op::addic<1>(regs,&regs.R28,regs.R28,0xFFFFFFFF);
		/* 821B791Ch case   28:*/		return 0x821B7920;
		  /* 821B7920h */ case   29:  		/* stwu R3, <#[R26 + 4]> */
		/* 821B7920h case   29:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R26 + 0x00000004) );
		regs.R26 = (uint32)(regs.R26 + 0x00000004);
		/* 821B7920h case   29:*/		return 0x821B7924;
		  /* 821B7924h */ case   30:  		/* addi R27, R27, 2 */
		/* 821B7924h case   30:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x2);
		/* 821B7924h case   30:*/		return 0x821B7928;
		  /* 821B7928h */ case   31:  		/* bc 4, CR0_EQ, -68 */
		/* 821B7928h case   31:*/		if ( !regs.CR[0].eq ) { return 0x821B78E4;  }
		/* 821B7928h case   31:*/		return 0x821B792C;
	}
	return 0x821B792C;
} // Block from 821B78ACh-821B792Ch (32 instructions)

//////////////////////////////////////////////////////
// Block at 821B792Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B792C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B792C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B792C);
		  /* 821B792Ch */ case    0:  		/* lwz R11, <#[R31]> */
		/* 821B792Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821B792Ch case    0:*/		return 0x821B7930;
		  /* 821B7930h */ case    1:  		/* li R10, 57 */
		/* 821B7930h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x39);
		/* 821B7930h case    1:*/		return 0x821B7934;
		  /* 821B7934h */ case    2:  		/* rlwimi R11, R10, 7, 19, 26 */
		/* 821B7934h case    2:*/		cpu::op::rlwimi<0,7,19,26>(regs,&regs.R11,regs.R10);
		/* 821B7934h case    2:*/		return 0x821B7938;
		  /* 821B7938h */ case    3:  		/* stw R11, <#[R31]> */
		/* 821B7938h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821B7938h case    3:*/		return 0x821B793C;
	}
	return 0x821B793C;
} // Block from 821B792Ch-821B793Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 821B793Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B793C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B793C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B793C);
		  /* 821B793Ch */ case    0:  		/* mr R3, R29 */
		/* 821B793Ch case    0:*/		regs.R3 = regs.R29;
		/* 821B793Ch case    0:*/		return 0x821B7940;
		  /* 821B7940h */ case    1:  		/* cmplwi CR6, R21, 0 */
		/* 821B7940h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000000);
		/* 821B7940h case    1:*/		return 0x821B7944;
		  /* 821B7944h */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 821B7944h case    2:*/		if ( regs.CR[6].eq ) { return 0x821B7958;  }
		/* 821B7944h case    2:*/		return 0x821B7948;
		  /* 821B7948h */ case    3:  		/* lwz R11, <#[R31]> */
		/* 821B7948h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821B7948h case    3:*/		return 0x821B794C;
		  /* 821B794Ch */ case    4:  		/* subf R10, R21, R11 */
		/* 821B794Ch case    4:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R21,regs.R11);
		/* 821B794Ch case    4:*/		return 0x821B7950;
		  /* 821B7950h */ case    5:  		/* rlwimi R10, R11, 0, 0, 26 */
		/* 821B7950h case    5:*/		cpu::op::rlwimi<0,0,0,26>(regs,&regs.R10,regs.R11);
		/* 821B7950h case    5:*/		return 0x821B7954;
		  /* 821B7954h */ case    6:  		/* stw R10, <#[R31]> */
		/* 821B7954h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 821B7954h case    6:*/		return 0x821B7958;
	}
	return 0x821B7958;
} // Block from 821B793Ch-821B7958h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821B7958h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7958( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7958) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7958);
		  /* 821B7958h */ case    0:  		/* addi R1, R1, 176 */
		/* 821B7958h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 821B7958h case    0:*/		return 0x821B795C;
		  /* 821B795Ch */ case    1:  		/* b -1205968 */
		/* 821B795Ch case    1:*/		return 0x8209128C;
		/* 821B795Ch case    1:*/		return 0x821B7960;
		  /* 821B7960h */ case    2:  		/* li R5, 0 */
		/* 821B7960h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821B7960h case    2:*/		return 0x821B7964;
		  /* 821B7964h */ case    3:  		/* b -844 */
		/* 821B7964h case    3:*/		return 0x821B7618;
		/* 821B7964h case    3:*/		return 0x821B7968;
	}
	return 0x821B7968;
} // Block from 821B7958h-821B7968h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821B7968h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7968( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7968) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7968);
		  /* 821B7968h */ case    0:  		/* mfspr R12, LR */
		/* 821B7968h case    0:*/		regs.R12 = regs.LR;
		/* 821B7968h case    0:*/		return 0x821B796C;
		  /* 821B796Ch */ case    1:  		/* bl -1206044 */
		/* 821B796Ch case    1:*/		regs.LR = 0x821B7970; return 0x82091250;
		/* 821B796Ch case    1:*/		return 0x821B7970;
		  /* 821B7970h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 821B7970h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 821B7970h case    2:*/		return 0x821B7974;
		  /* 821B7974h */ case    3:  		/* lwz R11, <#[R6]> */
		/* 821B7974h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000000) );
		/* 821B7974h case    3:*/		return 0x821B7978;
		  /* 821B7978h */ case    4:  		/* mr R28, R3 */
		/* 821B7978h case    4:*/		regs.R28 = regs.R3;
		/* 821B7978h case    4:*/		return 0x821B797C;
		  /* 821B797Ch */ case    5:  		/* mr R27, R4 */
		/* 821B797Ch case    5:*/		regs.R27 = regs.R4;
		/* 821B797Ch case    5:*/		return 0x821B7980;
		  /* 821B7980h */ case    6:  		/* mr R31, R6 */
		/* 821B7980h case    6:*/		regs.R31 = regs.R6;
		/* 821B7980h case    6:*/		return 0x821B7984;
		  /* 821B7984h */ case    7:  		/* li R26, 0 */
		/* 821B7984h case    7:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 821B7984h case    7:*/		return 0x821B7988;
		  /* 821B7988h */ case    8:  		/* rlwinm. R11, R11, 0, 27, 27 */
		/* 821B7988h case    8:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R11);
		/* 821B7988h case    8:*/		return 0x821B798C;
		  /* 821B798Ch */ case    9:  		/* bc 12, CR0_EQ, 60 */
		/* 821B798Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x821B79C8;  }
		/* 821B798Ch case    9:*/		return 0x821B7990;
		  /* 821B7990h */ case   10:  		/* rlwinm R5, R4, 0, 0, 29 */
		/* 821B7990h case   10:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R5,regs.R4);
		/* 821B7990h case   10:*/		return 0x821B7994;
		  /* 821B7994h */ case   11:  		/* lwz R4, <#[R4 + 28]> */
		/* 821B7994h case   11:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x0000001C) );
		/* 821B7994h case   11:*/		return 0x821B7998;
		  /* 821B7998h */ case   12:  		/* bl 468520 */
		/* 821B7998h case   12:*/		regs.LR = 0x821B799C; return 0x82229FC0;
		/* 821B7998h case   12:*/		return 0x821B799C;
		  /* 821B799Ch */ case   13:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821B799Ch case   13:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821B799Ch case   13:*/		return 0x821B79A0;
		  /* 821B79A0h */ case   14:  		/* bc 4, CR0_EQ, 244 */
		/* 821B79A0h case   14:*/		if ( !regs.CR[0].eq ) { return 0x821B7A94;  }
		/* 821B79A0h case   14:*/		return 0x821B79A4;
		  /* 821B79A4h */ case   15:  		/* lwz R31, <#[R31 + 12]> */
		/* 821B79A4h case   15:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x0000000C) );
		/* 821B79A4h case   15:*/		return 0x821B79A8;
		  /* 821B79A8h */ case   16:  		/* mr R3, R31 */
		/* 821B79A8h case   16:*/		regs.R3 = regs.R31;
		/* 821B79A8h case   16:*/		return 0x821B79AC;
		  /* 821B79ACh */ case   17:  		/* bl -259636 */
		/* 821B79ACh case   17:*/		regs.LR = 0x821B79B0; return 0x82178378;
		/* 821B79ACh case   17:*/		return 0x821B79B0;
		  /* 821B79B0h */ case   18:  		/* mr R3, R31 */
		/* 821B79B0h case   18:*/		regs.R3 = regs.R31;
		/* 821B79B0h case   18:*/		return 0x821B79B4;
		  /* 821B79B4h */ case   19:  		/* bl -163628 */
		/* 821B79B4h case   19:*/		regs.LR = 0x821B79B8; return 0x8218FA88;
		/* 821B79B4h case   19:*/		return 0x821B79B8;
		  /* 821B79B8h */ case   20:  		/* lwz R11, <#[R31 + 8]> */
		/* 821B79B8h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821B79B8h case   20:*/		return 0x821B79BC;
		  /* 821B79BCh */ case   21:  		/* oris R11, R11, 256 */
		/* 821B79BCh case   21:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x100);
		/* 821B79BCh case   21:*/		return 0x821B79C0;
		  /* 821B79C0h */ case   22:  		/* stw R11, <#[R31 + 8]> */
		/* 821B79C0h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821B79C0h case   22:*/		return 0x821B79C4;
		  /* 821B79C4h */ case   23:  		/* b 208 */
		/* 821B79C4h case   23:*/		return 0x821B7A94;
		/* 821B79C4h case   23:*/		return 0x821B79C8;
	}
	return 0x821B79C8;
} // Block from 821B7968h-821B79C8h (24 instructions)

//////////////////////////////////////////////////////
// Block at 821B79C8h
// Function '?FindOrCreateAllocs@Compiler@D3DXShader@@AAAPAVBlock@2@PAV32@PAPAVInstruction@2@1@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B79C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B79C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B79C8);
		  /* 821B79C8h */ case    0:  		/* lwz R11, <#[R28 + 4]> */
		/* 821B79C8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 821B79C8h case    0:*/		return 0x821B79CC;
		  /* 821B79CCh */ case    1:  		/* lwz R10, <#[R31 + 12]> */
		/* 821B79CCh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 821B79CCh case    1:*/		return 0x821B79D0;
		  /* 821B79D0h */ case    2:  		/* rlwinm R9, R11, 0, 31, 31 */
		/* 821B79D0h case    2:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R9,regs.R11);
		/* 821B79D0h case    2:*/		return 0x821B79D4;
		  /* 821B79D4h */ case    3:  		/* addic R9, R9, -1 */
		/* 821B79D4h case    3:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 821B79D4h case    3:*/		return 0x821B79D8;
		  /* 821B79D8h */ case    4:  		/* subfe R9, R9, R9 */
		/* 821B79D8h case    4:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 821B79D8h case    4:*/		return 0x821B79DC;
		  /* 821B79DCh */ case    5:  		/* lwz R10, <#[R10 + 8]> */
		/* 821B79DCh case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 821B79DCh case    5:*/		return 0x821B79E0;
		  /* 821B79E0h */ case    6:  		/* and R30, R9, R11 */
		/* 821B79E0h case    6:*/		cpu::op::and<0>(regs,&regs.R30,regs.R9,regs.R11);
		/* 821B79E0h case    6:*/		return 0x821B79E4;
		  /* 821B79E4h */ case    7:  		/* rlwinm R11, R10, 25, 25, 31 */
		/* 821B79E4h case    7:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R10);
		/* 821B79E4h case    7:*/		return 0x821B79E8;
		  /* 821B79E8h */ case    8:  		/* cmplwi CR6, R11, 125 */
		/* 821B79E8h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 821B79E8h case    8:*/		return 0x821B79EC;
		  /* 821B79ECh */ case    9:  		/* bc 12, CR6_EQ, 16 */
		/* 821B79ECh case    9:*/		if ( regs.CR[6].eq ) { return 0x821B79FC;  }
		/* 821B79ECh case    9:*/		return 0x821B79F0;
		  /* 821B79F0h */ case   10:  		/* cmplwi CR6, R11, 124 */
		/* 821B79F0h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 821B79F0h case   10:*/		return 0x821B79F4;
		  /* 821B79F4h */ case   11:  		/* li R11, 0 */
		/* 821B79F4h case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821B79F4h case   11:*/		return 0x821B79F8;
		  /* 821B79F8h */ case   12:  		/* bc 4, CR6_EQ, 8 */
		/* 821B79F8h case   12:*/		if ( !regs.CR[6].eq ) { return 0x821B7A00;  }
		/* 821B79F8h case   12:*/		return 0x821B79FC;
	}
	return 0x821B79FC;
} // Block from 821B79C8h-821B79FCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 821B79FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B79FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B79FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B79FC);
		  /* 821B79FCh */ case    0:  		/* li R11, 1 */
		/* 821B79FCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821B79FCh case    0:*/		return 0x821B7A00;
	}
	return 0x821B7A00;
} // Block from 821B79FCh-821B7A00h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B7A00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7A00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7A00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7A00);
		  /* 821B7A00h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821B7A00h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821B7A00h case    0:*/		return 0x821B7A04;
		  /* 821B7A04h */ case    1:  		/* bc 4, CR0_EQ, 8 */
		/* 821B7A04h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821B7A0C;  }
		/* 821B7A04h case    1:*/		return 0x821B7A08;
		  /* 821B7A08h */ case    2:  		/* lwz R30, <#[R27 + 28]> */
		/* 821B7A08h case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R27 + 0x0000001C) );
		/* 821B7A08h case    2:*/		return 0x821B7A0C;
	}
	return 0x821B7A0C;
} // Block from 821B7A00h-821B7A0Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 821B7A0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7A0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7A0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7A0C);
		  /* 821B7A0Ch */ case    0:  		/* lwz R11, <#[R27 + 28]> */
		/* 821B7A0Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000001C) );
		/* 821B7A0Ch case    0:*/		return 0x821B7A10;
		  /* 821B7A10h */ case    1:  		/* cmplw CR6, R11, R30 */
		/* 821B7A10h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 821B7A10h case    1:*/		return 0x821B7A14;
		  /* 821B7A14h */ case    2:  		/* bc 4, CR6_EQ, 12 */
		/* 821B7A14h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821B7A20;  }
		/* 821B7A14h case    2:*/		return 0x821B7A18;
		  /* 821B7A18h */ case    3:  		/* rlwinm R5, R27, 0, 0, 29 */
		/* 821B7A18h case    3:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R5,regs.R27);
		/* 821B7A18h case    3:*/		return 0x821B7A1C;
		  /* 821B7A1Ch */ case    4:  		/* b 16 */
		/* 821B7A1Ch case    4:*/		return 0x821B7A2C;
		/* 821B7A1Ch case    4:*/		return 0x821B7A20;
	}
	return 0x821B7A20;
} // Block from 821B7A0Ch-821B7A20h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821B7A20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7A20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7A20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7A20);
		  /* 821B7A20h */ case    0:  		/* addi R11, R30, 24 */
		/* 821B7A20h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x18);
		/* 821B7A20h case    0:*/		return 0x821B7A24;
		  /* 821B7A24h */ case    1:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821B7A24h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821B7A24h case    1:*/		return 0x821B7A28;
		  /* 821B7A28h */ case    2:  		/* ori R5, R11, 2 */
		/* 821B7A28h case    2:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R11,0x2);
		/* 821B7A28h case    2:*/		return 0x821B7A2C;
	}
	return 0x821B7A2C;
} // Block from 821B7A20h-821B7A2Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 821B7A2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7A2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7A2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7A2C);
		  /* 821B7A2Ch */ case    0:  		/* mr R6, R31 */
		/* 821B7A2Ch case    0:*/		regs.R6 = regs.R31;
		/* 821B7A2Ch case    0:*/		return 0x821B7A30;
		  /* 821B7A30h */ case    1:  		/* mr R4, R30 */
		/* 821B7A30h case    1:*/		regs.R4 = regs.R30;
		/* 821B7A30h case    1:*/		return 0x821B7A34;
		  /* 821B7A34h */ case    2:  		/* mr R3, R28 */
		/* 821B7A34h case    2:*/		regs.R3 = regs.R28;
		/* 821B7A34h case    2:*/		return 0x821B7A38;
		  /* 821B7A38h */ case    3:  		/* bl 468360 */
		/* 821B7A38h case    3:*/		regs.LR = 0x821B7A3C; return 0x82229FC0;
		/* 821B7A38h case    3:*/		return 0x821B7A3C;
		  /* 821B7A3Ch */ case    4:  		/* lwz R29, <#[R31 + 12]> */
		/* 821B7A3Ch case    4:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x0000000C) );
		/* 821B7A3Ch case    4:*/		return 0x821B7A40;
		  /* 821B7A40h */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821B7A40h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821B7A40h case    5:*/		return 0x821B7A44;
		  /* 821B7A44h */ case    6:  		/* bc 4, CR0_EQ, 32 */
		/* 821B7A44h case    6:*/		if ( !regs.CR[0].eq ) { return 0x821B7A64;  }
		/* 821B7A44h case    6:*/		return 0x821B7A48;
		  /* 821B7A48h */ case    7:  		/* mr R3, R29 */
		/* 821B7A48h case    7:*/		regs.R3 = regs.R29;
		/* 821B7A48h case    7:*/		return 0x821B7A4C;
		  /* 821B7A4Ch */ case    8:  		/* bl -259796 */
		/* 821B7A4Ch case    8:*/		regs.LR = 0x821B7A50; return 0x82178378;
		/* 821B7A4Ch case    8:*/		return 0x821B7A50;
		  /* 821B7A50h */ case    9:  		/* mr R3, R29 */
		/* 821B7A50h case    9:*/		regs.R3 = regs.R29;
		/* 821B7A50h case    9:*/		return 0x821B7A54;
		  /* 821B7A54h */ case   10:  		/* bl -163788 */
		/* 821B7A54h case   10:*/		regs.LR = 0x821B7A58; return 0x8218FA88;
		/* 821B7A54h case   10:*/		return 0x821B7A58;
		  /* 821B7A58h */ case   11:  		/* lwz R11, <#[R29 + 8]> */
		/* 821B7A58h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 821B7A58h case   11:*/		return 0x821B7A5C;
		  /* 821B7A5Ch */ case   12:  		/* oris R11, R11, 256 */
		/* 821B7A5Ch case   12:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x100);
		/* 821B7A5Ch case   12:*/		return 0x821B7A60;
		  /* 821B7A60h */ case   13:  		/* stw R11, <#[R29 + 8]> */
		/* 821B7A60h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 821B7A60h case   13:*/		return 0x821B7A64;
	}
	return 0x821B7A64;
} // Block from 821B7A2Ch-821B7A64h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821B7A64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7A64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7A64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7A64);
		  /* 821B7A64h */ case    0:  		/* lwz R11, <#[R27 + 28]> */
		/* 821B7A64h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000001C) );
		/* 821B7A64h case    0:*/		return 0x821B7A68;
		  /* 821B7A68h */ case    1:  		/* cmplw CR6, R11, R30 */
		/* 821B7A68h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 821B7A68h case    1:*/		return 0x821B7A6C;
		  /* 821B7A6Ch */ case    2:  		/* bc 12, CR6_EQ, 40 */
		/* 821B7A6Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x821B7A94;  }
		/* 821B7A6Ch case    2:*/		return 0x821B7A70;
		  /* 821B7A70h */ case    3:  		/* li R5, 1 */
		/* 821B7A70h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 821B7A70h case    3:*/		return 0x821B7A74;
		  /* 821B7A74h */ case    4:  		/* mr R4, R31 */
		/* 821B7A74h case    4:*/		regs.R4 = regs.R31;
		/* 821B7A74h case    4:*/		return 0x821B7A78;
		  /* 821B7A78h */ case    5:  		/* mr R3, R28 */
		/* 821B7A78h case    5:*/		regs.R3 = regs.R28;
		/* 821B7A78h case    5:*/		return 0x821B7A7C;
		  /* 821B7A7Ch */ case    6:  		/* bl -1124 */
		/* 821B7A7Ch case    6:*/		regs.LR = 0x821B7A80; return 0x821B7618;
		/* 821B7A7Ch case    6:*/		return 0x821B7A80;
		  /* 821B7A80h */ case    7:  		/* lwz R11, <#[R3 + 8]> */
		/* 821B7A80h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821B7A80h case    7:*/		return 0x821B7A84;
		  /* 821B7A84h */ case    8:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821B7A84h case    8:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821B7A84h case    8:*/		return 0x821B7A88;
		  /* 821B7A88h */ case    9:  		/* addi R11, R11, -14080 */
		/* 821B7A88h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFC900);
		/* 821B7A88h case    9:*/		return 0x821B7A8C;
		  /* 821B7A8Ch */ case   10:  		/* cntlzw R11, R11 */
		/* 821B7A8Ch case   10:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 821B7A8Ch case   10:*/		return 0x821B7A90;
		  /* 821B7A90h */ case   11:  		/* rlwinm R26, R11, 27, 31, 31 */
		/* 821B7A90h case   11:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R26,regs.R11);
		/* 821B7A90h case   11:*/		return 0x821B7A94;
	}
	return 0x821B7A94;
} // Block from 821B7A64h-821B7A94h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821B7A94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7A94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7A94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7A94);
		  /* 821B7A94h */ case    0:  		/* mr R3, R26 */
		/* 821B7A94h case    0:*/		regs.R3 = regs.R26;
		/* 821B7A94h case    0:*/		return 0x821B7A98;
		  /* 821B7A98h */ case    1:  		/* addi R1, R1, 144 */
		/* 821B7A98h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 821B7A98h case    1:*/		return 0x821B7A9C;
		  /* 821B7A9Ch */ case    2:  		/* b -1206268 */
		/* 821B7A9Ch case    2:*/		return 0x820912A0;
		/* 821B7A9Ch case    2:*/		return 0x821B7AA0;
	}
	return 0x821B7AA0;
} // Block from 821B7A94h-821B7AA0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821B7AA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7AA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7AA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7AA0);
		  /* 821B7AA0h */ case    0:  		/* mfspr R12, LR */
		/* 821B7AA0h case    0:*/		regs.R12 = regs.LR;
		/* 821B7AA0h case    0:*/		return 0x821B7AA4;
		  /* 821B7AA4h */ case    1:  		/* bl -1206404 */
		/* 821B7AA4h case    1:*/		regs.LR = 0x821B7AA8; return 0x82091220;
		/* 821B7AA4h case    1:*/		return 0x821B7AA8;
		  /* 821B7AA8h */ case    2:  		/* stfd FR30, <#[R1 - 168]> */
		/* 821B7AA8h case    2:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R1 + 0xFFFFFF58) );
		/* 821B7AA8h case    2:*/		return 0x821B7AAC;
		  /* 821B7AACh */ case    3:  		/* stfd FR31, <#[R1 - 160]> */
		/* 821B7AACh case    3:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 821B7AACh case    3:*/		return 0x821B7AB0;
		  /* 821B7AB0h */ case    4:  		/* stwu R1, <#[R1 - 416]> */
		/* 821B7AB0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFE60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFE60);
		/* 821B7AB0h case    4:*/		return 0x821B7AB4;
		  /* 821B7AB4h */ case    5:  		/* addi R11, R1, 84 */
		/* 821B7AB4h case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x54);
		/* 821B7AB4h case    5:*/		return 0x821B7AB8;
		  /* 821B7AB8h */ case    6:  		/* lwz R10, <#[R5 + 8]> */
		/* 821B7AB8h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000008) );
		/* 821B7AB8h case    6:*/		return 0x821B7ABC;
		  /* 821B7ABCh */ case    7:  		/* addi R9, R1, 80 */
		/* 821B7ABCh case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x50);
		/* 821B7ABCh case    7:*/		return 0x821B7AC0;
		  /* 821B7AC0h */ case    8:  		/* stw R5, <#[R1 + 452]> */
		/* 821B7AC0h case    8:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x000001C4) );
		/* 821B7AC0h case    8:*/		return 0x821B7AC4;
		  /* 821B7AC4h */ case    9:  		/* li R6, 0 */
		/* 821B7AC4h case    9:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821B7AC4h case    9:*/		return 0x821B7AC8;
		  /* 821B7AC8h */ case   10:  		/* stw R3, <#[R1 + 436]> */
		/* 821B7AC8h case   10:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x000001B4) );
		/* 821B7AC8h case   10:*/		return 0x821B7ACC;
		  /* 821B7ACCh */ case   11:  		/* rlwinm. R14, R10, 13, 29, 31 */
		/* 821B7ACCh case   11:*/		cpu::op::rlwinm<1,13,29,31>(regs,&regs.R14,regs.R10);
		/* 821B7ACCh case   11:*/		return 0x821B7AD0;
		  /* 821B7AD0h */ case   12:  		/* stw R4, <#[R1 + 444]> */
		/* 821B7AD0h case   12:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x000001BC) );
		/* 821B7AD0h case   12:*/		return 0x821B7AD4;
		  /* 821B7AD4h */ case   13:  		/* li R15, -1 */
		/* 821B7AD4h case   13:*/		cpu::op::li<0>(regs,&regs.R15,0xFFFFFFFF);
		/* 821B7AD4h case   13:*/		return 0x821B7AD8;
		  /* 821B7AD8h */ case   14:  		/* stw R6, <#[R11]> */
		/* 821B7AD8h case   14:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 821B7AD8h case   14:*/		return 0x821B7ADC;
		  /* 821B7ADCh */ case   15:  		/* mr R21, R5 */
		/* 821B7ADCh case   15:*/		regs.R21 = regs.R5;
		/* 821B7ADCh case   15:*/		return 0x821B7AE0;
		  /* 821B7AE0h */ case   16:  		/* stw R6, <#[R9]> */
		/* 821B7AE0h case   16:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R9 + 0x00000000) );
		/* 821B7AE0h case   16:*/		return 0x821B7AE4;
		  /* 821B7AE4h */ case   17:  		/* mr R17, R3 */
		/* 821B7AE4h case   17:*/		regs.R17 = regs.R3;
		/* 821B7AE4h case   17:*/		return 0x821B7AE8;
		  /* 821B7AE8h */ case   18:  		/* mr R27, R6 */
		/* 821B7AE8h case   18:*/		regs.R27 = regs.R6;
		/* 821B7AE8h case   18:*/		return 0x821B7AEC;
		  /* 821B7AECh */ case   19:  		/* mr R20, R6 */
		/* 821B7AECh case   19:*/		regs.R20 = regs.R6;
		/* 821B7AECh case   19:*/		return 0x821B7AF0;
		  /* 821B7AF0h */ case   20:  		/* stw R6, <#[R1 + 88]> */
		/* 821B7AF0h case   20:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x00000058) );
		/* 821B7AF0h case   20:*/		return 0x821B7AF4;
		  /* 821B7AF4h */ case   21:  		/* mr R19, R6 */
		/* 821B7AF4h case   21:*/		regs.R19 = regs.R6;
		/* 821B7AF4h case   21:*/		return 0x821B7AF8;
		  /* 821B7AF8h */ case   22:  		/* stw R14, <#[R1 + 104]> */
		/* 821B7AF8h case   22:*/		cpu::mem::store32( regs, regs.R14, (uint32)(regs.R1 + 0x00000068) );
		/* 821B7AF8h case   22:*/		return 0x821B7AFC;
		  /* 821B7AFCh */ case   23:  		/* mr R18, R6 */
		/* 821B7AFCh case   23:*/		regs.R18 = regs.R6;
		/* 821B7AFCh case   23:*/		return 0x821B7B00;
		  /* 821B7B00h */ case   24:  		/* mr R22, R6 */
		/* 821B7B00h case   24:*/		regs.R22 = regs.R6;
		/* 821B7B00h case   24:*/		return 0x821B7B04;
		  /* 821B7B04h */ case   25:  		/* li R30, 2 */
		/* 821B7B04h case   25:*/		cpu::op::li<0>(regs,&regs.R30,0x2);
		/* 821B7B04h case   25:*/		return 0x821B7B08;
		  /* 821B7B08h */ case   26:  		/* li R16, 3 */
		/* 821B7B08h case   26:*/		cpu::op::li<0>(regs,&regs.R16,0x3);
		/* 821B7B08h case   26:*/		return 0x821B7B0C;
		  /* 821B7B0Ch */ case   27:  		/* mr R23, R15 */
		/* 821B7B0Ch case   27:*/		regs.R23 = regs.R15;
		/* 821B7B0Ch case   27:*/		return 0x821B7B10;
		  /* 821B7B10h */ case   28:  		/* li R24, 228 */
		/* 821B7B10h case   28:*/		cpu::op::li<0>(regs,&regs.R24,0xE4);
		/* 821B7B10h case   28:*/		return 0x821B7B14;
		  /* 821B7B14h */ case   29:  		/* mr R5, R6 */
		/* 821B7B14h case   29:*/		regs.R5 = regs.R6;
		/* 821B7B14h case   29:*/		return 0x821B7B18;
		  /* 821B7B18h */ case   30:  		/* bc 12, CR0_EQ, 904 */
		/* 821B7B18h case   30:*/		if ( regs.CR[0].eq ) { return 0x821B7EA0;  }
		/* 821B7B18h case   30:*/		return 0x821B7B1C;
		  /* 821B7B1Ch */ case   31:  		/* li R4, 0 */
		/* 821B7B1Ch case   31:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 821B7B1Ch case   31:*/		return 0x821B7B20;
		  /* 821B7B20h */ case   32:  		/* li R25, 0 */
		/* 821B7B20h case   32:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 821B7B20h case   32:*/		return 0x821B7B24;
		  /* 821B7B24h */ case   33:  		/* li R31, 0 */
		/* 821B7B24h case   33:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 821B7B24h case   33:*/		return 0x821B7B28;
		  /* 821B7B28h */ case   34:  		/* addi R28, R21, 44 */
		/* 821B7B28h case   34:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R21,0x2C);
		/* 821B7B28h case   34:*/		return 0x821B7B2C;
		  /* 821B7B2Ch */ case   35:  		/* rlwinm R9, R31, 29, 3, 29 */
		/* 821B7B2Ch case   35:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R9,regs.R31);
		/* 821B7B2Ch case   35:*/		return 0x821B7B30;
		  /* 821B7B30h */ case   36:  		/* lwzx R8, <#[R4 + R28]> */
		/* 821B7B30h case   36:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R4 + regs.R28 + 0x00000000) );
		/* 821B7B30h case   36:*/		return 0x821B7B34;
		  /* 821B7B34h */ case   37:  		/* addi R10, R1, 84 */
		/* 821B7B34h case   37:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x54);
		/* 821B7B34h case   37:*/		return 0x821B7B38;
		  /* 821B7B38h */ case   38:  		/* rlwinm R30, R31, 0, 27, 31 */
		/* 821B7B38h case   38:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R30,regs.R31);
		/* 821B7B38h case   38:*/		return 0x821B7B3C;
		  /* 821B7B3Ch */ case   39:  		/* addi R26, R1, 112 */
		/* 821B7B3Ch case   39:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R1,0x70);
		/* 821B7B3Ch case   39:*/		return 0x821B7B40;
		  /* 821B7B40h */ case   40:  		/* li R11, 0 */
		/* 821B7B40h case   40:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821B7B40h case   40:*/		return 0x821B7B44;
		  /* 821B7B44h */ case   41:  		/* lwz R7, <#[R8]> */
		/* 821B7B44h case   41:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R8 + 0x00000000) );
		/* 821B7B44h case   41:*/		return 0x821B7B48;
		  /* 821B7B48h */ case   42:  		/* cmplwi CR6, R5, 0 */
		/* 821B7B48h case   42:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 821B7B48h case   42:*/		return 0x821B7B4C;
		  /* 821B7B4Ch */ case   43:  		/* lwzx R3, <#[R9 + R10]> */
		/* 821B7B4Ch case   43:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 821B7B4Ch case   43:*/		return 0x821B7B50;
		  /* 821B7B50h */ case   44:  		/* rlwinm R29, R7, 0, 27, 30 */
		/* 821B7B50h case   44:*/		cpu::op::rlwinm<0,0,27,30>(regs,&regs.R29,regs.R7);
		/* 821B7B50h case   44:*/		return 0x821B7B54;
		  /* 821B7B54h */ case   45:  		/* rlwinm R7, R7, 27, 30, 31 */
		/* 821B7B54h case   45:*/		cpu::op::rlwinm<0,27,30,31>(regs,&regs.R7,regs.R7);
		/* 821B7B54h case   45:*/		return 0x821B7B58;
		  /* 821B7B58h */ case   46:  		/* stw R3, <#[R1 + 96]> */
		/* 821B7B58h case   46:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R1 + 0x00000060) );
		/* 821B7B58h case   46:*/		return 0x821B7B5C;
		  /* 821B7B5Ch */ case   47:  		/* lwz R3, <#[R8 + 12]> */
		/* 821B7B5Ch case   47:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R8 + 0x0000000C) );
		/* 821B7B5Ch case   47:*/		return 0x821B7B60;
		  /* 821B7B60h */ case   48:  		/* slw R8, R29, R30 */
		/* 821B7B60h case   48:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R29,regs.R30);
		/* 821B7B60h case   48:*/		return 0x821B7B64;
		  /* 821B7B64h */ case   49:  		/* stwx R3, <#[R4 + R26]> */
		/* 821B7B64h case   49:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R4 + regs.R26 + 0x00000000) );
		/* 821B7B64h case   49:*/		return 0x821B7B68;
		  /* 821B7B68h */ case   50:  		/* lwz R30, <#[R1 + 96]> */
		/* 821B7B68h case   50:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000060) );
		/* 821B7B68h case   50:*/		return 0x821B7B6C;
		  /* 821B7B6Ch */ case   51:  		/* or R8, R8, R30 */
		/* 821B7B6Ch case   51:*/		cpu::op::or<0>(regs,&regs.R8,regs.R8,regs.R30);
		/* 821B7B6Ch case   51:*/		return 0x821B7B70;
		  /* 821B7B70h */ case   52:  		/* stwx R8, <#[R9 + R10]> */
		/* 821B7B70h case   52:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 821B7B70h case   52:*/		return 0x821B7B74;
		  /* 821B7B74h */ case   53:  		/* bc 12, CR6_EQ, 36 */
		/* 821B7B74h case   53:*/		if ( regs.CR[6].eq ) { return 0x821B7B98;  }
		/* 821B7B74h case   53:*/		return 0x821B7B78;
		  /* 821B7B78h */ case   54:  		/* addi R10, R1, 112 */
		/* 821B7B78h case   54:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x70);
		/* 821B7B78h case   54:*/		return 0x821B7B7C;
		  /* 821B7B7Ch */ case   55:  		/* lwz R9, <#[R10]> */
		/* 821B7B7Ch case   55:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821B7B7Ch case   55:*/		return 0x821B7B80;
		  /* 821B7B80h */ case   56:  		/* cmplw CR6, R3, R9 */
		/* 821B7B80h case   56:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R9);
		/* 821B7B80h case   56:*/		return 0x821B7B84;
		  /* 821B7B84h */ case   57:  		/* bc 12, CR6_EQ, 20 */
		/* 821B7B84h case   57:*/		if ( regs.CR[6].eq ) { return 0x821B7B98;  }
		/* 821B7B84h case   57:*/		return 0x821B7B88;
		  /* 821B7B88h */ case   58:  		/* addi R11, R11, 1 */
		/* 821B7B88h case   58:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821B7B88h case   58:*/		return 0x821B7B8C;
		  /* 821B7B8Ch */ case   59:  		/* addi R10, R10, 4 */
		/* 821B7B8Ch case   59:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821B7B8Ch case   59:*/		return 0x821B7B90;
		  /* 821B7B90h */ case   60:  		/* cmplw CR6, R11, R5 */
		/* 821B7B90h case   60:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R5);
		/* 821B7B90h case   60:*/		return 0x821B7B94;
		  /* 821B7B94h */ case   61:  		/* bc 12, CR6_LT, -24 */
		/* 821B7B94h case   61:*/		if ( regs.CR[6].lt ) { return 0x821B7B7C;  }
		/* 821B7B94h case   61:*/		return 0x821B7B98;
	}
	return 0x821B7B98;
} // Block from 821B7AA0h-821B7B98h (62 instructions)

//////////////////////////////////////////////////////
// Block at 821B7B98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7B98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7B98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7B98);
		  /* 821B7B98h */ case    0:  		/* addi R6, R6, 1 */
		/* 821B7B98h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821B7B98h case    0:*/		return 0x821B7B9C;
		  /* 821B7B9Ch */ case    1:  		/* cmplw CR6, R11, R5 */
		/* 821B7B9Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R5);
		/* 821B7B9Ch case    1:*/		return 0x821B7BA0;
		  /* 821B7BA0h */ case    2:  		/* bc 4, CR6_EQ, 48 */
		/* 821B7BA0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821B7BD0;  }
		/* 821B7BA0h case    2:*/		return 0x821B7BA4;
		  /* 821B7BA4h */ case    3:  		/* rlwinm R10, R4, 29, 3, 29 */
		/* 821B7BA4h case    3:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R10,regs.R4);
		/* 821B7BA4h case    3:*/		return 0x821B7BA8;
		  /* 821B7BA8h */ case    4:  		/* addi R11, R1, 80 */
		/* 821B7BA8h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 821B7BA8h case    4:*/		return 0x821B7BAC;
		  /* 821B7BACh */ case    5:  		/* li R9, 1 */
		/* 821B7BACh case    5:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 821B7BACh case    5:*/		return 0x821B7BB0;
		  /* 821B7BB0h */ case    6:  		/* rlwinm R8, R4, 0, 27, 31 */
		/* 821B7BB0h case    6:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R8,regs.R4);
		/* 821B7BB0h case    6:*/		return 0x821B7BB4;
		  /* 821B7BB4h */ case    7:  		/* slw R9, R9, R7 */
		/* 821B7BB4h case    7:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 821B7BB4h case    7:*/		return 0x821B7BB8;
		  /* 821B7BB8h */ case    8:  		/* lwzx R7, <#[R10 + R11]> */
		/* 821B7BB8h case    8:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821B7BB8h case    8:*/		return 0x821B7BBC;
		  /* 821B7BBCh */ case    9:  		/* slw R9, R9, R8 */
		/* 821B7BBCh case    9:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 821B7BBCh case    9:*/		return 0x821B7BC0;
		  /* 821B7BC0h */ case   10:  		/* or R9, R9, R7 */
		/* 821B7BC0h case   10:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 821B7BC0h case   10:*/		return 0x821B7BC4;
		  /* 821B7BC4h */ case   11:  		/* addi R19, R19, 1 */
		/* 821B7BC4h case   11:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R19,0x1);
		/* 821B7BC4h case   11:*/		return 0x821B7BC8;
		  /* 821B7BC8h */ case   12:  		/* stwx R9, <#[R10 + R11]> */
		/* 821B7BC8h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821B7BC8h case   12:*/		return 0x821B7BCC;
		  /* 821B7BCCh */ case   13:  		/* b 208 */
		/* 821B7BCCh case   13:*/		return 0x821B7C9C;
		/* 821B7BCCh case   13:*/		return 0x821B7BD0;
	}
	return 0x821B7BD0;
} // Block from 821B7B98h-821B7BD0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821B7BD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7BD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7BD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7BD0);
		  /* 821B7BD0h */ case    0:  		/* rlwinm R10, R11, 2, 0, 29 */
		/* 821B7BD0h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R11);
		/* 821B7BD0h case    0:*/		return 0x821B7BD4;
		  /* 821B7BD4h */ case    1:  		/* li R8, 2 */
		/* 821B7BD4h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x2);
		/* 821B7BD4h case    1:*/		return 0x821B7BD8;
		  /* 821B7BD8h */ case    2:  		/* addi R10, R10, 3 */
		/* 821B7BD8h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x3);
		/* 821B7BD8h case    2:*/		return 0x821B7BDC;
		  /* 821B7BDCh */ case    3:  		/* rlwinm R9, R11, 31, 3, 29 */
		/* 821B7BDCh case    3:*/		cpu::op::rlwinm<0,31,3,29>(regs,&regs.R9,regs.R11);
		/* 821B7BDCh case    3:*/		return 0x821B7BE0;
		  /* 821B7BE0h */ case    4:  		/* rlwinm R10, R10, 0, 27, 31 */
		/* 821B7BE0h case    4:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R10);
		/* 821B7BE0h case    4:*/		return 0x821B7BE4;
		  /* 821B7BE4h */ case    5:  		/* rlwinm R11, R11, 2, 27, 29 */
		/* 821B7BE4h case    5:*/		cpu::op::rlwinm<0,2,27,29>(regs,&regs.R11,regs.R11);
		/* 821B7BE4h case    5:*/		return 0x821B7BE8;
		  /* 821B7BE8h */ case    6:  		/* slw R8, R8, R10 */
		/* 821B7BE8h case    6:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R8,regs.R10);
		/* 821B7BE8h case    6:*/		return 0x821B7BEC;
		  /* 821B7BECh */ case    7:  		/* addi R10, R1, 80 */
		/* 821B7BECh case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 821B7BECh case    7:*/		return 0x821B7BF0;
		  /* 821B7BF0h */ case    8:  		/* addi R8, R8, -1 */
		/* 821B7BF0h case    8:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 821B7BF0h case    8:*/		return 0x821B7BF4;
		  /* 821B7BF4h */ case    9:  		/* slw R30, R15, R11 */
		/* 821B7BF4h case    9:*/		cpu::op::slw<0>(regs,&regs.R30,regs.R15,regs.R11);
		/* 821B7BF4h case    9:*/		return 0x821B7BF8;
		  /* 821B7BF8h */ case   10:  		/* lwzx R26, <#[R9 + R10]> */
		/* 821B7BF8h case   10:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 821B7BF8h case   10:*/		return 0x821B7BFC;
		  /* 821B7BFCh */ case   11:  		/* and R8, R8, R30 */
		/* 821B7BFCh case   11:*/		cpu::op::and<0>(regs,&regs.R8,regs.R8,regs.R30);
		/* 821B7BFCh case   11:*/		return 0x821B7C00;
		  /* 821B7C00h */ case   12:  		/* li R30, 1 */
		/* 821B7C00h case   12:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 821B7C00h case   12:*/		return 0x821B7C04;
		  /* 821B7C04h */ case   13:  		/* and R26, R8, R26 */
		/* 821B7C04h case   13:*/		cpu::op::and<0>(regs,&regs.R26,regs.R8,regs.R26);
		/* 821B7C04h case   13:*/		return 0x821B7C08;
		  /* 821B7C08h */ case   14:  		/* slw R8, R30, R7 */
		/* 821B7C08h case   14:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R30,regs.R7);
		/* 821B7C08h case   14:*/		return 0x821B7C0C;
		  /* 821B7C0Ch */ case   15:  		/* srw R30, R26, R11 */
		/* 821B7C0Ch case   15:*/		cpu::op::srw<0>(regs,&regs.R30,regs.R26,regs.R11);
		/* 821B7C0Ch case   15:*/		return 0x821B7C10;
		  /* 821B7C10h */ case   16:  		/* and. R30, R30, R8 */
		/* 821B7C10h case   16:*/		cpu::op::and<1>(regs,&regs.R30,regs.R30,regs.R8);
		/* 821B7C10h case   16:*/		return 0x821B7C14;
		  /* 821B7C14h */ case   17:  		/* bc 12, CR0_EQ, 120 */
		/* 821B7C14h case   17:*/		if ( regs.CR[0].eq ) { return 0x821B7C8C;  }
		/* 821B7C14h case   17:*/		return 0x821B7C18;
		  /* 821B7C18h */ case   18:  		/* li R11, 0 */
		/* 821B7C18h case   18:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821B7C18h case   18:*/		return 0x821B7C1C;
		  /* 821B7C1Ch */ case   19:  		/* cmplwi CR6, R5, 0 */
		/* 821B7C1Ch case   19:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 821B7C1Ch case   19:*/		return 0x821B7C20;
		  /* 821B7C20h */ case   20:  		/* bc 12, CR6_EQ, 124 */
		/* 821B7C20h case   20:*/		if ( regs.CR[6].eq ) { return 0x821B7C9C;  }
		/* 821B7C20h case   20:*/		return 0x821B7C24;
		  /* 821B7C24h */ case   21:  		/* addi R9, R1, 112 */
		/* 821B7C24h case   21:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x70);
		/* 821B7C24h case   21:*/		return 0x821B7C28;
		  /* 821B7C28h */ case   22:  		/* mr R10, R28 */
		/* 821B7C28h case   22:*/		regs.R10 = regs.R28;
		/* 821B7C28h case   22:*/		return 0x821B7C2C;
		  /* 821B7C2Ch */ case   23:  		/* lwz R8, <#[R9]> */
		/* 821B7C2Ch case   23:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 821B7C2Ch case   23:*/		return 0x821B7C30;
		  /* 821B7C30h */ case   24:  		/* cmplw CR6, R3, R8 */
		/* 821B7C30h case   24:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R8);
		/* 821B7C30h case   24:*/		return 0x821B7C34;
		  /* 821B7C34h */ case   25:  		/* bc 4, CR6_EQ, 36 */
		/* 821B7C34h case   25:*/		if ( !regs.CR[6].eq ) { return 0x821B7C58;  }
		/* 821B7C34h case   25:*/		return 0x821B7C38;
		  /* 821B7C38h */ case   26:  		/* lwz R8, <#[R10]> */
		/* 821B7C38h case   26:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 821B7C38h case   26:*/		return 0x821B7C3C;
		  /* 821B7C3Ch */ case   27:  		/* lwz R8, <#[R8]> */
		/* 821B7C3Ch case   27:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000000) );
		/* 821B7C3Ch case   27:*/		return 0x821B7C40;
		  /* 821B7C40h */ case   28:  		/* rlwinm R30, R8, 27, 30, 31 */
		/* 821B7C40h case   28:*/		cpu::op::rlwinm<0,27,30,31>(regs,&regs.R30,regs.R8);
		/* 821B7C40h case   28:*/		return 0x821B7C44;
		  /* 821B7C44h */ case   29:  		/* cmpw CR6, R30, R7 */
		/* 821B7C44h case   29:*/		cpu::op::cmpw<6>(regs,regs.R30,regs.R7);
		/* 821B7C44h case   29:*/		return 0x821B7C48;
		  /* 821B7C48h */ case   30:  		/* bc 4, CR6_EQ, 16 */
		/* 821B7C48h case   30:*/		if ( !regs.CR[6].eq ) { return 0x821B7C58;  }
		/* 821B7C48h case   30:*/		return 0x821B7C4C;
		  /* 821B7C4Ch */ case   31:  		/* rlwinm R8, R8, 0, 27, 30 */
		/* 821B7C4Ch case   31:*/		cpu::op::rlwinm<0,0,27,30>(regs,&regs.R8,regs.R8);
		/* 821B7C4Ch case   31:*/		return 0x821B7C50;
		  /* 821B7C50h */ case   32:  		/* cmplw CR6, R8, R29 */
		/* 821B7C50h case   32:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R29);
		/* 821B7C50h case   32:*/		return 0x821B7C54;
		  /* 821B7C54h */ case   33:  		/* bc 12, CR6_EQ, 24 */
		/* 821B7C54h case   33:*/		if ( regs.CR[6].eq ) { return 0x821B7C6C;  }
		/* 821B7C54h case   33:*/		return 0x821B7C58;
	}
	return 0x821B7C58;
} // Block from 821B7BD0h-821B7C58h (34 instructions)

//////////////////////////////////////////////////////
// Block at 821B7C58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7C58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7C58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7C58);
		  /* 821B7C58h */ case    0:  		/* addi R11, R11, 1 */
		/* 821B7C58h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821B7C58h case    0:*/		return 0x821B7C5C;
		  /* 821B7C5Ch */ case    1:  		/* addi R9, R9, 4 */
		/* 821B7C5Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 821B7C5Ch case    1:*/		return 0x821B7C60;
		  /* 821B7C60h */ case    2:  		/* addi R10, R10, 4 */
		/* 821B7C60h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821B7C60h case    2:*/		return 0x821B7C64;
		  /* 821B7C64h */ case    3:  		/* cmplw CR6, R11, R5 */
		/* 821B7C64h case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R5);
		/* 821B7C64h case    3:*/		return 0x821B7C68;
		  /* 821B7C68h */ case    4:  		/* bc 12, CR6_LT, -60 */
		/* 821B7C68h case    4:*/		if ( regs.CR[6].lt ) { return 0x821B7C2C;  }
		/* 821B7C68h case    4:*/		return 0x821B7C6C;
	}
	return 0x821B7C6C;
} // Block from 821B7C58h-821B7C6Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 821B7C6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7C6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7C6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7C6C);
		  /* 821B7C6Ch */ case    0:  		/* cmplw CR6, R11, R5 */
		/* 821B7C6Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R5);
		/* 821B7C6Ch case    0:*/		return 0x821B7C70;
		  /* 821B7C70h */ case    1:  		/* bc 4, CR6_LT, 44 */
		/* 821B7C70h case    1:*/		if ( !regs.CR[6].lt ) { return 0x821B7C9C;  }
		/* 821B7C70h case    1:*/		return 0x821B7C74;
		  /* 821B7C74h */ case    2:  		/* slw R10, R16, R25 */
		/* 821B7C74h case    2:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R16,regs.R25);
		/* 821B7C74h case    2:*/		return 0x821B7C78;
		  /* 821B7C78h */ case    3:  		/* slw R11, R11, R25 */
		/* 821B7C78h case    3:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R25);
		/* 821B7C78h case    3:*/		return 0x821B7C7C;
		  /* 821B7C7Ch */ case    4:  		/* andc R10, R24, R10 */
		/* 821B7C7Ch case    4:*/		cpu::op::andc<0>(regs,&regs.R10,regs.R24,regs.R10);
		/* 821B7C7Ch case    4:*/		return 0x821B7C80;
		  /* 821B7C80h */ case    5:  		/* addi R6, R6, -1 */
		/* 821B7C80h case    5:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0xFFFFFFFF);
		/* 821B7C80h case    5:*/		return 0x821B7C84;
		  /* 821B7C84h */ case    6:  		/* or R24, R10, R11 */
		/* 821B7C84h case    6:*/		cpu::op::or<0>(regs,&regs.R24,regs.R10,regs.R11);
		/* 821B7C84h case    6:*/		return 0x821B7C88;
		  /* 821B7C88h */ case    7:  		/* b 20 */
		/* 821B7C88h case    7:*/		return 0x821B7C9C;
		/* 821B7C88h case    7:*/		return 0x821B7C8C;
	}
	return 0x821B7C8C;
} // Block from 821B7C6Ch-821B7C8Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 821B7C8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7C8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7C8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7C8C);
		  /* 821B7C8Ch */ case    0:  		/* lwzx R7, <#[R9 + R10]> */
		/* 821B7C8Ch case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 821B7C8Ch case    0:*/		return 0x821B7C90;
		  /* 821B7C90h */ case    1:  		/* slw R11, R8, R11 */
		/* 821B7C90h case    1:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 821B7C90h case    1:*/		return 0x821B7C94;
		  /* 821B7C94h */ case    2:  		/* or R11, R11, R7 */
		/* 821B7C94h case    2:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 821B7C94h case    2:*/		return 0x821B7C98;
		  /* 821B7C98h */ case    3:  		/* stwx R11, <#[R9 + R10]> */
		/* 821B7C98h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 821B7C98h case    3:*/		return 0x821B7C9C;
	}
	return 0x821B7C9C;
} // Block from 821B7C8Ch-821B7C9Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 821B7C9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7C9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7C9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7C9C);
		  /* 821B7C9Ch */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 821B7C9Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821B7C9Ch case    0:*/		return 0x821B7CA0;
		  /* 821B7CA0h */ case    1:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821B7CA0h case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821B7CA0h case    1:*/		return 0x821B7CA4;
		  /* 821B7CA4h */ case    2:  		/* cmplwi CR6, R11, 125 */
		/* 821B7CA4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 821B7CA4h case    2:*/		return 0x821B7CA8;
		  /* 821B7CA8h */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 821B7CA8h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821B7CB4;  }
		/* 821B7CA8h case    3:*/		return 0x821B7CAC;
		  /* 821B7CACh */ case    4:  		/* addi R27, R27, 1 */
		/* 821B7CACh case    4:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 821B7CACh case    4:*/		return 0x821B7CB0;
		  /* 821B7CB0h */ case    5:  		/* b 40 */
		/* 821B7CB0h case    5:*/		return 0x821B7CD8;
		/* 821B7CB0h case    5:*/		return 0x821B7CB4;
	}
	return 0x821B7CB4;
} // Block from 821B7C9Ch-821B7CB4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821B7CB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7CB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7CB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7CB4);
		  /* 821B7CB4h */ case    0:  		/* cmplwi CR6, R11, 124 */
		/* 821B7CB4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 821B7CB4h case    0:*/		return 0x821B7CB8;
		  /* 821B7CB8h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 821B7CB8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821B7CC4;  }
		/* 821B7CB8h case    1:*/		return 0x821B7CBC;
		  /* 821B7CBCh */ case    2:  		/* addi R20, R20, 1 */
		/* 821B7CBCh case    2:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R20,0x1);
		/* 821B7CBCh case    2:*/		return 0x821B7CC0;
		  /* 821B7CC0h */ case    3:  		/* b 16 */
		/* 821B7CC0h case    3:*/		return 0x821B7CD0;
		/* 821B7CC0h case    3:*/		return 0x821B7CC4;
	}
	return 0x821B7CC4;
} // Block from 821B7CB4h-821B7CC4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821B7CC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7CC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7CC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7CC4);
		  /* 821B7CC4h */ case    0:  		/* cmplwi CR6, R11, 113 */
		/* 821B7CC4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000071);
		/* 821B7CC4h case    0:*/		return 0x821B7CC8;
		  /* 821B7CC8h */ case    1:  		/* bc 4, CR6_EQ, 8 */
		/* 821B7CC8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821B7CD0;  }
		/* 821B7CC8h case    1:*/		return 0x821B7CCC;
		  /* 821B7CCCh */ case    2:  		/* addi R18, R18, 1 */
		/* 821B7CCCh case    2:*/		cpu::op::addi<0>(regs,&regs.R18,regs.R18,0x1);
		/* 821B7CCCh case    2:*/		return 0x821B7CD0;
	}
	return 0x821B7CD0;
} // Block from 821B7CC4h-821B7CD0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821B7CD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7CD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7CD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7CD0);
		  /* 821B7CD0h */ case    0:  		/* or R22, R29, R22 */
		/* 821B7CD0h case    0:*/		cpu::op::or<0>(regs,&regs.R22,regs.R29,regs.R22);
		/* 821B7CD0h case    0:*/		return 0x821B7CD4;
		  /* 821B7CD4h */ case    1:  		/* and R23, R29, R23 */
		/* 821B7CD4h case    1:*/		cpu::op::and<0>(regs,&regs.R23,regs.R29,regs.R23);
		/* 821B7CD4h case    1:*/		return 0x821B7CD8;
	}
	return 0x821B7CD8;
} // Block from 821B7CD0h-821B7CD8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B7CD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7CD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7CD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7CD8);
		  /* 821B7CD8h */ case    0:  		/* addi R5, R5, 1 */
		/* 821B7CD8h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 821B7CD8h case    0:*/		return 0x821B7CDC;
		  /* 821B7CDCh */ case    1:  		/* addi R31, R31, 5 */
		/* 821B7CDCh case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x5);
		/* 821B7CDCh case    1:*/		return 0x821B7CE0;
		  /* 821B7CE0h */ case    2:  		/* addi R25, R25, 2 */
		/* 821B7CE0h case    2:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x2);
		/* 821B7CE0h case    2:*/		return 0x821B7CE4;
		  /* 821B7CE4h */ case    3:  		/* addi R4, R4, 4 */
		/* 821B7CE4h case    3:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x4);
		/* 821B7CE4h case    3:*/		return 0x821B7CE8;
		  /* 821B7CE8h */ case    4:  		/* cmplw CR6, R5, R14 */
		/* 821B7CE8h case    4:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R14);
		/* 821B7CE8h case    4:*/		return 0x821B7CEC;
		  /* 821B7CECh */ case    5:  		/* bc 12, CR6_LT, -448 */
		/* 821B7CECh case    5:*/		if ( regs.CR[6].lt ) { return 0x821B7B2C;  }
		/* 821B7CECh case    5:*/		return 0x821B7CF0;
		  /* 821B7CF0h */ case    6:  		/* stw R27, <#[R1 + 88]> */
		/* 821B7CF0h case    6:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000058) );
		/* 821B7CF0h case    6:*/		return 0x821B7CF4;
		  /* 821B7CF4h */ case    7:  		/* cmplwi CR6, R24, 228 */
		/* 821B7CF4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x000000E4);
		/* 821B7CF4h case    7:*/		return 0x821B7CF8;
		  /* 821B7CF8h */ case    8:  		/* bc 12, CR6_EQ, 420 */
		/* 821B7CF8h case    8:*/		if ( regs.CR[6].eq ) { return 0x821B7E9C;  }
		/* 821B7CF8h case    8:*/		return 0x821B7CFC;
		  /* 821B7CFCh */ case    9:  		/* li R5, 0 */
		/* 821B7CFCh case    9:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821B7CFCh case    9:*/		return 0x821B7D00;
		  /* 821B7D00h */ case   10:  		/* lwz R4, <#[R1 + 444]> */
		/* 821B7D00h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x000001BC) );
		/* 821B7D00h case   10:*/		return 0x821B7D04;
		  /* 821B7D04h */ case   11:  		/* mr R3, R17 */
		/* 821B7D04h case   11:*/		regs.R3 = regs.R17;
		/* 821B7D04h case   11:*/		return 0x821B7D08;
		  /* 821B7D08h */ case   12:  		/* bl 445944 */
		/* 821B7D08h case   12:*/		regs.LR = 0x821B7D0C; return 0x82224B00;
		/* 821B7D08h case   12:*/		return 0x821B7D0C;
		  /* 821B7D0Ch */ case   13:  		/* rlwinm R11, R21, 0, 0, 30 */
		/* 821B7D0Ch case   13:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R21);
		/* 821B7D0Ch case   13:*/		return 0x821B7D10;
		  /* 821B7D10h */ case   14:  		/* rlwinm R10, R3, 0, 0, 30 */
		/* 821B7D10h case   14:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R3);
		/* 821B7D10h case   14:*/		return 0x821B7D14;
		  /* 821B7D14h */ case   15:  		/* addi R11, R11, 36 */
		/* 821B7D14h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821B7D14h case   15:*/		return 0x821B7D18;
		  /* 821B7D18h */ case   16:  		/* addi R10, R10, 36 */
		/* 821B7D18h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 821B7D18h case   16:*/		return 0x821B7D1C;
		  /* 821B7D1Ch */ case   17:  		/* addi R9, R11, 4 */
		/* 821B7D1Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821B7D1Ch case   17:*/		return 0x821B7D20;
		  /* 821B7D20h */ case   18:  		/* addi R8, R10, 4 */
		/* 821B7D20h case   18:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x4);
		/* 821B7D20h case   18:*/		return 0x821B7D24;
		  /* 821B7D24h */ case   19:  		/* addi R6, R10, -36 */
		/* 821B7D24h case   19:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821B7D24h case   19:*/		return 0x821B7D28;
		  /* 821B7D28h */ case   20:  		/* lwz R7, <#[R11 + 4]> */
		/* 821B7D28h case   20:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 821B7D28h case   20:*/		return 0x821B7D2C;
		  /* 821B7D2Ch */ case   21:  		/* mr R31, R3 */
		/* 821B7D2Ch case   21:*/		regs.R31 = regs.R3;
		/* 821B7D2Ch case   21:*/		return 0x821B7D30;
		  /* 821B7D30h */ case   22:  		/* li R27, 0 */
		/* 821B7D30h case   22:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 821B7D30h case   22:*/		return 0x821B7D34;
		  /* 821B7D34h */ case   23:  		/* li R29, 0 */
		/* 821B7D34h case   23:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 821B7D34h case   23:*/		return 0x821B7D38;
		  /* 821B7D38h */ case   24:  		/* li R26, 0 */
		/* 821B7D38h case   24:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 821B7D38h case   24:*/		return 0x821B7D3C;
		  /* 821B7D3Ch */ case   25:  		/* li R30, 0 */
		/* 821B7D3Ch case   25:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 821B7D3Ch case   25:*/		return 0x821B7D40;
		  /* 821B7D40h */ case   26:  		/* stw R7, <#[R10 + 4]> */
		/* 821B7D40h case   26:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x00000004) );
		/* 821B7D40h case   26:*/		return 0x821B7D44;
		  /* 821B7D44h */ case   27:  		/* addi R25, R3, 40 */
		/* 821B7D44h case   27:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R3,0x28);
		/* 821B7D44h case   27:*/		return 0x821B7D48;
		  /* 821B7D48h */ case   28:  		/* lwz R7, <#[R11 + 4]> */
		/* 821B7D48h case   28:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 821B7D48h case   28:*/		return 0x821B7D4C;
		  /* 821B7D4Ch */ case   29:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821B7D4Ch case   29:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821B7D4Ch case   29:*/		return 0x821B7D50;
		  /* 821B7D50h */ case   30:  		/* stw R8, <#[R7 + 36]> */
		/* 821B7D50h case   30:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R7 + 0x00000024) );
		/* 821B7D50h case   30:*/		return 0x821B7D54;
		  /* 821B7D54h */ case   31:  		/* stw R9, <#[R10]> */
		/* 821B7D54h case   31:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821B7D54h case   31:*/		return 0x821B7D58;
		  /* 821B7D58h */ case   32:  		/* stw R6, <#[R11 + 4]> */
		/* 821B7D58h case   32:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821B7D58h case   32:*/		return 0x821B7D5C;
		  /* 821B7D5Ch */ case   33:  		/* srw R11, R24, R30 */
		/* 821B7D5Ch case   33:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R24,regs.R30);
		/* 821B7D5Ch case   33:*/		return 0x821B7D60;
		  /* 821B7D60h */ case   34:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 821B7D60h case   34:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 821B7D60h case   34:*/		return 0x821B7D64;
		  /* 821B7D64h */ case   35:  		/* cmpw CR6, R26, R11 */
		/* 821B7D64h case   35:*/		cpu::op::cmpw<6>(regs,regs.R26,regs.R11);
		/* 821B7D64h case   35:*/		return 0x821B7D68;
		  /* 821B7D68h */ case   36:  		/* bc 4, CR6_EQ, 40 */
		/* 821B7D68h case   36:*/		if ( !regs.CR[6].eq ) { return 0x821B7D90;  }
		/* 821B7D68h case   36:*/		return 0x821B7D6C;
		  /* 821B7D6Ch */ case   37:  		/* mr R3, R31 */
		/* 821B7D6Ch case   37:*/		regs.R3 = regs.R31;
		/* 821B7D6Ch case   37:*/		return 0x821B7D70;
		  /* 821B7D70h */ case   38:  		/* lwz R4, <#[R28]> */
		/* 821B7D70h case   38:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R28 + 0x00000000) );
		/* 821B7D70h case   38:*/		return 0x821B7D74;
		  /* 821B7D74h */ case   39:  		/* bl -261036 */
		/* 821B7D74h case   39:*/		regs.LR = 0x821B7D78; return 0x821781C8;
		/* 821B7D74h case   39:*/		return 0x821B7D78;
		  /* 821B7D78h */ case   40:  		/* slw R11, R16, R30 */
		/* 821B7D78h case   40:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R16,regs.R30);
		/* 821B7D78h case   40:*/		return 0x821B7D7C;
		  /* 821B7D7Ch */ case   41:  		/* slw R10, R29, R30 */
		/* 821B7D7Ch case   41:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R29,regs.R30);
		/* 821B7D7Ch case   41:*/		return 0x821B7D80;
		  /* 821B7D80h */ case   42:  		/* stwu R3, <#[R25 + 4]> */
		/* 821B7D80h case   42:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R25 + 0x00000004) );
		regs.R25 = (uint32)(regs.R25 + 0x00000004);
		/* 821B7D80h case   42:*/		return 0x821B7D84;
		  /* 821B7D84h */ case   43:  		/* andc R11, R27, R11 */
		/* 821B7D84h case   43:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R27,regs.R11);
		/* 821B7D84h case   43:*/		return 0x821B7D88;
		  /* 821B7D88h */ case   44:  		/* addi R29, R29, 1 */
		/* 821B7D88h case   44:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 821B7D88h case   44:*/		return 0x821B7D8C;
		  /* 821B7D8Ch */ case   45:  		/* or R27, R11, R10 */
		/* 821B7D8Ch case   45:*/		cpu::op::or<0>(regs,&regs.R27,regs.R11,regs.R10);
		/* 821B7D8Ch case   45:*/		return 0x821B7D90;
	}
	return 0x821B7D90;
} // Block from 821B7CD8h-821B7D90h (46 instructions)

//////////////////////////////////////////////////////
// Block at 821B7D90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7D90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7D90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7D90);
		  /* 821B7D90h */ case    0:  		/* addi R26, R26, 1 */
		/* 821B7D90h case    0:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x1);
		/* 821B7D90h case    0:*/		return 0x821B7D94;
		  /* 821B7D94h */ case    1:  		/* addi R28, R28, 4 */
		/* 821B7D94h case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 821B7D94h case    1:*/		return 0x821B7D98;
		  /* 821B7D98h */ case    2:  		/* addi R30, R30, 2 */
		/* 821B7D98h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x2);
		/* 821B7D98h case    2:*/		return 0x821B7D9C;
		  /* 821B7D9Ch */ case    3:  		/* cmplw CR6, R26, R14 */
		/* 821B7D9Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R26,regs.R14);
		/* 821B7D9Ch case    3:*/		return 0x821B7DA0;
		  /* 821B7DA0h */ case    4:  		/* bc 12, CR6_LT, -68 */
		/* 821B7DA0h case    4:*/		if ( regs.CR[6].lt ) { return 0x821B7D5C;  }
		/* 821B7DA0h case    4:*/		return 0x821B7DA4;
		  /* 821B7DA4h */ case    5:  		/* addi R8, R21, 4 */
		/* 821B7DA4h case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R21,0x4);
		/* 821B7DA4h case    5:*/		return 0x821B7DA8;
		  /* 821B7DA8h */ case    6:  		/* lwz R11, <#[R8]> */
		/* 821B7DA8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 821B7DA8h case    6:*/		return 0x821B7DAC;
		  /* 821B7DACh */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 821B7DACh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821B7DACh case    7:*/		return 0x821B7DB0;
		  /* 821B7DB0h */ case    8:  		/* bc 12, CR6_EQ, 208 */
		/* 821B7DB0h case    8:*/		if ( regs.CR[6].eq ) { return 0x821B7E80;  }
		/* 821B7DB0h case    8:*/		return 0x821B7DB4;
		  /* 821B7DB4h */ case    9:  		/* lwz R10, <#[R11 + 16]> */
		/* 821B7DB4h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 821B7DB4h case    9:*/		return 0x821B7DB8;
		  /* 821B7DB8h */ case   10:  		/* cmplwi CR6, R10, 0 */
		/* 821B7DB8h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821B7DB8h case   10:*/		return 0x821B7DBC;
		  /* 821B7DBCh */ case   11:  		/* bc 12, CR6_EQ, 176 */
		/* 821B7DBCh case   11:*/		if ( regs.CR[6].eq ) { return 0x821B7E6C;  }
		/* 821B7DBCh case   11:*/		return 0x821B7DC0;
		  /* 821B7DC0h */ case   12:  		/* lwz R10, <#[R11 + 12]> */
		/* 821B7DC0h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 821B7DC0h case   12:*/		return 0x821B7DC4;
		  /* 821B7DC4h */ case   13:  		/* addi R10, R10, 4 */
		/* 821B7DC4h case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821B7DC4h case   13:*/		return 0x821B7DC8;
		  /* 821B7DC8h */ case   14:  		/* lwz R9, <#[R10]> */
		/* 821B7DC8h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821B7DC8h case   14:*/		return 0x821B7DCC;
		  /* 821B7DCCh */ case   15:  		/* b 12 */
		/* 821B7DCCh case   15:*/		return 0x821B7DD8;
		/* 821B7DCCh case   15:*/		return 0x821B7DD0;
		  /* 821B7DD0h */ case   16:  		/* addi R10, R9, 8 */
		/* 821B7DD0h case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x8);
		/* 821B7DD0h case   16:*/		return 0x821B7DD4;
		  /* 821B7DD4h */ case   17:  		/* lwz R9, <#[R9 + 8]> */
		/* 821B7DD4h case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 821B7DD4h case   17:*/		return 0x821B7DD8;
	}
	return 0x821B7DD8;
} // Block from 821B7D90h-821B7DD8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821B7DD8h
// Function '?ReplaceOperands@Compiler@D3DXShader@@AAAXPAVInstruction@2@II0I@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7DD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7DD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7DD8);
		  /* 821B7DD8h */ case    0:  		/* cmplw CR6, R9, R11 */
		/* 821B7DD8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 821B7DD8h case    0:*/		return 0x821B7DDC;
		  /* 821B7DDCh */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 821B7DDCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x821B7DD0;  }
		/* 821B7DDCh case    1:*/		return 0x821B7DE0;
		  /* 821B7DE0h */ case    2:  		/* lwz R9, <#[R11 + 8]> */
		/* 821B7DE0h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 821B7DE0h case    2:*/		return 0x821B7DE4;
		  /* 821B7DE4h */ case    3:  		/* stw R9, <#[R10]> */
		/* 821B7DE4h case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821B7DE4h case    3:*/		return 0x821B7DE8;
		  /* 821B7DE8h */ case    4:  		/* lwz R10, <#[R31 + 4]> */
		/* 821B7DE8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 821B7DE8h case    4:*/		return 0x821B7DEC;
		  /* 821B7DECh */ case    5:  		/* stw R10, <#[R11 + 8]> */
		/* 821B7DECh case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821B7DECh case    5:*/		return 0x821B7DF0;
		  /* 821B7DF0h */ case    6:  		/* stw R11, <#[R31 + 4]> */
		/* 821B7DF0h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 821B7DF0h case    6:*/		return 0x821B7DF4;
		  /* 821B7DF4h */ case    7:  		/* lwz R10, <#[R11]> */
		/* 821B7DF4h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821B7DF4h case    7:*/		return 0x821B7DF8;
		  /* 821B7DF8h */ case    8:  		/* rlwinm R9, R10, 22, 29, 30 */
		/* 821B7DF8h case    8:*/		cpu::op::rlwinm<0,22,29,30>(regs,&regs.R9,regs.R10);
		/* 821B7DF8h case    8:*/		return 0x821B7DFC;
		  /* 821B7DFCh */ case    9:  		/* rlwinm R7, R10, 24, 29, 30 */
		/* 821B7DFCh case    9:*/		cpu::op::rlwinm<0,24,29,30>(regs,&regs.R7,regs.R10);
		/* 821B7DFCh case    9:*/		return 0x821B7E00;
		  /* 821B7E00h */ case   10:  		/* stw R31, <#[R11 + 12]> */
		/* 821B7E00h case   10:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x0000000C) );
		/* 821B7E00h case   10:*/		return 0x821B7E04;
		  /* 821B7E04h */ case   11:  		/* srw R9, R24, R9 */
		/* 821B7E04h case   11:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R24,regs.R9);
		/* 821B7E04h case   11:*/		return 0x821B7E08;
		  /* 821B7E08h */ case   12:  		/* srw R7, R24, R7 */
		/* 821B7E08h case   12:*/		cpu::op::srw<0>(regs,&regs.R7,regs.R24,regs.R7);
		/* 821B7E08h case   12:*/		return 0x821B7E0C;
		  /* 821B7E0Ch */ case   13:  		/* rlwimi R7, R9, 2, 28, 29 */
		/* 821B7E0Ch case   13:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R7,regs.R9);
		/* 821B7E0Ch case   13:*/		return 0x821B7E10;
		  /* 821B7E10h */ case   14:  		/* rlwinm R9, R10, 26, 29, 30 */
		/* 821B7E10h case   14:*/		cpu::op::rlwinm<0,26,29,30>(regs,&regs.R9,regs.R10);
		/* 821B7E10h case   14:*/		return 0x821B7E14;
		  /* 821B7E14h */ case   15:  		/* rlwinm R7, R7, 0, 28, 31 */
		/* 821B7E14h case   15:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R7,regs.R7);
		/* 821B7E14h case   15:*/		return 0x821B7E18;
		  /* 821B7E18h */ case   16:  		/* srw R9, R24, R9 */
		/* 821B7E18h case   16:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R24,regs.R9);
		/* 821B7E18h case   16:*/		return 0x821B7E1C;
		  /* 821B7E1Ch */ case   17:  		/* rlwinm R6, R10, 28, 29, 30 */
		/* 821B7E1Ch case   17:*/		cpu::op::rlwinm<0,28,29,30>(regs,&regs.R6,regs.R10);
		/* 821B7E1Ch case   17:*/		return 0x821B7E20;
		  /* 821B7E20h */ case   18:  		/* rlwimi R9, R7, 2, 0, 29 */
		/* 821B7E20h case   18:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R9,regs.R7);
		/* 821B7E20h case   18:*/		return 0x821B7E24;
		  /* 821B7E24h */ case   19:  		/* srw R7, R24, R6 */
		/* 821B7E24h case   19:*/		cpu::op::srw<0>(regs,&regs.R7,regs.R24,regs.R6);
		/* 821B7E24h case   19:*/		return 0x821B7E28;
		  /* 821B7E28h */ case   20:  		/* rlwimi R7, R9, 2, 0, 29 */
		/* 821B7E28h case   20:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R7,regs.R9);
		/* 821B7E28h case   20:*/		return 0x821B7E2C;
		  /* 821B7E2Ch */ case   21:  		/* rlwinm R10, R10, 0, 27, 18 */
		/* 821B7E2Ch case   21:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R10,regs.R10);
		/* 821B7E2Ch case   21:*/		return 0x821B7E30;
		  /* 821B7E30h */ case   22:  		/* rlwinm R9, R7, 27, 29, 30 */
		/* 821B7E30h case   22:*/		cpu::op::rlwinm<0,27,29,30>(regs,&regs.R9,regs.R7);
		/* 821B7E30h case   22:*/		return 0x821B7E34;
		  /* 821B7E34h */ case   23:  		/* rlwinm R6, R7, 29, 29, 30 */
		/* 821B7E34h case   23:*/		cpu::op::rlwinm<0,29,29,30>(regs,&regs.R6,regs.R7);
		/* 821B7E34h case   23:*/		return 0x821B7E38;
		  /* 821B7E38h */ case   24:  		/* srw R9, R27, R9 */
		/* 821B7E38h case   24:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R27,regs.R9);
		/* 821B7E38h case   24:*/		return 0x821B7E3C;
		  /* 821B7E3Ch */ case   25:  		/* srw R6, R27, R6 */
		/* 821B7E3Ch case   25:*/		cpu::op::srw<0>(regs,&regs.R6,regs.R27,regs.R6);
		/* 821B7E3Ch case   25:*/		return 0x821B7E40;
		  /* 821B7E40h */ case   26:  		/* rlwimi R6, R9, 2, 28, 29 */
		/* 821B7E40h case   26:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R6,regs.R9);
		/* 821B7E40h case   26:*/		return 0x821B7E44;
		  /* 821B7E44h */ case   27:  		/* rlwinm R9, R7, 31, 29, 30 */
		/* 821B7E44h case   27:*/		cpu::op::rlwinm<0,31,29,30>(regs,&regs.R9,regs.R7);
		/* 821B7E44h case   27:*/		return 0x821B7E48;
		  /* 821B7E48h */ case   28:  		/* rlwinm R7, R7, 1, 29, 30 */
		/* 821B7E48h case   28:*/		cpu::op::rlwinm<0,1,29,30>(regs,&regs.R7,regs.R7);
		/* 821B7E48h case   28:*/		return 0x821B7E4C;
		  /* 821B7E4Ch */ case   29:  		/* srw R9, R27, R9 */
		/* 821B7E4Ch case   29:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R27,regs.R9);
		/* 821B7E4Ch case   29:*/		return 0x821B7E50;
		  /* 821B7E50h */ case   30:  		/* rlwinm R6, R6, 0, 28, 31 */
		/* 821B7E50h case   30:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R6,regs.R6);
		/* 821B7E50h case   30:*/		return 0x821B7E54;
		  /* 821B7E54h */ case   31:  		/* srw R7, R27, R7 */
		/* 821B7E54h case   31:*/		cpu::op::srw<0>(regs,&regs.R7,regs.R27,regs.R7);
		/* 821B7E54h case   31:*/		return 0x821B7E58;
		  /* 821B7E58h */ case   32:  		/* rlwimi R9, R6, 2, 0, 29 */
		/* 821B7E58h case   32:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R9,regs.R6);
		/* 821B7E58h case   32:*/		return 0x821B7E5C;
		  /* 821B7E5Ch */ case   33:  		/* rlwimi R7, R9, 2, 0, 29 */
		/* 821B7E5Ch case   33:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R7,regs.R9);
		/* 821B7E5Ch case   33:*/		return 0x821B7E60;
		  /* 821B7E60h */ case   34:  		/* rlwinm R9, R7, 5, 0, 26 */
		/* 821B7E60h case   34:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R9,regs.R7);
		/* 821B7E60h case   34:*/		return 0x821B7E64;
		  /* 821B7E64h */ case   35:  		/* or R10, R9, R10 */
		/* 821B7E64h case   35:*/		cpu::op::or<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 821B7E64h case   35:*/		return 0x821B7E68;
		  /* 821B7E68h */ case   36:  		/* stw R10, <#[R11]> */
		/* 821B7E68h case   36:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821B7E68h case   36:*/		return 0x821B7E6C;
	}
	return 0x821B7E6C;
} // Block from 821B7DD8h-821B7E6Ch (37 instructions)

//////////////////////////////////////////////////////
// Block at 821B7E6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7E6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7E6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7E6C);
		  /* 821B7E6Ch */ case    0:  		/* lwz R10, <#[R8]> */
		/* 821B7E6Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 821B7E6Ch case    0:*/		return 0x821B7E70;
		  /* 821B7E70h */ case    1:  		/* cmplw CR6, R10, R11 */
		/* 821B7E70h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 821B7E70h case    1:*/		return 0x821B7E74;
		  /* 821B7E74h */ case    2:  		/* bc 4, CR6_EQ, -204 */
		/* 821B7E74h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821B7DA8;  }
		/* 821B7E74h case    2:*/		return 0x821B7E78;
		  /* 821B7E78h */ case    3:  		/* addi R8, R11, 8 */
		/* 821B7E78h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x8);
		/* 821B7E78h case    3:*/		return 0x821B7E7C;
		  /* 821B7E7Ch */ case    4:  		/* b -212 */
		/* 821B7E7Ch case    4:*/		return 0x821B7DA8;
		/* 821B7E7Ch case    4:*/		return 0x821B7E80;
	}
	return 0x821B7E80;
} // Block from 821B7E6Ch-821B7E80h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821B7E80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7E80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7E80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7E80);
		  /* 821B7E80h */ case    0:  		/* mr R4, R21 */
		/* 821B7E80h case    0:*/		regs.R4 = regs.R21;
		/* 821B7E80h case    0:*/		return 0x821B7E84;
		  /* 821B7E84h */ case    1:  		/* mr R3, R17 */
		/* 821B7E84h case    1:*/		regs.R3 = regs.R17;
		/* 821B7E84h case    1:*/		return 0x821B7E88;
	}
	return 0x821B7E88;
} // Block from 821B7E80h-821B7E88h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B7E88h
// Function '?BreakCrossBlockDependency@Compiler@D3DXShader@@AAAPAVInstruction@2@PAVDependency@2@_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7E88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7E88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7E88);
		  /* 821B7E88h */ case    0:  		/* li R6, 1 */
		/* 821B7E88h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821B7E88h case    0:*/		return 0x821B7E8C;
		  /* 821B7E8Ch */ case    1:  		/* li R5, 0 */
		/* 821B7E8Ch case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821B7E8Ch case    1:*/		return 0x821B7E90;
		  /* 821B7E90h */ case    2:  		/* bl 472376 */
		/* 821B7E90h case    2:*/		regs.LR = 0x821B7E94; return 0x8222B3C8;
		/* 821B7E90h case    2:*/		return 0x821B7E94;
		  /* 821B7E94h */ case    3:  		/* li R3, 1 */
		/* 821B7E94h case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821B7E94h case    3:*/		return 0x821B7E98;
		  /* 821B7E98h */ case    4:  		/* b 6728 */
		/* 821B7E98h case    4:*/		return 0x821B98E0;
		/* 821B7E98h case    4:*/		return 0x821B7E9C;
	}
	return 0x821B7E9C;
} // Block from 821B7E88h-821B7E9Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 821B7E9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7E9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7E9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7E9C);
		  /* 821B7E9Ch */ case    0:  		/* li R30, 2 */
		/* 821B7E9Ch case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x2);
		/* 821B7E9Ch case    0:*/		return 0x821B7EA0;
	}
	return 0x821B7EA0;
} // Block from 821B7E9Ch-821B7EA0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B7EA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7EA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7EA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7EA0);
		  /* 821B7EA0h */ case    0:  		/* addi R11, R1, 80 */
		/* 821B7EA0h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 821B7EA0h case    0:*/		return 0x821B7EA4;
		  /* 821B7EA4h */ case    1:  		/* li R4, 0 */
		/* 821B7EA4h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 821B7EA4h case    1:*/		return 0x821B7EA8;
		  /* 821B7EA8h */ case    2:  		/* rlwinm. R10, R22, 0, 27, 28 */
		/* 821B7EA8h case    2:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R10,regs.R22);
		/* 821B7EA8h case    2:*/		return 0x821B7EAC;
		  /* 821B7EACh */ case    3:  		/* li R16, 4369 */
		/* 821B7EACh case    3:*/		cpu::op::li<0>(regs,&regs.R16,0x1111);
		/* 821B7EACh case    3:*/		return 0x821B7EB0;
		  /* 821B7EB0h */ case    4:  		/* stw R4, <#[R11]> */
		/* 821B7EB0h case    4:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R11 + 0x00000000) );
		/* 821B7EB0h case    4:*/		return 0x821B7EB4;
		  /* 821B7EB4h */ case    5:  		/* mr R17, R4 */
		/* 821B7EB4h case    5:*/		regs.R17 = regs.R4;
		/* 821B7EB4h case    5:*/		return 0x821B7EB8;
		  /* 821B7EB8h */ case    6:  		/* mr R21, R4 */
		/* 821B7EB8h case    6:*/		regs.R21 = regs.R4;
		/* 821B7EB8h case    6:*/		return 0x821B7EBC;
		  /* 821B7EBCh */ case    7:  		/* bc 12, CR0_EQ, 264 */
		/* 821B7EBCh case    7:*/		if ( regs.CR[0].eq ) { return 0x821B7FC4;  }
		/* 821B7EBCh case    7:*/		return 0x821B7EC0;
		  /* 821B7EC0h */ case    8:  		/* mr R7, R4 */
		/* 821B7EC0h case    8:*/		regs.R7 = regs.R4;
		/* 821B7EC0h case    8:*/		return 0x821B7EC4;
		  /* 821B7EC4h */ case    9:  		/* cmplwi CR6, R14, 0 */
		/* 821B7EC4h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R14,0x00000000);
		/* 821B7EC4h case    9:*/		return 0x821B7EC8;
		  /* 821B7EC8h */ case   10:  		/* bc 12, CR6_EQ, 244 */
		/* 821B7EC8h case   10:*/		if ( regs.CR[6].eq ) { return 0x821B7FBC;  }
		/* 821B7EC8h case   10:*/		return 0x821B7ECC;
		  /* 821B7ECCh */ case   11:  		/* mr R5, R4 */
		/* 821B7ECCh case   11:*/		regs.R5 = regs.R4;
		/* 821B7ECCh case   11:*/		return 0x821B7ED0;
		  /* 821B7ED0h */ case   12:  		/* addi R3, R1, 112 */
		/* 821B7ED0h case   12:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x70);
		/* 821B7ED0h case   12:*/		return 0x821B7ED4;
		  /* 821B7ED4h */ case   13:  		/* lwz R11, <#[R1 + 80]> */
		/* 821B7ED4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 821B7ED4h case   13:*/		return 0x821B7ED8;
		  /* 821B7ED8h */ case   14:  		/* slw R10, R16, R7 */
		/* 821B7ED8h case   14:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R16,regs.R7);
		/* 821B7ED8h case   14:*/		return 0x821B7EDC;
		  /* 821B7EDCh */ case   15:  		/* and. R11, R10, R11 */
		/* 821B7EDCh case   15:*/		cpu::op::and<1>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821B7EDCh case   15:*/		return 0x821B7EE0;
		  /* 821B7EE0h */ case   16:  		/* bc 4, CR0_EQ, 200 */
		/* 821B7EE0h case   16:*/		if ( !regs.CR[0].eq ) { return 0x821B7FA8;  }
		/* 821B7EE0h case   16:*/		return 0x821B7EE4;
		  /* 821B7EE4h */ case   17:  		/* addi R11, R4, 4 */
		/* 821B7EE4h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x4);
		/* 821B7EE4h case   17:*/		return 0x821B7EE8;
		  /* 821B7EE8h */ case   18:  		/* addi R9, R1, 84 */
		/* 821B7EE8h case   18:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x54);
		/* 821B7EE8h case   18:*/		return 0x821B7EEC;
		  /* 821B7EECh */ case   19:  		/* rlwinm R10, R4, 29, 3, 29 */
		/* 821B7EECh case   19:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R10,regs.R4);
		/* 821B7EECh case   19:*/		return 0x821B7EF0;
		  /* 821B7EF0h */ case   20:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 821B7EF0h case   20:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 821B7EF0h case   20:*/		return 0x821B7EF4;
		  /* 821B7EF4h */ case   21:  		/* slw R11, R30, R11 */
		/* 821B7EF4h case   21:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R30,regs.R11);
		/* 821B7EF4h case   21:*/		return 0x821B7EF8;
		  /* 821B7EF8h */ case   22:  		/* lwzx R10, <#[R10 + R9]> */
		/* 821B7EF8h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 821B7EF8h case   22:*/		return 0x821B7EFC;
		  /* 821B7EFCh */ case   23:  		/* addi R11, R11, -1 */
		/* 821B7EFCh case   23:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 821B7EFCh case   23:*/		return 0x821B7F00;
		  /* 821B7F00h */ case   24:  		/* rlwinm R9, R4, 0, 27, 31 */
		/* 821B7F00h case   24:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R4);
		/* 821B7F00h case   24:*/		return 0x821B7F04;
		  /* 821B7F04h */ case   25:  		/* and R11, R11, R10 */
		/* 821B7F04h case   25:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821B7F04h case   25:*/		return 0x821B7F08;
		  /* 821B7F08h */ case   26:  		/* slw R8, R15, R9 */
		/* 821B7F08h case   26:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R15,regs.R9);
		/* 821B7F08h case   26:*/		return 0x821B7F0C;
		  /* 821B7F0Ch */ case   27:  		/* and R11, R11, R8 */
		/* 821B7F0Ch case   27:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 821B7F0Ch case   27:*/		return 0x821B7F10;
		  /* 821B7F10h */ case   28:  		/* srw R11, R11, R9 */
		/* 821B7F10h case   28:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 821B7F10h case   28:*/		return 0x821B7F14;
		  /* 821B7F14h */ case   29:  		/* rlwinm. R11, R11, 0, 27, 28 */
		/* 821B7F14h case   29:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R11,regs.R11);
		/* 821B7F14h case   29:*/		return 0x821B7F18;
		  /* 821B7F18h */ case   30:  		/* bc 12, CR0_EQ, 144 */
		/* 821B7F18h case   30:*/		if ( regs.CR[0].eq ) { return 0x821B7FA8;  }
		/* 821B7F18h case   30:*/		return 0x821B7F1C;
		  /* 821B7F1Ch */ case   31:  		/* rlwinm R9, R5, 29, 3, 29 */
		/* 821B7F1Ch case   31:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R9,regs.R5);
		/* 821B7F1Ch case   31:*/		return 0x821B7F20;
		  /* 821B7F20h */ case   32:  		/* addi R10, R1, 80 */
		/* 821B7F20h case   32:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 821B7F20h case   32:*/		return 0x821B7F24;
		  /* 821B7F24h */ case   33:  		/* li R31, 1 */
		/* 821B7F24h case   33:*/		cpu::op::li<0>(regs,&regs.R31,0x1);
		/* 821B7F24h case   33:*/		return 0x821B7F28;
		  /* 821B7F28h */ case   34:  		/* rlwinm R8, R5, 0, 27, 31 */
		/* 821B7F28h case   34:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R8,regs.R5);
		/* 821B7F28h case   34:*/		return 0x821B7F2C;
		  /* 821B7F2Ch */ case   35:  		/* slw R11, R31, R7 */
		/* 821B7F2Ch case   35:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R31,regs.R7);
		/* 821B7F2Ch case   35:*/		return 0x821B7F30;
		  /* 821B7F30h */ case   36:  		/* lwzx R6, <#[R9 + R10]> */
		/* 821B7F30h case   36:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 821B7F30h case   36:*/		return 0x821B7F34;
		  /* 821B7F34h */ case   37:  		/* slw R29, R11, R8 */
		/* 821B7F34h case   37:*/		cpu::op::slw<0>(regs,&regs.R29,regs.R11,regs.R8);
		/* 821B7F34h case   37:*/		return 0x821B7F38;
		  /* 821B7F38h */ case   38:  		/* addi R11, R7, 1 */
		/* 821B7F38h case   38:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R7,0x1);
		/* 821B7F38h case   38:*/		return 0x821B7F3C;
		  /* 821B7F3Ch */ case   39:  		/* or R6, R29, R6 */
		/* 821B7F3Ch case   39:*/		cpu::op::or<0>(regs,&regs.R6,regs.R29,regs.R6);
		/* 821B7F3Ch case   39:*/		return 0x821B7F40;
		  /* 821B7F40h */ case   40:  		/* addi R21, R21, 1 */
		/* 821B7F40h case   40:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R21,0x1);
		/* 821B7F40h case   40:*/		return 0x821B7F44;
		  /* 821B7F44h */ case   41:  		/* stwx R6, <#[R9 + R10]> */
		/* 821B7F44h case   41:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 821B7F44h case   41:*/		return 0x821B7F48;
		  /* 821B7F48h */ case   42:  		/* cmplw CR6, R11, R14 */
		/* 821B7F48h case   42:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R14);
		/* 821B7F48h case   42:*/		return 0x821B7F4C;
		  /* 821B7F4Ch */ case   43:  		/* bc 4, CR6_LT, 84 */
		/* 821B7F4Ch case   43:*/		if ( !regs.CR[6].lt ) { return 0x821B7FA0;  }
		/* 821B7F4Ch case   43:*/		return 0x821B7F50;
		  /* 821B7F50h */ case   44:  		/* subf R29, R11, R14 */
		/* 821B7F50h case   44:*/		cpu::op::subf<0>(regs,&regs.R29,regs.R11,regs.R14);
		/* 821B7F50h case   44:*/		return 0x821B7F54;
		  /* 821B7F54h */ case   45:  		/* addi R6, R3, 4 */
		/* 821B7F54h case   45:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R3,0x4);
		/* 821B7F54h case   45:*/		return 0x821B7F58;
		  /* 821B7F58h */ case   46:  		/* mtspr CTR, R29 */
		/* 821B7F58h case   46:*/		regs.CTR = regs.R29;
		/* 821B7F58h case   46:*/		return 0x821B7F5C;
		  /* 821B7F5Ch */ case   47:  		/* lwz R29, <#[R1 + 80]> */
		/* 821B7F5Ch case   47:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 821B7F5Ch case   47:*/		return 0x821B7F60;
		  /* 821B7F60h */ case   48:  		/* slw R28, R16, R11 */
		/* 821B7F60h case   48:*/		cpu::op::slw<0>(regs,&regs.R28,regs.R16,regs.R11);
		/* 821B7F60h case   48:*/		return 0x821B7F64;
		  /* 821B7F64h */ case   49:  		/* and. R29, R28, R29 */
		/* 821B7F64h case   49:*/		cpu::op::and<1>(regs,&regs.R29,regs.R28,regs.R29);
		/* 821B7F64h case   49:*/		return 0x821B7F68;
		  /* 821B7F68h */ case   50:  		/* bc 4, CR0_EQ, 44 */
		/* 821B7F68h case   50:*/		if ( !regs.CR[0].eq ) { return 0x821B7F94;  }
		/* 821B7F68h case   50:*/		return 0x821B7F6C;
		  /* 821B7F6Ch */ case   51:  		/* lwz R29, <#[R6]> */
		/* 821B7F6Ch case   51:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R6 + 0x00000000) );
		/* 821B7F6Ch case   51:*/		return 0x821B7F70;
		  /* 821B7F70h */ case   52:  		/* lwz R28, <#[R3]> */
		/* 821B7F70h case   52:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R3 + 0x00000000) );
		/* 821B7F70h case   52:*/		return 0x821B7F74;
		  /* 821B7F74h */ case   53:  		/* cmplw CR6, R28, R29 */
		/* 821B7F74h case   53:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R29);
		/* 821B7F74h case   53:*/		return 0x821B7F78;
		  /* 821B7F78h */ case   54:  		/* bc 4, CR6_EQ, 28 */
		/* 821B7F78h case   54:*/		if ( !regs.CR[6].eq ) { return 0x821B7F94;  }
		/* 821B7F78h case   54:*/		return 0x821B7F7C;
		  /* 821B7F7Ch */ case   55:  		/* slw R29, R31, R11 */
		/* 821B7F7Ch case   55:*/		cpu::op::slw<0>(regs,&regs.R29,regs.R31,regs.R11);
		/* 821B7F7Ch case   55:*/		return 0x821B7F80;
		  /* 821B7F80h */ case   56:  		/* lwzx R28, <#[R9 + R10]> */
		/* 821B7F80h case   56:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 821B7F80h case   56:*/		return 0x821B7F84;
		  /* 821B7F84h */ case   57:  		/* slw R29, R29, R8 */
		/* 821B7F84h case   57:*/		cpu::op::slw<0>(regs,&regs.R29,regs.R29,regs.R8);
		/* 821B7F84h case   57:*/		return 0x821B7F88;
		  /* 821B7F88h */ case   58:  		/* or R29, R29, R28 */
		/* 821B7F88h case   58:*/		cpu::op::or<0>(regs,&regs.R29,regs.R29,regs.R28);
		/* 821B7F88h case   58:*/		return 0x821B7F8C;
		  /* 821B7F8Ch */ case   59:  		/* addi R21, R21, 1 */
		/* 821B7F8Ch case   59:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R21,0x1);
		/* 821B7F8Ch case   59:*/		return 0x821B7F90;
		  /* 821B7F90h */ case   60:  		/* stwx R29, <#[R9 + R10]> */
		/* 821B7F90h case   60:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 821B7F90h case   60:*/		return 0x821B7F94;
	}
	return 0x821B7F94;
} // Block from 821B7EA0h-821B7F94h (61 instructions)

//////////////////////////////////////////////////////
// Block at 821B7F94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7F94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7F94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7F94);
		  /* 821B7F94h */ case    0:  		/* addi R11, R11, 1 */
		/* 821B7F94h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821B7F94h case    0:*/		return 0x821B7F98;
		  /* 821B7F98h */ case    1:  		/* addi R6, R6, 4 */
		/* 821B7F98h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x4);
		/* 821B7F98h case    1:*/		return 0x821B7F9C;
		  /* 821B7F9Ch */ case    2:  		/* bc 16, CR0_LT, -64 */
		/* 821B7F9Ch case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x821B7F5C;  }
		/* 821B7F9Ch case    2:*/		return 0x821B7FA0;
	}
	return 0x821B7FA0;
} // Block from 821B7F94h-821B7FA0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821B7FA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7FA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7FA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7FA0);
		  /* 821B7FA0h */ case    0:  		/* addi R17, R17, 1 */
		/* 821B7FA0h case    0:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R17,0x1);
		/* 821B7FA0h case    0:*/		return 0x821B7FA4;
		  /* 821B7FA4h */ case    1:  		/* addi R5, R5, 4 */
		/* 821B7FA4h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x4);
		/* 821B7FA4h case    1:*/		return 0x821B7FA8;
	}
	return 0x821B7FA8;
} // Block from 821B7FA0h-821B7FA8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B7FA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7FA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7FA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7FA8);
		  /* 821B7FA8h */ case    0:  		/* addi R7, R7, 1 */
		/* 821B7FA8h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 821B7FA8h case    0:*/		return 0x821B7FAC;
		  /* 821B7FACh */ case    1:  		/* addi R4, R4, 5 */
		/* 821B7FACh case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x5);
		/* 821B7FACh case    1:*/		return 0x821B7FB0;
		  /* 821B7FB0h */ case    2:  		/* addi R3, R3, 4 */
		/* 821B7FB0h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x4);
		/* 821B7FB0h case    2:*/		return 0x821B7FB4;
		  /* 821B7FB4h */ case    3:  		/* cmplw CR6, R7, R14 */
		/* 821B7FB4h case    3:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R14);
		/* 821B7FB4h case    3:*/		return 0x821B7FB8;
		  /* 821B7FB8h */ case    4:  		/* bc 12, CR6_LT, -228 */
		/* 821B7FB8h case    4:*/		if ( regs.CR[6].lt ) { return 0x821B7ED4;  }
		/* 821B7FB8h case    4:*/		return 0x821B7FBC;
	}
	return 0x821B7FBC;
} // Block from 821B7FA8h-821B7FBCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 821B7FBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7FBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7FBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7FBC);
		  /* 821B7FBCh */ case    0:  		/* rlwinm R22, R22, 0, 29, 26 */
		/* 821B7FBCh case    0:*/		cpu::op::rlwinm<0,0,29,26>(regs,&regs.R22,regs.R22);
		/* 821B7FBCh case    0:*/		return 0x821B7FC0;
		  /* 821B7FC0h */ case    1:  		/* rlwinm R23, R23, 0, 29, 26 */
		/* 821B7FC0h case    1:*/		cpu::op::rlwinm<0,0,29,26>(regs,&regs.R23,regs.R23);
		/* 821B7FC0h case    1:*/		return 0x821B7FC4;
	}
	return 0x821B7FC4;
} // Block from 821B7FBCh-821B7FC4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B7FC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B7FC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B7FC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B7FC4);
		  /* 821B7FC4h */ case    0:  		/* lwz R26, <#[R1 + 452]> */
		/* 821B7FC4h case    0:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x000001C4) );
		/* 821B7FC4h case    0:*/		return 0x821B7FC8;
		  /* 821B7FC8h */ case    1:  		/* cmplwi CR6, R22, 0 */
		/* 821B7FC8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 821B7FC8h case    1:*/		return 0x821B7FCC;
		  /* 821B7FCCh */ case    2:  		/* bc 12, CR6_EQ, 704 */
		/* 821B7FCCh case    2:*/		if ( regs.CR[6].eq ) { return 0x821B828C;  }
		/* 821B7FCCh case    2:*/		return 0x821B7FD0;
		  /* 821B7FD0h */ case    3:  		/* li R8, 1 */
		/* 821B7FD0h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 821B7FD0h case    3:*/		return 0x821B7FD4;
		  /* 821B7FD4h */ case    4:  		/* cmplw CR6, R22, R23 */
		/* 821B7FD4h case    4:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R23);
		/* 821B7FD4h case    4:*/		return 0x821B7FD8;
		  /* 821B7FD8h */ case    5:  		/* bc 4, CR6_EQ, 156 */
		/* 821B7FD8h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821B8074;  }
		/* 821B7FD8h case    5:*/		return 0x821B7FDC;
		  /* 821B7FDCh */ case    6:  		/* cmplwi CR6, R27, 0 */
		/* 821B7FDCh case    6:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 821B7FDCh case    6:*/		return 0x821B7FE0;
		  /* 821B7FE0h */ case    7:  		/* bc 4, CR6_EQ, 148 */
		/* 821B7FE0h case    7:*/		if ( !regs.CR[6].eq ) { return 0x821B8074;  }
		/* 821B7FE0h case    7:*/		return 0x821B7FE4;
		  /* 821B7FE4h */ case    8:  		/* lwz R9, <#[R26 + 4]> */
		/* 821B7FE4h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000004) );
		/* 821B7FE4h case    8:*/		return 0x821B7FE8;
		  /* 821B7FE8h */ case    9:  		/* cmplwi CR6, R9, 0 */
		/* 821B7FE8h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 821B7FE8h case    9:*/		return 0x821B7FEC;
		  /* 821B7FECh */ case   10:  		/* bc 12, CR6_EQ, 140 */
		/* 821B7FECh case   10:*/		if ( regs.CR[6].eq ) { return 0x821B8078;  }
		/* 821B7FECh case   10:*/		return 0x821B7FF0;
		  /* 821B7FF0h */ case   11:  		/* lwz R11, <#[R9 + 16]> */
		/* 821B7FF0h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000010) );
		/* 821B7FF0h case   11:*/		return 0x821B7FF4;
		  /* 821B7FF4h */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 821B7FF4h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821B7FF4h case   12:*/		return 0x821B7FF8;
		  /* 821B7FF8h */ case   13:  		/* bc 12, CR6_EQ, 116 */
		/* 821B7FF8h case   13:*/		if ( regs.CR[6].eq ) { return 0x821B806C;  }
		/* 821B7FF8h case   13:*/		return 0x821B7FFC;
		  /* 821B7FFCh */ case   14:  		/* lwz R10, <#[R9]> */
		/* 821B7FFCh case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 821B7FFCh case   14:*/		return 0x821B8000;
		  /* 821B8000h */ case   15:  		/* rlwinm. R11, R10, 0, 1, 1 */
		/* 821B8000h case   15:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R10);
		/* 821B8000h case   15:*/		return 0x821B8004;
		  /* 821B8004h */ case   16:  		/* bc 4, CR0_EQ, 16 */
		/* 821B8004h case   16:*/		if ( !regs.CR[0].eq ) { return 0x821B8014;  }
		/* 821B8004h case   16:*/		return 0x821B8008;
		  /* 821B8008h */ case   17:  		/* rlwinm. R11, R10, 0, 4, 6 */
		/* 821B8008h case   17:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R10);
		/* 821B8008h case   17:*/		return 0x821B800C;
		  /* 821B800Ch */ case   18:  		/* li R11, 0 */
		/* 821B800Ch case   18:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821B800Ch case   18:*/		return 0x821B8010;
		  /* 821B8010h */ case   19:  		/* bc 12, CR0_EQ, 8 */
		/* 821B8010h case   19:*/		if ( regs.CR[0].eq ) { return 0x821B8018;  }
		/* 821B8010h case   19:*/		return 0x821B8014;
	}
	return 0x821B8014;
} // Block from 821B7FC4h-821B8014h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821B8014h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8014( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8014) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8014);
		  /* 821B8014h */ case    0:  		/* li R11, 1 */
		/* 821B8014h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821B8014h case    0:*/		return 0x821B8018;
	}
	return 0x821B8018;
} // Block from 821B8014h-821B8018h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B8018h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8018( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8018) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8018);
		  /* 821B8018h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821B8018h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821B8018h case    0:*/		return 0x821B801C;
		  /* 821B801Ch */ case    1:  		/* bc 12, CR0_EQ, 80 */
		/* 821B801Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x821B806C;  }
		/* 821B801Ch case    1:*/		return 0x821B8020;
		  /* 821B8020h */ case    2:  		/* rlwinm. R7, R22, 0, 27, 28 */
		/* 821B8020h case    2:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R7,regs.R22);
		/* 821B8020h case    2:*/		return 0x821B8024;
		  /* 821B8024h */ case    3:  		/* rlwinm R11, R10, 0, 27, 31 */
		/* 821B8024h case    3:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R10);
		/* 821B8024h case    3:*/		return 0x821B8028;
		  /* 821B8028h */ case    4:  		/* bc 12, CR0_EQ, 20 */
		/* 821B8028h case    4:*/		if ( regs.CR[0].eq ) { return 0x821B803C;  }
		/* 821B8028h case    4:*/		return 0x821B802C;
		  /* 821B802Ch */ case    5:  		/* rlwinm. R10, R11, 0, 27, 28 */
		/* 821B802Ch case    5:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R10,regs.R11);
		/* 821B802Ch case    5:*/		return 0x821B8030;
		  /* 821B8030h */ case    6:  		/* bc 12, CR0_EQ, 12 */
		/* 821B8030h case    6:*/		if ( regs.CR[0].eq ) { return 0x821B803C;  }
		/* 821B8030h case    6:*/		return 0x821B8034;
		  /* 821B8034h */ case    7:  		/* li R11, 0 */
		/* 821B8034h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821B8034h case    7:*/		return 0x821B8038;
		  /* 821B8038h */ case    8:  		/* b 44 */
		/* 821B8038h case    8:*/		return 0x821B8064;
		/* 821B8038h case    8:*/		return 0x821B803C;
	}
	return 0x821B803C;
} // Block from 821B8018h-821B803Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 821B803Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B803C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B803C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B803C);
		  /* 821B803Ch */ case    0:  		/* rlwinm. R10, R22, 0, 30, 30 */
		/* 821B803Ch case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R22);
		/* 821B803Ch case    0:*/		return 0x821B8040;
		  /* 821B8040h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 821B8040h case    1:*/		if ( regs.CR[0].eq ) { return 0x821B804C;  }
		/* 821B8040h case    1:*/		return 0x821B8044;
		  /* 821B8044h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821B8044h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821B8044h case    2:*/		return 0x821B8048;
		  /* 821B8048h */ case    3:  		/* bc 4, CR0_EQ, -20 */
		/* 821B8048h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821B8034;  }
		/* 821B8048h case    3:*/		return 0x821B804C;
	}
	return 0x821B804C;
} // Block from 821B803Ch-821B804Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 821B804Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B804C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B804C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B804C);
		  /* 821B804Ch */ case    0:  		/* rlwinm. R10, R22, 0, 29, 29 */
		/* 821B804Ch case    0:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R22);
		/* 821B804Ch case    0:*/		return 0x821B8050;
		  /* 821B8050h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 821B8050h case    1:*/		if ( regs.CR[0].eq ) { return 0x821B8060;  }
		/* 821B8050h case    1:*/		return 0x821B8054;
		  /* 821B8054h */ case    2:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821B8054h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821B8054h case    2:*/		return 0x821B8058;
		  /* 821B8058h */ case    3:  		/* li R11, 0 */
		/* 821B8058h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821B8058h case    3:*/		return 0x821B805C;
		  /* 821B805Ch */ case    4:  		/* bc 4, CR0_EQ, 8 */
		/* 821B805Ch case    4:*/		if ( !regs.CR[0].eq ) { return 0x821B8064;  }
		/* 821B805Ch case    4:*/		return 0x821B8060;
	}
	return 0x821B8060;
} // Block from 821B804Ch-821B8060h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821B8060h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8060( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8060) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8060);
		  /* 821B8060h */ case    0:  		/* li R11, 1 */
		/* 821B8060h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821B8060h case    0:*/		return 0x821B8064;
	}
	return 0x821B8064;
} // Block from 821B8060h-821B8064h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B8064h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8064( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8064) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8064);
		  /* 821B8064h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821B8064h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821B8064h case    0:*/		return 0x821B8068;
		  /* 821B8068h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 821B8068h case    1:*/		if ( regs.CR[0].eq ) { return 0x821B8074;  }
		/* 821B8068h case    1:*/		return 0x821B806C;
	}
	return 0x821B806C;
} // Block from 821B8064h-821B806Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B806Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B806C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B806C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B806C);
		  /* 821B806Ch */ case    0:  		/* lwz R9, <#[R9 + 8]> */
		/* 821B806Ch case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 821B806Ch case    0:*/		return 0x821B8070;
		  /* 821B8070h */ case    1:  		/* b -136 */
		/* 821B8070h case    1:*/		return 0x821B7FE8;
		/* 821B8070h case    1:*/		return 0x821B8074;
	}
	return 0x821B8074;
} // Block from 821B806Ch-821B8074h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B8074h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8074( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8074) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8074);
		  /* 821B8074h */ case    0:  		/* li R8, 0 */
		/* 821B8074h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821B8074h case    0:*/		return 0x821B8078;
	}
	return 0x821B8078;
} // Block from 821B8074h-821B8078h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B8078h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8078( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8078) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8078);
		  /* 821B8078h */ case    0:  		/* rlwinm. R11, R8, 0, 24, 31 */
		/* 821B8078h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R8);
		/* 821B8078h case    0:*/		return 0x821B807C;
		  /* 821B807Ch */ case    1:  		/* bc 12, CR0_EQ, 204 */
		/* 821B807Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x821B8148;  }
		/* 821B807Ch case    1:*/		return 0x821B8080;
		  /* 821B8080h */ case    2:  		/* lwz R8, <#[R26 + 4]> */
		/* 821B8080h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R26 + 0x00000004) );
		/* 821B8080h case    2:*/		return 0x821B8084;
		  /* 821B8084h */ case    3:  		/* cmplwi CR6, R8, 0 */
		/* 821B8084h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 821B8084h case    3:*/		return 0x821B8088;
		  /* 821B8088h */ case    4:  		/* bc 12, CR6_EQ, 140 */
		/* 821B8088h case    4:*/		if ( regs.CR[6].eq ) { return 0x821B8114;  }
		/* 821B8088h case    4:*/		return 0x821B808C;
		  /* 821B808Ch */ case    5:  		/* lwz R11, <#[R8 + 16]> */
		/* 821B808Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000010) );
		/* 821B808Ch case    5:*/		return 0x821B8090;
		  /* 821B8090h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 821B8090h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821B8090h case    6:*/		return 0x821B8094;
		  /* 821B8094h */ case    7:  		/* bc 12, CR6_EQ, 120 */
		/* 821B8094h case    7:*/		if ( regs.CR[6].eq ) { return 0x821B810C;  }
		/* 821B8094h case    7:*/		return 0x821B8098;
		  /* 821B8098h */ case    8:  		/* lwz R9, <#[R8]> */
		/* 821B8098h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000000) );
		/* 821B8098h case    8:*/		return 0x821B809C;
		  /* 821B809Ch */ case    9:  		/* rlwinm. R11, R9, 0, 1, 1 */
		/* 821B809Ch case    9:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R9);
		/* 821B809Ch case    9:*/		return 0x821B80A0;
		  /* 821B80A0h */ case   10:  		/* bc 4, CR0_EQ, 16 */
		/* 821B80A0h case   10:*/		if ( !regs.CR[0].eq ) { return 0x821B80B0;  }
		/* 821B80A0h case   10:*/		return 0x821B80A4;
		  /* 821B80A4h */ case   11:  		/* rlwinm. R11, R9, 0, 4, 6 */
		/* 821B80A4h case   11:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R9);
		/* 821B80A4h case   11:*/		return 0x821B80A8;
		  /* 821B80A8h */ case   12:  		/* li R11, 0 */
		/* 821B80A8h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821B80A8h case   12:*/		return 0x821B80AC;
		  /* 821B80ACh */ case   13:  		/* bc 12, CR0_EQ, 8 */
		/* 821B80ACh case   13:*/		if ( regs.CR[0].eq ) { return 0x821B80B4;  }
		/* 821B80ACh case   13:*/		return 0x821B80B0;
	}
	return 0x821B80B0;
} // Block from 821B8078h-821B80B0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821B80B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B80B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B80B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B80B0);
		  /* 821B80B0h */ case    0:  		/* li R11, 1 */
		/* 821B80B0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821B80B0h case    0:*/		return 0x821B80B4;
	}
	return 0x821B80B4;
} // Block from 821B80B0h-821B80B4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B80B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B80B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B80B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B80B4);
		  /* 821B80B4h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821B80B4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821B80B4h case    0:*/		return 0x821B80B8;
		  /* 821B80B8h */ case    1:  		/* bc 12, CR0_EQ, 84 */
		/* 821B80B8h case    1:*/		if ( regs.CR[0].eq ) { return 0x821B810C;  }
		/* 821B80B8h case    1:*/		return 0x821B80BC;
		  /* 821B80BCh */ case    2:  		/* rlwinm. R7, R22, 0, 29, 29 */
		/* 821B80BCh case    2:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R7,regs.R22);
		/* 821B80BCh case    2:*/		return 0x821B80C0;
		  /* 821B80C0h */ case    3:  		/* rlwinm R11, R9, 0, 27, 31 */
		/* 821B80C0h case    3:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R9);
		/* 821B80C0h case    3:*/		return 0x821B80C4;
		  /* 821B80C4h */ case    4:  		/* mr R10, R22 */
		/* 821B80C4h case    4:*/		regs.R10 = regs.R22;
		/* 821B80C4h case    4:*/		return 0x821B80C8;
		  /* 821B80C8h */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 821B80C8h case    5:*/		if ( regs.CR[0].eq ) { return 0x821B80D8;  }
		/* 821B80C8h case    5:*/		return 0x821B80CC;
		  /* 821B80CCh */ case    6:  		/* rlwinm. R7, R11, 0, 30, 30 */
		/* 821B80CCh case    6:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R7,regs.R11);
		/* 821B80CCh case    6:*/		return 0x821B80D0;
		  /* 821B80D0h */ case    7:  		/* bc 12, CR0_EQ, 8 */
		/* 821B80D0h case    7:*/		if ( regs.CR[0].eq ) { return 0x821B80D8;  }
		/* 821B80D0h case    7:*/		return 0x821B80D4;
		  /* 821B80D4h */ case    8:  		/* addi R10, R22, -4 */
		/* 821B80D4h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R22,0xFFFFFFFC);
		/* 821B80D4h case    8:*/		return 0x821B80D8;
	}
	return 0x821B80D8;
} // Block from 821B80B4h-821B80D8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821B80D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B80D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B80D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B80D8);
		  /* 821B80D8h */ case    0:  		/* and R7, R10, R11 */
		/* 821B80D8h case    0:*/		cpu::op::and<0>(regs,&regs.R7,regs.R10,regs.R11);
		/* 821B80D8h case    0:*/		return 0x821B80DC;
		  /* 821B80DCh */ case    1:  		/* rlwinm. R7, R7, 0, 29, 29 */
		/* 821B80DCh case    1:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R7,regs.R7);
		/* 821B80DCh case    1:*/		return 0x821B80E0;
		  /* 821B80E0h */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 821B80E0h case    2:*/		if ( regs.CR[0].eq ) { return 0x821B80EC;  }
		/* 821B80E0h case    2:*/		return 0x821B80E4;
		  /* 821B80E4h */ case    3:  		/* addi R10, R10, -4 */
		/* 821B80E4h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFC);
		/* 821B80E4h case    3:*/		return 0x821B80E8;
		  /* 821B80E8h */ case    4:  		/* addi R11, R11, -4 */
		/* 821B80E8h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 821B80E8h case    4:*/		return 0x821B80EC;
	}
	return 0x821B80EC;
} // Block from 821B80D8h-821B80ECh (5 instructions)

//////////////////////////////////////////////////////
// Block at 821B80ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B80EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B80EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B80EC);
		  /* 821B80ECh */ case    0:  		/* rlwinm. R7, R10, 0, 31, 31 */
		/* 821B80ECh case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R7,regs.R10);
		/* 821B80ECh case    0:*/		return 0x821B80F0;
		  /* 821B80F0h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 821B80F0h case    1:*/		if ( regs.CR[0].eq ) { return 0x821B8100;  }
		/* 821B80F0h case    1:*/		return 0x821B80F4;
		  /* 821B80F4h */ case    2:  		/* rlwinm. R7, R11, 0, 30, 30 */
		/* 821B80F4h case    2:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R7,regs.R11);
		/* 821B80F4h case    2:*/		return 0x821B80F8;
		  /* 821B80F8h */ case    3:  		/* bc 12, CR0_EQ, 8 */
		/* 821B80F8h case    3:*/		if ( regs.CR[0].eq ) { return 0x821B8100;  }
		/* 821B80F8h case    3:*/		return 0x821B80FC;
		  /* 821B80FCh */ case    4:  		/* addi R11, R11, -2 */
		/* 821B80FCh case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFE);
		/* 821B80FCh case    4:*/		return 0x821B8100;
	}
	return 0x821B8100;
} // Block from 821B80ECh-821B8100h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821B8100h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8100( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8100) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8100);
		  /* 821B8100h */ case    0:  		/* or R11, R10, R11 */
		/* 821B8100h case    0:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821B8100h case    0:*/		return 0x821B8104;
		  /* 821B8104h */ case    1:  		/* rlwimi R11, R9, 0, 0, 26 */
		/* 821B8104h case    1:*/		cpu::op::rlwimi<0,0,0,26>(regs,&regs.R11,regs.R9);
		/* 821B8104h case    1:*/		return 0x821B8108;
		  /* 821B8108h */ case    2:  		/* stw R11, <#[R8]> */
		/* 821B8108h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 821B8108h case    2:*/		return 0x821B810C;
	}
	return 0x821B810C;
} // Block from 821B8100h-821B810Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 821B810Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B810C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B810C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B810C);
		  /* 821B810Ch */ case    0:  		/* lwz R8, <#[R8 + 8]> */
		/* 821B810Ch case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000008) );
		/* 821B810Ch case    0:*/		return 0x821B8110;
		  /* 821B8110h */ case    1:  		/* b -140 */
		/* 821B8110h case    1:*/		return 0x821B8084;
		/* 821B8110h case    1:*/		return 0x821B8114;
	}
	return 0x821B8114;
} // Block from 821B810Ch-821B8114h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B8114h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8114( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8114) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8114);
		  /* 821B8114h */ case    0:  		/* li R11, 0 */
		/* 821B8114h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821B8114h case    0:*/		return 0x821B8118;
		  /* 821B8118h */ case    1:  		/* addi R9, R26, 40 */
		/* 821B8118h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R26,0x28);
		/* 821B8118h case    1:*/		return 0x821B811C;
		  /* 821B811Ch */ case    2:  		/* lwz R10, <#[R26 + 8]> */
		/* 821B811Ch case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000008) );
		/* 821B811Ch case    2:*/		return 0x821B8120;
		  /* 821B8120h */ case    3:  		/* rlwinm R10, R10, 13, 29, 31 */
		/* 821B8120h case    3:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R10,regs.R10);
		/* 821B8120h case    3:*/		return 0x821B8124;
		  /* 821B8124h */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 821B8124h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821B8124h case    4:*/		return 0x821B8128;
		  /* 821B8128h */ case    5:  		/* bc 4, CR6_LT, 356 */
		/* 821B8128h case    5:*/		if ( !regs.CR[6].lt ) { return 0x821B828C;  }
		/* 821B8128h case    5:*/		return 0x821B812C;
		  /* 821B812Ch */ case    6:  		/* lwzu R10, <#[R9 + 4]> */
		/* 821B812Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 821B812Ch case    6:*/		return 0x821B8130;
		  /* 821B8130h */ case    7:  		/* addi R11, R11, 1 */
		/* 821B8130h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821B8130h case    7:*/		return 0x821B8134;
		  /* 821B8134h */ case    8:  		/* lwz R8, <#[R10]> */
		/* 821B8134h case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 821B8134h case    8:*/		return 0x821B8138;
		  /* 821B8138h */ case    9:  		/* subf R7, R22, R8 */
		/* 821B8138h case    9:*/		cpu::op::subf<0>(regs,&regs.R7,regs.R22,regs.R8);
		/* 821B8138h case    9:*/		return 0x821B813C;
		  /* 821B813Ch */ case   10:  		/* rlwimi R7, R8, 0, 0, 26 */
		/* 821B813Ch case   10:*/		cpu::op::rlwimi<0,0,0,26>(regs,&regs.R7,regs.R8);
		/* 821B813Ch case   10:*/		return 0x821B8140;
		  /* 821B8140h */ case   11:  		/* stw R7, <#[R10]> */
		/* 821B8140h case   11:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821B8140h case   11:*/		return 0x821B8144;
		  /* 821B8144h */ case   12:  		/* b -40 */
		/* 821B8144h case   12:*/		return 0x821B811C;
		/* 821B8144h case   12:*/		return 0x821B8148;
	}
	return 0x821B8148;
} // Block from 821B8114h-821B8148h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821B8148h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8148( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8148) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8148);
		  /* 821B8148h */ case    0:  		/* li R4, 0 */
		/* 821B8148h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 821B8148h case    0:*/		return 0x821B814C;
		  /* 821B814Ch */ case    1:  		/* cmplwi CR6, R14, 0 */
		/* 821B814Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R14,0x00000000);
		/* 821B814Ch case    1:*/		return 0x821B8150;
		  /* 821B8150h */ case    2:  		/* bc 12, CR6_EQ, 316 */
		/* 821B8150h case    2:*/		if ( regs.CR[6].eq ) { return 0x821B828C;  }
		/* 821B8150h case    2:*/		return 0x821B8154;
		  /* 821B8154h */ case    3:  		/* rlwinm R31, R17, 2, 0, 29 */
		/* 821B8154h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R31,regs.R17);
		/* 821B8154h case    3:*/		return 0x821B8158;
		  /* 821B8158h */ case    4:  		/* li R3, 0 */
		/* 821B8158h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821B8158h case    4:*/		return 0x821B815C;
		  /* 821B815Ch */ case    5:  		/* addi R28, R1, 112 */
		/* 821B815Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R1,0x70);
		/* 821B815Ch case    5:*/		return 0x821B8160;
		  /* 821B8160h */ case    6:  		/* li R25, 1 */
		/* 821B8160h case    6:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 821B8160h case    6:*/		return 0x821B8164;
		  /* 821B8164h */ case    7:  		/* lwz R11, <#[R1 + 80]> */
		/* 821B8164h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 821B8164h case    7:*/		return 0x821B8168;
		  /* 821B8168h */ case    8:  		/* slw R10, R16, R4 */
		/* 821B8168h case    8:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R16,regs.R4);
		/* 821B8168h case    8:*/		return 0x821B816C;
		  /* 821B816Ch */ case    9:  		/* and. R11, R10, R11 */
		/* 821B816Ch case    9:*/		cpu::op::and<1>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821B816Ch case    9:*/		return 0x821B8170;
		  /* 821B8170h */ case   10:  		/* bc 4, CR0_EQ, 264 */
		/* 821B8170h case   10:*/		if ( !regs.CR[0].eq ) { return 0x821B8278;  }
		/* 821B8170h case   10:*/		return 0x821B8174;
		  /* 821B8174h */ case   11:  		/* addi R7, R3, 5 */
		/* 821B8174h case   11:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R3,0x5);
		/* 821B8174h case   11:*/		return 0x821B8178;
		  /* 821B8178h */ case   12:  		/* addi R9, R1, 84 */
		/* 821B8178h case   12:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x54);
		/* 821B8178h case   12:*/		return 0x821B817C;
		  /* 821B817Ch */ case   13:  		/* addi R11, R7, -1 */
		/* 821B817Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R7,0xFFFFFFFF);
		/* 821B817Ch case   13:*/		return 0x821B8180;
		  /* 821B8180h */ case   14:  		/* rlwinm R10, R3, 29, 3, 29 */
		/* 821B8180h case   14:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R10,regs.R3);
		/* 821B8180h case   14:*/		return 0x821B8184;
		  /* 821B8184h */ case   15:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 821B8184h case   15:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 821B8184h case   15:*/		return 0x821B8188;
		  /* 821B8188h */ case   16:  		/* rlwinm R8, R3, 0, 27, 31 */
		/* 821B8188h case   16:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R8,regs.R3);
		/* 821B8188h case   16:*/		return 0x821B818C;
		  /* 821B818Ch */ case   17:  		/* slw R11, R30, R11 */
		/* 821B818Ch case   17:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R30,regs.R11);
		/* 821B818Ch case   17:*/		return 0x821B8190;
		  /* 821B8190h */ case   18:  		/* lwzx R10, <#[R10 + R9]> */
		/* 821B8190h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 821B8190h case   18:*/		return 0x821B8194;
		  /* 821B8194h */ case   19:  		/* addi R11, R11, -1 */
		/* 821B8194h case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 821B8194h case   19:*/		return 0x821B8198;
		  /* 821B8198h */ case   20:  		/* slw R9, R15, R8 */
		/* 821B8198h case   20:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R15,regs.R8);
		/* 821B8198h case   20:*/		return 0x821B819C;
		  /* 821B819Ch */ case   21:  		/* and R11, R11, R10 */
		/* 821B819Ch case   21:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821B819Ch case   21:*/		return 0x821B81A0;
		  /* 821B81A0h */ case   22:  		/* and R11, R11, R9 */
		/* 821B81A0h case   22:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 821B81A0h case   22:*/		return 0x821B81A4;
		  /* 821B81A4h */ case   23:  		/* srw. R29, R11, R8 */
		/* 821B81A4h case   23:*/		cpu::op::srw<1>(regs,&regs.R29,regs.R11,regs.R8);
		/* 821B81A4h case   23:*/		return 0x821B81A8;
		  /* 821B81A8h */ case   24:  		/* bc 12, CR0_EQ, 208 */
		/* 821B81A8h case   24:*/		if ( regs.CR[0].eq ) { return 0x821B8278;  }
		/* 821B81A8h case   24:*/		return 0x821B81AC;
		  /* 821B81ACh */ case   25:  		/* rlwinm R9, R31, 29, 3, 29 */
		/* 821B81ACh case   25:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R9,regs.R31);
		/* 821B81ACh case   25:*/		return 0x821B81B0;
		  /* 821B81B0h */ case   26:  		/* addi R10, R1, 80 */
		/* 821B81B0h case   26:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 821B81B0h case   26:*/		return 0x821B81B4;
		  /* 821B81B4h */ case   27:  		/* slw R11, R25, R4 */
		/* 821B81B4h case   27:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R25,regs.R4);
		/* 821B81B4h case   27:*/		return 0x821B81B8;
		  /* 821B81B8h */ case   28:  		/* rlwinm R6, R31, 0, 27, 31 */
		/* 821B81B8h case   28:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R6,regs.R31);
		/* 821B81B8h case   28:*/		return 0x821B81BC;
		  /* 821B81BCh */ case   29:  		/* lwzx R8, <#[R9 + R10]> */
		/* 821B81BCh case   29:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 821B81BCh case   29:*/		return 0x821B81C0;
		  /* 821B81C0h */ case   30:  		/* addi R21, R21, 1 */
		/* 821B81C0h case   30:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R21,0x1);
		/* 821B81C0h case   30:*/		return 0x821B81C4;
		  /* 821B81C4h */ case   31:  		/* slw R5, R11, R6 */
		/* 821B81C4h case   31:*/		cpu::op::slw<0>(regs,&regs.R5,regs.R11,regs.R6);
		/* 821B81C4h case   31:*/		return 0x821B81C8;
		  /* 821B81C8h */ case   32:  		/* or R8, R5, R8 */
		/* 821B81C8h case   32:*/		cpu::op::or<0>(regs,&regs.R8,regs.R5,regs.R8);
		/* 821B81C8h case   32:*/		return 0x821B81CC;
		  /* 821B81CCh */ case   33:  		/* addi R11, R4, 1 */
		/* 821B81CCh case   33:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x1);
		/* 821B81CCh case   33:*/		return 0x821B81D0;
	}
	return 0x821B81D0;
} // Block from 821B8148h-821B81D0h (34 instructions)

//////////////////////////////////////////////////////
// Block at 821B81D0h
// Function '?BreakCrossBlockDependency_BeforeCleanPhase@Compiler@D3DXShader@@AAAXPAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B81D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B81D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B81D0);
		  /* 821B81D0h */ case    0:  		/* stwx R8, <#[R9 + R10]> */
		/* 821B81D0h case    0:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 821B81D0h case    0:*/		return 0x821B81D4;
		  /* 821B81D4h */ case    1:  		/* mr R8, R11 */
		/* 821B81D4h case    1:*/		regs.R8 = regs.R11;
		/* 821B81D4h case    1:*/		return 0x821B81D8;
	}
	return 0x821B81D8;
} // Block from 821B81D0h-821B81D8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B81D8h
// Function '?EjectConstantOperand@Compiler@D3DXShader@@AAA_NPAVInstruction@2@IPAVDependency@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B81D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B81D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B81D8);
		  /* 821B81D8h */ case    0:  		/* cmplw CR6, R11, R14 */
		/* 821B81D8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R14);
		/* 821B81D8h case    0:*/		return 0x821B81DC;
		  /* 821B81DCh */ case    1:  		/* bc 4, CR6_LT, 148 */
		/* 821B81DCh case    1:*/		if ( !regs.CR[6].lt ) { return 0x821B8270;  }
		/* 821B81DCh case    1:*/		return 0x821B81E0;
		  /* 821B81E0h */ case    2:  		/* subf R24, R11, R14 */
		/* 821B81E0h case    2:*/		cpu::op::subf<0>(regs,&regs.R24,regs.R11,regs.R14);
		/* 821B81E0h case    2:*/		return 0x821B81E4;
		  /* 821B81E4h */ case    3:  		/* mr R11, R7 */
		/* 821B81E4h case    3:*/		regs.R11 = regs.R7;
		/* 821B81E4h case    3:*/		return 0x821B81E8;
		  /* 821B81E8h */ case    4:  		/* addi R5, R28, 4 */
		/* 821B81E8h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R28,0x4);
		/* 821B81E8h case    4:*/		return 0x821B81EC;
		  /* 821B81ECh */ case    5:  		/* mtspr CTR, R24 */
		/* 821B81ECh case    5:*/		regs.CTR = regs.R24;
		/* 821B81ECh case    5:*/		return 0x821B81F0;
		  /* 821B81F0h */ case    6:  		/* lwz R7, <#[R1 + 80]> */
		/* 821B81F0h case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000050) );
		/* 821B81F0h case    6:*/		return 0x821B81F4;
		  /* 821B81F4h */ case    7:  		/* slw R24, R16, R8 */
		/* 821B81F4h case    7:*/		cpu::op::slw<0>(regs,&regs.R24,regs.R16,regs.R8);
		/* 821B81F4h case    7:*/		return 0x821B81F8;
		  /* 821B81F8h */ case    8:  		/* and. R7, R24, R7 */
		/* 821B81F8h case    8:*/		cpu::op::and<1>(regs,&regs.R7,regs.R24,regs.R7);
		/* 821B81F8h case    8:*/		return 0x821B81FC;
		  /* 821B81FCh */ case    9:  		/* bc 4, CR0_EQ, 100 */
		/* 821B81FCh case    9:*/		if ( !regs.CR[0].eq ) { return 0x821B8260;  }
		/* 821B81FCh case    9:*/		return 0x821B8200;
		  /* 821B8200h */ case   10:  		/* lwz R7, <#[R5]> */
		/* 821B8200h case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R5 + 0x00000000) );
		/* 821B8200h case   10:*/		return 0x821B8204;
		  /* 821B8204h */ case   11:  		/* lwz R24, <#[R28]> */
		/* 821B8204h case   11:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R28 + 0x00000000) );
		/* 821B8204h case   11:*/		return 0x821B8208;
		  /* 821B8208h */ case   12:  		/* cmplw CR6, R24, R7 */
		/* 821B8208h case   12:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R7);
		/* 821B8208h case   12:*/		return 0x821B820C;
		  /* 821B820Ch */ case   13:  		/* bc 4, CR6_EQ, 84 */
		/* 821B820Ch case   13:*/		if ( !regs.CR[6].eq ) { return 0x821B8260;  }
		/* 821B820Ch case   13:*/		return 0x821B8210;
		  /* 821B8210h */ case   14:  		/* addi R7, R11, 4 */
		/* 821B8210h case   14:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0x4);
		/* 821B8210h case   14:*/		return 0x821B8214;
		  /* 821B8214h */ case   15:  		/* addi R23, R1, 84 */
		/* 821B8214h case   15:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R1,0x54);
		/* 821B8214h case   15:*/		return 0x821B8218;
		  /* 821B8218h */ case   16:  		/* rlwinm R24, R11, 29, 3, 29 */
		/* 821B8218h case   16:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R24,regs.R11);
		/* 821B8218h case   16:*/		return 0x821B821C;
		  /* 821B821Ch */ case   17:  		/* rlwinm R7, R7, 0, 27, 31 */
		/* 821B821Ch case   17:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R7,regs.R7);
		/* 821B821Ch case   17:*/		return 0x821B8220;
		  /* 821B8220h */ case   18:  		/* slw R7, R30, R7 */
		/* 821B8220h case   18:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R30,regs.R7);
		/* 821B8220h case   18:*/		return 0x821B8224;
		  /* 821B8224h */ case   19:  		/* lwzx R24, <#[R24 + R23]> */
		/* 821B8224h case   19:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R24 + regs.R23 + 0x00000000) );
		/* 821B8224h case   19:*/		return 0x821B8228;
		  /* 821B8228h */ case   20:  		/* addi R7, R7, -1 */
		/* 821B8228h case   20:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0xFFFFFFFF);
		/* 821B8228h case   20:*/		return 0x821B822C;
		  /* 821B822Ch */ case   21:  		/* rlwinm R23, R11, 0, 27, 31 */
		/* 821B822Ch case   21:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R23,regs.R11);
		/* 821B822Ch case   21:*/		return 0x821B8230;
		  /* 821B8230h */ case   22:  		/* and R7, R7, R24 */
		/* 821B8230h case   22:*/		cpu::op::and<0>(regs,&regs.R7,regs.R7,regs.R24);
		/* 821B8230h case   22:*/		return 0x821B8234;
		  /* 821B8234h */ case   23:  		/* slw R22, R15, R23 */
		/* 821B8234h case   23:*/		cpu::op::slw<0>(regs,&regs.R22,regs.R15,regs.R23);
		/* 821B8234h case   23:*/		return 0x821B8238;
		  /* 821B8238h */ case   24:  		/* and R7, R7, R22 */
		/* 821B8238h case   24:*/		cpu::op::and<0>(regs,&regs.R7,regs.R7,regs.R22);
		/* 821B8238h case   24:*/		return 0x821B823C;
		  /* 821B823Ch */ case   25:  		/* srw R7, R7, R23 */
		/* 821B823Ch case   25:*/		cpu::op::srw<0>(regs,&regs.R7,regs.R7,regs.R23);
		/* 821B823Ch case   25:*/		return 0x821B8240;
		  /* 821B8240h */ case   26:  		/* cmplw CR6, R7, R29 */
		/* 821B8240h case   26:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R29);
		/* 821B8240h case   26:*/		return 0x821B8244;
		  /* 821B8244h */ case   27:  		/* bc 4, CR6_EQ, 28 */
		/* 821B8244h case   27:*/		if ( !regs.CR[6].eq ) { return 0x821B8260;  }
		/* 821B8244h case   27:*/		return 0x821B8248;
		  /* 821B8248h */ case   28:  		/* slw R7, R25, R8 */
		/* 821B8248h case   28:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R25,regs.R8);
		/* 821B8248h case   28:*/		return 0x821B824C;
		  /* 821B824Ch */ case   29:  		/* lwzx R24, <#[R9 + R10]> */
		/* 821B824Ch case   29:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 821B824Ch case   29:*/		return 0x821B8250;
		  /* 821B8250h */ case   30:  		/* slw R7, R7, R6 */
		/* 821B8250h case   30:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R7,regs.R6);
		/* 821B8250h case   30:*/		return 0x821B8254;
		  /* 821B8254h */ case   31:  		/* or R7, R7, R24 */
		/* 821B8254h case   31:*/		cpu::op::or<0>(regs,&regs.R7,regs.R7,regs.R24);
		/* 821B8254h case   31:*/		return 0x821B8258;
		  /* 821B8258h */ case   32:  		/* addi R21, R21, 1 */
		/* 821B8258h case   32:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R21,0x1);
		/* 821B8258h case   32:*/		return 0x821B825C;
		  /* 821B825Ch */ case   33:  		/* stwx R7, <#[R9 + R10]> */
		/* 821B825Ch case   33:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 821B825Ch case   33:*/		return 0x821B8260;
	}
	return 0x821B8260;
} // Block from 821B81D8h-821B8260h (34 instructions)

//////////////////////////////////////////////////////
// Block at 821B8260h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8260( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8260) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8260);
		  /* 821B8260h */ case    0:  		/* addi R8, R8, 1 */
		/* 821B8260h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821B8260h case    0:*/		return 0x821B8264;
		  /* 821B8264h */ case    1:  		/* addi R5, R5, 4 */
		/* 821B8264h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x4);
		/* 821B8264h case    1:*/		return 0x821B8268;
		  /* 821B8268h */ case    2:  		/* addi R11, R11, 5 */
		/* 821B8268h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x5);
		/* 821B8268h case    2:*/		return 0x821B826C;
		  /* 821B826Ch */ case    3:  		/* bc 16, CR0_LT, -124 */
		/* 821B826Ch case    3:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x821B81F0;  }
		/* 821B826Ch case    3:*/		return 0x821B8270;
	}
	return 0x821B8270;
} // Block from 821B8260h-821B8270h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821B8270h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8270( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8270) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8270);
		  /* 821B8270h */ case    0:  		/* addi R17, R17, 1 */
		/* 821B8270h case    0:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R17,0x1);
		/* 821B8270h case    0:*/		return 0x821B8274;
		  /* 821B8274h */ case    1:  		/* addi R31, R31, 4 */
		/* 821B8274h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 821B8274h case    1:*/		return 0x821B8278;
	}
	return 0x821B8278;
} // Block from 821B8270h-821B8278h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B8278h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8278( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8278) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8278);
		  /* 821B8278h */ case    0:  		/* addi R4, R4, 1 */
		/* 821B8278h case    0:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x1);
		/* 821B8278h case    0:*/		return 0x821B827C;
		  /* 821B827Ch */ case    1:  		/* addi R3, R3, 5 */
		/* 821B827Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x5);
		/* 821B827Ch case    1:*/		return 0x821B8280;
		  /* 821B8280h */ case    2:  		/* addi R28, R28, 4 */
		/* 821B8280h case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 821B8280h case    2:*/		return 0x821B8284;
		  /* 821B8284h */ case    3:  		/* cmplw CR6, R4, R14 */
		/* 821B8284h case    3:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R14);
		/* 821B8284h case    3:*/		return 0x821B8288;
		  /* 821B8288h */ case    4:  		/* bc 12, CR6_LT, -292 */
		/* 821B8288h case    4:*/		if ( regs.CR[6].lt ) { return 0x821B8164;  }
		/* 821B8288h case    4:*/		return 0x821B828C;
	}
	return 0x821B828C;
} // Block from 821B8278h-821B828Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 821B828Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B828C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B828C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B828C);
		  /* 821B828Ch */ case    0:  		/* lwz R23, <#[R1 + 112]> */
		/* 821B828Ch case    0:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R1 + 0x00000070) );
		/* 821B828Ch case    0:*/		return 0x821B8290;
		  /* 821B8290h */ case    1:  		/* cmplwi CR6, R20, 0 */
		/* 821B8290h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000000);
		/* 821B8290h case    1:*/		return 0x821B8294;
		  /* 821B8294h */ case    2:  		/* bc 12, CR6_EQ, 116 */
		/* 821B8294h case    2:*/		if ( regs.CR[6].eq ) { return 0x821B8308;  }
		/* 821B8294h case    2:*/		return 0x821B8298;
		  /* 821B8298h */ case    3:  		/* cmplwi CR6, R17, 0 */
		/* 821B8298h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R17,0x00000000);
		/* 821B8298h case    3:*/		return 0x821B829C;
		  /* 821B829Ch */ case    4:  		/* bc 12, CR6_EQ, 84 */
		/* 821B829Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x821B82F0;  }
		/* 821B829Ch case    4:*/		return 0x821B82A0;
		  /* 821B82A0h */ case    5:  		/* li R20, 0 */
		/* 821B82A0h case    5:*/		cpu::op::li<0>(regs,&regs.R20,0x0);
		/* 821B82A0h case    5:*/		return 0x821B82A4;
		  /* 821B82A4h */ case    6:  		/* li R11, 0 */
		/* 821B82A4h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821B82A4h case    6:*/		return 0x821B82A8;
		  /* 821B82A8h */ case    7:  		/* cmplwi CR6, R14, 0 */
		/* 821B82A8h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R14,0x00000000);
		/* 821B82A8h case    7:*/		return 0x821B82AC;
		  /* 821B82ACh */ case    8:  		/* bc 12, CR6_EQ, 92 */
		/* 821B82ACh case    8:*/		if ( regs.CR[6].eq ) { return 0x821B8308;  }
		/* 821B82ACh case    8:*/		return 0x821B82B0;
		  /* 821B82B0h */ case    9:  		/* addi R10, R26, 44 */
		/* 821B82B0h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R26,0x2C);
		/* 821B82B0h case    9:*/		return 0x821B82B4;
		  /* 821B82B4h */ case   10:  		/* mtspr CTR, R14 */
		/* 821B82B4h case   10:*/		regs.CTR = regs.R14;
		/* 821B82B4h case   10:*/		return 0x821B82B8;
		  /* 821B82B8h */ case   11:  		/* lwz R9, <#[R1 + 80]> */
		/* 821B82B8h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000050) );
		/* 821B82B8h case   11:*/		return 0x821B82BC;
		  /* 821B82BCh */ case   12:  		/* slw R8, R16, R11 */
		/* 821B82BCh case   12:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R16,regs.R11);
		/* 821B82BCh case   12:*/		return 0x821B82C0;
		  /* 821B82C0h */ case   13:  		/* and. R9, R8, R9 */
		/* 821B82C0h case   13:*/		cpu::op::and<1>(regs,&regs.R9,regs.R8,regs.R9);
		/* 821B82C0h case   13:*/		return 0x821B82C4;
		  /* 821B82C4h */ case   14:  		/* bc 4, CR0_EQ, 32 */
		/* 821B82C4h case   14:*/		if ( !regs.CR[0].eq ) { return 0x821B82E4;  }
		/* 821B82C4h case   14:*/		return 0x821B82C8;
		  /* 821B82C8h */ case   15:  		/* lwz R9, <#[R10]> */
		/* 821B82C8h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821B82C8h case   15:*/		return 0x821B82CC;
		  /* 821B82CCh */ case   16:  		/* lwz R9, <#[R9 + 12]> */
		/* 821B82CCh case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x0000000C) );
		/* 821B82CCh case   16:*/		return 0x821B82D0;
		  /* 821B82D0h */ case   17:  		/* lwz R9, <#[R9 + 8]> */
		/* 821B82D0h case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 821B82D0h case   17:*/		return 0x821B82D4;
		  /* 821B82D4h */ case   18:  		/* rlwinm R9, R9, 0, 18, 24 */
		/* 821B82D4h case   18:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R9,regs.R9);
		/* 821B82D4h case   18:*/		return 0x821B82D8;
		  /* 821B82D8h */ case   19:  		/* cmplwi CR6, R9, 15872 */
		/* 821B82D8h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00003E00);
		/* 821B82D8h case   19:*/		return 0x821B82DC;
		  /* 821B82DCh */ case   20:  		/* bc 4, CR6_EQ, 8 */
		/* 821B82DCh case   20:*/		if ( !regs.CR[6].eq ) { return 0x821B82E4;  }
		/* 821B82DCh case   20:*/		return 0x821B82E0;
		  /* 821B82E0h */ case   21:  		/* addi R20, R20, 1 */
		/* 821B82E0h case   21:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R20,0x1);
		/* 821B82E0h case   21:*/		return 0x821B82E4;
	}
	return 0x821B82E4;
} // Block from 821B828Ch-821B82E4h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821B82E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B82E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B82E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B82E4);
		  /* 821B82E4h */ case    0:  		/* addi R11, R11, 1 */
		/* 821B82E4h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821B82E4h case    0:*/		return 0x821B82E8;
		  /* 821B82E8h */ case    1:  		/* addi R10, R10, 4 */
		/* 821B82E8h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821B82E8h case    1:*/		return 0x821B82EC;
		  /* 821B82ECh */ case    2:  		/* bc 16, CR0_LT, -52 */
		/* 821B82ECh case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x821B82B8;  }
		/* 821B82ECh case    2:*/		return 0x821B82F0;
	}
	return 0x821B82F0;
} // Block from 821B82E4h-821B82F0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821B82F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B82F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B82F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B82F0);
		  /* 821B82F0h */ case    0:  		/* cmplwi CR6, R20, 0 */
		/* 821B82F0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000000);
		/* 821B82F0h case    0:*/		return 0x821B82F4;
		  /* 821B82F4h */ case    1:  		/* bc 12, CR6_EQ, 20 */
		/* 821B82F4h case    1:*/		if ( regs.CR[6].eq ) { return 0x821B8308;  }
		/* 821B82F4h case    1:*/		return 0x821B82F8;
		  /* 821B82F8h */ case    2:  		/* cmplwi CR6, R19, 1 */
		/* 821B82F8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R19,0x00000001);
		/* 821B82F8h case    2:*/		return 0x821B82FC;
		  /* 821B82FCh */ case    3:  		/* bc 12, CR6_GT, 536 */
		/* 821B82FCh case    3:*/		if ( regs.CR[6].gt ) { return 0x821B8514;  }
		/* 821B82FCh case    3:*/		return 0x821B8300;
		  /* 821B8300h */ case    4:  		/* cmplwi CR6, R17, 0 */
		/* 821B8300h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R17,0x00000000);
		/* 821B8300h case    4:*/		return 0x821B8304;
		  /* 821B8304h */ case    5:  		/* bc 4, CR6_EQ, 528 */
		/* 821B8304h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821B8514;  }
		/* 821B8304h case    5:*/		return 0x821B8308;
	}
	return 0x821B8308;
} // Block from 821B82F0h-821B8308h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821B8308h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8308( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8308) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8308);
		  /* 821B8308h */ case    0:  		/* li R22, 1 */
		/* 821B8308h case    0:*/		cpu::op::li<0>(regs,&regs.R22,0x1);
		/* 821B8308h case    0:*/		return 0x821B830C;
		  /* 821B830Ch */ case    1:  		/* cmplwi CR6, R27, 0 */
		/* 821B830Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 821B830Ch case    1:*/		return 0x821B8310;
	}
	return 0x821B8310;
} // Block from 821B8308h-821B8310h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B8310h
// Function '?CheckMerge@Compiler@D3DXShader@@AAA_NPAVBlock@2@PAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8310( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8310) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8310);
		  /* 821B8310h */ case    0:  		/* bc 4, CR6_EQ, 412 */
		/* 821B8310h case    0:*/		if ( !regs.CR[6].eq ) { return 0x821B84AC;  }
		/* 821B8310h case    0:*/		return 0x821B8314;
		  /* 821B8314h */ case    1:  		/* cmplwi CR6, R17, 0 */
		/* 821B8314h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R17,0x00000000);
		/* 821B8314h case    1:*/		return 0x821B8318;
		  /* 821B8318h */ case    2:  		/* bc 4, CR6_EQ, 404 */
		/* 821B8318h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821B84AC;  }
		/* 821B8318h case    2:*/		return 0x821B831C;
		  /* 821B831Ch */ case    3:  		/* cmplwi CR6, R19, 1 */
		/* 821B831Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R19,0x00000001);
		/* 821B831Ch case    3:*/		return 0x821B8320;
		  /* 821B8320h */ case    4:  		/* bc 4, CR6_EQ, 396 */
		/* 821B8320h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821B84AC;  }
		/* 821B8320h case    4:*/		return 0x821B8324;
		  /* 821B8324h */ case    5:  		/* lwz R8, <#[R26 + 44]> */
		/* 821B8324h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R26 + 0x0000002C) );
		/* 821B8324h case    5:*/		return 0x821B8328;
		  /* 821B8328h */ case    6:  		/* addi R10, R26, 44 */
		/* 821B8328h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R26,0x2C);
		/* 821B8328h case    6:*/		return 0x821B832C;
		  /* 821B832Ch */ case    7:  		/* lwz R11, <#[R26 + 8]> */
		/* 821B832Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 821B832Ch case    7:*/		return 0x821B8330;
		  /* 821B8330h */ case    8:  		/* li R29, 0 */
		/* 821B8330h case    8:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 821B8330h case    8:*/		return 0x821B8334;
		  /* 821B8334h */ case    9:  		/* li R9, 0 */
		/* 821B8334h case    9:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821B8334h case    9:*/		return 0x821B8338;
		  /* 821B8338h */ case   10:  		/* rlwinm R7, R11, 13, 29, 31 */
		/* 821B8338h case   10:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R7,regs.R11);
		/* 821B8338h case   10:*/		return 0x821B833C;
		  /* 821B833Ch */ case   11:  		/* li R11, 0 */
		/* 821B833Ch case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821B833Ch case   11:*/		return 0x821B8340;
		  /* 821B8340h */ case   12:  		/* lwz R8, <#[R8]> */
		/* 821B8340h case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000000) );
		/* 821B8340h case   12:*/		return 0x821B8344;
		  /* 821B8344h */ case   13:  		/* addi R10, R10, -4 */
		/* 821B8344h case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFC);
		/* 821B8344h case   13:*/		return 0x821B8348;
		  /* 821B8348h */ case   14:  		/* rlwinm R25, R8, 0, 31, 31 */
		/* 821B8348h case   14:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R25,regs.R8);
		/* 821B8348h case   14:*/		return 0x821B834C;
		  /* 821B834Ch */ case   15:  		/* cmplw CR6, R9, R7 */
		/* 821B834Ch case   15:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R7);
		/* 821B834Ch case   15:*/		return 0x821B8350;
		  /* 821B8350h */ case   16:  		/* bc 4, CR6_LT, 48 */
		/* 821B8350h case   16:*/		if ( !regs.CR[6].lt ) { return 0x821B8380;  }
		/* 821B8350h case   16:*/		return 0x821B8354;
		  /* 821B8354h */ case   17:  		/* lwzu R8, <#[R10 + 4]> */
		/* 821B8354h case   17:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000004) );
		regs.R10 = (uint32)(regs.R10 + 0x00000004);
		/* 821B8354h case   17:*/		return 0x821B8358;
		  /* 821B8358h */ case   18:  		/* li R6, 3 */
		/* 821B8358h case   18:*/		cpu::op::li<0>(regs,&regs.R6,0x3);
		/* 821B8358h case   18:*/		return 0x821B835C;
		  /* 821B835Ch */ case   19:  		/* addi R9, R9, 1 */
		/* 821B835Ch case   19:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 821B835Ch case   19:*/		return 0x821B8360;
		  /* 821B8360h */ case   20:  		/* slw R6, R6, R11 */
		/* 821B8360h case   20:*/		cpu::op::slw<0>(regs,&regs.R6,regs.R6,regs.R11);
		/* 821B8360h case   20:*/		return 0x821B8364;
		  /* 821B8364h */ case   21:  		/* lwz R8, <#[R8]> */
		/* 821B8364h case   21:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000000) );
		/* 821B8364h case   21:*/		return 0x821B8368;
		  /* 821B8368h */ case   22:  		/* andc R6, R29, R6 */
		/* 821B8368h case   22:*/		cpu::op::andc<0>(regs,&regs.R6,regs.R29,regs.R6);
		/* 821B8368h case   22:*/		return 0x821B836C;
		  /* 821B836Ch */ case   23:  		/* rlwinm R8, R8, 27, 30, 31 */
		/* 821B836Ch case   23:*/		cpu::op::rlwinm<0,27,30,31>(regs,&regs.R8,regs.R8);
		/* 821B836Ch case   23:*/		return 0x821B8370;
		  /* 821B8370h */ case   24:  		/* slw R8, R8, R11 */
		/* 821B8370h case   24:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R8,regs.R11);
		/* 821B8370h case   24:*/		return 0x821B8374;
		  /* 821B8374h */ case   25:  		/* or R29, R8, R6 */
		/* 821B8374h case   25:*/		cpu::op::or<0>(regs,&regs.R29,regs.R8,regs.R6);
		/* 821B8374h case   25:*/		return 0x821B8378;
		  /* 821B8378h */ case   26:  		/* addi R11, R11, 2 */
		/* 821B8378h case   26:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 821B8378h case   26:*/		return 0x821B837C;
		  /* 821B837Ch */ case   27:  		/* b -48 */
		/* 821B837Ch case   27:*/		return 0x821B834C;
		/* 821B837Ch case   27:*/		return 0x821B8380;
	}
	return 0x821B8380;
} // Block from 821B8310h-821B8380h (28 instructions)

//////////////////////////////////////////////////////
// Block at 821B8380h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8380( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8380) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8380);
		  /* 821B8380h */ case    0:  		/* addi R24, R26, 4 */
		/* 821B8380h case    0:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R26,0x4);
		/* 821B8380h case    0:*/		return 0x821B8384;
		  /* 821B8384h */ case    1:  		/* mr R28, R24 */
		/* 821B8384h case    1:*/		regs.R28 = regs.R24;
		/* 821B8384h case    1:*/		return 0x821B8388;
		  /* 821B8388h */ case    2:  		/* lwz R31, <#[R28]> */
		/* 821B8388h case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R28 + 0x00000000) );
		/* 821B8388h case    2:*/		return 0x821B838C;
		  /* 821B838Ch */ case    3:  		/* cmplwi CR6, R31, 0 */
		/* 821B838Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821B838Ch case    3:*/		return 0x821B8390;
		  /* 821B8390h */ case    4:  		/* bc 12, CR6_EQ, 264 */
		/* 821B8390h case    4:*/		if ( regs.CR[6].eq ) { return 0x821B8498;  }
		/* 821B8390h case    4:*/		return 0x821B8394;
		  /* 821B8394h */ case    5:  		/* lwz R11, <#[R31 + 16]> */
		/* 821B8394h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 821B8394h case    5:*/		return 0x821B8398;
		  /* 821B8398h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 821B8398h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821B8398h case    6:*/		return 0x821B839C;
		  /* 821B839Ch */ case    7:  		/* bc 12, CR6_EQ, 232 */
		/* 821B839Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x821B8484;  }
		/* 821B839Ch case    7:*/		return 0x821B83A0;
		  /* 821B83A0h */ case    8:  		/* lwz R10, <#[R31]> */
		/* 821B83A0h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 821B83A0h case    8:*/		return 0x821B83A4;
		  /* 821B83A4h */ case    9:  		/* rlwinm. R10, R10, 0, 4, 6 */
		/* 821B83A4h case    9:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R10);
		/* 821B83A4h case    9:*/		return 0x821B83A8;
		  /* 821B83A8h */ case   10:  		/* bc 12, CR0_EQ, 220 */
		/* 821B83A8h case   10:*/		if ( regs.CR[0].eq ) { return 0x821B8484;  }
		/* 821B83A8h case   10:*/		return 0x821B83AC;
		  /* 821B83ACh */ case   11:  		/* lwz R10, <#[R23 + 8]> */
		/* 821B83ACh case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000008) );
		/* 821B83ACh case   11:*/		return 0x821B83B0;
		  /* 821B83B0h */ case   12:  		/* rlwinm R10, R10, 0, 18, 24 */
		/* 821B83B0h case   12:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R10);
		/* 821B83B0h case   12:*/		return 0x821B83B4;
		  /* 821B83B4h */ case   13:  		/* cmplwi CR6, R10, 15872 */
		/* 821B83B4h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003E00);
		/* 821B83B4h case   13:*/		return 0x821B83B8;
		  /* 821B83B8h */ case   14:  		/* bc 4, CR6_EQ, 44 */
		/* 821B83B8h case   14:*/		if ( !regs.CR[6].eq ) { return 0x821B83E4;  }
		/* 821B83B8h case   14:*/		return 0x821B83BC;
		  /* 821B83BCh */ case   15:  		/* lwz R11, <#[R11 + 8]> */
		/* 821B83BCh case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821B83BCh case   15:*/		return 0x821B83C0;
		  /* 821B83C0h */ case   16:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821B83C0h case   16:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821B83C0h case   16:*/		return 0x821B83C4;
		  /* 821B83C4h */ case   17:  		/* cmplwi CR6, R11, 1 */
		/* 821B83C4h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 821B83C4h case   17:*/		return 0x821B83C8;
		  /* 821B83C8h */ case   18:  		/* bc 12, CR6_LT, 16 */
		/* 821B83C8h case   18:*/		if ( regs.CR[6].lt ) { return 0x821B83D8;  }
		/* 821B83C8h case   18:*/		return 0x821B83CC;
		  /* 821B83CCh */ case   19:  		/* cmplwi CR6, R11, 102 */
		/* 821B83CCh case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000066);
		/* 821B83CCh case   19:*/		return 0x821B83D0;
		  /* 821B83D0h */ case   20:  		/* mr R11, R22 */
		/* 821B83D0h case   20:*/		regs.R11 = regs.R22;
		/* 821B83D0h case   20:*/		return 0x821B83D4;
		  /* 821B83D4h */ case   21:  		/* bc 4, CR6_GT, 8 */
		/* 821B83D4h case   21:*/		if ( !regs.CR[6].gt ) { return 0x821B83DC;  }
		/* 821B83D4h case   21:*/		return 0x821B83D8;
	}
	return 0x821B83D8;
} // Block from 821B8380h-821B83D8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821B83D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B83D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B83D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B83D8);
		  /* 821B83D8h */ case    0:  		/* li R11, 0 */
		/* 821B83D8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821B83D8h case    0:*/		return 0x821B83DC;
	}
	return 0x821B83DC;
} // Block from 821B83D8h-821B83DCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B83DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B83DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B83DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B83DC);
		  /* 821B83DCh */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821B83DCh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821B83DCh case    0:*/		return 0x821B83E0;
		  /* 821B83E0h */ case    1:  		/* bc 12, CR0_EQ, 164 */
		/* 821B83E0h case    1:*/		if ( regs.CR[0].eq ) { return 0x821B8484;  }
		/* 821B83E0h case    1:*/		return 0x821B83E4;
	}
	return 0x821B83E4;
} // Block from 821B83DCh-821B83E4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B83E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B83E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B83E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B83E4);
		  /* 821B83E4h */ case    0:  		/* lwz R11, <#[R31 + 12]> */
		/* 821B83E4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 821B83E4h case    0:*/		return 0x821B83E8;
		  /* 821B83E8h */ case    1:  		/* addi R11, R11, 4 */
		/* 821B83E8h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821B83E8h case    1:*/		return 0x821B83EC;
		  /* 821B83ECh */ case    2:  		/* lwz R10, <#[R11]> */
		/* 821B83ECh case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821B83ECh case    2:*/		return 0x821B83F0;
		  /* 821B83F0h */ case    3:  		/* b 12 */
		/* 821B83F0h case    3:*/		return 0x821B83FC;
		/* 821B83F0h case    3:*/		return 0x821B83F4;
		  /* 821B83F4h */ case    4:  		/* addi R11, R10, 8 */
		/* 821B83F4h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 821B83F4h case    4:*/		return 0x821B83F8;
		  /* 821B83F8h */ case    5:  		/* lwz R10, <#[R10 + 8]> */
		/* 821B83F8h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 821B83F8h case    5:*/		return 0x821B83FC;
	}
	return 0x821B83FC;
} // Block from 821B83E4h-821B83FCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 821B83FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B83FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B83FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B83FC);
		  /* 821B83FCh */ case    0:  		/* cmplw CR6, R10, R31 */
		/* 821B83FCh case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 821B83FCh case    0:*/		return 0x821B8400;
		  /* 821B8400h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 821B8400h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821B83F4;  }
		/* 821B8400h case    1:*/		return 0x821B8404;
		  /* 821B8404h */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 821B8404h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 821B8404h case    2:*/		return 0x821B8408;
		  /* 821B8408h */ case    3:  		/* mr R3, R25 */
		/* 821B8408h case    3:*/		regs.R3 = regs.R25;
		/* 821B8408h case    3:*/		return 0x821B840C;
		  /* 821B840Ch */ case    4:  		/* stw R10, <#[R11]> */
		/* 821B840Ch case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821B840Ch case    4:*/		return 0x821B8410;
		  /* 821B8410h */ case    5:  		/* lwz R11, <#[R23 + 4]> */
		/* 821B8410h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 821B8410h case    5:*/		return 0x821B8414;
		  /* 821B8414h */ case    6:  		/* stw R11, <#[R31 + 8]> */
		/* 821B8414h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821B8414h case    6:*/		return 0x821B8418;
		  /* 821B8418h */ case    7:  		/* stw R31, <#[R23 + 4]> */
		/* 821B8418h case    7:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R23 + 0x00000004) );
		/* 821B8418h case    7:*/		return 0x821B841C;
		  /* 821B841Ch */ case    8:  		/* lwz R11, <#[R31]> */
		/* 821B841Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821B841Ch case    8:*/		return 0x821B8420;
		  /* 821B8420h */ case    9:  		/* mr R10, R11 */
		/* 821B8420h case    9:*/		regs.R10 = regs.R11;
		/* 821B8420h case    9:*/		return 0x821B8424;
		  /* 821B8424h */ case   10:  		/* rlwinm R10, R10, 27, 24, 31 */
		/* 821B8424h case   10:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R10,regs.R10);
		/* 821B8424h case   10:*/		return 0x821B8428;
		  /* 821B8428h */ case   11:  		/* stw R23, <#[R31 + 12]> */
		/* 821B8428h case   11:*/		cpu::mem::store32( regs, regs.R23, (uint32)(regs.R31 + 0x0000000C) );
		/* 821B8428h case   11:*/		return 0x821B842C;
		  /* 821B842Ch */ case   12:  		/* rlwinm R11, R11, 0, 27, 18 */
		/* 821B842Ch case   12:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R11,regs.R11);
		/* 821B842Ch case   12:*/		return 0x821B8430;
		  /* 821B8430h */ case   13:  		/* rlwinm R9, R10, 27, 29, 30 */
		/* 821B8430h case   13:*/		cpu::op::rlwinm<0,27,29,30>(regs,&regs.R9,regs.R10);
		/* 821B8430h case   13:*/		return 0x821B8434;
		  /* 821B8434h */ case   14:  		/* rlwinm R8, R10, 29, 29, 30 */
		/* 821B8434h case   14:*/		cpu::op::rlwinm<0,29,29,30>(regs,&regs.R8,regs.R10);
		/* 821B8434h case   14:*/		return 0x821B8438;
		  /* 821B8438h */ case   15:  		/* srw R9, R29, R9 */
		/* 821B8438h case   15:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R29,regs.R9);
		/* 821B8438h case   15:*/		return 0x821B843C;
		  /* 821B843Ch */ case   16:  		/* srw R8, R29, R8 */
		/* 821B843Ch case   16:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R29,regs.R8);
		/* 821B843Ch case   16:*/		return 0x821B8440;
		  /* 821B8440h */ case   17:  		/* rlwimi R8, R9, 2, 28, 29 */
		/* 821B8440h case   17:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R8,regs.R9);
		/* 821B8440h case   17:*/		return 0x821B8444;
		  /* 821B8444h */ case   18:  		/* rlwinm R9, R10, 31, 29, 30 */
		/* 821B8444h case   18:*/		cpu::op::rlwinm<0,31,29,30>(regs,&regs.R9,regs.R10);
		/* 821B8444h case   18:*/		return 0x821B8448;
		  /* 821B8448h */ case   19:  		/* rlwinm R10, R10, 1, 29, 30 */
		/* 821B8448h case   19:*/		cpu::op::rlwinm<0,1,29,30>(regs,&regs.R10,regs.R10);
		/* 821B8448h case   19:*/		return 0x821B844C;
		  /* 821B844Ch */ case   20:  		/* rlwinm R8, R8, 0, 28, 31 */
		/* 821B844Ch case   20:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R8,regs.R8);
		/* 821B844Ch case   20:*/		return 0x821B8450;
		  /* 821B8450h */ case   21:  		/* srw R9, R29, R9 */
		/* 821B8450h case   21:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R29,regs.R9);
		/* 821B8450h case   21:*/		return 0x821B8454;
		  /* 821B8454h */ case   22:  		/* srw R10, R29, R10 */
		/* 821B8454h case   22:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R29,regs.R10);
		/* 821B8454h case   22:*/		return 0x821B8458;
		  /* 821B8458h */ case   23:  		/* rlwimi R9, R8, 2, 0, 29 */
		/* 821B8458h case   23:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R9,regs.R8);
		/* 821B8458h case   23:*/		return 0x821B845C;
		  /* 821B845Ch */ case   24:  		/* rlwimi R10, R9, 2, 0, 29 */
		/* 821B845Ch case   24:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R10,regs.R9);
		/* 821B845Ch case   24:*/		return 0x821B8460;
		  /* 821B8460h */ case   25:  		/* rlwinm R10, R10, 5, 0, 26 */
		/* 821B8460h case   25:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R10,regs.R10);
		/* 821B8460h case   25:*/		return 0x821B8464;
		  /* 821B8464h */ case   26:  		/* or R11, R10, R11 */
		/* 821B8464h case   26:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821B8464h case   26:*/		return 0x821B8468;
		  /* 821B8468h */ case   27:  		/* rlwinm R4, R11, 0, 27, 31 */
		/* 821B8468h case   27:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R4,regs.R11);
		/* 821B8468h case   27:*/		return 0x821B846C;
		  /* 821B846Ch */ case   28:  		/* stw R11, <#[R1 + 96]> */
		/* 821B846Ch case   28:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 821B846Ch case   28:*/		return 0x821B8470;
		  /* 821B8470h */ case   29:  		/* bl -264696 */
		/* 821B8470h case   29:*/		regs.LR = 0x821B8474; return 0x82177A78;
		/* 821B8470h case   29:*/		return 0x821B8474;
		  /* 821B8474h */ case   30:  		/* lwz R11, <#[R1 + 96]> */
		/* 821B8474h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 821B8474h case   30:*/		return 0x821B8478;
		  /* 821B8478h */ case   31:  		/* li R22, 1 */
		/* 821B8478h case   31:*/		cpu::op::li<0>(regs,&regs.R22,0x1);
		/* 821B8478h case   31:*/		return 0x821B847C;
		  /* 821B847Ch */ case   32:  		/* rlwimi R3, R11, 0, 0, 26 */
		/* 821B847Ch case   32:*/		cpu::op::rlwimi<0,0,0,26>(regs,&regs.R3,regs.R11);
		/* 821B847Ch case   32:*/		return 0x821B8480;
		  /* 821B8480h */ case   33:  		/* stw R3, <#[R31]> */
		/* 821B8480h case   33:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 821B8480h case   33:*/		return 0x821B8484;
	}
	return 0x821B8484;
} // Block from 821B83FCh-821B8484h (34 instructions)

//////////////////////////////////////////////////////
// Block at 821B8484h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8484( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8484) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8484);
		  /* 821B8484h */ case    0:  		/* lwz R11, <#[R28]> */
		/* 821B8484h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 821B8484h case    0:*/		return 0x821B8488;
		  /* 821B8488h */ case    1:  		/* cmplw CR6, R11, R31 */
		/* 821B8488h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 821B8488h case    1:*/		return 0x821B848C;
		  /* 821B848Ch */ case    2:  		/* bc 4, CR6_EQ, -260 */
		/* 821B848Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x821B8388;  }
		/* 821B848Ch case    2:*/		return 0x821B8490;
		  /* 821B8490h */ case    3:  		/* addi R28, R31, 8 */
		/* 821B8490h case    3:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R31,0x8);
		/* 821B8490h case    3:*/		return 0x821B8494;
		  /* 821B8494h */ case    4:  		/* b -268 */
		/* 821B8494h case    4:*/		return 0x821B8388;
		/* 821B8494h case    4:*/		return 0x821B8498;
	}
	return 0x821B8498;
} // Block from 821B8484h-821B8498h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821B8498h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8498( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8498) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8498);
		  /* 821B8498h */ case    0:  		/* lwz R11, <#[R24]> */
		/* 821B8498h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 821B8498h case    0:*/		return 0x821B849C;
		  /* 821B849Ch */ case    1:  		/* cmpwi CR6, R11, 0 */
		/* 821B849Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 821B849Ch case    1:*/		return 0x821B84A0;
		  /* 821B84A0h */ case    2:  		/* bc 12, CR6_EQ, 496 */
		/* 821B84A0h case    2:*/		if ( regs.CR[6].eq ) { return 0x821B8690;  }
		/* 821B84A0h case    2:*/		return 0x821B84A4;
		  /* 821B84A4h */ case    3:  		/* cmplwi CR6, R20, 0 */
		/* 821B84A4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000000);
		/* 821B84A4h case    3:*/		return 0x821B84A8;
		  /* 821B84A8h */ case    4:  		/* bc 4, CR6_EQ, 112 */
		/* 821B84A8h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821B8518;  }
		/* 821B84A8h case    4:*/		return 0x821B84AC;
	}
	return 0x821B84AC;
} // Block from 821B8498h-821B84ACh (5 instructions)

//////////////////////////////////////////////////////
// Block at 821B84ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B84AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B84AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B84AC);
		  /* 821B84ACh */ case    0:  		/* cmplwi CR6, R18, 1 */
		/* 821B84ACh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R18,0x00000001);
		/* 821B84ACh case    0:*/		return 0x821B84B0;
		  /* 821B84B0h */ case    1:  		/* li R24, 0 */
		/* 821B84B0h case    1:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 821B84B0h case    1:*/		return 0x821B84B4;
		  /* 821B84B4h */ case    2:  		/* bc 4, CR6_GT, 644 */
		/* 821B84B4h case    2:*/		if ( !regs.CR[6].gt ) { return 0x821B8738;  }
		/* 821B84B4h case    2:*/		return 0x821B84B8;
		  /* 821B84B8h */ case    3:  		/* cmplwi CR6, R14, 0 */
		/* 821B84B8h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R14,0x00000000);
		/* 821B84B8h case    3:*/		return 0x821B84BC;
		  /* 821B84BCh */ case    4:  		/* mr R31, R24 */
		/* 821B84BCh case    4:*/		regs.R31 = regs.R24;
		/* 821B84BCh case    4:*/		return 0x821B84C0;
		  /* 821B84C0h */ case    5:  		/* mr R7, R24 */
		/* 821B84C0h case    5:*/		regs.R7 = regs.R24;
		/* 821B84C0h case    5:*/		return 0x821B84C4;
		  /* 821B84C4h */ case    6:  		/* bc 12, CR6_EQ, 628 */
		/* 821B84C4h case    6:*/		if ( regs.CR[6].eq ) { return 0x821B8738;  }
		/* 821B84C4h case    6:*/		return 0x821B84C8;
		  /* 821B84C8h */ case    7:  		/* rlwinm R5, R17, 2, 0, 29 */
		/* 821B84C8h case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R5,regs.R17);
		/* 821B84C8h case    7:*/		return 0x821B84CC;
		  /* 821B84CCh */ case    8:  		/* addi R4, R1, 112 */
		/* 821B84CCh case    8:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x70);
		/* 821B84CCh case    8:*/		return 0x821B84D0;
		  /* 821B84D0h */ case    9:  		/* addi R3, R26, 44 */
		/* 821B84D0h case    9:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R26,0x2C);
		/* 821B84D0h case    9:*/		return 0x821B84D4;
		  /* 821B84D4h */ case   10:  		/* lwz R11, <#[R1 + 80]> */
		/* 821B84D4h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 821B84D4h case   10:*/		return 0x821B84D8;
		  /* 821B84D8h */ case   11:  		/* slw R10, R16, R7 */
		/* 821B84D8h case   11:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R16,regs.R7);
		/* 821B84D8h case   11:*/		return 0x821B84DC;
		  /* 821B84DCh */ case   12:  		/* and. R11, R10, R11 */
		/* 821B84DCh case   12:*/		cpu::op::and<1>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821B84DCh case   12:*/		return 0x821B84E0;
		  /* 821B84E0h */ case   13:  		/* bc 4, CR0_EQ, 580 */
		/* 821B84E0h case   13:*/		if ( !regs.CR[0].eq ) { return 0x821B8724;  }
		/* 821B84E0h case   13:*/		return 0x821B84E4;
		  /* 821B84E4h */ case   14:  		/* lwz R11, <#[R3]> */
		/* 821B84E4h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821B84E4h case   14:*/		return 0x821B84E8;
		  /* 821B84E8h */ case   15:  		/* lwz R11, <#[R11 + 12]> */
		/* 821B84E8h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 821B84E8h case   15:*/		return 0x821B84EC;
		  /* 821B84ECh */ case   16:  		/* lwz R10, <#[R11 + 8]> */
		/* 821B84ECh case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821B84ECh case   16:*/		return 0x821B84F0;
		  /* 821B84F0h */ case   17:  		/* rlwinm R10, R10, 0, 18, 24 */
		/* 821B84F0h case   17:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R10);
		/* 821B84F0h case   17:*/		return 0x821B84F4;
		  /* 821B84F4h */ case   18:  		/* cmplwi CR6, R10, 14464 */
		/* 821B84F4h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003880);
		/* 821B84F4h case   18:*/		return 0x821B84F8;
		  /* 821B84F8h */ case   19:  		/* bc 4, CR6_EQ, 556 */
		/* 821B84F8h case   19:*/		if ( !regs.CR[6].eq ) { return 0x821B8724;  }
		/* 821B84F8h case   19:*/		return 0x821B84FC;
		  /* 821B84FCh */ case   20:  		/* cmplw CR6, R11, R31 */
		/* 821B84FCh case   20:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 821B84FCh case   20:*/		return 0x821B8500;
		  /* 821B8500h */ case   21:  		/* bc 12, CR6_EQ, 548 */
		/* 821B8500h case   21:*/		if ( regs.CR[6].eq ) { return 0x821B8724;  }
		/* 821B8500h case   21:*/		return 0x821B8504;
		  /* 821B8504h */ case   22:  		/* cmplwi CR6, R31, 0 */
		/* 821B8504h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821B8504h case   22:*/		return 0x821B8508;
		  /* 821B8508h */ case   23:  		/* bc 4, CR6_EQ, 404 */
		/* 821B8508h case   23:*/		if ( !regs.CR[6].eq ) { return 0x821B869C;  }
		/* 821B8508h case   23:*/		return 0x821B850C;
		  /* 821B850Ch */ case   24:  		/* mr R31, R11 */
		/* 821B850Ch case   24:*/		regs.R31 = regs.R11;
		/* 821B850Ch case   24:*/		return 0x821B8510;
		  /* 821B8510h */ case   25:  		/* b 532 */
		/* 821B8510h case   25:*/		return 0x821B8724;
		/* 821B8510h case   25:*/		return 0x821B8514;
	}
	return 0x821B8514;
} // Block from 821B84ACh-821B8514h (26 instructions)

//////////////////////////////////////////////////////
// Block at 821B8514h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8514( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8514) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8514);
		  /* 821B8514h */ case    0:  		/* li R22, 1 */
		/* 821B8514h case    0:*/		cpu::op::li<0>(regs,&regs.R22,0x1);
		/* 821B8514h case    0:*/		return 0x821B8518;
	}
	return 0x821B8518;
} // Block from 821B8514h-821B8518h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B8518h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8518( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8518) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8518);
		  /* 821B8518h */ case    0:  		/* li R31, 0 */
		/* 821B8518h case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 821B8518h case    0:*/		return 0x821B851C;
		  /* 821B851Ch */ case    1:  		/* cmplwi CR6, R14, 0 */
		/* 821B851Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R14,0x00000000);
		/* 821B851Ch case    1:*/		return 0x821B8520;
		  /* 821B8520h */ case    2:  		/* bc 12, CR6_EQ, 360 */
		/* 821B8520h case    2:*/		if ( regs.CR[6].eq ) { return 0x821B8688;  }
		/* 821B8520h case    2:*/		return 0x821B8524;
		  /* 821B8524h */ case    3:  		/* rlwinm R28, R17, 2, 0, 29 */
		/* 821B8524h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R28,regs.R17);
		/* 821B8524h case    3:*/		return 0x821B8528;
		  /* 821B8528h */ case    4:  		/* li R5, 0 */
		/* 821B8528h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821B8528h case    4:*/		return 0x821B852C;
		  /* 821B852Ch */ case    5:  		/* addi R25, R1, 112 */
		/* 821B852Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R1,0x70);
		/* 821B852Ch case    5:*/		return 0x821B8530;
		  /* 821B8530h */ case    6:  		/* addi R24, R26, 44 */
		/* 821B8530h case    6:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R26,0x2C);
		/* 821B8530h case    6:*/		return 0x821B8534;
		  /* 821B8534h */ case    7:  		/* lwz R11, <#[R1 + 80]> */
		/* 821B8534h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 821B8534h case    7:*/		return 0x821B8538;
		  /* 821B8538h */ case    8:  		/* slw R10, R16, R31 */
		/* 821B8538h case    8:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R16,regs.R31);
		/* 821B8538h case    8:*/		return 0x821B853C;
		  /* 821B853Ch */ case    9:  		/* and. R11, R10, R11 */
		/* 821B853Ch case    9:*/		cpu::op::and<1>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821B853Ch case    9:*/		return 0x821B8540;
		  /* 821B8540h */ case   10:  		/* bc 4, CR0_EQ, 304 */
		/* 821B8540h case   10:*/		if ( !regs.CR[0].eq ) { return 0x821B8670;  }
		/* 821B8540h case   10:*/		return 0x821B8544;
		  /* 821B8544h */ case   11:  		/* lwz R11, <#[R24]> */
		/* 821B8544h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 821B8544h case   11:*/		return 0x821B8548;
		  /* 821B8548h */ case   12:  		/* lwz R11, <#[R11 + 12]> */
		/* 821B8548h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 821B8548h case   12:*/		return 0x821B854C;
		  /* 821B854Ch */ case   13:  		/* lwz R11, <#[R11 + 8]> */
		/* 821B854Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821B854Ch case   13:*/		return 0x821B8550;
		  /* 821B8550h */ case   14:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821B8550h case   14:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821B8550h case   14:*/		return 0x821B8554;
		  /* 821B8554h */ case   15:  		/* cmplwi CR6, R11, 15872 */
		/* 821B8554h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E00);
		/* 821B8554h case   15:*/		return 0x821B8558;
		  /* 821B8558h */ case   16:  		/* bc 4, CR6_EQ, 280 */
		/* 821B8558h case   16:*/		if ( !regs.CR[6].eq ) { return 0x821B8670;  }
		/* 821B8558h case   16:*/		return 0x821B855C;
		  /* 821B855Ch */ case   17:  		/* rlwinm R9, R28, 29, 3, 29 */
		/* 821B855Ch case   17:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R9,regs.R28);
		/* 821B855Ch case   17:*/		return 0x821B8560;
		  /* 821B8560h */ case   18:  		/* addi R10, R1, 80 */
		/* 821B8560h case   18:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 821B8560h case   18:*/		return 0x821B8564;
		  /* 821B8564h */ case   19:  		/* slw R11, R22, R31 */
		/* 821B8564h case   19:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R22,regs.R31);
		/* 821B8564h case   19:*/		return 0x821B8568;
		  /* 821B8568h */ case   20:  		/* rlwinm R3, R28, 0, 27, 31 */
		/* 821B8568h case   20:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R3,regs.R28);
		/* 821B8568h case   20:*/		return 0x821B856C;
		  /* 821B856Ch */ case   21:  		/* lwzx R8, <#[R9 + R10]> */
		/* 821B856Ch case   21:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 821B856Ch case   21:*/		return 0x821B8570;
		  /* 821B8570h */ case   22:  		/* addi R21, R21, 1 */
		/* 821B8570h case   22:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R21,0x1);
		/* 821B8570h case   22:*/		return 0x821B8574;
		  /* 821B8574h */ case   23:  		/* slw R7, R11, R3 */
		/* 821B8574h case   23:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R11,regs.R3);
		/* 821B8574h case   23:*/		return 0x821B8578;
		  /* 821B8578h */ case   24:  		/* addi R11, R31, 1 */
		/* 821B8578h case   24:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x1);
		/* 821B8578h case   24:*/		return 0x821B857C;
		  /* 821B857Ch */ case   25:  		/* or R8, R7, R8 */
		/* 821B857Ch case   25:*/		cpu::op::or<0>(regs,&regs.R8,regs.R7,regs.R8);
		/* 821B857Ch case   25:*/		return 0x821B8580;
		  /* 821B8580h */ case   26:  		/* mr R6, R11 */
		/* 821B8580h case   26:*/		regs.R6 = regs.R11;
		/* 821B8580h case   26:*/		return 0x821B8584;
		  /* 821B8584h */ case   27:  		/* stwx R8, <#[R9 + R10]> */
		/* 821B8584h case   27:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 821B8584h case   27:*/		return 0x821B8588;
		  /* 821B8588h */ case   28:  		/* cmplw CR6, R11, R14 */
		/* 821B8588h case   28:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R14);
		/* 821B8588h case   28:*/		return 0x821B858C;
		  /* 821B858Ch */ case   29:  		/* bc 4, CR6_LT, 220 */
		/* 821B858Ch case   29:*/		if ( !regs.CR[6].lt ) { return 0x821B8668;  }
		/* 821B858Ch case   29:*/		return 0x821B8590;
		  /* 821B8590h */ case   30:  		/* subf R8, R11, R14 */
		/* 821B8590h case   30:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R11,regs.R14);
		/* 821B8590h case   30:*/		return 0x821B8594;
		  /* 821B8594h */ case   31:  		/* addi R4, R5, 4 */
		/* 821B8594h case   31:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R5,0x4);
		/* 821B8594h case   31:*/		return 0x821B8598;
		  /* 821B8598h */ case   32:  		/* addi R29, R25, 4 */
		/* 821B8598h case   32:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R25,0x4);
		/* 821B8598h case   32:*/		return 0x821B859C;
		  /* 821B859Ch */ case   33:  		/* addi R11, R4, 1 */
		/* 821B859Ch case   33:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0x1);
		/* 821B859Ch case   33:*/		return 0x821B85A0;
		  /* 821B85A0h */ case   34:  		/* mtspr CTR, R8 */
		/* 821B85A0h case   34:*/		regs.CTR = regs.R8;
		/* 821B85A0h case   34:*/		return 0x821B85A4;
		  /* 821B85A4h */ case   35:  		/* lwz R8, <#[R1 + 80]> */
		/* 821B85A4h case   35:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000050) );
		/* 821B85A4h case   35:*/		return 0x821B85A8;
		  /* 821B85A8h */ case   36:  		/* slw R7, R16, R6 */
		/* 821B85A8h case   36:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R16,regs.R6);
		/* 821B85A8h case   36:*/		return 0x821B85AC;
		  /* 821B85ACh */ case   37:  		/* and. R8, R7, R8 */
		/* 821B85ACh case   37:*/		cpu::op::and<1>(regs,&regs.R8,regs.R7,regs.R8);
		/* 821B85ACh case   37:*/		return 0x821B85B0;
		  /* 821B85B0h */ case   38:  		/* bc 4, CR0_EQ, 160 */
		/* 821B85B0h case   38:*/		if ( !regs.CR[0].eq ) { return 0x821B8650;  }
		/* 821B85B0h case   38:*/		return 0x821B85B4;
		  /* 821B85B4h */ case   39:  		/* lwz R8, <#[R29]> */
		/* 821B85B4h case   39:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R29 + 0x00000000) );
		/* 821B85B4h case   39:*/		return 0x821B85B8;
		  /* 821B85B8h */ case   40:  		/* lwz R7, <#[R25]> */
		/* 821B85B8h case   40:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R25 + 0x00000000) );
		/* 821B85B8h case   40:*/		return 0x821B85BC;
		  /* 821B85BCh */ case   41:  		/* cmplw CR6, R7, R8 */
		/* 821B85BCh case   41:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R8);
		/* 821B85BCh case   41:*/		return 0x821B85C0;
		  /* 821B85C0h */ case   42:  		/* bc 4, CR6_EQ, 144 */
		/* 821B85C0h case   42:*/		if ( !regs.CR[6].eq ) { return 0x821B8650;  }
		/* 821B85C0h case   42:*/		return 0x821B85C4;
		  /* 821B85C4h */ case   43:  		/* addi R8, R11, 4 */
		/* 821B85C4h case   43:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x4);
		/* 821B85C4h case   43:*/		return 0x821B85C8;
		  /* 821B85C8h */ case   44:  		/* lwz R14, <#[R1 + 104]> */
		/* 821B85C8h case   44:*/		cpu::mem::load32z( regs, &regs.R14, (uint32)(regs.R1 + 0x00000068) );
		/* 821B85C8h case   44:*/		return 0x821B85CC;
		  /* 821B85CCh */ case   45:  		/* rlwinm R27, R11, 29, 3, 29 */
		/* 821B85CCh case   45:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R27,regs.R11);
		/* 821B85CCh case   45:*/		return 0x821B85D0;
		  /* 821B85D0h */ case   46:  		/* addi R26, R1, 84 */
		/* 821B85D0h case   46:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R1,0x54);
		/* 821B85D0h case   46:*/		return 0x821B85D4;
		  /* 821B85D4h */ case   47:  		/* rlwinm R8, R8, 0, 27, 31 */
		/* 821B85D4h case   47:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R8,regs.R8);
		/* 821B85D4h case   47:*/		return 0x821B85D8;
		  /* 821B85D8h */ case   48:  		/* rlwinm R22, R5, 29, 3, 29 */
		/* 821B85D8h case   48:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R22,regs.R5);
		/* 821B85D8h case   48:*/		return 0x821B85DC;
		  /* 821B85DCh */ case   49:  		/* rlwinm R7, R4, 0, 27, 31 */
		/* 821B85DCh case   49:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R7,regs.R4);
		/* 821B85DCh case   49:*/		return 0x821B85E0;
		  /* 821B85E0h */ case   50:  		/* addi R20, R1, 84 */
		/* 821B85E0h case   50:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R1,0x54);
		/* 821B85E0h case   50:*/		return 0x821B85E4;
		  /* 821B85E4h */ case   51:  		/* slw R8, R30, R8 */
		/* 821B85E4h case   51:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R30,regs.R8);
		/* 821B85E4h case   51:*/		return 0x821B85E8;
		  /* 821B85E8h */ case   52:  		/* slw R7, R30, R7 */
		/* 821B85E8h case   52:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R30,regs.R7);
		/* 821B85E8h case   52:*/		return 0x821B85EC;
		  /* 821B85ECh */ case   53:  		/* lwzx R30, <#[R27 + R26]> */
		/* 821B85ECh case   53:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R27 + regs.R26 + 0x00000000) );
		/* 821B85ECh case   53:*/		return 0x821B85F0;
		  /* 821B85F0h */ case   54:  		/* lwzx R27, <#[R22 + R20]> */
		/* 821B85F0h case   54:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R22 + regs.R20 + 0x00000000) );
		/* 821B85F0h case   54:*/		return 0x821B85F4;
		  /* 821B85F4h */ case   55:  		/* addi R8, R8, -1 */
		/* 821B85F4h case   55:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 821B85F4h case   55:*/		return 0x821B85F8;
		  /* 821B85F8h */ case   56:  		/* addi R7, R7, -1 */
		/* 821B85F8h case   56:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0xFFFFFFFF);
		/* 821B85F8h case   56:*/		return 0x821B85FC;
		  /* 821B85FCh */ case   57:  		/* rlwinm R26, R5, 0, 27, 31 */
		/* 821B85FCh case   57:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R26,regs.R5);
		/* 821B85FCh case   57:*/		return 0x821B8600;
		  /* 821B8600h */ case   58:  		/* rlwinm R22, R11, 0, 27, 31 */
		/* 821B8600h case   58:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R22,regs.R11);
		/* 821B8600h case   58:*/		return 0x821B8604;
		  /* 821B8604h */ case   59:  		/* and R8, R8, R30 */
		/* 821B8604h case   59:*/		cpu::op::and<0>(regs,&regs.R8,regs.R8,regs.R30);
		/* 821B8604h case   59:*/		return 0x821B8608;
		  /* 821B8608h */ case   60:  		/* and R7, R7, R27 */
		/* 821B8608h case   60:*/		cpu::op::and<0>(regs,&regs.R7,regs.R7,regs.R27);
		/* 821B8608h case   60:*/		return 0x821B860C;
		  /* 821B860Ch */ case   61:  		/* slw R30, R15, R22 */
		/* 821B860Ch case   61:*/		cpu::op::slw<0>(regs,&regs.R30,regs.R15,regs.R22);
		/* 821B860Ch case   61:*/		return 0x821B8610;
		  /* 821B8610h */ case   62:  		/* slw R27, R15, R26 */
		/* 821B8610h case   62:*/		cpu::op::slw<0>(regs,&regs.R27,regs.R15,regs.R26);
		/* 821B8610h case   62:*/		return 0x821B8614;
		  /* 821B8614h */ case   63:  		/* and R8, R8, R30 */
		/* 821B8614h case   63:*/		cpu::op::and<0>(regs,&regs.R8,regs.R8,regs.R30);
		/* 821B8614h case   63:*/		return 0x821B8618;
		  /* 821B8618h */ case   64:  		/* and R7, R7, R27 */
		/* 821B8618h case   64:*/		cpu::op::and<0>(regs,&regs.R7,regs.R7,regs.R27);
		/* 821B8618h case   64:*/		return 0x821B861C;
		  /* 821B861Ch */ case   65:  		/* lwz R27, <#[R1 + 88]> */
		/* 821B861Ch case   65:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x00000058) );
		/* 821B861Ch case   65:*/		return 0x821B8620;
		  /* 821B8620h */ case   66:  		/* srw R8, R8, R22 */
		/* 821B8620h case   66:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R8,regs.R22);
		/* 821B8620h case   66:*/		return 0x821B8624;
		  /* 821B8624h */ case   67:  		/* srw R7, R7, R26 */
		/* 821B8624h case   67:*/		cpu::op::srw<0>(regs,&regs.R7,regs.R7,regs.R26);
		/* 821B8624h case   67:*/		return 0x821B8628;
		  /* 821B8628h */ case   68:  		/* cmplw CR6, R8, R7 */
		/* 821B8628h case   68:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 821B8628h case   68:*/		return 0x821B862C;
		  /* 821B862Ch */ case   69:  		/* li R30, 2 */
		/* 821B862Ch case   69:*/		cpu::op::li<0>(regs,&regs.R30,0x2);
		/* 821B862Ch case   69:*/		return 0x821B8630;
		  /* 821B8630h */ case   70:  		/* bc 4, CR6_EQ, 32 */
		/* 821B8630h case   70:*/		if ( !regs.CR[6].eq ) { return 0x821B8650;  }
		/* 821B8630h case   70:*/		return 0x821B8634;
		  /* 821B8634h */ case   71:  		/* li R8, 1 */
		/* 821B8634h case   71:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 821B8634h case   71:*/		return 0x821B8638;
		  /* 821B8638h */ case   72:  		/* lwzx R7, <#[R9 + R10]> */
		/* 821B8638h case   72:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 821B8638h case   72:*/		return 0x821B863C;
		  /* 821B863Ch */ case   73:  		/* addi R21, R21, 1 */
		/* 821B863Ch case   73:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R21,0x1);
		/* 821B863Ch case   73:*/		return 0x821B8640;
		  /* 821B8640h */ case   74:  		/* slw R8, R8, R6 */
		/* 821B8640h case   74:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R8,regs.R6);
		/* 821B8640h case   74:*/		return 0x821B8644;
		  /* 821B8644h */ case   75:  		/* slw R8, R8, R3 */
		/* 821B8644h case   75:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R8,regs.R3);
		/* 821B8644h case   75:*/		return 0x821B8648;
		  /* 821B8648h */ case   76:  		/* or R8, R8, R7 */
		/* 821B8648h case   76:*/		cpu::op::or<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 821B8648h case   76:*/		return 0x821B864C;
		  /* 821B864Ch */ case   77:  		/* stwx R8, <#[R9 + R10]> */
		/* 821B864Ch case   77:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 821B864Ch case   77:*/		return 0x821B8650;
	}
	return 0x821B8650;
} // Block from 821B8518h-821B8650h (78 instructions)

//////////////////////////////////////////////////////
// Block at 821B8650h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8650( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8650) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8650);
		  /* 821B8650h */ case    0:  		/* addi R6, R6, 1 */
		/* 821B8650h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821B8650h case    0:*/		return 0x821B8654;
		  /* 821B8654h */ case    1:  		/* addi R29, R29, 4 */
		/* 821B8654h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 821B8654h case    1:*/		return 0x821B8658;
		  /* 821B8658h */ case    2:  		/* addi R11, R11, 5 */
		/* 821B8658h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x5);
		/* 821B8658h case    2:*/		return 0x821B865C;
		  /* 821B865Ch */ case    3:  		/* bc 16, CR0_LT, -184 */
		/* 821B865Ch case    3:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x821B85A4;  }
		/* 821B865Ch case    3:*/		return 0x821B8660;
		  /* 821B8660h */ case    4:  		/* lwz R26, <#[R1 + 452]> */
		/* 821B8660h case    4:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x000001C4) );
		/* 821B8660h case    4:*/		return 0x821B8664;
		  /* 821B8664h */ case    5:  		/* li R22, 1 */
		/* 821B8664h case    5:*/		cpu::op::li<0>(regs,&regs.R22,0x1);
		/* 821B8664h case    5:*/		return 0x821B8668;
	}
	return 0x821B8668;
} // Block from 821B8650h-821B8668h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821B8668h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8668( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8668) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8668);
		  /* 821B8668h */ case    0:  		/* addi R17, R17, 1 */
		/* 821B8668h case    0:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R17,0x1);
		/* 821B8668h case    0:*/		return 0x821B866C;
		  /* 821B866Ch */ case    1:  		/* addi R28, R28, 4 */
		/* 821B866Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 821B866Ch case    1:*/		return 0x821B8670;
	}
	return 0x821B8670;
} // Block from 821B8668h-821B8670h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B8670h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8670( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8670) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8670);
		  /* 821B8670h */ case    0:  		/* addi R31, R31, 1 */
		/* 821B8670h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 821B8670h case    0:*/		return 0x821B8674;
		  /* 821B8674h */ case    1:  		/* addi R24, R24, 4 */
		/* 821B8674h case    1:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x4);
		/* 821B8674h case    1:*/		return 0x821B8678;
		  /* 821B8678h */ case    2:  		/* addi R25, R25, 4 */
		/* 821B8678h case    2:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x4);
		/* 821B8678h case    2:*/		return 0x821B867C;
		  /* 821B867Ch */ case    3:  		/* addi R5, R5, 5 */
		/* 821B867Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x5);
		/* 821B867Ch case    3:*/		return 0x821B8680;
		  /* 821B8680h */ case    4:  		/* cmplw CR6, R31, R14 */
		/* 821B8680h case    4:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R14);
		/* 821B8680h case    4:*/		return 0x821B8684;
		  /* 821B8684h */ case    5:  		/* bc 12, CR6_LT, -336 */
		/* 821B8684h case    5:*/		if ( regs.CR[6].lt ) { return 0x821B8534;  }
		/* 821B8684h case    5:*/		return 0x821B8688;
	}
	return 0x821B8688;
} // Block from 821B8670h-821B8688h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821B8688h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8688( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8688) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8688);
		  /* 821B8688h */ case    0:  		/* li R20, 0 */
		/* 821B8688h case    0:*/		cpu::op::li<0>(regs,&regs.R20,0x0);
		/* 821B8688h case    0:*/		return 0x821B868C;
		  /* 821B868Ch */ case    1:  		/* b -896 */
		/* 821B868Ch case    1:*/		return 0x821B830C;
		/* 821B868Ch case    1:*/		return 0x821B8690;
	}
	return 0x821B8690;
} // Block from 821B8688h-821B8690h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B8690h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8690( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8690) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8690);
		  /* 821B8690h */ case    0:  		/* lwz R3, <#[R1 + 436]> */
		/* 821B8690h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x000001B4) );
		/* 821B8690h case    0:*/		return 0x821B8694;
		  /* 821B8694h */ case    1:  		/* mr R4, R26 */
		/* 821B8694h case    1:*/		regs.R4 = regs.R26;
		/* 821B8694h case    1:*/		return 0x821B8698;
		  /* 821B8698h */ case    2:  		/* b -2064 */
		/* 821B8698h case    2:*/		return 0x821B7E88;
		/* 821B8698h case    2:*/		return 0x821B869C;
	}
	return 0x821B869C;
} // Block from 821B8690h-821B869Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 821B869Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B869C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B869C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B869C);
		  /* 821B869Ch */ case    0:  		/* rlwinm R9, R5, 29, 3, 29 */
		/* 821B869Ch case    0:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R9,regs.R5);
		/* 821B869Ch case    0:*/		return 0x821B86A0;
		  /* 821B86A0h */ case    1:  		/* addi R10, R1, 80 */
		/* 821B86A0h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 821B86A0h case    1:*/		return 0x821B86A4;
		  /* 821B86A4h */ case    2:  		/* slw R11, R22, R7 */
		/* 821B86A4h case    2:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R22,regs.R7);
		/* 821B86A4h case    2:*/		return 0x821B86A8;
		  /* 821B86A8h */ case    3:  		/* rlwinm R8, R5, 0, 27, 31 */
		/* 821B86A8h case    3:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R8,regs.R5);
		/* 821B86A8h case    3:*/		return 0x821B86AC;
		  /* 821B86ACh */ case    4:  		/* lwzx R6, <#[R9 + R10]> */
		/* 821B86ACh case    4:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 821B86ACh case    4:*/		return 0x821B86B0;
		  /* 821B86B0h */ case    5:  		/* addi R21, R21, 1 */
		/* 821B86B0h case    5:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R21,0x1);
		/* 821B86B0h case    5:*/		return 0x821B86B4;
		  /* 821B86B4h */ case    6:  		/* slw R29, R11, R8 */
		/* 821B86B4h case    6:*/		cpu::op::slw<0>(regs,&regs.R29,regs.R11,regs.R8);
		/* 821B86B4h case    6:*/		return 0x821B86B8;
		  /* 821B86B8h */ case    7:  		/* addi R11, R7, 1 */
		/* 821B86B8h case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R7,0x1);
		/* 821B86B8h case    7:*/		return 0x821B86BC;
		  /* 821B86BCh */ case    8:  		/* or R6, R29, R6 */
		/* 821B86BCh case    8:*/		cpu::op::or<0>(regs,&regs.R6,regs.R29,regs.R6);
		/* 821B86BCh case    8:*/		return 0x821B86C0;
		  /* 821B86C0h */ case    9:  		/* cmplw CR6, R11, R14 */
		/* 821B86C0h case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R14);
		/* 821B86C0h case    9:*/		return 0x821B86C4;
		  /* 821B86C4h */ case   10:  		/* stwx R6, <#[R9 + R10]> */
		/* 821B86C4h case   10:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 821B86C4h case   10:*/		return 0x821B86C8;
		  /* 821B86C8h */ case   11:  		/* bc 4, CR6_LT, 84 */
		/* 821B86C8h case   11:*/		if ( !regs.CR[6].lt ) { return 0x821B871C;  }
		/* 821B86C8h case   11:*/		return 0x821B86CC;
		  /* 821B86CCh */ case   12:  		/* subf R29, R11, R14 */
		/* 821B86CCh case   12:*/		cpu::op::subf<0>(regs,&regs.R29,regs.R11,regs.R14);
		/* 821B86CCh case   12:*/		return 0x821B86D0;
		  /* 821B86D0h */ case   13:  		/* addi R6, R4, 4 */
		/* 821B86D0h case   13:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R4,0x4);
		/* 821B86D0h case   13:*/		return 0x821B86D4;
		  /* 821B86D4h */ case   14:  		/* mtspr CTR, R29 */
		/* 821B86D4h case   14:*/		regs.CTR = regs.R29;
		/* 821B86D4h case   14:*/		return 0x821B86D8;
		  /* 821B86D8h */ case   15:  		/* lwz R29, <#[R1 + 80]> */
		/* 821B86D8h case   15:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 821B86D8h case   15:*/		return 0x821B86DC;
		  /* 821B86DCh */ case   16:  		/* slw R28, R16, R11 */
		/* 821B86DCh case   16:*/		cpu::op::slw<0>(regs,&regs.R28,regs.R16,regs.R11);
		/* 821B86DCh case   16:*/		return 0x821B86E0;
		  /* 821B86E0h */ case   17:  		/* and. R29, R28, R29 */
		/* 821B86E0h case   17:*/		cpu::op::and<1>(regs,&regs.R29,regs.R28,regs.R29);
		/* 821B86E0h case   17:*/		return 0x821B86E4;
		  /* 821B86E4h */ case   18:  		/* bc 4, CR0_EQ, 44 */
		/* 821B86E4h case   18:*/		if ( !regs.CR[0].eq ) { return 0x821B8710;  }
		/* 821B86E4h case   18:*/		return 0x821B86E8;
		  /* 821B86E8h */ case   19:  		/* lwz R29, <#[R6]> */
		/* 821B86E8h case   19:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R6 + 0x00000000) );
		/* 821B86E8h case   19:*/		return 0x821B86EC;
		  /* 821B86ECh */ case   20:  		/* lwz R28, <#[R4]> */
		/* 821B86ECh case   20:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R4 + 0x00000000) );
		/* 821B86ECh case   20:*/		return 0x821B86F0;
		  /* 821B86F0h */ case   21:  		/* cmplw CR6, R28, R29 */
		/* 821B86F0h case   21:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R29);
		/* 821B86F0h case   21:*/		return 0x821B86F4;
		  /* 821B86F4h */ case   22:  		/* bc 4, CR6_EQ, 28 */
		/* 821B86F4h case   22:*/		if ( !regs.CR[6].eq ) { return 0x821B8710;  }
		/* 821B86F4h case   22:*/		return 0x821B86F8;
		  /* 821B86F8h */ case   23:  		/* slw R29, R22, R11 */
		/* 821B86F8h case   23:*/		cpu::op::slw<0>(regs,&regs.R29,regs.R22,regs.R11);
		/* 821B86F8h case   23:*/		return 0x821B86FC;
		  /* 821B86FCh */ case   24:  		/* lwzx R28, <#[R9 + R10]> */
		/* 821B86FCh case   24:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 821B86FCh case   24:*/		return 0x821B8700;
		  /* 821B8700h */ case   25:  		/* slw R29, R29, R8 */
		/* 821B8700h case   25:*/		cpu::op::slw<0>(regs,&regs.R29,regs.R29,regs.R8);
		/* 821B8700h case   25:*/		return 0x821B8704;
		  /* 821B8704h */ case   26:  		/* or R29, R29, R28 */
		/* 821B8704h case   26:*/		cpu::op::or<0>(regs,&regs.R29,regs.R29,regs.R28);
		/* 821B8704h case   26:*/		return 0x821B8708;
		  /* 821B8708h */ case   27:  		/* addi R21, R21, 1 */
		/* 821B8708h case   27:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R21,0x1);
		/* 821B8708h case   27:*/		return 0x821B870C;
		  /* 821B870Ch */ case   28:  		/* stwx R29, <#[R9 + R10]> */
		/* 821B870Ch case   28:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 821B870Ch case   28:*/		return 0x821B8710;
	}
	return 0x821B8710;
} // Block from 821B869Ch-821B8710h (29 instructions)

//////////////////////////////////////////////////////
// Block at 821B8710h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8710( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8710) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8710);
		  /* 821B8710h */ case    0:  		/* addi R11, R11, 1 */
		/* 821B8710h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821B8710h case    0:*/		return 0x821B8714;
		  /* 821B8714h */ case    1:  		/* addi R6, R6, 4 */
		/* 821B8714h case    1:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x4);
		/* 821B8714h case    1:*/		return 0x821B8718;
		  /* 821B8718h */ case    2:  		/* bc 16, CR0_LT, -64 */
		/* 821B8718h case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x821B86D8;  }
		/* 821B8718h case    2:*/		return 0x821B871C;
	}
	return 0x821B871C;
} // Block from 821B8710h-821B871Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 821B871Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B871C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B871C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B871C);
		  /* 821B871Ch */ case    0:  		/* addi R17, R17, 1 */
		/* 821B871Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R17,0x1);
		/* 821B871Ch case    0:*/		return 0x821B8720;
		  /* 821B8720h */ case    1:  		/* addi R5, R5, 4 */
		/* 821B8720h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x4);
		/* 821B8720h case    1:*/		return 0x821B8724;
	}
	return 0x821B8724;
} // Block from 821B871Ch-821B8724h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B8724h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8724( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8724) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8724);
		  /* 821B8724h */ case    0:  		/* addi R7, R7, 1 */
		/* 821B8724h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x1);
		/* 821B8724h case    0:*/		return 0x821B8728;
		  /* 821B8728h */ case    1:  		/* addi R3, R3, 4 */
		/* 821B8728h case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x4);
		/* 821B8728h case    1:*/		return 0x821B872C;
		  /* 821B872Ch */ case    2:  		/* addi R4, R4, 4 */
		/* 821B872Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x4);
		/* 821B872Ch case    2:*/		return 0x821B8730;
		  /* 821B8730h */ case    3:  		/* cmplw CR6, R7, R14 */
		/* 821B8730h case    3:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R14);
		/* 821B8730h case    3:*/		return 0x821B8734;
		  /* 821B8734h */ case    4:  		/* bc 12, CR6_LT, -608 */
		/* 821B8734h case    4:*/		if ( regs.CR[6].lt ) { return 0x821B84D4;  }
		/* 821B8734h case    4:*/		return 0x821B8738;
	}
	return 0x821B8738;
} // Block from 821B8724h-821B8738h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821B8738h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8738( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8738) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8738);
		  /* 821B8738h */ case    0:  		/* lis R11, -28311 */
		/* 821B8738h case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF9169);
		/* 821B8738h case    0:*/		return 0x821B873C;
		  /* 821B873Ch */ case    1:  		/* addi R9, R1, 96 */
		/* 821B873Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x60);
		/* 821B873Ch case    1:*/		return 0x821B8740;
		  /* 821B8740h */ case    2:  		/* addi R8, R1, 88 */
		/* 821B8740h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x58);
		/* 821B8740h case    2:*/		return 0x821B8744;
		  /* 821B8744h */ case    3:  		/* addi R7, R1, 104 */
		/* 821B8744h case    3:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x68);
		/* 821B8744h case    3:*/		return 0x821B8748;
		  /* 821B8748h */ case    4:  		/* lis R10, 0 */
		/* 821B8748h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0x0);
		/* 821B8748h case    4:*/		return 0x821B874C;
		  /* 821B874Ch */ case    5:  		/* ori R28, R11, 5192 */
		/* 821B874Ch case    5:*/		cpu::op::ori<0>(regs,&regs.R28,regs.R11,0x1448);
		/* 821B874Ch case    5:*/		return 0x821B8750;
		  /* 821B8750h */ case    6:  		/* ori R11, R10, 36262 */
		/* 821B8750h case    6:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R10,0x8DA6);
		/* 821B8750h case    6:*/		return 0x821B8754;
		  /* 821B8754h */ case    7:  		/* stw R24, <#[R9]> */
		/* 821B8754h case    7:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R9 + 0x00000000) );
		/* 821B8754h case    7:*/		return 0x821B8758;
		  /* 821B8758h */ case    8:  		/* stw R24, <#[R8]> */
		/* 821B8758h case    8:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R8 + 0x00000000) );
		/* 821B8758h case    8:*/		return 0x821B875C;
		  /* 821B875Ch */ case    9:  		/* stw R24, <#[R7]> */
		/* 821B875Ch case    9:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R7 + 0x00000000) );
		/* 821B875Ch case    9:*/		return 0x821B8760;
		  /* 821B8760h */ case   10:  		/* mr R25, R24 */
		/* 821B8760h case   10:*/		regs.R25 = regs.R24;
		/* 821B8760h case   10:*/		return 0x821B8764;
		  /* 821B8764h */ case   11:  		/* rldimi R28, R11, 32, 0 */
		/* 821B8764h case   11:*/		cpu::op::rldimi<0,32,0>(regs,&regs.R28,regs.R11);
		/* 821B8764h case   11:*/		return 0x821B8768;
		  /* 821B8768h */ case   12:  		/* mr R31, R24 */
		/* 821B8768h case   12:*/		regs.R31 = regs.R24;
		/* 821B8768h case   12:*/		return 0x821B876C;
		  /* 821B876Ch */ case   13:  		/* mr R6, R24 */
		/* 821B876Ch case   13:*/		regs.R6 = regs.R24;
		/* 821B876Ch case   13:*/		return 0x821B8770;
		  /* 821B8770h */ case   14:  		/* cmplwi CR6, R14, 0 */
		/* 821B8770h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R14,0x00000000);
		/* 821B8770h case   14:*/		return 0x821B8774;
		  /* 821B8774h */ case   15:  		/* bc 12, CR6_EQ, 428 */
		/* 821B8774h case   15:*/		if ( regs.CR[6].eq ) { return 0x821B8920;  }
		/* 821B8774h case   15:*/		return 0x821B8778;
		  /* 821B8778h */ case   16:  		/* rlwinm R3, R17, 2, 0, 29 */
		/* 821B8778h case   16:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R3,regs.R17);
		/* 821B8778h case   16:*/		return 0x821B877C;
		  /* 821B877Ch */ case   17:  		/* mr R4, R24 */
		/* 821B877Ch case   17:*/		regs.R4 = regs.R24;
		/* 821B877Ch case   17:*/		return 0x821B8780;
		  /* 821B8780h */ case   18:  		/* lwz R8, <#[R1 + 80]> */
		/* 821B8780h case   18:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000050) );
		/* 821B8780h case   18:*/		return 0x821B8784;
		  /* 821B8784h */ case   19:  		/* slw R11, R16, R6 */
		/* 821B8784h case   19:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R16,regs.R6);
		/* 821B8784h case   19:*/		return 0x821B8788;
		  /* 821B8788h */ case   20:  		/* and. R11, R11, R8 */
		/* 821B8788h case   20:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R8);
		/* 821B8788h case   20:*/		return 0x821B878C;
		  /* 821B878Ch */ case   21:  		/* bc 4, CR0_EQ, 388 */
		/* 821B878Ch case   21:*/		if ( !regs.CR[0].eq ) { return 0x821B8910;  }
		/* 821B878Ch case   21:*/		return 0x821B8790;
		  /* 821B8790h */ case   22:  		/* addi R11, R1, 112 */
		/* 821B8790h case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 821B8790h case   22:*/		return 0x821B8794;
		  /* 821B8794h */ case   23:  		/* add R7, R4, R11 */
		/* 821B8794h case   23:*/		cpu::op::add<0>(regs,&regs.R7,regs.R4,regs.R11);
		/* 821B8794h case   23:*/		return 0x821B8798;
		  /* 821B8798h */ case   24:  		/* lwzx R5, <#[R4 + R11]> */
		/* 821B8798h case   24:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R4 + regs.R11 + 0x00000000) );
		/* 821B8798h case   24:*/		return 0x821B879C;
		  /* 821B879Ch */ case   25:  		/* lwz R11, <#[R5 + 8]> */
		/* 821B879Ch case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000008) );
		/* 821B879Ch case   25:*/		return 0x821B87A0;
		  /* 821B87A0h */ case   26:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821B87A0h case   26:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821B87A0h case   26:*/		return 0x821B87A4;
		  /* 821B87A4h */ case   27:  		/* cmplwi CR6, R11, 125 */
		/* 821B87A4h case   27:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 821B87A4h case   27:*/		return 0x821B87A8;
		  /* 821B87A8h */ case   28:  		/* bc 12, CR6_EQ, 16 */
		/* 821B87A8h case   28:*/		if ( regs.CR[6].eq ) { return 0x821B87B8;  }
		/* 821B87A8h case   28:*/		return 0x821B87AC;
		  /* 821B87ACh */ case   29:  		/* cmplwi CR6, R11, 124 */
		/* 821B87ACh case   29:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 821B87ACh case   29:*/		return 0x821B87B0;
		  /* 821B87B0h */ case   30:  		/* mr R11, R24 */
		/* 821B87B0h case   30:*/		regs.R11 = regs.R24;
		/* 821B87B0h case   30:*/		return 0x821B87B4;
		  /* 821B87B4h */ case   31:  		/* bc 4, CR6_EQ, 8 */
		/* 821B87B4h case   31:*/		if ( !regs.CR[6].eq ) { return 0x821B87BC;  }
		/* 821B87B4h case   31:*/		return 0x821B87B8;
	}
	return 0x821B87B8;
} // Block from 821B8738h-821B87B8h (32 instructions)

//////////////////////////////////////////////////////
// Block at 821B87B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B87B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B87B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B87B8);
		  /* 821B87B8h */ case    0:  		/* mr R11, R22 */
		/* 821B87B8h case    0:*/		regs.R11 = regs.R22;
		/* 821B87B8h case    0:*/		return 0x821B87BC;
	}
	return 0x821B87BC;
} // Block from 821B87B8h-821B87BCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B87BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B87BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B87BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B87BC);
		  /* 821B87BCh */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821B87BCh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821B87BCh case    0:*/		return 0x821B87C0;
		  /* 821B87C0h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 821B87C0h case    1:*/		if ( regs.CR[0].eq ) { return 0x821B87CC;  }
		/* 821B87C0h case    1:*/		return 0x821B87C4;
		  /* 821B87C4h */ case    2:  		/* addi R31, R31, 1 */
		/* 821B87C4h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 821B87C4h case    2:*/		return 0x821B87C8;
		  /* 821B87C8h */ case    3:  		/* b 328 */
		/* 821B87C8h case    3:*/		return 0x821B8910;
		/* 821B87C8h case    3:*/		return 0x821B87CC;
	}
	return 0x821B87CC;
} // Block from 821B87BCh-821B87CCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 821B87CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B87CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B87CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B87CC);
		  /* 821B87CCh */ case    0:  		/* lwz R11, <#[R5 + 8]> */
		/* 821B87CCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000008) );
		/* 821B87CCh case    0:*/		return 0x821B87D0;
		  /* 821B87D0h */ case    1:  		/* rlwinm R9, R11, 31, 28, 31 */
		/* 821B87D0h case    1:*/		cpu::op::rlwinm<0,31,28,31>(regs,&regs.R9,regs.R11);
		/* 821B87D0h case    1:*/		return 0x821B87D4;
		  /* 821B87D4h */ case    2:  		/* srd R11, R28, R9 */
		/* 821B87D4h case    2:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R28,regs.R9);
		/* 821B87D4h case    2:*/		return 0x821B87D8;
		  /* 821B87D8h */ case    3:  		/* srd R11, R11, R9 */
		/* 821B87D8h case    3:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 821B87D8h case    3:*/		return 0x821B87DC;
		  /* 821B87DCh */ case    4:  		/* srd R11, R11, R9 */
		/* 821B87DCh case    4:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 821B87DCh case    4:*/		return 0x821B87E0;
		  /* 821B87E0h */ case    5:  		/* rlwinm R11, R11, 0, 29, 31 */
		/* 821B87E0h case    5:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R11,regs.R11);
		/* 821B87E0h case    5:*/		return 0x821B87E4;
		  /* 821B87E4h */ case    6:  		/* cmplwi CR6, R11, 4 */
		/* 821B87E4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 821B87E4h case    6:*/		return 0x821B87E8;
		  /* 821B87E8h */ case    7:  		/* bc 4, CR6_EQ, 140 */
		/* 821B87E8h case    7:*/		if ( !regs.CR[6].eq ) { return 0x821B8874;  }
		/* 821B87E8h case    7:*/		return 0x821B87EC;
		  /* 821B87ECh */ case    8:  		/* rlwinm R9, R3, 29, 3, 29 */
		/* 821B87ECh case    8:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R9,regs.R3);
		/* 821B87ECh case    8:*/		return 0x821B87F0;
		  /* 821B87F0h */ case    9:  		/* addi R10, R1, 80 */
		/* 821B87F0h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x50);
		/* 821B87F0h case    9:*/		return 0x821B87F4;
		  /* 821B87F4h */ case   10:  		/* slw R11, R22, R6 */
		/* 821B87F4h case   10:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R22,regs.R6);
		/* 821B87F4h case   10:*/		return 0x821B87F8;
		  /* 821B87F8h */ case   11:  		/* rlwinm R8, R3, 0, 27, 31 */
		/* 821B87F8h case   11:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R8,regs.R3);
		/* 821B87F8h case   11:*/		return 0x821B87FC;
		  /* 821B87FCh */ case   12:  		/* lwzx R29, <#[R9 + R10]> */
		/* 821B87FCh case   12:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 821B87FCh case   12:*/		return 0x821B8800;
		  /* 821B8800h */ case   13:  		/* addi R21, R21, 1 */
		/* 821B8800h case   13:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R21,0x1);
		/* 821B8800h case   13:*/		return 0x821B8804;
		  /* 821B8804h */ case   14:  		/* slw R23, R11, R8 */
		/* 821B8804h case   14:*/		cpu::op::slw<0>(regs,&regs.R23,regs.R11,regs.R8);
		/* 821B8804h case   14:*/		return 0x821B8808;
		  /* 821B8808h */ case   15:  		/* addi R11, R6, 1 */
		/* 821B8808h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R6,0x1);
		/* 821B8808h case   15:*/		return 0x821B880C;
		  /* 821B880Ch */ case   16:  		/* or R29, R23, R29 */
		/* 821B880Ch case   16:*/		cpu::op::or<0>(regs,&regs.R29,regs.R23,regs.R29);
		/* 821B880Ch case   16:*/		return 0x821B8810;
		  /* 821B8810h */ case   17:  		/* cmplw CR6, R11, R14 */
		/* 821B8810h case   17:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R14);
		/* 821B8810h case   17:*/		return 0x821B8814;
		  /* 821B8814h */ case   18:  		/* stwx R29, <#[R9 + R10]> */
		/* 821B8814h case   18:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 821B8814h case   18:*/		return 0x821B8818;
		  /* 821B8818h */ case   19:  		/* bc 4, CR6_LT, 80 */
		/* 821B8818h case   19:*/		if ( !regs.CR[6].lt ) { return 0x821B8868;  }
		/* 821B8818h case   19:*/		return 0x821B881C;
		  /* 821B881Ch */ case   20:  		/* subf R29, R11, R14 */
		/* 821B881Ch case   20:*/		cpu::op::subf<0>(regs,&regs.R29,regs.R11,regs.R14);
		/* 821B881Ch case   20:*/		return 0x821B8820;
		  /* 821B8820h */ case   21:  		/* addi R7, R7, 4 */
		/* 821B8820h case   21:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 821B8820h case   21:*/		return 0x821B8824;
		  /* 821B8824h */ case   22:  		/* mtspr CTR, R29 */
		/* 821B8824h case   22:*/		regs.CTR = regs.R29;
		/* 821B8824h case   22:*/		return 0x821B8828;
		  /* 821B8828h */ case   23:  		/* lwz R29, <#[R1 + 80]> */
		/* 821B8828h case   23:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x00000050) );
		/* 821B8828h case   23:*/		return 0x821B882C;
		  /* 821B882Ch */ case   24:  		/* slw R23, R16, R11 */
		/* 821B882Ch case   24:*/		cpu::op::slw<0>(regs,&regs.R23,regs.R16,regs.R11);
		/* 821B882Ch case   24:*/		return 0x821B8830;
		  /* 821B8830h */ case   25:  		/* and. R29, R23, R29 */
		/* 821B8830h case   25:*/		cpu::op::and<1>(regs,&regs.R29,regs.R23,regs.R29);
		/* 821B8830h case   25:*/		return 0x821B8834;
		  /* 821B8834h */ case   26:  		/* bc 4, CR0_EQ, 40 */
		/* 821B8834h case   26:*/		if ( !regs.CR[0].eq ) { return 0x821B885C;  }
		/* 821B8834h case   26:*/		return 0x821B8838;
		  /* 821B8838h */ case   27:  		/* lwz R29, <#[R7]> */
		/* 821B8838h case   27:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R7 + 0x00000000) );
		/* 821B8838h case   27:*/		return 0x821B883C;
		  /* 821B883Ch */ case   28:  		/* cmplw CR6, R5, R29 */
		/* 821B883Ch case   28:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R29);
		/* 821B883Ch case   28:*/		return 0x821B8840;
		  /* 821B8840h */ case   29:  		/* bc 4, CR6_EQ, 28 */
		/* 821B8840h case   29:*/		if ( !regs.CR[6].eq ) { return 0x821B885C;  }
		/* 821B8840h case   29:*/		return 0x821B8844;
		  /* 821B8844h */ case   30:  		/* slw R29, R22, R11 */
		/* 821B8844h case   30:*/		cpu::op::slw<0>(regs,&regs.R29,regs.R22,regs.R11);
		/* 821B8844h case   30:*/		return 0x821B8848;
		  /* 821B8848h */ case   31:  		/* lwzx R23, <#[R9 + R10]> */
		/* 821B8848h case   31:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 821B8848h case   31:*/		return 0x821B884C;
		  /* 821B884Ch */ case   32:  		/* slw R29, R29, R8 */
		/* 821B884Ch case   32:*/		cpu::op::slw<0>(regs,&regs.R29,regs.R29,regs.R8);
		/* 821B884Ch case   32:*/		return 0x821B8850;
		  /* 821B8850h */ case   33:  		/* or R29, R29, R23 */
		/* 821B8850h case   33:*/		cpu::op::or<0>(regs,&regs.R29,regs.R29,regs.R23);
		/* 821B8850h case   33:*/		return 0x821B8854;
		  /* 821B8854h */ case   34:  		/* addi R21, R21, 1 */
		/* 821B8854h case   34:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R21,0x1);
		/* 821B8854h case   34:*/		return 0x821B8858;
		  /* 821B8858h */ case   35:  		/* stwx R29, <#[R9 + R10]> */
		/* 821B8858h case   35:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 821B8858h case   35:*/		return 0x821B885C;
	}
	return 0x821B885C;
} // Block from 821B87CCh-821B885Ch (36 instructions)

//////////////////////////////////////////////////////
// Block at 821B885Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B885C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B885C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B885C);
		  /* 821B885Ch */ case    0:  		/* addi R11, R11, 1 */
		/* 821B885Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821B885Ch case    0:*/		return 0x821B8860;
		  /* 821B8860h */ case    1:  		/* addi R7, R7, 4 */
		/* 821B8860h case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 821B8860h case    1:*/		return 0x821B8864;
		  /* 821B8864h */ case    2:  		/* bc 16, CR0_LT, -60 */
		/* 821B8864h case    2:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x821B8828;  }
		/* 821B8864h case    2:*/		return 0x821B8868;
	}
	return 0x821B8868;
} // Block from 821B885Ch-821B8868h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821B8868h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8868( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8868) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8868);
		  /* 821B8868h */ case    0:  		/* addi R17, R17, 1 */
		/* 821B8868h case    0:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R17,0x1);
		/* 821B8868h case    0:*/		return 0x821B886C;
		  /* 821B886Ch */ case    1:  		/* addi R3, R3, 4 */
		/* 821B886Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x4);
		/* 821B886Ch case    1:*/		return 0x821B8870;
		  /* 821B8870h */ case    2:  		/* b 160 */
		/* 821B8870h case    2:*/		return 0x821B8910;
		/* 821B8870h case    2:*/		return 0x821B8874;
	}
	return 0x821B8874;
} // Block from 821B8868h-821B8874h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821B8874h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8874( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8874) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8874);
		  /* 821B8874h */ case    0:  		/* mr R10, R24 */
		/* 821B8874h case    0:*/		regs.R10 = regs.R24;
		/* 821B8874h case    0:*/		return 0x821B8878;
		  /* 821B8878h */ case    1:  		/* cmplwi CR6, R6, 0 */
		/* 821B8878h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 821B8878h case    1:*/		return 0x821B887C;
		  /* 821B887Ch */ case    2:  		/* bc 12, CR6_EQ, 48 */
		/* 821B887Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x821B88AC;  }
		/* 821B887Ch case    2:*/		return 0x821B8880;
		  /* 821B8880h */ case    3:  		/* addi R11, R1, 112 */
		/* 821B8880h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 821B8880h case    3:*/		return 0x821B8884;
		  /* 821B8884h */ case    4:  		/* slw R7, R16, R10 */
		/* 821B8884h case    4:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R16,regs.R10);
		/* 821B8884h case    4:*/		return 0x821B8888;
		  /* 821B8888h */ case    5:  		/* and. R7, R7, R8 */
		/* 821B8888h case    5:*/		cpu::op::and<1>(regs,&regs.R7,regs.R7,regs.R8);
		/* 821B8888h case    5:*/		return 0x821B888C;
		  /* 821B888Ch */ case    6:  		/* bc 4, CR0_EQ, 16 */
		/* 821B888Ch case    6:*/		if ( !regs.CR[0].eq ) { return 0x821B889C;  }
		/* 821B888Ch case    6:*/		return 0x821B8890;
		  /* 821B8890h */ case    7:  		/* lwz R7, <#[R11]> */
		/* 821B8890h case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821B8890h case    7:*/		return 0x821B8894;
		  /* 821B8894h */ case    8:  		/* cmplw CR6, R5, R7 */
		/* 821B8894h case    8:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R7);
		/* 821B8894h case    8:*/		return 0x821B8898;
		  /* 821B8898h */ case    9:  		/* bc 12, CR6_EQ, 20 */
		/* 821B8898h case    9:*/		if ( regs.CR[6].eq ) { return 0x821B88AC;  }
		/* 821B8898h case    9:*/		return 0x821B889C;
	}
	return 0x821B889C;
} // Block from 821B8874h-821B889Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 821B889Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B889C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B889C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B889C);
		  /* 821B889Ch */ case    0:  		/* addi R10, R10, 1 */
		/* 821B889Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821B889Ch case    0:*/		return 0x821B88A0;
		  /* 821B88A0h */ case    1:  		/* addi R11, R11, 4 */
		/* 821B88A0h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821B88A0h case    1:*/		return 0x821B88A4;
		  /* 821B88A4h */ case    2:  		/* cmplw CR6, R10, R6 */
		/* 821B88A4h case    2:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R6);
		/* 821B88A4h case    2:*/		return 0x821B88A8;
		  /* 821B88A8h */ case    3:  		/* bc 12, CR6_LT, -36 */
		/* 821B88A8h case    3:*/		if ( regs.CR[6].lt ) { return 0x821B8884;  }
		/* 821B88A8h case    3:*/		return 0x821B88AC;
	}
	return 0x821B88AC;
} // Block from 821B889Ch-821B88ACh (4 instructions)

//////////////////////////////////////////////////////
// Block at 821B88ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B88AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B88AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B88AC);
		  /* 821B88ACh */ case    0:  		/* cmplw CR6, R10, R6 */
		/* 821B88ACh case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R6);
		/* 821B88ACh case    0:*/		return 0x821B88B0;
		  /* 821B88B0h */ case    1:  		/* bc 4, CR6_EQ, 44 */
		/* 821B88B0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821B88DC;  }
		/* 821B88B0h case    1:*/		return 0x821B88B4;
		  /* 821B88B4h */ case    2:  		/* rlwinm R10, R4, 29, 3, 29 */
		/* 821B88B4h case    2:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R10,regs.R4);
		/* 821B88B4h case    2:*/		return 0x821B88B8;
		  /* 821B88B8h */ case    3:  		/* addi R11, R1, 88 */
		/* 821B88B8h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x58);
		/* 821B88B8h case    3:*/		return 0x821B88BC;
		  /* 821B88BCh */ case    4:  		/* rlwinm R8, R4, 0, 27, 31 */
		/* 821B88BCh case    4:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R8,regs.R4);
		/* 821B88BCh case    4:*/		return 0x821B88C0;
		  /* 821B88C0h */ case    5:  		/* slw R7, R22, R6 */
		/* 821B88C0h case    5:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R22,regs.R6);
		/* 821B88C0h case    5:*/		return 0x821B88C4;
		  /* 821B88C4h */ case    6:  		/* lwzx R5, <#[R10 + R11]> */
		/* 821B88C4h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821B88C4h case    6:*/		return 0x821B88C8;
		  /* 821B88C8h */ case    7:  		/* slw R9, R9, R8 */
		/* 821B88C8h case    7:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 821B88C8h case    7:*/		return 0x821B88CC;
		  /* 821B88CCh */ case    8:  		/* or R9, R9, R5 */
		/* 821B88CCh case    8:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R5);
		/* 821B88CCh case    8:*/		return 0x821B88D0;
		  /* 821B88D0h */ case    9:  		/* or R25, R7, R25 */
		/* 821B88D0h case    9:*/		cpu::op::or<0>(regs,&regs.R25,regs.R7,regs.R25);
		/* 821B88D0h case    9:*/		return 0x821B88D4;
		  /* 821B88D4h */ case   10:  		/* stwx R9, <#[R10 + R11]> */
		/* 821B88D4h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821B88D4h case   10:*/		return 0x821B88D8;
		  /* 821B88D8h */ case   11:  		/* b 56 */
		/* 821B88D8h case   11:*/		return 0x821B8910;
		/* 821B88D8h case   11:*/		return 0x821B88DC;
	}
	return 0x821B88DC;
} // Block from 821B88ACh-821B88DCh (12 instructions)

//////////////////////////////////////////////////////
// Block at 821B88DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B88DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B88DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B88DC);
		  /* 821B88DCh */ case    0:  		/* rlwinm R11, R10, 31, 3, 29 */
		/* 821B88DCh case    0:*/		cpu::op::rlwinm<0,31,3,29>(regs,&regs.R11,regs.R10);
		/* 821B88DCh case    0:*/		return 0x821B88E0;
		  /* 821B88E0h */ case    1:  		/* addi R9, R1, 96 */
		/* 821B88E0h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x60);
		/* 821B88E0h case    1:*/		return 0x821B88E4;
		  /* 821B88E4h */ case    2:  		/* addi R8, R1, 104 */
		/* 821B88E4h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R1,0x68);
		/* 821B88E4h case    2:*/		return 0x821B88E8;
		  /* 821B88E8h */ case    3:  		/* rlwinm R7, R10, 2, 27, 29 */
		/* 821B88E8h case    3:*/		cpu::op::rlwinm<0,2,27,29>(regs,&regs.R7,regs.R10);
		/* 821B88E8h case    3:*/		return 0x821B88EC;
		  /* 821B88ECh */ case    4:  		/* slw R10, R22, R6 */
		/* 821B88ECh case    4:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R22,regs.R6);
		/* 821B88ECh case    4:*/		return 0x821B88F0;
		  /* 821B88F0h */ case    5:  		/* slw R29, R10, R7 */
		/* 821B88F0h case    5:*/		cpu::op::slw<0>(regs,&regs.R29,regs.R10,regs.R7);
		/* 821B88F0h case    5:*/		return 0x821B88F4;
		  /* 821B88F4h */ case    6:  		/* lwzx R5, <#[R11 + R9]> */
		/* 821B88F4h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 821B88F4h case    6:*/		return 0x821B88F8;
		  /* 821B88F8h */ case    7:  		/* lwzx R10, <#[R11 + R8]> */
		/* 821B88F8h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 821B88F8h case    7:*/		return 0x821B88FC;
		  /* 821B88FCh */ case    8:  		/* slw R7, R22, R7 */
		/* 821B88FCh case    8:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R22,regs.R7);
		/* 821B88FCh case    8:*/		return 0x821B8900;
		  /* 821B8900h */ case    9:  		/* or R5, R29, R5 */
		/* 821B8900h case    9:*/		cpu::op::or<0>(regs,&regs.R5,regs.R29,regs.R5);
		/* 821B8900h case    9:*/		return 0x821B8904;
		  /* 821B8904h */ case   10:  		/* add R10, R7, R10 */
		/* 821B8904h case   10:*/		cpu::op::add<0>(regs,&regs.R10,regs.R7,regs.R10);
		/* 821B8904h case   10:*/		return 0x821B8908;
		  /* 821B8908h */ case   11:  		/* stwx R5, <#[R11 + R9]> */
		/* 821B8908h case   11:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 821B8908h case   11:*/		return 0x821B890C;
		  /* 821B890Ch */ case   12:  		/* stwx R10, <#[R11 + R8]> */
		/* 821B890Ch case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 821B890Ch case   12:*/		return 0x821B8910;
	}
	return 0x821B8910;
} // Block from 821B88DCh-821B8910h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821B8910h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8910( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8910) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8910);
		  /* 821B8910h */ case    0:  		/* addi R6, R6, 1 */
		/* 821B8910h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821B8910h case    0:*/		return 0x821B8914;
		  /* 821B8914h */ case    1:  		/* addi R4, R4, 4 */
		/* 821B8914h case    1:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R4,0x4);
		/* 821B8914h case    1:*/		return 0x821B8918;
		  /* 821B8918h */ case    2:  		/* cmplw CR6, R6, R14 */
		/* 821B8918h case    2:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R14);
		/* 821B8918h case    2:*/		return 0x821B891C;
		  /* 821B891Ch */ case    3:  		/* bc 12, CR6_LT, -412 */
		/* 821B891Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x821B8780;  }
		/* 821B891Ch case    3:*/		return 0x821B8920;
	}
	return 0x821B8920;
} // Block from 821B8910h-821B8920h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821B8920h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8920( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8920) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8920);
		  /* 821B8920h */ case    0:  		/* li R9, 4 */
		/* 821B8920h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x4);
		/* 821B8920h case    0:*/		return 0x821B8924;
		  /* 821B8924h */ case    1:  		/* add R10, R31, R21 */
		/* 821B8924h case    1:*/		cpu::op::add<0>(regs,&regs.R10,regs.R31,regs.R21);
		/* 821B8924h case    1:*/		return 0x821B8928;
		  /* 821B8928h */ case    2:  		/* mr R11, R24 */
		/* 821B8928h case    2:*/		regs.R11 = regs.R24;
		/* 821B8928h case    2:*/		return 0x821B892C;
		  /* 821B892Ch */ case    3:  		/* mtspr CTR, R9 */
		/* 821B892Ch case    3:*/		regs.CTR = regs.R9;
		/* 821B892Ch case    3:*/		return 0x821B8930;
		  /* 821B8930h */ case    4:  		/* addi R9, R11, 3 */
		/* 821B8930h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x3);
		/* 821B8930h case    4:*/		return 0x821B8934;
		  /* 821B8934h */ case    5:  		/* rlwinm R8, R11, 29, 3, 29 */
		/* 821B8934h case    5:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R8,regs.R11);
		/* 821B8934h case    5:*/		return 0x821B8938;
		  /* 821B8938h */ case    6:  		/* addi R7, R1, 88 */
		/* 821B8938h case    6:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x58);
		/* 821B8938h case    6:*/		return 0x821B893C;
		  /* 821B893Ch */ case    7:  		/* rlwinm R9, R9, 0, 27, 31 */
		/* 821B893Ch case    7:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R9);
		/* 821B893Ch case    7:*/		return 0x821B8940;
		  /* 821B8940h */ case    8:  		/* slw R9, R30, R9 */
		/* 821B8940h case    8:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R30,regs.R9);
		/* 821B8940h case    8:*/		return 0x821B8944;
		  /* 821B8944h */ case    9:  		/* lwzx R8, <#[R8 + R7]> */
		/* 821B8944h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + regs.R7 + 0x00000000) );
		/* 821B8944h case    9:*/		return 0x821B8948;
		  /* 821B8948h */ case   10:  		/* addi R9, R9, -1 */
		/* 821B8948h case   10:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 821B8948h case   10:*/		return 0x821B894C;
		  /* 821B894Ch */ case   11:  		/* rlwinm R7, R11, 0, 27, 31 */
		/* 821B894Ch case   11:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R7,regs.R11);
		/* 821B894Ch case   11:*/		return 0x821B8950;
		  /* 821B8950h */ case   12:  		/* and R9, R9, R8 */
		/* 821B8950h case   12:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 821B8950h case   12:*/		return 0x821B8954;
		  /* 821B8954h */ case   13:  		/* slw R6, R15, R7 */
		/* 821B8954h case   13:*/		cpu::op::slw<0>(regs,&regs.R6,regs.R15,regs.R7);
		/* 821B8954h case   13:*/		return 0x821B8958;
		  /* 821B8958h */ case   14:  		/* and R9, R9, R6 */
		/* 821B8958h case   14:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R6);
		/* 821B8958h case   14:*/		return 0x821B895C;
		  /* 821B895Ch */ case   15:  		/* addi R11, R11, 4 */
		/* 821B895Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821B895Ch case   15:*/		return 0x821B8960;
		  /* 821B8960h */ case   16:  		/* srw R9, R9, R7 */
		/* 821B8960h case   16:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 821B8960h case   16:*/		return 0x821B8964;
		  /* 821B8964h */ case   17:  		/* rldicl R9, R9, 0, 32 */
		/* 821B8964h case   17:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R9,regs.R9);
		/* 821B8964h case   17:*/		return 0x821B8968;
		  /* 821B8968h */ case   18:  		/* srd R8, R28, R9 */
		/* 821B8968h case   18:*/		cpu::op::srd<0>(regs,&regs.R8,regs.R28,regs.R9);
		/* 821B8968h case   18:*/		return 0x821B896C;
		  /* 821B896Ch */ case   19:  		/* srd R8, R8, R9 */
		/* 821B896Ch case   19:*/		cpu::op::srd<0>(regs,&regs.R8,regs.R8,regs.R9);
		/* 821B896Ch case   19:*/		return 0x821B8970;
		  /* 821B8970h */ case   20:  		/* srd R9, R8, R9 */
		/* 821B8970h case   20:*/		cpu::op::srd<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 821B8970h case   20:*/		return 0x821B8974;
		  /* 821B8974h */ case   21:  		/* rlwinm R9, R9, 0, 29, 31 */
		/* 821B8974h case   21:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R9,regs.R9);
		/* 821B8974h case   21:*/		return 0x821B8978;
		  /* 821B8978h */ case   22:  		/* add R10, R9, R10 */
		/* 821B8978h case   22:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 821B8978h case   22:*/		return 0x821B897C;
		  /* 821B897Ch */ case   23:  		/* bc 16, CR0_LT, -76 */
		/* 821B897Ch case   23:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x821B8930;  }
		/* 821B897Ch case   23:*/		return 0x821B8980;
		  /* 821B8980h */ case   24:  		/* cmplwi CR6, R10, 4 */
		/* 821B8980h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000004);
		/* 821B8980h case   24:*/		return 0x821B8984;
		  /* 821B8984h */ case   25:  		/* bc 4, CR6_GT, 424 */
		/* 821B8984h case   25:*/		if ( !regs.CR[6].gt ) { return 0x821B8B2C;  }
		/* 821B8984h case   25:*/		return 0x821B8988;
		  /* 821B8988h */ case   26:  		/* lwz R31, <#[R1 + 96]> */
		/* 821B8988h case   26:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000060) );
		/* 821B8988h case   26:*/		return 0x821B898C;
		  /* 821B898Ch */ case   27:  		/* mr R5, R24 */
		/* 821B898Ch case   27:*/		regs.R5 = regs.R24;
		/* 821B898Ch case   27:*/		return 0x821B8990;
		  /* 821B8990h */ case   28:  		/* li R29, 8191 */
		/* 821B8990h case   28:*/		cpu::op::li<0>(regs,&regs.R29,0x1FFF);
		/* 821B8990h case   28:*/		return 0x821B8994;
		  /* 821B8994h */ case   29:  		/* stw R24, <#[R1 + 240]> */
		/* 821B8994h case   29:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R1 + 0x000000F0) );
		/* 821B8994h case   29:*/		return 0x821B8998;
		  /* 821B8998h */ case   30:  		/* li R3, 15 */
		/* 821B8998h case   30:*/		cpu::op::li<0>(regs,&regs.R3,0xF);
		/* 821B8998h case   30:*/		return 0x821B899C;
		  /* 821B899Ch */ case   31:  		/* mr R6, R24 */
		/* 821B899Ch case   31:*/		regs.R6 = regs.R24;
		/* 821B899Ch case   31:*/		return 0x821B89A0;
		  /* 821B89A0h */ case   32:  		/* mr R4, R24 */
		/* 821B89A0h case   32:*/		regs.R4 = regs.R24;
		/* 821B89A0h case   32:*/		return 0x821B89A4;
		  /* 821B89A4h */ case   33:  		/* mr R8, R25 */
		/* 821B89A4h case   33:*/		regs.R8 = regs.R25;
		/* 821B89A4h case   33:*/		return 0x821B89A8;
		  /* 821B89A8h */ case   34:  		/* addi R11, R8, -1 */
		/* 821B89A8h case   34:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R8,0xFFFFFFFF);
		/* 821B89A8h case   34:*/		return 0x821B89AC;
		  /* 821B89ACh */ case   35:  		/* addi R7, R1, 112 */
		/* 821B89ACh case   35:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x70);
		/* 821B89ACh case   35:*/		return 0x821B89B0;
		  /* 821B89B0h */ case   36:  		/* andc R9, R8, R11 */
		/* 821B89B0h case   36:*/		cpu::op::andc<0>(regs,&regs.R9,regs.R8,regs.R11);
		/* 821B89B0h case   36:*/		return 0x821B89B4;
		  /* 821B89B4h */ case   37:  		/* cntlzw R11, R9 */
		/* 821B89B4h case   37:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R9);
		/* 821B89B4h case   37:*/		return 0x821B89B8;
		  /* 821B89B8h */ case   38:  		/* subf R8, R9, R8 */
		/* 821B89B8h case   38:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R9,regs.R8);
		/* 821B89B8h case   38:*/		return 0x821B89BC;
		  /* 821B89BCh */ case   39:  		/* subfic R11, R11, 31 */
		/* 821B89BCh case   39:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x1F);
		/* 821B89BCh case   39:*/		return 0x821B89C0;
		  /* 821B89C0h */ case   40:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821B89C0h case   40:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821B89C0h case   40:*/		return 0x821B89C4;
		  /* 821B89C4h */ case   41:  		/* lwzx R7, <#[R11 + R7]> */
		/* 821B89C4h case   41:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + regs.R7 + 0x00000000) );
		/* 821B89C4h case   41:*/		return 0x821B89C8;
		  /* 821B89C8h */ case   42:  		/* lwz R7, <#[R7 + 20]> */
		/* 821B89C8h case   42:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000014) );
		/* 821B89C8h case   42:*/		return 0x821B89CC;
		  /* 821B89CCh */ case   43:  		/* rlwinm R7, R7, 19, 19, 31 */
		/* 821B89CCh case   43:*/		cpu::op::rlwinm<0,19,19,31>(regs,&regs.R7,regs.R7);
		/* 821B89CCh case   43:*/		return 0x821B89D0;
		  /* 821B89D0h */ case   44:  		/* add R7, R7, R4 */
		/* 821B89D0h case   44:*/		cpu::op::add<0>(regs,&regs.R7,regs.R7,regs.R4);
		/* 821B89D0h case   44:*/		return 0x821B89D4;
		  /* 821B89D4h */ case   45:  		/* cmplwi CR6, R7, 8191 */
		/* 821B89D4h case   45:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00001FFF);
		/* 821B89D4h case   45:*/		return 0x821B89D8;
		  /* 821B89D8h */ case   46:  		/* bc 4, CR6_GT, 8 */
		/* 821B89D8h case   46:*/		if ( !regs.CR[6].gt ) { return 0x821B89E0;  }
		/* 821B89D8h case   46:*/		return 0x821B89DC;
		  /* 821B89DCh */ case   47:  		/* li R7, 8191 */
		/* 821B89DCh case   47:*/		cpu::op::li<0>(regs,&regs.R7,0x1FFF);
		/* 821B89DCh case   47:*/		return 0x821B89E0;
	}
	return 0x821B89E0;
} // Block from 821B8920h-821B89E0h (48 instructions)

//////////////////////////////////////////////////////
// Block at 821B89E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B89E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B89E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B89E0);
		  /* 821B89E0h */ case    0:  		/* cmplw CR6, R7, R29 */
		/* 821B89E0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R29);
		/* 821B89E0h case    0:*/		return 0x821B89E4;
		  /* 821B89E4h */ case    1:  		/* bc 12, CR6_GT, 236 */
		/* 821B89E4h case    1:*/		if ( regs.CR[6].gt ) { return 0x821B8AD0;  }
		/* 821B89E4h case    1:*/		return 0x821B89E8;
		  /* 821B89E8h */ case    2:  		/* addi R24, R11, 3 */
		/* 821B89E8h case    2:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R11,0x3);
		/* 821B89E8h case    2:*/		return 0x821B89EC;
		  /* 821B89ECh */ case    3:  		/* rlwinm R23, R11, 0, 27, 31 */
		/* 821B89ECh case    3:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R23,regs.R11);
		/* 821B89ECh case    3:*/		return 0x821B89F0;
		  /* 821B89F0h */ case    4:  		/* rlwinm R24, R24, 0, 27, 31 */
		/* 821B89F0h case    4:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R24,regs.R24);
		/* 821B89F0h case    4:*/		return 0x821B89F4;
		  /* 821B89F4h */ case    5:  		/* rlwinm R22, R11, 29, 3, 29 */
		/* 821B89F4h case    5:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R22,regs.R11);
		/* 821B89F4h case    5:*/		return 0x821B89F8;
		  /* 821B89F8h */ case    6:  		/* slw R11, R30, R24 */
		/* 821B89F8h case    6:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R30,regs.R24);
		/* 821B89F8h case    6:*/		return 0x821B89FC;
		  /* 821B89FCh */ case    7:  		/* addi R24, R1, 88 */
		/* 821B89FCh case    7:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R1,0x58);
		/* 821B89FCh case    7:*/		return 0x821B8A00;
		  /* 821B8A00h */ case    8:  		/* addi R11, R11, -1 */
		/* 821B8A00h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 821B8A00h case    8:*/		return 0x821B8A04;
		  /* 821B8A04h */ case    9:  		/* slw R21, R15, R23 */
		/* 821B8A04h case    9:*/		cpu::op::slw<0>(regs,&regs.R21,regs.R15,regs.R23);
		/* 821B8A04h case    9:*/		return 0x821B8A08;
		  /* 821B8A08h */ case   10:  		/* lwzx R24, <#[R22 + R24]> */
		/* 821B8A08h case   10:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R22 + regs.R24 + 0x00000000) );
		/* 821B8A08h case   10:*/		return 0x821B8A0C;
		  /* 821B8A0Ch */ case   11:  		/* and R11, R11, R21 */
		/* 821B8A0Ch case   11:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R21);
		/* 821B8A0Ch case   11:*/		return 0x821B8A10;
		  /* 821B8A10h */ case   12:  		/* addi R21, R1, 104 */
		/* 821B8A10h case   12:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R1,0x68);
		/* 821B8A10h case   12:*/		return 0x821B8A14;
		  /* 821B8A14h */ case   13:  		/* and R24, R24, R11 */
		/* 821B8A14h case   13:*/		cpu::op::and<0>(regs,&regs.R24,regs.R24,regs.R11);
		/* 821B8A14h case   13:*/		return 0x821B8A18;
		  /* 821B8A18h */ case   14:  		/* addi R20, R1, 96 */
		/* 821B8A18h case   14:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R1,0x60);
		/* 821B8A18h case   14:*/		return 0x821B8A1C;
		  /* 821B8A1Ch */ case   15:  		/* srw R24, R24, R23 */
		/* 821B8A1Ch case   15:*/		cpu::op::srw<0>(regs,&regs.R24,regs.R24,regs.R23);
		/* 821B8A1Ch case   15:*/		return 0x821B8A20;
		  /* 821B8A20h */ case   16:  		/* rldicl R24, R24, 0, 32 */
		/* 821B8A20h case   16:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R24,regs.R24);
		/* 821B8A20h case   16:*/		return 0x821B8A24;
		  /* 821B8A24h */ case   17:  		/* lwzx R21, <#[R22 + R21]> */
		/* 821B8A24h case   17:*/		cpu::mem::load32z( regs, &regs.R21, (uint32)(regs.R22 + regs.R21 + 0x00000000) );
		/* 821B8A24h case   17:*/		return 0x821B8A28;
		  /* 821B8A28h */ case   18:  		/* lwzx R22, <#[R22 + R20]> */
		/* 821B8A28h case   18:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R22 + regs.R20 + 0x00000000) );
		/* 821B8A28h case   18:*/		return 0x821B8A2C;
		  /* 821B8A2Ch */ case   19:  		/* srd R20, R28, R24 */
		/* 821B8A2Ch case   19:*/		cpu::op::srd<0>(regs,&regs.R20,regs.R28,regs.R24);
		/* 821B8A2Ch case   19:*/		return 0x821B8A30;
		  /* 821B8A30h */ case   20:  		/* srd R20, R20, R24 */
		/* 821B8A30h case   20:*/		cpu::op::srd<0>(regs,&regs.R20,regs.R20,regs.R24);
		/* 821B8A30h case   20:*/		return 0x821B8A34;
		  /* 821B8A34h */ case   21:  		/* and R21, R21, R11 */
		/* 821B8A34h case   21:*/		cpu::op::and<0>(regs,&regs.R21,regs.R21,regs.R11);
		/* 821B8A34h case   21:*/		return 0x821B8A38;
		  /* 821B8A38h */ case   22:  		/* srd R24, R20, R24 */
		/* 821B8A38h case   22:*/		cpu::op::srd<0>(regs,&regs.R24,regs.R20,regs.R24);
		/* 821B8A38h case   22:*/		return 0x821B8A3C;
		  /* 821B8A3Ch */ case   23:  		/* rlwinm R24, R24, 0, 29, 31 */
		/* 821B8A3Ch case   23:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R24,regs.R24);
		/* 821B8A3Ch case   23:*/		return 0x821B8A40;
		  /* 821B8A40h */ case   24:  		/* srw R21, R21, R23 */
		/* 821B8A40h case   24:*/		cpu::op::srw<0>(regs,&regs.R21,regs.R21,regs.R23);
		/* 821B8A40h case   24:*/		return 0x821B8A44;
		  /* 821B8A44h */ case   25:  		/* and R22, R22, R11 */
		/* 821B8A44h case   25:*/		cpu::op::and<0>(regs,&regs.R22,regs.R22,regs.R11);
		/* 821B8A44h case   25:*/		return 0x821B8A48;
		  /* 821B8A48h */ case   26:  		/* subf R11, R24, R21 */
		/* 821B8A48h case   26:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R24,regs.R21);
		/* 821B8A48h case   26:*/		return 0x821B8A4C;
		  /* 821B8A4Ch */ case   27:  		/* srw R24, R22, R23 */
		/* 821B8A4Ch case   27:*/		cpu::op::srw<0>(regs,&regs.R24,regs.R22,regs.R23);
		/* 821B8A4Ch case   27:*/		return 0x821B8A50;
		  /* 821B8A50h */ case   28:  		/* add R11, R11, R10 */
		/* 821B8A50h case   28:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821B8A50h case   28:*/		return 0x821B8A54;
		  /* 821B8A54h */ case   29:  		/* or R9, R24, R9 */
		/* 821B8A54h case   29:*/		cpu::op::or<0>(regs,&regs.R9,regs.R24,regs.R9);
		/* 821B8A54h case   29:*/		return 0x821B8A58;
		  /* 821B8A58h */ case   30:  		/* addi R11, R11, 1 */
		/* 821B8A58h case   30:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821B8A58h case   30:*/		return 0x821B8A5C;
		  /* 821B8A5Ch */ case   31:  		/* or R9, R9, R6 */
		/* 821B8A5Ch case   31:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R6);
		/* 821B8A5Ch case   31:*/		return 0x821B8A60;
		  /* 821B8A60h */ case   32:  		/* cmplwi CR6, R11, 4 */
		/* 821B8A60h case   32:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 821B8A60h case   32:*/		return 0x821B8A64;
		  /* 821B8A64h */ case   33:  		/* bc 12, CR6_GT, 64 */
		/* 821B8A64h case   33:*/		if ( regs.CR[6].gt ) { return 0x821B8AA4;  }
		/* 821B8A64h case   33:*/		return 0x821B8A68;
		  /* 821B8A68h */ case   34:  		/* rldicl R11, R9, 0, 32 */
		/* 821B8A68h case   34:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R11,regs.R9);
		/* 821B8A68h case   34:*/		return 0x821B8A6C;
		  /* 821B8A6Ch */ case   35:  		/* rldicl R24, R3, 0, 32 */
		/* 821B8A6Ch case   35:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R24,regs.R3);
		/* 821B8A6Ch case   35:*/		return 0x821B8A70;
		  /* 821B8A70h */ case   36:  		/* srd R23, R28, R11 */
		/* 821B8A70h case   36:*/		cpu::op::srd<0>(regs,&regs.R23,regs.R28,regs.R11);
		/* 821B8A70h case   36:*/		return 0x821B8A74;
		  /* 821B8A74h */ case   37:  		/* srd R22, R28, R24 */
		/* 821B8A74h case   37:*/		cpu::op::srd<0>(regs,&regs.R22,regs.R28,regs.R24);
		/* 821B8A74h case   37:*/		return 0x821B8A78;
		  /* 821B8A78h */ case   38:  		/* srd R22, R22, R24 */
		/* 821B8A78h case   38:*/		cpu::op::srd<0>(regs,&regs.R22,regs.R22,regs.R24);
		/* 821B8A78h case   38:*/		return 0x821B8A7C;
		  /* 821B8A7Ch */ case   39:  		/* srd R23, R23, R11 */
		/* 821B8A7Ch case   39:*/		cpu::op::srd<0>(regs,&regs.R23,regs.R23,regs.R11);
		/* 821B8A7Ch case   39:*/		return 0x821B8A80;
		  /* 821B8A80h */ case   40:  		/* srd R24, R22, R24 */
		/* 821B8A80h case   40:*/		cpu::op::srd<0>(regs,&regs.R24,regs.R22,regs.R24);
		/* 821B8A80h case   40:*/		return 0x821B8A84;
		  /* 821B8A84h */ case   41:  		/* srd R11, R23, R11 */
		/* 821B8A84h case   41:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R23,regs.R11);
		/* 821B8A84h case   41:*/		return 0x821B8A88;
		  /* 821B8A88h */ case   42:  		/* rlwinm R24, R24, 0, 29, 31 */
		/* 821B8A88h case   42:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R24,regs.R24);
		/* 821B8A88h case   42:*/		return 0x821B8A8C;
		  /* 821B8A8Ch */ case   43:  		/* rlwinm R11, R11, 0, 29, 31 */
		/* 821B8A8Ch case   43:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R11,regs.R11);
		/* 821B8A8Ch case   43:*/		return 0x821B8A90;
		  /* 821B8A90h */ case   44:  		/* cmplw CR6, R11, R24 */
		/* 821B8A90h case   44:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R24);
		/* 821B8A90h case   44:*/		return 0x821B8A94;
		  /* 821B8A94h */ case   45:  		/* bc 12, CR6_GT, 60 */
		/* 821B8A94h case   45:*/		if ( regs.CR[6].gt ) { return 0x821B8AD0;  }
		/* 821B8A94h case   45:*/		return 0x821B8A98;
		  /* 821B8A98h */ case   46:  		/* mr R29, R7 */
		/* 821B8A98h case   46:*/		regs.R29 = regs.R7;
		/* 821B8A98h case   46:*/		return 0x821B8A9C;
		  /* 821B8A9Ch */ case   47:  		/* mr R3, R9 */
		/* 821B8A9Ch case   47:*/		regs.R3 = regs.R9;
		/* 821B8A9Ch case   47:*/		return 0x821B8AA0;
		  /* 821B8AA0h */ case   48:  		/* b 48 */
		/* 821B8AA0h case   48:*/		return 0x821B8AD0;
		/* 821B8AA0h case   48:*/		return 0x821B8AA4;
	}
	return 0x821B8AA4;
} // Block from 821B89E0h-821B8AA4h (49 instructions)

//////////////////////////////////////////////////////
// Block at 821B8AA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8AA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8AA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8AA4);
		  /* 821B8AA4h */ case    0:  		/* rlwinm R31, R31, 0, 21, 31 */
		/* 821B8AA4h case    0:*/		cpu::op::rlwinm<0,0,21,31>(regs,&regs.R31,regs.R31);
		/* 821B8AA4h case    0:*/		return 0x821B8AA8;
		  /* 821B8AA8h */ case    1:  		/* rlwinm R9, R9, 28, 0, 3 */
		/* 821B8AA8h case    1:*/		cpu::op::rlwinm<0,28,0,3>(regs,&regs.R9,regs.R9);
		/* 821B8AA8h case    1:*/		return 0x821B8AAC;
		  /* 821B8AACh */ case    2:  		/* rlwimi R11, R7, 4, 15, 27 */
		/* 821B8AACh case    2:*/		cpu::op::rlwimi<0,4,15,27>(regs,&regs.R11,regs.R7);
		/* 821B8AACh case    2:*/		return 0x821B8AB0;
		  /* 821B8AB0h */ case    3:  		/* or R31, R31, R9 */
		/* 821B8AB0h case    3:*/		cpu::op::or<0>(regs,&regs.R31,regs.R31,regs.R9);
		/* 821B8AB0h case    3:*/		return 0x821B8AB4;
		  /* 821B8AB4h */ case    4:  		/* rlwinm R9, R5, 2, 0, 29 */
		/* 821B8AB4h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R5);
		/* 821B8AB4h case    4:*/		return 0x821B8AB8;
		  /* 821B8AB8h */ case    5:  		/* rlwimi R31, R11, 11, 4, 20 */
		/* 821B8AB8h case    5:*/		cpu::op::rlwimi<0,11,4,20>(regs,&regs.R31,regs.R11);
		/* 821B8AB8h case    5:*/		return 0x821B8ABC;
		  /* 821B8ABCh */ case    6:  		/* addi R11, R1, 144 */
		/* 821B8ABCh case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x90);
		/* 821B8ABCh case    6:*/		return 0x821B8AC0;
		  /* 821B8AC0h */ case    7:  		/* stwx R31, <#[R9 + R11]> */
		/* 821B8AC0h case    7:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 821B8AC0h case    7:*/		return 0x821B8AC4;
		  /* 821B8AC4h */ case    8:  		/* lwz R11, <#[R1 + 240]> */
		/* 821B8AC4h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x000000F0) );
		/* 821B8AC4h case    8:*/		return 0x821B8AC8;
		  /* 821B8AC8h */ case    9:  		/* addi R5, R11, 1 */
		/* 821B8AC8h case    9:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0x1);
		/* 821B8AC8h case    9:*/		return 0x821B8ACC;
		  /* 821B8ACCh */ case   10:  		/* stw R5, <#[R1 + 240]> */
		/* 821B8ACCh case   10:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x000000F0) );
		/* 821B8ACCh case   10:*/		return 0x821B8AD0;
	}
	return 0x821B8AD0;
} // Block from 821B8AA4h-821B8AD0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821B8AD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8AD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8AD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8AD0);
		  /* 821B8AD0h */ case    0:  		/* cmplwi CR6, R8, 0 */
		/* 821B8AD0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 821B8AD0h case    0:*/		return 0x821B8AD4;
		  /* 821B8AD4h */ case    1:  		/* bc 4, CR6_EQ, -300 */
		/* 821B8AD4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821B89A8;  }
		/* 821B8AD4h case    1:*/		return 0x821B8AD8;
		  /* 821B8AD8h */ case    2:  		/* cmplwi CR6, R5, 0 */
		/* 821B8AD8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 821B8AD8h case    2:*/		return 0x821B8ADC;
		  /* 821B8ADCh */ case    3:  		/* bc 12, CR6_EQ, 48 */
		/* 821B8ADCh case    3:*/		if ( regs.CR[6].eq ) { return 0x821B8B0C;  }
		/* 821B8ADCh case    3:*/		return 0x821B8AE0;
		  /* 821B8AE0h */ case    4:  		/* addi R11, R5, -1 */
		/* 821B8AE0h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R5,0xFFFFFFFF);
		/* 821B8AE0h case    4:*/		return 0x821B8AE4;
		  /* 821B8AE4h */ case    5:  		/* addi R10, R1, 144 */
		/* 821B8AE4h case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x90);
		/* 821B8AE4h case    5:*/		return 0x821B8AE8;
		  /* 821B8AE8h */ case    6:  		/* mr R5, R11 */
		/* 821B8AE8h case    6:*/		regs.R5 = regs.R11;
		/* 821B8AE8h case    6:*/		return 0x821B8AEC;
		  /* 821B8AECh */ case    7:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821B8AECh case    7:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821B8AECh case    7:*/		return 0x821B8AF0;
		  /* 821B8AF0h */ case    8:  		/* stw R5, <#[R1 + 240]> */
		/* 821B8AF0h case    8:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x000000F0) );
		/* 821B8AF0h case    8:*/		return 0x821B8AF4;
		  /* 821B8AF4h */ case    9:  		/* lwzx R11, <#[R11 + R10]> */
		/* 821B8AF4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821B8AF4h case    9:*/		return 0x821B8AF8;
		  /* 821B8AF8h */ case   10:  		/* rlwinm R6, R11, 4, 28, 31 */
		/* 821B8AF8h case   10:*/		cpu::op::rlwinm<0,4,28,31>(regs,&regs.R6,regs.R11);
		/* 821B8AF8h case   10:*/		return 0x821B8AFC;
		  /* 821B8AFCh */ case   11:  		/* rlwinm R4, R11, 17, 19, 31 */
		/* 821B8AFCh case   11:*/		cpu::op::rlwinm<0,17,19,31>(regs,&regs.R4,regs.R11);
		/* 821B8AFCh case   11:*/		return 0x821B8B00;
		  /* 821B8B00h */ case   12:  		/* rlwinm R10, R11, 21, 28, 31 */
		/* 821B8B00h case   12:*/		cpu::op::rlwinm<0,21,28,31>(regs,&regs.R10,regs.R11);
		/* 821B8B00h case   12:*/		return 0x821B8B04;
		  /* 821B8B04h */ case   13:  		/* andc R8, R25, R6 */
		/* 821B8B04h case   13:*/		cpu::op::andc<0>(regs,&regs.R8,regs.R25,regs.R6);
		/* 821B8B04h case   13:*/		return 0x821B8B08;
		  /* 821B8B08h */ case   14:  		/* b -352 */
		/* 821B8B08h case   14:*/		return 0x821B89A8;
		/* 821B8B08h case   14:*/		return 0x821B8B0C;
	}
	return 0x821B8B0C;
} // Block from 821B8AD0h-821B8B0Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 821B8B0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8B0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8B0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8B0C);
		  /* 821B8B0Ch */ case    0:  		/* rlwinm R10, R17, 31, 3, 29 */
		/* 821B8B0Ch case    0:*/		cpu::op::rlwinm<0,31,3,29>(regs,&regs.R10,regs.R17);
		/* 821B8B0Ch case    0:*/		return 0x821B8B10;
		  /* 821B8B10h */ case    1:  		/* addi R11, R1, 80 */
		/* 821B8B10h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 821B8B10h case    1:*/		return 0x821B8B14;
		  /* 821B8B14h */ case    2:  		/* rlwinm R9, R17, 2, 27, 29 */
		/* 821B8B14h case    2:*/		cpu::op::rlwinm<0,2,27,29>(regs,&regs.R9,regs.R17);
		/* 821B8B14h case    2:*/		return 0x821B8B18;
		  /* 821B8B18h */ case    3:  		/* addi R17, R17, 1 */
		/* 821B8B18h case    3:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R17,0x1);
		/* 821B8B18h case    3:*/		return 0x821B8B1C;
		  /* 821B8B1Ch */ case    4:  		/* slw R9, R3, R9 */
		/* 821B8B1Ch case    4:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R3,regs.R9);
		/* 821B8B1Ch case    4:*/		return 0x821B8B20;
		  /* 821B8B20h */ case    5:  		/* lwzx R8, <#[R10 + R11]> */
		/* 821B8B20h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821B8B20h case    5:*/		return 0x821B8B24;
		  /* 821B8B24h */ case    6:  		/* or R9, R9, R8 */
		/* 821B8B24h case    6:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 821B8B24h case    6:*/		return 0x821B8B28;
		  /* 821B8B28h */ case    7:  		/* stwx R9, <#[R10 + R11]> */
		/* 821B8B28h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821B8B28h case    7:*/		return 0x821B8B2C;
	}
	return 0x821B8B2C;
} // Block from 821B8B0Ch-821B8B2Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 821B8B2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8B2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8B2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8B2C);
		  /* 821B8B2Ch */ case    0:  		/* cmplwi CR6, R27, 0 */
		/* 821B8B2Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 821B8B2Ch case    0:*/		return 0x821B8B30;
		  /* 821B8B30h */ case    1:  		/* bc 12, CR6_EQ, 756 */
		/* 821B8B30h case    1:*/		if ( regs.CR[6].eq ) { return 0x821B8E24;  }
		/* 821B8B30h case    1:*/		return 0x821B8B34;
		  /* 821B8B34h */ case    2:  		/* li R21, 0 */
		/* 821B8B34h case    2:*/		cpu::op::li<0>(regs,&regs.R21,0x0);
		/* 821B8B34h case    2:*/		return 0x821B8B38;
		  /* 821B8B38h */ case    3:  		/* li R22, 0 */
		/* 821B8B38h case    3:*/		cpu::op::li<0>(regs,&regs.R22,0x0);
		/* 821B8B38h case    3:*/		return 0x821B8B3C;
		  /* 821B8B3Ch */ case    4:  		/* li R19, 0 */
		/* 821B8B3Ch case    4:*/		cpu::op::li<0>(regs,&regs.R19,0x0);
		/* 821B8B3Ch case    4:*/		return 0x821B8B40;
		  /* 821B8B40h */ case    5:  		/* li R20, 0 */
		/* 821B8B40h case    5:*/		cpu::op::li<0>(regs,&regs.R20,0x0);
		/* 821B8B40h case    5:*/		return 0x821B8B44;
		  /* 821B8B44h */ case    6:  		/* li R31, 0 */
		/* 821B8B44h case    6:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 821B8B44h case    6:*/		return 0x821B8B48;
		  /* 821B8B48h */ case    7:  		/* cmplwi CR6, R14, 0 */
		/* 821B8B48h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R14,0x00000000);
		/* 821B8B48h case    7:*/		return 0x821B8B4C;
		  /* 821B8B4Ch */ case    8:  		/* bc 12, CR6_EQ, 728 */
		/* 821B8B4Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x821B8E24;  }
		/* 821B8B4Ch case    8:*/		return 0x821B8B50;
		  /* 821B8B50h */ case    9:  		/* addi R10, R1, 128 */
		/* 821B8B50h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x80);
		/* 821B8B50h case    9:*/		return 0x821B8B54;
		  /* 821B8B54h */ case   10:  		/* lwz R18, <#[R1 + 80]> */
		/* 821B8B54h case   10:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R1 + 0x00000050) );
		/* 821B8B54h case   10:*/		return 0x821B8B58;
		  /* 821B8B58h */ case   11:  		/* rlwinm R29, R17, 2, 0, 29 */
		/* 821B8B58h case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R29,regs.R17);
		/* 821B8B58h case   11:*/		return 0x821B8B5C;
		  /* 821B8B5Ch */ case   12:  		/* li R28, 0 */
		/* 821B8B5Ch case   12:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 821B8B5Ch case   12:*/		return 0x821B8B60;
		  /* 821B8B60h */ case   13:  		/* addi R23, R10, -4 */
		/* 821B8B60h case   13:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R10,0xFFFFFFFC);
		/* 821B8B60h case   13:*/		return 0x821B8B64;
		  /* 821B8B64h */ case   14:  		/* addi R24, R1, 112 */
		/* 821B8B64h case   14:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R1,0x70);
		/* 821B8B64h case   14:*/		return 0x821B8B68;
		  /* 821B8B68h */ case   15:  		/* addi R25, R26, 44 */
		/* 821B8B68h case   15:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R26,0x2C);
		/* 821B8B68h case   15:*/		return 0x821B8B6C;
		  /* 821B8B6Ch */ case   16:  		/* slw R11, R16, R31 */
		/* 821B8B6Ch case   16:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R16,regs.R31);
		/* 821B8B6Ch case   16:*/		return 0x821B8B70;
		  /* 821B8B70h */ case   17:  		/* and. R11, R11, R18 */
		/* 821B8B70h case   17:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R18);
		/* 821B8B70h case   17:*/		return 0x821B8B74;
		  /* 821B8B74h */ case   18:  		/* bc 4, CR0_EQ, 244 */
		/* 821B8B74h case   18:*/		if ( !regs.CR[0].eq ) { return 0x821B8C68;  }
		/* 821B8B74h case   18:*/		return 0x821B8B78;
		  /* 821B8B78h */ case   19:  		/* lwz R3, <#[R24]> */
		/* 821B8B78h case   19:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R24 + 0x00000000) );
		/* 821B8B78h case   19:*/		return 0x821B8B7C;
		  /* 821B8B7Ch */ case   20:  		/* lwz R11, <#[R3 + 8]> */
		/* 821B8B7Ch case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821B8B7Ch case   20:*/		return 0x821B8B80;
		  /* 821B8B80h */ case   21:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821B8B80h case   21:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821B8B80h case   21:*/		return 0x821B8B84;
		  /* 821B8B84h */ case   22:  		/* cmplwi CR6, R11, 16000 */
		/* 821B8B84h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E80);
		/* 821B8B84h case   22:*/		return 0x821B8B88;
		  /* 821B8B88h */ case   23:  		/* bc 4, CR6_EQ, 224 */
		/* 821B8B88h case   23:*/		if ( !regs.CR[6].eq ) { return 0x821B8C68;  }
		/* 821B8B88h case   23:*/		return 0x821B8B8C;
		  /* 821B8B8Ch */ case   24:  		/* addi R11, R28, 4 */
		/* 821B8B8Ch case   24:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R28,0x4);
		/* 821B8B8Ch case   24:*/		return 0x821B8B90;
		  /* 821B8B90h */ case   25:  		/* addi R9, R1, 84 */
		/* 821B8B90h case   25:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x54);
		/* 821B8B90h case   25:*/		return 0x821B8B94;
		  /* 821B8B94h */ case   26:  		/* rlwinm R10, R28, 29, 3, 29 */
		/* 821B8B94h case   26:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R10,regs.R28);
		/* 821B8B94h case   26:*/		return 0x821B8B98;
		  /* 821B8B98h */ case   27:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 821B8B98h case   27:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 821B8B98h case   27:*/		return 0x821B8B9C;
		  /* 821B8B9Ch */ case   28:  		/* slw R11, R30, R11 */
		/* 821B8B9Ch case   28:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R30,regs.R11);
		/* 821B8B9Ch case   28:*/		return 0x821B8BA0;
		  /* 821B8BA0h */ case   29:  		/* lwzx R10, <#[R10 + R9]> */
		/* 821B8BA0h case   29:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 821B8BA0h case   29:*/		return 0x821B8BA4;
		  /* 821B8BA4h */ case   30:  		/* addi R11, R11, -1 */
		/* 821B8BA4h case   30:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 821B8BA4h case   30:*/		return 0x821B8BA8;
		  /* 821B8BA8h */ case   31:  		/* rlwinm R9, R28, 0, 27, 31 */
		/* 821B8BA8h case   31:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R28);
		/* 821B8BA8h case   31:*/		return 0x821B8BAC;
		  /* 821B8BACh */ case   32:  		/* and R11, R11, R10 */
		/* 821B8BACh case   32:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821B8BACh case   32:*/		return 0x821B8BB0;
		  /* 821B8BB0h */ case   33:  		/* slw R8, R15, R9 */
		/* 821B8BB0h case   33:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R15,regs.R9);
		/* 821B8BB0h case   33:*/		return 0x821B8BB4;
		  /* 821B8BB4h */ case   34:  		/* and R11, R11, R8 */
		/* 821B8BB4h case   34:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 821B8BB4h case   34:*/		return 0x821B8BB8;
		  /* 821B8BB8h */ case   35:  		/* srw R11, R11, R9 */
		/* 821B8BB8h case   35:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 821B8BB8h case   35:*/		return 0x821B8BBC;
		  /* 821B8BBCh */ case   36:  		/* rlwinm. R11, R11, 0, 27, 28 */
		/* 821B8BBCh case   36:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R11,regs.R11);
		/* 821B8BBCh case   36:*/		return 0x821B8BC0;
		  /* 821B8BC0h */ case   37:  		/* bc 12, CR0_EQ, 56 */
		/* 821B8BC0h case   37:*/		if ( regs.CR[0].eq ) { return 0x821B8BF8;  }
		/* 821B8BC0h case   37:*/		return 0x821B8BC4;
		  /* 821B8BC4h */ case   38:  		/* rlwinm R10, R29, 29, 3, 29 */
		/* 821B8BC4h case   38:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R10,regs.R29);
		/* 821B8BC4h case   38:*/		return 0x821B8BC8;
		  /* 821B8BC8h */ case   39:  		/* addi R11, R1, 80 */
		/* 821B8BC8h case   39:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 821B8BC8h case   39:*/		return 0x821B8BCC;
		  /* 821B8BCCh */ case   40:  		/* li R9, 1 */
		/* 821B8BCCh case   40:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 821B8BCCh case   40:*/		return 0x821B8BD0;
		  /* 821B8BD0h */ case   41:  		/* rlwinm R8, R29, 0, 27, 31 */
		/* 821B8BD0h case   41:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R8,regs.R29);
		/* 821B8BD0h case   41:*/		return 0x821B8BD4;
		  /* 821B8BD4h */ case   42:  		/* slw R9, R9, R31 */
		/* 821B8BD4h case   42:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R9,regs.R31);
		/* 821B8BD4h case   42:*/		return 0x821B8BD8;
		  /* 821B8BD8h */ case   43:  		/* lwzx R7, <#[R10 + R11]> */
		/* 821B8BD8h case   43:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821B8BD8h case   43:*/		return 0x821B8BDC;
		  /* 821B8BDCh */ case   44:  		/* slw R9, R9, R8 */
		/* 821B8BDCh case   44:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 821B8BDCh case   44:*/		return 0x821B8BE0;
		  /* 821B8BE0h */ case   45:  		/* or R9, R9, R7 */
		/* 821B8BE0h case   45:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R7);
		/* 821B8BE0h case   45:*/		return 0x821B8BE4;
		  /* 821B8BE4h */ case   46:  		/* addi R17, R17, 1 */
		/* 821B8BE4h case   46:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R17,0x1);
		/* 821B8BE4h case   46:*/		return 0x821B8BE8;
		  /* 821B8BE8h */ case   47:  		/* stwx R9, <#[R10 + R11]> */
		/* 821B8BE8h case   47:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821B8BE8h case   47:*/		return 0x821B8BEC;
		  /* 821B8BECh */ case   48:  		/* addi R29, R29, 4 */
		/* 821B8BECh case   48:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x4);
		/* 821B8BECh case   48:*/		return 0x821B8BF0;
		  /* 821B8BF0h */ case   49:  		/* lwz R18, <#[R1 + 80]> */
		/* 821B8BF0h case   49:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R1 + 0x00000050) );
		/* 821B8BF0h case   49:*/		return 0x821B8BF4;
		  /* 821B8BF4h */ case   50:  		/* b 116 */
		/* 821B8BF4h case   50:*/		return 0x821B8C68;
		/* 821B8BF4h case   50:*/		return 0x821B8BF8;
	}
	return 0x821B8BF8;
} // Block from 821B8B2Ch-821B8BF8h (51 instructions)

//////////////////////////////////////////////////////
// Block at 821B8BF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8BF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8BF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8BF8);
		  /* 821B8BF8h */ case    0:  		/* li R11, 1 */
		/* 821B8BF8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821B8BF8h case    0:*/		return 0x821B8BFC;
		  /* 821B8BFCh */ case    1:  		/* addi R20, R20, 1 */
		/* 821B8BFCh case    1:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R20,0x1);
		/* 821B8BFCh case    1:*/		return 0x821B8C00;
		  /* 821B8C00h */ case    2:  		/* slw R11, R11, R31 */
		/* 821B8C00h case    2:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R31);
		/* 821B8C00h case    2:*/		return 0x821B8C04;
		  /* 821B8C04h */ case    3:  		/* or R19, R11, R19 */
		/* 821B8C04h case    3:*/		cpu::op::or<0>(regs,&regs.R19,regs.R11,regs.R19);
		/* 821B8C04h case    3:*/		return 0x821B8C08;
		  /* 821B8C08h */ case    4:  		/* li R11, 0 */
		/* 821B8C08h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821B8C08h case    4:*/		return 0x821B8C0C;
		  /* 821B8C0Ch */ case    5:  		/* cmplwi CR6, R31, 0 */
		/* 821B8C0Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821B8C0Ch case    5:*/		return 0x821B8C10;
		  /* 821B8C10h */ case    6:  		/* bc 12, CR6_EQ, 48 */
		/* 821B8C10h case    6:*/		if ( regs.CR[6].eq ) { return 0x821B8C40;  }
		/* 821B8C10h case    6:*/		return 0x821B8C14;
		  /* 821B8C14h */ case    7:  		/* addi R10, R1, 112 */
		/* 821B8C14h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R1,0x70);
		/* 821B8C14h case    7:*/		return 0x821B8C18;
		  /* 821B8C18h */ case    8:  		/* slw R9, R16, R11 */
		/* 821B8C18h case    8:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R16,regs.R11);
		/* 821B8C18h case    8:*/		return 0x821B8C1C;
		  /* 821B8C1Ch */ case    9:  		/* and. R9, R9, R18 */
		/* 821B8C1Ch case    9:*/		cpu::op::and<1>(regs,&regs.R9,regs.R9,regs.R18);
		/* 821B8C1Ch case    9:*/		return 0x821B8C20;
		  /* 821B8C20h */ case   10:  		/* bc 4, CR0_EQ, 16 */
		/* 821B8C20h case   10:*/		if ( !regs.CR[0].eq ) { return 0x821B8C30;  }
		/* 821B8C20h case   10:*/		return 0x821B8C24;
		  /* 821B8C24h */ case   11:  		/* lwz R9, <#[R10]> */
		/* 821B8C24h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821B8C24h case   11:*/		return 0x821B8C28;
		  /* 821B8C28h */ case   12:  		/* cmplw CR6, R3, R9 */
		/* 821B8C28h case   12:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R9);
		/* 821B8C28h case   12:*/		return 0x821B8C2C;
		  /* 821B8C2Ch */ case   13:  		/* bc 12, CR6_EQ, 20 */
		/* 821B8C2Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x821B8C40;  }
		/* 821B8C2Ch case   13:*/		return 0x821B8C30;
	}
	return 0x821B8C30;
} // Block from 821B8BF8h-821B8C30h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821B8C30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8C30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8C30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8C30);
		  /* 821B8C30h */ case    0:  		/* addi R11, R11, 1 */
		/* 821B8C30h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821B8C30h case    0:*/		return 0x821B8C34;
		  /* 821B8C34h */ case    1:  		/* addi R10, R10, 4 */
		/* 821B8C34h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821B8C34h case    1:*/		return 0x821B8C38;
		  /* 821B8C38h */ case    2:  		/* cmplw CR6, R11, R31 */
		/* 821B8C38h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 821B8C38h case    2:*/		return 0x821B8C3C;
		  /* 821B8C3Ch */ case    3:  		/* bc 12, CR6_LT, -36 */
		/* 821B8C3Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x821B8C18;  }
		/* 821B8C3Ch case    3:*/		return 0x821B8C40;
	}
	return 0x821B8C40;
} // Block from 821B8C30h-821B8C40h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821B8C40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8C40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8C40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8C40);
		  /* 821B8C40h */ case    0:  		/* cmplw CR6, R11, R31 */
		/* 821B8C40h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 821B8C40h case    0:*/		return 0x821B8C44;
		  /* 821B8C44h */ case    1:  		/* bc 4, CR6_EQ, 8 */
		/* 821B8C44h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821B8C4C;  }
		/* 821B8C44h case    1:*/		return 0x821B8C48;
		  /* 821B8C48h */ case    2:  		/* addi R21, R21, 1 */
		/* 821B8C48h case    2:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R21,0x1);
		/* 821B8C48h case    2:*/		return 0x821B8C4C;
	}
	return 0x821B8C4C;
} // Block from 821B8C40h-821B8C4Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 821B8C4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8C4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8C4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8C4C);
		  /* 821B8C4Ch */ case    0:  		/* lwz R11, <#[R25]> */
		/* 821B8C4Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 821B8C4Ch case    0:*/		return 0x821B8C50;
		  /* 821B8C50h */ case    1:  		/* lwz R11, <#[R11]> */
		/* 821B8C50h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821B8C50h case    1:*/		return 0x821B8C54;
		  /* 821B8C54h */ case    2:  		/* rlwinm R4, R11, 27, 30, 31 */
		/* 821B8C54h case    2:*/		cpu::op::rlwinm<0,27,30,31>(regs,&regs.R4,regs.R11);
		/* 821B8C54h case    2:*/		return 0x821B8C58;
		  /* 821B8C58h */ case    3:  		/* rlwinm R5, R11, 0, 27, 31 */
		/* 821B8C58h case    3:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R5,regs.R11);
		/* 821B8C58h case    3:*/		return 0x821B8C5C;
		  /* 821B8C5Ch */ case    4:  		/* bl 428588 */
		/* 821B8C5Ch case    4:*/		regs.LR = 0x821B8C60; return 0x82221688;
		/* 821B8C5Ch case    4:*/		return 0x821B8C60;
		  /* 821B8C60h */ case    5:  		/* stfsu FR1, <#[R23 + 4]> */
		/* 821B8C60h case    5:*/		cpu::mem::store32f( regs, regs.FR1, (uint32)(regs.R23 + 0x00000004) );
		regs.R23 = (uint32)(regs.R23 + 0x00000004);
		/* 821B8C60h case    5:*/		return 0x821B8C64;
		  /* 821B8C64h */ case    6:  		/* addi R22, R22, 1 */
		/* 821B8C64h case    6:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R22,0x1);
		/* 821B8C64h case    6:*/		return 0x821B8C68;
	}
	return 0x821B8C68;
} // Block from 821B8C4Ch-821B8C68h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821B8C68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8C68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8C68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8C68);
		  /* 821B8C68h */ case    0:  		/* addi R31, R31, 1 */
		/* 821B8C68h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 821B8C68h case    0:*/		return 0x821B8C6C;
		  /* 821B8C6Ch */ case    1:  		/* addi R24, R24, 4 */
		/* 821B8C6Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x4);
		/* 821B8C6Ch case    1:*/		return 0x821B8C70;
		  /* 821B8C70h */ case    2:  		/* addi R25, R25, 4 */
		/* 821B8C70h case    2:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x4);
		/* 821B8C70h case    2:*/		return 0x821B8C74;
		  /* 821B8C74h */ case    3:  		/* addi R28, R28, 5 */
		/* 821B8C74h case    3:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x5);
		/* 821B8C74h case    3:*/		return 0x821B8C78;
		  /* 821B8C78h */ case    4:  		/* cmplw CR6, R31, R14 */
		/* 821B8C78h case    4:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R14);
		/* 821B8C78h case    4:*/		return 0x821B8C7C;
		  /* 821B8C7Ch */ case    5:  		/* bc 12, CR6_LT, -272 */
		/* 821B8C7Ch case    5:*/		if ( regs.CR[6].lt ) { return 0x821B8B6C;  }
		/* 821B8C7Ch case    5:*/		return 0x821B8C80;
		  /* 821B8C80h */ case    6:  		/* cmplwi CR6, R20, 0 */
		/* 821B8C80h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000000);
		/* 821B8C80h case    6:*/		return 0x821B8C84;
		  /* 821B8C84h */ case    7:  		/* bc 12, CR6_EQ, 416 */
		/* 821B8C84h case    7:*/		if ( regs.CR[6].eq ) { return 0x821B8E24;  }
		/* 821B8C84h case    7:*/		return 0x821B8C88;
		  /* 821B8C88h */ case    8:  		/* lwz R27, <#[R1 + 436]> */
		/* 821B8C88h case    8:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x000001B4) );
		/* 821B8C88h case    8:*/		return 0x821B8C8C;
		  /* 821B8C8Ch */ case    9:  		/* cmplwi CR6, R21, 1 */
		/* 821B8C8Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R21,0x00000001);
		/* 821B8C8Ch case    9:*/		return 0x821B8C90;
		  /* 821B8C90h */ case   10:  		/* bc 4, CR6_GT, 168 */
		/* 821B8C90h case   10:*/		if ( !regs.CR[6].gt ) { return 0x821B8D38;  }
		/* 821B8C90h case   10:*/		return 0x821B8C94;
		  /* 821B8C94h */ case   11:  		/* addi R11, R1, 96 */
		/* 821B8C94h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 821B8C94h case   11:*/		return 0x821B8C98;
		  /* 821B8C98h */ case   12:  		/* li R10, 0 */
		/* 821B8C98h case   12:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821B8C98h case   12:*/		return 0x821B8C9C;
		  /* 821B8C9Ch */ case   13:  		/* addi R5, R1, 128 */
		/* 821B8C9Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x80);
		/* 821B8C9Ch case   13:*/		return 0x821B8CA0;
		  /* 821B8CA0h */ case   14:  		/* mr R4, R22 */
		/* 821B8CA0h case   14:*/		regs.R4 = regs.R22;
		/* 821B8CA0h case   14:*/		return 0x821B8CA4;
		  /* 821B8CA4h */ case   15:  		/* mr R3, R27 */
		/* 821B8CA4h case   15:*/		regs.R3 = regs.R27;
		/* 821B8CA4h case   15:*/		return 0x821B8CA8;
		  /* 821B8CA8h */ case   16:  		/* stw R10, <#[R11]> */
		/* 821B8CA8h case   16:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821B8CA8h case   16:*/		return 0x821B8CAC;
		  /* 821B8CACh */ case   17:  		/* lwz R6, <#[R1 + 96]> */
		/* 821B8CACh case   17:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000060) );
		/* 821B8CACh case   17:*/		return 0x821B8CB0;
		  /* 821B8CB0h */ case   18:  		/* bl 451464 */
		/* 821B8CB0h case   18:*/		regs.LR = 0x821B8CB4; return 0x82227038;
		/* 821B8CB0h case   18:*/		return 0x821B8CB4;
		  /* 821B8CB4h */ case   19:  		/* mr R28, R3 */
		/* 821B8CB4h case   19:*/		regs.R28 = regs.R3;
		/* 821B8CB4h case   19:*/		return 0x821B8CB8;
		  /* 821B8CB8h */ case   20:  		/* li R29, 0 */
		/* 821B8CB8h case   20:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 821B8CB8h case   20:*/		return 0x821B8CBC;
		  /* 821B8CBCh */ case   21:  		/* li R31, 0 */
		/* 821B8CBCh case   21:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 821B8CBCh case   21:*/		return 0x821B8CC0;
		  /* 821B8CC0h */ case   22:  		/* addi R25, R1, 112 */
		/* 821B8CC0h case   22:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R1,0x70);
		/* 821B8CC0h case   22:*/		return 0x821B8CC4;
		  /* 821B8CC4h */ case   23:  		/* slw R11, R16, R31 */
		/* 821B8CC4h case   23:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R16,regs.R31);
		/* 821B8CC4h case   23:*/		return 0x821B8CC8;
		  /* 821B8CC8h */ case   24:  		/* and. R11, R11, R18 */
		/* 821B8CC8h case   24:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R18);
		/* 821B8CC8h case   24:*/		return 0x821B8CCC;
		  /* 821B8CCCh */ case   25:  		/* bc 4, CR0_EQ, 72 */
		/* 821B8CCCh case   25:*/		if ( !regs.CR[0].eq ) { return 0x821B8D14;  }
		/* 821B8CCCh case   25:*/		return 0x821B8CD0;
		  /* 821B8CD0h */ case   26:  		/* lwz R11, <#[R25]> */
		/* 821B8CD0h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 821B8CD0h case   26:*/		return 0x821B8CD4;
		  /* 821B8CD4h */ case   27:  		/* lwz R11, <#[R11 + 8]> */
		/* 821B8CD4h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821B8CD4h case   27:*/		return 0x821B8CD8;
		  /* 821B8CD8h */ case   28:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821B8CD8h case   28:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821B8CD8h case   28:*/		return 0x821B8CDC;
		  /* 821B8CDCh */ case   29:  		/* cmplwi CR6, R11, 16000 */
		/* 821B8CDCh case   29:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E80);
		/* 821B8CDCh case   29:*/		return 0x821B8CE0;
		  /* 821B8CE0h */ case   30:  		/* bc 4, CR6_EQ, 52 */
		/* 821B8CE0h case   30:*/		if ( !regs.CR[6].eq ) { return 0x821B8D14;  }
		/* 821B8CE0h case   30:*/		return 0x821B8CE4;
		  /* 821B8CE4h */ case   31:  		/* li R7, 0 */
		/* 821B8CE4h case   31:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821B8CE4h case   31:*/		return 0x821B8CE8;
		  /* 821B8CE8h */ case   32:  		/* ori R6, R29, 228 */
		/* 821B8CE8h case   32:*/		cpu::op::ori<0>(regs,&regs.R6,regs.R29,0xE4);
		/* 821B8CE8h case   32:*/		return 0x821B8CEC;
		  /* 821B8CECh */ case   33:  		/* li R5, 1 */
		/* 821B8CECh case   33:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 821B8CECh case   33:*/		return 0x821B8CF0;
		  /* 821B8CF0h */ case   34:  		/* mr R4, R28 */
		/* 821B8CF0h case   34:*/		regs.R4 = regs.R28;
		/* 821B8CF0h case   34:*/		return 0x821B8CF4;
		  /* 821B8CF4h */ case   35:  		/* mr R3, R27 */
		/* 821B8CF4h case   35:*/		regs.R3 = regs.R27;
		/* 821B8CF4h case   35:*/		return 0x821B8CF8;
		  /* 821B8CF8h */ case   36:  		/* bl -265272 */
		/* 821B8CF8h case   36:*/		regs.LR = 0x821B8CFC; return 0x821780C0;
		/* 821B8CF8h case   36:*/		return 0x821B8CFC;
		  /* 821B8CFCh */ case   37:  		/* mr R5, R3 */
		/* 821B8CFCh case   37:*/		regs.R5 = regs.R3;
		/* 821B8CFCh case   37:*/		return 0x821B8D00;
		  /* 821B8D00h */ case   38:  		/* mr R6, R27 */
		/* 821B8D00h case   38:*/		regs.R6 = regs.R27;
		/* 821B8D00h case   38:*/		return 0x821B8D04;
		  /* 821B8D04h */ case   39:  		/* mr R4, R31 */
		/* 821B8D04h case   39:*/		regs.R4 = regs.R31;
		/* 821B8D04h case   39:*/		return 0x821B8D08;
		  /* 821B8D08h */ case   40:  		/* mr R3, R26 */
		/* 821B8D08h case   40:*/		regs.R3 = regs.R26;
		/* 821B8D08h case   40:*/		return 0x821B8D0C;
		  /* 821B8D0Ch */ case   41:  		/* addi R29, R29, 1 */
		/* 821B8D0Ch case   41:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 821B8D0Ch case   41:*/		return 0x821B8D10;
		  /* 821B8D10h */ case   42:  		/* bl -257816 */
		/* 821B8D10h case   42:*/		regs.LR = 0x821B8D14; return 0x82179DF8;
		/* 821B8D10h case   42:*/		return 0x821B8D14;
	}
	return 0x821B8D14;
} // Block from 821B8C68h-821B8D14h (43 instructions)

//////////////////////////////////////////////////////
// Block at 821B8D14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8D14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8D14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8D14);
		  /* 821B8D14h */ case    0:  		/* addi R31, R31, 1 */
		/* 821B8D14h case    0:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x1);
		/* 821B8D14h case    0:*/		return 0x821B8D18;
		  /* 821B8D18h */ case    1:  		/* addi R25, R25, 4 */
		/* 821B8D18h case    1:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x4);
		/* 821B8D18h case    1:*/		return 0x821B8D1C;
		  /* 821B8D1Ch */ case    2:  		/* cmplw CR6, R31, R14 */
		/* 821B8D1Ch case    2:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R14);
		/* 821B8D1Ch case    2:*/		return 0x821B8D20;
		  /* 821B8D20h */ case    3:  		/* bc 12, CR6_LT, -92 */
		/* 821B8D20h case    3:*/		if ( regs.CR[6].lt ) { return 0x821B8CC4;  }
		/* 821B8D20h case    3:*/		return 0x821B8D24;
		  /* 821B8D24h */ case    4:  		/* mr R3, R28 */
		/* 821B8D24h case    4:*/		regs.R3 = regs.R28;
		/* 821B8D24h case    4:*/		return 0x821B8D28;
		  /* 821B8D28h */ case    5:  		/* bl -141688 */
		/* 821B8D28h case    5:*/		regs.LR = 0x821B8D2C; return 0x821963B0;
		/* 821B8D28h case    5:*/		return 0x821B8D2C;
		  /* 821B8D2Ch */ case    6:  		/* lwz R11, <#[R28 + 8]> */
		/* 821B8D2Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 821B8D2Ch case    6:*/		return 0x821B8D30;
		  /* 821B8D30h */ case    7:  		/* oris R11, R11, 256 */
		/* 821B8D30h case    7:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x100);
		/* 821B8D30h case    7:*/		return 0x821B8D34;
		  /* 821B8D34h */ case    8:  		/* stw R11, <#[R28 + 8]> */
		/* 821B8D34h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 821B8D34h case    8:*/		return 0x821B8D38;
	}
	return 0x821B8D38;
} // Block from 821B8D14h-821B8D38h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821B8D38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8D38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8D38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8D38);
		  /* 821B8D38h */ case    0:  		/* cmplw CR6, R20, R14 */
		/* 821B8D38h case    0:*/		cpu::op::cmplw<6>(regs,regs.R20,regs.R14);
		/* 821B8D38h case    0:*/		return 0x821B8D3C;
		  /* 821B8D3Ch */ case    1:  		/* bc 4, CR6_LT, 40 */
		/* 821B8D3Ch case    1:*/		if ( !regs.CR[6].lt ) { return 0x821B8D64;  }
		/* 821B8D3Ch case    1:*/		return 0x821B8D40;
		  /* 821B8D40h */ case    2:  		/* rlwinm R10, R17, 31, 3, 29 */
		/* 821B8D40h case    2:*/		cpu::op::rlwinm<0,31,3,29>(regs,&regs.R10,regs.R17);
		/* 821B8D40h case    2:*/		return 0x821B8D44;
		  /* 821B8D44h */ case    3:  		/* addi R11, R1, 80 */
		/* 821B8D44h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 821B8D44h case    3:*/		return 0x821B8D48;
		  /* 821B8D48h */ case    4:  		/* rlwinm R9, R17, 2, 27, 29 */
		/* 821B8D48h case    4:*/		cpu::op::rlwinm<0,2,27,29>(regs,&regs.R9,regs.R17);
		/* 821B8D48h case    4:*/		return 0x821B8D4C;
		  /* 821B8D4Ch */ case    5:  		/* addi R17, R17, 1 */
		/* 821B8D4Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R17,0x1);
		/* 821B8D4Ch case    5:*/		return 0x821B8D50;
		  /* 821B8D50h */ case    6:  		/* slw R9, R19, R9 */
		/* 821B8D50h case    6:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R19,regs.R9);
		/* 821B8D50h case    6:*/		return 0x821B8D54;
		  /* 821B8D54h */ case    7:  		/* lwzx R8, <#[R10 + R11]> */
		/* 821B8D54h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821B8D54h case    7:*/		return 0x821B8D58;
		  /* 821B8D58h */ case    8:  		/* or R9, R9, R8 */
		/* 821B8D58h case    8:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 821B8D58h case    8:*/		return 0x821B8D5C;
		  /* 821B8D5Ch */ case    9:  		/* stwx R9, <#[R10 + R11]> */
		/* 821B8D5Ch case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821B8D5Ch case    9:*/		return 0x821B8D60;
		  /* 821B8D60h */ case   10:  		/* b 200 */
		/* 821B8D60h case   10:*/		return 0x821B8E28;
		/* 821B8D60h case   10:*/		return 0x821B8D64;
	}
	return 0x821B8D64;
} // Block from 821B8D38h-821B8D64h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821B8D64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8D64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8D64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8D64);
		  /* 821B8D64h */ case    0:  		/* li R6, 0 */
		/* 821B8D64h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821B8D64h case    0:*/		return 0x821B8D68;
		  /* 821B8D68h */ case    1:  		/* mr R5, R27 */
		/* 821B8D68h case    1:*/		regs.R5 = regs.R27;
		/* 821B8D68h case    1:*/		return 0x821B8D6C;
		  /* 821B8D6Ch */ case    2:  		/* mr R4, R26 */
		/* 821B8D6Ch case    2:*/		regs.R4 = regs.R26;
		/* 821B8D6Ch case    2:*/		return 0x821B8D70;
		  /* 821B8D70h */ case    3:  		/* addi R3, R1, 96 */
		/* 821B8D70h case    3:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 821B8D70h case    3:*/		return 0x821B8D74;
		  /* 821B8D74h */ case    4:  		/* bl 484532 */
		/* 821B8D74h case    4:*/		regs.LR = 0x821B8D78; return 0x8222F228;
		/* 821B8D74h case    4:*/		return 0x821B8D78;
		  /* 821B8D78h */ case    5:  		/* lwz R11, <#[R26 + 4]> */
		/* 821B8D78h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000004) );
		/* 821B8D78h case    5:*/		return 0x821B8D7C;
		  /* 821B8D7Ch */ case    6:  		/* cmpwi CR6, R11, 0 */
		/* 821B8D7Ch case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 821B8D7Ch case    6:*/		return 0x821B8D80;
		  /* 821B8D80h */ case    7:  		/* bc 12, CR6_EQ, 92 */
		/* 821B8D80h case    7:*/		if ( regs.CR[6].eq ) { return 0x821B8DDC;  }
		/* 821B8D80h case    7:*/		return 0x821B8D84;
		  /* 821B8D84h */ case    8:  		/* li R7, 0 */
		/* 821B8D84h case    8:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821B8D84h case    8:*/		return 0x821B8D88;
		  /* 821B8D88h */ case    9:  		/* lwz R4, <#[R1 + 96]> */
		/* 821B8D88h case    9:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000060) );
		/* 821B8D88h case    9:*/		return 0x821B8D8C;
		  /* 821B8D8Ch */ case   10:  		/* li R6, 228 */
		/* 821B8D8Ch case   10:*/		cpu::op::li<0>(regs,&regs.R6,0xE4);
		/* 821B8D8Ch case   10:*/		return 0x821B8D90;
		  /* 821B8D90h */ case   11:  		/* mr R5, R14 */
		/* 821B8D90h case   11:*/		regs.R5 = regs.R14;
		/* 821B8D90h case   11:*/		return 0x821B8D94;
		  /* 821B8D94h */ case   12:  		/* mr R3, R27 */
		/* 821B8D94h case   12:*/		regs.R3 = regs.R27;
		/* 821B8D94h case   12:*/		return 0x821B8D98;
		  /* 821B8D98h */ case   13:  		/* bl -265432 */
		/* 821B8D98h case   13:*/		regs.LR = 0x821B8D9C; return 0x821780C0;
		/* 821B8D98h case   13:*/		return 0x821B8D9C;
		  /* 821B8D9Ch */ case   14:  		/* mr R7, R3 */
		/* 821B8D9Ch case   14:*/		regs.R7 = regs.R3;
		/* 821B8D9Ch case   14:*/		return 0x821B8DA0;
		  /* 821B8DA0h */ case   15:  		/* mr R6, R3 */
		/* 821B8DA0h case   15:*/		regs.R6 = regs.R3;
		/* 821B8DA0h case   15:*/		return 0x821B8DA4;
		  /* 821B8DA4h */ case   16:  		/* mr R5, R26 */
		/* 821B8DA4h case   16:*/		regs.R5 = regs.R26;
		/* 821B8DA4h case   16:*/		return 0x821B8DA8;
		  /* 821B8DA8h */ case   17:  		/* li R4, 0 */
		/* 821B8DA8h case   17:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 821B8DA8h case   17:*/		return 0x821B8DAC;
		  /* 821B8DACh */ case   18:  		/* mr R3, R27 */
		/* 821B8DACh case   18:*/		regs.R3 = regs.R27;
		/* 821B8DACh case   18:*/		return 0x821B8DB0;
		  /* 821B8DB0h */ case   19:  		/* bl -110328 */
		/* 821B8DB0h case   19:*/		regs.LR = 0x821B8DB4; return 0x8219DEB8;
		/* 821B8DB0h case   19:*/		return 0x821B8DB4;
		  /* 821B8DB4h */ case   20:  		/* li R11, 0 */
		/* 821B8DB4h case   20:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821B8DB4h case   20:*/		return 0x821B8DB8;
		  /* 821B8DB8h */ case   21:  		/* mr R5, R3 */
		/* 821B8DB8h case   21:*/		regs.R5 = regs.R3;
		/* 821B8DB8h case   21:*/		return 0x821B8DBC;
		  /* 821B8DBCh */ case   22:  		/* stb R11, <#[R1 + 92]> */
		/* 821B8DBCh case   22:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x0000005C) );
		/* 821B8DBCh case   22:*/		return 0x821B8DC0;
		  /* 821B8DC0h */ case   23:  		/* addi R9, R1, 92 */
		/* 821B8DC0h case   23:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x5C);
		/* 821B8DC0h case   23:*/		return 0x821B8DC4;
		  /* 821B8DC4h */ case   24:  		/* li R8, 0 */
		/* 821B8DC4h case   24:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821B8DC4h case   24:*/		return 0x821B8DC8;
		  /* 821B8DC8h */ case   25:  		/* li R7, 0 */
		/* 821B8DC8h case   25:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821B8DC8h case   25:*/		return 0x821B8DCC;
		  /* 821B8DCCh */ case   26:  		/* li R6, 228 */
		/* 821B8DCCh case   26:*/		cpu::op::li<0>(regs,&regs.R6,0xE4);
		/* 821B8DCCh case   26:*/		return 0x821B8DD0;
		  /* 821B8DD0h */ case   27:  		/* mr R4, R26 */
		/* 821B8DD0h case   27:*/		regs.R4 = regs.R26;
		/* 821B8DD0h case   27:*/		return 0x821B8DD4;
		  /* 821B8DD4h */ case   28:  		/* mr R3, R27 */
		/* 821B8DD4h case   28:*/		regs.R3 = regs.R27;
		/* 821B8DD4h case   28:*/		return 0x821B8DD8;
		  /* 821B8DD8h */ case   29:  		/* bl 476472 */
		/* 821B8DD8h case   29:*/		regs.LR = 0x821B8DDC; return 0x8222D310;
		/* 821B8DD8h case   29:*/		return 0x821B8DDC;
	}
	return 0x821B8DDC;
} // Block from 821B8D64h-821B8DDCh (30 instructions)

//////////////////////////////////////////////////////
// Block at 821B8DDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8DDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8DDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8DDC);
		  /* 821B8DDCh */ case    0:  		/* lwz R11, <#[R26 + 4]> */
		/* 821B8DDCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000004) );
		/* 821B8DDCh case    0:*/		return 0x821B8DE0;
		  /* 821B8DE0h */ case    1:  		/* mr R3, R27 */
		/* 821B8DE0h case    1:*/		regs.R3 = regs.R27;
		/* 821B8DE0h case    1:*/		return 0x821B8DE4;
		  /* 821B8DE4h */ case    2:  		/* cmpwi CR6, R11, 0 */
		/* 821B8DE4h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 821B8DE4h case    2:*/		return 0x821B8DE8;
		  /* 821B8DE8h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 821B8DE8h case    3:*/		if ( regs.CR[6].eq ) { return 0x821B8DF4;  }
		/* 821B8DE8h case    3:*/		return 0x821B8DEC;
		  /* 821B8DECh */ case    4:  		/* li R4, 4800 */
		/* 821B8DECh case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 821B8DECh case    4:*/		return 0x821B8DF0;
		  /* 821B8DF0h */ case    5:  		/* bl -421768 */
		/* 821B8DF0h case    5:*/		regs.LR = 0x821B8DF4; return 0x82151E68;
		/* 821B8DF0h case    5:*/		return 0x821B8DF4;
	}
	return 0x821B8DF4;
} // Block from 821B8DDCh-821B8DF4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821B8DF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8DF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8DF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8DF4);
		  /* 821B8DF4h */ case    0:  		/* li R6, 1 */
		/* 821B8DF4h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821B8DF4h case    0:*/		return 0x821B8DF8;
		  /* 821B8DF8h */ case    1:  		/* li R5, 0 */
		/* 821B8DF8h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821B8DF8h case    1:*/		return 0x821B8DFC;
		  /* 821B8DFCh */ case    2:  		/* mr R4, R26 */
		/* 821B8DFCh case    2:*/		regs.R4 = regs.R26;
		/* 821B8DFCh case    2:*/		return 0x821B8E00;
		  /* 821B8E00h */ case    3:  		/* bl 468424 */
		/* 821B8E00h case    3:*/		regs.LR = 0x821B8E04; return 0x8222B3C8;
		/* 821B8E00h case    3:*/		return 0x821B8E04;
		  /* 821B8E04h */ case    4:  		/* lwz R3, <#[R1 + 96]> */
		/* 821B8E04h case    4:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000060) );
		/* 821B8E04h case    4:*/		return 0x821B8E08;
		  /* 821B8E08h */ case    5:  		/* bl -141912 */
		/* 821B8E08h case    5:*/		regs.LR = 0x821B8E0C; return 0x821963B0;
		/* 821B8E08h case    5:*/		return 0x821B8E0C;
		  /* 821B8E0Ch */ case    6:  		/* lwz R11, <#[R1 + 96]> */
		/* 821B8E0Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 821B8E0Ch case    6:*/		return 0x821B8E10;
		  /* 821B8E10h */ case    7:  		/* li R3, 1 */
		/* 821B8E10h case    7:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821B8E10h case    7:*/		return 0x821B8E14;
		  /* 821B8E14h */ case    8:  		/* lwz R10, <#[R11 + 8]> */
		/* 821B8E14h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821B8E14h case    8:*/		return 0x821B8E18;
		  /* 821B8E18h */ case    9:  		/* oris R10, R10, 256 */
		/* 821B8E18h case    9:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x100);
		/* 821B8E18h case    9:*/		return 0x821B8E1C;
		  /* 821B8E1Ch */ case   10:  		/* stw R10, <#[R11 + 8]> */
		/* 821B8E1Ch case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821B8E1Ch case   10:*/		return 0x821B8E20;
		  /* 821B8E20h */ case   11:  		/* b 2752 */
		/* 821B8E20h case   11:*/		return 0x821B98E0;
		/* 821B8E20h case   11:*/		return 0x821B8E24;
	}
	return 0x821B8E24;
} // Block from 821B8DF4h-821B8E24h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821B8E24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8E24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8E24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8E24);
		  /* 821B8E24h */ case    0:  		/* lwz R27, <#[R1 + 436]> */
		/* 821B8E24h case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R1 + 0x000001B4) );
		/* 821B8E24h case    0:*/		return 0x821B8E28;
	}
	return 0x821B8E28;
} // Block from 821B8E24h-821B8E28h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B8E28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8E28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8E28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8E28);
		  /* 821B8E28h */ case    0:  		/* li R25, 0 */
		/* 821B8E28h case    0:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 821B8E28h case    0:*/		return 0x821B8E2C;
		  /* 821B8E2Ch */ case    1:  		/* cmplwi CR6, R17, 0 */
		/* 821B8E2Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R17,0x00000000);
		/* 821B8E2Ch case    1:*/		return 0x821B8E30;
		  /* 821B8E30h */ case    2:  		/* bc 12, CR6_EQ, 296 */
		/* 821B8E30h case    2:*/		if ( regs.CR[6].eq ) { return 0x821B8F58;  }
		/* 821B8E30h case    2:*/		return 0x821B8E34;
		  /* 821B8E34h */ case    3:  		/* rlwinm R28, R17, 2, 0, 29 */
		/* 821B8E34h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R28,regs.R17);
		/* 821B8E34h case    3:*/		return 0x821B8E38;
		  /* 821B8E38h */ case    4:  		/* li R31, 0 */
		/* 821B8E38h case    4:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 821B8E38h case    4:*/		return 0x821B8E3C;
		  /* 821B8E3Ch */ case    5:  		/* addi R11, R31, 3 */
		/* 821B8E3Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x3);
		/* 821B8E3Ch case    5:*/		return 0x821B8E40;
		  /* 821B8E40h */ case    6:  		/* rlwinm R4, R31, 0, 27, 31 */
		/* 821B8E40h case    6:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R4,regs.R31);
		/* 821B8E40h case    6:*/		return 0x821B8E44;
		  /* 821B8E44h */ case    7:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 821B8E44h case    7:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 821B8E44h case    7:*/		return 0x821B8E48;
		  /* 821B8E48h */ case    8:  		/* rlwinm R6, R31, 29, 3, 29 */
		/* 821B8E48h case    8:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R6,regs.R31);
		/* 821B8E48h case    8:*/		return 0x821B8E4C;
		  /* 821B8E4Ch */ case    9:  		/* slw R11, R30, R11 */
		/* 821B8E4Ch case    9:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R30,regs.R11);
		/* 821B8E4Ch case    9:*/		return 0x821B8E50;
		  /* 821B8E50h */ case   10:  		/* addi R7, R1, 80 */
		/* 821B8E50h case   10:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 821B8E50h case   10:*/		return 0x821B8E54;
		  /* 821B8E54h */ case   11:  		/* addi R11, R11, -1 */
		/* 821B8E54h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 821B8E54h case   11:*/		return 0x821B8E58;
		  /* 821B8E58h */ case   12:  		/* slw R10, R15, R4 */
		/* 821B8E58h case   12:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R15,regs.R4);
		/* 821B8E58h case   12:*/		return 0x821B8E5C;
		  /* 821B8E5Ch */ case   13:  		/* lwzx R9, <#[R6 + R7]> */
		/* 821B8E5Ch case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + regs.R7 + 0x00000000) );
		/* 821B8E5Ch case   13:*/		return 0x821B8E60;
		  /* 821B8E60h */ case   14:  		/* and R11, R11, R10 */
		/* 821B8E60h case   14:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821B8E60h case   14:*/		return 0x821B8E64;
		  /* 821B8E64h */ case   15:  		/* and R11, R11, R9 */
		/* 821B8E64h case   15:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 821B8E64h case   15:*/		return 0x821B8E68;
		  /* 821B8E68h */ case   16:  		/* srw. R11, R11, R4 */
		/* 821B8E68h case   16:*/		cpu::op::srw<1>(regs,&regs.R11,regs.R11,regs.R4);
		/* 821B8E68h case   16:*/		return 0x821B8E6C;
		  /* 821B8E6Ch */ case   17:  		/* bc 12, CR0_EQ, 24 */
		/* 821B8E6Ch case   17:*/		if ( regs.CR[0].eq ) { return 0x821B8E84;  }
		/* 821B8E6Ch case   17:*/		return 0x821B8E70;
		  /* 821B8E70h */ case   18:  		/* addi R10, R11, -1 */
		/* 821B8E70h case   18:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xFFFFFFFF);
		/* 821B8E70h case   18:*/		return 0x821B8E74;
		  /* 821B8E74h */ case   19:  		/* andc R10, R11, R10 */
		/* 821B8E74h case   19:*/		cpu::op::andc<0>(regs,&regs.R10,regs.R11,regs.R10);
		/* 821B8E74h case   19:*/		return 0x821B8E78;
		  /* 821B8E78h */ case   20:  		/* subf. R10, R10, R11 */
		/* 821B8E78h case   20:*/		cpu::op::subf<1>(regs,&regs.R10,regs.R10,regs.R11);
		/* 821B8E78h case   20:*/		return 0x821B8E7C;
		  /* 821B8E7Ch */ case   21:  		/* li R10, 1 */
		/* 821B8E7Ch case   21:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 821B8E7Ch case   21:*/		return 0x821B8E80;
		  /* 821B8E80h */ case   22:  		/* bc 12, CR0_EQ, 8 */
		/* 821B8E80h case   22:*/		if ( regs.CR[0].eq ) { return 0x821B8E88;  }
		/* 821B8E80h case   22:*/		return 0x821B8E84;
	}
	return 0x821B8E84;
} // Block from 821B8E28h-821B8E84h (23 instructions)

//////////////////////////////////////////////////////
// Block at 821B8E84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8E84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8E84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8E84);
		  /* 821B8E84h */ case    0:  		/* li R10, 0 */
		/* 821B8E84h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821B8E84h case    0:*/		return 0x821B8E88;
	}
	return 0x821B8E88;
} // Block from 821B8E84h-821B8E88h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B8E88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8E88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8E88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8E88);
		  /* 821B8E88h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 821B8E88h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 821B8E88h case    0:*/		return 0x821B8E8C;
		  /* 821B8E8Ch */ case    1:  		/* bc 4, CR0_EQ, 188 */
		/* 821B8E8Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x821B8F48;  }
		/* 821B8E8Ch case    1:*/		return 0x821B8E90;
		  /* 821B8E90h */ case    2:  		/* li R5, 0 */
		/* 821B8E90h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821B8E90h case    2:*/		return 0x821B8E94;
		  /* 821B8E94h */ case    3:  		/* li R29, 0 */
		/* 821B8E94h case    3:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 821B8E94h case    3:*/		return 0x821B8E98;
		  /* 821B8E98h */ case    4:  		/* li R3, 0 */
		/* 821B8E98h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821B8E98h case    4:*/		return 0x821B8E9C;
		  /* 821B8E9Ch */ case    5:  		/* mr R8, R11 */
		/* 821B8E9Ch case    5:*/		regs.R8 = regs.R11;
		/* 821B8E9Ch case    5:*/		return 0x821B8EA0;
		  /* 821B8EA0h */ case    6:  		/* cmplwi CR6, R8, 0 */
		/* 821B8EA0h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 821B8EA0h case    6:*/		return 0x821B8EA4;
		  /* 821B8EA4h */ case    7:  		/* bc 12, CR6_EQ, 148 */
		/* 821B8EA4h case    7:*/		if ( regs.CR[6].eq ) { return 0x821B8F38;  }
		/* 821B8EA4h case    7:*/		return 0x821B8EA8;
		  /* 821B8EA8h */ case    8:  		/* addi R11, R8, -1 */
		/* 821B8EA8h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R8,0xFFFFFFFF);
		/* 821B8EA8h case    8:*/		return 0x821B8EAC;
		  /* 821B8EACh */ case    9:  		/* cmplwi CR6, R5, 0 */
		/* 821B8EACh case    9:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 821B8EACh case    9:*/		return 0x821B8EB0;
		  /* 821B8EB0h */ case   10:  		/* andc R11, R8, R11 */
		/* 821B8EB0h case   10:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 821B8EB0h case   10:*/		return 0x821B8EB4;
		  /* 821B8EB4h */ case   11:  		/* cntlzw R11, R11 */
		/* 821B8EB4h case   11:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 821B8EB4h case   11:*/		return 0x821B8EB8;
		  /* 821B8EB8h */ case   12:  		/* subfic R11, R11, 31 */
		/* 821B8EB8h case   12:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R11,0x1F);
		/* 821B8EB8h case   12:*/		return 0x821B8EBC;
		  /* 821B8EBCh */ case   13:  		/* addi R10, R11, 11 */
		/* 821B8EBCh case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0xB);
		/* 821B8EBCh case   13:*/		return 0x821B8EC0;
		  /* 821B8EC0h */ case   14:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821B8EC0h case   14:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821B8EC0h case   14:*/		return 0x821B8EC4;
		  /* 821B8EC4h */ case   15:  		/* lwzx R10, <#[R10 + R26]> */
		/* 821B8EC4h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R26 + 0x00000000) );
		/* 821B8EC4h case   15:*/		return 0x821B8EC8;
		  /* 821B8EC8h */ case   16:  		/* lwz R9, <#[R10]> */
		/* 821B8EC8h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821B8EC8h case   16:*/		return 0x821B8ECC;
		  /* 821B8ECCh */ case   17:  		/* lwz R10, <#[R10 + 12]> */
		/* 821B8ECCh case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000000C) );
		/* 821B8ECCh case   17:*/		return 0x821B8ED0;
		  /* 821B8ED0h */ case   18:  		/* rlwinm R9, R9, 0, 27, 31 */
		/* 821B8ED0h case   18:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R9);
		/* 821B8ED0h case   18:*/		return 0x821B8ED4;
		  /* 821B8ED4h */ case   19:  		/* bc 4, CR6_EQ, 16 */
		/* 821B8ED4h case   19:*/		if ( !regs.CR[6].eq ) { return 0x821B8EE4;  }
		/* 821B8ED4h case   19:*/		return 0x821B8ED8;
		  /* 821B8ED8h */ case   20:  		/* mr R5, R10 */
		/* 821B8ED8h case   20:*/		regs.R5 = regs.R10;
		/* 821B8ED8h case   20:*/		return 0x821B8EDC;
		  /* 821B8EDCh */ case   21:  		/* mr R29, R9 */
		/* 821B8EDCh case   21:*/		regs.R29 = regs.R9;
		/* 821B8EDCh case   21:*/		return 0x821B8EE0;
		  /* 821B8EE0h */ case   22:  		/* b 72 */
		/* 821B8EE0h case   22:*/		return 0x821B8F28;
		/* 821B8EE0h case   22:*/		return 0x821B8EE4;
	}
	return 0x821B8EE4;
} // Block from 821B8E88h-821B8EE4h (23 instructions)

//////////////////////////////////////////////////////
// Block at 821B8EE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8EE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8EE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8EE4);
		  /* 821B8EE4h */ case    0:  		/* cmplw CR6, R10, R5 */
		/* 821B8EE4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R5);
		/* 821B8EE4h case    0:*/		return 0x821B8EE8;
		  /* 821B8EE8h */ case    1:  		/* bc 4, CR6_EQ, 12 */
		/* 821B8EE8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821B8EF4;  }
		/* 821B8EE8h case    1:*/		return 0x821B8EEC;
		  /* 821B8EECh */ case    2:  		/* cmplw CR6, R9, R29 */
		/* 821B8EECh case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R29);
		/* 821B8EECh case    2:*/		return 0x821B8EF0;
		  /* 821B8EF0h */ case    3:  		/* bc 12, CR6_EQ, 56 */
		/* 821B8EF0h case    3:*/		if ( regs.CR[6].eq ) { return 0x821B8F28;  }
		/* 821B8EF0h case    3:*/		return 0x821B8EF4;
	}
	return 0x821B8EF4;
} // Block from 821B8EE4h-821B8EF4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821B8EF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8EF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8EF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8EF4);
		  /* 821B8EF4h */ case    0:  		/* li R3, 1 */
		/* 821B8EF4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821B8EF4h case    0:*/		return 0x821B8EF8;
		  /* 821B8EF8h */ case    1:  		/* lwzx R9, <#[R6 + R7]> */
		/* 821B8EF8h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R6 + regs.R7 + 0x00000000) );
		/* 821B8EF8h case    1:*/		return 0x821B8EFC;
		  /* 821B8EFCh */ case    2:  		/* rlwinm R10, R28, 29, 3, 29 */
		/* 821B8EFCh case    2:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R10,regs.R28);
		/* 821B8EFCh case    2:*/		return 0x821B8F00;
		  /* 821B8F00h */ case    3:  		/* slw R24, R3, R11 */
		/* 821B8F00h case    3:*/		cpu::op::slw<0>(regs,&regs.R24,regs.R3,regs.R11);
		/* 821B8F00h case    3:*/		return 0x821B8F04;
		  /* 821B8F04h */ case    4:  		/* slw R11, R24, R4 */
		/* 821B8F04h case    4:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R24,regs.R4);
		/* 821B8F04h case    4:*/		return 0x821B8F08;
		  /* 821B8F08h */ case    5:  		/* subf R9, R11, R9 */
		/* 821B8F08h case    5:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 821B8F08h case    5:*/		return 0x821B8F0C;
		  /* 821B8F0Ch */ case    6:  		/* addi R11, R1, 80 */
		/* 821B8F0Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x50);
		/* 821B8F0Ch case    6:*/		return 0x821B8F10;
		  /* 821B8F10h */ case    7:  		/* stwx R9, <#[R6 + R7]> */
		/* 821B8F10h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R6 + regs.R7 + 0x00000000) );
		/* 821B8F10h case    7:*/		return 0x821B8F14;
		  /* 821B8F14h */ case    8:  		/* rlwinm R9, R28, 0, 27, 31 */
		/* 821B8F14h case    8:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R28);
		/* 821B8F14h case    8:*/		return 0x821B8F18;
		  /* 821B8F18h */ case    9:  		/* slw R9, R24, R9 */
		/* 821B8F18h case    9:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R24,regs.R9);
		/* 821B8F18h case    9:*/		return 0x821B8F1C;
		  /* 821B8F1Ch */ case   10:  		/* lwzx R24, <#[R10 + R11]> */
		/* 821B8F1Ch case   10:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821B8F1Ch case   10:*/		return 0x821B8F20;
		  /* 821B8F20h */ case   11:  		/* or R9, R9, R24 */
		/* 821B8F20h case   11:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R24);
		/* 821B8F20h case   11:*/		return 0x821B8F24;
		  /* 821B8F24h */ case   12:  		/* stwx R9, <#[R10 + R11]> */
		/* 821B8F24h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821B8F24h case   12:*/		return 0x821B8F28;
	}
	return 0x821B8F28;
} // Block from 821B8EF4h-821B8F28h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821B8F28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8F28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8F28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8F28);
		  /* 821B8F28h */ case    0:  		/* addi R11, R8, -1 */
		/* 821B8F28h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R8,0xFFFFFFFF);
		/* 821B8F28h case    0:*/		return 0x821B8F2C;
		  /* 821B8F2Ch */ case    1:  		/* andc R11, R8, R11 */
		/* 821B8F2Ch case    1:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 821B8F2Ch case    1:*/		return 0x821B8F30;
		  /* 821B8F30h */ case    2:  		/* subf R8, R11, R8 */
		/* 821B8F30h case    2:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R11,regs.R8);
		/* 821B8F30h case    2:*/		return 0x821B8F34;
		  /* 821B8F34h */ case    3:  		/* b -148 */
		/* 821B8F34h case    3:*/		return 0x821B8EA0;
		/* 821B8F34h case    3:*/		return 0x821B8F38;
	}
	return 0x821B8F38;
} // Block from 821B8F28h-821B8F38h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821B8F38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8F38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8F38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8F38);
		  /* 821B8F38h */ case    0:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821B8F38h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821B8F38h case    0:*/		return 0x821B8F3C;
		  /* 821B8F3Ch */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 821B8F3Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x821B8F48;  }
		/* 821B8F3Ch case    1:*/		return 0x821B8F40;
		  /* 821B8F40h */ case    2:  		/* addi R17, R17, 1 */
		/* 821B8F40h case    2:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R17,0x1);
		/* 821B8F40h case    2:*/		return 0x821B8F44;
		  /* 821B8F44h */ case    3:  		/* addi R28, R28, 4 */
		/* 821B8F44h case    3:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x4);
		/* 821B8F44h case    3:*/		return 0x821B8F48;
	}
	return 0x821B8F48;
} // Block from 821B8F38h-821B8F48h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821B8F48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8F48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8F48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8F48);
		  /* 821B8F48h */ case    0:  		/* addi R25, R25, 1 */
		/* 821B8F48h case    0:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x1);
		/* 821B8F48h case    0:*/		return 0x821B8F4C;
		  /* 821B8F4Ch */ case    1:  		/* addi R31, R31, 4 */
		/* 821B8F4Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 821B8F4Ch case    1:*/		return 0x821B8F50;
		  /* 821B8F50h */ case    2:  		/* cmplw CR6, R25, R17 */
		/* 821B8F50h case    2:*/		cpu::op::cmplw<6>(regs,regs.R25,regs.R17);
		/* 821B8F50h case    2:*/		return 0x821B8F54;
		  /* 821B8F54h */ case    3:  		/* bc 12, CR6_LT, -280 */
		/* 821B8F54h case    3:*/		if ( regs.CR[6].lt ) { return 0x821B8E3C;  }
		/* 821B8F54h case    3:*/		return 0x821B8F58;
	}
	return 0x821B8F58;
} // Block from 821B8F48h-821B8F58h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821B8F58h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B8F58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B8F58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B8F58);
		  /* 821B8F58h */ case    0:  		/* lwz R15, <#[R1 + 444]> */
		/* 821B8F58h case    0:*/		cpu::mem::load32z( regs, &regs.R15, (uint32)(regs.R1 + 0x000001BC) );
		/* 821B8F58h case    0:*/		return 0x821B8F5C;
		  /* 821B8F5Ch */ case    1:  		/* li R21, 0 */
		/* 821B8F5Ch case    1:*/		cpu::op::li<0>(regs,&regs.R21,0x0);
		/* 821B8F5Ch case    1:*/		return 0x821B8F60;
		  /* 821B8F60h */ case    2:  		/* lwz R16, <#[R1 + 80]> */
		/* 821B8F60h case    2:*/		cpu::mem::load32z( regs, &regs.R16, (uint32)(regs.R1 + 0x00000050) );
		/* 821B8F60h case    2:*/		return 0x821B8F64;
		  /* 821B8F64h */ case    3:  		/* li R18, 0 */
		/* 821B8F64h case    3:*/		cpu::op::li<0>(regs,&regs.R18,0x0);
		/* 821B8F64h case    3:*/		return 0x821B8F68;
		  /* 821B8F68h */ case    4:  		/* cmplwi CR6, R17, 2 */
		/* 821B8F68h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R17,0x00000002);
		/* 821B8F68h case    4:*/		return 0x821B8F6C;
		  /* 821B8F6Ch */ case    5:  		/* bc 12, CR6_LT, 852 */
		/* 821B8F6Ch case    5:*/		if ( regs.CR[6].lt ) { return 0x821B92C0;  }
		/* 821B8F6Ch case    5:*/		return 0x821B8F70;
		  /* 821B8F70h */ case    6:  		/* lis R11, -32256 */
		/* 821B8F70h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 821B8F70h case    6:*/		return 0x821B8F74;
		  /* 821B8F74h */ case    7:  		/* lis R10, -32256 */
		/* 821B8F74h case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 821B8F74h case    7:*/		return 0x821B8F78;
		  /* 821B8F78h */ case    8:  		/* lfs FR30, <#[R11 + 1792]> */
		/* 821B8F78h case    8:*/		cpu::mem::load32f( regs, &regs.FR30, (uint32)(regs.R11 + 0x00000700) );
		/* 821B8F78h case    8:*/		return 0x821B8F7C;
		  /* 821B8F7Ch */ case    9:  		/* lfs FR31, <#[R10 + 1816]> */
		/* 821B8F7Ch case    9:*/		cpu::mem::load32f( regs, &regs.FR31, (uint32)(regs.R10 + 0x00000718) );
		/* 821B8F7Ch case    9:*/		return 0x821B8F80;
		  /* 821B8F80h */ case   10:  		/* rlwinm R25, R16, 0, 28, 31 */
		/* 821B8F80h case   10:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R25,regs.R16);
		/* 821B8F80h case   10:*/		return 0x821B8F84;
		  /* 821B8F84h */ case   11:  		/* li R7, 0 */
		/* 821B8F84h case   11:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821B8F84h case   11:*/		return 0x821B8F88;
		  /* 821B8F88h */ case   12:  		/* mr R6, R25 */
		/* 821B8F88h case   12:*/		regs.R6 = regs.R25;
		/* 821B8F88h case   12:*/		return 0x821B8F8C;
		  /* 821B8F8Ch */ case   13:  		/* mr R5, R14 */
		/* 821B8F8Ch case   13:*/		regs.R5 = regs.R14;
		/* 821B8F8Ch case   13:*/		return 0x821B8F90;
		  /* 821B8F90h */ case   14:  		/* mr R4, R26 */
		/* 821B8F90h case   14:*/		regs.R4 = regs.R26;
		/* 821B8F90h case   14:*/		return 0x821B8F94;
		  /* 821B8F94h */ case   15:  		/* mr R3, R27 */
		/* 821B8F94h case   15:*/		regs.R3 = regs.R27;
		/* 821B8F94h case   15:*/		return 0x821B8F98;
		  /* 821B8F98h */ case   16:  		/* bl -10696 */
		/* 821B8F98h case   16:*/		regs.LR = 0x821B8F9C; return 0x821B65D0;
		/* 821B8F98h case   16:*/		return 0x821B8F9C;
		  /* 821B8F9Ch */ case   17:  		/* lwz R11, <#[R3]> */
		/* 821B8F9Ch case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821B8F9Ch case   17:*/		return 0x821B8FA0;
		  /* 821B8FA0h */ case   18:  		/* rlwinm R24, R16, 28, 28, 31 */
		/* 821B8FA0h case   18:*/		cpu::op::rlwinm<0,28,28,31>(regs,&regs.R24,regs.R16);
		/* 821B8FA0h case   18:*/		return 0x821B8FA4;
		  /* 821B8FA4h */ case   19:  		/* rlwinm R28, R11, 7, 29, 31 */
		/* 821B8FA4h case   19:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R28,regs.R11);
		/* 821B8FA4h case   19:*/		return 0x821B8FA8;
		  /* 821B8FA8h */ case   20:  		/* mr R29, R3 */
		/* 821B8FA8h case   20:*/		regs.R29 = regs.R3;
		/* 821B8FA8h case   20:*/		return 0x821B8FAC;
		  /* 821B8FACh */ case   21:  		/* mr R5, R14 */
		/* 821B8FACh case   21:*/		regs.R5 = regs.R14;
		/* 821B8FACh case   21:*/		return 0x821B8FB0;
		  /* 821B8FB0h */ case   22:  		/* mr R6, R24 */
		/* 821B8FB0h case   22:*/		regs.R6 = regs.R24;
		/* 821B8FB0h case   22:*/		return 0x821B8FB4;
		  /* 821B8FB4h */ case   23:  		/* mr R4, R26 */
		/* 821B8FB4h case   23:*/		regs.R4 = regs.R26;
		/* 821B8FB4h case   23:*/		return 0x821B8FB8;
		  /* 821B8FB8h */ case   24:  		/* mr R3, R27 */
		/* 821B8FB8h case   24:*/		regs.R3 = regs.R27;
		/* 821B8FB8h case   24:*/		return 0x821B8FBC;
		  /* 821B8FBCh */ case   25:  		/* mr R7, R28 */
		/* 821B8FBCh case   25:*/		regs.R7 = regs.R28;
		/* 821B8FBCh case   25:*/		return 0x821B8FC0;
		  /* 821B8FC0h */ case   26:  		/* bl -10736 */
		/* 821B8FC0h case   26:*/		regs.LR = 0x821B8FC4; return 0x821B65D0;
		/* 821B8FC0h case   26:*/		return 0x821B8FC4;
		  /* 821B8FC4h */ case   27:  		/* lwz R10, <#[R3]> */
		/* 821B8FC4h case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 821B8FC4h case   27:*/		return 0x821B8FC8;
		  /* 821B8FC8h */ case   28:  		/* lwz R11, <#[R29]> */
		/* 821B8FC8h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 821B8FC8h case   28:*/		return 0x821B8FCC;
		  /* 821B8FCCh */ case   29:  		/* mr R22, R3 */
		/* 821B8FCCh case   29:*/		regs.R22 = regs.R3;
		/* 821B8FCCh case   29:*/		return 0x821B8FD0;
		  /* 821B8FD0h */ case   30:  		/* rlwinm R23, R10, 7, 29, 31 */
		/* 821B8FD0h case   30:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R23,regs.R10);
		/* 821B8FD0h case   30:*/		return 0x821B8FD4;
		  /* 821B8FD4h */ case   31:  		/* rlwinm R11, R11, 27, 24, 31 */
		/* 821B8FD4h case   31:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R11,regs.R11);
		/* 821B8FD4h case   31:*/		return 0x821B8FD8;
		  /* 821B8FD8h */ case   32:  		/* cmplw CR6, R28, R23 */
		/* 821B8FD8h case   32:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R23);
		/* 821B8FD8h case   32:*/		return 0x821B8FDC;
		  /* 821B8FDCh */ case   33:  		/* bc 4, CR6_LT, 60 */
		/* 821B8FDCh case   33:*/		if ( !regs.CR[6].lt ) { return 0x821B9018;  }
		/* 821B8FDCh case   33:*/		return 0x821B8FE0;
		  /* 821B8FE0h */ case   34:  		/* subf R8, R28, R23 */
		/* 821B8FE0h case   34:*/		cpu::op::subf<0>(regs,&regs.R8,regs.R28,regs.R23);
		/* 821B8FE0h case   34:*/		return 0x821B8FE4;
		  /* 821B8FE4h */ case   35:  		/* addi R9, R28, -1 */
		/* 821B8FE4h case   35:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R28,0xFFFFFFFF);
		/* 821B8FE4h case   35:*/		return 0x821B8FE8;
		  /* 821B8FE8h */ case   36:  		/* rlwinm R10, R28, 1, 0, 30 */
		/* 821B8FE8h case   36:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R28);
		/* 821B8FE8h case   36:*/		return 0x821B8FEC;
		  /* 821B8FECh */ case   37:  		/* rlwinm R9, R9, 1, 0, 30 */
		/* 821B8FECh case   37:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R9,regs.R9);
		/* 821B8FECh case   37:*/		return 0x821B8FF0;
		  /* 821B8FF0h */ case   38:  		/* mtspr CTR, R8 */
		/* 821B8FF0h case   38:*/		regs.CTR = regs.R8;
		/* 821B8FF0h case   38:*/		return 0x821B8FF4;
		  /* 821B8FF4h */ case   39:  		/* srw R8, R11, R9 */
		/* 821B8FF4h case   39:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R11,regs.R9);
		/* 821B8FF4h case   39:*/		return 0x821B8FF8;
		  /* 821B8FF8h */ case   40:  		/* li R7, 3 */
		/* 821B8FF8h case   40:*/		cpu::op::li<0>(regs,&regs.R7,0x3);
		/* 821B8FF8h case   40:*/		return 0x821B8FFC;
		  /* 821B8FFCh */ case   41:  		/* rlwinm R8, R8, 0, 30, 31 */
		/* 821B8FFCh case   41:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R8,regs.R8);
		/* 821B8FFCh case   41:*/		return 0x821B9000;
		  /* 821B9000h */ case   42:  		/* slw R7, R7, R10 */
		/* 821B9000h case   42:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R7,regs.R10);
		/* 821B9000h case   42:*/		return 0x821B9004;
		  /* 821B9004h */ case   43:  		/* slw R8, R8, R10 */
		/* 821B9004h case   43:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R8,regs.R10);
		/* 821B9004h case   43:*/		return 0x821B9008;
		  /* 821B9008h */ case   44:  		/* andc R11, R11, R7 */
		/* 821B9008h case   44:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 821B9008h case   44:*/		return 0x821B900C;
		  /* 821B900Ch */ case   45:  		/* addi R10, R10, 2 */
		/* 821B900Ch case   45:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 821B900Ch case   45:*/		return 0x821B9010;
		  /* 821B9010h */ case   46:  		/* or R11, R8, R11 */
		/* 821B9010h case   46:*/		cpu::op::or<0>(regs,&regs.R11,regs.R8,regs.R11);
		/* 821B9010h case   46:*/		return 0x821B9014;
		  /* 821B9014h */ case   47:  		/* bc 16, CR0_LT, -32 */
		/* 821B9014h case   47:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x821B8FF4;  }
		/* 821B9014h case   47:*/		return 0x821B9018;
	}
	return 0x821B9018;
} // Block from 821B8F58h-821B9018h (48 instructions)

//////////////////////////////////////////////////////
// Block at 821B9018h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9018( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9018) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9018);
		  /* 821B9018h */ case    0:  		/* lwz R9, <#[R29]> */
		/* 821B9018h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000000) );
		/* 821B9018h case    0:*/		return 0x821B901C;
		  /* 821B901Ch */ case    1:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 821B901Ch case    1:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821B901Ch case    1:*/		return 0x821B9020;
		  /* 821B9020h */ case    2:  		/* rlwinm R10, R23, 20, 9, 11 */
		/* 821B9020h case    2:*/		cpu::op::rlwinm<0,20,9,11>(regs,&regs.R10,regs.R23);
		/* 821B9020h case    2:*/		return 0x821B9024;
		  /* 821B9024h */ case    3:  		/* lwz R3, <#[R29 + 12]> */
		/* 821B9024h case    3:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R29 + 0x0000000C) );
		/* 821B9024h case    3:*/		return 0x821B9028;
		  /* 821B9028h */ case    4:  		/* rlwinm R9, R9, 0, 27, 18 */
		/* 821B9028h case    4:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R9,regs.R9);
		/* 821B9028h case    4:*/		return 0x821B902C;
		  /* 821B902Ch */ case    5:  		/* or R11, R10, R11 */
		/* 821B902Ch case    5:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821B902Ch case    5:*/		return 0x821B9030;
		  /* 821B9030h */ case    6:  		/* rlwinm R9, R9, 0, 7, 3 */
		/* 821B9030h case    6:*/		cpu::op::rlwinm<0,0,7,3>(regs,&regs.R9,regs.R9);
		/* 821B9030h case    6:*/		return 0x821B9034;
		  /* 821B9034h */ case    7:  		/* rlwinm R11, R11, 5, 0, 26 */
		/* 821B9034h case    7:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R11);
		/* 821B9034h case    7:*/		return 0x821B9038;
		  /* 821B9038h */ case    8:  		/* mr R20, R3 */
		/* 821B9038h case    8:*/		regs.R20 = regs.R3;
		/* 821B9038h case    8:*/		return 0x821B903C;
		  /* 821B903Ch */ case    9:  		/* or R10, R11, R9 */
		/* 821B903Ch case    9:*/		cpu::op::or<0>(regs,&regs.R10,regs.R11,regs.R9);
		/* 821B903Ch case    9:*/		return 0x821B9040;
		  /* 821B9040h */ case   10:  		/* stw R10, <#[R29]> */
		/* 821B9040h case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 821B9040h case   10:*/		return 0x821B9044;
		  /* 821B9044h */ case   11:  		/* lwz R11, <#[R3 + 8]> */
		/* 821B9044h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821B9044h case   11:*/		return 0x821B9048;
		  /* 821B9048h */ case   12:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821B9048h case   12:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821B9048h case   12:*/		return 0x821B904C;
		  /* 821B904Ch */ case   13:  		/* cmplwi CR6, R11, 15104 */
		/* 821B904Ch case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003B00);
		/* 821B904Ch case   13:*/		return 0x821B9050;
		  /* 821B9050h */ case   14:  		/* bc 4, CR6_EQ, 12 */
		/* 821B9050h case   14:*/		if ( !regs.CR[6].eq ) { return 0x821B905C;  }
		/* 821B9050h case   14:*/		return 0x821B9054;
		  /* 821B9054h */ case   15:  		/* lwz R11, <#[R3 + 44]> */
		/* 821B9054h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000002C) );
		/* 821B9054h case   15:*/		return 0x821B9058;
		  /* 821B9058h */ case   16:  		/* lwz R20, <#[R11 + 12]> */
		/* 821B9058h case   16:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R11 + 0x0000000C) );
		/* 821B9058h case   16:*/		return 0x821B905C;
	}
	return 0x821B905C;
} // Block from 821B9018h-821B905Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 821B905Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B905C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B905C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B905C);
		  /* 821B905Ch */ case    0:  		/* lwz R9, <#[R22 + 12]> */
		/* 821B905Ch case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R22 + 0x0000000C) );
		/* 821B905Ch case    0:*/		return 0x821B9060;
		  /* 821B9060h */ case    1:  		/* mr R19, R9 */
		/* 821B9060h case    1:*/		regs.R19 = regs.R9;
		/* 821B9060h case    1:*/		return 0x821B9064;
		  /* 821B9064h */ case    2:  		/* lwz R11, <#[R9 + 8]> */
		/* 821B9064h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000008) );
		/* 821B9064h case    2:*/		return 0x821B9068;
		  /* 821B9068h */ case    3:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821B9068h case    3:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821B9068h case    3:*/		return 0x821B906C;
		  /* 821B906Ch */ case    4:  		/* cmplwi CR6, R11, 15104 */
		/* 821B906Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003B00);
		/* 821B906Ch case    4:*/		return 0x821B9070;
		  /* 821B9070h */ case    5:  		/* bc 4, CR6_EQ, 12 */
		/* 821B9070h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821B907C;  }
		/* 821B9070h case    5:*/		return 0x821B9074;
		  /* 821B9074h */ case    6:  		/* lwz R11, <#[R9 + 44]> */
		/* 821B9074h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x0000002C) );
		/* 821B9074h case    6:*/		return 0x821B9078;
		  /* 821B9078h */ case    7:  		/* lwz R19, <#[R11 + 12]> */
		/* 821B9078h case    7:*/		cpu::mem::load32z( regs, &regs.R19, (uint32)(regs.R11 + 0x0000000C) );
		/* 821B9078h case    7:*/		return 0x821B907C;
	}
	return 0x821B907C;
} // Block from 821B905Ch-821B907Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 821B907Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B907C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B907C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B907C);
		  /* 821B907Ch */ case    0:  		/* lwz R11, <#[R20 + 8]> */
		/* 821B907Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000008) );
		/* 821B907Ch case    0:*/		return 0x821B9080;
		  /* 821B9080h */ case    1:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821B9080h case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821B9080h case    1:*/		return 0x821B9084;
		  /* 821B9084h */ case    2:  		/* cmplwi CR6, R11, 125 */
		/* 821B9084h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 821B9084h case    2:*/		return 0x821B9088;
		  /* 821B9088h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 821B9088h case    3:*/		if ( regs.CR[6].eq ) { return 0x821B9098;  }
		/* 821B9088h case    3:*/		return 0x821B908C;
		  /* 821B908Ch */ case    4:  		/* cmplwi CR6, R11, 124 */
		/* 821B908Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 821B908Ch case    4:*/		return 0x821B9090;
		  /* 821B9090h */ case    5:  		/* li R11, 0 */
		/* 821B9090h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821B9090h case    5:*/		return 0x821B9094;
		  /* 821B9094h */ case    6:  		/* bc 4, CR6_EQ, 8 */
		/* 821B9094h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821B909C;  }
		/* 821B9094h case    6:*/		return 0x821B9098;
	}
	return 0x821B9098;
} // Block from 821B907Ch-821B9098h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821B9098h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9098( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9098) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9098);
		  /* 821B9098h */ case    0:  		/* li R11, 1 */
		/* 821B9098h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821B9098h case    0:*/		return 0x821B909C;
	}
	return 0x821B909C;
} // Block from 821B9098h-821B909Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B909Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B909C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B909C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B909C);
		  /* 821B909Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821B909Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821B909Ch case    0:*/		return 0x821B90A0;
		  /* 821B90A0h */ case    1:  		/* bc 12, CR0_EQ, 80 */
		/* 821B90A0h case    1:*/		if ( regs.CR[0].eq ) { return 0x821B90F0;  }
		/* 821B90A0h case    1:*/		return 0x821B90A4;
		  /* 821B90A4h */ case    2:  		/* lwz R11, <#[R19 + 8]> */
		/* 821B90A4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000008) );
		/* 821B90A4h case    2:*/		return 0x821B90A8;
		  /* 821B90A8h */ case    3:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821B90A8h case    3:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821B90A8h case    3:*/		return 0x821B90AC;
		  /* 821B90ACh */ case    4:  		/* cmplwi CR6, R11, 125 */
		/* 821B90ACh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 821B90ACh case    4:*/		return 0x821B90B0;
		  /* 821B90B0h */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 821B90B0h case    5:*/		if ( regs.CR[6].eq ) { return 0x821B90C0;  }
		/* 821B90B0h case    5:*/		return 0x821B90B4;
		  /* 821B90B4h */ case    6:  		/* cmplwi CR6, R11, 124 */
		/* 821B90B4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 821B90B4h case    6:*/		return 0x821B90B8;
		  /* 821B90B8h */ case    7:  		/* li R11, 0 */
		/* 821B90B8h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821B90B8h case    7:*/		return 0x821B90BC;
		  /* 821B90BCh */ case    8:  		/* bc 4, CR6_EQ, 8 */
		/* 821B90BCh case    8:*/		if ( !regs.CR[6].eq ) { return 0x821B90C4;  }
		/* 821B90BCh case    8:*/		return 0x821B90C0;
	}
	return 0x821B90C0;
} // Block from 821B909Ch-821B90C0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821B90C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B90C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B90C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B90C0);
		  /* 821B90C0h */ case    0:  		/* li R11, 1 */
		/* 821B90C0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821B90C0h case    0:*/		return 0x821B90C4;
	}
	return 0x821B90C4;
} // Block from 821B90C0h-821B90C4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B90C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B90C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B90C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B90C4);
		  /* 821B90C4h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821B90C4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821B90C4h case    0:*/		return 0x821B90C8;
		  /* 821B90C8h */ case    1:  		/* bc 12, CR0_EQ, 40 */
		/* 821B90C8h case    1:*/		if ( regs.CR[0].eq ) { return 0x821B90F0;  }
		/* 821B90C8h case    1:*/		return 0x821B90CC;
		  /* 821B90CCh */ case    2:  		/* lwz R11, <#[R22]> */
		/* 821B90CCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 821B90CCh case    2:*/		return 0x821B90D0;
		  /* 821B90D0h */ case    3:  		/* xor R8, R10, R11 */
		/* 821B90D0h case    3:*/		cpu::op::xor<0>(regs,&regs.R8,regs.R10,regs.R11);
		/* 821B90D0h case    3:*/		return 0x821B90D4;
		  /* 821B90D4h */ case    4:  		/* rlwinm. R8, R8, 0, 27, 28 */
		/* 821B90D4h case    4:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R8,regs.R8);
		/* 821B90D4h case    4:*/		return 0x821B90D8;
		  /* 821B90D8h */ case    5:  		/* bc 4, CR0_EQ, 460 */
		/* 821B90D8h case    5:*/		if ( !regs.CR[0].eq ) { return 0x821B92A4;  }
		/* 821B90D8h case    5:*/		return 0x821B90DC;
		  /* 821B90DCh */ case    6:  		/* rlwinm R11, R11, 31, 1, 31 */
		/* 821B90DCh case    6:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R11,regs.R11);
		/* 821B90DCh case    6:*/		return 0x821B90E0;
		  /* 821B90E0h */ case    7:  		/* rlwinm R10, R10, 31, 1, 31 */
		/* 821B90E0h case    7:*/		cpu::op::rlwinm<0,31,1,31>(regs,&regs.R10,regs.R10);
		/* 821B90E0h case    7:*/		return 0x821B90E4;
		  /* 821B90E4h */ case    8:  		/* xor R11, R10, R11 */
		/* 821B90E4h case    8:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821B90E4h case    8:*/		return 0x821B90E8;
		  /* 821B90E8h */ case    9:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821B90E8h case    9:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821B90E8h case    9:*/		return 0x821B90EC;
		  /* 821B90ECh */ case   10:  		/* bc 4, CR0_EQ, 440 */
		/* 821B90ECh case   10:*/		if ( !regs.CR[0].eq ) { return 0x821B92A4;  }
		/* 821B90ECh case   10:*/		return 0x821B90F0;
	}
	return 0x821B90F0;
} // Block from 821B90C4h-821B90F0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821B90F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B90F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B90F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B90F0);
		  /* 821B90F0h */ case    0:  		/* cmplwi CR6, R28, 3 */
		/* 821B90F0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000003);
		/* 821B90F0h case    0:*/		return 0x821B90F4;
		  /* 821B90F4h */ case    1:  		/* bc 4, CR6_GT, 12 */
		/* 821B90F4h case    1:*/		if ( !regs.CR[6].gt ) { return 0x821B9100;  }
		/* 821B90F4h case    1:*/		return 0x821B90F8;
		  /* 821B90F8h */ case    2:  		/* fmr FR4, FR31 */
		/* 821B90F8h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR4,regs.FR31);
		/* 821B90F8h case    2:*/		return 0x821B90FC;
		  /* 821B90FCh */ case    3:  		/* b 8 */
		/* 821B90FCh case    3:*/		return 0x821B9104;
		/* 821B90FCh case    3:*/		return 0x821B9100;
	}
	return 0x821B9100;
} // Block from 821B90F0h-821B9100h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821B9100h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9100( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9100) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9100);
		  /* 821B9100h */ case    0:  		/* fmr FR4, FR30 */
		/* 821B9100h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR4,regs.FR30);
		/* 821B9100h case    0:*/		return 0x821B9104;
	}
	return 0x821B9104;
} // Block from 821B9100h-821B9104h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B9104h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9104( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9104) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9104);
		  /* 821B9104h */ case    0:  		/* cmplwi CR6, R28, 2 */
		/* 821B9104h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000002);
		/* 821B9104h case    0:*/		return 0x821B9108;
		  /* 821B9108h */ case    1:  		/* bc 4, CR6_GT, 12 */
		/* 821B9108h case    1:*/		if ( !regs.CR[6].gt ) { return 0x821B9114;  }
		/* 821B9108h case    1:*/		return 0x821B910C;
		  /* 821B910Ch */ case    2:  		/* fmr FR3, FR31 */
		/* 821B910Ch case    2:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR31);
		/* 821B910Ch case    2:*/		return 0x821B9110;
		  /* 821B9110h */ case    3:  		/* b 8 */
		/* 821B9110h case    3:*/		return 0x821B9118;
		/* 821B9110h case    3:*/		return 0x821B9114;
	}
	return 0x821B9114;
} // Block from 821B9104h-821B9114h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821B9114h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9114( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9114) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9114);
		  /* 821B9114h */ case    0:  		/* fmr FR3, FR30 */
		/* 821B9114h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR30);
		/* 821B9114h case    0:*/		return 0x821B9118;
	}
	return 0x821B9118;
} // Block from 821B9114h-821B9118h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B9118h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9118( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9118) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9118);
		  /* 821B9118h */ case    0:  		/* cmplwi CR6, R28, 1 */
		/* 821B9118h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000001);
		/* 821B9118h case    0:*/		return 0x821B911C;
		  /* 821B911Ch */ case    1:  		/* bc 4, CR6_GT, 12 */
		/* 821B911Ch case    1:*/		if ( !regs.CR[6].gt ) { return 0x821B9128;  }
		/* 821B911Ch case    1:*/		return 0x821B9120;
		  /* 821B9120h */ case    2:  		/* fmr FR2, FR31 */
		/* 821B9120h case    2:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR31);
		/* 821B9120h case    2:*/		return 0x821B9124;
		  /* 821B9124h */ case    3:  		/* b 8 */
		/* 821B9124h case    3:*/		return 0x821B912C;
		/* 821B9124h case    3:*/		return 0x821B9128;
	}
	return 0x821B9128;
} // Block from 821B9118h-821B9128h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821B9128h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9128( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9128) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9128);
		  /* 821B9128h */ case    0:  		/* fmr FR2, FR30 */
		/* 821B9128h case    0:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR30);
		/* 821B9128h case    0:*/		return 0x821B912C;
	}
	return 0x821B912C;
} // Block from 821B9128h-821B912Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B912Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B912C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B912C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B912C);
		  /* 821B912Ch */ case    0:  		/* li R4, 4 */
		/* 821B912Ch case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x4);
		/* 821B912Ch case    0:*/		return 0x821B9130;
		  /* 821B9130h */ case    1:  		/* fmr FR1, FR31 */
		/* 821B9130h case    1:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 821B9130h case    1:*/		return 0x821B9134;
		  /* 821B9134h */ case    2:  		/* mr R3, R27 */
		/* 821B9134h case    2:*/		regs.R3 = regs.R27;
		/* 821B9134h case    2:*/		return 0x821B9138;
		  /* 821B9138h */ case    3:  		/* bl 465440 */
		/* 821B9138h case    3:*/		regs.LR = 0x821B913C; return 0x8222AB58;
		/* 821B9138h case    3:*/		return 0x821B913C;
		  /* 821B913Ch */ case    4:  		/* lwz R11, <#[R29]> */
		/* 821B913Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 821B913Ch case    4:*/		return 0x821B9140;
		  /* 821B9140h */ case    5:  		/* mr R31, R3 */
		/* 821B9140h case    5:*/		regs.R31 = regs.R3;
		/* 821B9140h case    5:*/		return 0x821B9144;
		  /* 821B9144h */ case    6:  		/* li R7, 0 */
		/* 821B9144h case    6:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821B9144h case    6:*/		return 0x821B9148;
		  /* 821B9148h */ case    7:  		/* rlwinm. R11, R11, 31, 31, 31 */
		/* 821B9148h case    7:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R11,regs.R11);
		/* 821B9148h case    7:*/		return 0x821B914C;
		  /* 821B914Ch */ case    8:  		/* bc 12, CR0_EQ, 44 */
		/* 821B914Ch case    8:*/		if ( regs.CR[0].eq ) { return 0x821B9178;  }
		/* 821B914Ch case    8:*/		return 0x821B9150;
		  /* 821B9150h */ case    9:  		/* lwz R11, <#[R20 + 8]> */
		/* 821B9150h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000008) );
		/* 821B9150h case    9:*/		return 0x821B9154;
		  /* 821B9154h */ case   10:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821B9154h case   10:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821B9154h case   10:*/		return 0x821B9158;
		  /* 821B9158h */ case   11:  		/* cmplwi CR6, R11, 125 */
		/* 821B9158h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 821B9158h case   11:*/		return 0x821B915C;
		  /* 821B915Ch */ case   12:  		/* bc 12, CR6_EQ, 16 */
		/* 821B915Ch case   12:*/		if ( regs.CR[6].eq ) { return 0x821B916C;  }
		/* 821B915Ch case   12:*/		return 0x821B9160;
		  /* 821B9160h */ case   13:  		/* cmplwi CR6, R11, 124 */
		/* 821B9160h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 821B9160h case   13:*/		return 0x821B9164;
		  /* 821B9164h */ case   14:  		/* li R11, 0 */
		/* 821B9164h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821B9164h case   14:*/		return 0x821B9168;
		  /* 821B9168h */ case   15:  		/* bc 4, CR6_EQ, 8 */
		/* 821B9168h case   15:*/		if ( !regs.CR[6].eq ) { return 0x821B9170;  }
		/* 821B9168h case   15:*/		return 0x821B916C;
	}
	return 0x821B916C;
} // Block from 821B912Ch-821B916Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 821B916Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B916C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B916C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B916C);
		  /* 821B916Ch */ case    0:  		/* li R11, 1 */
		/* 821B916Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821B916Ch case    0:*/		return 0x821B9170;
	}
	return 0x821B9170;
} // Block from 821B916Ch-821B9170h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B9170h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9170( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9170) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9170);
		  /* 821B9170h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821B9170h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821B9170h case    0:*/		return 0x821B9174;
		  /* 821B9174h */ case    1:  		/* bc 4, CR0_EQ, 56 */
		/* 821B9174h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821B91AC;  }
		/* 821B9174h case    1:*/		return 0x821B9178;
	}
	return 0x821B9178;
} // Block from 821B9170h-821B9178h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B9178h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9178( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9178) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9178);
		  /* 821B9178h */ case    0:  		/* lwz R11, <#[R22]> */
		/* 821B9178h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000000) );
		/* 821B9178h case    0:*/		return 0x821B917C;
		  /* 821B917Ch */ case    1:  		/* rlwinm. R11, R11, 31, 31, 31 */
		/* 821B917Ch case    1:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R11,regs.R11);
		/* 821B917Ch case    1:*/		return 0x821B9180;
		  /* 821B9180h */ case    2:  		/* bc 12, CR0_EQ, 48 */
		/* 821B9180h case    2:*/		if ( regs.CR[0].eq ) { return 0x821B91B0;  }
		/* 821B9180h case    2:*/		return 0x821B9184;
		  /* 821B9184h */ case    3:  		/* lwz R11, <#[R19 + 8]> */
		/* 821B9184h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000008) );
		/* 821B9184h case    3:*/		return 0x821B9188;
		  /* 821B9188h */ case    4:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821B9188h case    4:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821B9188h case    4:*/		return 0x821B918C;
		  /* 821B918Ch */ case    5:  		/* cmplwi CR6, R11, 125 */
		/* 821B918Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 821B918Ch case    5:*/		return 0x821B9190;
		  /* 821B9190h */ case    6:  		/* bc 12, CR6_EQ, 16 */
		/* 821B9190h case    6:*/		if ( regs.CR[6].eq ) { return 0x821B91A0;  }
		/* 821B9190h case    6:*/		return 0x821B9194;
		  /* 821B9194h */ case    7:  		/* cmplwi CR6, R11, 124 */
		/* 821B9194h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 821B9194h case    7:*/		return 0x821B9198;
		  /* 821B9198h */ case    8:  		/* li R11, 0 */
		/* 821B9198h case    8:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821B9198h case    8:*/		return 0x821B919C;
		  /* 821B919Ch */ case    9:  		/* bc 4, CR6_EQ, 8 */
		/* 821B919Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x821B91A4;  }
		/* 821B919Ch case    9:*/		return 0x821B91A0;
	}
	return 0x821B91A0;
} // Block from 821B9178h-821B91A0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821B91A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B91A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B91A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B91A0);
		  /* 821B91A0h */ case    0:  		/* li R11, 1 */
		/* 821B91A0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821B91A0h case    0:*/		return 0x821B91A4;
	}
	return 0x821B91A4;
} // Block from 821B91A0h-821B91A4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B91A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B91A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B91A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B91A4);
		  /* 821B91A4h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821B91A4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821B91A4h case    0:*/		return 0x821B91A8;
		  /* 821B91A8h */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 821B91A8h case    1:*/		if ( regs.CR[0].eq ) { return 0x821B91B0;  }
		/* 821B91A8h case    1:*/		return 0x821B91AC;
	}
	return 0x821B91AC;
} // Block from 821B91A4h-821B91ACh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B91ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B91AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B91AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B91AC);
		  /* 821B91ACh */ case    0:  		/* mr R7, R30 */
		/* 821B91ACh case    0:*/		regs.R7 = regs.R30;
		/* 821B91ACh case    0:*/		return 0x821B91B0;
	}
	return 0x821B91B0;
} // Block from 821B91ACh-821B91B0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B91B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B91B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B91B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B91B0);
		  /* 821B91B0h */ case    0:  		/* li R6, 228 */
		/* 821B91B0h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0xE4);
		/* 821B91B0h case    0:*/		return 0x821B91B4;
		  /* 821B91B4h */ case    1:  		/* mr R5, R23 */
		/* 821B91B4h case    1:*/		regs.R5 = regs.R23;
		/* 821B91B4h case    1:*/		return 0x821B91B8;
		  /* 821B91B8h */ case    2:  		/* mr R4, R31 */
		/* 821B91B8h case    2:*/		regs.R4 = regs.R31;
		/* 821B91B8h case    2:*/		return 0x821B91BC;
		  /* 821B91BCh */ case    3:  		/* mr R3, R27 */
		/* 821B91BCh case    3:*/		regs.R3 = regs.R27;
		/* 821B91BCh case    3:*/		return 0x821B91C0;
		  /* 821B91C0h */ case    4:  		/* bl -266496 */
		/* 821B91C0h case    4:*/		regs.LR = 0x821B91C4; return 0x821780C0;
		/* 821B91C0h case    4:*/		return 0x821B91C4;
		  /* 821B91C4h */ case    5:  		/* mr R6, R3 */
		/* 821B91C4h case    5:*/		regs.R6 = regs.R3;
		/* 821B91C4h case    5:*/		return 0x821B91C8;
		  /* 821B91C8h */ case    6:  		/* mr R8, R22 */
		/* 821B91C8h case    6:*/		regs.R8 = regs.R22;
		/* 821B91C8h case    6:*/		return 0x821B91CC;
		  /* 821B91CCh */ case    7:  		/* mr R7, R29 */
		/* 821B91CCh case    7:*/		regs.R7 = regs.R29;
		/* 821B91CCh case    7:*/		return 0x821B91D0;
		  /* 821B91D0h */ case    8:  		/* li R5, 0 */
		/* 821B91D0h case    8:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821B91D0h case    8:*/		return 0x821B91D4;
		  /* 821B91D4h */ case    9:  		/* mr R4, R15 */
		/* 821B91D4h case    9:*/		regs.R4 = regs.R15;
		/* 821B91D4h case    9:*/		return 0x821B91D8;
		  /* 821B91D8h */ case   10:  		/* mr R3, R27 */
		/* 821B91D8h case   10:*/		regs.R3 = regs.R27;
		/* 821B91D8h case   10:*/		return 0x821B91DC;
		  /* 821B91DCh */ case   11:  		/* bl -258740 */
		/* 821B91DCh case   11:*/		regs.LR = 0x821B91E0; return 0x82179F28;
		/* 821B91DCh case   11:*/		return 0x821B91E0;
		  /* 821B91E0h */ case   12:  		/* mr R29, R3 */
		/* 821B91E0h case   12:*/		regs.R29 = regs.R3;
		/* 821B91E0h case   12:*/		return 0x821B91E4;
		  /* 821B91E4h */ case   13:  		/* mr R3, R31 */
		/* 821B91E4h case   13:*/		regs.R3 = regs.R31;
		/* 821B91E4h case   13:*/		return 0x821B91E8;
		  /* 821B91E8h */ case   14:  		/* bl -142904 */
		/* 821B91E8h case   14:*/		regs.LR = 0x821B91EC; return 0x821963B0;
		/* 821B91E8h case   14:*/		return 0x821B91EC;
		  /* 821B91ECh */ case   15:  		/* lwz R11, <#[R31 + 8]> */
		/* 821B91ECh case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821B91ECh case   15:*/		return 0x821B91F0;
		  /* 821B91F0h */ case   16:  		/* li R8, 0 */
		/* 821B91F0h case   16:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821B91F0h case   16:*/		return 0x821B91F4;
		  /* 821B91F4h */ case   17:  		/* oris R11, R11, 256 */
		/* 821B91F4h case   17:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x100);
		/* 821B91F4h case   17:*/		return 0x821B91F8;
		  /* 821B91F8h */ case   18:  		/* mr R7, R29 */
		/* 821B91F8h case   18:*/		regs.R7 = regs.R29;
		/* 821B91F8h case   18:*/		return 0x821B91FC;
		  /* 821B91FCh */ case   19:  		/* stw R11, <#[R31 + 8]> */
		/* 821B91FCh case   19:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821B91FCh case   19:*/		return 0x821B9200;
		  /* 821B9200h */ case   20:  		/* mr R6, R25 */
		/* 821B9200h case   20:*/		regs.R6 = regs.R25;
		/* 821B9200h case   20:*/		return 0x821B9204;
		  /* 821B9204h */ case   21:  		/* mr R5, R14 */
		/* 821B9204h case   21:*/		regs.R5 = regs.R14;
		/* 821B9204h case   21:*/		return 0x821B9208;
		  /* 821B9208h */ case   22:  		/* mr R4, R26 */
		/* 821B9208h case   22:*/		regs.R4 = regs.R26;
		/* 821B9208h case   22:*/		return 0x821B920C;
		  /* 821B920Ch */ case   23:  		/* mr R3, R27 */
		/* 821B920Ch case   23:*/		regs.R3 = regs.R27;
		/* 821B920Ch case   23:*/		return 0x821B9210;
		  /* 821B9210h */ case   24:  		/* bl -7336 */
		/* 821B9210h case   24:*/		regs.LR = 0x821B9214; return 0x821B7568;
		/* 821B9210h case   24:*/		return 0x821B9214;
		  /* 821B9214h */ case   25:  		/* mr R8, R28 */
		/* 821B9214h case   25:*/		regs.R8 = regs.R28;
		/* 821B9214h case   25:*/		return 0x821B9218;
		  /* 821B9218h */ case   26:  		/* mr R7, R29 */
		/* 821B9218h case   26:*/		regs.R7 = regs.R29;
		/* 821B9218h case   26:*/		return 0x821B921C;
		  /* 821B921Ch */ case   27:  		/* mr R6, R24 */
		/* 821B921Ch case   27:*/		regs.R6 = regs.R24;
		/* 821B921Ch case   27:*/		return 0x821B9220;
		  /* 821B9220h */ case   28:  		/* mr R5, R14 */
		/* 821B9220h case   28:*/		regs.R5 = regs.R14;
		/* 821B9220h case   28:*/		return 0x821B9224;
		  /* 821B9224h */ case   29:  		/* mr R4, R26 */
		/* 821B9224h case   29:*/		regs.R4 = regs.R26;
		/* 821B9224h case   29:*/		return 0x821B9228;
		  /* 821B9228h */ case   30:  		/* mr R3, R27 */
		/* 821B9228h case   30:*/		regs.R3 = regs.R27;
		/* 821B9228h case   30:*/		return 0x821B922C;
		  /* 821B922Ch */ case   31:  		/* bl -7364 */
		/* 821B922Ch case   31:*/		regs.LR = 0x821B9230; return 0x821B7568;
		/* 821B922Ch case   31:*/		return 0x821B9230;
		  /* 821B9230h */ case   32:  		/* rlwinm R11, R26, 0, 0, 30 */
		/* 821B9230h case   32:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R26);
		/* 821B9230h case   32:*/		return 0x821B9234;
		  /* 821B9234h */ case   33:  		/* rlwinm R10, R29, 0, 0, 30 */
		/* 821B9234h case   33:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R29);
		/* 821B9234h case   33:*/		return 0x821B9238;
		  /* 821B9238h */ case   34:  		/* addi R11, R11, 36 */
		/* 821B9238h case   34:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821B9238h case   34:*/		return 0x821B923C;
		  /* 821B923Ch */ case   35:  		/* addi R10, R10, 36 */
		/* 821B923Ch case   35:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 821B923Ch case   35:*/		return 0x821B9240;
		  /* 821B9240h */ case   36:  		/* addi R8, R11, -36 */
		/* 821B9240h case   36:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821B9240h case   36:*/		return 0x821B9244;
		  /* 821B9244h */ case   37:  		/* addi R7, R10, -36 */
		/* 821B9244h case   37:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0xFFFFFFDC);
		/* 821B9244h case   37:*/		return 0x821B9248;
		  /* 821B9248h */ case   38:  		/* addi R9, R10, 4 */
		/* 821B9248h case   38:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 821B9248h case   38:*/		return 0x821B924C;
		  /* 821B924Ch */ case   39:  		/* lwz R6, <#[R11]> */
		/* 821B924Ch case   39:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 821B924Ch case   39:*/		return 0x821B9250;
		  /* 821B9250h */ case   40:  		/* mr R3, R29 */
		/* 821B9250h case   40:*/		regs.R3 = regs.R29;
		/* 821B9250h case   40:*/		return 0x821B9254;
		  /* 821B9254h */ case   41:  		/* stw R6, <#[R10]> */
		/* 821B9254h case   41:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + 0x00000000) );
		/* 821B9254h case   41:*/		return 0x821B9258;
		  /* 821B9258h */ case   42:  		/* lwz R6, <#[R11]> */
		/* 821B9258h case   42:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 821B9258h case   42:*/		return 0x821B925C;
		  /* 821B925Ch */ case   43:  		/* rlwinm R6, R6, 0, 0, 30 */
		/* 821B925Ch case   43:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R6);
		/* 821B925Ch case   43:*/		return 0x821B9260;
		  /* 821B9260h */ case   44:  		/* stw R7, <#[R6]> */
		/* 821B9260h case   44:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R6 + 0x00000000) );
		/* 821B9260h case   44:*/		return 0x821B9264;
		  /* 821B9264h */ case   45:  		/* stw R8, <#[R10 + 4]> */
		/* 821B9264h case   45:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 821B9264h case   45:*/		return 0x821B9268;
		  /* 821B9268h */ case   46:  		/* stw R9, <#[R11]> */
		/* 821B9268h case   46:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821B9268h case   46:*/		return 0x821B926C;
		  /* 821B926Ch */ case   47:  		/* bl -265972 */
		/* 821B926Ch case   47:*/		regs.LR = 0x821B9270; return 0x82178378;
		/* 821B926Ch case   47:*/		return 0x821B9270;
		  /* 821B9270h */ case   48:  		/* mr R3, R29 */
		/* 821B9270h case   48:*/		regs.R3 = regs.R29;
		/* 821B9270h case   48:*/		return 0x821B9274;
		  /* 821B9274h */ case   49:  		/* bl -169964 */
		/* 821B9274h case   49:*/		regs.LR = 0x821B9278; return 0x8218FA88;
		/* 821B9274h case   49:*/		return 0x821B9278;
		  /* 821B9278h */ case   50:  		/* or R11, R24, R25 */
		/* 821B9278h case   50:*/		cpu::op::or<0>(regs,&regs.R11,regs.R24,regs.R25);
		/* 821B9278h case   50:*/		return 0x821B927C;
		  /* 821B927Ch */ case   51:  		/* addi R17, R17, -2 */
		/* 821B927Ch case   51:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R17,0xFFFFFFFE);
		/* 821B927Ch case   51:*/		return 0x821B9280;
		  /* 821B9280h */ case   52:  		/* or R21, R11, R21 */
		/* 821B9280h case   52:*/		cpu::op::or<0>(regs,&regs.R21,regs.R11,regs.R21);
		/* 821B9280h case   52:*/		return 0x821B9284;
		  /* 821B9284h */ case   53:  		/* rlwinm R16, R16, 24, 8, 31 */
		/* 821B9284h case   53:*/		cpu::op::rlwinm<0,24,8,31>(regs,&regs.R16,regs.R16);
		/* 821B9284h case   53:*/		return 0x821B9288;
		  /* 821B9288h */ case   54:  		/* addi R18, R18, 1 */
		/* 821B9288h case   54:*/		cpu::op::addi<0>(regs,&regs.R18,regs.R18,0x1);
		/* 821B9288h case   54:*/		return 0x821B928C;
		  /* 821B928Ch */ case   55:  		/* cmplwi CR6, R17, 2 */
		/* 821B928Ch case   55:*/		cpu::op::cmplwi<6>(regs,regs.R17,0x00000002);
		/* 821B928Ch case   55:*/		return 0x821B9290;
		  /* 821B9290h */ case   56:  		/* lwz R11, <#[R29 + 8]> */
		/* 821B9290h case   56:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 821B9290h case   56:*/		return 0x821B9294;
		  /* 821B9294h */ case   57:  		/* oris R11, R11, 256 */
		/* 821B9294h case   57:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x100);
		/* 821B9294h case   57:*/		return 0x821B9298;
		  /* 821B9298h */ case   58:  		/* stw R11, <#[R29 + 8]> */
		/* 821B9298h case   58:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 821B9298h case   58:*/		return 0x821B929C;
		  /* 821B929Ch */ case   59:  		/* bc 4, CR6_LT, -796 */
		/* 821B929Ch case   59:*/		if ( !regs.CR[6].lt ) { return 0x821B8F80;  }
		/* 821B929Ch case   59:*/		return 0x821B92A0;
		  /* 821B92A0h */ case   60:  		/* b 32 */
		/* 821B92A0h case   60:*/		return 0x821B92C0;
		/* 821B92A0h case   60:*/		return 0x821B92A4;
	}
	return 0x821B92A4;
} // Block from 821B91B0h-821B92A4h (61 instructions)

//////////////////////////////////////////////////////
// Block at 821B92A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B92A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B92A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B92A4);
		  /* 821B92A4h */ case    0:  		/* cmpw CR6, R3, R9 */
		/* 821B92A4h case    0:*/		cpu::op::cmpw<6>(regs,regs.R3,regs.R9);
		/* 821B92A4h case    0:*/		return 0x821B92A8;
		  /* 821B92A8h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 821B92A8h case    1:*/		if ( regs.CR[6].eq ) { return 0x821B92B4;  }
		/* 821B92A8h case    1:*/		return 0x821B92AC;
		  /* 821B92ACh */ case    2:  		/* mr R4, R27 */
		/* 821B92ACh case    2:*/		regs.R4 = regs.R27;
		/* 821B92ACh case    2:*/		return 0x821B92B0;
		  /* 821B92B0h */ case    3:  		/* bl -141064 */
		/* 821B92B0h case    3:*/		regs.LR = 0x821B92B4; return 0x82196BA8;
		/* 821B92B0h case    3:*/		return 0x821B92B4;
	}
	return 0x821B92B4;
} // Block from 821B92A4h-821B92B4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821B92B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B92B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B92B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B92B4);
		  /* 821B92B4h */ case    0:  		/* mr R4, R27 */
		/* 821B92B4h case    0:*/		regs.R4 = regs.R27;
		/* 821B92B4h case    0:*/		return 0x821B92B8;
		  /* 821B92B8h */ case    1:  		/* lwz R3, <#[R22 + 12]> */
		/* 821B92B8h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R22 + 0x0000000C) );
		/* 821B92B8h case    1:*/		return 0x821B92BC;
		  /* 821B92BCh */ case    2:  		/* bl -141076 */
		/* 821B92BCh case    2:*/		regs.LR = 0x821B92C0; return 0x82196BA8;
		/* 821B92BCh case    2:*/		return 0x821B92C0;
	}
	return 0x821B92C0;
} // Block from 821B92B4h-821B92C0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821B92C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B92C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B92C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B92C0);
		  /* 821B92C0h */ case    0:  		/* cmplwi CR6, R17, 0 */
		/* 821B92C0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R17,0x00000000);
		/* 821B92C0h case    0:*/		return 0x821B92C4;
		  /* 821B92C4h */ case    1:  		/* bc 12, CR6_EQ, 192 */
		/* 821B92C4h case    1:*/		if ( regs.CR[6].eq ) { return 0x821B9384;  }
		/* 821B92C4h case    1:*/		return 0x821B92C8;
		  /* 821B92C8h */ case    2:  		/* rlwinm R11, R26, 0, 0, 30 */
		/* 821B92C8h case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R26);
		/* 821B92C8h case    2:*/		return 0x821B92CC;
		  /* 821B92CCh */ case    3:  		/* add R18, R18, R17 */
		/* 821B92CCh case    3:*/		cpu::op::add<0>(regs,&regs.R18,regs.R18,regs.R17);
		/* 821B92CCh case    3:*/		return 0x821B92D0;
		  /* 821B92D0h */ case    4:  		/* addi R31, R11, 36 */
		/* 821B92D0h case    4:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x24);
		/* 821B92D0h case    4:*/		return 0x821B92D4;
		  /* 821B92D4h */ case    5:  		/* addi R29, R31, -36 */
		/* 821B92D4h case    5:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R31,0xFFFFFFDC);
		/* 821B92D4h case    5:*/		return 0x821B92D8;
		  /* 821B92D8h */ case    6:  		/* rlwinm R30, R16, 0, 28, 31 */
		/* 821B92D8h case    6:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R30,regs.R16);
		/* 821B92D8h case    6:*/		return 0x821B92DC;
		  /* 821B92DCh */ case    7:  		/* li R7, 0 */
		/* 821B92DCh case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821B92DCh case    7:*/		return 0x821B92E0;
		  /* 821B92E0h */ case    8:  		/* mr R6, R30 */
		/* 821B92E0h case    8:*/		regs.R6 = regs.R30;
		/* 821B92E0h case    8:*/		return 0x821B92E4;
		  /* 821B92E4h */ case    9:  		/* mr R5, R14 */
		/* 821B92E4h case    9:*/		regs.R5 = regs.R14;
		/* 821B92E4h case    9:*/		return 0x821B92E8;
		  /* 821B92E8h */ case   10:  		/* mr R4, R26 */
		/* 821B92E8h case   10:*/		regs.R4 = regs.R26;
		/* 821B92E8h case   10:*/		return 0x821B92EC;
		  /* 821B92ECh */ case   11:  		/* mr R3, R27 */
		/* 821B92ECh case   11:*/		regs.R3 = regs.R27;
		/* 821B92ECh case   11:*/		return 0x821B92F0;
		  /* 821B92F0h */ case   12:  		/* bl -11552 */
		/* 821B92F0h case   12:*/		regs.LR = 0x821B92F4; return 0x821B65D0;
		/* 821B92F0h case   12:*/		return 0x821B92F4;
		  /* 821B92F4h */ case   13:  		/* mr R7, R3 */
		/* 821B92F4h case   13:*/		regs.R7 = regs.R3;
		/* 821B92F4h case   13:*/		return 0x821B92F8;
		  /* 821B92F8h */ case   14:  		/* mr R6, R3 */
		/* 821B92F8h case   14:*/		regs.R6 = regs.R3;
		/* 821B92F8h case   14:*/		return 0x821B92FC;
		  /* 821B92FCh */ case   15:  		/* li R5, 0 */
		/* 821B92FCh case   15:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821B92FCh case   15:*/		return 0x821B9300;
		  /* 821B9300h */ case   16:  		/* mr R4, R15 */
		/* 821B9300h case   16:*/		regs.R4 = regs.R15;
		/* 821B9300h case   16:*/		return 0x821B9304;
		  /* 821B9304h */ case   17:  		/* mr R3, R27 */
		/* 821B9304h case   17:*/		regs.R3 = regs.R27;
		/* 821B9304h case   17:*/		return 0x821B9308;
		  /* 821B9308h */ case   18:  		/* bl -259280 */
		/* 821B9308h case   18:*/		regs.LR = 0x821B930C; return 0x82179E38;
		/* 821B9308h case   18:*/		return 0x821B930C;
		  /* 821B930Ch */ case   19:  		/* mr R28, R3 */
		/* 821B930Ch case   19:*/		regs.R28 = regs.R3;
		/* 821B930Ch case   19:*/		return 0x821B9310;
		  /* 821B9310h */ case   20:  		/* mr R7, R3 */
		/* 821B9310h case   20:*/		regs.R7 = regs.R3;
		/* 821B9310h case   20:*/		return 0x821B9314;
		  /* 821B9314h */ case   21:  		/* li R8, 0 */
		/* 821B9314h case   21:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821B9314h case   21:*/		return 0x821B9318;
		  /* 821B9318h */ case   22:  		/* mr R6, R30 */
		/* 821B9318h case   22:*/		regs.R6 = regs.R30;
		/* 821B9318h case   22:*/		return 0x821B931C;
		  /* 821B931Ch */ case   23:  		/* mr R5, R14 */
		/* 821B931Ch case   23:*/		regs.R5 = regs.R14;
		/* 821B931Ch case   23:*/		return 0x821B9320;
		  /* 821B9320h */ case   24:  		/* mr R4, R26 */
		/* 821B9320h case   24:*/		regs.R4 = regs.R26;
		/* 821B9320h case   24:*/		return 0x821B9324;
		  /* 821B9324h */ case   25:  		/* mr R3, R27 */
		/* 821B9324h case   25:*/		regs.R3 = regs.R27;
		/* 821B9324h case   25:*/		return 0x821B9328;
		  /* 821B9328h */ case   26:  		/* bl -7616 */
		/* 821B9328h case   26:*/		regs.LR = 0x821B932C; return 0x821B7568;
		/* 821B9328h case   26:*/		return 0x821B932C;
		  /* 821B932Ch */ case   27:  		/* rlwinm R11, R28, 0, 0, 30 */
		/* 821B932Ch case   27:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R28);
		/* 821B932Ch case   27:*/		return 0x821B9330;
		  /* 821B9330h */ case   28:  		/* lwz R8, <#[R31]> */
		/* 821B9330h case   28:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 821B9330h case   28:*/		return 0x821B9334;
		  /* 821B9334h */ case   29:  		/* mr R3, R28 */
		/* 821B9334h case   29:*/		regs.R3 = regs.R28;
		/* 821B9334h case   29:*/		return 0x821B9338;
		  /* 821B9338h */ case   30:  		/* addi R11, R11, 36 */
		/* 821B9338h case   30:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821B9338h case   30:*/		return 0x821B933C;
		  /* 821B933Ch */ case   31:  		/* addi R9, R11, -36 */
		/* 821B933Ch case   31:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0xFFFFFFDC);
		/* 821B933Ch case   31:*/		return 0x821B9340;
		  /* 821B9340h */ case   32:  		/* addi R10, R11, 4 */
		/* 821B9340h case   32:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 821B9340h case   32:*/		return 0x821B9344;
		  /* 821B9344h */ case   33:  		/* stw R8, <#[R11]> */
		/* 821B9344h case   33:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 821B9344h case   33:*/		return 0x821B9348;
		  /* 821B9348h */ case   34:  		/* lwz R8, <#[R31]> */
		/* 821B9348h case   34:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 821B9348h case   34:*/		return 0x821B934C;
		  /* 821B934Ch */ case   35:  		/* rlwinm R8, R8, 0, 0, 30 */
		/* 821B934Ch case   35:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R8,regs.R8);
		/* 821B934Ch case   35:*/		return 0x821B9350;
		  /* 821B9350h */ case   36:  		/* stw R9, <#[R8]> */
		/* 821B9350h case   36:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R8 + 0x00000000) );
		/* 821B9350h case   36:*/		return 0x821B9354;
		  /* 821B9354h */ case   37:  		/* stw R29, <#[R11 + 4]> */
		/* 821B9354h case   37:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R11 + 0x00000004) );
		/* 821B9354h case   37:*/		return 0x821B9358;
		  /* 821B9358h */ case   38:  		/* stw R10, <#[R31]> */
		/* 821B9358h case   38:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 821B9358h case   38:*/		return 0x821B935C;
		  /* 821B935Ch */ case   39:  		/* bl -266212 */
		/* 821B935Ch case   39:*/		regs.LR = 0x821B9360; return 0x82178378;
		/* 821B935Ch case   39:*/		return 0x821B9360;
		  /* 821B9360h */ case   40:  		/* mr R3, R28 */
		/* 821B9360h case   40:*/		regs.R3 = regs.R28;
		/* 821B9360h case   40:*/		return 0x821B9364;
		  /* 821B9364h */ case   41:  		/* bl -170204 */
		/* 821B9364h case   41:*/		regs.LR = 0x821B9368; return 0x8218FA88;
		/* 821B9364h case   41:*/		return 0x821B9368;
		  /* 821B9368h */ case   42:  		/* lwz R11, <#[R28 + 8]> */
		/* 821B9368h case   42:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 821B9368h case   42:*/		return 0x821B936C;
		  /* 821B936Ch */ case   43:  		/* addic. R17, R17, -1 */
		/* 821B936Ch case   43:*/		cpu::op::addic<1>(regs,&regs.R17,regs.R17,0xFFFFFFFF);
		/* 821B936Ch case   43:*/		return 0x821B9370;
		  /* 821B9370h */ case   44:  		/* oris R11, R11, 256 */
		/* 821B9370h case   44:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x100);
		/* 821B9370h case   44:*/		return 0x821B9374;
		  /* 821B9374h */ case   45:  		/* or R21, R30, R21 */
		/* 821B9374h case   45:*/		cpu::op::or<0>(regs,&regs.R21,regs.R30,regs.R21);
		/* 821B9374h case   45:*/		return 0x821B9378;
		  /* 821B9378h */ case   46:  		/* rlwinm R16, R16, 28, 4, 31 */
		/* 821B9378h case   46:*/		cpu::op::rlwinm<0,28,4,31>(regs,&regs.R16,regs.R16);
		/* 821B9378h case   46:*/		return 0x821B937C;
		  /* 821B937Ch */ case   47:  		/* stw R11, <#[R28 + 8]> */
		/* 821B937Ch case   47:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 821B937Ch case   47:*/		return 0x821B9380;
		  /* 821B9380h */ case   48:  		/* bc 4, CR0_EQ, -168 */
		/* 821B9380h case   48:*/		if ( !regs.CR[0].eq ) { return 0x821B92D8;  }
		/* 821B9380h case   48:*/		return 0x821B9384;
	}
	return 0x821B9384;
} // Block from 821B92C0h-821B9384h (49 instructions)

//////////////////////////////////////////////////////
// Block at 821B9384h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9384( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9384) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9384);
		  /* 821B9384h */ case    0:  		/* li R11, 1 */
		/* 821B9384h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821B9384h case    0:*/		return 0x821B9388;
		  /* 821B9388h */ case    1:  		/* slw R11, R11, R14 */
		/* 821B9388h case    1:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R14);
		/* 821B9388h case    1:*/		return 0x821B938C;
		  /* 821B938Ch */ case    2:  		/* addi R11, R11, -1 */
		/* 821B938Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 821B938Ch case    2:*/		return 0x821B9390;
		  /* 821B9390h */ case    3:  		/* cmplw CR6, R21, R11 */
		/* 821B9390h case    3:*/		cpu::op::cmplw<6>(regs,regs.R21,regs.R11);
		/* 821B9390h case    3:*/		return 0x821B9394;
		  /* 821B9394h */ case    4:  		/* bc 4, CR6_EQ, 200 */
		/* 821B9394h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821B945C;  }
		/* 821B9394h case    4:*/		return 0x821B9398;
		  /* 821B9398h */ case    5:  		/* cmplwi CR6, R18, 1 */
		/* 821B9398h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R18,0x00000001);
		/* 821B9398h case    5:*/		return 0x821B939C;
		  /* 821B939Ch */ case    6:  		/* bc 4, CR6_EQ, 192 */
		/* 821B939Ch case    6:*/		if ( !regs.CR[6].eq ) { return 0x821B945C;  }
		/* 821B939Ch case    6:*/		return 0x821B93A0;
		  /* 821B93A0h */ case    7:  		/* li R29, 0 */
		/* 821B93A0h case    7:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 821B93A0h case    7:*/		return 0x821B93A4;
		  /* 821B93A4h */ case    8:  		/* li R30, 0 */
		/* 821B93A4h case    8:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 821B93A4h case    8:*/		return 0x821B93A8;
		  /* 821B93A8h */ case    9:  		/* cmplwi CR6, R14, 0 */
		/* 821B93A8h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R14,0x00000000);
		/* 821B93A8h case    9:*/		return 0x821B93AC;
		  /* 821B93ACh */ case   10:  		/* bc 12, CR6_EQ, 60 */
		/* 821B93ACh case   10:*/		if ( regs.CR[6].eq ) { return 0x821B93E8;  }
		/* 821B93ACh case   10:*/		return 0x821B93B0;
		  /* 821B93B0h */ case   11:  		/* li R11, 0 */
		/* 821B93B0h case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821B93B0h case   11:*/		return 0x821B93B4;
		  /* 821B93B4h */ case   12:  		/* mtspr CTR, R14 */
		/* 821B93B4h case   12:*/		regs.CTR = regs.R14;
		/* 821B93B4h case   12:*/		return 0x821B93B8;
		  /* 821B93B8h */ case   13:  		/* addi R9, R26, 40 */
		/* 821B93B8h case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R26,0x28);
		/* 821B93B8h case   13:*/		return 0x821B93BC;
		  /* 821B93BCh */ case   14:  		/* lwzu R10, <#[R9 + 4]> */
		/* 821B93BCh case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000004) );
		regs.R9 = (uint32)(regs.R9 + 0x00000004);
		/* 821B93BCh case   14:*/		return 0x821B93C0;
		  /* 821B93C0h */ case   15:  		/* li R8, 3 */
		/* 821B93C0h case   15:*/		cpu::op::li<0>(regs,&regs.R8,0x3);
		/* 821B93C0h case   15:*/		return 0x821B93C4;
		  /* 821B93C4h */ case   16:  		/* slw R8, R8, R11 */
		/* 821B93C4h case   16:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R8,regs.R11);
		/* 821B93C4h case   16:*/		return 0x821B93C8;
		  /* 821B93C8h */ case   17:  		/* lwz R7, <#[R10]> */
		/* 821B93C8h case   17:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821B93C8h case   17:*/		return 0x821B93CC;
		  /* 821B93CCh */ case   18:  		/* andc R8, R29, R8 */
		/* 821B93CCh case   18:*/		cpu::op::andc<0>(regs,&regs.R8,regs.R29,regs.R8);
		/* 821B93CCh case   18:*/		return 0x821B93D0;
		  /* 821B93D0h */ case   19:  		/* lwz R30, <#[R10 + 12]> */
		/* 821B93D0h case   19:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R10 + 0x0000000C) );
		/* 821B93D0h case   19:*/		return 0x821B93D4;
		  /* 821B93D4h */ case   20:  		/* rlwinm R10, R7, 27, 30, 31 */
		/* 821B93D4h case   20:*/		cpu::op::rlwinm<0,27,30,31>(regs,&regs.R10,regs.R7);
		/* 821B93D4h case   20:*/		return 0x821B93D8;
		  /* 821B93D8h */ case   21:  		/* slw R10, R10, R11 */
		/* 821B93D8h case   21:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 821B93D8h case   21:*/		return 0x821B93DC;
		  /* 821B93DCh */ case   22:  		/* or R29, R8, R10 */
		/* 821B93DCh case   22:*/		cpu::op::or<0>(regs,&regs.R29,regs.R8,regs.R10);
		/* 821B93DCh case   22:*/		return 0x821B93E0;
		  /* 821B93E0h */ case   23:  		/* addi R11, R11, 2 */
		/* 821B93E0h case   23:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 821B93E0h case   23:*/		return 0x821B93E4;
		  /* 821B93E4h */ case   24:  		/* bc 16, CR0_LT, -40 */
		/* 821B93E4h case   24:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x821B93BC;  }
		/* 821B93E4h case   24:*/		return 0x821B93E8;
	}
	return 0x821B93E8;
} // Block from 821B9384h-821B93E8h (25 instructions)

//////////////////////////////////////////////////////
// Block at 821B93E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B93E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B93E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B93E8);
		  /* 821B93E8h */ case    0:  		/* addi R28, R26, 4 */
		/* 821B93E8h case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R26,0x4);
		/* 821B93E8h case    0:*/		return 0x821B93EC;
		  /* 821B93ECh */ case    1:  		/* lwz R31, <#[R28]> */
		/* 821B93ECh case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R28 + 0x00000000) );
		/* 821B93ECh case    1:*/		return 0x821B93F0;
		  /* 821B93F0h */ case    2:  		/* cmplwi CR6, R31, 0 */
		/* 821B93F0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821B93F0h case    2:*/		return 0x821B93F4;
		  /* 821B93F4h */ case    3:  		/* bc 12, CR6_EQ, 1164 */
		/* 821B93F4h case    3:*/		if ( regs.CR[6].eq ) { return 0x821B9880;  }
		/* 821B93F4h case    3:*/		return 0x821B93F8;
		  /* 821B93F8h */ case    4:  		/* lwz R11, <#[R31 + 16]> */
		/* 821B93F8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 821B93F8h case    4:*/		return 0x821B93FC;
		  /* 821B93FCh */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821B93FCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821B93FCh case    5:*/		return 0x821B9400;
		  /* 821B9400h */ case    6:  		/* bc 12, CR6_EQ, 72 */
		/* 821B9400h case    6:*/		if ( regs.CR[6].eq ) { return 0x821B9448;  }
		/* 821B9400h case    6:*/		return 0x821B9404;
		  /* 821B9404h */ case    7:  		/* lwz R11, <#[R31 + 12]> */
		/* 821B9404h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 821B9404h case    7:*/		return 0x821B9408;
		  /* 821B9408h */ case    8:  		/* addi R11, R11, 4 */
		/* 821B9408h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821B9408h case    8:*/		return 0x821B940C;
		  /* 821B940Ch */ case    9:  		/* lwz R10, <#[R11]> */
		/* 821B940Ch case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821B940Ch case    9:*/		return 0x821B9410;
		  /* 821B9410h */ case   10:  		/* b 12 */
		/* 821B9410h case   10:*/		return 0x821B941C;
		/* 821B9410h case   10:*/		return 0x821B9414;
		  /* 821B9414h */ case   11:  		/* addi R11, R10, 8 */
		/* 821B9414h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 821B9414h case   11:*/		return 0x821B9418;
		  /* 821B9418h */ case   12:  		/* lwz R10, <#[R10 + 8]> */
		/* 821B9418h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 821B9418h case   12:*/		return 0x821B941C;
	}
	return 0x821B941C;
} // Block from 821B93E8h-821B941Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 821B941Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B941C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B941C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B941C);
		  /* 821B941Ch */ case    0:  		/* cmplw CR6, R10, R31 */
		/* 821B941Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 821B941Ch case    0:*/		return 0x821B9420;
		  /* 821B9420h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 821B9420h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821B9414;  }
		/* 821B9420h case    1:*/		return 0x821B9424;
		  /* 821B9424h */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 821B9424h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 821B9424h case    2:*/		return 0x821B9428;
		  /* 821B9428h */ case    3:  		/* mr R4, R29 */
		/* 821B9428h case    3:*/		regs.R4 = regs.R29;
		/* 821B9428h case    3:*/		return 0x821B942C;
		  /* 821B942Ch */ case    4:  		/* mr R3, R31 */
		/* 821B942Ch case    4:*/		regs.R3 = regs.R31;
		/* 821B942Ch case    4:*/		return 0x821B9430;
		  /* 821B9430h */ case    5:  		/* stw R10, <#[R11]> */
		/* 821B9430h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821B9430h case    5:*/		return 0x821B9434;
		  /* 821B9434h */ case    6:  		/* lwz R11, <#[R30 + 4]> */
		/* 821B9434h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 821B9434h case    6:*/		return 0x821B9438;
		  /* 821B9438h */ case    7:  		/* stw R11, <#[R31 + 8]> */
		/* 821B9438h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821B9438h case    7:*/		return 0x821B943C;
		  /* 821B943Ch */ case    8:  		/* stw R31, <#[R30 + 4]> */
		/* 821B943Ch case    8:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000004) );
		/* 821B943Ch case    8:*/		return 0x821B9440;
		  /* 821B9440h */ case    9:  		/* stw R30, <#[R31 + 12]> */
		/* 821B9440h case    9:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000000C) );
		/* 821B9440h case    9:*/		return 0x821B9444;
		  /* 821B9444h */ case   10:  		/* bl -296668 */
		/* 821B9444h case   10:*/		regs.LR = 0x821B9448; return 0x82170D68;
		/* 821B9444h case   10:*/		return 0x821B9448;
	}
	return 0x821B9448;
} // Block from 821B941Ch-821B9448h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821B9448h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9448( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9448) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9448);
		  /* 821B9448h */ case    0:  		/* lwz R11, <#[R28]> */
		/* 821B9448h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 821B9448h case    0:*/		return 0x821B944C;
		  /* 821B944Ch */ case    1:  		/* cmplw CR6, R11, R31 */
		/* 821B944Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 821B944Ch case    1:*/		return 0x821B9450;
		  /* 821B9450h */ case    2:  		/* bc 4, CR6_EQ, -100 */
		/* 821B9450h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821B93EC;  }
		/* 821B9450h case    2:*/		return 0x821B9454;
		  /* 821B9454h */ case    3:  		/* addi R28, R31, 8 */
		/* 821B9454h case    3:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R31,0x8);
		/* 821B9454h case    3:*/		return 0x821B9458;
		  /* 821B9458h */ case    4:  		/* b -108 */
		/* 821B9458h case    4:*/		return 0x821B93EC;
		/* 821B9458h case    4:*/		return 0x821B945C;
	}
	return 0x821B945C;
} // Block from 821B9448h-821B945Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 821B945Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B945C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B945C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B945C);
		  /* 821B945Ch */ case    0:  		/* mr R4, R26 */
		/* 821B945Ch case    0:*/		regs.R4 = regs.R26;
		/* 821B945Ch case    0:*/		return 0x821B9460;
		  /* 821B9460h */ case    1:  		/* mr R3, R27 */
		/* 821B9460h case    1:*/		regs.R3 = regs.R27;
		/* 821B9460h case    1:*/		return 0x821B9464;
		  /* 821B9464h */ case    2:  		/* bl -12412 */
		/* 821B9464h case    2:*/		regs.LR = 0x821B9468; return 0x821B63E8;
		/* 821B9464h case    2:*/		return 0x821B9468;
		  /* 821B9468h */ case    3:  		/* addi R21, R26, 44 */
		/* 821B9468h case    3:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R26,0x2C);
		/* 821B9468h case    3:*/		return 0x821B946C;
		  /* 821B946Ch */ case    4:  		/* li R18, 0 */
		/* 821B946Ch case    4:*/		cpu::op::li<0>(regs,&regs.R18,0x0);
		/* 821B946Ch case    4:*/		return 0x821B9470;
		  /* 821B9470h */ case    5:  		/* mr R17, R21 */
		/* 821B9470h case    5:*/		regs.R17 = regs.R21;
		/* 821B9470h case    5:*/		return 0x821B9474;
		  /* 821B9474h */ case    6:  		/* lwz R11, <#[R26 + 8]> */
		/* 821B9474h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 821B9474h case    6:*/		return 0x821B9478;
		  /* 821B9478h */ case    7:  		/* rlwinm R10, R11, 13, 29, 31 */
		/* 821B9478h case    7:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R10,regs.R11);
		/* 821B9478h case    7:*/		return 0x821B947C;
		  /* 821B947Ch */ case    8:  		/* cmplw CR6, R18, R10 */
		/* 821B947Ch case    8:*/		cpu::op::cmplw<6>(regs,regs.R18,regs.R10);
		/* 821B947Ch case    8:*/		return 0x821B9480;
		  /* 821B9480h */ case    9:  		/* bc 4, CR6_LT, 1036 */
		/* 821B9480h case    9:*/		if ( !regs.CR[6].lt ) { return 0x821B988C;  }
		/* 821B9480h case    9:*/		return 0x821B9484;
		  /* 821B9484h */ case   10:  		/* lwz R11, <#[R17]> */
		/* 821B9484h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R17 + 0x00000000) );
		/* 821B9484h case   10:*/		return 0x821B9488;
		  /* 821B9488h */ case   11:  		/* lwz R22, <#[R11 + 12]> */
		/* 821B9488h case   11:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R11 + 0x0000000C) );
		/* 821B9488h case   11:*/		return 0x821B948C;
		  /* 821B948Ch */ case   12:  		/* addi R19, R22, 4 */
		/* 821B948Ch case   12:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R22,0x4);
		/* 821B948Ch case   12:*/		return 0x821B9490;
		  /* 821B9490h */ case   13:  		/* lwz R20, <#[R19]> */
		/* 821B9490h case   13:*/		cpu::mem::load32z( regs, &regs.R20, (uint32)(regs.R19 + 0x00000000) );
		/* 821B9490h case   13:*/		return 0x821B9494;
		  /* 821B9494h */ case   14:  		/* cmplwi CR6, R20, 0 */
		/* 821B9494h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000000);
		/* 821B9494h case   14:*/		return 0x821B9498;
		  /* 821B9498h */ case   15:  		/* bc 12, CR6_EQ, 828 */
		/* 821B9498h case   15:*/		if ( regs.CR[6].eq ) { return 0x821B97D4;  }
		/* 821B9498h case   15:*/		return 0x821B949C;
		  /* 821B949Ch */ case   16:  		/* lwz R29, <#[R20 + 16]> */
		/* 821B949Ch case   16:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R20 + 0x00000010) );
		/* 821B949Ch case   16:*/		return 0x821B94A0;
		  /* 821B94A0h */ case   17:  		/* cmplwi CR6, R29, 0 */
		/* 821B94A0h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 821B94A0h case   17:*/		return 0x821B94A4;
		  /* 821B94A4h */ case   18:  		/* bc 12, CR6_EQ, 796 */
		/* 821B94A4h case   18:*/		if ( regs.CR[6].eq ) { return 0x821B97C0;  }
		/* 821B94A4h case   18:*/		return 0x821B94A8;
		  /* 821B94A8h */ case   19:  		/* lwz R11, <#[R20]> */
		/* 821B94A8h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R20 + 0x00000000) );
		/* 821B94A8h case   19:*/		return 0x821B94AC;
		  /* 821B94ACh */ case   20:  		/* rlwinm. R10, R11, 0, 1, 1 */
		/* 821B94ACh case   20:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R11);
		/* 821B94ACh case   20:*/		return 0x821B94B0;
		  /* 821B94B0h */ case   21:  		/* bc 4, CR0_EQ, 16 */
		/* 821B94B0h case   21:*/		if ( !regs.CR[0].eq ) { return 0x821B94C0;  }
		/* 821B94B0h case   21:*/		return 0x821B94B4;
		  /* 821B94B4h */ case   22:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 821B94B4h case   22:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 821B94B4h case   22:*/		return 0x821B94B8;
		  /* 821B94B8h */ case   23:  		/* li R11, 0 */
		/* 821B94B8h case   23:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821B94B8h case   23:*/		return 0x821B94BC;
		  /* 821B94BCh */ case   24:  		/* bc 12, CR0_EQ, 8 */
		/* 821B94BCh case   24:*/		if ( regs.CR[0].eq ) { return 0x821B94C4;  }
		/* 821B94BCh case   24:*/		return 0x821B94C0;
	}
	return 0x821B94C0;
} // Block from 821B945Ch-821B94C0h (25 instructions)

//////////////////////////////////////////////////////
// Block at 821B94C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B94C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B94C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B94C0);
		  /* 821B94C0h */ case    0:  		/* li R11, 1 */
		/* 821B94C0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821B94C0h case    0:*/		return 0x821B94C4;
	}
	return 0x821B94C4;
} // Block from 821B94C0h-821B94C4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B94C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B94C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B94C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B94C4);
		  /* 821B94C4h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821B94C4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821B94C4h case    0:*/		return 0x821B94C8;
		  /* 821B94C8h */ case    1:  		/* bc 12, CR0_EQ, 760 */
		/* 821B94C8h case    1:*/		if ( regs.CR[0].eq ) { return 0x821B97C0;  }
		/* 821B94C8h case    1:*/		return 0x821B94CC;
		  /* 821B94CCh */ case    2:  		/* cmplw CR6, R29, R26 */
		/* 821B94CCh case    2:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R26);
		/* 821B94CCh case    2:*/		return 0x821B94D0;
		  /* 821B94D0h */ case    3:  		/* bc 12, CR6_EQ, 752 */
		/* 821B94D0h case    3:*/		if ( regs.CR[6].eq ) { return 0x821B97C0;  }
		/* 821B94D0h case    3:*/		return 0x821B94D4;
		  /* 821B94D4h */ case    4:  		/* lwz R11, <#[R29 + 8]> */
		/* 821B94D4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 821B94D4h case    4:*/		return 0x821B94D8;
		  /* 821B94D8h */ case    5:  		/* rlwinm R10, R11, 0, 18, 24 */
		/* 821B94D8h case    5:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R11);
		/* 821B94D8h case    5:*/		return 0x821B94DC;
		  /* 821B94DCh */ case    6:  		/* cmplwi CR6, R10, 14080 */
		/* 821B94DCh case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003700);
		/* 821B94DCh case    6:*/		return 0x821B94E0;
		  /* 821B94E0h */ case    7:  		/* bc 4, CR6_EQ, 736 */
		/* 821B94E0h case    7:*/		if ( !regs.CR[6].eq ) { return 0x821B97C0;  }
		/* 821B94E0h case    7:*/		return 0x821B94E4;
		  /* 821B94E4h */ case    8:  		/* rlwinm. R11, R11, 8, 31, 31 */
		/* 821B94E4h case    8:*/		cpu::op::rlwinm<1,8,31,31>(regs,&regs.R11,regs.R11);
		/* 821B94E4h case    8:*/		return 0x821B94E8;
		  /* 821B94E8h */ case    9:  		/* bc 12, CR0_EQ, 728 */
		/* 821B94E8h case    9:*/		if ( regs.CR[0].eq ) { return 0x821B97C0;  }
		/* 821B94E8h case    9:*/		return 0x821B94EC;
		  /* 821B94ECh */ case   10:  		/* mr R4, R29 */
		/* 821B94ECh case   10:*/		regs.R4 = regs.R29;
		/* 821B94ECh case   10:*/		return 0x821B94F0;
		  /* 821B94F0h */ case   11:  		/* mr R3, R26 */
		/* 821B94F0h case   11:*/		regs.R3 = regs.R26;
		/* 821B94F0h case   11:*/		return 0x821B94F4;
		  /* 821B94F4h */ case   12:  		/* bl 445388 */
		/* 821B94F4h case   12:*/		regs.LR = 0x821B94F8; return 0x822260C0;
		/* 821B94F4h case   12:*/		return 0x821B94F8;
		  /* 821B94F8h */ case   13:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821B94F8h case   13:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821B94F8h case   13:*/		return 0x821B94FC;
		  /* 821B94FCh */ case   14:  		/* bc 12, CR0_EQ, 708 */
		/* 821B94FCh case   14:*/		if ( regs.CR[0].eq ) { return 0x821B97C0;  }
		/* 821B94FCh case   14:*/		return 0x821B9500;
		  /* 821B9500h */ case   15:  		/* lwz R11, <#[R26 + 8]> */
		/* 821B9500h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 821B9500h case   15:*/		return 0x821B9504;
		  /* 821B9504h */ case   16:  		/* li R31, 0 */
		/* 821B9504h case   16:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 821B9504h case   16:*/		return 0x821B9508;
		  /* 821B9508h */ case   17:  		/* li R6, 0 */
		/* 821B9508h case   17:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821B9508h case   17:*/		return 0x821B950C;
		  /* 821B950Ch */ case   18:  		/* li R4, 0 */
		/* 821B950Ch case   18:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 821B950Ch case   18:*/		return 0x821B9510;
		  /* 821B9510h */ case   19:  		/* li R3, 0 */
		/* 821B9510h case   19:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821B9510h case   19:*/		return 0x821B9514;
		  /* 821B9514h */ case   20:  		/* rlwinm R28, R11, 13, 29, 31 */
		/* 821B9514h case   20:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R28,regs.R11);
		/* 821B9514h case   20:*/		return 0x821B9518;
		  /* 821B9518h */ case   21:  		/* mr R5, R21 */
		/* 821B9518h case   21:*/		regs.R5 = regs.R21;
		/* 821B9518h case   21:*/		return 0x821B951C;
		  /* 821B951Ch */ case   22:  		/* cmplw CR6, R3, R28 */
		/* 821B951Ch case   22:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R28);
		/* 821B951Ch case   22:*/		return 0x821B9520;
		  /* 821B9520h */ case   23:  		/* bc 4, CR6_LT, 188 */
		/* 821B9520h case   23:*/		if ( !regs.CR[6].lt ) { return 0x821B95DC;  }
		/* 821B9520h case   23:*/		return 0x821B9524;
		  /* 821B9524h */ case   24:  		/* lwz R8, <#[R5]> */
		/* 821B9524h case   24:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R5 + 0x00000000) );
		/* 821B9524h case   24:*/		return 0x821B9528;
		  /* 821B9528h */ case   25:  		/* lwz R7, <#[R8 + 12]> */
		/* 821B9528h case   25:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R8 + 0x0000000C) );
		/* 821B9528h case   25:*/		return 0x821B952C;
		  /* 821B952Ch */ case   26:  		/* lwz R11, <#[R7 + 20]> */
		/* 821B952Ch case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000014) );
		/* 821B952Ch case   26:*/		return 0x821B9530;
		  /* 821B9530h */ case   27:  		/* rlwinm R11, R11, 19, 19, 31 */
		/* 821B9530h case   27:*/		cpu::op::rlwinm<0,19,19,31>(regs,&regs.R11,regs.R11);
		/* 821B9530h case   27:*/		return 0x821B9534;
		  /* 821B9534h */ case   28:  		/* cmplw CR6, R11, R4 */
		/* 821B9534h case   28:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R4);
		/* 821B9534h case   28:*/		return 0x821B9538;
		  /* 821B9538h */ case   29:  		/* bc 4, CR6_GT, 8 */
		/* 821B9538h case   29:*/		if ( !regs.CR[6].gt ) { return 0x821B9540;  }
		/* 821B9538h case   29:*/		return 0x821B953C;
		  /* 821B953Ch */ case   30:  		/* mr R4, R11 */
		/* 821B953Ch case   30:*/		regs.R4 = regs.R11;
		/* 821B953Ch case   30:*/		return 0x821B9540;
	}
	return 0x821B9540;
} // Block from 821B94C4h-821B9540h (31 instructions)

//////////////////////////////////////////////////////
// Block at 821B9540h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9540( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9540) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9540);
		  /* 821B9540h */ case    0:  		/* li R9, 0 */
		/* 821B9540h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821B9540h case    0:*/		return 0x821B9544;
		  /* 821B9544h */ case    1:  		/* mr R10, R21 */
		/* 821B9544h case    1:*/		regs.R10 = regs.R21;
		/* 821B9544h case    1:*/		return 0x821B9548;
		  /* 821B9548h */ case    2:  		/* cmplw CR6, R9, R28 */
		/* 821B9548h case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R28);
		/* 821B9548h case    2:*/		return 0x821B954C;
		  /* 821B954Ch */ case    3:  		/* bc 4, CR6_LT, 40 */
		/* 821B954Ch case    3:*/		if ( !regs.CR[6].lt ) { return 0x821B9574;  }
		/* 821B954Ch case    3:*/		return 0x821B9550;
		  /* 821B9550h */ case    4:  		/* lwz R11, <#[R10]> */
		/* 821B9550h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 821B9550h case    4:*/		return 0x821B9554;
		  /* 821B9554h */ case    5:  		/* cmplw CR6, R11, R8 */
		/* 821B9554h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 821B9554h case    5:*/		return 0x821B9558;
		  /* 821B9558h */ case    6:  		/* bc 12, CR6_EQ, 40 */
		/* 821B9558h case    6:*/		if ( regs.CR[6].eq ) { return 0x821B9580;  }
		/* 821B9558h case    6:*/		return 0x821B955C;
		  /* 821B955Ch */ case    7:  		/* lwz R30, <#[R11 + 12]> */
		/* 821B955Ch case    7:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x0000000C) );
		/* 821B955Ch case    7:*/		return 0x821B9560;
		  /* 821B9560h */ case    8:  		/* cmplw CR6, R30, R7 */
		/* 821B9560h case    8:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R7);
		/* 821B9560h case    8:*/		return 0x821B9564;
		  /* 821B9564h */ case    9:  		/* bc 12, CR6_EQ, 20 */
		/* 821B9564h case    9:*/		if ( regs.CR[6].eq ) { return 0x821B9578;  }
		/* 821B9564h case    9:*/		return 0x821B9568;
		  /* 821B9568h */ case   10:  		/* addi R9, R9, 1 */
		/* 821B9568h case   10:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 821B9568h case   10:*/		return 0x821B956C;
		  /* 821B956Ch */ case   11:  		/* addi R10, R10, 4 */
		/* 821B956Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821B956Ch case   11:*/		return 0x821B9570;
		  /* 821B9570h */ case   12:  		/* b -40 */
		/* 821B9570h case   12:*/		return 0x821B9548;
		/* 821B9570h case   12:*/		return 0x821B9574;
	}
	return 0x821B9574;
} // Block from 821B9540h-821B9574h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821B9574h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9574( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9574) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9574);
		  /* 821B9574h */ case    0:  		/* li R11, 0 */
		/* 821B9574h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821B9574h case    0:*/		return 0x821B9578;
	}
	return 0x821B9578;
} // Block from 821B9574h-821B9578h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B9578h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9578( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9578) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9578);
		  /* 821B9578h */ case    0:  		/* cmplw CR6, R11, R8 */
		/* 821B9578h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 821B9578h case    0:*/		return 0x821B957C;
		  /* 821B957Ch */ case    1:  		/* bc 4, CR6_EQ, 84 */
		/* 821B957Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x821B95D0;  }
		/* 821B957Ch case    1:*/		return 0x821B9580;
	}
	return 0x821B9580;
} // Block from 821B9578h-821B9580h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B9580h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9580( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9580) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9580);
		  /* 821B9580h */ case    0:  		/* lwz R9, <#[R29 + 8]> */
		/* 821B9580h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R29 + 0x00000008) );
		/* 821B9580h case    0:*/		return 0x821B9584;
		  /* 821B9584h */ case    1:  		/* li R11, 0 */
		/* 821B9584h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821B9584h case    1:*/		return 0x821B9588;
		  /* 821B9588h */ case    2:  		/* addi R10, R29, 44 */
		/* 821B9588h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R29,0x2C);
		/* 821B9588h case    2:*/		return 0x821B958C;
		  /* 821B958Ch */ case    3:  		/* rlwinm R9, R9, 13, 29, 31 */
		/* 821B958Ch case    3:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R9,regs.R9);
		/* 821B958Ch case    3:*/		return 0x821B9590;
		  /* 821B9590h */ case    4:  		/* cmplw CR6, R11, R9 */
		/* 821B9590h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 821B9590h case    4:*/		return 0x821B9594;
		  /* 821B9594h */ case    5:  		/* bc 4, CR6_LT, 48 */
		/* 821B9594h case    5:*/		if ( !regs.CR[6].lt ) { return 0x821B95C4;  }
		/* 821B9594h case    5:*/		return 0x821B9598;
		  /* 821B9598h */ case    6:  		/* lwz R8, <#[R10]> */
		/* 821B9598h case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 821B9598h case    6:*/		return 0x821B959C;
		  /* 821B959Ch */ case    7:  		/* lwz R8, <#[R8 + 12]> */
		/* 821B959Ch case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x0000000C) );
		/* 821B959Ch case    7:*/		return 0x821B95A0;
		  /* 821B95A0h */ case    8:  		/* cmplw CR6, R7, R8 */
		/* 821B95A0h case    8:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R8);
		/* 821B95A0h case    8:*/		return 0x821B95A4;
		  /* 821B95A4h */ case    9:  		/* bc 12, CR6_EQ, 16 */
		/* 821B95A4h case    9:*/		if ( regs.CR[6].eq ) { return 0x821B95B4;  }
		/* 821B95A4h case    9:*/		return 0x821B95A8;
		  /* 821B95A8h */ case   10:  		/* addi R11, R11, 1 */
		/* 821B95A8h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821B95A8h case   10:*/		return 0x821B95AC;
		  /* 821B95ACh */ case   11:  		/* addi R10, R10, 4 */
		/* 821B95ACh case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821B95ACh case   11:*/		return 0x821B95B0;
		  /* 821B95B0h */ case   12:  		/* b -32 */
		/* 821B95B0h case   12:*/		return 0x821B9590;
		/* 821B95B0h case   12:*/		return 0x821B95B4;
	}
	return 0x821B95B4;
} // Block from 821B9580h-821B95B4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821B95B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B95B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B95B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B95B4);
		  /* 821B95B4h */ case    0:  		/* lwz R11, <#[R7 + 8]> */
		/* 821B95B4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000008) );
		/* 821B95B4h case    0:*/		return 0x821B95B8;
		  /* 821B95B8h */ case    1:  		/* rlwinm R11, R11, 18, 29, 31 */
		/* 821B95B8h case    1:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R11,regs.R11);
		/* 821B95B8h case    1:*/		return 0x821B95BC;
		  /* 821B95BCh */ case    2:  		/* add R6, R11, R6 */
		/* 821B95BCh case    2:*/		cpu::op::add<0>(regs,&regs.R6,regs.R11,regs.R6);
		/* 821B95BCh case    2:*/		return 0x821B95C0;
		  /* 821B95C0h */ case    3:  		/* b 16 */
		/* 821B95C0h case    3:*/		return 0x821B95D0;
		/* 821B95C0h case    3:*/		return 0x821B95C4;
	}
	return 0x821B95C4;
} // Block from 821B95B4h-821B95C4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821B95C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B95C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B95C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B95C4);
		  /* 821B95C4h */ case    0:  		/* lwz R11, <#[R7 + 8]> */
		/* 821B95C4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000008) );
		/* 821B95C4h case    0:*/		return 0x821B95C8;
		  /* 821B95C8h */ case    1:  		/* rlwinm R11, R11, 18, 29, 31 */
		/* 821B95C8h case    1:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R11,regs.R11);
		/* 821B95C8h case    1:*/		return 0x821B95CC;
		  /* 821B95CCh */ case    2:  		/* add R31, R11, R31 */
		/* 821B95CCh case    2:*/		cpu::op::add<0>(regs,&regs.R31,regs.R11,regs.R31);
		/* 821B95CCh case    2:*/		return 0x821B95D0;
	}
	return 0x821B95D0;
} // Block from 821B95C4h-821B95D0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821B95D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B95D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B95D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B95D0);
		  /* 821B95D0h */ case    0:  		/* addi R3, R3, 1 */
		/* 821B95D0h case    0:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R3,0x1);
		/* 821B95D0h case    0:*/		return 0x821B95D4;
		  /* 821B95D4h */ case    1:  		/* addi R5, R5, 4 */
		/* 821B95D4h case    1:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x4);
		/* 821B95D4h case    1:*/		return 0x821B95D8;
		  /* 821B95D8h */ case    2:  		/* b -188 */
		/* 821B95D8h case    2:*/		return 0x821B951C;
		/* 821B95D8h case    2:*/		return 0x821B95DC;
	}
	return 0x821B95DC;
} // Block from 821B95D0h-821B95DCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821B95DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B95DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B95DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B95DC);
		  /* 821B95DCh */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 821B95DCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821B95DCh case    0:*/		return 0x821B95E0;
		  /* 821B95E0h */ case    1:  		/* bc 4, CR6_EQ, 20 */
		/* 821B95E0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821B95F4;  }
		/* 821B95E0h case    1:*/		return 0x821B95E4;
		  /* 821B95E4h */ case    2:  		/* lwz R11, <#[R29 + 8]> */
		/* 821B95E4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 821B95E4h case    2:*/		return 0x821B95E8;
		  /* 821B95E8h */ case    3:  		/* rlwinm R10, R11, 18, 29, 31 */
		/* 821B95E8h case    3:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R10,regs.R11);
		/* 821B95E8h case    3:*/		return 0x821B95EC;
		  /* 821B95ECh */ case    4:  		/* subf. R10, R6, R10 */
		/* 821B95ECh case    4:*/		cpu::op::subf<1>(regs,&regs.R10,regs.R6,regs.R10);
		/* 821B95ECh case    4:*/		return 0x821B95F0;
		  /* 821B95F0h */ case    5:  		/* bc 12, CR0_EQ, 496 */
		/* 821B95F0h case    5:*/		if ( regs.CR[0].eq ) { return 0x821B97E0;  }
		/* 821B95F0h case    5:*/		return 0x821B95F4;
	}
	return 0x821B95F4;
} // Block from 821B95DCh-821B95F4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821B95F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B95F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B95F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B95F4);
		  /* 821B95F4h */ case    0:  		/* lwz R11, <#[R29 + 20]> */
		/* 821B95F4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000014) );
		/* 821B95F4h case    0:*/		return 0x821B95F8;
		  /* 821B95F8h */ case    1:  		/* mr R28, R26 */
		/* 821B95F8h case    1:*/		regs.R28 = regs.R26;
		/* 821B95F8h case    1:*/		return 0x821B95FC;
		  /* 821B95FCh */ case    2:  		/* rlwinm R11, R11, 19, 19, 31 */
		/* 821B95FCh case    2:*/		cpu::op::rlwinm<0,19,19,31>(regs,&regs.R11,regs.R11);
		/* 821B95FCh case    2:*/		return 0x821B9600;
		  /* 821B9600h */ case    3:  		/* cmplw CR6, R4, R11 */
		/* 821B9600h case    3:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 821B9600h case    3:*/		return 0x821B9604;
		  /* 821B9604h */ case    4:  		/* bc 4, CR6_GT, 8 */
		/* 821B9604h case    4:*/		if ( !regs.CR[6].gt ) { return 0x821B960C;  }
		/* 821B9604h case    4:*/		return 0x821B9608;
		  /* 821B9608h */ case    5:  		/* mr R28, R29 */
		/* 821B9608h case    5:*/		regs.R28 = regs.R29;
		/* 821B9608h case    5:*/		return 0x821B960C;
	}
	return 0x821B960C;
} // Block from 821B95F4h-821B960Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 821B960Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B960C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B960C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B960C);
		  /* 821B960Ch */ case    0:  		/* lwz R10, <#[R28 + 8]> */
		/* 821B960Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000008) );
		/* 821B960Ch case    0:*/		return 0x821B9610;
		  /* 821B9610h */ case    1:  		/* addi R29, R28, 44 */
		/* 821B9610h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R28,0x2C);
		/* 821B9610h case    1:*/		return 0x821B9614;
		  /* 821B9614h */ case    2:  		/* li R5, 0 */
		/* 821B9614h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821B9614h case    2:*/		return 0x821B9618;
		  /* 821B9618h */ case    3:  		/* li R6, 0 */
		/* 821B9618h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821B9618h case    3:*/		return 0x821B961C;
		  /* 821B961Ch */ case    4:  		/* li R23, 0 */
		/* 821B961Ch case    4:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 821B961Ch case    4:*/		return 0x821B9620;
		  /* 821B9620h */ case    5:  		/* li R8, 0 */
		/* 821B9620h case    5:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821B9620h case    5:*/		return 0x821B9624;
		  /* 821B9624h */ case    6:  		/* li R11, 0 */
		/* 821B9624h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821B9624h case    6:*/		return 0x821B9628;
		  /* 821B9628h */ case    7:  		/* rlwinm R7, R10, 13, 29, 31 */
		/* 821B9628h case    7:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R7,regs.R10);
		/* 821B9628h case    7:*/		return 0x821B962C;
		  /* 821B962Ch */ case    8:  		/* mr R9, R29 */
		/* 821B962Ch case    8:*/		regs.R9 = regs.R29;
		/* 821B962Ch case    8:*/		return 0x821B9630;
		  /* 821B9630h */ case    9:  		/* cmplw CR6, R8, R7 */
		/* 821B9630h case    9:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R7);
		/* 821B9630h case    9:*/		return 0x821B9634;
		  /* 821B9634h */ case   10:  		/* bc 4, CR6_LT, 88 */
		/* 821B9634h case   10:*/		if ( !regs.CR[6].lt ) { return 0x821B968C;  }
		/* 821B9634h case   10:*/		return 0x821B9638;
		  /* 821B9638h */ case   11:  		/* lwz R10, <#[R9]> */
		/* 821B9638h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 821B9638h case   11:*/		return 0x821B963C;
		  /* 821B963Ch */ case   12:  		/* lwz R4, <#[R10 + 12]> */
		/* 821B963Ch case   12:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x0000000C) );
		/* 821B963Ch case   12:*/		return 0x821B9640;
		  /* 821B9640h */ case   13:  		/* cmplw CR6, R4, R22 */
		/* 821B9640h case   13:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R22);
		/* 821B9640h case   13:*/		return 0x821B9644;
		  /* 821B9644h */ case   14:  		/* bc 4, CR6_EQ, 60 */
		/* 821B9644h case   14:*/		if ( !regs.CR[6].eq ) { return 0x821B9680;  }
		/* 821B9644h case   14:*/		return 0x821B9648;
		  /* 821B9648h */ case   15:  		/* lwz R4, <#[R10]> */
		/* 821B9648h case   15:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000000) );
		/* 821B9648h case   15:*/		return 0x821B964C;
		  /* 821B964Ch */ case   16:  		/* li R10, 3 */
		/* 821B964Ch case   16:*/		cpu::op::li<0>(regs,&regs.R10,0x3);
		/* 821B964Ch case   16:*/		return 0x821B9650;
		  /* 821B9650h */ case   17:  		/* rlwinm R4, R4, 27, 30, 31 */
		/* 821B9650h case   17:*/		cpu::op::rlwinm<0,27,30,31>(regs,&regs.R4,regs.R4);
		/* 821B9650h case   17:*/		return 0x821B9654;
		  /* 821B9654h */ case   18:  		/* slw R3, R10, R11 */
		/* 821B9654h case   18:*/		cpu::op::slw<0>(regs,&regs.R3,regs.R10,regs.R11);
		/* 821B9654h case   18:*/		return 0x821B9658;
		  /* 821B9658h */ case   19:  		/* rlwinm R31, R4, 1, 0, 30 */
		/* 821B9658h case   19:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R31,regs.R4);
		/* 821B9658h case   19:*/		return 0x821B965C;
		  /* 821B965Ch */ case   20:  		/* slw R4, R4, R11 */
		/* 821B965Ch case   20:*/		cpu::op::slw<0>(regs,&regs.R4,regs.R4,regs.R11);
		/* 821B965Ch case   20:*/		return 0x821B9660;
		  /* 821B9660h */ case   21:  		/* slw R10, R10, R31 */
		/* 821B9660h case   21:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R10,regs.R31);
		/* 821B9660h case   21:*/		return 0x821B9664;
		  /* 821B9664h */ case   22:  		/* slw R31, R5, R31 */
		/* 821B9664h case   22:*/		cpu::op::slw<0>(regs,&regs.R31,regs.R5,regs.R31);
		/* 821B9664h case   22:*/		return 0x821B9668;
		  /* 821B9668h */ case   23:  		/* andc R6, R6, R3 */
		/* 821B9668h case   23:*/		cpu::op::andc<0>(regs,&regs.R6,regs.R6,regs.R3);
		/* 821B9668h case   23:*/		return 0x821B966C;
		  /* 821B966Ch */ case   24:  		/* andc R10, R23, R10 */
		/* 821B966Ch case   24:*/		cpu::op::andc<0>(regs,&regs.R10,regs.R23,regs.R10);
		/* 821B966Ch case   24:*/		return 0x821B9670;
		  /* 821B9670h */ case   25:  		/* or R6, R6, R4 */
		/* 821B9670h case   25:*/		cpu::op::or<0>(regs,&regs.R6,regs.R6,regs.R4);
		/* 821B9670h case   25:*/		return 0x821B9674;
		  /* 821B9674h */ case   26:  		/* or R23, R10, R31 */
		/* 821B9674h case   26:*/		cpu::op::or<0>(regs,&regs.R23,regs.R10,regs.R31);
		/* 821B9674h case   26:*/		return 0x821B9678;
		  /* 821B9678h */ case   27:  		/* addi R5, R5, 1 */
		/* 821B9678h case   27:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 821B9678h case   27:*/		return 0x821B967C;
		  /* 821B967Ch */ case   28:  		/* addi R11, R11, 2 */
		/* 821B967Ch case   28:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 821B967Ch case   28:*/		return 0x821B9680;
	}
	return 0x821B9680;
} // Block from 821B960Ch-821B9680h (29 instructions)

//////////////////////////////////////////////////////
// Block at 821B9680h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9680( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9680) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9680);
		  /* 821B9680h */ case    0:  		/* addi R8, R8, 1 */
		/* 821B9680h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x1);
		/* 821B9680h case    0:*/		return 0x821B9684;
		  /* 821B9684h */ case    1:  		/* addi R9, R9, 4 */
		/* 821B9684h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x4);
		/* 821B9684h case    1:*/		return 0x821B9688;
		  /* 821B9688h */ case    2:  		/* b -88 */
		/* 821B9688h case    2:*/		return 0x821B9630;
		/* 821B9688h case    2:*/		return 0x821B968C;
	}
	return 0x821B968C;
} // Block from 821B9680h-821B968Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 821B968Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B968C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B968C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B968C);
		  /* 821B968Ch */ case    0:  		/* li R7, 0 */
		/* 821B968Ch case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821B968Ch case    0:*/		return 0x821B9690;
		  /* 821B9690h */ case    1:  		/* mr R4, R22 */
		/* 821B9690h case    1:*/		regs.R4 = regs.R22;
		/* 821B9690h case    1:*/		return 0x821B9694;
		  /* 821B9694h */ case    2:  		/* mr R3, R27 */
		/* 821B9694h case    2:*/		regs.R3 = regs.R27;
		/* 821B9694h case    2:*/		return 0x821B9698;
		  /* 821B9698h */ case    3:  		/* bl -267736 */
		/* 821B9698h case    3:*/		regs.LR = 0x821B969C; return 0x821780C0;
		/* 821B9698h case    3:*/		return 0x821B969C;
		  /* 821B969Ch */ case    4:  		/* mr R7, R3 */
		/* 821B969Ch case    4:*/		regs.R7 = regs.R3;
		/* 821B969Ch case    4:*/		return 0x821B96A0;
		  /* 821B96A0h */ case    5:  		/* mr R6, R3 */
		/* 821B96A0h case    5:*/		regs.R6 = regs.R3;
		/* 821B96A0h case    5:*/		return 0x821B96A4;
		  /* 821B96A4h */ case    6:  		/* li R5, 0 */
		/* 821B96A4h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821B96A4h case    6:*/		return 0x821B96A8;
		  /* 821B96A8h */ case    7:  		/* mr R4, R15 */
		/* 821B96A8h case    7:*/		regs.R4 = regs.R15;
		/* 821B96A8h case    7:*/		return 0x821B96AC;
		  /* 821B96ACh */ case    8:  		/* mr R3, R27 */
		/* 821B96ACh case    8:*/		regs.R3 = regs.R27;
		/* 821B96ACh case    8:*/		return 0x821B96B0;
		  /* 821B96B0h */ case    9:  		/* bl -260216 */
		/* 821B96B0h case    9:*/		regs.LR = 0x821B96B4; return 0x82179E38;
		/* 821B96B0h case    9:*/		return 0x821B96B4;
		  /* 821B96B4h */ case   10:  		/* rlwinm R11, R28, 0, 0, 30 */
		/* 821B96B4h case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R28);
		/* 821B96B4h case   10:*/		return 0x821B96B8;
		  /* 821B96B8h */ case   11:  		/* rlwinm R10, R3, 0, 0, 30 */
		/* 821B96B8h case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R3);
		/* 821B96B8h case   11:*/		return 0x821B96BC;
		  /* 821B96BCh */ case   12:  		/* addi R11, R11, 36 */
		/* 821B96BCh case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821B96BCh case   12:*/		return 0x821B96C0;
		  /* 821B96C0h */ case   13:  		/* addi R10, R10, 36 */
		/* 821B96C0h case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 821B96C0h case   13:*/		return 0x821B96C4;
		  /* 821B96C4h */ case   14:  		/* addi R8, R11, -36 */
		/* 821B96C4h case   14:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821B96C4h case   14:*/		return 0x821B96C8;
		  /* 821B96C8h */ case   15:  		/* addi R6, R10, -36 */
		/* 821B96C8h case   15:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R10,0xFFFFFFDC);
		/* 821B96C8h case   15:*/		return 0x821B96CC;
		  /* 821B96CCh */ case   16:  		/* addi R9, R10, 4 */
		/* 821B96CCh case   16:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 821B96CCh case   16:*/		return 0x821B96D0;
		  /* 821B96D0h */ case   17:  		/* lwz R7, <#[R11]> */
		/* 821B96D0h case   17:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821B96D0h case   17:*/		return 0x821B96D4;
		  /* 821B96D4h */ case   18:  		/* mr R31, R3 */
		/* 821B96D4h case   18:*/		regs.R31 = regs.R3;
		/* 821B96D4h case   18:*/		return 0x821B96D8;
		  /* 821B96D8h */ case   19:  		/* li R24, 0 */
		/* 821B96D8h case   19:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 821B96D8h case   19:*/		return 0x821B96DC;
		  /* 821B96DCh */ case   20:  		/* mr R25, R29 */
		/* 821B96DCh case   20:*/		regs.R25 = regs.R29;
		/* 821B96DCh case   20:*/		return 0x821B96E0;
		  /* 821B96E0h */ case   21:  		/* stw R7, <#[R10]> */
		/* 821B96E0h case   21:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821B96E0h case   21:*/		return 0x821B96E4;
		  /* 821B96E4h */ case   22:  		/* lwz R7, <#[R11]> */
		/* 821B96E4h case   22:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821B96E4h case   22:*/		return 0x821B96E8;
		  /* 821B96E8h */ case   23:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821B96E8h case   23:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821B96E8h case   23:*/		return 0x821B96EC;
		  /* 821B96ECh */ case   24:  		/* stw R6, <#[R7]> */
		/* 821B96ECh case   24:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R7 + 0x00000000) );
		/* 821B96ECh case   24:*/		return 0x821B96F0;
		  /* 821B96F0h */ case   25:  		/* stw R8, <#[R10 + 4]> */
		/* 821B96F0h case   25:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 821B96F0h case   25:*/		return 0x821B96F4;
		  /* 821B96F4h */ case   26:  		/* stw R9, <#[R11]> */
		/* 821B96F4h case   26:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821B96F4h case   26:*/		return 0x821B96F8;
		  /* 821B96F8h */ case   27:  		/* lwz R11, <#[R28 + 8]> */
		/* 821B96F8h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 821B96F8h case   27:*/		return 0x821B96FC;
		  /* 821B96FCh */ case   28:  		/* rlwinm R11, R11, 13, 29, 31 */
		/* 821B96FCh case   28:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R11,regs.R11);
		/* 821B96FCh case   28:*/		return 0x821B9700;
		  /* 821B9700h */ case   29:  		/* cmplw CR6, R24, R11 */
		/* 821B9700h case   29:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R11);
		/* 821B9700h case   29:*/		return 0x821B9704;
		  /* 821B9704h */ case   30:  		/* bc 4, CR6_LT, 108 */
		/* 821B9704h case   30:*/		if ( !regs.CR[6].lt ) { return 0x821B9770;  }
		/* 821B9704h case   30:*/		return 0x821B9708;
		  /* 821B9708h */ case   31:  		/* lwz R29, <#[R25]> */
		/* 821B9708h case   31:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R25 + 0x00000000) );
		/* 821B9708h case   31:*/		return 0x821B970C;
		  /* 821B970Ch */ case   32:  		/* lwz R11, <#[R29 + 12]> */
		/* 821B970Ch case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 821B970Ch case   32:*/		return 0x821B9710;
		  /* 821B9710h */ case   33:  		/* cmplw CR6, R11, R22 */
		/* 821B9710h case   33:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R22);
		/* 821B9710h case   33:*/		return 0x821B9714;
		  /* 821B9714h */ case   34:  		/* bc 4, CR6_EQ, 80 */
		/* 821B9714h case   34:*/		if ( !regs.CR[6].eq ) { return 0x821B9764;  }
		/* 821B9714h case   34:*/		return 0x821B9718;
		  /* 821B9718h */ case   35:  		/* addi R11, R11, 4 */
		/* 821B9718h case   35:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821B9718h case   35:*/		return 0x821B971C;
		  /* 821B971Ch */ case   36:  		/* lwz R10, <#[R11]> */
		/* 821B971Ch case   36:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821B971Ch case   36:*/		return 0x821B9720;
		  /* 821B9720h */ case   37:  		/* b 12 */
		/* 821B9720h case   37:*/		return 0x821B972C;
		/* 821B9720h case   37:*/		return 0x821B9724;
		  /* 821B9724h */ case   38:  		/* addi R11, R10, 8 */
		/* 821B9724h case   38:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 821B9724h case   38:*/		return 0x821B9728;
		  /* 821B9728h */ case   39:  		/* lwz R10, <#[R10 + 8]> */
		/* 821B9728h case   39:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 821B9728h case   39:*/		return 0x821B972C;
	}
	return 0x821B972C;
} // Block from 821B968Ch-821B972Ch (40 instructions)

//////////////////////////////////////////////////////
// Block at 821B972Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B972C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B972C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B972C);
		  /* 821B972Ch */ case    0:  		/* cmplw CR6, R10, R29 */
		/* 821B972Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R29);
		/* 821B972Ch case    0:*/		return 0x821B9730;
		  /* 821B9730h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 821B9730h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821B9724;  }
		/* 821B9730h case    1:*/		return 0x821B9734;
		  /* 821B9734h */ case    2:  		/* lwz R10, <#[R29 + 8]> */
		/* 821B9734h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000008) );
		/* 821B9734h case    2:*/		return 0x821B9738;
		  /* 821B9738h */ case    3:  		/* mr R4, R23 */
		/* 821B9738h case    3:*/		regs.R4 = regs.R23;
		/* 821B9738h case    3:*/		return 0x821B973C;
		  /* 821B973Ch */ case    4:  		/* mr R3, R29 */
		/* 821B973Ch case    4:*/		regs.R3 = regs.R29;
		/* 821B973Ch case    4:*/		return 0x821B9740;
		  /* 821B9740h */ case    5:  		/* stw R10, <#[R11]> */
		/* 821B9740h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821B9740h case    5:*/		return 0x821B9744;
		  /* 821B9744h */ case    6:  		/* lwz R11, <#[R31 + 4]> */
		/* 821B9744h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 821B9744h case    6:*/		return 0x821B9748;
		  /* 821B9748h */ case    7:  		/* stw R11, <#[R29 + 8]> */
		/* 821B9748h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 821B9748h case    7:*/		return 0x821B974C;
		  /* 821B974Ch */ case    8:  		/* stw R29, <#[R31 + 4]> */
		/* 821B974Ch case    8:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000004) );
		/* 821B974Ch case    8:*/		return 0x821B9750;
		  /* 821B9750h */ case    9:  		/* stw R31, <#[R29 + 12]> */
		/* 821B9750h case    9:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R29 + 0x0000000C) );
		/* 821B9750h case    9:*/		return 0x821B9754;
		  /* 821B9754h */ case   10:  		/* bl -297452 */
		/* 821B9754h case   10:*/		regs.LR = 0x821B9758; return 0x82170D68;
		/* 821B9754h case   10:*/		return 0x821B9758;
		  /* 821B9758h */ case   11:  		/* lwz R11, <#[R29]> */
		/* 821B9758h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 821B9758h case   11:*/		return 0x821B975C;
		  /* 821B975Ch */ case   12:  		/* rlwinm R11, R11, 0, 0, 26 */
		/* 821B975Ch case   12:*/		cpu::op::rlwinm<0,0,0,26>(regs,&regs.R11,regs.R11);
		/* 821B975Ch case   12:*/		return 0x821B9760;
		  /* 821B9760h */ case   13:  		/* stw R11, <#[R29]> */
		/* 821B9760h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 821B9760h case   13:*/		return 0x821B9764;
	}
	return 0x821B9764;
} // Block from 821B972Ch-821B9764h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821B9764h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9764( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9764) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9764);
		  /* 821B9764h */ case    0:  		/* addi R24, R24, 1 */
		/* 821B9764h case    0:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x1);
		/* 821B9764h case    0:*/		return 0x821B9768;
		  /* 821B9768h */ case    1:  		/* addi R25, R25, 4 */
		/* 821B9768h case    1:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R25,0x4);
		/* 821B9768h case    1:*/		return 0x821B976C;
		  /* 821B976Ch */ case    2:  		/* b -116 */
		/* 821B976Ch case    2:*/		return 0x821B96F8;
		/* 821B976Ch case    2:*/		return 0x821B9770;
	}
	return 0x821B9770;
} // Block from 821B9764h-821B9770h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821B9770h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9770( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9770) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9770);
		  /* 821B9770h */ case    0:  		/* mr R3, R31 */
		/* 821B9770h case    0:*/		regs.R3 = regs.R31;
		/* 821B9770h case    0:*/		return 0x821B9774;
		  /* 821B9774h */ case    1:  		/* bl -267260 */
		/* 821B9774h case    1:*/		regs.LR = 0x821B9778; return 0x82178378;
		/* 821B9774h case    1:*/		return 0x821B9778;
		  /* 821B9778h */ case    2:  		/* mr R3, R31 */
		/* 821B9778h case    2:*/		regs.R3 = regs.R31;
		/* 821B9778h case    2:*/		return 0x821B977C;
		  /* 821B977Ch */ case    3:  		/* bl -171252 */
		/* 821B977Ch case    3:*/		regs.LR = 0x821B9780; return 0x8218FA88;
		/* 821B977Ch case    3:*/		return 0x821B9780;
		  /* 821B9780h */ case    4:  		/* lwz R11, <#[R31 + 8]> */
		/* 821B9780h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821B9780h case    4:*/		return 0x821B9784;
		  /* 821B9784h */ case    5:  		/* mr R4, R28 */
		/* 821B9784h case    5:*/		regs.R4 = regs.R28;
		/* 821B9784h case    5:*/		return 0x821B9788;
		  /* 821B9788h */ case    6:  		/* oris R11, R11, 256 */
		/* 821B9788h case    6:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x100);
		/* 821B9788h case    6:*/		return 0x821B978C;
		  /* 821B978Ch */ case    7:  		/* mr R3, R27 */
		/* 821B978Ch case    7:*/		regs.R3 = regs.R27;
		/* 821B978Ch case    7:*/		return 0x821B9790;
		  /* 821B9790h */ case    8:  		/* stw R11, <#[R31 + 8]> */
		/* 821B9790h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821B9790h case    8:*/		return 0x821B9794;
		  /* 821B9794h */ case    9:  		/* bl -13228 */
		/* 821B9794h case    9:*/		regs.LR = 0x821B9798; return 0x821B63E8;
		/* 821B9794h case    9:*/		return 0x821B9798;
		  /* 821B9798h */ case   10:  		/* lwz R11, <#[R28 + 8]> */
		/* 821B9798h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 821B9798h case   10:*/		return 0x821B979C;
		  /* 821B979Ch */ case   11:  		/* rlwinm. R10, R11, 9, 31, 31 */
		/* 821B979Ch case   11:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R10,regs.R11);
		/* 821B979Ch case   11:*/		return 0x821B97A0;
		  /* 821B97A0h */ case   12:  		/* bc 12, CR0_EQ, 24 */
		/* 821B97A0h case   12:*/		if ( regs.CR[0].eq ) { return 0x821B97B8;  }
		/* 821B97A0h case   12:*/		return 0x821B97A4;
		  /* 821B97A4h */ case   13:  		/* rlwinm R11, R11, 0, 9, 7 */
		/* 821B97A4h case   13:*/		cpu::op::rlwinm<0,0,9,7>(regs,&regs.R11,regs.R11);
		/* 821B97A4h case   13:*/		return 0x821B97A8;
		  /* 821B97A8h */ case   14:  		/* mr R4, R28 */
		/* 821B97A8h case   14:*/		regs.R4 = regs.R28;
		/* 821B97A8h case   14:*/		return 0x821B97AC;
		  /* 821B97ACh */ case   15:  		/* stw R11, <#[R28 + 8]> */
		/* 821B97ACh case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 821B97ACh case   15:*/		return 0x821B97B0;
		  /* 821B97B0h */ case   16:  		/* mr R3, R27 */
		/* 821B97B0h case   16:*/		regs.R3 = regs.R27;
		/* 821B97B0h case   16:*/		return 0x821B97B4;
		  /* 821B97B4h */ case   17:  		/* bl -11628 */
		/* 821B97B4h case   17:*/		regs.LR = 0x821B97B8; return 0x821B6A48;
		/* 821B97B4h case   17:*/		return 0x821B97B8;
	}
	return 0x821B97B8;
} // Block from 821B9770h-821B97B8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821B97B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B97B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B97B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B97B8);
		  /* 821B97B8h */ case    0:  		/* cmplw CR6, R28, R26 */
		/* 821B97B8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R26);
		/* 821B97B8h case    0:*/		return 0x821B97BC;
		  /* 821B97BCh */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 821B97BCh case    1:*/		if ( regs.CR[6].eq ) { return 0x821B97D4;  }
		/* 821B97BCh case    1:*/		return 0x821B97C0;
	}
	return 0x821B97C0;
} // Block from 821B97B8h-821B97C0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B97C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B97C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B97C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B97C0);
		  /* 821B97C0h */ case    0:  		/* lwz R11, <#[R19]> */
		/* 821B97C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000000) );
		/* 821B97C0h case    0:*/		return 0x821B97C4;
		  /* 821B97C4h */ case    1:  		/* cmplw CR6, R11, R20 */
		/* 821B97C4h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R20);
		/* 821B97C4h case    1:*/		return 0x821B97C8;
		  /* 821B97C8h */ case    2:  		/* bc 4, CR6_EQ, -824 */
		/* 821B97C8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821B9490;  }
		/* 821B97C8h case    2:*/		return 0x821B97CC;
		  /* 821B97CCh */ case    3:  		/* addi R19, R20, 8 */
		/* 821B97CCh case    3:*/		cpu::op::addi<0>(regs,&regs.R19,regs.R20,0x8);
		/* 821B97CCh case    3:*/		return 0x821B97D0;
		  /* 821B97D0h */ case    4:  		/* b -832 */
		/* 821B97D0h case    4:*/		return 0x821B9490;
		/* 821B97D0h case    4:*/		return 0x821B97D4;
	}
	return 0x821B97D4;
} // Block from 821B97C0h-821B97D4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821B97D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B97D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B97D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B97D4);
		  /* 821B97D4h */ case    0:  		/* addi R18, R18, 1 */
		/* 821B97D4h case    0:*/		cpu::op::addi<0>(regs,&regs.R18,regs.R18,0x1);
		/* 821B97D4h case    0:*/		return 0x821B97D8;
		  /* 821B97D8h */ case    1:  		/* addi R17, R17, 4 */
		/* 821B97D8h case    1:*/		cpu::op::addi<0>(regs,&regs.R17,regs.R17,0x4);
		/* 821B97D8h case    1:*/		return 0x821B97DC;
		  /* 821B97DCh */ case    2:  		/* b -872 */
		/* 821B97DCh case    2:*/		return 0x821B9474;
		/* 821B97DCh case    2:*/		return 0x821B97E0;
	}
	return 0x821B97E0;
} // Block from 821B97D4h-821B97E0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821B97E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B97E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B97E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B97E0);
		  /* 821B97E0h */ case    0:  		/* rlwinm R11, R11, 13, 29, 31 */
		/* 821B97E0h case    0:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R11,regs.R11);
		/* 821B97E0h case    0:*/		return 0x821B97E4;
		  /* 821B97E4h */ case    1:  		/* mr R5, R29 */
		/* 821B97E4h case    1:*/		regs.R5 = regs.R29;
		/* 821B97E4h case    1:*/		return 0x821B97E8;
		  /* 821B97E8h */ case    2:  		/* cmplw CR6, R6, R11 */
		/* 821B97E8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R11);
		/* 821B97E8h case    2:*/		return 0x821B97EC;
		  /* 821B97ECh */ case    3:  		/* bc 4, CR6_GT, 136 */
		/* 821B97ECh case    3:*/		if ( !regs.CR[6].gt ) { return 0x821B9874;  }
		/* 821B97ECh case    3:*/		return 0x821B97F0;
		  /* 821B97F0h */ case    4:  		/* li R5, 0 */
		/* 821B97F0h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821B97F0h case    4:*/		return 0x821B97F4;
		  /* 821B97F4h */ case    5:  		/* mr R4, R15 */
		/* 821B97F4h case    5:*/		regs.R4 = regs.R15;
		/* 821B97F4h case    5:*/		return 0x821B97F8;
		  /* 821B97F8h */ case    6:  		/* mr R3, R27 */
		/* 821B97F8h case    6:*/		regs.R3 = regs.R27;
		/* 821B97F8h case    6:*/		return 0x821B97FC;
		  /* 821B97FCh */ case    7:  		/* bl 439044 */
		/* 821B97FCh case    7:*/		regs.LR = 0x821B9800; return 0x82224B00;
		/* 821B97FCh case    7:*/		return 0x821B9800;
		  /* 821B9800h */ case    8:  		/* rlwinm R11, R29, 0, 0, 30 */
		/* 821B9800h case    8:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R29);
		/* 821B9800h case    8:*/		return 0x821B9804;
		  /* 821B9804h */ case    9:  		/* rlwinm R10, R3, 0, 0, 30 */
		/* 821B9804h case    9:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R3);
		/* 821B9804h case    9:*/		return 0x821B9808;
		  /* 821B9808h */ case   10:  		/* addi R11, R11, 36 */
		/* 821B9808h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821B9808h case   10:*/		return 0x821B980C;
		  /* 821B980Ch */ case   11:  		/* addi R10, R10, 36 */
		/* 821B980Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 821B980Ch case   11:*/		return 0x821B9810;
		  /* 821B9810h */ case   12:  		/* addi R8, R11, -36 */
		/* 821B9810h case   12:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0xFFFFFFDC);
		/* 821B9810h case   12:*/		return 0x821B9814;
		  /* 821B9814h */ case   13:  		/* addi R30, R10, -36 */
		/* 821B9814h case   13:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R10,0xFFFFFFDC);
		/* 821B9814h case   13:*/		return 0x821B9818;
		  /* 821B9818h */ case   14:  		/* addi R9, R10, 4 */
		/* 821B9818h case   14:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 821B9818h case   14:*/		return 0x821B981C;
		  /* 821B981Ch */ case   15:  		/* lwz R7, <#[R11]> */
		/* 821B981Ch case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821B981Ch case   15:*/		return 0x821B9820;
		  /* 821B9820h */ case   16:  		/* mr R31, R3 */
		/* 821B9820h case   16:*/		regs.R31 = regs.R3;
		/* 821B9820h case   16:*/		return 0x821B9824;
		  /* 821B9824h */ case   17:  		/* mr R4, R3 */
		/* 821B9824h case   17:*/		regs.R4 = regs.R3;
		/* 821B9824h case   17:*/		return 0x821B9828;
		  /* 821B9828h */ case   18:  		/* mr R6, R29 */
		/* 821B9828h case   18:*/		regs.R6 = regs.R29;
		/* 821B9828h case   18:*/		return 0x821B982C;
		  /* 821B982Ch */ case   19:  		/* li R5, 0 */
		/* 821B982Ch case   19:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821B982Ch case   19:*/		return 0x821B9830;
		  /* 821B9830h */ case   20:  		/* mr R3, R27 */
		/* 821B9830h case   20:*/		regs.R3 = regs.R27;
		/* 821B9830h case   20:*/		return 0x821B9834;
		  /* 821B9834h */ case   21:  		/* stw R7, <#[R10]> */
		/* 821B9834h case   21:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821B9834h case   21:*/		return 0x821B9838;
		  /* 821B9838h */ case   22:  		/* lwz R7, <#[R11]> */
		/* 821B9838h case   22:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821B9838h case   22:*/		return 0x821B983C;
		  /* 821B983Ch */ case   23:  		/* rlwinm R7, R7, 0, 0, 30 */
		/* 821B983Ch case   23:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R7,regs.R7);
		/* 821B983Ch case   23:*/		return 0x821B9840;
		  /* 821B9840h */ case   24:  		/* stw R30, <#[R7]> */
		/* 821B9840h case   24:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R7 + 0x00000000) );
		/* 821B9840h case   24:*/		return 0x821B9844;
		  /* 821B9844h */ case   25:  		/* stw R8, <#[R10 + 4]> */
		/* 821B9844h case   25:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 821B9844h case   25:*/		return 0x821B9848;
		  /* 821B9848h */ case   26:  		/* stw R9, <#[R11]> */
		/* 821B9848h case   26:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821B9848h case   26:*/		return 0x821B984C;
		  /* 821B984Ch */ case   27:  		/* bl -11148 */
		/* 821B984Ch case   27:*/		regs.LR = 0x821B9850; return 0x821B6CC0;
		/* 821B984Ch case   27:*/		return 0x821B9850;
		  /* 821B9850h */ case   28:  		/* mr R5, R31 */
		/* 821B9850h case   28:*/		regs.R5 = regs.R31;
		/* 821B9850h case   28:*/		return 0x821B9854;
		  /* 821B9854h */ case   29:  		/* mr R4, R29 */
		/* 821B9854h case   29:*/		regs.R4 = regs.R29;
		/* 821B9854h case   29:*/		return 0x821B9858;
		  /* 821B9858h */ case   30:  		/* mr R3, R27 */
		/* 821B9858h case   30:*/		regs.R3 = regs.R27;
		/* 821B9858h case   30:*/		return 0x821B985C;
		  /* 821B985Ch */ case   31:  		/* bl -12732 */
		/* 821B985Ch case   31:*/		regs.LR = 0x821B9860; return 0x821B66A0;
		/* 821B985Ch case   31:*/		return 0x821B9860;
		  /* 821B9860h */ case   32:  		/* li R6, 1 */
		/* 821B9860h case   32:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821B9860h case   32:*/		return 0x821B9864;
		  /* 821B9864h */ case   33:  		/* li R5, 0 */
		/* 821B9864h case   33:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821B9864h case   33:*/		return 0x821B9868;
		  /* 821B9868h */ case   34:  		/* mr R3, R27 */
		/* 821B9868h case   34:*/		regs.R3 = regs.R27;
		/* 821B9868h case   34:*/		return 0x821B986C;
		  /* 821B986Ch */ case   35:  		/* bl 465756 */
		/* 821B986Ch case   35:*/		regs.LR = 0x821B9870; return 0x8222B3C8;
		/* 821B986Ch case   35:*/		return 0x821B9870;
		  /* 821B9870h */ case   36:  		/* mr R5, R31 */
		/* 821B9870h case   36:*/		regs.R5 = regs.R31;
		/* 821B9870h case   36:*/		return 0x821B9874;
	}
	return 0x821B9874;
} // Block from 821B97E0h-821B9874h (37 instructions)

//////////////////////////////////////////////////////
// Block at 821B9874h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9874( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9874) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9874);
		  /* 821B9874h */ case    0:  		/* mr R4, R26 */
		/* 821B9874h case    0:*/		regs.R4 = regs.R26;
		/* 821B9874h case    0:*/		return 0x821B9878;
		  /* 821B9878h */ case    1:  		/* mr R3, R27 */
		/* 821B9878h case    1:*/		regs.R3 = regs.R27;
		/* 821B9878h case    1:*/		return 0x821B987C;
		  /* 821B987Ch */ case    2:  		/* bl -12764 */
		/* 821B987Ch case    2:*/		regs.LR = 0x821B9880; return 0x821B66A0;
		/* 821B987Ch case    2:*/		return 0x821B9880;
	}
	return 0x821B9880;
} // Block from 821B9874h-821B9880h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821B9880h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9880( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9880) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9880);
		  /* 821B9880h */ case    0:  		/* mr R4, R26 */
		/* 821B9880h case    0:*/		regs.R4 = regs.R26;
		/* 821B9880h case    0:*/		return 0x821B9884;
		  /* 821B9884h */ case    1:  		/* mr R3, R27 */
		/* 821B9884h case    1:*/		regs.R3 = regs.R27;
		/* 821B9884h case    1:*/		return 0x821B9888;
		  /* 821B9888h */ case    2:  		/* b -6656 */
		/* 821B9888h case    2:*/		return 0x821B7E88;
		/* 821B9888h case    2:*/		return 0x821B988C;
	}
	return 0x821B988C;
} // Block from 821B9880h-821B988Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 821B988Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B988C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B988C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B988C);
		  /* 821B988Ch */ case    0:  		/* rlwinm R11, R11, 18, 29, 31 */
		/* 821B988Ch case    0:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R11,regs.R11);
		/* 821B988Ch case    0:*/		return 0x821B9890;
		  /* 821B9890h */ case    1:  		/* cmplw CR6, R11, R14 */
		/* 821B9890h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R14);
		/* 821B9890h case    1:*/		return 0x821B9894;
		  /* 821B9894h */ case    2:  		/* bc 4, CR6_GT, 20 */
		/* 821B9894h case    2:*/		if ( !regs.CR[6].gt ) { return 0x821B98A8;  }
		/* 821B9894h case    2:*/		return 0x821B9898;
		  /* 821B9898h */ case    3:  		/* mr R4, R26 */
		/* 821B9898h case    3:*/		regs.R4 = regs.R26;
		/* 821B9898h case    3:*/		return 0x821B989C;
		  /* 821B989Ch */ case    4:  		/* mr R3, R27 */
		/* 821B989Ch case    4:*/		regs.R3 = regs.R27;
		/* 821B989Ch case    4:*/		return 0x821B98A0;
		  /* 821B98A0h */ case    5:  		/* bl -11640 */
		/* 821B98A0h case    5:*/		regs.LR = 0x821B98A4; return 0x821B6B28;
		/* 821B98A0h case    5:*/		return 0x821B98A4;
		  /* 821B98A4h */ case    6:  		/* b -36 */
		/* 821B98A4h case    6:*/		return 0x821B9880;
		/* 821B98A4h case    6:*/		return 0x821B98A8;
	}
	return 0x821B98A8;
} // Block from 821B988Ch-821B98A8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821B98A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B98A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B98A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B98A8);
		  /* 821B98A8h */ case    0:  		/* li R11, 0 */
		/* 821B98A8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821B98A8h case    0:*/		return 0x821B98AC;
		  /* 821B98ACh */ case    1:  		/* cmplwi CR6, R14, 0 */
		/* 821B98ACh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R14,0x00000000);
		/* 821B98ACh case    1:*/		return 0x821B98B0;
		  /* 821B98B0h */ case    2:  		/* stw R11, <#[R26]> */
		/* 821B98B0h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 821B98B0h case    2:*/		return 0x821B98B4;
		  /* 821B98B4h */ case    3:  		/* bc 12, CR6_EQ, 40 */
		/* 821B98B4h case    3:*/		if ( regs.CR[6].eq ) { return 0x821B98DC;  }
		/* 821B98B4h case    3:*/		return 0x821B98B8;
		  /* 821B98B8h */ case    4:  		/* addi R11, R14, 10 */
		/* 821B98B8h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R14,0xA);
		/* 821B98B8h case    4:*/		return 0x821B98BC;
		  /* 821B98BCh */ case    5:  		/* mtspr CTR, R14 */
		/* 821B98BCh case    5:*/		regs.CTR = regs.R14;
		/* 821B98BCh case    5:*/		return 0x821B98C0;
		  /* 821B98C0h */ case    6:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821B98C0h case    6:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821B98C0h case    6:*/		return 0x821B98C4;
		  /* 821B98C4h */ case    7:  		/* lwzx R10, <#[R11 + R26]> */
		/* 821B98C4h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + regs.R26 + 0x00000000) );
		/* 821B98C4h case    7:*/		return 0x821B98C8;
		  /* 821B98C8h */ case    8:  		/* addi R11, R11, -4 */
		/* 821B98C8h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 821B98C8h case    8:*/		return 0x821B98CC;
		  /* 821B98CCh */ case    9:  		/* lwz R9, <#[R26]> */
		/* 821B98CCh case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x00000000) );
		/* 821B98CCh case    9:*/		return 0x821B98D0;
		  /* 821B98D0h */ case   10:  		/* stw R9, <#[R10 + 4]> */
		/* 821B98D0h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 821B98D0h case   10:*/		return 0x821B98D4;
		  /* 821B98D4h */ case   11:  		/* stw R10, <#[R26]> */
		/* 821B98D4h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R26 + 0x00000000) );
		/* 821B98D4h case   11:*/		return 0x821B98D8;
		  /* 821B98D8h */ case   12:  		/* bc 16, CR0_LT, -20 */
		/* 821B98D8h case   12:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x821B98C4;  }
		/* 821B98D8h case   12:*/		return 0x821B98DC;
	}
	return 0x821B98DC;
} // Block from 821B98A8h-821B98DCh (13 instructions)

//////////////////////////////////////////////////////
// Block at 821B98DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B98DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B98DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B98DC);
		  /* 821B98DCh */ case    0:  		/* li R3, 0 */
		/* 821B98DCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821B98DCh case    0:*/		return 0x821B98E0;
	}
	return 0x821B98E0;
} // Block from 821B98DCh-821B98E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B98E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B98E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B98E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B98E0);
		  /* 821B98E0h */ case    0:  		/* addi R1, R1, 416 */
		/* 821B98E0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x1A0);
		/* 821B98E0h case    0:*/		return 0x821B98E4;
		  /* 821B98E4h */ case    1:  		/* lfd FR30, <#[R1 - 168]> */
		/* 821B98E4h case    1:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R1 + 0xFFFFFF58) );
		/* 821B98E4h case    1:*/		return 0x821B98E8;
		  /* 821B98E8h */ case    2:  		/* lfd FR31, <#[R1 - 160]> */
		/* 821B98E8h case    2:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 821B98E8h case    2:*/		return 0x821B98EC;
		  /* 821B98ECh */ case    3:  		/* b -1214076 */
		/* 821B98ECh case    3:*/		return 0x82091270;
		/* 821B98ECh case    3:*/		return 0x821B98F0;
	}
	return 0x821B98F0;
} // Block from 821B98E0h-821B98F0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821B98F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B98F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B98F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B98F0);
		  /* 821B98F0h */ case    0:  		/* mfspr R12, LR */
		/* 821B98F0h case    0:*/		regs.R12 = regs.LR;
		/* 821B98F0h case    0:*/		return 0x821B98F4;
		  /* 821B98F4h */ case    1:  		/* bl -1214164 */
		/* 821B98F4h case    1:*/		regs.LR = 0x821B98F8; return 0x82091220;
		/* 821B98F4h case    1:*/		return 0x821B98F8;
		  /* 821B98F8h */ case    2:  		/* stfd FR31, <#[R1 - 160]> */
		/* 821B98F8h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 821B98F8h case    2:*/		return 0x821B98FC;
		  /* 821B98FCh */ case    3:  		/* stwu R1, <#[R1 - 288]> */
		/* 821B98FCh case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFEE0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFEE0);
		/* 821B98FCh case    3:*/		return 0x821B9900;
		  /* 821B9900h */ case    4:  		/* lis R9, -32256 */
		/* 821B9900h case    4:*/		cpu::op::lis<0>(regs,&regs.R9,0xFFFF8200);
		/* 821B9900h case    4:*/		return 0x821B9904;
		  /* 821B9904h */ case    5:  		/* stw R4, <#[R1 + 316]> */
		/* 821B9904h case    5:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x0000013C) );
		/* 821B9904h case    5:*/		return 0x821B9908;
		  /* 821B9908h */ case    6:  		/* lis R11, -32252 */
		/* 821B9908h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 821B9908h case    6:*/		return 0x821B990C;
		  /* 821B990Ch */ case    7:  		/* lis R10, -32252 */
		/* 821B990Ch case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8204);
		/* 821B990Ch case    7:*/		return 0x821B9910;
		  /* 821B9910h */ case    8:  		/* addi R11, R11, -17164 */
		/* 821B9910h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFBCF4);
		/* 821B9910h case    8:*/		return 0x821B9914;
		  /* 821B9914h */ case    9:  		/* addi R10, R10, -16648 */
		/* 821B9914h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFBEF8);
		/* 821B9914h case    9:*/		return 0x821B9918;
		  /* 821B9918h */ case   10:  		/* lfs FR31, <#[R9 + 1816]> */
		/* 821B9918h case   10:*/		cpu::mem::load32f( regs, &regs.FR31, (uint32)(regs.R9 + 0x00000718) );
		/* 821B9918h case   10:*/		return 0x821B991C;
		  /* 821B991Ch */ case   11:  		/* mr R15, R3 */
		/* 821B991Ch case   11:*/		regs.R15 = regs.R3;
		/* 821B991Ch case   11:*/		return 0x821B9920;
		  /* 821B9920h */ case   12:  		/* mr R23, R4 */
		/* 821B9920h case   12:*/		regs.R23 = regs.R4;
		/* 821B9920h case   12:*/		return 0x821B9924;
		  /* 821B9924h */ case   13:  		/* stw R11, <#[R1 + 84]> */
		/* 821B9924h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 821B9924h case   13:*/		return 0x821B9928;
		  /* 821B9928h */ case   14:  		/* li R21, 1 */
		/* 821B9928h case   14:*/		cpu::op::li<0>(regs,&regs.R21,0x1);
		/* 821B9928h case   14:*/		return 0x821B992C;
		  /* 821B992Ch */ case   15:  		/* stw R10, <#[R1 + 88]> */
		/* 821B992Ch case   15:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x00000058) );
		/* 821B992Ch case   15:*/		return 0x821B9930;
		  /* 821B9930h */ case   16:  		/* li R20, 57 */
		/* 821B9930h case   16:*/		cpu::op::li<0>(regs,&regs.R20,0x39);
		/* 821B9930h case   16:*/		return 0x821B9934;
		  /* 821B9934h */ case   17:  		/* lwz R11, <#[R23 + 20]> */
		/* 821B9934h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000014) );
		/* 821B9934h case   17:*/		return 0x821B9938;
		  /* 821B9938h */ case   18:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821B9938h case   18:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821B9938h case   18:*/		return 0x821B993C;
		  /* 821B993Ch */ case   19:  		/* bc 12, CR0_EQ, 32 */
		/* 821B993Ch case   19:*/		if ( regs.CR[0].eq ) { return 0x821B995C;  }
		/* 821B993Ch case   19:*/		return 0x821B9940;
		  /* 821B9940h */ case   20:  		/* lwz R11, <#[R23 + 28]> */
		/* 821B9940h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x0000001C) );
		/* 821B9940h case   20:*/		return 0x821B9944;
		  /* 821B9944h */ case   21:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821B9944h case   21:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821B9944h case   21:*/		return 0x821B9948;
		  /* 821B9948h */ case   22:  		/* bc 12, CR0_EQ, 12 */
		/* 821B9948h case   22:*/		if ( regs.CR[0].eq ) { return 0x821B9954;  }
		/* 821B9948h case   22:*/		return 0x821B994C;
		  /* 821B994Ch */ case   23:  		/* addi R22, R23, 32 */
		/* 821B994Ch case   23:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R23,0x20);
		/* 821B994Ch case   23:*/		return 0x821B9950;
		  /* 821B9950h */ case   24:  		/* b 16 */
		/* 821B9950h case   24:*/		return 0x821B9960;
		/* 821B9950h case   24:*/		return 0x821B9954;
	}
	return 0x821B9954;
} // Block from 821B98F0h-821B9954h (25 instructions)

//////////////////////////////////////////////////////
// Block at 821B9954h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9954( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9954) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9954);
		  /* 821B9954h */ case    0:  		/* addi R22, R23, 24 */
		/* 821B9954h case    0:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R23,0x18);
		/* 821B9954h case    0:*/		return 0x821B9958;
		  /* 821B9958h */ case    1:  		/* b 8 */
		/* 821B9958h case    1:*/		return 0x821B9960;
		/* 821B9958h case    1:*/		return 0x821B995C;
	}
	return 0x821B995C;
} // Block from 821B9954h-821B995Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B995Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B995C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B995C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B995C);
		  /* 821B995Ch */ case    0:  		/* addi R22, R23, 16 */
		/* 821B995Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R23,0x10);
		/* 821B995Ch case    0:*/		return 0x821B9960;
	}
	return 0x821B9960;
} // Block from 821B995Ch-821B9960h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B9960h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9960( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9960) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9960);
		  /* 821B9960h */ case    0:  		/* lwz R11, <#[R22 + 4]> */
		/* 821B9960h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000004) );
		/* 821B9960h case    0:*/		return 0x821B9964;
		  /* 821B9964h */ case    1:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 821B9964h case    1:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821B9964h case    1:*/		return 0x821B9968;
		  /* 821B9968h */ case    2:  		/* addic R10, R10, -1 */
		/* 821B9968h case    2:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 821B9968h case    2:*/		return 0x821B996C;
		  /* 821B996Ch */ case    3:  		/* subfe R10, R10, R10 */
		/* 821B996Ch case    3:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 821B996Ch case    3:*/		return 0x821B9970;
		  /* 821B9970h */ case    4:  		/* and R16, R10, R11 */
		/* 821B9970h case    4:*/		cpu::op::and<0>(regs,&regs.R16,regs.R10,regs.R11);
		/* 821B9970h case    4:*/		return 0x821B9974;
		  /* 821B9974h */ case    5:  		/* stw R22, <#[R1 + 80]> */
		/* 821B9974h case    5:*/		cpu::mem::store32( regs, regs.R22, (uint32)(regs.R1 + 0x00000050) );
		/* 821B9974h case    5:*/		return 0x821B9978;
		  /* 821B9978h */ case    6:  		/* cmplwi CR6, R16, 0 */
		/* 821B9978h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R16,0x00000000);
		/* 821B9978h case    6:*/		return 0x821B997C;
		  /* 821B997Ch */ case    7:  		/* bc 12, CR6_EQ, 7632 */
		/* 821B997Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x821BB74C;  }
		/* 821B997Ch case    7:*/		return 0x821B9980;
		  /* 821B9980h */ case    8:  		/* lwz R11, <#[R16 + 16]> */
		/* 821B9980h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000010) );
		/* 821B9980h case    8:*/		return 0x821B9984;
		  /* 821B9984h */ case    9:  		/* mr R4, R15 */
		/* 821B9984h case    9:*/		regs.R4 = regs.R15;
		/* 821B9984h case    9:*/		return 0x821B9988;
		  /* 821B9988h */ case   10:  		/* mr R3, R16 */
		/* 821B9988h case   10:*/		regs.R3 = regs.R16;
		/* 821B9988h case   10:*/		return 0x821B998C;
		  /* 821B998Ch */ case   11:  		/* rlwinm R11, R11, 0, 13, 10 */
		/* 821B998Ch case   11:*/		cpu::op::rlwinm<0,0,13,10>(regs,&regs.R11,regs.R11);
		/* 821B998Ch case   11:*/		return 0x821B9990;
		  /* 821B9990h */ case   12:  		/* li R26, 0 */
		/* 821B9990h case   12:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 821B9990h case   12:*/		return 0x821B9994;
		  /* 821B9994h */ case   13:  		/* rlwinm R11, R11, 0, 8, 6 */
		/* 821B9994h case   13:*/		cpu::op::rlwinm<0,0,8,6>(regs,&regs.R11,regs.R11);
		/* 821B9994h case   13:*/		return 0x821B9998;
		  /* 821B9998h */ case   14:  		/* li R25, -1 */
		/* 821B9998h case   14:*/		cpu::op::li<0>(regs,&regs.R25,0xFFFFFFFF);
		/* 821B9998h case   14:*/		return 0x821B999C;
		  /* 821B999Ch */ case   15:  		/* stw R11, <#[R16 + 16]> */
		/* 821B999Ch case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R16 + 0x00000010) );
		/* 821B999Ch case   15:*/		return 0x821B99A0;
		  /* 821B99A0h */ case   16:  		/* bl -142840 */
		/* 821B99A0h case   16:*/		regs.LR = 0x821B99A4; return 0x82196BA8;
		/* 821B99A0h case   16:*/		return 0x821B99A4;
		  /* 821B99A4h */ case   17:  		/* addi R11, R23, 32 */
		/* 821B99A4h case   17:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R23,0x20);
		/* 821B99A4h case   17:*/		return 0x821B99A8;
		  /* 821B99A8h */ case   18:  		/* cmplw CR6, R22, R11 */
		/* 821B99A8h case   18:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R11);
		/* 821B99A8h case   18:*/		return 0x821B99AC;
		  /* 821B99ACh */ case   19:  		/* bc 4, CR6_EQ, 20 */
		/* 821B99ACh case   19:*/		if ( !regs.CR[6].eq ) { return 0x821B99C0;  }
		/* 821B99ACh case   19:*/		return 0x821B99B0;
		  /* 821B99B0h */ case   20:  		/* lwz R11, <#[R16 + 8]> */
		/* 821B99B0h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000008) );
		/* 821B99B0h case   20:*/		return 0x821B99B4;
		  /* 821B99B4h */ case   21:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821B99B4h case   21:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821B99B4h case   21:*/		return 0x821B99B8;
		  /* 821B99B8h */ case   22:  		/* cmplwi CR6, R11, 14848 */
		/* 821B99B8h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003A00);
		/* 821B99B8h case   22:*/		return 0x821B99BC;
		  /* 821B99BCh */ case   23:  		/* bc 4, CR6_EQ, 20 */
		/* 821B99BCh case   23:*/		if ( !regs.CR[6].eq ) { return 0x821B99D0;  }
		/* 821B99BCh case   23:*/		return 0x821B99C0;
	}
	return 0x821B99C0;
} // Block from 821B9960h-821B99C0h (24 instructions)

//////////////////////////////////////////////////////
// Block at 821B99C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B99C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B99C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B99C0);
		  /* 821B99C0h */ case    0:  		/* mr R3, R16 */
		/* 821B99C0h case    0:*/		regs.R3 = regs.R16;
		/* 821B99C0h case    0:*/		return 0x821B99C4;
		  /* 821B99C4h */ case    1:  		/* bl -348228 */
		/* 821B99C4h case    1:*/		regs.LR = 0x821B99C8; return 0x82164980;
		/* 821B99C4h case    1:*/		return 0x821B99C8;
		  /* 821B99C8h */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821B99C8h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821B99C8h case    2:*/		return 0x821B99CC;
		  /* 821B99CCh */ case    3:  		/* bc 4, CR0_EQ, 7384 */
		/* 821B99CCh case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BB6A4;  }
		/* 821B99CCh case    3:*/		return 0x821B99D0;
	}
	return 0x821B99D0;
} // Block from 821B99C0h-821B99D0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821B99D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B99D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B99D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B99D0);
		  /* 821B99D0h */ case    0:  		/* lwz R11, <#[R16 + 8]> */
		/* 821B99D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000008) );
		/* 821B99D0h case    0:*/		return 0x821B99D4;
		  /* 821B99D4h */ case    1:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821B99D4h case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821B99D4h case    1:*/		return 0x821B99D8;
		  /* 821B99D8h */ case    2:  		/* cmplwi CR6, R11, 116 */
		/* 821B99D8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000074);
		/* 821B99D8h case    2:*/		return 0x821B99DC;
		  /* 821B99DCh */ case    3:  		/* bc 4, CR6_EQ, 16 */
		/* 821B99DCh case    3:*/		if ( !regs.CR[6].eq ) { return 0x821B99EC;  }
		/* 821B99DCh case    3:*/		return 0x821B99E0;
		  /* 821B99E0h */ case    4:  		/* lwz R10, <#[R15 + 52]> */
		/* 821B99E0h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R15 + 0x00000034) );
		/* 821B99E0h case    4:*/		return 0x821B99E4;
		  /* 821B99E4h */ case    5:  		/* rlwinm. R10, R10, 0, 13, 13 */
		/* 821B99E4h case    5:*/		cpu::op::rlwinm<1,0,13,13>(regs,&regs.R10,regs.R10);
		/* 821B99E4h case    5:*/		return 0x821B99E8;
		  /* 821B99E8h */ case    6:  		/* bc 4, CR0_EQ, 7084 */
		/* 821B99E8h case    6:*/		if ( !regs.CR[0].eq ) { return 0x821BB594;  }
		/* 821B99E8h case    6:*/		return 0x821B99EC;
	}
	return 0x821B99EC;
} // Block from 821B99D0h-821B99ECh (7 instructions)

//////////////////////////////////////////////////////
// Block at 821B99ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B99EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B99EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B99EC);
		  /* 821B99ECh */ case    0:  		/* cmplwi CR6, R11, 104 */
		/* 821B99ECh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000068);
		/* 821B99ECh case    0:*/		return 0x821B99F0;
		  /* 821B99F0h */ case    1:  		/* bc 4, CR6_EQ, 124 */
		/* 821B99F0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821B9A6C;  }
		/* 821B99F0h case    1:*/		return 0x821B99F4;
		  /* 821B99F4h */ case    2:  		/* lwz R11, <#[R16 + 4]> */
		/* 821B99F4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000004) );
		/* 821B99F4h case    2:*/		return 0x821B99F8;
		  /* 821B99F8h */ case    3:  		/* cmpwi CR6, R11, 0 */
		/* 821B99F8h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 821B99F8h case    3:*/		return 0x821B99FC;
		  /* 821B99FCh */ case    4:  		/* bc 4, CR6_EQ, 112 */
		/* 821B99FCh case    4:*/		if ( !regs.CR[6].eq ) { return 0x821B9A6C;  }
		/* 821B99FCh case    4:*/		return 0x821B9A00;
		  /* 821B9A00h */ case    5:  		/* li R7, 0 */
		/* 821B9A00h case    5:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821B9A00h case    5:*/		return 0x821B9A04;
		  /* 821B9A04h */ case    6:  		/* lwz R3, <#[R16 + 44]> */
		/* 821B9A04h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R16 + 0x0000002C) );
		/* 821B9A04h case    6:*/		return 0x821B9A08;
		  /* 821B9A08h */ case    7:  		/* addi R6, R1, 100 */
		/* 821B9A08h case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x64);
		/* 821B9A08h case    7:*/		return 0x821B9A0C;
		  /* 821B9A0Ch */ case    8:  		/* addi R5, R1, 104 */
		/* 821B9A0Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x68);
		/* 821B9A0Ch case    8:*/		return 0x821B9A10;
		  /* 821B9A10h */ case    9:  		/* addi R4, R1, 92 */
		/* 821B9A10h case    9:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x5C);
		/* 821B9A10h case    9:*/		return 0x821B9A14;
		  /* 821B9A14h */ case   10:  		/* bl 480540 */
		/* 821B9A14h case   10:*/		regs.LR = 0x821B9A18; return 0x8222EF30;
		/* 821B9A14h case   10:*/		return 0x821B9A18;
		  /* 821B9A18h */ case   11:  		/* lwz R31, <#[R1 + 92]> */
		/* 821B9A18h case   11:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x0000005C) );
		/* 821B9A18h case   11:*/		return 0x821B9A1C;
		  /* 821B9A1Ch */ case   12:  		/* lwz R11, <#[R31 + 8]> */
		/* 821B9A1Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821B9A1Ch case   12:*/		return 0x821B9A20;
		  /* 821B9A20h */ case   13:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821B9A20h case   13:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821B9A20h case   13:*/		return 0x821B9A24;
		  /* 821B9A24h */ case   14:  		/* cmplwi CR6, R11, 15872 */
		/* 821B9A24h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E00);
		/* 821B9A24h case   14:*/		return 0x821B9A28;
		  /* 821B9A28h */ case   15:  		/* bc 4, CR6_EQ, 68 */
		/* 821B9A28h case   15:*/		if ( !regs.CR[6].eq ) { return 0x821B9A6C;  }
		/* 821B9A28h case   15:*/		return 0x821B9A2C;
		  /* 821B9A2Ch */ case   16:  		/* lwz R11, <#[R31 + 8]> */
		/* 821B9A2Ch case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821B9A2Ch case   16:*/		return 0x821B9A30;
		  /* 821B9A30h */ case   17:  		/* mr R3, R15 */
		/* 821B9A30h case   17:*/		regs.R3 = regs.R15;
		/* 821B9A30h case   17:*/		return 0x821B9A34;
		  /* 821B9A34h */ case   18:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 821B9A34h case   18:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 821B9A34h case   18:*/		return 0x821B9A38;
		  /* 821B9A38h */ case   19:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 821B9A38h case   19:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 821B9A38h case   19:*/		return 0x821B9A3C;
		  /* 821B9A3Ch */ case   20:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 821B9A3Ch case   20:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 821B9A3Ch case   20:*/		return 0x821B9A40;
		  /* 821B9A40h */ case   21:  		/* bl -349712 */
		/* 821B9A40h case   21:*/		regs.LR = 0x821B9A44; return 0x82164430;
		/* 821B9A40h case   21:*/		return 0x821B9A44;
		  /* 821B9A44h */ case   22:  		/* addi R10, R31, -8 */
		/* 821B9A44h case   22:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0xFFFFFFF8);
		/* 821B9A44h case   22:*/		return 0x821B9A48;
		  /* 821B9A48h */ case   23:  		/* lwz R11, <#[R15 + 12]> */
		/* 821B9A48h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x0000000C) );
		/* 821B9A48h case   23:*/		return 0x821B9A4C;
		  /* 821B9A4Ch */ case   24:  		/* lwzx R10, <#[R3 + R10]> */
		/* 821B9A4Ch case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + regs.R10 + 0x00000000) );
		/* 821B9A4Ch case   24:*/		return 0x821B9A50;
		  /* 821B9A50h */ case   25:  		/* rlwinm R10, R10, 0, 17, 31 */
		/* 821B9A50h case   25:*/		cpu::op::rlwinm<0,0,17,31>(regs,&regs.R10,regs.R10);
		/* 821B9A50h case   25:*/		return 0x821B9A54;
		  /* 821B9A54h */ case   26:  		/* mulli R10, R10, 40 */
		/* 821B9A54h case   26:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x28);
		/* 821B9A54h case   26:*/		return 0x821B9A58;
		  /* 821B9A58h */ case   27:  		/* add R11, R10, R11 */
		/* 821B9A58h case   27:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821B9A58h case   27:*/		return 0x821B9A5C;
		  /* 821B9A5Ch */ case   28:  		/* lwz R11, <#[R11 + 4]> */
		/* 821B9A5Ch case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821B9A5Ch case   28:*/		return 0x821B9A60;
		  /* 821B9A60h */ case   29:  		/* rlwinm R11, R11, 0, 25, 27 */
		/* 821B9A60h case   29:*/		cpu::op::rlwinm<0,0,25,27>(regs,&regs.R11,regs.R11);
		/* 821B9A60h case   29:*/		return 0x821B9A64;
		  /* 821B9A64h */ case   30:  		/* cmplwi CR6, R11, 48 */
		/* 821B9A64h case   30:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000030);
		/* 821B9A64h case   30:*/		return 0x821B9A68;
		  /* 821B9A68h */ case   31:  		/* bc 12, CR6_EQ, 7216 */
		/* 821B9A68h case   31:*/		if ( regs.CR[6].eq ) { return 0x821BB698;  }
		/* 821B9A68h case   31:*/		return 0x821B9A6C;
	}
	return 0x821B9A6C;
} // Block from 821B99ECh-821B9A6Ch (32 instructions)

//////////////////////////////////////////////////////
// Block at 821B9A6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9A6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9A6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9A6C);
		  /* 821B9A6Ch */ case    0:  		/* lwz R27, <#[R16 + 8]> */
		/* 821B9A6Ch case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R16 + 0x00000008) );
		/* 821B9A6Ch case    0:*/		return 0x821B9A70;
		  /* 821B9A70h */ case    1:  		/* rlwinm R29, R27, 25, 25, 31 */
		/* 821B9A70h case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R29,regs.R27);
		/* 821B9A70h case    1:*/		return 0x821B9A74;
		  /* 821B9A74h */ case    2:  		/* cmplwi CR6, R29, 112 */
		/* 821B9A74h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000070);
		/* 821B9A74h case    2:*/		return 0x821B9A78;
		  /* 821B9A78h */ case    3:  		/* bc 12, CR6_EQ, 324 */
		/* 821B9A78h case    3:*/		if ( regs.CR[6].eq ) { return 0x821B9BBC;  }
		/* 821B9A78h case    3:*/		return 0x821B9A7C;
		  /* 821B9A7Ch */ case    4:  		/* li R28, 0 */
		/* 821B9A7Ch case    4:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 821B9A7Ch case    4:*/		return 0x821B9A80;
		  /* 821B9A80h */ case    5:  		/* mr R30, R16 */
		/* 821B9A80h case    5:*/		regs.R30 = regs.R16;
		/* 821B9A80h case    5:*/		return 0x821B9A84;
		  /* 821B9A84h */ case    6:  		/* lwz R31, <#[R30]> */
		/* 821B9A84h case    6:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000000) );
		/* 821B9A84h case    6:*/		return 0x821B9A88;
		  /* 821B9A88h */ case    7:  		/* cmplwi CR6, R31, 0 */
		/* 821B9A88h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821B9A88h case    7:*/		return 0x821B9A8C;
		  /* 821B9A8Ch */ case    8:  		/* bc 12, CR6_EQ, 132 */
		/* 821B9A8Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x821B9B10;  }
		/* 821B9A8Ch case    8:*/		return 0x821B9A90;
		  /* 821B9A90h */ case    9:  		/* lwz R11, <#[R31]> */
		/* 821B9A90h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821B9A90h case    9:*/		return 0x821B9A94;
		  /* 821B9A94h */ case   10:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 821B9A94h case   10:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 821B9A94h case   10:*/		return 0x821B9A98;
		  /* 821B9A98h */ case   11:  		/* bc 12, CR0_EQ, 100 */
		/* 821B9A98h case   11:*/		if ( regs.CR[0].eq ) { return 0x821B9AFC;  }
		/* 821B9A98h case   11:*/		return 0x821B9A9C;
		  /* 821B9A9Ch */ case   12:  		/* lwz R10, <#[R31 + 12]> */
		/* 821B9A9Ch case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 821B9A9Ch case   12:*/		return 0x821B9AA0;
		  /* 821B9AA0h */ case   13:  		/* lwz R11, <#[R10 + 8]> */
		/* 821B9AA0h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 821B9AA0h case   13:*/		return 0x821B9AA4;
		  /* 821B9AA4h */ case   14:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821B9AA4h case   14:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821B9AA4h case   14:*/		return 0x821B9AA8;
		  /* 821B9AA8h */ case   15:  		/* cmplwi CR6, R11, 125 */
		/* 821B9AA8h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 821B9AA8h case   15:*/		return 0x821B9AAC;
		  /* 821B9AACh */ case   16:  		/* bc 12, CR6_EQ, 16 */
		/* 821B9AACh case   16:*/		if ( regs.CR[6].eq ) { return 0x821B9ABC;  }
		/* 821B9AACh case   16:*/		return 0x821B9AB0;
		  /* 821B9AB0h */ case   17:  		/* cmplwi CR6, R11, 124 */
		/* 821B9AB0h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 821B9AB0h case   17:*/		return 0x821B9AB4;
		  /* 821B9AB4h */ case   18:  		/* li R11, 0 */
		/* 821B9AB4h case   18:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821B9AB4h case   18:*/		return 0x821B9AB8;
		  /* 821B9AB8h */ case   19:  		/* bc 4, CR6_EQ, 8 */
		/* 821B9AB8h case   19:*/		if ( !regs.CR[6].eq ) { return 0x821B9AC0;  }
		/* 821B9AB8h case   19:*/		return 0x821B9ABC;
	}
	return 0x821B9ABC;
} // Block from 821B9A6Ch-821B9ABCh (20 instructions)

//////////////////////////////////////////////////////
// Block at 821B9ABCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9ABC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9ABC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9ABC);
		  /* 821B9ABCh */ case    0:  		/* mr R11, R21 */
		/* 821B9ABCh case    0:*/		regs.R11 = regs.R21;
		/* 821B9ABCh case    0:*/		return 0x821B9AC0;
	}
	return 0x821B9AC0;
} // Block from 821B9ABCh-821B9AC0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B9AC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9AC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9AC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9AC0);
		  /* 821B9AC0h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821B9AC0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821B9AC0h case    0:*/		return 0x821B9AC4;
		  /* 821B9AC4h */ case    1:  		/* bc 4, CR0_EQ, 56 */
		/* 821B9AC4h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821B9AFC;  }
		/* 821B9AC4h case    1:*/		return 0x821B9AC8;
		  /* 821B9AC8h */ case    2:  		/* lwz R11, <#[R10 + 28]> */
		/* 821B9AC8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000001C) );
		/* 821B9AC8h case    2:*/		return 0x821B9ACC;
		  /* 821B9ACCh */ case    3:  		/* cmplw CR6, R11, R23 */
		/* 821B9ACCh case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R23);
		/* 821B9ACCh case    3:*/		return 0x821B9AD0;
		  /* 821B9AD0h */ case    4:  		/* bc 12, CR6_EQ, 44 */
		/* 821B9AD0h case    4:*/		if ( regs.CR[6].eq ) { return 0x821B9AFC;  }
		/* 821B9AD0h case    4:*/		return 0x821B9AD4;
		  /* 821B9AD4h */ case    5:  		/* li R5, 1 */
		/* 821B9AD4h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 821B9AD4h case    5:*/		return 0x821B9AD8;
		  /* 821B9AD8h */ case    6:  		/* mr R4, R31 */
		/* 821B9AD8h case    6:*/		regs.R4 = regs.R31;
		/* 821B9AD8h case    6:*/		return 0x821B9ADC;
		  /* 821B9ADCh */ case    7:  		/* mr R3, R15 */
		/* 821B9ADCh case    7:*/		regs.R3 = regs.R15;
		/* 821B9ADCh case    7:*/		return 0x821B9AE0;
		  /* 821B9AE0h */ case    8:  		/* bl -9416 */
		/* 821B9AE0h case    8:*/		regs.LR = 0x821B9AE4; return 0x821B7618;
		/* 821B9AE0h case    8:*/		return 0x821B9AE4;
		  /* 821B9AE4h */ case    9:  		/* lwz R11, <#[R3 + 8]> */
		/* 821B9AE4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821B9AE4h case    9:*/		return 0x821B9AE8;
		  /* 821B9AE8h */ case   10:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821B9AE8h case   10:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821B9AE8h case   10:*/		return 0x821B9AEC;
		  /* 821B9AECh */ case   11:  		/* addi R11, R11, -14080 */
		/* 821B9AECh case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFC900);
		/* 821B9AECh case   11:*/		return 0x821B9AF0;
		  /* 821B9AF0h */ case   12:  		/* cntlzw R11, R11 */
		/* 821B9AF0h case   12:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 821B9AF0h case   12:*/		return 0x821B9AF4;
		  /* 821B9AF4h */ case   13:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 821B9AF4h case   13:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 821B9AF4h case   13:*/		return 0x821B9AF8;
		  /* 821B9AF8h */ case   14:  		/* or R28, R11, R28 */
		/* 821B9AF8h case   14:*/		cpu::op::or<0>(regs,&regs.R28,regs.R11,regs.R28);
		/* 821B9AF8h case   14:*/		return 0x821B9AFC;
	}
	return 0x821B9AFC;
} // Block from 821B9AC0h-821B9AFCh (15 instructions)

//////////////////////////////////////////////////////
// Block at 821B9AFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9AFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9AFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9AFC);
		  /* 821B9AFCh */ case    0:  		/* lwz R11, <#[R30]> */
		/* 821B9AFCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821B9AFCh case    0:*/		return 0x821B9B00;
		  /* 821B9B00h */ case    1:  		/* cmplw CR6, R11, R31 */
		/* 821B9B00h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 821B9B00h case    1:*/		return 0x821B9B04;
		  /* 821B9B04h */ case    2:  		/* bc 4, CR6_EQ, -128 */
		/* 821B9B04h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821B9A84;  }
		/* 821B9B04h case    2:*/		return 0x821B9B08;
		  /* 821B9B08h */ case    3:  		/* addi R30, R31, 4 */
		/* 821B9B08h case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x4);
		/* 821B9B08h case    3:*/		return 0x821B9B0C;
		  /* 821B9B0Ch */ case    4:  		/* b -136 */
		/* 821B9B0Ch case    4:*/		return 0x821B9A84;
		/* 821B9B0Ch case    4:*/		return 0x821B9B10;
	}
	return 0x821B9B10;
} // Block from 821B9AFCh-821B9B10h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821B9B10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9B10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9B10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9B10);
		  /* 821B9B10h */ case    0:  		/* lwz R27, <#[R16 + 8]> */
		/* 821B9B10h case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R16 + 0x00000008) );
		/* 821B9B10h case    0:*/		return 0x821B9B14;
		  /* 821B9B14h */ case    1:  		/* rlwinm R29, R27, 25, 25, 31 */
		/* 821B9B14h case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R29,regs.R27);
		/* 821B9B14h case    1:*/		return 0x821B9B18;
		  /* 821B9B18h */ case    2:  		/* cmplwi CR6, R29, 125 */
		/* 821B9B18h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x0000007D);
		/* 821B9B18h case    2:*/		return 0x821B9B1C;
		  /* 821B9B1Ch */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 821B9B1Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x821B9B2C;  }
		/* 821B9B1Ch case    3:*/		return 0x821B9B20;
		  /* 821B9B20h */ case    4:  		/* cmplwi CR6, R29, 124 */
		/* 821B9B20h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x0000007C);
		/* 821B9B20h case    4:*/		return 0x821B9B24;
		  /* 821B9B24h */ case    5:  		/* li R11, 0 */
		/* 821B9B24h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821B9B24h case    5:*/		return 0x821B9B28;
		  /* 821B9B28h */ case    6:  		/* bc 4, CR6_EQ, 8 */
		/* 821B9B28h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821B9B30;  }
		/* 821B9B28h case    6:*/		return 0x821B9B2C;
	}
	return 0x821B9B2C;
} // Block from 821B9B10h-821B9B2Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 821B9B2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9B2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9B2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9B2C);
		  /* 821B9B2Ch */ case    0:  		/* mr R11, R21 */
		/* 821B9B2Ch case    0:*/		regs.R11 = regs.R21;
		/* 821B9B2Ch case    0:*/		return 0x821B9B30;
	}
	return 0x821B9B30;
} // Block from 821B9B2Ch-821B9B30h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B9B30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9B30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9B30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9B30);
		  /* 821B9B30h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821B9B30h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821B9B30h case    0:*/		return 0x821B9B34;
		  /* 821B9B34h */ case    1:  		/* bc 4, CR0_EQ, 128 */
		/* 821B9B34h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821B9BB4;  }
		/* 821B9B34h case    1:*/		return 0x821B9B38;
		  /* 821B9B38h */ case    2:  		/* addi R30, R16, 4 */
		/* 821B9B38h case    2:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R16,0x4);
		/* 821B9B38h case    2:*/		return 0x821B9B3C;
		  /* 821B9B3Ch */ case    3:  		/* lwz R31, <#[R30]> */
		/* 821B9B3Ch case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000000) );
		/* 821B9B3Ch case    3:*/		return 0x821B9B40;
		  /* 821B9B40h */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 821B9B40h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821B9B40h case    4:*/		return 0x821B9B44;
		  /* 821B9B44h */ case    5:  		/* bc 12, CR6_EQ, 112 */
		/* 821B9B44h case    5:*/		if ( regs.CR[6].eq ) { return 0x821B9BB4;  }
		/* 821B9B44h case    5:*/		return 0x821B9B48;
		  /* 821B9B48h */ case    6:  		/* lwz R11, <#[R31 + 16]> */
		/* 821B9B48h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 821B9B48h case    6:*/		return 0x821B9B4C;
		  /* 821B9B4Ch */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 821B9B4Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821B9B4Ch case    7:*/		return 0x821B9B50;
		  /* 821B9B50h */ case    8:  		/* bc 12, CR6_EQ, 80 */
		/* 821B9B50h case    8:*/		if ( regs.CR[6].eq ) { return 0x821B9BA0;  }
		/* 821B9B50h case    8:*/		return 0x821B9B54;
		  /* 821B9B54h */ case    9:  		/* lwz R10, <#[R31]> */
		/* 821B9B54h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 821B9B54h case    9:*/		return 0x821B9B58;
		  /* 821B9B58h */ case   10:  		/* rlwinm. R10, R10, 0, 4, 6 */
		/* 821B9B58h case   10:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R10);
		/* 821B9B58h case   10:*/		return 0x821B9B5C;
		  /* 821B9B5Ch */ case   11:  		/* bc 12, CR0_EQ, 68 */
		/* 821B9B5Ch case   11:*/		if ( regs.CR[0].eq ) { return 0x821B9BA0;  }
		/* 821B9B5Ch case   11:*/		return 0x821B9B60;
		  /* 821B9B60h */ case   12:  		/* lwz R10, <#[R11 + 28]> */
		/* 821B9B60h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000001C) );
		/* 821B9B60h case   12:*/		return 0x821B9B64;
		  /* 821B9B64h */ case   13:  		/* cmplw CR6, R10, R23 */
		/* 821B9B64h case   13:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R23);
		/* 821B9B64h case   13:*/		return 0x821B9B68;
		  /* 821B9B68h */ case   14:  		/* bc 12, CR6_EQ, 56 */
		/* 821B9B68h case   14:*/		if ( regs.CR[6].eq ) { return 0x821B9BA0;  }
		/* 821B9B68h case   14:*/		return 0x821B9B6C;
		  /* 821B9B6Ch */ case   15:  		/* lwz R11, <#[R11 + 8]> */
		/* 821B9B6Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821B9B6Ch case   15:*/		return 0x821B9B70;
		  /* 821B9B70h */ case   16:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821B9B70h case   16:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821B9B70h case   16:*/		return 0x821B9B74;
		  /* 821B9B74h */ case   17:  		/* cmplwi CR6, R11, 14336 */
		/* 821B9B74h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003800);
		/* 821B9B74h case   17:*/		return 0x821B9B78;
		  /* 821B9B78h */ case   18:  		/* bc 12, CR6_EQ, 40 */
		/* 821B9B78h case   18:*/		if ( regs.CR[6].eq ) { return 0x821B9BA0;  }
		/* 821B9B78h case   18:*/		return 0x821B9B7C;
		  /* 821B9B7Ch */ case   19:  		/* li R5, 1 */
		/* 821B9B7Ch case   19:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 821B9B7Ch case   19:*/		return 0x821B9B80;
		  /* 821B9B80h */ case   20:  		/* mr R4, R31 */
		/* 821B9B80h case   20:*/		regs.R4 = regs.R31;
		/* 821B9B80h case   20:*/		return 0x821B9B84;
		  /* 821B9B84h */ case   21:  		/* mr R3, R15 */
		/* 821B9B84h case   21:*/		regs.R3 = regs.R15;
		/* 821B9B84h case   21:*/		return 0x821B9B88;
		  /* 821B9B88h */ case   22:  		/* bl -9584 */
		/* 821B9B88h case   22:*/		regs.LR = 0x821B9B8C; return 0x821B7618;
		/* 821B9B88h case   22:*/		return 0x821B9B8C;
		  /* 821B9B8Ch */ case   23:  		/* lwz R27, <#[R16 + 8]> */
		/* 821B9B8Ch case   23:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R16 + 0x00000008) );
		/* 821B9B8Ch case   23:*/		return 0x821B9B90;
		  /* 821B9B90h */ case   24:  		/* rlwinm R29, R27, 25, 25, 31 */
		/* 821B9B90h case   24:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R29,regs.R27);
		/* 821B9B90h case   24:*/		return 0x821B9B94;
		  /* 821B9B94h */ case   25:  		/* cmplwi CR6, R29, 110 */
		/* 821B9B94h case   25:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x0000006E);
		/* 821B9B94h case   25:*/		return 0x821B9B98;
		  /* 821B9B98h */ case   26:  		/* bc 4, CR6_EQ, 8 */
		/* 821B9B98h case   26:*/		if ( !regs.CR[6].eq ) { return 0x821B9BA0;  }
		/* 821B9B98h case   26:*/		return 0x821B9B9C;
		  /* 821B9B9Ch */ case   27:  		/* mr R28, R21 */
		/* 821B9B9Ch case   27:*/		regs.R28 = regs.R21;
		/* 821B9B9Ch case   27:*/		return 0x821B9BA0;
	}
	return 0x821B9BA0;
} // Block from 821B9B30h-821B9BA0h (28 instructions)

//////////////////////////////////////////////////////
// Block at 821B9BA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9BA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9BA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9BA0);
		  /* 821B9BA0h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 821B9BA0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821B9BA0h case    0:*/		return 0x821B9BA4;
		  /* 821B9BA4h */ case    1:  		/* cmplw CR6, R11, R31 */
		/* 821B9BA4h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 821B9BA4h case    1:*/		return 0x821B9BA8;
		  /* 821B9BA8h */ case    2:  		/* bc 4, CR6_EQ, -108 */
		/* 821B9BA8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821B9B3C;  }
		/* 821B9BA8h case    2:*/		return 0x821B9BAC;
		  /* 821B9BACh */ case    3:  		/* addi R30, R31, 8 */
		/* 821B9BACh case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x8);
		/* 821B9BACh case    3:*/		return 0x821B9BB0;
		  /* 821B9BB0h */ case    4:  		/* b -116 */
		/* 821B9BB0h case    4:*/		return 0x821B9B3C;
		/* 821B9BB0h case    4:*/		return 0x821B9BB4;
	}
	return 0x821B9BB4;
} // Block from 821B9BA0h-821B9BB4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821B9BB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9BB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9BB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9BB4);
		  /* 821B9BB4h */ case    0:  		/* rlwinm. R11, R28, 0, 24, 31 */
		/* 821B9BB4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R28);
		/* 821B9BB4h case    0:*/		return 0x821B9BB8;
		  /* 821B9BB8h */ case    1:  		/* bc 4, CR0_EQ, -644 */
		/* 821B9BB8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821B9934;  }
		/* 821B9BB8h case    1:*/		return 0x821B9BBC;
	}
	return 0x821B9BBC;
} // Block from 821B9BB4h-821B9BBCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B9BBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9BBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9BBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9BBC);
		  /* 821B9BBCh */ case    0:  		/* lwz R24, <#[R16 + 4]> */
		/* 821B9BBCh case    0:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R16 + 0x00000004) );
		/* 821B9BBCh case    0:*/		return 0x821B9BC0;
		  /* 821B9BC0h */ case    1:  		/* addi R14, R16, 4 */
		/* 821B9BC0h case    1:*/		cpu::op::addi<0>(regs,&regs.R14,regs.R16,0x4);
		/* 821B9BC0h case    1:*/		return 0x821B9BC4;
		  /* 821B9BC4h */ case    2:  		/* mr R11, R24 */
		/* 821B9BC4h case    2:*/		regs.R11 = regs.R24;
		/* 821B9BC4h case    2:*/		return 0x821B9BC8;
		  /* 821B9BC8h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 821B9BC8h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821B9BC8h case    3:*/		return 0x821B9BCC;
		  /* 821B9BCCh */ case    4:  		/* bc 12, CR6_EQ, 48 */
		/* 821B9BCCh case    4:*/		if ( regs.CR[6].eq ) { return 0x821B9BFC;  }
		/* 821B9BCCh case    4:*/		return 0x821B9BD0;
		  /* 821B9BD0h */ case    5:  		/* lwz R10, <#[R11 + 16]> */
		/* 821B9BD0h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 821B9BD0h case    5:*/		return 0x821B9BD4;
		  /* 821B9BD4h */ case    6:  		/* cmplwi CR6, R10, 0 */
		/* 821B9BD4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821B9BD4h case    6:*/		return 0x821B9BD8;
		  /* 821B9BD8h */ case    7:  		/* bc 12, CR6_EQ, 28 */
		/* 821B9BD8h case    7:*/		if ( regs.CR[6].eq ) { return 0x821B9BF4;  }
		/* 821B9BD8h case    7:*/		return 0x821B9BDC;
		  /* 821B9BDCh */ case    8:  		/* lwz R10, <#[R11]> */
		/* 821B9BDCh case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821B9BDCh case    8:*/		return 0x821B9BE0;
		  /* 821B9BE0h */ case    9:  		/* rlwinm. R9, R10, 0, 4, 6 */
		/* 821B9BE0h case    9:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R9,regs.R10);
		/* 821B9BE0h case    9:*/		return 0x821B9BE4;
		  /* 821B9BE4h */ case   10:  		/* bc 12, CR0_EQ, 16 */
		/* 821B9BE4h case   10:*/		if ( regs.CR[0].eq ) { return 0x821B9BF4;  }
		/* 821B9BE4h case   10:*/		return 0x821B9BE8;
		  /* 821B9BE8h */ case   11:  		/* rlwinm R10, R10, 0, 27, 31 */
		/* 821B9BE8h case   11:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R10);
		/* 821B9BE8h case   11:*/		return 0x821B9BEC;
		  /* 821B9BECh */ case   12:  		/* or R26, R10, R26 */
		/* 821B9BECh case   12:*/		cpu::op::or<0>(regs,&regs.R26,regs.R10,regs.R26);
		/* 821B9BECh case   12:*/		return 0x821B9BF0;
		  /* 821B9BF0h */ case   13:  		/* and R25, R10, R25 */
		/* 821B9BF0h case   13:*/		cpu::op::and<0>(regs,&regs.R25,regs.R10,regs.R25);
		/* 821B9BF0h case   13:*/		return 0x821B9BF4;
	}
	return 0x821B9BF4;
} // Block from 821B9BBCh-821B9BF4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821B9BF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9BF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9BF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9BF4);
		  /* 821B9BF4h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 821B9BF4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821B9BF4h case    0:*/		return 0x821B9BF8;
		  /* 821B9BF8h */ case    1:  		/* b -48 */
		/* 821B9BF8h case    1:*/		return 0x821B9BC8;
		/* 821B9BF8h case    1:*/		return 0x821B9BFC;
	}
	return 0x821B9BFC;
} // Block from 821B9BF4h-821B9BFCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B9BFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9BFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9BFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9BFC);
		  /* 821B9BFCh */ case    0:  		/* rlwinm. R11, R26, 0, 27, 27 */
		/* 821B9BFCh case    0:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R26);
		/* 821B9BFCh case    0:*/		return 0x821B9C00;
		  /* 821B9C00h */ case    1:  		/* bc 12, CR0_EQ, 36 */
		/* 821B9C00h case    1:*/		if ( regs.CR[0].eq ) { return 0x821B9C24;  }
		/* 821B9C00h case    1:*/		return 0x821B9C04;
		  /* 821B9C04h */ case    2:  		/* cmplwi CR6, R29, 125 */
		/* 821B9C04h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x0000007D);
		/* 821B9C04h case    2:*/		return 0x821B9C08;
		  /* 821B9C08h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 821B9C08h case    3:*/		if ( regs.CR[6].eq ) { return 0x821B9C18;  }
		/* 821B9C08h case    3:*/		return 0x821B9C0C;
		  /* 821B9C0Ch */ case    4:  		/* cmplwi CR6, R29, 124 */
		/* 821B9C0Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x0000007C);
		/* 821B9C0Ch case    4:*/		return 0x821B9C10;
		  /* 821B9C10h */ case    5:  		/* li R11, 0 */
		/* 821B9C10h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821B9C10h case    5:*/		return 0x821B9C14;
		  /* 821B9C14h */ case    6:  		/* bc 4, CR6_EQ, 8 */
		/* 821B9C14h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821B9C1C;  }
		/* 821B9C14h case    6:*/		return 0x821B9C18;
	}
	return 0x821B9C18;
} // Block from 821B9BFCh-821B9C18h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821B9C18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9C18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9C18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9C18);
		  /* 821B9C18h */ case    0:  		/* mr R11, R21 */
		/* 821B9C18h case    0:*/		regs.R11 = regs.R21;
		/* 821B9C18h case    0:*/		return 0x821B9C1C;
	}
	return 0x821B9C1C;
} // Block from 821B9C18h-821B9C1Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B9C1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9C1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9C1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9C1C);
		  /* 821B9C1Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821B9C1Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821B9C1Ch case    0:*/		return 0x821B9C20;
		  /* 821B9C20h */ case    1:  		/* bc 12, CR0_EQ, 6924 */
		/* 821B9C20h case    1:*/		if ( regs.CR[0].eq ) { return 0x821BB72C;  }
		/* 821B9C20h case    1:*/		return 0x821B9C24;
	}
	return 0x821B9C24;
} // Block from 821B9C1Ch-821B9C24h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B9C24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9C24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9C24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9C24);
		  /* 821B9C24h */ case    0:  		/* rlwinm. R11, R26, 0, 31, 31 */
		/* 821B9C24h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R26);
		/* 821B9C24h case    0:*/		return 0x821B9C28;
		  /* 821B9C28h */ case    1:  		/* bc 12, CR0_EQ, 1916 */
		/* 821B9C28h case    1:*/		if ( regs.CR[0].eq ) { return 0x821BA3A4;  }
		/* 821B9C28h case    1:*/		return 0x821B9C2C;
		  /* 821B9C2Ch */ case    2:  		/* rlwinm R10, R25, 0, 31, 31 */
		/* 821B9C2Ch case    2:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R25);
		/* 821B9C2Ch case    2:*/		return 0x821B9C30;
		  /* 821B9C30h */ case    3:  		/* li R28, 0 */
		/* 821B9C30h case    3:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 821B9C30h case    3:*/		return 0x821B9C34;
		  /* 821B9C34h */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 821B9C34h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821B9C34h case    4:*/		return 0x821B9C38;
		  /* 821B9C38h */ case    5:  		/* bc 4, CR6_EQ, 196 */
		/* 821B9C38h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821B9CFC;  }
		/* 821B9C38h case    5:*/		return 0x821B9C3C;
		  /* 821B9C3Ch */ case    6:  		/* mr R3, R16 */
		/* 821B9C3Ch case    6:*/		regs.R3 = regs.R16;
		/* 821B9C3Ch case    6:*/		return 0x821B9C40;
		  /* 821B9C40h */ case    7:  		/* bl -146152 */
		/* 821B9C40h case    7:*/		regs.LR = 0x821B9C44; return 0x82196158;
		/* 821B9C40h case    7:*/		return 0x821B9C44;
		  /* 821B9C44h */ case    8:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821B9C44h case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821B9C44h case    8:*/		return 0x821B9C48;
		  /* 821B9C48h */ case    9:  		/* bc 4, CR0_EQ, 184 */
		/* 821B9C48h case    9:*/		if ( !regs.CR[0].eq ) { return 0x821B9D00;  }
		/* 821B9C48h case    9:*/		return 0x821B9C4C;
		  /* 821B9C4Ch */ case   10:  		/* cmplwi CR6, R29, 112 */
		/* 821B9C4Ch case   10:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000070);
		/* 821B9C4Ch case   10:*/		return 0x821B9C50;
		  /* 821B9C50h */ case   11:  		/* bc 12, CR6_EQ, 12 */
		/* 821B9C50h case   11:*/		if ( regs.CR[6].eq ) { return 0x821B9C5C;  }
		/* 821B9C50h case   11:*/		return 0x821B9C54;
		  /* 821B9C54h */ case   12:  		/* cmplwi CR6, R29, 110 */
		/* 821B9C54h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x0000006E);
		/* 821B9C54h case   12:*/		return 0x821B9C58;
		  /* 821B9C58h */ case   13:  		/* bc 4, CR6_EQ, 164 */
		/* 821B9C58h case   13:*/		if ( !regs.CR[6].eq ) { return 0x821B9CFC;  }
		/* 821B9C58h case   13:*/		return 0x821B9C5C;
	}
	return 0x821B9C5C;
} // Block from 821B9C24h-821B9C5Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 821B9C5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9C5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9C5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9C5C);
		  /* 821B9C5Ch */ case    0:  		/* lwz R29, <#[R16]> */
		/* 821B9C5Ch case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R16 + 0x00000000) );
		/* 821B9C5Ch case    0:*/		return 0x821B9C60;
		  /* 821B9C60h */ case    1:  		/* cmplwi CR6, R29, 0 */
		/* 821B9C60h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 821B9C60h case    1:*/		return 0x821B9C64;
		  /* 821B9C64h */ case    2:  		/* bc 12, CR6_EQ, 156 */
		/* 821B9C64h case    2:*/		if ( regs.CR[6].eq ) { return 0x821B9D00;  }
		/* 821B9C64h case    2:*/		return 0x821B9C68;
		  /* 821B9C68h */ case    3:  		/* lwz R31, <#[R29]> */
		/* 821B9C68h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R29 + 0x00000000) );
		/* 821B9C68h case    3:*/		return 0x821B9C6C;
		  /* 821B9C6Ch */ case    4:  		/* rlwinm. R11, R31, 0, 4, 6 */
		/* 821B9C6Ch case    4:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R31);
		/* 821B9C6Ch case    4:*/		return 0x821B9C70;
		  /* 821B9C70h */ case    5:  		/* bc 12, CR0_EQ, 132 */
		/* 821B9C70h case    5:*/		if ( regs.CR[0].eq ) { return 0x821B9CF4;  }
		/* 821B9C70h case    5:*/		return 0x821B9C74;
		  /* 821B9C74h */ case    6:  		/* lwz R30, <#[R29 + 12]> */
		/* 821B9C74h case    6:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R29 + 0x0000000C) );
		/* 821B9C74h case    6:*/		return 0x821B9C78;
		  /* 821B9C78h */ case    7:  		/* mr R3, R30 */
		/* 821B9C78h case    7:*/		regs.R3 = regs.R30;
		/* 821B9C78h case    7:*/		return 0x821B9C7C;
		  /* 821B9C7Ch */ case    8:  		/* bl -146212 */
		/* 821B9C7Ch case    8:*/		regs.LR = 0x821B9C80; return 0x82196158;
		/* 821B9C7Ch case    8:*/		return 0x821B9C80;
		  /* 821B9C80h */ case    9:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821B9C80h case    9:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821B9C80h case    9:*/		return 0x821B9C84;
		  /* 821B9C84h */ case   10:  		/* bc 12, CR0_EQ, 120 */
		/* 821B9C84h case   10:*/		if ( regs.CR[0].eq ) { return 0x821B9CFC;  }
		/* 821B9C84h case   10:*/		return 0x821B9C88;
		  /* 821B9C88h */ case   11:  		/* rlwinm. R10, R31, 0, 30, 30 */
		/* 821B9C88h case   11:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R31);
		/* 821B9C88h case   11:*/		return 0x821B9C8C;
		  /* 821B9C8Ch */ case   12:  		/* rlwinm R11, R31, 0, 27, 31 */
		/* 821B9C8Ch case   12:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R31);
		/* 821B9C8Ch case   12:*/		return 0x821B9C90;
		  /* 821B9C90h */ case   13:  		/* bc 12, CR0_EQ, 12 */
		/* 821B9C90h case   13:*/		if ( regs.CR[0].eq ) { return 0x821B9C9C;  }
		/* 821B9C90h case   13:*/		return 0x821B9C94;
		  /* 821B9C94h */ case   14:  		/* li R11, 0 */
		/* 821B9C94h case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821B9C94h case   14:*/		return 0x821B9C98;
		  /* 821B9C98h */ case   15:  		/* b 12 */
		/* 821B9C98h case   15:*/		return 0x821B9CA4;
		/* 821B9C98h case   15:*/		return 0x821B9C9C;
	}
	return 0x821B9C9C;
} // Block from 821B9C5Ch-821B9C9Ch (16 instructions)

//////////////////////////////////////////////////////
// Block at 821B9C9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9C9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9C9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9C9C);
		  /* 821B9C9Ch */ case    0:  		/* nor R11, R11, R11 */
		/* 821B9C9Ch case    0:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 821B9C9Ch case    0:*/		return 0x821B9CA0;
		  /* 821B9CA0h */ case    1:  		/* rlwinm R11, R11, 30, 31, 31 */
		/* 821B9CA0h case    1:*/		cpu::op::rlwinm<0,30,31,31>(regs,&regs.R11,regs.R11);
		/* 821B9CA0h case    1:*/		return 0x821B9CA4;
	}
	return 0x821B9CA4;
} // Block from 821B9C9Ch-821B9CA4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B9CA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9CA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9CA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9CA4);
		  /* 821B9CA4h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821B9CA4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821B9CA4h case    0:*/		return 0x821B9CA8;
		  /* 821B9CA8h */ case    1:  		/* bc 12, CR0_EQ, 84 */
		/* 821B9CA8h case    1:*/		if ( regs.CR[0].eq ) { return 0x821B9CFC;  }
		/* 821B9CA8h case    1:*/		return 0x821B9CAC;
		  /* 821B9CACh */ case    2:  		/* lwz R11, <#[R30 + 8]> */
		/* 821B9CACh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821B9CACh case    2:*/		return 0x821B9CB0;
		  /* 821B9CB0h */ case    3:  		/* rlwinm. R10, R11, 8, 31, 31 */
		/* 821B9CB0h case    3:*/		cpu::op::rlwinm<1,8,31,31>(regs,&regs.R10,regs.R11);
		/* 821B9CB0h case    3:*/		return 0x821B9CB4;
		  /* 821B9CB4h */ case    4:  		/* bc 12, CR0_EQ, 12 */
		/* 821B9CB4h case    4:*/		if ( regs.CR[0].eq ) { return 0x821B9CC0;  }
		/* 821B9CB4h case    4:*/		return 0x821B9CB8;
		  /* 821B9CB8h */ case    5:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821B9CB8h case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821B9CB8h case    5:*/		return 0x821B9CBC;
		  /* 821B9CBCh */ case    6:  		/* bc 12, CR0_EQ, 64 */
		/* 821B9CBCh case    6:*/		if ( regs.CR[0].eq ) { return 0x821B9CFC;  }
		/* 821B9CBCh case    6:*/		return 0x821B9CC0;
	}
	return 0x821B9CC0;
} // Block from 821B9CA4h-821B9CC0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821B9CC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9CC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9CC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9CC0);
		  /* 821B9CC0h */ case    0:  		/* lwz R11, <#[R30 + 4]> */
		/* 821B9CC0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 821B9CC0h case    0:*/		return 0x821B9CC4;
		  /* 821B9CC4h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 821B9CC4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821B9CC4h case    1:*/		return 0x821B9CC8;
		  /* 821B9CC8h */ case    2:  		/* bc 12, CR6_EQ, 44 */
		/* 821B9CC8h case    2:*/		if ( regs.CR[6].eq ) { return 0x821B9CF4;  }
		/* 821B9CC8h case    2:*/		return 0x821B9CCC;
		  /* 821B9CCCh */ case    3:  		/* lwz R10, <#[R11 + 16]> */
		/* 821B9CCCh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 821B9CCCh case    3:*/		return 0x821B9CD0;
		  /* 821B9CD0h */ case    4:  		/* cmplwi CR6, R10, 0 */
		/* 821B9CD0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821B9CD0h case    4:*/		return 0x821B9CD4;
		  /* 821B9CD4h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 821B9CD4h case    5:*/		if ( regs.CR[6].eq ) { return 0x821B9CEC;  }
		/* 821B9CD4h case    5:*/		return 0x821B9CD8;
		  /* 821B9CD8h */ case    6:  		/* lwz R10, <#[R11]> */
		/* 821B9CD8h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821B9CD8h case    6:*/		return 0x821B9CDC;
		  /* 821B9CDCh */ case    7:  		/* rlwinm. R9, R10, 0, 4, 6 */
		/* 821B9CDCh case    7:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R9,regs.R10);
		/* 821B9CDCh case    7:*/		return 0x821B9CE0;
		  /* 821B9CE0h */ case    8:  		/* bc 12, CR0_EQ, 12 */
		/* 821B9CE0h case    8:*/		if ( regs.CR[0].eq ) { return 0x821B9CEC;  }
		/* 821B9CE0h case    8:*/		return 0x821B9CE4;
		  /* 821B9CE4h */ case    9:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 821B9CE4h case    9:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 821B9CE4h case    9:*/		return 0x821B9CE8;
		  /* 821B9CE8h */ case   10:  		/* bc 12, CR0_EQ, 20 */
		/* 821B9CE8h case   10:*/		if ( regs.CR[0].eq ) { return 0x821B9CFC;  }
		/* 821B9CE8h case   10:*/		return 0x821B9CEC;
	}
	return 0x821B9CEC;
} // Block from 821B9CC0h-821B9CECh (11 instructions)

//////////////////////////////////////////////////////
// Block at 821B9CECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9CEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9CEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9CEC);
		  /* 821B9CECh */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 821B9CECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821B9CECh case    0:*/		return 0x821B9CF0;
		  /* 821B9CF0h */ case    1:  		/* b -44 */
		/* 821B9CF0h case    1:*/		return 0x821B9CC4;
		/* 821B9CF0h case    1:*/		return 0x821B9CF4;
	}
	return 0x821B9CF4;
} // Block from 821B9CECh-821B9CF4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B9CF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9CF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9CF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9CF4);
		  /* 821B9CF4h */ case    0:  		/* lwz R29, <#[R29 + 4]> */
		/* 821B9CF4h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R29 + 0x00000004) );
		/* 821B9CF4h case    0:*/		return 0x821B9CF8;
		  /* 821B9CF8h */ case    1:  		/* b -152 */
		/* 821B9CF8h case    1:*/		return 0x821B9C60;
		/* 821B9CF8h case    1:*/		return 0x821B9CFC;
	}
	return 0x821B9CFC;
} // Block from 821B9CF4h-821B9CFCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B9CFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9CFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9CFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9CFC);
		  /* 821B9CFCh */ case    0:  		/* mr R28, R21 */
		/* 821B9CFCh case    0:*/		regs.R28 = regs.R21;
		/* 821B9CFCh case    0:*/		return 0x821B9D00;
	}
	return 0x821B9D00;
} // Block from 821B9CFCh-821B9D00h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B9D00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9D00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9D00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9D00);
		  /* 821B9D00h */ case    0:  		/* rlwinm. R11, R28, 0, 24, 31 */
		/* 821B9D00h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R28);
		/* 821B9D00h case    0:*/		return 0x821B9D04;
		  /* 821B9D04h */ case    1:  		/* bc 12, CR0_EQ, 1672 */
		/* 821B9D04h case    1:*/		if ( regs.CR[0].eq ) { return 0x821BA38C;  }
		/* 821B9D04h case    1:*/		return 0x821B9D08;
		  /* 821B9D08h */ case    2:  		/* rlwinm R11, R27, 0, 18, 24 */
		/* 821B9D08h case    2:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R27);
		/* 821B9D08h case    2:*/		return 0x821B9D0C;
		  /* 821B9D0Ch */ case    3:  		/* rlwinm R10, R27, 0, 0, 30 */
		/* 821B9D0Ch case    3:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R27);
		/* 821B9D0Ch case    3:*/		return 0x821B9D10;
		  /* 821B9D10h */ case    4:  		/* addi R11, R11, -15104 */
		/* 821B9D10h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFC500);
		/* 821B9D10h case    4:*/		return 0x821B9D14;
		  /* 821B9D14h */ case    5:  		/* stw R10, <#[R16 + 8]> */
		/* 821B9D14h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R16 + 0x00000008) );
		/* 821B9D14h case    5:*/		return 0x821B9D18;
		  /* 821B9D18h */ case    6:  		/* cntlzw R11, R11 */
		/* 821B9D18h case    6:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 821B9D18h case    6:*/		return 0x821B9D1C;
		  /* 821B9D1Ch */ case    7:  		/* rlwinm. R7, R11, 27, 31, 31 */
		/* 821B9D1Ch case    7:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R7,regs.R11);
		/* 821B9D1Ch case    7:*/		return 0x821B9D20;
		  /* 821B9D20h */ case    8:  		/* bc 4, CR0_EQ, 164 */
		/* 821B9D20h case    8:*/		if ( !regs.CR[0].eq ) { return 0x821B9DC4;  }
		/* 821B9D20h case    8:*/		return 0x821B9D24;
		  /* 821B9D24h */ case    9:  		/* li R8, 0 */
		/* 821B9D24h case    9:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821B9D24h case    9:*/		return 0x821B9D28;
		  /* 821B9D28h */ case   10:  		/* mr R9, R24 */
		/* 821B9D28h case   10:*/		regs.R9 = regs.R24;
		/* 821B9D28h case   10:*/		return 0x821B9D2C;
		  /* 821B9D2Ch */ case   11:  		/* cmplwi CR6, R9, 0 */
		/* 821B9D2Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 821B9D2Ch case   11:*/		return 0x821B9D30;
		  /* 821B9D30h */ case   12:  		/* bc 12, CR6_EQ, 128 */
		/* 821B9D30h case   12:*/		if ( regs.CR[6].eq ) { return 0x821B9DB0;  }
		/* 821B9D30h case   12:*/		return 0x821B9D34;
		  /* 821B9D34h */ case   13:  		/* lwz R10, <#[R9 + 16]> */
		/* 821B9D34h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000010) );
		/* 821B9D34h case   13:*/		return 0x821B9D38;
		  /* 821B9D38h */ case   14:  		/* cmplwi CR6, R10, 0 */
		/* 821B9D38h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821B9D38h case   14:*/		return 0x821B9D3C;
		  /* 821B9D3Ch */ case   15:  		/* bc 12, CR6_EQ, 108 */
		/* 821B9D3Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x821B9DA8;  }
		/* 821B9D3Ch case   15:*/		return 0x821B9D40;
		  /* 821B9D40h */ case   16:  		/* lwz R11, <#[R9]> */
		/* 821B9D40h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 821B9D40h case   16:*/		return 0x821B9D44;
		  /* 821B9D44h */ case   17:  		/* rlwinm. R6, R11, 0, 4, 6 */
		/* 821B9D44h case   17:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R6,regs.R11);
		/* 821B9D44h case   17:*/		return 0x821B9D48;
		  /* 821B9D48h */ case   18:  		/* bc 12, CR0_EQ, 96 */
		/* 821B9D48h case   18:*/		if ( regs.CR[0].eq ) { return 0x821B9DA8;  }
		/* 821B9D48h case   18:*/		return 0x821B9D4C;
		  /* 821B9D4Ch */ case   19:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821B9D4Ch case   19:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821B9D4Ch case   19:*/		return 0x821B9D50;
		  /* 821B9D50h */ case   20:  		/* bc 12, CR0_EQ, 88 */
		/* 821B9D50h case   20:*/		if ( regs.CR[0].eq ) { return 0x821B9DA8;  }
		/* 821B9D50h case   20:*/		return 0x821B9D54;
		  /* 821B9D54h */ case   21:  		/* lwz R11, <#[R10 + 8]> */
		/* 821B9D54h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 821B9D54h case   21:*/		return 0x821B9D58;
		  /* 821B9D58h */ case   22:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821B9D58h case   22:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821B9D58h case   22:*/		return 0x821B9D5C;
		  /* 821B9D5Ch */ case   23:  		/* cmplwi CR6, R11, 14336 */
		/* 821B9D5Ch case   23:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003800);
		/* 821B9D5Ch case   23:*/		return 0x821B9D60;
		  /* 821B9D60h */ case   24:  		/* bc 4, CR6_EQ, 48 */
		/* 821B9D60h case   24:*/		if ( !regs.CR[6].eq ) { return 0x821B9D90;  }
		/* 821B9D60h case   24:*/		return 0x821B9D64;
		  /* 821B9D64h */ case   25:  		/* lwz R11, <#[R10]> */
		/* 821B9D64h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 821B9D64h case   25:*/		return 0x821B9D68;
		  /* 821B9D68h */ case   26:  		/* cmplwi CR6, R11, 0 */
		/* 821B9D68h case   26:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821B9D68h case   26:*/		return 0x821B9D6C;
		  /* 821B9D6Ch */ case   27:  		/* bc 12, CR6_EQ, 20 */
		/* 821B9D6Ch case   27:*/		if ( regs.CR[6].eq ) { return 0x821B9D80;  }
		/* 821B9D6Ch case   27:*/		return 0x821B9D70;
		  /* 821B9D70h */ case   28:  		/* lwz R11, <#[R11 + 4]> */
		/* 821B9D70h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821B9D70h case   28:*/		return 0x821B9D74;
		  /* 821B9D74h */ case   29:  		/* cmplwi CR6, R11, 0 */
		/* 821B9D74h case   29:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821B9D74h case   29:*/		return 0x821B9D78;
		  /* 821B9D78h */ case   30:  		/* mr R11, R21 */
		/* 821B9D78h case   30:*/		regs.R11 = regs.R21;
		/* 821B9D78h case   30:*/		return 0x821B9D7C;
		  /* 821B9D7Ch */ case   31:  		/* bc 4, CR6_EQ, 8 */
		/* 821B9D7Ch case   31:*/		if ( !regs.CR[6].eq ) { return 0x821B9D84;  }
		/* 821B9D7Ch case   31:*/		return 0x821B9D80;
	}
	return 0x821B9D80;
} // Block from 821B9D00h-821B9D80h (32 instructions)

//////////////////////////////////////////////////////
// Block at 821B9D80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9D80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9D80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9D80);
		  /* 821B9D80h */ case    0:  		/* li R11, 0 */
		/* 821B9D80h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821B9D80h case    0:*/		return 0x821B9D84;
	}
	return 0x821B9D84;
} // Block from 821B9D80h-821B9D84h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B9D84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9D84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9D84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9D84);
		  /* 821B9D84h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821B9D84h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821B9D84h case    0:*/		return 0x821B9D88;
		  /* 821B9D88h */ case    1:  		/* bc 12, CR0_EQ, 8 */
		/* 821B9D88h case    1:*/		if ( regs.CR[0].eq ) { return 0x821B9D90;  }
		/* 821B9D88h case    1:*/		return 0x821B9D8C;
		  /* 821B9D8Ch */ case    2:  		/* mr R7, R21 */
		/* 821B9D8Ch case    2:*/		regs.R7 = regs.R21;
		/* 821B9D8Ch case    2:*/		return 0x821B9D90;
	}
	return 0x821B9D90;
} // Block from 821B9D84h-821B9D90h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821B9D90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9D90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9D90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9D90);
		  /* 821B9D90h */ case    0:  		/* lwz R11, <#[R10 + 28]> */
		/* 821B9D90h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000001C) );
		/* 821B9D90h case    0:*/		return 0x821B9D94;
		  /* 821B9D94h */ case    1:  		/* lwz R11, <#[R11 + 68]> */
		/* 821B9D94h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000044) );
		/* 821B9D94h case    1:*/		return 0x821B9D98;
		  /* 821B9D98h */ case    2:  		/* rlwinm R11, R11, 0, 4, 31 */
		/* 821B9D98h case    2:*/		cpu::op::rlwinm<0,0,4,31>(regs,&regs.R11,regs.R11);
		/* 821B9D98h case    2:*/		return 0x821B9D9C;
		  /* 821B9D9Ch */ case    3:  		/* cmplw CR6, R11, R8 */
		/* 821B9D9Ch case    3:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 821B9D9Ch case    3:*/		return 0x821B9DA0;
		  /* 821B9DA0h */ case    4:  		/* bc 4, CR6_GT, 8 */
		/* 821B9DA0h case    4:*/		if ( !regs.CR[6].gt ) { return 0x821B9DA8;  }
		/* 821B9DA0h case    4:*/		return 0x821B9DA4;
		  /* 821B9DA4h */ case    5:  		/* mr R8, R11 */
		/* 821B9DA4h case    5:*/		regs.R8 = regs.R11;
		/* 821B9DA4h case    5:*/		return 0x821B9DA8;
	}
	return 0x821B9DA8;
} // Block from 821B9D90h-821B9DA8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821B9DA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9DA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9DA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9DA8);
		  /* 821B9DA8h */ case    0:  		/* lwz R9, <#[R9 + 8]> */
		/* 821B9DA8h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 821B9DA8h case    0:*/		return 0x821B9DAC;
		  /* 821B9DACh */ case    1:  		/* b -128 */
		/* 821B9DACh case    1:*/		return 0x821B9D2C;
		/* 821B9DACh case    1:*/		return 0x821B9DB0;
	}
	return 0x821B9DB0;
} // Block from 821B9DA8h-821B9DB0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821B9DB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9DB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9DB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9DB0);
		  /* 821B9DB0h */ case    0:  		/* lwz R11, <#[R23 + 68]> */
		/* 821B9DB0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000044) );
		/* 821B9DB0h case    0:*/		return 0x821B9DB4;
		  /* 821B9DB4h */ case    1:  		/* rlwinm R11, R11, 0, 4, 31 */
		/* 821B9DB4h case    1:*/		cpu::op::rlwinm<0,0,4,31>(regs,&regs.R11,regs.R11);
		/* 821B9DB4h case    1:*/		return 0x821B9DB8;
		  /* 821B9DB8h */ case    2:  		/* cmplw CR6, R8, R11 */
		/* 821B9DB8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 821B9DB8h case    2:*/		return 0x821B9DBC;
		  /* 821B9DBCh */ case    3:  		/* bc 12, CR6_LT, 8 */
		/* 821B9DBCh case    3:*/		if ( regs.CR[6].lt ) { return 0x821B9DC4;  }
		/* 821B9DBCh case    3:*/		return 0x821B9DC0;
		  /* 821B9DC0h */ case    4:  		/* mr R7, R21 */
		/* 821B9DC0h case    4:*/		regs.R7 = regs.R21;
		/* 821B9DC0h case    4:*/		return 0x821B9DC4;
	}
	return 0x821B9DC4;
} // Block from 821B9DB0h-821B9DC4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821B9DC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9DC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9DC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9DC4);
		  /* 821B9DC4h */ case    0:  		/* rlwinm. R11, R7, 0, 24, 31 */
		/* 821B9DC4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R7);
		/* 821B9DC4h case    0:*/		return 0x821B9DC8;
		  /* 821B9DC8h */ case    1:  		/* bc 4, CR0_EQ, 872 */
		/* 821B9DC8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821BA130;  }
		/* 821B9DC8h case    1:*/		return 0x821B9DCC;
		  /* 821B9DCCh */ case    2:  		/* li R25, 0 */
		/* 821B9DCCh case    2:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 821B9DCCh case    2:*/		return 0x821B9DD0;
		  /* 821B9DD0h */ case    3:  		/* mr R24, R14 */
		/* 821B9DD0h case    3:*/		regs.R24 = regs.R14;
		/* 821B9DD0h case    3:*/		return 0x821B9DD4;
		  /* 821B9DD4h */ case    4:  		/* lwz R27, <#[R24]> */
		/* 821B9DD4h case    4:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R24 + 0x00000000) );
		/* 821B9DD4h case    4:*/		return 0x821B9DD8;
		  /* 821B9DD8h */ case    5:  		/* cmplwi CR6, R27, 0 */
		/* 821B9DD8h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 821B9DD8h case    5:*/		return 0x821B9DDC;
		  /* 821B9DDCh */ case    6:  		/* bc 12, CR6_EQ, 1480 */
		/* 821B9DDCh case    6:*/		if ( regs.CR[6].eq ) { return 0x821BA3A4;  }
		/* 821B9DDCh case    6:*/		return 0x821B9DE0;
		  /* 821B9DE0h */ case    7:  		/* lwz R11, <#[R27 + 16]> */
		/* 821B9DE0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000010) );
		/* 821B9DE0h case    7:*/		return 0x821B9DE4;
		  /* 821B9DE4h */ case    8:  		/* cmplwi CR6, R11, 0 */
		/* 821B9DE4h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821B9DE4h case    8:*/		return 0x821B9DE8;
		  /* 821B9DE8h */ case    9:  		/* bc 12, CR6_EQ, 820 */
		/* 821B9DE8h case    9:*/		if ( regs.CR[6].eq ) { return 0x821BA11C;  }
		/* 821B9DE8h case    9:*/		return 0x821B9DEC;
		  /* 821B9DECh */ case   10:  		/* lwz R11, <#[R27]> */
		/* 821B9DECh case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 821B9DECh case   10:*/		return 0x821B9DF0;
		  /* 821B9DF0h */ case   11:  		/* rlwinm. R9, R11, 7, 29, 31 */
		/* 821B9DF0h case   11:*/		cpu::op::rlwinm<1,7,29,31>(regs,&regs.R9,regs.R11);
		/* 821B9DF0h case   11:*/		return 0x821B9DF4;
		  /* 821B9DF4h */ case   12:  		/* bc 12, CR0_EQ, 808 */
		/* 821B9DF4h case   12:*/		if ( regs.CR[0].eq ) { return 0x821BA11C;  }
		/* 821B9DF4h case   12:*/		return 0x821B9DF8;
		  /* 821B9DF8h */ case   13:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821B9DF8h case   13:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821B9DF8h case   13:*/		return 0x821B9DFC;
		  /* 821B9DFCh */ case   14:  		/* bc 12, CR0_EQ, 800 */
		/* 821B9DFCh case   14:*/		if ( regs.CR[0].eq ) { return 0x821BA11C;  }
		/* 821B9DFCh case   14:*/		return 0x821B9E00;
		  /* 821B9E00h */ case   15:  		/* li R28, 0 */
		/* 821B9E00h case   15:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 821B9E00h case   15:*/		return 0x821B9E04;
		  /* 821B9E04h */ case   16:  		/* li R10, 0 */
		/* 821B9E04h case   16:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821B9E04h case   16:*/		return 0x821B9E08;
		  /* 821B9E08h */ case   17:  		/* cmplwi CR6, R9, 0 */
		/* 821B9E08h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 821B9E08h case   17:*/		return 0x821B9E0C;
		  /* 821B9E0Ch */ case   18:  		/* bc 12, CR6_EQ, 52 */
		/* 821B9E0Ch case   18:*/		if ( regs.CR[6].eq ) { return 0x821B9E40;  }
		/* 821B9E0Ch case   18:*/		return 0x821B9E10;
		  /* 821B9E10h */ case   19:  		/* rlwinm R8, R11, 0, 0, 31 */
		/* 821B9E10h case   19:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R8,regs.R11);
		/* 821B9E10h case   19:*/		return 0x821B9E14;
		  /* 821B9E14h */ case   20:  		/* rlwinm R9, R11, 27, 24, 31 */
		/* 821B9E14h case   20:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R9,regs.R11);
		/* 821B9E14h case   20:*/		return 0x821B9E18;
		  /* 821B9E18h */ case   21:  		/* li R11, 0 */
		/* 821B9E18h case   21:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821B9E18h case   21:*/		return 0x821B9E1C;
		  /* 821B9E1Ch */ case   22:  		/* rlwinm R8, R8, 7, 29, 31 */
		/* 821B9E1Ch case   22:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R8,regs.R8);
		/* 821B9E1Ch case   22:*/		return 0x821B9E20;
		  /* 821B9E20h */ case   23:  		/* srw R7, R9, R11 */
		/* 821B9E20h case   23:*/		cpu::op::srw<0>(regs,&regs.R7,regs.R9,regs.R11);
		/* 821B9E20h case   23:*/		return 0x821B9E24;
		  /* 821B9E24h */ case   24:  		/* rlwinm R7, R7, 0, 30, 31 */
		/* 821B9E24h case   24:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R7,regs.R7);
		/* 821B9E24h case   24:*/		return 0x821B9E28;
		  /* 821B9E28h */ case   25:  		/* addi R10, R10, 1 */
		/* 821B9E28h case   25:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821B9E28h case   25:*/		return 0x821B9E2C;
		  /* 821B9E2Ch */ case   26:  		/* slw R7, R21, R7 */
		/* 821B9E2Ch case   26:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R21,regs.R7);
		/* 821B9E2Ch case   26:*/		return 0x821B9E30;
		  /* 821B9E30h */ case   27:  		/* or R28, R7, R28 */
		/* 821B9E30h case   27:*/		cpu::op::or<0>(regs,&regs.R28,regs.R7,regs.R28);
		/* 821B9E30h case   27:*/		return 0x821B9E34;
		  /* 821B9E34h */ case   28:  		/* addi R11, R11, 2 */
		/* 821B9E34h case   28:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 821B9E34h case   28:*/		return 0x821B9E38;
		  /* 821B9E38h */ case   29:  		/* cmplw CR6, R10, R8 */
		/* 821B9E38h case   29:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 821B9E38h case   29:*/		return 0x821B9E3C;
		  /* 821B9E3Ch */ case   30:  		/* bc 12, CR6_LT, -28 */
		/* 821B9E3Ch case   30:*/		if ( regs.CR[6].lt ) { return 0x821B9E20;  }
		/* 821B9E3Ch case   30:*/		return 0x821B9E40;
	}
	return 0x821B9E40;
} // Block from 821B9DC4h-821B9E40h (31 instructions)

//////////////////////////////////////////////////////
// Block at 821B9E40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9E40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9E40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9E40);
		  /* 821B9E40h */ case    0:  		/* lwz R11, <#[R1 + 84]> */
		/* 821B9E40h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 821B9E40h case    0:*/		return 0x821B9E44;
		  /* 821B9E44h */ case    1:  		/* mr R4, R16 */
		/* 821B9E44h case    1:*/		regs.R4 = regs.R16;
		/* 821B9E44h case    1:*/		return 0x821B9E48;
		  /* 821B9E48h */ case    2:  		/* mr R3, R15 */
		/* 821B9E48h case    2:*/		regs.R3 = regs.R15;
		/* 821B9E48h case    2:*/		return 0x821B9E4C;
		  /* 821B9E4Ch */ case    3:  		/* add R11, R28, R11 */
		/* 821B9E4Ch case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R28,regs.R11);
		/* 821B9E4Ch case    3:*/		return 0x821B9E50;
		  /* 821B9E50h */ case    4:  		/* lbz R30, <#[R11 - 1]> */
		/* 821B9E50h case    4:*/		cpu::mem::load8z( regs, &regs.R30, (uint32)(regs.R11 + 0xFFFFFFFF) );
		/* 821B9E50h case    4:*/		return 0x821B9E54;
		  /* 821B9E54h */ case    5:  		/* bl -269908 */
		/* 821B9E54h case    5:*/		regs.LR = 0x821B9E58; return 0x82178000;
		/* 821B9E54h case    5:*/		return 0x821B9E58;
		  /* 821B9E58h */ case    6:  		/* lis R11, -28311 */
		/* 821B9E58h case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF9169);
		/* 821B9E58h case    6:*/		return 0x821B9E5C;
		  /* 821B9E5Ch */ case    7:  		/* lis R10, 0 */
		/* 821B9E5Ch case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0x0);
		/* 821B9E5Ch case    7:*/		return 0x821B9E60;
		  /* 821B9E60h */ case    8:  		/* ori R11, R11, 5192 */
		/* 821B9E60h case    8:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1448);
		/* 821B9E60h case    8:*/		return 0x821B9E64;
		  /* 821B9E64h */ case    9:  		/* ori R10, R10, 36262 */
		/* 821B9E64h case    9:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x8DA6);
		/* 821B9E64h case    9:*/		return 0x821B9E68;
		  /* 821B9E68h */ case   10:  		/* rldicl R9, R28, 0, 32 */
		/* 821B9E68h case   10:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R9,regs.R28);
		/* 821B9E68h case   10:*/		return 0x821B9E6C;
		  /* 821B9E6Ch */ case   11:  		/* rldimi R11, R10, 32, 0 */
		/* 821B9E6Ch case   11:*/		cpu::op::rldimi<0,32,0>(regs,&regs.R11,regs.R10);
		/* 821B9E6Ch case   11:*/		return 0x821B9E70;
		  /* 821B9E70h */ case   12:  		/* lwz R10, <#[R3]> */
		/* 821B9E70h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 821B9E70h case   12:*/		return 0x821B9E74;
		  /* 821B9E74h */ case   13:  		/* li R4, 0 */
		/* 821B9E74h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 821B9E74h case   13:*/		return 0x821B9E78;
		  /* 821B9E78h */ case   14:  		/* srd R11, R11, R9 */
		/* 821B9E78h case   14:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 821B9E78h case   14:*/		return 0x821B9E7C;
		  /* 821B9E7Ch */ case   15:  		/* srd R11, R11, R9 */
		/* 821B9E7Ch case   15:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 821B9E7Ch case   15:*/		return 0x821B9E80;
		  /* 821B9E80h */ case   16:  		/* srd R11, R11, R9 */
		/* 821B9E80h case   16:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 821B9E80h case   16:*/		return 0x821B9E84;
		  /* 821B9E84h */ case   17:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 821B9E84h case   17:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 821B9E84h case   17:*/		return 0x821B9E88;
		  /* 821B9E88h */ case   18:  		/* mr R31, R3 */
		/* 821B9E88h case   18:*/		regs.R31 = regs.R3;
		/* 821B9E88h case   18:*/		return 0x821B9E8C;
		  /* 821B9E8Ch */ case   19:  		/* rlwimi R10, R11, 25, 4, 6 */
		/* 821B9E8Ch case   19:*/		cpu::op::rlwimi<0,25,4,6>(regs,&regs.R10,regs.R11);
		/* 821B9E8Ch case   19:*/		return 0x821B9E90;
		  /* 821B9E90h */ case   20:  		/* stw R10, <#[R3]> */
		/* 821B9E90h case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 821B9E90h case   20:*/		return 0x821B9E94;
		  /* 821B9E94h */ case   21:  		/* bl -271316 */
		/* 821B9E94h case   21:*/		regs.LR = 0x821B9E98; return 0x82177AC0;
		/* 821B9E94h case   21:*/		return 0x821B9E98;
		  /* 821B9E98h */ case   22:  		/* lwz R11, <#[R31]> */
		/* 821B9E98h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821B9E98h case   22:*/		return 0x821B9E9C;
		  /* 821B9E9Ch */ case   23:  		/* rlwimi R11, R30, 5, 19, 26 */
		/* 821B9E9Ch case   23:*/		cpu::op::rlwimi<0,5,19,26>(regs,&regs.R11,regs.R30);
		/* 821B9E9Ch case   23:*/		return 0x821B9EA0;
		  /* 821B9EA0h */ case   24:  		/* stw R11, <#[R31]> */
		/* 821B9EA0h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821B9EA0h case   24:*/		return 0x821B9EA4;
		  /* 821B9EA4h */ case   25:  		/* lwz R26, <#[R27 + 16]> */
		/* 821B9EA4h case   25:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R27 + 0x00000010) );
		/* 821B9EA4h case   25:*/		return 0x821B9EA8;
		  /* 821B9EA8h */ case   26:  		/* lwz R30, <#[R26 + 28]> */
		/* 821B9EA8h case   26:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R26 + 0x0000001C) );
		/* 821B9EA8h case   26:*/		return 0x821B9EAC;
		  /* 821B9EACh */ case   27:  		/* cmplw CR6, R30, R23 */
		/* 821B9EACh case   27:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R23);
		/* 821B9EACh case   27:*/		return 0x821B9EB0;
		  /* 821B9EB0h */ case   28:  		/* bc 4, CR6_EQ, 20 */
		/* 821B9EB0h case   28:*/		if ( !regs.CR[6].eq ) { return 0x821B9EC4;  }
		/* 821B9EB0h case   28:*/		return 0x821B9EB4;
		  /* 821B9EB4h */ case   29:  		/* cmplwi CR6, R25, 0 */
		/* 821B9EB4h case   29:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 821B9EB4h case   29:*/		return 0x821B9EB8;
		  /* 821B9EB8h */ case   30:  		/* bc 12, CR6_EQ, 12 */
		/* 821B9EB8h case   30:*/		if ( regs.CR[6].eq ) { return 0x821B9EC4;  }
		/* 821B9EB8h case   30:*/		return 0x821B9EBC;
		  /* 821B9EBCh */ case   31:  		/* mr R31, R25 */
		/* 821B9EBCh case   31:*/		regs.R31 = regs.R25;
		/* 821B9EBCh case   31:*/		return 0x821B9EC0;
		  /* 821B9EC0h */ case   32:  		/* b 260 */
		/* 821B9EC0h case   32:*/		return 0x821B9FC4;
		/* 821B9EC0h case   32:*/		return 0x821B9EC4;
	}
	return 0x821B9EC4;
} // Block from 821B9E40h-821B9EC4h (33 instructions)

//////////////////////////////////////////////////////
// Block at 821B9EC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9EC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9EC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9EC4);
		  /* 821B9EC4h */ case    0:  		/* mr R7, R31 */
		/* 821B9EC4h case    0:*/		regs.R7 = regs.R31;
		/* 821B9EC4h case    0:*/		return 0x821B9EC8;
		  /* 821B9EC8h */ case    1:  		/* mr R6, R31 */
		/* 821B9EC8h case    1:*/		regs.R6 = regs.R31;
		/* 821B9EC8h case    1:*/		return 0x821B9ECC;
		  /* 821B9ECCh */ case    2:  		/* li R5, 0 */
		/* 821B9ECCh case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821B9ECCh case    2:*/		return 0x821B9ED0;
		  /* 821B9ED0h */ case    3:  		/* mr R4, R30 */
		/* 821B9ED0h case    3:*/		regs.R4 = regs.R30;
		/* 821B9ED0h case    3:*/		return 0x821B9ED4;
		  /* 821B9ED4h */ case    4:  		/* mr R3, R15 */
		/* 821B9ED4h case    4:*/		regs.R3 = regs.R15;
		/* 821B9ED4h case    4:*/		return 0x821B9ED8;
		  /* 821B9ED8h */ case    5:  		/* bl -262304 */
		/* 821B9ED8h case    5:*/		regs.LR = 0x821B9EDC; return 0x82179E38;
		/* 821B9ED8h case    5:*/		return 0x821B9EDC;
		  /* 821B9EDCh */ case    6:  		/* mr R31, R3 */
		/* 821B9EDCh case    6:*/		regs.R31 = regs.R3;
		/* 821B9EDCh case    6:*/		return 0x821B9EE0;
		  /* 821B9EE0h */ case    7:  		/* cmplw CR6, R30, R23 */
		/* 821B9EE0h case    7:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R23);
		/* 821B9EE0h case    7:*/		return 0x821B9EE4;
		  /* 821B9EE4h */ case    8:  		/* bc 12, CR6_EQ, 152 */
		/* 821B9EE4h case    8:*/		if ( regs.CR[6].eq ) { return 0x821B9F7C;  }
		/* 821B9EE4h case    8:*/		return 0x821B9EE8;
		  /* 821B9EE8h */ case    9:  		/* rlwinm R11, R3, 0, 0, 30 */
		/* 821B9EE8h case    9:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R3);
		/* 821B9EE8h case    9:*/		return 0x821B9EEC;
		  /* 821B9EECh */ case   10:  		/* lwz R8, <#[R30 + 28]> */
		/* 821B9EECh case   10:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x0000001C) );
		/* 821B9EECh case   10:*/		return 0x821B9EF0;
		  /* 821B9EF0h */ case   11:  		/* addi R10, R30, 24 */
		/* 821B9EF0h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0x18);
		/* 821B9EF0h case   11:*/		return 0x821B9EF4;
		  /* 821B9EF4h */ case   12:  		/* addi R11, R11, 36 */
		/* 821B9EF4h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821B9EF4h case   12:*/		return 0x821B9EF8;
		  /* 821B9EF8h */ case   13:  		/* addi R10, R10, 4 */
		/* 821B9EF8h case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821B9EF8h case   13:*/		return 0x821B9EFC;
		  /* 821B9EFCh */ case   14:  		/* addi R9, R11, 4 */
		/* 821B9EFCh case   14:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821B9EFCh case   14:*/		return 0x821B9F00;
		  /* 821B9F00h */ case   15:  		/* ori R10, R10, 1 */
		/* 821B9F00h case   15:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821B9F00h case   15:*/		return 0x821B9F04;
		  /* 821B9F04h */ case   16:  		/* addi R7, R11, -36 */
		/* 821B9F04h case   16:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFDC);
		/* 821B9F04h case   16:*/		return 0x821B9F08;
		  /* 821B9F08h */ case   17:  		/* stw R8, <#[R11 + 4]> */
		/* 821B9F08h case   17:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 821B9F08h case   17:*/		return 0x821B9F0C;
		  /* 821B9F0Ch */ case   18:  		/* lwz R8, <#[R30 + 28]> */
		/* 821B9F0Ch case   18:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R30 + 0x0000001C) );
		/* 821B9F0Ch case   18:*/		return 0x821B9F10;
		  /* 821B9F10h */ case   19:  		/* rlwinm R8, R8, 0, 0, 30 */
		/* 821B9F10h case   19:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R8,regs.R8);
		/* 821B9F10h case   19:*/		return 0x821B9F14;
		  /* 821B9F14h */ case   20:  		/* stw R9, <#[R8 + 36]> */
		/* 821B9F14h case   20:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R8 + 0x00000024) );
		/* 821B9F14h case   20:*/		return 0x821B9F18;
		  /* 821B9F18h */ case   21:  		/* stw R10, <#[R11]> */
		/* 821B9F18h case   21:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821B9F18h case   21:*/		return 0x821B9F1C;
		  /* 821B9F1Ch */ case   22:  		/* stw R7, <#[R30 + 28]> */
		/* 821B9F1Ch case   22:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R30 + 0x0000001C) );
		/* 821B9F1Ch case   22:*/		return 0x821B9F20;
		  /* 821B9F20h */ case   23:  		/* lwz R11, <#[R16 + 8]> */
		/* 821B9F20h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000008) );
		/* 821B9F20h case   23:*/		return 0x821B9F24;
		  /* 821B9F24h */ case   24:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821B9F24h case   24:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821B9F24h case   24:*/		return 0x821B9F28;
		  /* 821B9F28h */ case   25:  		/* cmplwi CR6, R11, 125 */
		/* 821B9F28h case   25:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 821B9F28h case   25:*/		return 0x821B9F2C;
		  /* 821B9F2Ch */ case   26:  		/* bc 12, CR6_EQ, 16 */
		/* 821B9F2Ch case   26:*/		if ( regs.CR[6].eq ) { return 0x821B9F3C;  }
		/* 821B9F2Ch case   26:*/		return 0x821B9F30;
		  /* 821B9F30h */ case   27:  		/* cmplwi CR6, R11, 124 */
		/* 821B9F30h case   27:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 821B9F30h case   27:*/		return 0x821B9F34;
		  /* 821B9F34h */ case   28:  		/* li R11, 0 */
		/* 821B9F34h case   28:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821B9F34h case   28:*/		return 0x821B9F38;
		  /* 821B9F38h */ case   29:  		/* bc 4, CR6_EQ, 8 */
		/* 821B9F38h case   29:*/		if ( !regs.CR[6].eq ) { return 0x821B9F40;  }
		/* 821B9F38h case   29:*/		return 0x821B9F3C;
	}
	return 0x821B9F3C;
} // Block from 821B9EC4h-821B9F3Ch (30 instructions)

//////////////////////////////////////////////////////
// Block at 821B9F3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9F3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9F3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9F3C);
		  /* 821B9F3Ch */ case    0:  		/* mr R11, R21 */
		/* 821B9F3Ch case    0:*/		regs.R11 = regs.R21;
		/* 821B9F3Ch case    0:*/		return 0x821B9F40;
	}
	return 0x821B9F40;
} // Block from 821B9F3Ch-821B9F40h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821B9F40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9F40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9F40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9F40);
		  /* 821B9F40h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821B9F40h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821B9F40h case    0:*/		return 0x821B9F44;
		  /* 821B9F44h */ case    1:  		/* bc 4, CR0_EQ, 116 */
		/* 821B9F44h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821B9FB8;  }
		/* 821B9F44h case    1:*/		return 0x821B9F48;
		  /* 821B9F48h */ case    2:  		/* mr R29, R31 */
		/* 821B9F48h case    2:*/		regs.R29 = regs.R31;
		/* 821B9F48h case    2:*/		return 0x821B9F4C;
		  /* 821B9F4Ch */ case    3:  		/* lwz R30, <#[R29]> */
		/* 821B9F4Ch case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R29 + 0x00000000) );
		/* 821B9F4Ch case    3:*/		return 0x821B9F50;
		  /* 821B9F50h */ case    4:  		/* cmplwi CR6, R30, 0 */
		/* 821B9F50h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821B9F50h case    4:*/		return 0x821B9F54;
		  /* 821B9F54h */ case    5:  		/* bc 12, CR6_EQ, 100 */
		/* 821B9F54h case    5:*/		if ( regs.CR[6].eq ) { return 0x821B9FB8;  }
		/* 821B9F54h case    5:*/		return 0x821B9F58;
		  /* 821B9F58h */ case    6:  		/* li R5, 1 */
		/* 821B9F58h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 821B9F58h case    6:*/		return 0x821B9F5C;
		  /* 821B9F5Ch */ case    7:  		/* mr R4, R30 */
		/* 821B9F5Ch case    7:*/		regs.R4 = regs.R30;
		/* 821B9F5Ch case    7:*/		return 0x821B9F60;
		  /* 821B9F60h */ case    8:  		/* mr R3, R15 */
		/* 821B9F60h case    8:*/		regs.R3 = regs.R15;
		/* 821B9F60h case    8:*/		return 0x821B9F64;
		  /* 821B9F64h */ case    9:  		/* bl -10572 */
		/* 821B9F64h case    9:*/		regs.LR = 0x821B9F68; return 0x821B7618;
		/* 821B9F64h case    9:*/		return 0x821B9F68;
		  /* 821B9F68h */ case   10:  		/* lwz R11, <#[R29]> */
		/* 821B9F68h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 821B9F68h case   10:*/		return 0x821B9F6C;
		  /* 821B9F6Ch */ case   11:  		/* cmplw CR6, R11, R30 */
		/* 821B9F6Ch case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 821B9F6Ch case   11:*/		return 0x821B9F70;
		  /* 821B9F70h */ case   12:  		/* bc 4, CR6_EQ, -36 */
		/* 821B9F70h case   12:*/		if ( !regs.CR[6].eq ) { return 0x821B9F4C;  }
		/* 821B9F70h case   12:*/		return 0x821B9F74;
		  /* 821B9F74h */ case   13:  		/* addi R29, R30, 4 */
		/* 821B9F74h case   13:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R30,0x4);
		/* 821B9F74h case   13:*/		return 0x821B9F78;
		  /* 821B9F78h */ case   14:  		/* b -44 */
		/* 821B9F78h case   14:*/		return 0x821B9F4C;
		/* 821B9F78h case   14:*/		return 0x821B9F7C;
	}
	return 0x821B9F7C;
} // Block from 821B9F40h-821B9F7Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 821B9F7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9F7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9F7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9F7C);
		  /* 821B9F7Ch */ case    0:  		/* rlwinm R11, R16, 0, 0, 30 */
		/* 821B9F7Ch case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R16);
		/* 821B9F7Ch case    0:*/		return 0x821B9F80;
		  /* 821B9F80h */ case    1:  		/* rlwinm R10, R31, 0, 0, 30 */
		/* 821B9F80h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R31);
		/* 821B9F80h case    1:*/		return 0x821B9F84;
		  /* 821B9F84h */ case    2:  		/* addi R11, R11, 36 */
		/* 821B9F84h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821B9F84h case    2:*/		return 0x821B9F88;
		  /* 821B9F88h */ case    3:  		/* addi R10, R10, 36 */
		/* 821B9F88h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 821B9F88h case    3:*/		return 0x821B9F8C;
		  /* 821B9F8Ch */ case    4:  		/* addi R9, R11, 4 */
		/* 821B9F8Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821B9F8Ch case    4:*/		return 0x821B9F90;
		  /* 821B9F90h */ case    5:  		/* addi R8, R10, 4 */
		/* 821B9F90h case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x4);
		/* 821B9F90h case    5:*/		return 0x821B9F94;
		  /* 821B9F94h */ case    6:  		/* addi R7, R10, -36 */
		/* 821B9F94h case    6:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0xFFFFFFDC);
		/* 821B9F94h case    6:*/		return 0x821B9F98;
		  /* 821B9F98h */ case    7:  		/* lwz R6, <#[R11 + 4]> */
		/* 821B9F98h case    7:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821B9F98h case    7:*/		return 0x821B9F9C;
		  /* 821B9F9Ch */ case    8:  		/* mr R25, R31 */
		/* 821B9F9Ch case    8:*/		regs.R25 = regs.R31;
		/* 821B9F9Ch case    8:*/		return 0x821B9FA0;
		  /* 821B9FA0h */ case    9:  		/* stw R6, <#[R10 + 4]> */
		/* 821B9FA0h case    9:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 821B9FA0h case    9:*/		return 0x821B9FA4;
		  /* 821B9FA4h */ case   10:  		/* lwz R6, <#[R11 + 4]> */
		/* 821B9FA4h case   10:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821B9FA4h case   10:*/		return 0x821B9FA8;
		  /* 821B9FA8h */ case   11:  		/* rlwinm R6, R6, 0, 0, 30 */
		/* 821B9FA8h case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R6);
		/* 821B9FA8h case   11:*/		return 0x821B9FAC;
		  /* 821B9FACh */ case   12:  		/* stw R8, <#[R6 + 36]> */
		/* 821B9FACh case   12:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R6 + 0x00000024) );
		/* 821B9FACh case   12:*/		return 0x821B9FB0;
		  /* 821B9FB0h */ case   13:  		/* stw R9, <#[R10]> */
		/* 821B9FB0h case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821B9FB0h case   13:*/		return 0x821B9FB4;
		  /* 821B9FB4h */ case   14:  		/* stw R7, <#[R11 + 4]> */
		/* 821B9FB4h case   14:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 821B9FB4h case   14:*/		return 0x821B9FB8;
	}
	return 0x821B9FB8;
} // Block from 821B9F7Ch-821B9FB8h (15 instructions)

//////////////////////////////////////////////////////
// Block at 821B9FB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9FB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9FB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9FB8);
		  /* 821B9FB8h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 821B9FB8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821B9FB8h case    0:*/		return 0x821B9FBC;
		  /* 821B9FBCh */ case    1:  		/* ori R11, R11, 1 */
		/* 821B9FBCh case    1:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821B9FBCh case    1:*/		return 0x821B9FC0;
		  /* 821B9FC0h */ case    2:  		/* stw R11, <#[R31 + 8]> */
		/* 821B9FC0h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821B9FC0h case    2:*/		return 0x821B9FC4;
	}
	return 0x821B9FC4;
} // Block from 821B9FB8h-821B9FC4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821B9FC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821B9FC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821B9FC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821B9FC4);
		  /* 821B9FC4h */ case    0:  		/* lwz R11, <#[R26 + 8]> */
		/* 821B9FC4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 821B9FC4h case    0:*/		return 0x821B9FC8;
		  /* 821B9FC8h */ case    1:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821B9FC8h case    1:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821B9FC8h case    1:*/		return 0x821B9FCC;
		  /* 821B9FCCh */ case    2:  		/* cmplwi CR6, R11, 14336 */
		/* 821B9FCCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003800);
		/* 821B9FCCh case    2:*/		return 0x821B9FD0;
		  /* 821B9FD0h */ case    3:  		/* bc 4, CR6_EQ, 160 */
		/* 821B9FD0h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821BA070;  }
		/* 821B9FD0h case    3:*/		return 0x821B9FD4;
		  /* 821B9FD4h */ case    4:  		/* addi R7, R26, 4 */
		/* 821B9FD4h case    4:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R26,0x4);
		/* 821B9FD4h case    4:*/		return 0x821B9FD8;
		  /* 821B9FD8h */ case    5:  		/* lwz R11, <#[R7]> */
		/* 821B9FD8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 821B9FD8h case    5:*/		return 0x821B9FDC;
		  /* 821B9FDCh */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 821B9FDCh case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821B9FDCh case    6:*/		return 0x821B9FE0;
		  /* 821B9FE0h */ case    7:  		/* bc 12, CR6_EQ, 280 */
		/* 821B9FE0h case    7:*/		if ( regs.CR[6].eq ) { return 0x821BA0F8;  }
		/* 821B9FE0h case    7:*/		return 0x821B9FE4;
		  /* 821B9FE4h */ case    8:  		/* lwz R10, <#[R11 + 16]> */
		/* 821B9FE4h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 821B9FE4h case    8:*/		return 0x821B9FE8;
		  /* 821B9FE8h */ case    9:  		/* cmplwi CR6, R10, 0 */
		/* 821B9FE8h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821B9FE8h case    9:*/		return 0x821B9FEC;
		  /* 821B9FECh */ case   10:  		/* bc 12, CR6_EQ, 112 */
		/* 821B9FECh case   10:*/		if ( regs.CR[6].eq ) { return 0x821BA05C;  }
		/* 821B9FECh case   10:*/		return 0x821B9FF0;
		  /* 821B9FF0h */ case   11:  		/* lwz R10, <#[R11 + 12]> */
		/* 821B9FF0h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 821B9FF0h case   11:*/		return 0x821B9FF4;
		  /* 821B9FF4h */ case   12:  		/* addi R10, R10, 4 */
		/* 821B9FF4h case   12:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821B9FF4h case   12:*/		return 0x821B9FF8;
		  /* 821B9FF8h */ case   13:  		/* lwz R9, <#[R10]> */
		/* 821B9FF8h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821B9FF8h case   13:*/		return 0x821B9FFC;
		  /* 821B9FFCh */ case   14:  		/* b 12 */
		/* 821B9FFCh case   14:*/		return 0x821BA008;
		/* 821B9FFCh case   14:*/		return 0x821BA000;
		  /* 821BA000h */ case   15:  		/* addi R10, R9, 8 */
		/* 821BA000h case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x8);
		/* 821BA000h case   15:*/		return 0x821BA004;
		  /* 821BA004h */ case   16:  		/* lwz R9, <#[R9 + 8]> */
		/* 821BA004h case   16:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 821BA004h case   16:*/		return 0x821BA008;
	}
	return 0x821BA008;
} // Block from 821B9FC4h-821BA008h (17 instructions)

//////////////////////////////////////////////////////
// Block at 821BA008h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA008( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA008) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA008);
		  /* 821BA008h */ case    0:  		/* cmplw CR6, R9, R11 */
		/* 821BA008h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 821BA008h case    0:*/		return 0x821BA00C;
		  /* 821BA00Ch */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 821BA00Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BA000;  }
		/* 821BA00Ch case    1:*/		return 0x821BA010;
		  /* 821BA010h */ case    2:  		/* lwz R8, <#[R11 + 8]> */
		/* 821BA010h case    2:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000008) );
		/* 821BA010h case    2:*/		return 0x821BA014;
		  /* 821BA014h */ case    3:  		/* mr R9, R21 */
		/* 821BA014h case    3:*/		regs.R9 = regs.R21;
		/* 821BA014h case    3:*/		return 0x821BA018;
		  /* 821BA018h */ case    4:  		/* stw R8, <#[R10]> */
		/* 821BA018h case    4:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 821BA018h case    4:*/		return 0x821BA01C;
		  /* 821BA01Ch */ case    5:  		/* rlwinm. R6, R21, 0, 31, 31 */
		/* 821BA01Ch case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R6,regs.R21);
		/* 821BA01Ch case    5:*/		return 0x821BA020;
		  /* 821BA020h */ case    6:  		/* lwz R10, <#[R31 + 4]> */
		/* 821BA020h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 821BA020h case    6:*/		return 0x821BA024;
		  /* 821BA024h */ case    7:  		/* stw R10, <#[R11 + 8]> */
		/* 821BA024h case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821BA024h case    7:*/		return 0x821BA028;
		  /* 821BA028h */ case    8:  		/* stw R11, <#[R31 + 4]> */
		/* 821BA028h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 821BA028h case    8:*/		return 0x821BA02C;
		  /* 821BA02Ch */ case    9:  		/* lwz R10, <#[R11]> */
		/* 821BA02Ch case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821BA02Ch case    9:*/		return 0x821BA030;
		  /* 821BA030h */ case   10:  		/* rlwinm R10, R10, 0, 27, 18 */
		/* 821BA030h case   10:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R10,regs.R10);
		/* 821BA030h case   10:*/		return 0x821BA034;
		  /* 821BA034h */ case   11:  		/* stw R31, <#[R11 + 12]> */
		/* 821BA034h case   11:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x0000000C) );
		/* 821BA034h case   11:*/		return 0x821BA038;
		  /* 821BA038h */ case   12:  		/* rlwinm R8, R10, 0, 27, 31 */
		/* 821BA038h case   12:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R8,regs.R10);
		/* 821BA038h case   12:*/		return 0x821BA03C;
		  /* 821BA03Ch */ case   13:  		/* stw R10, <#[R11]> */
		/* 821BA03Ch case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821BA03Ch case   13:*/		return 0x821BA040;
		  /* 821BA040h */ case   14:  		/* bc 12, CR0_EQ, 16 */
		/* 821BA040h case   14:*/		if ( regs.CR[0].eq ) { return 0x821BA050;  }
		/* 821BA040h case   14:*/		return 0x821BA044;
		  /* 821BA044h */ case   15:  		/* rlwinm. R6, R8, 0, 30, 30 */
		/* 821BA044h case   15:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R6,regs.R8);
		/* 821BA044h case   15:*/		return 0x821BA048;
		  /* 821BA048h */ case   16:  		/* bc 12, CR0_EQ, 8 */
		/* 821BA048h case   16:*/		if ( regs.CR[0].eq ) { return 0x821BA050;  }
		/* 821BA048h case   16:*/		return 0x821BA04C;
		  /* 821BA04Ch */ case   17:  		/* addi R8, R8, -2 */
		/* 821BA04Ch case   17:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFFE);
		/* 821BA04Ch case   17:*/		return 0x821BA050;
	}
	return 0x821BA050;
} // Block from 821BA008h-821BA050h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821BA050h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA050( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA050) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA050);
		  /* 821BA050h */ case    0:  		/* or R9, R9, R8 */
		/* 821BA050h case    0:*/		cpu::op::or<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 821BA050h case    0:*/		return 0x821BA054;
		  /* 821BA054h */ case    1:  		/* rlwimi R9, R10, 0, 0, 26 */
		/* 821BA054h case    1:*/		cpu::op::rlwimi<0,0,0,26>(regs,&regs.R9,regs.R10);
		/* 821BA054h case    1:*/		return 0x821BA058;
		  /* 821BA058h */ case    2:  		/* stw R9, <#[R11]> */
		/* 821BA058h case    2:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821BA058h case    2:*/		return 0x821BA05C;
	}
	return 0x821BA05C;
} // Block from 821BA050h-821BA05Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BA05Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA05C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA05C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA05C);
		  /* 821BA05Ch */ case    0:  		/* lwz R10, <#[R7]> */
		/* 821BA05Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + 0x00000000) );
		/* 821BA05Ch case    0:*/		return 0x821BA060;
		  /* 821BA060h */ case    1:  		/* cmplw CR6, R10, R11 */
		/* 821BA060h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 821BA060h case    1:*/		return 0x821BA064;
		  /* 821BA064h */ case    2:  		/* bc 4, CR6_EQ, -140 */
		/* 821BA064h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821B9FD8;  }
		/* 821BA064h case    2:*/		return 0x821BA068;
		  /* 821BA068h */ case    3:  		/* addi R7, R11, 8 */
		/* 821BA068h case    3:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0x8);
		/* 821BA068h case    3:*/		return 0x821BA06C;
		  /* 821BA06Ch */ case    4:  		/* b -148 */
		/* 821BA06Ch case    4:*/		return 0x821B9FD8;
		/* 821BA06Ch case    4:*/		return 0x821BA070;
	}
	return 0x821BA070;
} // Block from 821BA05Ch-821BA070h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BA070h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA070( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA070) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA070);
		  /* 821BA070h */ case    0:  		/* lwz R11, <#[R27 + 12]> */
		/* 821BA070h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000000C) );
		/* 821BA070h case    0:*/		return 0x821BA074;
		  /* 821BA074h */ case    1:  		/* addi R11, R11, 4 */
		/* 821BA074h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821BA074h case    1:*/		return 0x821BA078;
		  /* 821BA078h */ case    2:  		/* lwz R10, <#[R11]> */
		/* 821BA078h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821BA078h case    2:*/		return 0x821BA07C;
		  /* 821BA07Ch */ case    3:  		/* b 12 */
		/* 821BA07Ch case    3:*/		return 0x821BA088;
		/* 821BA07Ch case    3:*/		return 0x821BA080;
		  /* 821BA080h */ case    4:  		/* addi R11, R10, 8 */
		/* 821BA080h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 821BA080h case    4:*/		return 0x821BA084;
		  /* 821BA084h */ case    5:  		/* lwz R10, <#[R10 + 8]> */
		/* 821BA084h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 821BA084h case    5:*/		return 0x821BA088;
	}
	return 0x821BA088;
} // Block from 821BA070h-821BA088h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BA088h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA088( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA088) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA088);
		  /* 821BA088h */ case    0:  		/* cmplw CR6, R10, R27 */
		/* 821BA088h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R27);
		/* 821BA088h case    0:*/		return 0x821BA08C;
		  /* 821BA08Ch */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 821BA08Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BA080;  }
		/* 821BA08Ch case    1:*/		return 0x821BA090;
		  /* 821BA090h */ case    2:  		/* lwz R10, <#[R27 + 8]> */
		/* 821BA090h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000008) );
		/* 821BA090h case    2:*/		return 0x821BA094;
		  /* 821BA094h */ case    3:  		/* lwz R9, <#[R1 + 88]> */
		/* 821BA094h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000058) );
		/* 821BA094h case    3:*/		return 0x821BA098;
		  /* 821BA098h */ case    4:  		/* add R9, R28, R9 */
		/* 821BA098h case    4:*/		cpu::op::add<0>(regs,&regs.R9,regs.R28,regs.R9);
		/* 821BA098h case    4:*/		return 0x821BA09C;
		  /* 821BA09Ch */ case    5:  		/* stw R10, <#[R11]> */
		/* 821BA09Ch case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821BA09Ch case    5:*/		return 0x821BA0A0;
		  /* 821BA0A0h */ case    6:  		/* lwz R11, <#[R31 + 4]> */
		/* 821BA0A0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 821BA0A0h case    6:*/		return 0x821BA0A4;
		  /* 821BA0A4h */ case    7:  		/* stw R11, <#[R27 + 8]> */
		/* 821BA0A4h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 821BA0A4h case    7:*/		return 0x821BA0A8;
		  /* 821BA0A8h */ case    8:  		/* stw R27, <#[R31 + 4]> */
		/* 821BA0A8h case    8:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R31 + 0x00000004) );
		/* 821BA0A8h case    8:*/		return 0x821BA0AC;
		  /* 821BA0ACh */ case    9:  		/* stw R31, <#[R27 + 12]> */
		/* 821BA0ACh case    9:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R27 + 0x0000000C) );
		/* 821BA0ACh case    9:*/		return 0x821BA0B0;
		  /* 821BA0B0h */ case   10:  		/* lwz R10, <#[R27]> */
		/* 821BA0B0h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000000) );
		/* 821BA0B0h case   10:*/		return 0x821BA0B4;
		  /* 821BA0B4h */ case   11:  		/* rlwinm R8, R10, 24, 29, 30 */
		/* 821BA0B4h case   11:*/		cpu::op::rlwinm<0,24,29,30>(regs,&regs.R8,regs.R10);
		/* 821BA0B4h case   11:*/		return 0x821BA0B8;
		  /* 821BA0B8h */ case   12:  		/* lbz R11, <#[R9 - 1]> */
		/* 821BA0B8h case   12:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R9 + 0xFFFFFFFF) );
		/* 821BA0B8h case   12:*/		return 0x821BA0BC;
		  /* 821BA0BCh */ case   13:  		/* rlwinm R9, R10, 22, 29, 30 */
		/* 821BA0BCh case   13:*/		cpu::op::rlwinm<0,22,29,30>(regs,&regs.R9,regs.R10);
		/* 821BA0BCh case   13:*/		return 0x821BA0C0;
		  /* 821BA0C0h */ case   14:  		/* srw R9, R11, R9 */
		/* 821BA0C0h case   14:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 821BA0C0h case   14:*/		return 0x821BA0C4;
		  /* 821BA0C4h */ case   15:  		/* srw R8, R11, R8 */
		/* 821BA0C4h case   15:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R11,regs.R8);
		/* 821BA0C4h case   15:*/		return 0x821BA0C8;
		  /* 821BA0C8h */ case   16:  		/* rlwinm R7, R10, 26, 29, 30 */
		/* 821BA0C8h case   16:*/		cpu::op::rlwinm<0,26,29,30>(regs,&regs.R7,regs.R10);
		/* 821BA0C8h case   16:*/		return 0x821BA0CC;
		  /* 821BA0CCh */ case   17:  		/* rlwimi R8, R9, 2, 28, 29 */
		/* 821BA0CCh case   17:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R8,regs.R9);
		/* 821BA0CCh case   17:*/		return 0x821BA0D0;
		  /* 821BA0D0h */ case   18:  		/* srw R7, R11, R7 */
		/* 821BA0D0h case   18:*/		cpu::op::srw<0>(regs,&regs.R7,regs.R11,regs.R7);
		/* 821BA0D0h case   18:*/		return 0x821BA0D4;
		  /* 821BA0D4h */ case   19:  		/* rlwinm R9, R10, 28, 29, 30 */
		/* 821BA0D4h case   19:*/		cpu::op::rlwinm<0,28,29,30>(regs,&regs.R9,regs.R10);
		/* 821BA0D4h case   19:*/		return 0x821BA0D8;
		  /* 821BA0D8h */ case   20:  		/* rlwinm R8, R8, 0, 28, 31 */
		/* 821BA0D8h case   20:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R8,regs.R8);
		/* 821BA0D8h case   20:*/		return 0x821BA0DC;
		  /* 821BA0DCh */ case   21:  		/* srw R11, R11, R9 */
		/* 821BA0DCh case   21:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 821BA0DCh case   21:*/		return 0x821BA0E0;
		  /* 821BA0E0h */ case   22:  		/* rlwimi R7, R8, 2, 0, 29 */
		/* 821BA0E0h case   22:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R7,regs.R8);
		/* 821BA0E0h case   22:*/		return 0x821BA0E4;
		  /* 821BA0E4h */ case   23:  		/* rlwinm R10, R10, 0, 27, 18 */
		/* 821BA0E4h case   23:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R10,regs.R10);
		/* 821BA0E4h case   23:*/		return 0x821BA0E8;
		  /* 821BA0E8h */ case   24:  		/* rlwimi R11, R7, 2, 0, 29 */
		/* 821BA0E8h case   24:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R11,regs.R7);
		/* 821BA0E8h case   24:*/		return 0x821BA0EC;
		  /* 821BA0ECh */ case   25:  		/* rlwinm R11, R11, 5, 0, 26 */
		/* 821BA0ECh case   25:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R11);
		/* 821BA0ECh case   25:*/		return 0x821BA0F0;
		  /* 821BA0F0h */ case   26:  		/* or R11, R11, R10 */
		/* 821BA0F0h case   26:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821BA0F0h case   26:*/		return 0x821BA0F4;
		  /* 821BA0F4h */ case   27:  		/* stw R11, <#[R27]> */
		/* 821BA0F4h case   27:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 821BA0F4h case   27:*/		return 0x821BA0F8;
	}
	return 0x821BA0F8;
} // Block from 821BA088h-821BA0F8h (28 instructions)

//////////////////////////////////////////////////////
// Block at 821BA0F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA0F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA0F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA0F8);
		  /* 821BA0F8h */ case    0:  		/* lwz R11, <#[R26 + 8]> */
		/* 821BA0F8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 821BA0F8h case    0:*/		return 0x821BA0FC;
		  /* 821BA0FCh */ case    1:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821BA0FCh case    1:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821BA0FCh case    1:*/		return 0x821BA100;
		  /* 821BA100h */ case    2:  		/* cmplwi CR6, R11, 14336 */
		/* 821BA100h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003800);
		/* 821BA100h case    2:*/		return 0x821BA104;
		  /* 821BA104h */ case    3:  		/* bc 4, CR6_EQ, 24 */
		/* 821BA104h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821BA11C;  }
		/* 821BA104h case    3:*/		return 0x821BA108;
		  /* 821BA108h */ case    4:  		/* li R6, 1 */
		/* 821BA108h case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821BA108h case    4:*/		return 0x821BA10C;
		  /* 821BA10Ch */ case    5:  		/* li R5, 0 */
		/* 821BA10Ch case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821BA10Ch case    5:*/		return 0x821BA110;
		  /* 821BA110h */ case    6:  		/* mr R4, R26 */
		/* 821BA110h case    6:*/		regs.R4 = regs.R26;
		/* 821BA110h case    6:*/		return 0x821BA114;
		  /* 821BA114h */ case    7:  		/* mr R3, R15 */
		/* 821BA114h case    7:*/		regs.R3 = regs.R15;
		/* 821BA114h case    7:*/		return 0x821BA118;
		  /* 821BA118h */ case    8:  		/* bl 463536 */
		/* 821BA118h case    8:*/		regs.LR = 0x821BA11C; return 0x8222B3C8;
		/* 821BA118h case    8:*/		return 0x821BA11C;
	}
	return 0x821BA11C;
} // Block from 821BA0F8h-821BA11Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 821BA11Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA11C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA11C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA11C);
		  /* 821BA11Ch */ case    0:  		/* lwz R11, <#[R24]> */
		/* 821BA11Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 821BA11Ch case    0:*/		return 0x821BA120;
		  /* 821BA120h */ case    1:  		/* cmplw CR6, R11, R27 */
		/* 821BA120h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R27);
		/* 821BA120h case    1:*/		return 0x821BA124;
		  /* 821BA124h */ case    2:  		/* bc 4, CR6_EQ, -848 */
		/* 821BA124h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821B9DD4;  }
		/* 821BA124h case    2:*/		return 0x821BA128;
		  /* 821BA128h */ case    3:  		/* addi R24, R27, 8 */
		/* 821BA128h case    3:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R27,0x8);
		/* 821BA128h case    3:*/		return 0x821BA12C;
		  /* 821BA12Ch */ case    4:  		/* b -856 */
		/* 821BA12Ch case    4:*/		return 0x821B9DD4;
		/* 821BA12Ch case    4:*/		return 0x821BA130;
	}
	return 0x821BA130;
} // Block from 821BA11Ch-821BA130h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BA130h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA130( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA130) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA130);
		  /* 821BA130h */ case    0:  		/* li R30, 0 */
		/* 821BA130h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 821BA130h case    0:*/		return 0x821BA134;
		  /* 821BA134h */ case    1:  		/* mr R6, R24 */
		/* 821BA134h case    1:*/		regs.R6 = regs.R24;
		/* 821BA134h case    1:*/		return 0x821BA138;
		  /* 821BA138h */ case    2:  		/* cmplwi CR6, R6, 0 */
		/* 821BA138h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000000);
		/* 821BA138h case    2:*/		return 0x821BA13C;
		  /* 821BA13Ch */ case    3:  		/* bc 12, CR6_EQ, 104 */
		/* 821BA13Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x821BA1A4;  }
		/* 821BA13Ch case    3:*/		return 0x821BA140;
		  /* 821BA140h */ case    4:  		/* lwz R11, <#[R6 + 16]> */
		/* 821BA140h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R6 + 0x00000010) );
		/* 821BA140h case    4:*/		return 0x821BA144;
		  /* 821BA144h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821BA144h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BA144h case    5:*/		return 0x821BA148;
		  /* 821BA148h */ case    6:  		/* bc 12, CR6_EQ, 84 */
		/* 821BA148h case    6:*/		if ( regs.CR[6].eq ) { return 0x821BA19C;  }
		/* 821BA148h case    6:*/		return 0x821BA14C;
		  /* 821BA14Ch */ case    7:  		/* lwz R7, <#[R6]> */
		/* 821BA14Ch case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R6 + 0x00000000) );
		/* 821BA14Ch case    7:*/		return 0x821BA150;
		  /* 821BA150h */ case    8:  		/* rlwinm. R8, R7, 7, 29, 31 */
		/* 821BA150h case    8:*/		cpu::op::rlwinm<1,7,29,31>(regs,&regs.R8,regs.R7);
		/* 821BA150h case    8:*/		return 0x821BA154;
		  /* 821BA154h */ case    9:  		/* bc 12, CR0_EQ, 72 */
		/* 821BA154h case    9:*/		if ( regs.CR[0].eq ) { return 0x821BA19C;  }
		/* 821BA154h case    9:*/		return 0x821BA158;
		  /* 821BA158h */ case   10:  		/* rlwinm. R11, R7, 0, 31, 31 */
		/* 821BA158h case   10:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R7);
		/* 821BA158h case   10:*/		return 0x821BA15C;
		  /* 821BA15Ch */ case   11:  		/* bc 12, CR0_EQ, 64 */
		/* 821BA15Ch case   11:*/		if ( regs.CR[0].eq ) { return 0x821BA19C;  }
		/* 821BA15Ch case   11:*/		return 0x821BA160;
	}
	return 0x821BA160;
} // Block from 821BA130h-821BA160h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821BA160h
// Function '?CleanInBlock@Compiler@D3DXShader@@AAAXPAVBlock@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA160( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA160) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA160);
		  /* 821BA160h */ case    0:  		/* li R9, 0 */
		/* 821BA160h case    0:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821BA160h case    0:*/		return 0x821BA164;
		  /* 821BA164h */ case    1:  		/* li R11, 0 */
		/* 821BA164h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BA164h case    1:*/		return 0x821BA168;
		  /* 821BA168h */ case    2:  		/* cmplwi CR6, R8, 0 */
		/* 821BA168h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 821BA168h case    2:*/		return 0x821BA16C;
		  /* 821BA16Ch */ case    3:  		/* bc 12, CR6_EQ, 44 */
		/* 821BA16Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x821BA198;  }
		/* 821BA16Ch case    3:*/		return 0x821BA170;
		  /* 821BA170h */ case    4:  		/* li R10, 0 */
		/* 821BA170h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821BA170h case    4:*/		return 0x821BA174;
		  /* 821BA174h */ case    5:  		/* rlwinm R5, R7, 27, 24, 31 */
		/* 821BA174h case    5:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R5,regs.R7);
		/* 821BA174h case    5:*/		return 0x821BA178;
		  /* 821BA178h */ case    6:  		/* addi R11, R11, 1 */
		/* 821BA178h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821BA178h case    6:*/		return 0x821BA17C;
		  /* 821BA17Ch */ case    7:  		/* srw R5, R5, R10 */
		/* 821BA17Ch case    7:*/		cpu::op::srw<0>(regs,&regs.R5,regs.R5,regs.R10);
		/* 821BA17Ch case    7:*/		return 0x821BA180;
		  /* 821BA180h */ case    8:  		/* rlwinm R5, R5, 0, 30, 31 */
		/* 821BA180h case    8:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R5,regs.R5);
		/* 821BA180h case    8:*/		return 0x821BA184;
		  /* 821BA184h */ case    9:  		/* addi R10, R10, 2 */
		/* 821BA184h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 821BA184h case    9:*/		return 0x821BA188;
		  /* 821BA188h */ case   10:  		/* slw R5, R21, R5 */
		/* 821BA188h case   10:*/		cpu::op::slw<0>(regs,&regs.R5,regs.R21,regs.R5);
		/* 821BA188h case   10:*/		return 0x821BA18C;
		  /* 821BA18Ch */ case   11:  		/* or R9, R5, R9 */
		/* 821BA18Ch case   11:*/		cpu::op::or<0>(regs,&regs.R9,regs.R5,regs.R9);
		/* 821BA18Ch case   11:*/		return 0x821BA190;
		  /* 821BA190h */ case   12:  		/* cmplw CR6, R11, R8 */
		/* 821BA190h case   12:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 821BA190h case   12:*/		return 0x821BA194;
		  /* 821BA194h */ case   13:  		/* bc 12, CR6_LT, -32 */
		/* 821BA194h case   13:*/		if ( regs.CR[6].lt ) { return 0x821BA174;  }
		/* 821BA194h case   13:*/		return 0x821BA198;
	}
	return 0x821BA198;
} // Block from 821BA160h-821BA198h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821BA198h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA198( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA198) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA198);
		  /* 821BA198h */ case    0:  		/* or R30, R30, R9 */
		/* 821BA198h case    0:*/		cpu::op::or<0>(regs,&regs.R30,regs.R30,regs.R9);
		/* 821BA198h case    0:*/		return 0x821BA19C;
	}
	return 0x821BA19C;
} // Block from 821BA198h-821BA19Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BA19Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA19C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA19C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA19C);
		  /* 821BA19Ch */ case    0:  		/* lwz R6, <#[R6 + 8]> */
		/* 821BA19Ch case    0:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R6 + 0x00000008) );
		/* 821BA19Ch case    0:*/		return 0x821BA1A0;
		  /* 821BA1A0h */ case    1:  		/* b -104 */
		/* 821BA1A0h case    1:*/		return 0x821BA138;
		/* 821BA1A0h case    1:*/		return 0x821BA1A4;
	}
	return 0x821BA1A4;
} // Block from 821BA19Ch-821BA1A4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BA1A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA1A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA1A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA1A4);
		  /* 821BA1A4h */ case    0:  		/* lwz R11, <#[R1 + 84]> */
		/* 821BA1A4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000054) );
		/* 821BA1A4h case    0:*/		return 0x821BA1A8;
		  /* 821BA1A8h */ case    1:  		/* mr R4, R16 */
		/* 821BA1A8h case    1:*/		regs.R4 = regs.R16;
		/* 821BA1A8h case    1:*/		return 0x821BA1AC;
		  /* 821BA1ACh */ case    2:  		/* mr R3, R15 */
		/* 821BA1ACh case    2:*/		regs.R3 = regs.R15;
		/* 821BA1ACh case    2:*/		return 0x821BA1B0;
		  /* 821BA1B0h */ case    3:  		/* add R11, R30, R11 */
		/* 821BA1B0h case    3:*/		cpu::op::add<0>(regs,&regs.R11,regs.R30,regs.R11);
		/* 821BA1B0h case    3:*/		return 0x821BA1B4;
		  /* 821BA1B4h */ case    4:  		/* lbz R29, <#[R11 - 1]> */
		/* 821BA1B4h case    4:*/		cpu::mem::load8z( regs, &regs.R29, (uint32)(regs.R11 + 0xFFFFFFFF) );
		/* 821BA1B4h case    4:*/		return 0x821BA1B8;
		  /* 821BA1B8h */ case    5:  		/* bl -270776 */
		/* 821BA1B8h case    5:*/		regs.LR = 0x821BA1BC; return 0x82178000;
		/* 821BA1B8h case    5:*/		return 0x821BA1BC;
		  /* 821BA1BCh */ case    6:  		/* lis R11, -28311 */
		/* 821BA1BCh case    6:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF9169);
		/* 821BA1BCh case    6:*/		return 0x821BA1C0;
		  /* 821BA1C0h */ case    7:  		/* lis R10, 0 */
		/* 821BA1C0h case    7:*/		cpu::op::lis<0>(regs,&regs.R10,0x0);
		/* 821BA1C0h case    7:*/		return 0x821BA1C4;
		  /* 821BA1C4h */ case    8:  		/* ori R11, R11, 5192 */
		/* 821BA1C4h case    8:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1448);
		/* 821BA1C4h case    8:*/		return 0x821BA1C8;
		  /* 821BA1C8h */ case    9:  		/* ori R10, R10, 36262 */
		/* 821BA1C8h case    9:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x8DA6);
		/* 821BA1C8h case    9:*/		return 0x821BA1CC;
		  /* 821BA1CCh */ case   10:  		/* rldicl R9, R30, 0, 32 */
		/* 821BA1CCh case   10:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R9,regs.R30);
		/* 821BA1CCh case   10:*/		return 0x821BA1D0;
		  /* 821BA1D0h */ case   11:  		/* rldimi R11, R10, 32, 0 */
		/* 821BA1D0h case   11:*/		cpu::op::rldimi<0,32,0>(regs,&regs.R11,regs.R10);
		/* 821BA1D0h case   11:*/		return 0x821BA1D4;
		  /* 821BA1D4h */ case   12:  		/* lwz R10, <#[R3]> */
		/* 821BA1D4h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 821BA1D4h case   12:*/		return 0x821BA1D8;
		  /* 821BA1D8h */ case   13:  		/* li R4, 0 */
		/* 821BA1D8h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x0);
		/* 821BA1D8h case   13:*/		return 0x821BA1DC;
		  /* 821BA1DCh */ case   14:  		/* srd R11, R11, R9 */
		/* 821BA1DCh case   14:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 821BA1DCh case   14:*/		return 0x821BA1E0;
		  /* 821BA1E0h */ case   15:  		/* srd R11, R11, R9 */
		/* 821BA1E0h case   15:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 821BA1E0h case   15:*/		return 0x821BA1E4;
		  /* 821BA1E4h */ case   16:  		/* srd R11, R11, R9 */
		/* 821BA1E4h case   16:*/		cpu::op::srd<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 821BA1E4h case   16:*/		return 0x821BA1E8;
		  /* 821BA1E8h */ case   17:  		/* rlwinm R11, R11, 0, 0, 31 */
		/* 821BA1E8h case   17:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R11,regs.R11);
		/* 821BA1E8h case   17:*/		return 0x821BA1EC;
		  /* 821BA1ECh */ case   18:  		/* mr R31, R3 */
		/* 821BA1ECh case   18:*/		regs.R31 = regs.R3;
		/* 821BA1ECh case   18:*/		return 0x821BA1F0;
		  /* 821BA1F0h */ case   19:  		/* rlwimi R10, R11, 25, 4, 6 */
		/* 821BA1F0h case   19:*/		cpu::op::rlwimi<0,25,4,6>(regs,&regs.R10,regs.R11);
		/* 821BA1F0h case   19:*/		return 0x821BA1F4;
		  /* 821BA1F4h */ case   20:  		/* stw R10, <#[R3]> */
		/* 821BA1F4h case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 821BA1F4h case   20:*/		return 0x821BA1F8;
		  /* 821BA1F8h */ case   21:  		/* bl -272184 */
		/* 821BA1F8h case   21:*/		regs.LR = 0x821BA1FC; return 0x82177AC0;
		/* 821BA1F8h case   21:*/		return 0x821BA1FC;
		  /* 821BA1FCh */ case   22:  		/* lwz R11, <#[R31]> */
		/* 821BA1FCh case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821BA1FCh case   22:*/		return 0x821BA200;
		  /* 821BA200h */ case   23:  		/* rlwimi R11, R29, 5, 19, 26 */
		/* 821BA200h case   23:*/		cpu::op::rlwimi<0,5,19,26>(regs,&regs.R11,regs.R29);
		/* 821BA200h case   23:*/		return 0x821BA204;
		  /* 821BA204h */ case   24:  		/* stw R11, <#[R31]> */
		/* 821BA204h case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821BA204h case   24:*/		return 0x821BA208;
		  /* 821BA208h */ case   25:  		/* lwz R10, <#[R16 + 8]> */
		/* 821BA208h case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R16 + 0x00000008) );
		/* 821BA208h case   25:*/		return 0x821BA20C;
		  /* 821BA20Ch */ case   26:  		/* rlwinm R10, R10, 0, 18, 24 */
		/* 821BA20Ch case   26:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R10);
		/* 821BA20Ch case   26:*/		return 0x821BA210;
		  /* 821BA210h */ case   27:  		/* cmplwi CR6, R10, 15104 */
		/* 821BA210h case   27:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003B00);
		/* 821BA210h case   27:*/		return 0x821BA214;
		  /* 821BA214h */ case   28:  		/* bc 4, CR6_EQ, 12 */
		/* 821BA214h case   28:*/		if ( !regs.CR[6].eq ) { return 0x821BA220;  }
		/* 821BA214h case   28:*/		return 0x821BA218;
		  /* 821BA218h */ case   29:  		/* ori R11, R11, 8 */
		/* 821BA218h case   29:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x8);
		/* 821BA218h case   29:*/		return 0x821BA21C;
		  /* 821BA21Ch */ case   30:  		/* stw R11, <#[R31]> */
		/* 821BA21Ch case   30:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821BA21Ch case   30:*/		return 0x821BA220;
	}
	return 0x821BA220;
} // Block from 821BA1A4h-821BA220h (31 instructions)

//////////////////////////////////////////////////////
// Block at 821BA220h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA220( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA220) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA220);
		  /* 821BA220h */ case    0:  		/* mr R7, R31 */
		/* 821BA220h case    0:*/		regs.R7 = regs.R31;
		/* 821BA220h case    0:*/		return 0x821BA224;
		  /* 821BA224h */ case    1:  		/* mr R6, R31 */
		/* 821BA224h case    1:*/		regs.R6 = regs.R31;
		/* 821BA224h case    1:*/		return 0x821BA228;
		  /* 821BA228h */ case    2:  		/* li R5, 0 */
		/* 821BA228h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821BA228h case    2:*/		return 0x821BA22C;
		  /* 821BA22Ch */ case    3:  		/* mr R4, R23 */
		/* 821BA22Ch case    3:*/		regs.R4 = regs.R23;
		/* 821BA22Ch case    3:*/		return 0x821BA230;
		  /* 821BA230h */ case    4:  		/* mr R3, R15 */
		/* 821BA230h case    4:*/		regs.R3 = regs.R15;
		/* 821BA230h case    4:*/		return 0x821BA234;
		  /* 821BA234h */ case    5:  		/* bl -263164 */
		/* 821BA234h case    5:*/		regs.LR = 0x821BA238; return 0x82179E38;
		/* 821BA234h case    5:*/		return 0x821BA238;
		  /* 821BA238h */ case    6:  		/* rlwinm R10, R3, 0, 0, 30 */
		/* 821BA238h case    6:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R3);
		/* 821BA238h case    6:*/		return 0x821BA23C;
		  /* 821BA23Ch */ case    7:  		/* addi R11, R23, 16 */
		/* 821BA23Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R23,0x10);
		/* 821BA23Ch case    7:*/		return 0x821BA240;
		  /* 821BA240h */ case    8:  		/* addi R10, R10, 36 */
		/* 821BA240h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 821BA240h case    8:*/		return 0x821BA244;
		  /* 821BA244h */ case    9:  		/* cmplw CR6, R22, R11 */
		/* 821BA244h case    9:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R11);
		/* 821BA244h case    9:*/		return 0x821BA248;
		  /* 821BA248h */ case   10:  		/* addi R7, R10, -36 */
		/* 821BA248h case   10:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0xFFFFFFDC);
		/* 821BA248h case   10:*/		return 0x821BA24C;
		  /* 821BA24Ch */ case   11:  		/* bc 4, CR6_EQ, 52 */
		/* 821BA24Ch case   11:*/		if ( !regs.CR[6].eq ) { return 0x821BA280;  }
		/* 821BA24Ch case   11:*/		return 0x821BA250;
		  /* 821BA250h */ case   12:  		/* addi R11, R23, 24 */
		/* 821BA250h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R23,0x18);
		/* 821BA250h case   12:*/		return 0x821BA254;
		  /* 821BA254h */ case   13:  		/* addi R9, R10, 4 */
		/* 821BA254h case   13:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 821BA254h case   13:*/		return 0x821BA258;
		  /* 821BA258h */ case   14:  		/* addi R11, R11, 4 */
		/* 821BA258h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821BA258h case   14:*/		return 0x821BA25C;
		  /* 821BA25Ch */ case   15:  		/* ori R8, R11, 1 */
		/* 821BA25Ch case   15:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R11,0x1);
		/* 821BA25Ch case   15:*/		return 0x821BA260;
		  /* 821BA260h */ case   16:  		/* lwz R6, <#[R11]> */
		/* 821BA260h case   16:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 821BA260h case   16:*/		return 0x821BA264;
		  /* 821BA264h */ case   17:  		/* stw R6, <#[R10 + 4]> */
		/* 821BA264h case   17:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 821BA264h case   17:*/		return 0x821BA268;
		  /* 821BA268h */ case   18:  		/* lwz R6, <#[R11]> */
		/* 821BA268h case   18:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 821BA268h case   18:*/		return 0x821BA26C;
		  /* 821BA26Ch */ case   19:  		/* rlwinm R6, R6, 0, 0, 30 */
		/* 821BA26Ch case   19:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R6);
		/* 821BA26Ch case   19:*/		return 0x821BA270;
		  /* 821BA270h */ case   20:  		/* stw R9, <#[R6 + 36]> */
		/* 821BA270h case   20:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R6 + 0x00000024) );
		/* 821BA270h case   20:*/		return 0x821BA274;
		  /* 821BA274h */ case   21:  		/* stw R8, <#[R10]> */
		/* 821BA274h case   21:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 821BA274h case   21:*/		return 0x821BA278;
		  /* 821BA278h */ case   22:  		/* stw R7, <#[R11]> */
		/* 821BA278h case   22:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000000) );
		/* 821BA278h case   22:*/		return 0x821BA27C;
		  /* 821BA27Ch */ case   23:  		/* b 48 */
		/* 821BA27Ch case   23:*/		return 0x821BA2AC;
		/* 821BA27Ch case   23:*/		return 0x821BA280;
	}
	return 0x821BA280;
} // Block from 821BA220h-821BA280h (24 instructions)

//////////////////////////////////////////////////////
// Block at 821BA280h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA280( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA280) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA280);
		  /* 821BA280h */ case    0:  		/* rlwinm R11, R16, 0, 0, 30 */
		/* 821BA280h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R16);
		/* 821BA280h case    0:*/		return 0x821BA284;
		  /* 821BA284h */ case    1:  		/* addi R8, R10, 4 */
		/* 821BA284h case    1:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x4);
		/* 821BA284h case    1:*/		return 0x821BA288;
		  /* 821BA288h */ case    2:  		/* addi R11, R11, 36 */
		/* 821BA288h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821BA288h case    2:*/		return 0x821BA28C;
		  /* 821BA28Ch */ case    3:  		/* addi R9, R11, 4 */
		/* 821BA28Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821BA28Ch case    3:*/		return 0x821BA290;
		  /* 821BA290h */ case    4:  		/* lwz R6, <#[R11 + 4]> */
		/* 821BA290h case    4:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821BA290h case    4:*/		return 0x821BA294;
		  /* 821BA294h */ case    5:  		/* stw R6, <#[R10 + 4]> */
		/* 821BA294h case    5:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 821BA294h case    5:*/		return 0x821BA298;
		  /* 821BA298h */ case    6:  		/* lwz R6, <#[R11 + 4]> */
		/* 821BA298h case    6:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821BA298h case    6:*/		return 0x821BA29C;
		  /* 821BA29Ch */ case    7:  		/* rlwinm R6, R6, 0, 0, 30 */
		/* 821BA29Ch case    7:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R6);
		/* 821BA29Ch case    7:*/		return 0x821BA2A0;
		  /* 821BA2A0h */ case    8:  		/* stw R8, <#[R6 + 36]> */
		/* 821BA2A0h case    8:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R6 + 0x00000024) );
		/* 821BA2A0h case    8:*/		return 0x821BA2A4;
		  /* 821BA2A4h */ case    9:  		/* stw R9, <#[R10]> */
		/* 821BA2A4h case    9:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821BA2A4h case    9:*/		return 0x821BA2A8;
		  /* 821BA2A8h */ case   10:  		/* stw R7, <#[R11 + 4]> */
		/* 821BA2A8h case   10:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 821BA2A8h case   10:*/		return 0x821BA2AC;
	}
	return 0x821BA2AC;
} // Block from 821BA280h-821BA2ACh (11 instructions)

//////////////////////////////////////////////////////
// Block at 821BA2ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA2AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA2AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA2AC);
		  /* 821BA2ACh */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 821BA2ACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821BA2ACh case    0:*/		return 0x821BA2B0;
		  /* 821BA2B0h */ case    1:  		/* mr R8, R14 */
		/* 821BA2B0h case    1:*/		regs.R8 = regs.R14;
		/* 821BA2B0h case    1:*/		return 0x821BA2B4;
		  /* 821BA2B4h */ case    2:  		/* ori R11, R11, 1 */
		/* 821BA2B4h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821BA2B4h case    2:*/		return 0x821BA2B8;
		  /* 821BA2B8h */ case    3:  		/* stw R11, <#[R3 + 8]> */
		/* 821BA2B8h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821BA2B8h case    3:*/		return 0x821BA2BC;
		  /* 821BA2BCh */ case    4:  		/* lwz R11, <#[R8]> */
		/* 821BA2BCh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 821BA2BCh case    4:*/		return 0x821BA2C0;
		  /* 821BA2C0h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821BA2C0h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BA2C0h case    5:*/		return 0x821BA2C4;
		  /* 821BA2C4h */ case    6:  		/* bc 12, CR6_EQ, 224 */
		/* 821BA2C4h case    6:*/		if ( regs.CR[6].eq ) { return 0x821BA3A4;  }
		/* 821BA2C4h case    6:*/		return 0x821BA2C8;
		  /* 821BA2C8h */ case    7:  		/* lwz R10, <#[R11 + 16]> */
		/* 821BA2C8h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 821BA2C8h case    7:*/		return 0x821BA2CC;
		  /* 821BA2CCh */ case    8:  		/* cmplwi CR6, R10, 0 */
		/* 821BA2CCh case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821BA2CCh case    8:*/		return 0x821BA2D0;
		  /* 821BA2D0h */ case    9:  		/* bc 12, CR6_EQ, 168 */
		/* 821BA2D0h case    9:*/		if ( regs.CR[6].eq ) { return 0x821BA378;  }
		/* 821BA2D0h case    9:*/		return 0x821BA2D4;
		  /* 821BA2D4h */ case   10:  		/* lwz R10, <#[R11]> */
		/* 821BA2D4h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821BA2D4h case   10:*/		return 0x821BA2D8;
		  /* 821BA2D8h */ case   11:  		/* rlwinm. R9, R10, 0, 4, 6 */
		/* 821BA2D8h case   11:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R9,regs.R10);
		/* 821BA2D8h case   11:*/		return 0x821BA2DC;
		  /* 821BA2DCh */ case   12:  		/* bc 12, CR0_EQ, 156 */
		/* 821BA2DCh case   12:*/		if ( regs.CR[0].eq ) { return 0x821BA378;  }
		/* 821BA2DCh case   12:*/		return 0x821BA2E0;
		  /* 821BA2E0h */ case   13:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 821BA2E0h case   13:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 821BA2E0h case   13:*/		return 0x821BA2E4;
		  /* 821BA2E4h */ case   14:  		/* bc 12, CR0_EQ, 148 */
		/* 821BA2E4h case   14:*/		if ( regs.CR[0].eq ) { return 0x821BA378;  }
		/* 821BA2E4h case   14:*/		return 0x821BA2E8;
		  /* 821BA2E8h */ case   15:  		/* lwz R10, <#[R11 + 12]> */
		/* 821BA2E8h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 821BA2E8h case   15:*/		return 0x821BA2EC;
		  /* 821BA2ECh */ case   16:  		/* addi R10, R10, 4 */
		/* 821BA2ECh case   16:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821BA2ECh case   16:*/		return 0x821BA2F0;
		  /* 821BA2F0h */ case   17:  		/* lwz R9, <#[R10]> */
		/* 821BA2F0h case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821BA2F0h case   17:*/		return 0x821BA2F4;
		  /* 821BA2F4h */ case   18:  		/* b 12 */
		/* 821BA2F4h case   18:*/		return 0x821BA300;
		/* 821BA2F4h case   18:*/		return 0x821BA2F8;
		  /* 821BA2F8h */ case   19:  		/* addi R10, R9, 8 */
		/* 821BA2F8h case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x8);
		/* 821BA2F8h case   19:*/		return 0x821BA2FC;
		  /* 821BA2FCh */ case   20:  		/* lwz R9, <#[R9 + 8]> */
		/* 821BA2FCh case   20:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 821BA2FCh case   20:*/		return 0x821BA300;
	}
	return 0x821BA300;
} // Block from 821BA2ACh-821BA300h (21 instructions)

//////////////////////////////////////////////////////
// Block at 821BA300h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA300( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA300) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA300);
		  /* 821BA300h */ case    0:  		/* cmplw CR6, R9, R11 */
		/* 821BA300h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 821BA300h case    0:*/		return 0x821BA304;
		  /* 821BA304h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 821BA304h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BA2F8;  }
		/* 821BA304h case    1:*/		return 0x821BA308;
		  /* 821BA308h */ case    2:  		/* lwz R9, <#[R11 + 8]> */
		/* 821BA308h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 821BA308h case    2:*/		return 0x821BA30C;
		  /* 821BA30Ch */ case    3:  		/* lwz R7, <#[R1 + 88]> */
		/* 821BA30Ch case    3:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000058) );
		/* 821BA30Ch case    3:*/		return 0x821BA310;
		  /* 821BA310h */ case    4:  		/* add R7, R30, R7 */
		/* 821BA310h case    4:*/		cpu::op::add<0>(regs,&regs.R7,regs.R30,regs.R7);
		/* 821BA310h case    4:*/		return 0x821BA314;
		  /* 821BA314h */ case    5:  		/* stw R9, <#[R10]> */
		/* 821BA314h case    5:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821BA314h case    5:*/		return 0x821BA318;
		  /* 821BA318h */ case    6:  		/* lwz R10, <#[R3 + 4]> */
		/* 821BA318h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 821BA318h case    6:*/		return 0x821BA31C;
		  /* 821BA31Ch */ case    7:  		/* stw R10, <#[R11 + 8]> */
		/* 821BA31Ch case    7:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821BA31Ch case    7:*/		return 0x821BA320;
		  /* 821BA320h */ case    8:  		/* stw R11, <#[R3 + 4]> */
		/* 821BA320h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821BA320h case    8:*/		return 0x821BA324;
		  /* 821BA324h */ case    9:  		/* stw R3, <#[R11 + 12]> */
		/* 821BA324h case    9:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x0000000C) );
		/* 821BA324h case    9:*/		return 0x821BA328;
		  /* 821BA328h */ case   10:  		/* lbz R7, <#[R7 - 1]> */
		/* 821BA328h case   10:*/		cpu::mem::load8z( regs, &regs.R7, (uint32)(regs.R7 + 0xFFFFFFFF) );
		/* 821BA328h case   10:*/		return 0x821BA32C;
		  /* 821BA32Ch */ case   11:  		/* lwz R10, <#[R11]> */
		/* 821BA32Ch case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821BA32Ch case   11:*/		return 0x821BA330;
		  /* 821BA330h */ case   12:  		/* mr R9, R10 */
		/* 821BA330h case   12:*/		regs.R9 = regs.R10;
		/* 821BA330h case   12:*/		return 0x821BA334;
		  /* 821BA334h */ case   13:  		/* rlwinm R9, R9, 27, 24, 31 */
		/* 821BA334h case   13:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R9,regs.R9);
		/* 821BA334h case   13:*/		return 0x821BA338;
		  /* 821BA338h */ case   14:  		/* rlwinm R10, R10, 0, 29, 18 */
		/* 821BA338h case   14:*/		cpu::op::rlwinm<0,0,29,18>(regs,&regs.R10,regs.R10);
		/* 821BA338h case   14:*/		return 0x821BA33C;
		  /* 821BA33Ch */ case   15:  		/* rlwinm R6, R9, 27, 29, 30 */
		/* 821BA33Ch case   15:*/		cpu::op::rlwinm<0,27,29,30>(regs,&regs.R6,regs.R9);
		/* 821BA33Ch case   15:*/		return 0x821BA340;
		  /* 821BA340h */ case   16:  		/* rlwinm R5, R9, 29, 29, 30 */
		/* 821BA340h case   16:*/		cpu::op::rlwinm<0,29,29,30>(regs,&regs.R5,regs.R9);
		/* 821BA340h case   16:*/		return 0x821BA344;
		  /* 821BA344h */ case   17:  		/* srw R6, R7, R6 */
		/* 821BA344h case   17:*/		cpu::op::srw<0>(regs,&regs.R6,regs.R7,regs.R6);
		/* 821BA344h case   17:*/		return 0x821BA348;
		  /* 821BA348h */ case   18:  		/* srw R5, R7, R5 */
		/* 821BA348h case   18:*/		cpu::op::srw<0>(regs,&regs.R5,regs.R7,regs.R5);
		/* 821BA348h case   18:*/		return 0x821BA34C;
		  /* 821BA34Ch */ case   19:  		/* rlwimi R5, R6, 2, 28, 29 */
		/* 821BA34Ch case   19:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R5,regs.R6);
		/* 821BA34Ch case   19:*/		return 0x821BA350;
		  /* 821BA350h */ case   20:  		/* rlwinm R6, R9, 31, 29, 30 */
		/* 821BA350h case   20:*/		cpu::op::rlwinm<0,31,29,30>(regs,&regs.R6,regs.R9);
		/* 821BA350h case   20:*/		return 0x821BA354;
		  /* 821BA354h */ case   21:  		/* rlwinm R9, R9, 1, 29, 30 */
		/* 821BA354h case   21:*/		cpu::op::rlwinm<0,1,29,30>(regs,&regs.R9,regs.R9);
		/* 821BA354h case   21:*/		return 0x821BA358;
		  /* 821BA358h */ case   22:  		/* rlwinm R5, R5, 0, 28, 31 */
		/* 821BA358h case   22:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R5,regs.R5);
		/* 821BA358h case   22:*/		return 0x821BA35C;
		  /* 821BA35Ch */ case   23:  		/* srw R6, R7, R6 */
		/* 821BA35Ch case   23:*/		cpu::op::srw<0>(regs,&regs.R6,regs.R7,regs.R6);
		/* 821BA35Ch case   23:*/		return 0x821BA360;
		  /* 821BA360h */ case   24:  		/* srw R9, R7, R9 */
		/* 821BA360h case   24:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 821BA360h case   24:*/		return 0x821BA364;
		  /* 821BA364h */ case   25:  		/* rlwimi R6, R5, 2, 0, 29 */
		/* 821BA364h case   25:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R6,regs.R5);
		/* 821BA364h case   25:*/		return 0x821BA368;
		  /* 821BA368h */ case   26:  		/* rlwimi R9, R6, 2, 0, 29 */
		/* 821BA368h case   26:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R9,regs.R6);
		/* 821BA368h case   26:*/		return 0x821BA36C;
		  /* 821BA36Ch */ case   27:  		/* rlwinm R9, R9, 5, 0, 26 */
		/* 821BA36Ch case   27:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R9,regs.R9);
		/* 821BA36Ch case   27:*/		return 0x821BA370;
		  /* 821BA370h */ case   28:  		/* or R10, R9, R10 */
		/* 821BA370h case   28:*/		cpu::op::or<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 821BA370h case   28:*/		return 0x821BA374;
		  /* 821BA374h */ case   29:  		/* stw R10, <#[R11]> */
		/* 821BA374h case   29:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821BA374h case   29:*/		return 0x821BA378;
	}
	return 0x821BA378;
} // Block from 821BA300h-821BA378h (30 instructions)

//////////////////////////////////////////////////////
// Block at 821BA378h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA378( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA378) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA378);
		  /* 821BA378h */ case    0:  		/* lwz R10, <#[R8]> */
		/* 821BA378h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 821BA378h case    0:*/		return 0x821BA37C;
		  /* 821BA37Ch */ case    1:  		/* cmplw CR6, R10, R11 */
		/* 821BA37Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 821BA37Ch case    1:*/		return 0x821BA380;
		  /* 821BA380h */ case    2:  		/* bc 4, CR6_EQ, -196 */
		/* 821BA380h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821BA2BC;  }
		/* 821BA380h case    2:*/		return 0x821BA384;
		  /* 821BA384h */ case    3:  		/* addi R8, R11, 8 */
		/* 821BA384h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x8);
		/* 821BA384h case    3:*/		return 0x821BA388;
		  /* 821BA388h */ case    4:  		/* b -204 */
		/* 821BA388h case    4:*/		return 0x821BA2BC;
		/* 821BA388h case    4:*/		return 0x821BA38C;
	}
	return 0x821BA38C;
} // Block from 821BA378h-821BA38Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BA38Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA38C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA38C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA38C);
		  /* 821BA38Ch */ case    0:  		/* mr R3, R16 */
		/* 821BA38Ch case    0:*/		regs.R3 = regs.R16;
		/* 821BA38Ch case    0:*/		return 0x821BA390;
		  /* 821BA390h */ case    1:  		/* bl -148024 */
		/* 821BA390h case    1:*/		regs.LR = 0x821BA394; return 0x82196158;
		/* 821BA390h case    1:*/		return 0x821BA394;
		  /* 821BA394h */ case    2:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821BA394h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821BA394h case    2:*/		return 0x821BA398;
		  /* 821BA398h */ case    3:  		/* bc 12, CR0_EQ, 124 */
		/* 821BA398h case    3:*/		if ( regs.CR[0].eq ) { return 0x821BA414;  }
		/* 821BA398h case    3:*/		return 0x821BA39C;
		  /* 821BA39Ch */ case    4:  		/* ori R11, R27, 1 */
		/* 821BA39Ch case    4:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R27,0x1);
		/* 821BA39Ch case    4:*/		return 0x821BA3A0;
		  /* 821BA3A0h */ case    5:  		/* stw R11, <#[R16 + 8]> */
		/* 821BA3A0h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R16 + 0x00000008) );
		/* 821BA3A0h case    5:*/		return 0x821BA3A4;
	}
	return 0x821BA3A4;
} // Block from 821BA38Ch-821BA3A4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BA3A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA3A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA3A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA3A4);
		  /* 821BA3A4h */ case    0:  		/* lwz R11, <#[R16 + 8]> */
		/* 821BA3A4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000008) );
		/* 821BA3A4h case    0:*/		return 0x821BA3A8;
		  /* 821BA3A8h */ case    1:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821BA3A8h case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821BA3A8h case    1:*/		return 0x821BA3AC;
		  /* 821BA3ACh */ case    2:  		/* cmplwi CR6, R11, 112 */
		/* 821BA3ACh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000070);
		/* 821BA3ACh case    2:*/		return 0x821BA3B0;
		  /* 821BA3B0h */ case    3:  		/* bc 12, CR6_EQ, 20 */
		/* 821BA3B0h case    3:*/		if ( regs.CR[6].eq ) { return 0x821BA3C4;  }
		/* 821BA3B0h case    3:*/		return 0x821BA3B4;
		  /* 821BA3B4h */ case    4:  		/* cmplwi CR6, R11, 117 */
		/* 821BA3B4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000075);
		/* 821BA3B4h case    4:*/		return 0x821BA3B8;
		  /* 821BA3B8h */ case    5:  		/* bc 12, CR6_EQ, 12 */
		/* 821BA3B8h case    5:*/		if ( regs.CR[6].eq ) { return 0x821BA3C4;  }
		/* 821BA3B8h case    5:*/		return 0x821BA3BC;
		  /* 821BA3BCh */ case    6:  		/* cmplwi CR6, R11, 104 */
		/* 821BA3BCh case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000068);
		/* 821BA3BCh case    6:*/		return 0x821BA3C0;
		  /* 821BA3C0h */ case    7:  		/* bc 4, CR6_EQ, 1236 */
		/* 821BA3C0h case    7:*/		if ( !regs.CR[6].eq ) { return 0x821BA894;  }
		/* 821BA3C0h case    7:*/		return 0x821BA3C4;
	}
	return 0x821BA3C4;
} // Block from 821BA3A4h-821BA3C4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821BA3C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA3C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA3C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA3C4);
		  /* 821BA3C4h */ case    0:  		/* mr R25, R16 */
		/* 821BA3C4h case    0:*/		regs.R25 = regs.R16;
		/* 821BA3C4h case    0:*/		return 0x821BA3C8;
		  /* 821BA3C8h */ case    1:  		/* lwz R29, <#[R25]> */
		/* 821BA3C8h case    1:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R25 + 0x00000000) );
		/* 821BA3C8h case    1:*/		return 0x821BA3CC;
		  /* 821BA3CCh */ case    2:  		/* cmplwi CR6, R29, 0 */
		/* 821BA3CCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 821BA3CCh case    2:*/		return 0x821BA3D0;
		  /* 821BA3D0h */ case    3:  		/* bc 12, CR6_EQ, 1220 */
		/* 821BA3D0h case    3:*/		if ( regs.CR[6].eq ) { return 0x821BA894;  }
		/* 821BA3D0h case    3:*/		return 0x821BA3D4;
		  /* 821BA3D4h */ case    4:  		/* lwz R30, <#[R29]> */
		/* 821BA3D4h case    4:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R29 + 0x00000000) );
		/* 821BA3D4h case    4:*/		return 0x821BA3D8;
		  /* 821BA3D8h */ case    5:  		/* rlwinm. R11, R30, 0, 4, 6 */
		/* 821BA3D8h case    5:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R30);
		/* 821BA3D8h case    5:*/		return 0x821BA3DC;
		  /* 821BA3DCh */ case    6:  		/* bc 12, CR0_EQ, 1188 */
		/* 821BA3DCh case    6:*/		if ( regs.CR[0].eq ) { return 0x821BA880;  }
		/* 821BA3DCh case    6:*/		return 0x821BA3E0;
		  /* 821BA3E0h */ case    7:  		/* rlwinm R4, R30, 0, 27, 30 */
		/* 821BA3E0h case    7:*/		cpu::op::rlwinm<0,0,27,30>(regs,&regs.R4,regs.R30);
		/* 821BA3E0h case    7:*/		return 0x821BA3E4;
		  /* 821BA3E4h */ case    8:  		/* lwz R26, <#[R29 + 12]> */
		/* 821BA3E4h case    8:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R29 + 0x0000000C) );
		/* 821BA3E4h case    8:*/		return 0x821BA3E8;
		  /* 821BA3E8h */ case    9:  		/* mr R3, R16 */
		/* 821BA3E8h case    9:*/		regs.R3 = regs.R16;
		/* 821BA3E8h case    9:*/		return 0x821BA3EC;
		  /* 821BA3ECh */ case   10:  		/* bl -147804 */
		/* 821BA3ECh case   10:*/		regs.LR = 0x821BA3F0; return 0x82196290;
		/* 821BA3ECh case   10:*/		return 0x821BA3F0;
		  /* 821BA3F0h */ case   11:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821BA3F0h case   11:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821BA3F0h case   11:*/		return 0x821BA3F4;
		  /* 821BA3F4h */ case   12:  		/* bc 12, CR0_EQ, 612 */
		/* 821BA3F4h case   12:*/		if ( regs.CR[0].eq ) { return 0x821BA658;  }
		/* 821BA3F4h case   12:*/		return 0x821BA3F8;
		  /* 821BA3F8h */ case   13:  		/* lwz R11, <#[R16 + 8]> */
		/* 821BA3F8h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000008) );
		/* 821BA3F8h case   13:*/		return 0x821BA3FC;
		  /* 821BA3FCh */ case   14:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821BA3FCh case   14:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821BA3FCh case   14:*/		return 0x821BA400;
		  /* 821BA400h */ case   15:  		/* cmplwi CR6, R11, 14336 */
		/* 821BA400h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003800);
		/* 821BA400h case   15:*/		return 0x821BA404;
		  /* 821BA404h */ case   16:  		/* bc 4, CR6_EQ, 1148 */
		/* 821BA404h case   16:*/		if ( !regs.CR[6].eq ) { return 0x821BA880;  }
		/* 821BA404h case   16:*/		return 0x821BA408;
		  /* 821BA408h */ case   17:  		/* lwz R10, <#[R26 + 8]> */
		/* 821BA408h case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000008) );
		/* 821BA408h case   17:*/		return 0x821BA40C;
		  /* 821BA40Ch */ case   18:  		/* addi R11, R26, 8 */
		/* 821BA40Ch case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0x8);
		/* 821BA40Ch case   18:*/		return 0x821BA410;
		  /* 821BA410h */ case   19:  		/* b 520 */
		/* 821BA410h case   19:*/		return 0x821BA618;
		/* 821BA410h case   19:*/		return 0x821BA414;
	}
	return 0x821BA414;
} // Block from 821BA3C4h-821BA414h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821BA414h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA414( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA414) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA414);
		  /* 821BA414h */ case    0:  		/* lwz R11, <#[R16]> */
		/* 821BA414h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000000) );
		/* 821BA414h case    0:*/		return 0x821BA418;
		  /* 821BA418h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 821BA418h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BA418h case    1:*/		return 0x821BA41C;
		  /* 821BA41Ch */ case    2:  		/* bc 12, CR6_EQ, 56 */
		/* 821BA41Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x821BA454;  }
		/* 821BA41Ch case    2:*/		return 0x821BA420;
		  /* 821BA420h */ case    3:  		/* lwz R10, <#[R11]> */
		/* 821BA420h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821BA420h case    3:*/		return 0x821BA424;
		  /* 821BA424h */ case    4:  		/* rlwinm. R9, R10, 0, 4, 6 */
		/* 821BA424h case    4:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R9,regs.R10);
		/* 821BA424h case    4:*/		return 0x821BA428;
		  /* 821BA428h */ case    5:  		/* bc 12, CR0_EQ, 36 */
		/* 821BA428h case    5:*/		if ( regs.CR[0].eq ) { return 0x821BA44C;  }
		/* 821BA428h case    5:*/		return 0x821BA42C;
		  /* 821BA42Ch */ case    6:  		/* lwz R9, <#[R11 + 12]> */
		/* 821BA42Ch case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 821BA42Ch case    6:*/		return 0x821BA430;
		  /* 821BA430h */ case    7:  		/* ori R10, R10, 1 */
		/* 821BA430h case    7:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821BA430h case    7:*/		return 0x821BA434;
		  /* 821BA434h */ case    8:  		/* stw R10, <#[R11]> */
		/* 821BA434h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821BA434h case    8:*/		return 0x821BA438;
		  /* 821BA438h */ case    9:  		/* lwz R10, <#[R9 + 8]> */
		/* 821BA438h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000008) );
		/* 821BA438h case    9:*/		return 0x821BA43C;
		  /* 821BA43Ch */ case   10:  		/* rlwinm. R8, R10, 8, 31, 31 */
		/* 821BA43Ch case   10:*/		cpu::op::rlwinm<1,8,31,31>(regs,&regs.R8,regs.R10);
		/* 821BA43Ch case   10:*/		return 0x821BA440;
		  /* 821BA440h */ case   11:  		/* bc 12, CR0_EQ, 12 */
		/* 821BA440h case   11:*/		if ( regs.CR[0].eq ) { return 0x821BA44C;  }
		/* 821BA440h case   11:*/		return 0x821BA444;
		  /* 821BA444h */ case   12:  		/* ori R10, R10, 1 */
		/* 821BA444h case   12:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821BA444h case   12:*/		return 0x821BA448;
		  /* 821BA448h */ case   13:  		/* stw R10, <#[R9 + 8]> */
		/* 821BA448h case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R9 + 0x00000008) );
		/* 821BA448h case   13:*/		return 0x821BA44C;
	}
	return 0x821BA44C;
} // Block from 821BA414h-821BA44Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 821BA44Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA44C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA44C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA44C);
		  /* 821BA44Ch */ case    0:  		/* lwz R11, <#[R11 + 4]> */
		/* 821BA44Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821BA44Ch case    0:*/		return 0x821BA450;
		  /* 821BA450h */ case    1:  		/* b -56 */
		/* 821BA450h case    1:*/		return 0x821BA418;
		/* 821BA450h case    1:*/		return 0x821BA454;
	}
	return 0x821BA454;
} // Block from 821BA44Ch-821BA454h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BA454h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA454( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA454) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA454);
		  /* 821BA454h */ case    0:  		/* lwz R11, <#[R14]> */
		/* 821BA454h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000000) );
		/* 821BA454h case    0:*/		return 0x821BA458;
		  /* 821BA458h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 821BA458h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BA458h case    1:*/		return 0x821BA45C;
		  /* 821BA45Ch */ case    2:  		/* bc 12, CR6_EQ, -184 */
		/* 821BA45Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x821BA3A4;  }
		/* 821BA45Ch case    2:*/		return 0x821BA460;
		  /* 821BA460h */ case    3:  		/* lwz R10, <#[R11 + 16]> */
		/* 821BA460h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 821BA460h case    3:*/		return 0x821BA464;
		  /* 821BA464h */ case    4:  		/* cmplwi CR6, R10, 0 */
		/* 821BA464h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821BA464h case    4:*/		return 0x821BA468;
		  /* 821BA468h */ case    5:  		/* bc 12, CR6_EQ, 24 */
		/* 821BA468h case    5:*/		if ( regs.CR[6].eq ) { return 0x821BA480;  }
		/* 821BA468h case    5:*/		return 0x821BA46C;
		  /* 821BA46Ch */ case    6:  		/* lwz R10, <#[R11]> */
		/* 821BA46Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821BA46Ch case    6:*/		return 0x821BA470;
		  /* 821BA470h */ case    7:  		/* rlwinm. R9, R10, 0, 4, 6 */
		/* 821BA470h case    7:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R9,regs.R10);
		/* 821BA470h case    7:*/		return 0x821BA474;
		  /* 821BA474h */ case    8:  		/* bc 12, CR0_EQ, 12 */
		/* 821BA474h case    8:*/		if ( regs.CR[0].eq ) { return 0x821BA480;  }
		/* 821BA474h case    8:*/		return 0x821BA478;
		  /* 821BA478h */ case    9:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 821BA478h case    9:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 821BA478h case    9:*/		return 0x821BA47C;
		  /* 821BA47Ch */ case   10:  		/* stw R10, <#[R11]> */
		/* 821BA47Ch case   10:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821BA47Ch case   10:*/		return 0x821BA480;
	}
	return 0x821BA480;
} // Block from 821BA454h-821BA480h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821BA480h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA480( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA480) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA480);
		  /* 821BA480h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 821BA480h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821BA480h case    0:*/		return 0x821BA484;
		  /* 821BA484h */ case    1:  		/* b -44 */
		/* 821BA484h case    1:*/		return 0x821BA458;
		/* 821BA484h case    1:*/		return 0x821BA488;
		  /* 821BA488h */ case    2:  		/* rlwinm R11, R30, 27, 30, 31 */
		/* 821BA488h case    2:*/		cpu::op::rlwinm<0,27,30,31>(regs,&regs.R11,regs.R30);
		/* 821BA488h case    2:*/		return 0x821BA48C;
		  /* 821BA48Ch */ case    3:  		/* lwz R10, <#[R26 + 28]> */
		/* 821BA48Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x0000001C) );
		/* 821BA48Ch case    3:*/		return 0x821BA490;
		  /* 821BA490h */ case    4:  		/* addi R11, R11, 11 */
		/* 821BA490h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xB);
		/* 821BA490h case    4:*/		return 0x821BA494;
		  /* 821BA494h */ case    5:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821BA494h case    5:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821BA494h case    5:*/		return 0x821BA498;
		  /* 821BA498h */ case    6:  		/* lwzx R11, <#[R11 + R26]> */
		/* 821BA498h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R26 + 0x00000000) );
		/* 821BA498h case    6:*/		return 0x821BA49C;
		  /* 821BA49Ch */ case    7:  		/* lwz R31, <#[R11 + 12]> */
		/* 821BA49Ch case    7:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x0000000C) );
		/* 821BA49Ch case    7:*/		return 0x821BA4A0;
		  /* 821BA4A0h */ case    8:  		/* lwz R9, <#[R31 + 28]> */
		/* 821BA4A0h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x0000001C) );
		/* 821BA4A0h case    8:*/		return 0x821BA4A4;
		  /* 821BA4A4h */ case    9:  		/* cmpw CR6, R9, R10 */
		/* 821BA4A4h case    9:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R10);
		/* 821BA4A4h case    9:*/		return 0x821BA4A8;
		  /* 821BA4A8h */ case   10:  		/* bc 4, CR6_EQ, 432 */
		/* 821BA4A8h case   10:*/		if ( !regs.CR[6].eq ) { return 0x821BA658;  }
		/* 821BA4A8h case   10:*/		return 0x821BA4AC;
		  /* 821BA4ACh */ case   11:  		/* lwz R8, <#[R11]> */
		/* 821BA4ACh case   11:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 821BA4ACh case   11:*/		return 0x821BA4B0;
		  /* 821BA4B0h */ case   12:  		/* rlwinm. R11, R8, 0, 27, 28 */
		/* 821BA4B0h case   12:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R11,regs.R8);
		/* 821BA4B0h case   12:*/		return 0x821BA4B4;
		  /* 821BA4B4h */ case   13:  		/* bc 4, CR0_EQ, 420 */
		/* 821BA4B4h case   13:*/		if ( !regs.CR[0].eq ) { return 0x821BA658;  }
		/* 821BA4B4h case   13:*/		return 0x821BA4B8;
		  /* 821BA4B8h */ case   14:  		/* rlwinm. R9, R8, 0, 27, 28 */
		/* 821BA4B8h case   14:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R9,regs.R8);
		/* 821BA4B8h case   14:*/		return 0x821BA4BC;
		  /* 821BA4BCh */ case   15:  		/* rlwinm R11, R30, 0, 27, 31 */
		/* 821BA4BCh case   15:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R30);
		/* 821BA4BCh case   15:*/		return 0x821BA4C0;
		  /* 821BA4C0h */ case   16:  		/* rlwinm R10, R8, 0, 27, 31 */
		/* 821BA4C0h case   16:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R8);
		/* 821BA4C0h case   16:*/		return 0x821BA4C4;
		  /* 821BA4C4h */ case   17:  		/* bc 12, CR0_EQ, 20 */
		/* 821BA4C4h case   17:*/		if ( regs.CR[0].eq ) { return 0x821BA4D8;  }
		/* 821BA4C4h case   17:*/		return 0x821BA4C8;
		  /* 821BA4C8h */ case   18:  		/* rlwinm. R9, R11, 0, 27, 28 */
		/* 821BA4C8h case   18:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R9,regs.R11);
		/* 821BA4C8h case   18:*/		return 0x821BA4CC;
		  /* 821BA4CCh */ case   19:  		/* bc 12, CR0_EQ, 12 */
		/* 821BA4CCh case   19:*/		if ( regs.CR[0].eq ) { return 0x821BA4D8;  }
		/* 821BA4CCh case   19:*/		return 0x821BA4D0;
		  /* 821BA4D0h */ case   20:  		/* li R9, 0 */
		/* 821BA4D0h case   20:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821BA4D0h case   20:*/		return 0x821BA4D4;
		  /* 821BA4D4h */ case   21:  		/* b 44 */
		/* 821BA4D4h case   21:*/		return 0x821BA500;
		/* 821BA4D4h case   21:*/		return 0x821BA4D8;
	}
	return 0x821BA4D8;
} // Block from 821BA480h-821BA4D8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821BA4D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA4D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA4D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA4D8);
		  /* 821BA4D8h */ case    0:  		/* rlwinm. R9, R10, 0, 30, 30 */
		/* 821BA4D8h case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R10);
		/* 821BA4D8h case    0:*/		return 0x821BA4DC;
		  /* 821BA4DCh */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 821BA4DCh case    1:*/		if ( regs.CR[0].eq ) { return 0x821BA4E8;  }
		/* 821BA4DCh case    1:*/		return 0x821BA4E0;
		  /* 821BA4E0h */ case    2:  		/* rlwinm. R9, R11, 0, 31, 31 */
		/* 821BA4E0h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R11);
		/* 821BA4E0h case    2:*/		return 0x821BA4E4;
		  /* 821BA4E4h */ case    3:  		/* bc 4, CR0_EQ, -20 */
		/* 821BA4E4h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BA4D0;  }
		/* 821BA4E4h case    3:*/		return 0x821BA4E8;
	}
	return 0x821BA4E8;
} // Block from 821BA4D8h-821BA4E8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BA4E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA4E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA4E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA4E8);
		  /* 821BA4E8h */ case    0:  		/* rlwinm. R9, R10, 0, 29, 29 */
		/* 821BA4E8h case    0:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R9,regs.R10);
		/* 821BA4E8h case    0:*/		return 0x821BA4EC;
		  /* 821BA4ECh */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 821BA4ECh case    1:*/		if ( regs.CR[0].eq ) { return 0x821BA4FC;  }
		/* 821BA4ECh case    1:*/		return 0x821BA4F0;
		  /* 821BA4F0h */ case    2:  		/* rlwinm. R9, R11, 0, 31, 31 */
		/* 821BA4F0h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R11);
		/* 821BA4F0h case    2:*/		return 0x821BA4F4;
		  /* 821BA4F4h */ case    3:  		/* li R9, 0 */
		/* 821BA4F4h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821BA4F4h case    3:*/		return 0x821BA4F8;
		  /* 821BA4F8h */ case    4:  		/* bc 4, CR0_EQ, 8 */
		/* 821BA4F8h case    4:*/		if ( !regs.CR[0].eq ) { return 0x821BA500;  }
		/* 821BA4F8h case    4:*/		return 0x821BA4FC;
	}
	return 0x821BA4FC;
} // Block from 821BA4E8h-821BA4FCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BA4FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA4FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA4FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA4FC);
		  /* 821BA4FCh */ case    0:  		/* mr R9, R21 */
		/* 821BA4FCh case    0:*/		regs.R9 = regs.R21;
		/* 821BA4FCh case    0:*/		return 0x821BA500;
	}
	return 0x821BA500;
} // Block from 821BA4FCh-821BA500h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BA500h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA500( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA500) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA500);
		  /* 821BA500h */ case    0:  		/* rlwinm. R9, R9, 0, 24, 31 */
		/* 821BA500h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R9,regs.R9);
		/* 821BA500h case    0:*/		return 0x821BA504;
		  /* 821BA504h */ case    1:  		/* bc 12, CR0_EQ, 340 */
		/* 821BA504h case    1:*/		if ( regs.CR[0].eq ) { return 0x821BA658;  }
		/* 821BA504h case    1:*/		return 0x821BA508;
		  /* 821BA508h */ case    2:  		/* rlwinm. R9, R10, 0, 29, 29 */
		/* 821BA508h case    2:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R9,regs.R10);
		/* 821BA508h case    2:*/		return 0x821BA50C;
		  /* 821BA50Ch */ case    3:  		/* bc 12, CR0_EQ, 16 */
		/* 821BA50Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x821BA51C;  }
		/* 821BA50Ch case    3:*/		return 0x821BA510;
		  /* 821BA510h */ case    4:  		/* rlwinm. R9, R11, 0, 30, 30 */
		/* 821BA510h case    4:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R11);
		/* 821BA510h case    4:*/		return 0x821BA514;
		  /* 821BA514h */ case    5:  		/* bc 12, CR0_EQ, 8 */
		/* 821BA514h case    5:*/		if ( regs.CR[0].eq ) { return 0x821BA51C;  }
		/* 821BA514h case    5:*/		return 0x821BA518;
		  /* 821BA518h */ case    6:  		/* addi R10, R10, -4 */
		/* 821BA518h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFC);
		/* 821BA518h case    6:*/		return 0x821BA51C;
	}
	return 0x821BA51C;
} // Block from 821BA500h-821BA51Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BA51Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA51C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA51C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA51C);
		  /* 821BA51Ch */ case    0:  		/* and R9, R10, R11 */
		/* 821BA51Ch case    0:*/		cpu::op::and<0>(regs,&regs.R9,regs.R10,regs.R11);
		/* 821BA51Ch case    0:*/		return 0x821BA520;
		  /* 821BA520h */ case    1:  		/* rlwinm. R9, R9, 0, 29, 29 */
		/* 821BA520h case    1:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R9,regs.R9);
		/* 821BA520h case    1:*/		return 0x821BA524;
		  /* 821BA524h */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 821BA524h case    2:*/		if ( regs.CR[0].eq ) { return 0x821BA530;  }
		/* 821BA524h case    2:*/		return 0x821BA528;
		  /* 821BA528h */ case    3:  		/* addi R10, R10, -4 */
		/* 821BA528h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFC);
		/* 821BA528h case    3:*/		return 0x821BA52C;
		  /* 821BA52Ch */ case    4:  		/* addi R11, R11, -4 */
		/* 821BA52Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 821BA52Ch case    4:*/		return 0x821BA530;
	}
	return 0x821BA530;
} // Block from 821BA51Ch-821BA530h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BA530h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA530);
		  /* 821BA530h */ case    0:  		/* rlwinm. R9, R10, 0, 31, 31 */
		/* 821BA530h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R10);
		/* 821BA530h case    0:*/		return 0x821BA534;
		  /* 821BA534h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 821BA534h case    1:*/		if ( regs.CR[0].eq ) { return 0x821BA544;  }
		/* 821BA534h case    1:*/		return 0x821BA538;
		  /* 821BA538h */ case    2:  		/* rlwinm. R9, R11, 0, 30, 30 */
		/* 821BA538h case    2:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R11);
		/* 821BA538h case    2:*/		return 0x821BA53C;
		  /* 821BA53Ch */ case    3:  		/* bc 12, CR0_EQ, 8 */
		/* 821BA53Ch case    3:*/		if ( regs.CR[0].eq ) { return 0x821BA544;  }
		/* 821BA53Ch case    3:*/		return 0x821BA540;
		  /* 821BA540h */ case    4:  		/* addi R11, R11, -2 */
		/* 821BA540h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFE);
		/* 821BA540h case    4:*/		return 0x821BA544;
	}
	return 0x821BA544;
} // Block from 821BA530h-821BA544h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BA544h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA544( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA544) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA544);
		  /* 821BA544h */ case    0:  		/* lwz R9, <#[R16]> */
		/* 821BA544h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R16 + 0x00000000) );
		/* 821BA544h case    0:*/		return 0x821BA548;
		  /* 821BA548h */ case    1:  		/* or R7, R10, R11 */
		/* 821BA548h case    1:*/		cpu::op::or<0>(regs,&regs.R7,regs.R10,regs.R11);
		/* 821BA548h case    1:*/		return 0x821BA54C;
		  /* 821BA54Ch */ case    2:  		/* rlwinm R6, R8, 27, 30, 31 */
		/* 821BA54Ch case    2:*/		cpu::op::rlwinm<0,27,30,31>(regs,&regs.R6,regs.R8);
		/* 821BA54Ch case    2:*/		return 0x821BA550;
		  /* 821BA550h */ case    3:  		/* cmplwi CR6, R9, 0 */
		/* 821BA550h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 821BA550h case    3:*/		return 0x821BA554;
		  /* 821BA554h */ case    4:  		/* bc 12, CR6_EQ, 20 */
		/* 821BA554h case    4:*/		if ( regs.CR[6].eq ) { return 0x821BA568;  }
		/* 821BA554h case    4:*/		return 0x821BA558;
		  /* 821BA558h */ case    5:  		/* lwz R11, <#[R9 + 4]> */
		/* 821BA558h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 821BA558h case    5:*/		return 0x821BA55C;
		  /* 821BA55Ch */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 821BA55Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BA55Ch case    6:*/		return 0x821BA560;
		  /* 821BA560h */ case    7:  		/* mr R11, R21 */
		/* 821BA560h case    7:*/		regs.R11 = regs.R21;
		/* 821BA560h case    7:*/		return 0x821BA564;
		  /* 821BA564h */ case    8:  		/* bc 4, CR6_EQ, 8 */
		/* 821BA564h case    8:*/		if ( !regs.CR[6].eq ) { return 0x821BA56C;  }
		/* 821BA564h case    8:*/		return 0x821BA568;
	}
	return 0x821BA568;
} // Block from 821BA544h-821BA568h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821BA568h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA568( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA568) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA568);
		  /* 821BA568h */ case    0:  		/* li R11, 0 */
		/* 821BA568h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BA568h case    0:*/		return 0x821BA56C;
	}
	return 0x821BA56C;
} // Block from 821BA568h-821BA56Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BA56Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA56C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA56C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA56C);
		  /* 821BA56Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821BA56Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821BA56Ch case    0:*/		return 0x821BA570;
		  /* 821BA570h */ case    1:  		/* bc 4, CR0_EQ, 32 */
		/* 821BA570h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821BA590;  }
		/* 821BA570h case    1:*/		return 0x821BA574;
		  /* 821BA574h */ case    2:  		/* li R8, 1 */
		/* 821BA574h case    2:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 821BA574h case    2:*/		return 0x821BA578;
		  /* 821BA578h */ case    3:  		/* mr R5, R31 */
		/* 821BA578h case    3:*/		regs.R5 = regs.R31;
		/* 821BA578h case    3:*/		return 0x821BA57C;
		  /* 821BA57Ch */ case    4:  		/* mr R4, R23 */
		/* 821BA57Ch case    4:*/		regs.R4 = regs.R23;
		/* 821BA57Ch case    4:*/		return 0x821BA580;
		  /* 821BA580h */ case    5:  		/* mr R3, R15 */
		/* 821BA580h case    5:*/		regs.R3 = regs.R15;
		/* 821BA580h case    5:*/		return 0x821BA584;
		  /* 821BA584h */ case    6:  		/* bl -15820 */
		/* 821BA584h case    6:*/		regs.LR = 0x821BA588; return 0x821B67B8;
		/* 821BA584h case    6:*/		return 0x821BA588;
		  /* 821BA588h */ case    7:  		/* cmplwi CR0, R3, 0 */
		/* 821BA588h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 821BA588h case    7:*/		return 0x821BA58C;
		  /* 821BA58Ch */ case    8:  		/* bc 4, CR0_EQ, 4392 */
		/* 821BA58Ch case    8:*/		if ( !regs.CR[0].eq ) { return 0x821BB6B4;  }
		/* 821BA58Ch case    8:*/		return 0x821BA590;
	}
	return 0x821BA590;
} // Block from 821BA56Ch-821BA590h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821BA590h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA590( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA590) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA590);
		  /* 821BA590h */ case    0:  		/* lwz R11, <#[R29 + 12]> */
		/* 821BA590h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 821BA590h case    0:*/		return 0x821BA594;
		  /* 821BA594h */ case    1:  		/* addi R11, R11, 4 */
		/* 821BA594h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821BA594h case    1:*/		return 0x821BA598;
		  /* 821BA598h */ case    2:  		/* lwz R10, <#[R11]> */
		/* 821BA598h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821BA598h case    2:*/		return 0x821BA59C;
		  /* 821BA59Ch */ case    3:  		/* b 12 */
		/* 821BA59Ch case    3:*/		return 0x821BA5A8;
		/* 821BA59Ch case    3:*/		return 0x821BA5A0;
		  /* 821BA5A0h */ case    4:  		/* addi R11, R10, 8 */
		/* 821BA5A0h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 821BA5A0h case    4:*/		return 0x821BA5A4;
		  /* 821BA5A4h */ case    5:  		/* lwz R10, <#[R10 + 8]> */
		/* 821BA5A4h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 821BA5A4h case    5:*/		return 0x821BA5A8;
	}
	return 0x821BA5A8;
} // Block from 821BA590h-821BA5A8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BA5A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA5A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA5A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA5A8);
		  /* 821BA5A8h */ case    0:  		/* cmplw CR6, R10, R29 */
		/* 821BA5A8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R29);
		/* 821BA5A8h case    0:*/		return 0x821BA5AC;
		  /* 821BA5ACh */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 821BA5ACh case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BA5A0;  }
		/* 821BA5ACh case    1:*/		return 0x821BA5B0;
		  /* 821BA5B0h */ case    2:  		/* lwz R10, <#[R29 + 8]> */
		/* 821BA5B0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000008) );
		/* 821BA5B0h case    2:*/		return 0x821BA5B4;
		  /* 821BA5B4h */ case    3:  		/* rlwinm R9, R6, 5, 22, 26 */
		/* 821BA5B4h case    3:*/		cpu::op::rlwinm<0,5,22,26>(regs,&regs.R9,regs.R6);
		/* 821BA5B4h case    3:*/		return 0x821BA5B8;
		  /* 821BA5B8h */ case    4:  		/* rlwinm R8, R7, 0, 27, 31 */
		/* 821BA5B8h case    4:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R8,regs.R7);
		/* 821BA5B8h case    4:*/		return 0x821BA5BC;
		  /* 821BA5BCh */ case    5:  		/* rlwinm R9, R9, 0, 25, 23 */
		/* 821BA5BCh case    5:*/		cpu::op::rlwinm<0,0,25,23>(regs,&regs.R9,regs.R9);
		/* 821BA5BCh case    5:*/		return 0x821BA5C0;
		  /* 821BA5C0h */ case    6:  		/* mr R3, R26 */
		/* 821BA5C0h case    6:*/		regs.R3 = regs.R26;
		/* 821BA5C0h case    6:*/		return 0x821BA5C4;
		  /* 821BA5C4h */ case    7:  		/* ori R9, R9, 7296 */
		/* 821BA5C4h case    7:*/		cpu::op::ori<0>(regs,&regs.R9,regs.R9,0x1C80);
		/* 821BA5C4h case    7:*/		return 0x821BA5C8;
		  /* 821BA5C8h */ case    8:  		/* stw R10, <#[R11]> */
		/* 821BA5C8h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821BA5C8h case    8:*/		return 0x821BA5CC;
		  /* 821BA5CCh */ case    9:  		/* lwz R11, <#[R31 + 4]> */
		/* 821BA5CCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 821BA5CCh case    9:*/		return 0x821BA5D0;
		  /* 821BA5D0h */ case   10:  		/* stw R11, <#[R29 + 8]> */
		/* 821BA5D0h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 821BA5D0h case   10:*/		return 0x821BA5D4;
		  /* 821BA5D4h */ case   11:  		/* stw R29, <#[R31 + 4]> */
		/* 821BA5D4h case   11:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000004) );
		/* 821BA5D4h case   11:*/		return 0x821BA5D8;
		  /* 821BA5D8h */ case   12:  		/* lwz R11, <#[R29]> */
		/* 821BA5D8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 821BA5D8h case   12:*/		return 0x821BA5DC;
		  /* 821BA5DCh */ case   13:  		/* rlwinm R11, R11, 0, 0, 24 */
		/* 821BA5DCh case   13:*/		cpu::op::rlwinm<0,0,0,24>(regs,&regs.R11,regs.R11);
		/* 821BA5DCh case   13:*/		return 0x821BA5E0;
		  /* 821BA5E0h */ case   14:  		/* rlwinm R11, R11, 0, 24, 21 */
		/* 821BA5E0h case   14:*/		cpu::op::rlwinm<0,0,24,21>(regs,&regs.R11,regs.R11);
		/* 821BA5E0h case   14:*/		return 0x821BA5E4;
		  /* 821BA5E4h */ case   15:  		/* stw R31, <#[R29 + 12]> */
		/* 821BA5E4h case   15:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R29 + 0x0000000C) );
		/* 821BA5E4h case   15:*/		return 0x821BA5E8;
		  /* 821BA5E8h */ case   16:  		/* or R11, R9, R11 */
		/* 821BA5E8h case   16:*/		cpu::op::or<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 821BA5E8h case   16:*/		return 0x821BA5EC;
		  /* 821BA5ECh */ case   17:  		/* or R11, R11, R8 */
		/* 821BA5ECh case   17:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R8);
		/* 821BA5ECh case   17:*/		return 0x821BA5F0;
		  /* 821BA5F0h */ case   18:  		/* stw R11, <#[R29]> */
		/* 821BA5F0h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 821BA5F0h case   18:*/		return 0x821BA5F4;
		  /* 821BA5F4h */ case   19:  		/* bl -351348 */
		/* 821BA5F4h case   19:*/		regs.LR = 0x821BA5F8; return 0x82164980;
		/* 821BA5F4h case   19:*/		return 0x821BA5F8;
		  /* 821BA5F8h */ case   20:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821BA5F8h case   20:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821BA5F8h case   20:*/		return 0x821BA5FC;
		  /* 821BA5FCh */ case   21:  		/* bc 12, CR0_EQ, 16 */
		/* 821BA5FCh case   21:*/		if ( regs.CR[0].eq ) { return 0x821BA60C;  }
		/* 821BA5FCh case   21:*/		return 0x821BA600;
		  /* 821BA600h */ case   22:  		/* mr R4, R26 */
		/* 821BA600h case   22:*/		regs.R4 = regs.R26;
		/* 821BA600h case   22:*/		return 0x821BA604;
		  /* 821BA604h */ case   23:  		/* mr R3, R15 */
		/* 821BA604h case   23:*/		regs.R3 = regs.R15;
		/* 821BA604h case   23:*/		return 0x821BA608;
		  /* 821BA608h */ case   24:  		/* bl 462920 */
		/* 821BA608h case   24:*/		regs.LR = 0x821BA60C; return 0x8222B650;
		/* 821BA608h case   24:*/		return 0x821BA60C;
	}
	return 0x821BA60C;
} // Block from 821BA5A8h-821BA60Ch (25 instructions)

//////////////////////////////////////////////////////
// Block at 821BA60Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA60C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA60C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA60C);
		  /* 821BA60Ch */ case    0:  		/* lwz R10, <#[R31 + 8]> */
		/* 821BA60Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 821BA60Ch case    0:*/		return 0x821BA610;
		  /* 821BA610h */ case    1:  		/* addi R11, R31, 8 */
		/* 821BA610h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0x8);
		/* 821BA610h case    1:*/		return 0x821BA614;
		  /* 821BA614h */ case    2:  		/* mr R26, R31 */
		/* 821BA614h case    2:*/		regs.R26 = regs.R31;
		/* 821BA614h case    2:*/		return 0x821BA618;
	}
	return 0x821BA618;
} // Block from 821BA60Ch-821BA618h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BA618h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA618( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA618) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA618);
		  /* 821BA618h */ case    0:  		/* rlwinm R10, R10, 0, 18, 24 */
		/* 821BA618h case    0:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R10);
		/* 821BA618h case    0:*/		return 0x821BA61C;
		  /* 821BA61Ch */ case    1:  		/* lwz R30, <#[R29]> */
		/* 821BA61Ch case    1:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R29 + 0x00000000) );
		/* 821BA61Ch case    1:*/		return 0x821BA620;
		  /* 821BA620h */ case    2:  		/* cmplwi CR6, R10, 14080 */
		/* 821BA620h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003700);
		/* 821BA620h case    2:*/		return 0x821BA624;
		  /* 821BA624h */ case    3:  		/* bc 12, CR6_EQ, -412 */
		/* 821BA624h case    3:*/		if ( regs.CR[6].eq ) { return 0x821BA488;  }
		/* 821BA624h case    3:*/		return 0x821BA628;
		  /* 821BA628h */ case    4:  		/* rlwinm. R10, R30, 0, 27, 30 */
		/* 821BA628h case    4:*/		cpu::op::rlwinm<1,0,27,30>(regs,&regs.R10,regs.R30);
		/* 821BA628h case    4:*/		return 0x821BA62C;
		  /* 821BA62Ch */ case    5:  		/* bc 4, CR0_EQ, 44 */
		/* 821BA62Ch case    5:*/		if ( !regs.CR[0].eq ) { return 0x821BA658;  }
		/* 821BA62Ch case    5:*/		return 0x821BA630;
		  /* 821BA630h */ case    6:  		/* lwz R11, <#[R11]> */
		/* 821BA630h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821BA630h case    6:*/		return 0x821BA634;
		  /* 821BA634h */ case    7:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821BA634h case    7:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821BA634h case    7:*/		return 0x821BA638;
		  /* 821BA638h */ case    8:  		/* cmplwi CR6, R11, 125 */
		/* 821BA638h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 821BA638h case    8:*/		return 0x821BA63C;
		  /* 821BA63Ch */ case    9:  		/* bc 12, CR6_EQ, 16 */
		/* 821BA63Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x821BA64C;  }
		/* 821BA63Ch case    9:*/		return 0x821BA640;
		  /* 821BA640h */ case   10:  		/* cmplwi CR6, R11, 124 */
		/* 821BA640h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 821BA640h case   10:*/		return 0x821BA644;
		  /* 821BA644h */ case   11:  		/* li R11, 0 */
		/* 821BA644h case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BA644h case   11:*/		return 0x821BA648;
		  /* 821BA648h */ case   12:  		/* bc 4, CR6_EQ, 8 */
		/* 821BA648h case   12:*/		if ( !regs.CR[6].eq ) { return 0x821BA650;  }
		/* 821BA648h case   12:*/		return 0x821BA64C;
	}
	return 0x821BA64C;
} // Block from 821BA618h-821BA64Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 821BA64Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA64C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA64C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA64C);
		  /* 821BA64Ch */ case    0:  		/* mr R11, R21 */
		/* 821BA64Ch case    0:*/		regs.R11 = regs.R21;
		/* 821BA64Ch case    0:*/		return 0x821BA650;
	}
	return 0x821BA650;
} // Block from 821BA64Ch-821BA650h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BA650h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA650( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA650) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA650);
		  /* 821BA650h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821BA650h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821BA650h case    0:*/		return 0x821BA654;
		  /* 821BA654h */ case    1:  		/* bc 12, CR0_EQ, 556 */
		/* 821BA654h case    1:*/		if ( regs.CR[0].eq ) { return 0x821BA880;  }
		/* 821BA654h case    1:*/		return 0x821BA658;
	}
	return 0x821BA658;
} // Block from 821BA650h-821BA658h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BA658h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA658( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA658) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA658);
		  /* 821BA658h */ case    0:  		/* lwz R11, <#[R16 + 8]> */
		/* 821BA658h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000008) );
		/* 821BA658h case    0:*/		return 0x821BA65C;
		  /* 821BA65Ch */ case    1:  		/* lwz R27, <#[R26 + 28]> */
		/* 821BA65Ch case    1:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R26 + 0x0000001C) );
		/* 821BA65Ch case    1:*/		return 0x821BA660;
		  /* 821BA660h */ case    2:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821BA660h case    2:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821BA660h case    2:*/		return 0x821BA664;
		  /* 821BA664h */ case    3:  		/* mr R28, R27 */
		/* 821BA664h case    3:*/		regs.R28 = regs.R27;
		/* 821BA664h case    3:*/		return 0x821BA668;
		  /* 821BA668h */ case    4:  		/* cmplwi CR6, R11, 14336 */
		/* 821BA668h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003800);
		/* 821BA668h case    4:*/		return 0x821BA66C;
		  /* 821BA66Ch */ case    5:  		/* bc 4, CR6_EQ, 52 */
		/* 821BA66Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x821BA6A0;  }
		/* 821BA66Ch case    5:*/		return 0x821BA670;
		  /* 821BA670h */ case    6:  		/* lwz R11, <#[R16]> */
		/* 821BA670h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000000) );
		/* 821BA670h case    6:*/		return 0x821BA674;
		  /* 821BA674h */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 821BA674h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BA674h case    7:*/		return 0x821BA678;
		  /* 821BA678h */ case    8:  		/* bc 12, CR6_EQ, 20 */
		/* 821BA678h case    8:*/		if ( regs.CR[6].eq ) { return 0x821BA68C;  }
		/* 821BA678h case    8:*/		return 0x821BA67C;
		  /* 821BA67Ch */ case    9:  		/* lwz R11, <#[R11 + 4]> */
		/* 821BA67Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821BA67Ch case    9:*/		return 0x821BA680;
		  /* 821BA680h */ case   10:  		/* cmplwi CR6, R11, 0 */
		/* 821BA680h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BA680h case   10:*/		return 0x821BA684;
		  /* 821BA684h */ case   11:  		/* mr R11, R21 */
		/* 821BA684h case   11:*/		regs.R11 = regs.R21;
		/* 821BA684h case   11:*/		return 0x821BA688;
		  /* 821BA688h */ case   12:  		/* bc 4, CR6_EQ, 8 */
		/* 821BA688h case   12:*/		if ( !regs.CR[6].eq ) { return 0x821BA690;  }
		/* 821BA688h case   12:*/		return 0x821BA68C;
	}
	return 0x821BA68C;
} // Block from 821BA658h-821BA68Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 821BA68Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA68C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA68C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA68C);
		  /* 821BA68Ch */ case    0:  		/* li R11, 0 */
		/* 821BA68Ch case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BA68Ch case    0:*/		return 0x821BA690;
	}
	return 0x821BA690;
} // Block from 821BA68Ch-821BA690h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BA690h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA690( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA690) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA690);
		  /* 821BA690h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821BA690h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821BA690h case    0:*/		return 0x821BA694;
		  /* 821BA694h */ case    1:  		/* bc 4, CR0_EQ, 16 */
		/* 821BA694h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821BA6A4;  }
		/* 821BA694h case    1:*/		return 0x821BA698;
		  /* 821BA698h */ case    2:  		/* rlwinm. R11, R30, 0, 27, 28 */
		/* 821BA698h case    2:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R11,regs.R30);
		/* 821BA698h case    2:*/		return 0x821BA69C;
		  /* 821BA69Ch */ case    3:  		/* bc 4, CR0_EQ, 8 */
		/* 821BA69Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BA6A4;  }
		/* 821BA69Ch case    3:*/		return 0x821BA6A0;
	}
	return 0x821BA6A0;
} // Block from 821BA690h-821BA6A0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BA6A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA6A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA6A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA6A0);
		  /* 821BA6A0h */ case    0:  		/* mr R28, R23 */
		/* 821BA6A0h case    0:*/		regs.R28 = regs.R23;
		/* 821BA6A0h case    0:*/		return 0x821BA6A4;
	}
	return 0x821BA6A4;
} // Block from 821BA6A0h-821BA6A4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BA6A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA6A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA6A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA6A4);
		  /* 821BA6A4h */ case    0:  		/* rlwinm R8, R30, 7, 29, 31 */
		/* 821BA6A4h case    0:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R8,regs.R30);
		/* 821BA6A4h case    0:*/		return 0x821BA6A8;
		  /* 821BA6A8h */ case    1:  		/* li R7, 2 */
		/* 821BA6A8h case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821BA6A8h case    1:*/		return 0x821BA6AC;
		  /* 821BA6ACh */ case    2:  		/* li R6, 3 */
		/* 821BA6ACh case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x3);
		/* 821BA6ACh case    2:*/		return 0x821BA6B0;
		  /* 821BA6B0h */ case    3:  		/* li R5, 0 */
		/* 821BA6B0h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821BA6B0h case    3:*/		return 0x821BA6B4;
		  /* 821BA6B4h */ case    4:  		/* mr R4, R28 */
		/* 821BA6B4h case    4:*/		regs.R4 = regs.R28;
		/* 821BA6B4h case    4:*/		return 0x821BA6B8;
		  /* 821BA6B8h */ case    5:  		/* mr R3, R15 */
		/* 821BA6B8h case    5:*/		regs.R3 = regs.R15;
		/* 821BA6B8h case    5:*/		return 0x821BA6BC;
		  /* 821BA6BCh */ case    6:  		/* bl 434908 */
		/* 821BA6BCh case    6:*/		regs.LR = 0x821BA6C0; return 0x82224998;
		/* 821BA6BCh case    6:*/		return 0x821BA6C0;
		  /* 821BA6C0h */ case    7:  		/* mr R31, R3 */
		/* 821BA6C0h case    7:*/		regs.R31 = regs.R3;
		/* 821BA6C0h case    7:*/		return 0x821BA6C4;
		  /* 821BA6C4h */ case    8:  		/* cmplw CR6, R28, R27 */
		/* 821BA6C4h case    8:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R27);
		/* 821BA6C4h case    8:*/		return 0x821BA6C8;
		  /* 821BA6C8h */ case    9:  		/* bc 4, CR6_EQ, 80 */
		/* 821BA6C8h case    9:*/		if ( !regs.CR[6].eq ) { return 0x821BA718;  }
		/* 821BA6C8h case    9:*/		return 0x821BA6CC;
		  /* 821BA6CCh */ case   10:  		/* mr R3, R26 */
		/* 821BA6CCh case   10:*/		regs.R3 = regs.R26;
		/* 821BA6CCh case   10:*/		return 0x821BA6D0;
		  /* 821BA6D0h */ case   11:  		/* bl -298792 */
		/* 821BA6D0h case   11:*/		regs.LR = 0x821BA6D4; return 0x821717A8;
		/* 821BA6D0h case   11:*/		return 0x821BA6D4;
		  /* 821BA6D4h */ case   12:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821BA6D4h case   12:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821BA6D4h case   12:*/		return 0x821BA6D8;
		  /* 821BA6D8h */ case   13:  		/* bc 12, CR0_EQ, 64 */
		/* 821BA6D8h case   13:*/		if ( regs.CR[0].eq ) { return 0x821BA718;  }
		/* 821BA6D8h case   13:*/		return 0x821BA6DC;
		  /* 821BA6DCh */ case   14:  		/* rlwinm R11, R26, 0, 0, 30 */
		/* 821BA6DCh case   14:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R26);
		/* 821BA6DCh case   14:*/		return 0x821BA6E0;
		  /* 821BA6E0h */ case   15:  		/* rlwinm R10, R31, 0, 0, 30 */
		/* 821BA6E0h case   15:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R31);
		/* 821BA6E0h case   15:*/		return 0x821BA6E4;
		  /* 821BA6E4h */ case   16:  		/* addi R11, R11, 36 */
		/* 821BA6E4h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821BA6E4h case   16:*/		return 0x821BA6E8;
		  /* 821BA6E8h */ case   17:  		/* addi R10, R10, 36 */
		/* 821BA6E8h case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 821BA6E8h case   17:*/		return 0x821BA6EC;
		  /* 821BA6ECh */ case   18:  		/* addi R9, R11, 4 */
		/* 821BA6ECh case   18:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821BA6ECh case   18:*/		return 0x821BA6F0;
		  /* 821BA6F0h */ case   19:  		/* addi R8, R10, 4 */
		/* 821BA6F0h case   19:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x4);
		/* 821BA6F0h case   19:*/		return 0x821BA6F4;
		  /* 821BA6F4h */ case   20:  		/* addi R7, R10, -36 */
		/* 821BA6F4h case   20:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0xFFFFFFDC);
		/* 821BA6F4h case   20:*/		return 0x821BA6F8;
		  /* 821BA6F8h */ case   21:  		/* lwz R6, <#[R11 + 4]> */
		/* 821BA6F8h case   21:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821BA6F8h case   21:*/		return 0x821BA6FC;
		  /* 821BA6FCh */ case   22:  		/* stw R6, <#[R10 + 4]> */
		/* 821BA6FCh case   22:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 821BA6FCh case   22:*/		return 0x821BA700;
		  /* 821BA700h */ case   23:  		/* lwz R6, <#[R11 + 4]> */
		/* 821BA700h case   23:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821BA700h case   23:*/		return 0x821BA704;
		  /* 821BA704h */ case   24:  		/* rlwinm R6, R6, 0, 0, 30 */
		/* 821BA704h case   24:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R6);
		/* 821BA704h case   24:*/		return 0x821BA708;
		  /* 821BA708h */ case   25:  		/* stw R8, <#[R6 + 36]> */
		/* 821BA708h case   25:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R6 + 0x00000024) );
		/* 821BA708h case   25:*/		return 0x821BA70C;
		  /* 821BA70Ch */ case   26:  		/* stw R9, <#[R10]> */
		/* 821BA70Ch case   26:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821BA70Ch case   26:*/		return 0x821BA710;
		  /* 821BA710h */ case   27:  		/* stw R7, <#[R11 + 4]> */
		/* 821BA710h case   27:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 821BA710h case   27:*/		return 0x821BA714;
		  /* 821BA714h */ case   28:  		/* b 60 */
		/* 821BA714h case   28:*/		return 0x821BA750;
		/* 821BA714h case   28:*/		return 0x821BA718;
	}
	return 0x821BA718;
} // Block from 821BA6A4h-821BA718h (29 instructions)

//////////////////////////////////////////////////////
// Block at 821BA718h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA718( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA718) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA718);
		  /* 821BA718h */ case    0:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821BA718h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821BA718h case    0:*/		return 0x821BA71C;
		  /* 821BA71Ch */ case    1:  		/* lwz R8, <#[R28 + 28]> */
		/* 821BA71Ch case    1:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R28 + 0x0000001C) );
		/* 821BA71Ch case    1:*/		return 0x821BA720;
		  /* 821BA720h */ case    2:  		/* addi R10, R28, 24 */
		/* 821BA720h case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R28,0x18);
		/* 821BA720h case    2:*/		return 0x821BA724;
		  /* 821BA724h */ case    3:  		/* addi R11, R11, 36 */
		/* 821BA724h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821BA724h case    3:*/		return 0x821BA728;
		  /* 821BA728h */ case    4:  		/* addi R10, R10, 4 */
		/* 821BA728h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821BA728h case    4:*/		return 0x821BA72C;
		  /* 821BA72Ch */ case    5:  		/* addi R9, R11, 4 */
		/* 821BA72Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821BA72Ch case    5:*/		return 0x821BA730;
		  /* 821BA730h */ case    6:  		/* ori R10, R10, 1 */
		/* 821BA730h case    6:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821BA730h case    6:*/		return 0x821BA734;
		  /* 821BA734h */ case    7:  		/* addi R7, R11, -36 */
		/* 821BA734h case    7:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFDC);
		/* 821BA734h case    7:*/		return 0x821BA738;
		  /* 821BA738h */ case    8:  		/* stw R8, <#[R11 + 4]> */
		/* 821BA738h case    8:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000004) );
		/* 821BA738h case    8:*/		return 0x821BA73C;
		  /* 821BA73Ch */ case    9:  		/* lwz R8, <#[R28 + 28]> */
		/* 821BA73Ch case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R28 + 0x0000001C) );
		/* 821BA73Ch case    9:*/		return 0x821BA740;
		  /* 821BA740h */ case   10:  		/* rlwinm R8, R8, 0, 0, 30 */
		/* 821BA740h case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R8,regs.R8);
		/* 821BA740h case   10:*/		return 0x821BA744;
		  /* 821BA744h */ case   11:  		/* stw R9, <#[R8 + 36]> */
		/* 821BA744h case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R8 + 0x00000024) );
		/* 821BA744h case   11:*/		return 0x821BA748;
		  /* 821BA748h */ case   12:  		/* stw R10, <#[R11]> */
		/* 821BA748h case   12:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821BA748h case   12:*/		return 0x821BA74C;
		  /* 821BA74Ch */ case   13:  		/* stw R7, <#[R28 + 28]> */
		/* 821BA74Ch case   13:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R28 + 0x0000001C) );
		/* 821BA74Ch case   13:*/		return 0x821BA750;
	}
	return 0x821BA750;
} // Block from 821BA718h-821BA750h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821BA750h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA750( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA750) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA750);
		  /* 821BA750h */ case    0:  		/* mr R4, R29 */
		/* 821BA750h case    0:*/		regs.R4 = regs.R29;
		/* 821BA750h case    0:*/		return 0x821BA754;
		  /* 821BA754h */ case    1:  		/* mr R3, R31 */
		/* 821BA754h case    1:*/		regs.R3 = regs.R31;
		/* 821BA754h case    1:*/		return 0x821BA758;
		  /* 821BA758h */ case    2:  		/* bl -271760 */
		/* 821BA758h case    2:*/		regs.LR = 0x821BA75C; return 0x821781C8;
		/* 821BA758h case    2:*/		return 0x821BA75C;
		  /* 821BA75Ch */ case    3:  		/* stw R3, <#[R31 + 44]> */
		/* 821BA75Ch case    3:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821BA75Ch case    3:*/		return 0x821BA760;
		  /* 821BA760h */ case    4:  		/* mr R4, R29 */
		/* 821BA760h case    4:*/		regs.R4 = regs.R29;
		/* 821BA760h case    4:*/		return 0x821BA764;
		  /* 821BA764h */ case    5:  		/* mr R3, R31 */
		/* 821BA764h case    5:*/		regs.R3 = regs.R31;
		/* 821BA764h case    5:*/		return 0x821BA768;
		  /* 821BA768h */ case    6:  		/* bl -271776 */
		/* 821BA768h case    6:*/		regs.LR = 0x821BA76C; return 0x821781C8;
		/* 821BA768h case    6:*/		return 0x821BA76C;
		  /* 821BA76Ch */ case    7:  		/* stw R3, <#[R31 + 48]> */
		/* 821BA76Ch case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821BA76Ch case    7:*/		return 0x821BA770;
		  /* 821BA770h */ case    8:  		/* lwz R11, <#[R29 + 12]> */
		/* 821BA770h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 821BA770h case    8:*/		return 0x821BA774;
		  /* 821BA774h */ case    9:  		/* addi R11, R11, 4 */
		/* 821BA774h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821BA774h case    9:*/		return 0x821BA778;
		  /* 821BA778h */ case   10:  		/* lwz R10, <#[R11]> */
		/* 821BA778h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821BA778h case   10:*/		return 0x821BA77C;
		  /* 821BA77Ch */ case   11:  		/* b 12 */
		/* 821BA77Ch case   11:*/		return 0x821BA788;
		/* 821BA77Ch case   11:*/		return 0x821BA780;
		  /* 821BA780h */ case   12:  		/* addi R11, R10, 8 */
		/* 821BA780h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 821BA780h case   12:*/		return 0x821BA784;
		  /* 821BA784h */ case   13:  		/* lwz R10, <#[R10 + 8]> */
		/* 821BA784h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 821BA784h case   13:*/		return 0x821BA788;
	}
	return 0x821BA788;
} // Block from 821BA750h-821BA788h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821BA788h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA788( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA788) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA788);
		  /* 821BA788h */ case    0:  		/* cmplw CR6, R10, R29 */
		/* 821BA788h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R29);
		/* 821BA788h case    0:*/		return 0x821BA78C;
		  /* 821BA78Ch */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 821BA78Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BA780;  }
		/* 821BA78Ch case    1:*/		return 0x821BA790;
		  /* 821BA790h */ case    2:  		/* lwz R10, <#[R29 + 8]> */
		/* 821BA790h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000008) );
		/* 821BA790h case    2:*/		return 0x821BA794;
		  /* 821BA794h */ case    3:  		/* cmplw CR6, R27, R23 */
		/* 821BA794h case    3:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R23);
		/* 821BA794h case    3:*/		return 0x821BA798;
		  /* 821BA798h */ case    4:  		/* stw R10, <#[R11]> */
		/* 821BA798h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821BA798h case    4:*/		return 0x821BA79C;
		  /* 821BA79Ch */ case    5:  		/* lwz R11, <#[R31 + 4]> */
		/* 821BA79Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 821BA79Ch case    5:*/		return 0x821BA7A0;
		  /* 821BA7A0h */ case    6:  		/* stw R11, <#[R29 + 8]> */
		/* 821BA7A0h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 821BA7A0h case    6:*/		return 0x821BA7A4;
		  /* 821BA7A4h */ case    7:  		/* stw R29, <#[R31 + 4]> */
		/* 821BA7A4h case    7:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R31 + 0x00000004) );
		/* 821BA7A4h case    7:*/		return 0x821BA7A8;
		  /* 821BA7A8h */ case    8:  		/* stw R31, <#[R29 + 12]> */
		/* 821BA7A8h case    8:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R29 + 0x0000000C) );
		/* 821BA7A8h case    8:*/		return 0x821BA7AC;
		  /* 821BA7ACh */ case    9:  		/* lwz R11, <#[R29]> */
		/* 821BA7ACh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 821BA7ACh case    9:*/		return 0x821BA7B0;
		  /* 821BA7B0h */ case   10:  		/* rlwimi R11, R20, 7, 19, 31 */
		/* 821BA7B0h case   10:*/		cpu::op::rlwimi<0,7,19,31>(regs,&regs.R11,regs.R20);
		/* 821BA7B0h case   10:*/		return 0x821BA7B4;
		  /* 821BA7B4h */ case   11:  		/* stw R11, <#[R29]> */
		/* 821BA7B4h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 821BA7B4h case   11:*/		return 0x821BA7B8;
		  /* 821BA7B8h */ case   12:  		/* bc 12, CR6_EQ, 152 */
		/* 821BA7B8h case   12:*/		if ( regs.CR[6].eq ) { return 0x821BA850;  }
		/* 821BA7B8h case   12:*/		return 0x821BA7BC;
		  /* 821BA7BCh */ case   13:  		/* cmplw CR6, R28, R23 */
		/* 821BA7BCh case   13:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R23);
		/* 821BA7BCh case   13:*/		return 0x821BA7C0;
		  /* 821BA7C0h */ case   14:  		/* bc 4, CR6_EQ, 152 */
		/* 821BA7C0h case   14:*/		if ( !regs.CR[6].eq ) { return 0x821BA858;  }
		/* 821BA7C0h case   14:*/		return 0x821BA7C4;
		  /* 821BA7C4h */ case   15:  		/* lwz R11, <#[R16 + 8]> */
		/* 821BA7C4h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000008) );
		/* 821BA7C4h case   15:*/		return 0x821BA7C8;
		  /* 821BA7C8h */ case   16:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821BA7C8h case   16:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821BA7C8h case   16:*/		return 0x821BA7CC;
		  /* 821BA7CCh */ case   17:  		/* cmplwi CR6, R11, 14336 */
		/* 821BA7CCh case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003800);
		/* 821BA7CCh case   17:*/		return 0x821BA7D0;
		  /* 821BA7D0h */ case   18:  		/* bc 4, CR6_EQ, 128 */
		/* 821BA7D0h case   18:*/		if ( !regs.CR[6].eq ) { return 0x821BA850;  }
		/* 821BA7D0h case   18:*/		return 0x821BA7D4;
		  /* 821BA7D4h */ case   19:  		/* mr R8, R14 */
		/* 821BA7D4h case   19:*/		regs.R8 = regs.R14;
		/* 821BA7D4h case   19:*/		return 0x821BA7D8;
		  /* 821BA7D8h */ case   20:  		/* lwz R11, <#[R8]> */
		/* 821BA7D8h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 821BA7D8h case   20:*/		return 0x821BA7DC;
		  /* 821BA7DCh */ case   21:  		/* cmplwi CR6, R11, 0 */
		/* 821BA7DCh case   21:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BA7DCh case   21:*/		return 0x821BA7E0;
		  /* 821BA7E0h */ case   22:  		/* bc 12, CR6_EQ, 92 */
		/* 821BA7E0h case   22:*/		if ( regs.CR[6].eq ) { return 0x821BA83C;  }
		/* 821BA7E0h case   22:*/		return 0x821BA7E4;
		  /* 821BA7E4h */ case   23:  		/* lwz R10, <#[R11 + 16]> */
		/* 821BA7E4h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 821BA7E4h case   23:*/		return 0x821BA7E8;
		  /* 821BA7E8h */ case   24:  		/* cmplwi CR6, R10, 0 */
		/* 821BA7E8h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821BA7E8h case   24:*/		return 0x821BA7EC;
		  /* 821BA7ECh */ case   25:  		/* bc 12, CR6_EQ, 60 */
		/* 821BA7ECh case   25:*/		if ( regs.CR[6].eq ) { return 0x821BA828;  }
		/* 821BA7ECh case   25:*/		return 0x821BA7F0;
		  /* 821BA7F0h */ case   26:  		/* lwz R10, <#[R11 + 12]> */
		/* 821BA7F0h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 821BA7F0h case   26:*/		return 0x821BA7F4;
		  /* 821BA7F4h */ case   27:  		/* addi R10, R10, 4 */
		/* 821BA7F4h case   27:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821BA7F4h case   27:*/		return 0x821BA7F8;
		  /* 821BA7F8h */ case   28:  		/* lwz R9, <#[R10]> */
		/* 821BA7F8h case   28:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821BA7F8h case   28:*/		return 0x821BA7FC;
		  /* 821BA7FCh */ case   29:  		/* b 12 */
		/* 821BA7FCh case   29:*/		return 0x821BA808;
		/* 821BA7FCh case   29:*/		return 0x821BA800;
		  /* 821BA800h */ case   30:  		/* addi R10, R9, 8 */
		/* 821BA800h case   30:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x8);
		/* 821BA800h case   30:*/		return 0x821BA804;
		  /* 821BA804h */ case   31:  		/* lwz R9, <#[R9 + 8]> */
		/* 821BA804h case   31:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 821BA804h case   31:*/		return 0x821BA808;
	}
	return 0x821BA808;
} // Block from 821BA788h-821BA808h (32 instructions)

//////////////////////////////////////////////////////
// Block at 821BA808h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA808( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA808) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA808);
		  /* 821BA808h */ case    0:  		/* cmplw CR6, R9, R11 */
		/* 821BA808h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 821BA808h case    0:*/		return 0x821BA80C;
		  /* 821BA80Ch */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 821BA80Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BA800;  }
		/* 821BA80Ch case    1:*/		return 0x821BA810;
		  /* 821BA810h */ case    2:  		/* lwz R9, <#[R11 + 8]> */
		/* 821BA810h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 821BA810h case    2:*/		return 0x821BA814;
		  /* 821BA814h */ case    3:  		/* stw R9, <#[R10]> */
		/* 821BA814h case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821BA814h case    3:*/		return 0x821BA818;
		  /* 821BA818h */ case    4:  		/* lwz R10, <#[R31 + 4]> */
		/* 821BA818h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 821BA818h case    4:*/		return 0x821BA81C;
		  /* 821BA81Ch */ case    5:  		/* stw R10, <#[R11 + 8]> */
		/* 821BA81Ch case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821BA81Ch case    5:*/		return 0x821BA820;
		  /* 821BA820h */ case    6:  		/* stw R11, <#[R31 + 4]> */
		/* 821BA820h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 821BA820h case    6:*/		return 0x821BA824;
		  /* 821BA824h */ case    7:  		/* stw R31, <#[R11 + 12]> */
		/* 821BA824h case    7:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x0000000C) );
		/* 821BA824h case    7:*/		return 0x821BA828;
	}
	return 0x821BA828;
} // Block from 821BA808h-821BA828h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821BA828h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA828( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA828) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA828);
		  /* 821BA828h */ case    0:  		/* lwz R10, <#[R8]> */
		/* 821BA828h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 821BA828h case    0:*/		return 0x821BA82C;
		  /* 821BA82Ch */ case    1:  		/* cmplw CR6, R10, R11 */
		/* 821BA82Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 821BA82Ch case    1:*/		return 0x821BA830;
		  /* 821BA830h */ case    2:  		/* bc 4, CR6_EQ, -88 */
		/* 821BA830h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821BA7D8;  }
		/* 821BA830h case    2:*/		return 0x821BA834;
		  /* 821BA834h */ case    3:  		/* addi R8, R11, 8 */
		/* 821BA834h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x8);
		/* 821BA834h case    3:*/		return 0x821BA838;
		  /* 821BA838h */ case    4:  		/* b -96 */
		/* 821BA838h case    4:*/		return 0x821BA7D8;
		/* 821BA838h case    4:*/		return 0x821BA83C;
	}
	return 0x821BA83C;
} // Block from 821BA828h-821BA83Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BA83Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA83C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA83C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA83C);
		  /* 821BA83Ch */ case    0:  		/* li R6, 1 */
		/* 821BA83Ch case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821BA83Ch case    0:*/		return 0x821BA840;
		  /* 821BA840h */ case    1:  		/* li R5, 0 */
		/* 821BA840h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821BA840h case    1:*/		return 0x821BA844;
		  /* 821BA844h */ case    2:  		/* mr R4, R16 */
		/* 821BA844h case    2:*/		regs.R4 = regs.R16;
		/* 821BA844h case    2:*/		return 0x821BA848;
		  /* 821BA848h */ case    3:  		/* mr R3, R15 */
		/* 821BA848h case    3:*/		regs.R3 = regs.R15;
		/* 821BA848h case    3:*/		return 0x821BA84C;
		  /* 821BA84Ch */ case    4:  		/* bl 461692 */
		/* 821BA84Ch case    4:*/		regs.LR = 0x821BA850; return 0x8222B3C8;
		/* 821BA84Ch case    4:*/		return 0x821BA850;
	}
	return 0x821BA850;
} // Block from 821BA83Ch-821BA850h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BA850h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA850( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA850) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA850);
		  /* 821BA850h */ case    0:  		/* cmplw CR6, R28, R23 */
		/* 821BA850h case    0:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R23);
		/* 821BA850h case    0:*/		return 0x821BA854;
		  /* 821BA854h */ case    1:  		/* bc 12, CR6_EQ, -3872 */
		/* 821BA854h case    1:*/		if ( regs.CR[6].eq ) { return 0x821B9934;  }
		/* 821BA854h case    1:*/		return 0x821BA858;
	}
	return 0x821BA858;
} // Block from 821BA850h-821BA858h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BA858h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA858( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA858) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA858);
		  /* 821BA858h */ case    0:  		/* lbz R11, <#[R26 + 8]> */
		/* 821BA858h case    0:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 821BA858h case    0:*/		return 0x821BA85C;
		  /* 821BA85Ch */ case    1:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821BA85Ch case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821BA85Ch case    1:*/		return 0x821BA860;
		  /* 821BA860h */ case    2:  		/* bc 12, CR0_EQ, 32 */
		/* 821BA860h case    2:*/		if ( regs.CR[0].eq ) { return 0x821BA880;  }
		/* 821BA860h case    2:*/		return 0x821BA864;
		  /* 821BA864h */ case    3:  		/* mr R3, R31 */
		/* 821BA864h case    3:*/		regs.R3 = regs.R31;
		/* 821BA864h case    3:*/		return 0x821BA868;
		  /* 821BA868h */ case    4:  		/* bl -271600 */
		/* 821BA868h case    4:*/		regs.LR = 0x821BA86C; return 0x82178378;
		/* 821BA868h case    4:*/		return 0x821BA86C;
		  /* 821BA86Ch */ case    5:  		/* mr R3, R31 */
		/* 821BA86Ch case    5:*/		regs.R3 = regs.R31;
		/* 821BA86Ch case    5:*/		return 0x821BA870;
		  /* 821BA870h */ case    6:  		/* bl -175592 */
		/* 821BA870h case    6:*/		regs.LR = 0x821BA874; return 0x8218FA88;
		/* 821BA870h case    6:*/		return 0x821BA874;
		  /* 821BA874h */ case    7:  		/* lwz R11, <#[R31 + 8]> */
		/* 821BA874h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821BA874h case    7:*/		return 0x821BA878;
		  /* 821BA878h */ case    8:  		/* oris R11, R11, 256 */
		/* 821BA878h case    8:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x100);
		/* 821BA878h case    8:*/		return 0x821BA87C;
		  /* 821BA87Ch */ case    9:  		/* stw R11, <#[R31 + 8]> */
		/* 821BA87Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821BA87Ch case    9:*/		return 0x821BA880;
	}
	return 0x821BA880;
} // Block from 821BA858h-821BA880h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821BA880h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA880( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA880) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA880);
		  /* 821BA880h */ case    0:  		/* lwz R11, <#[R25]> */
		/* 821BA880h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 821BA880h case    0:*/		return 0x821BA884;
		  /* 821BA884h */ case    1:  		/* cmplw CR6, R11, R29 */
		/* 821BA884h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R29);
		/* 821BA884h case    1:*/		return 0x821BA888;
		  /* 821BA888h */ case    2:  		/* bc 4, CR6_EQ, -1216 */
		/* 821BA888h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821BA3C8;  }
		/* 821BA888h case    2:*/		return 0x821BA88C;
		  /* 821BA88Ch */ case    3:  		/* addi R25, R29, 4 */
		/* 821BA88Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R29,0x4);
		/* 821BA88Ch case    3:*/		return 0x821BA890;
		  /* 821BA890h */ case    4:  		/* b -1224 */
		/* 821BA890h case    4:*/		return 0x821BA3C8;
		/* 821BA890h case    4:*/		return 0x821BA894;
	}
	return 0x821BA894;
} // Block from 821BA880h-821BA894h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BA894h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA894( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA894) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA894);
		  /* 821BA894h */ case    0:  		/* lwz R11, <#[R16 + 8]> */
		/* 821BA894h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000008) );
		/* 821BA894h case    0:*/		return 0x821BA898;
		  /* 821BA898h */ case    1:  		/* rlwinm R10, R11, 0, 18, 24 */
		/* 821BA898h case    1:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R11);
		/* 821BA898h case    1:*/		return 0x821BA89C;
		  /* 821BA89Ch */ case    2:  		/* cmplwi CR6, R10, 14080 */
		/* 821BA89Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003700);
		/* 821BA89Ch case    2:*/		return 0x821BA8A0;
		  /* 821BA8A0h */ case    3:  		/* bc 4, CR6_EQ, 572 */
		/* 821BA8A0h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821BAADC;  }
		/* 821BA8A0h case    3:*/		return 0x821BA8A4;
		  /* 821BA8A4h */ case    4:  		/* li R27, 0 */
		/* 821BA8A4h case    4:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 821BA8A4h case    4:*/		return 0x821BA8A8;
		  /* 821BA8A8h */ case    5:  		/* addi R26, R16, 44 */
		/* 821BA8A8h case    5:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R16,0x2C);
		/* 821BA8A8h case    5:*/		return 0x821BA8AC;
		  /* 821BA8ACh */ case    6:  		/* lwz R11, <#[R16 + 8]> */
		/* 821BA8ACh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000008) );
		/* 821BA8ACh case    6:*/		return 0x821BA8B0;
		  /* 821BA8B0h */ case    7:  		/* rlwinm R10, R11, 13, 29, 31 */
		/* 821BA8B0h case    7:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R10,regs.R11);
		/* 821BA8B0h case    7:*/		return 0x821BA8B4;
		  /* 821BA8B4h */ case    8:  		/* cmplw CR6, R27, R10 */
		/* 821BA8B4h case    8:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R10);
		/* 821BA8B4h case    8:*/		return 0x821BA8B8;
		  /* 821BA8B8h */ case    9:  		/* bc 4, CR6_LT, 548 */
		/* 821BA8B8h case    9:*/		if ( !regs.CR[6].lt ) { return 0x821BAADC;  }
		/* 821BA8B8h case    9:*/		return 0x821BA8BC;
		  /* 821BA8BCh */ case   10:  		/* lwz R31, <#[R26]> */
		/* 821BA8BCh case   10:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R26 + 0x00000000) );
		/* 821BA8BCh case   10:*/		return 0x821BA8C0;
		  /* 821BA8C0h */ case   11:  		/* b 284 */
		/* 821BA8C0h case   11:*/		return 0x821BA9DC;
		/* 821BA8C0h case   11:*/		return 0x821BA8C4;
		  /* 821BA8C4h */ case   12:  		/* lwz R11, <#[R31]> */
		/* 821BA8C4h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821BA8C4h case   12:*/		return 0x821BA8C8;
		  /* 821BA8C8h */ case   13:  		/* rlwinm R11, R11, 27, 30, 31 */
		/* 821BA8C8h case   13:*/		cpu::op::rlwinm<0,27,30,31>(regs,&regs.R11,regs.R11);
		/* 821BA8C8h case   13:*/		return 0x821BA8CC;
		  /* 821BA8CCh */ case   14:  		/* addi R11, R11, 11 */
		/* 821BA8CCh case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xB);
		/* 821BA8CCh case   14:*/		return 0x821BA8D0;
		  /* 821BA8D0h */ case   15:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821BA8D0h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821BA8D0h case   15:*/		return 0x821BA8D4;
		  /* 821BA8D4h */ case   16:  		/* lwzx R7, <#[R11 + R29]> */
		/* 821BA8D4h case   16:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 821BA8D4h case   16:*/		return 0x821BA8D8;
		  /* 821BA8D8h */ case   17:  		/* lwz R11, <#[R7]> */
		/* 821BA8D8h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 821BA8D8h case   17:*/		return 0x821BA8DC;
		  /* 821BA8DCh */ case   18:  		/* rlwinm. R10, R11, 0, 27, 28 */
		/* 821BA8DCh case   18:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R10,regs.R11);
		/* 821BA8DCh case   18:*/		return 0x821BA8E0;
		  /* 821BA8E0h */ case   19:  		/* bc 4, CR0_EQ, 276 */
		/* 821BA8E0h case   19:*/		if ( !regs.CR[0].eq ) { return 0x821BA9F4;  }
		/* 821BA8E0h case   19:*/		return 0x821BA8E4;
		  /* 821BA8E4h */ case   20:  		/* lwz R9, <#[R31]> */
		/* 821BA8E4h case   20:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 821BA8E4h case   20:*/		return 0x821BA8E8;
		  /* 821BA8E8h */ case   21:  		/* rlwinm. R8, R11, 0, 27, 28 */
		/* 821BA8E8h case   21:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R8,regs.R11);
		/* 821BA8E8h case   21:*/		return 0x821BA8EC;
		  /* 821BA8ECh */ case   22:  		/* rlwinm R10, R11, 0, 27, 31 */
		/* 821BA8ECh case   22:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R11);
		/* 821BA8ECh case   22:*/		return 0x821BA8F0;
		  /* 821BA8F0h */ case   23:  		/* rlwinm R11, R9, 0, 27, 31 */
		/* 821BA8F0h case   23:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R9);
		/* 821BA8F0h case   23:*/		return 0x821BA8F4;
		  /* 821BA8F4h */ case   24:  		/* bc 12, CR0_EQ, 20 */
		/* 821BA8F4h case   24:*/		if ( regs.CR[0].eq ) { return 0x821BA908;  }
		/* 821BA8F4h case   24:*/		return 0x821BA8F8;
		  /* 821BA8F8h */ case   25:  		/* rlwinm. R9, R11, 0, 27, 28 */
		/* 821BA8F8h case   25:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R9,regs.R11);
		/* 821BA8F8h case   25:*/		return 0x821BA8FC;
		  /* 821BA8FCh */ case   26:  		/* bc 12, CR0_EQ, 12 */
		/* 821BA8FCh case   26:*/		if ( regs.CR[0].eq ) { return 0x821BA908;  }
		/* 821BA8FCh case   26:*/		return 0x821BA900;
		  /* 821BA900h */ case   27:  		/* li R11, 0 */
		/* 821BA900h case   27:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BA900h case   27:*/		return 0x821BA904;
		  /* 821BA904h */ case   28:  		/* b 44 */
		/* 821BA904h case   28:*/		return 0x821BA930;
		/* 821BA904h case   28:*/		return 0x821BA908;
	}
	return 0x821BA908;
} // Block from 821BA894h-821BA908h (29 instructions)

//////////////////////////////////////////////////////
// Block at 821BA908h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA908( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA908) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA908);
		  /* 821BA908h */ case    0:  		/* rlwinm. R9, R10, 0, 30, 30 */
		/* 821BA908h case    0:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R10);
		/* 821BA908h case    0:*/		return 0x821BA90C;
		  /* 821BA90Ch */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 821BA90Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x821BA918;  }
		/* 821BA90Ch case    1:*/		return 0x821BA910;
		  /* 821BA910h */ case    2:  		/* rlwinm. R9, R11, 0, 31, 31 */
		/* 821BA910h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R11);
		/* 821BA910h case    2:*/		return 0x821BA914;
		  /* 821BA914h */ case    3:  		/* bc 4, CR0_EQ, -20 */
		/* 821BA914h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BA900;  }
		/* 821BA914h case    3:*/		return 0x821BA918;
	}
	return 0x821BA918;
} // Block from 821BA908h-821BA918h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BA918h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA918( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA918) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA918);
		  /* 821BA918h */ case    0:  		/* rlwinm. R10, R10, 0, 29, 29 */
		/* 821BA918h case    0:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R10);
		/* 821BA918h case    0:*/		return 0x821BA91C;
		  /* 821BA91Ch */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 821BA91Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x821BA92C;  }
		/* 821BA91Ch case    1:*/		return 0x821BA920;
		  /* 821BA920h */ case    2:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821BA920h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821BA920h case    2:*/		return 0x821BA924;
		  /* 821BA924h */ case    3:  		/* li R11, 0 */
		/* 821BA924h case    3:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BA924h case    3:*/		return 0x821BA928;
		  /* 821BA928h */ case    4:  		/* bc 4, CR0_EQ, 8 */
		/* 821BA928h case    4:*/		if ( !regs.CR[0].eq ) { return 0x821BA930;  }
		/* 821BA928h case    4:*/		return 0x821BA92C;
	}
	return 0x821BA92C;
} // Block from 821BA918h-821BA92Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BA92Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA92C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA92C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA92C);
		  /* 821BA92Ch */ case    0:  		/* mr R11, R21 */
		/* 821BA92Ch case    0:*/		regs.R11 = regs.R21;
		/* 821BA92Ch case    0:*/		return 0x821BA930;
	}
	return 0x821BA930;
} // Block from 821BA92Ch-821BA930h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BA930h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA930( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA930) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA930);
		  /* 821BA930h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821BA930h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821BA930h case    0:*/		return 0x821BA934;
		  /* 821BA934h */ case    1:  		/* bc 12, CR0_EQ, 192 */
		/* 821BA934h case    1:*/		if ( regs.CR[0].eq ) { return 0x821BA9F4;  }
		/* 821BA934h case    1:*/		return 0x821BA938;
		  /* 821BA938h */ case    2:  		/* lwz R10, <#[R31 + 12]> */
		/* 821BA938h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000000C) );
		/* 821BA938h case    2:*/		return 0x821BA93C;
		  /* 821BA93Ch */ case    3:  		/* lwz R11, <#[R7 + 12]> */
		/* 821BA93Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x0000000C) );
		/* 821BA93Ch case    3:*/		return 0x821BA940;
		  /* 821BA940h */ case    4:  		/* addi R10, R10, 4 */
		/* 821BA940h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821BA940h case    4:*/		return 0x821BA944;
		  /* 821BA944h */ case    5:  		/* lwz R9, <#[R10]> */
		/* 821BA944h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821BA944h case    5:*/		return 0x821BA948;
		  /* 821BA948h */ case    6:  		/* b 12 */
		/* 821BA948h case    6:*/		return 0x821BA954;
		/* 821BA948h case    6:*/		return 0x821BA94C;
		  /* 821BA94Ch */ case    7:  		/* addi R10, R9, 8 */
		/* 821BA94Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x8);
		/* 821BA94Ch case    7:*/		return 0x821BA950;
		  /* 821BA950h */ case    8:  		/* lwz R9, <#[R9 + 8]> */
		/* 821BA950h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 821BA950h case    8:*/		return 0x821BA954;
	}
	return 0x821BA954;
} // Block from 821BA930h-821BA954h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821BA954h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA954( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA954) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA954);
		  /* 821BA954h */ case    0:  		/* cmplw CR6, R9, R31 */
		/* 821BA954h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R31);
		/* 821BA954h case    0:*/		return 0x821BA958;
		  /* 821BA958h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 821BA958h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BA94C;  }
		/* 821BA958h case    1:*/		return 0x821BA95C;
		  /* 821BA95Ch */ case    2:  		/* lwz R9, <#[R31 + 8]> */
		/* 821BA95Ch case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821BA95Ch case    2:*/		return 0x821BA960;
		  /* 821BA960h */ case    3:  		/* stw R9, <#[R10]> */
		/* 821BA960h case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821BA960h case    3:*/		return 0x821BA964;
		  /* 821BA964h */ case    4:  		/* lwz R10, <#[R11 + 4]> */
		/* 821BA964h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821BA964h case    4:*/		return 0x821BA968;
		  /* 821BA968h */ case    5:  		/* stw R10, <#[R31 + 8]> */
		/* 821BA968h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 821BA968h case    5:*/		return 0x821BA96C;
		  /* 821BA96Ch */ case    6:  		/* stw R31, <#[R11 + 4]> */
		/* 821BA96Ch case    6:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000004) );
		/* 821BA96Ch case    6:*/		return 0x821BA970;
		  /* 821BA970h */ case    7:  		/* stw R11, <#[R31 + 12]> */
		/* 821BA970h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 821BA970h case    7:*/		return 0x821BA974;
		  /* 821BA974h */ case    8:  		/* lwz R11, <#[R31]> */
		/* 821BA974h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821BA974h case    8:*/		return 0x821BA978;
		  /* 821BA978h */ case    9:  		/* lwz R10, <#[R7]> */
		/* 821BA978h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + 0x00000000) );
		/* 821BA978h case    9:*/		return 0x821BA97C;
		  /* 821BA97Ch */ case   10:  		/* rlwimi R10, R11, 0, 27, 18 */
		/* 821BA97Ch case   10:*/		cpu::op::rlwimi<0,0,27,18>(regs,&regs.R10,regs.R11);
		/* 821BA97Ch case   10:*/		return 0x821BA980;
		  /* 821BA980h */ case   11:  		/* stw R10, <#[R31]> */
		/* 821BA980h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 821BA980h case   11:*/		return 0x821BA984;
		  /* 821BA984h */ case   12:  		/* rlwinm R10, R10, 0, 27, 31 */
		/* 821BA984h case   12:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R10);
		/* 821BA984h case   12:*/		return 0x821BA988;
		  /* 821BA988h */ case   13:  		/* lwz R11, <#[R7]> */
		/* 821BA988h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000000) );
		/* 821BA988h case   13:*/		return 0x821BA98C;
		  /* 821BA98Ch */ case   14:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 821BA98Ch case   14:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 821BA98Ch case   14:*/		return 0x821BA990;
		  /* 821BA990h */ case   15:  		/* rlwinm. R9, R11, 0, 29, 29 */
		/* 821BA990h case   15:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R9,regs.R11);
		/* 821BA990h case   15:*/		return 0x821BA994;
		  /* 821BA994h */ case   16:  		/* bc 12, CR0_EQ, 16 */
		/* 821BA994h case   16:*/		if ( regs.CR[0].eq ) { return 0x821BA9A4;  }
		/* 821BA994h case   16:*/		return 0x821BA998;
		  /* 821BA998h */ case   17:  		/* rlwinm. R9, R10, 0, 30, 30 */
		/* 821BA998h case   17:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R10);
		/* 821BA998h case   17:*/		return 0x821BA99C;
		  /* 821BA99Ch */ case   18:  		/* bc 12, CR0_EQ, 8 */
		/* 821BA99Ch case   18:*/		if ( regs.CR[0].eq ) { return 0x821BA9A4;  }
		/* 821BA99Ch case   18:*/		return 0x821BA9A0;
		  /* 821BA9A0h */ case   19:  		/* addi R11, R11, -4 */
		/* 821BA9A0h case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 821BA9A0h case   19:*/		return 0x821BA9A4;
	}
	return 0x821BA9A4;
} // Block from 821BA954h-821BA9A4h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821BA9A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA9A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA9A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA9A4);
		  /* 821BA9A4h */ case    0:  		/* and R9, R11, R10 */
		/* 821BA9A4h case    0:*/		cpu::op::and<0>(regs,&regs.R9,regs.R11,regs.R10);
		/* 821BA9A4h case    0:*/		return 0x821BA9A8;
		  /* 821BA9A8h */ case    1:  		/* rlwinm. R9, R9, 0, 29, 29 */
		/* 821BA9A8h case    1:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R9,regs.R9);
		/* 821BA9A8h case    1:*/		return 0x821BA9AC;
		  /* 821BA9ACh */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 821BA9ACh case    2:*/		if ( regs.CR[0].eq ) { return 0x821BA9B8;  }
		/* 821BA9ACh case    2:*/		return 0x821BA9B0;
		  /* 821BA9B0h */ case    3:  		/* addi R11, R11, -4 */
		/* 821BA9B0h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 821BA9B0h case    3:*/		return 0x821BA9B4;
		  /* 821BA9B4h */ case    4:  		/* addi R10, R10, -4 */
		/* 821BA9B4h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFC);
		/* 821BA9B4h case    4:*/		return 0x821BA9B8;
	}
	return 0x821BA9B8;
} // Block from 821BA9A4h-821BA9B8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BA9B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA9B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA9B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA9B8);
		  /* 821BA9B8h */ case    0:  		/* rlwinm. R9, R11, 0, 31, 31 */
		/* 821BA9B8h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R11);
		/* 821BA9B8h case    0:*/		return 0x821BA9BC;
		  /* 821BA9BCh */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 821BA9BCh case    1:*/		if ( regs.CR[0].eq ) { return 0x821BA9CC;  }
		/* 821BA9BCh case    1:*/		return 0x821BA9C0;
		  /* 821BA9C0h */ case    2:  		/* rlwinm. R9, R10, 0, 30, 30 */
		/* 821BA9C0h case    2:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R9,regs.R10);
		/* 821BA9C0h case    2:*/		return 0x821BA9C4;
		  /* 821BA9C4h */ case    3:  		/* bc 12, CR0_EQ, 8 */
		/* 821BA9C4h case    3:*/		if ( regs.CR[0].eq ) { return 0x821BA9CC;  }
		/* 821BA9C4h case    3:*/		return 0x821BA9C8;
		  /* 821BA9C8h */ case    4:  		/* addi R10, R10, -2 */
		/* 821BA9C8h case    4:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFE);
		/* 821BA9C8h case    4:*/		return 0x821BA9CC;
	}
	return 0x821BA9CC;
} // Block from 821BA9B8h-821BA9CCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BA9CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA9CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA9CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA9CC);
		  /* 821BA9CCh */ case    0:  		/* lwz R9, <#[R31]> */
		/* 821BA9CCh case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 821BA9CCh case    0:*/		return 0x821BA9D0;
		  /* 821BA9D0h */ case    1:  		/* or R11, R11, R10 */
		/* 821BA9D0h case    1:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821BA9D0h case    1:*/		return 0x821BA9D4;
		  /* 821BA9D4h */ case    2:  		/* rlwimi R11, R9, 0, 0, 26 */
		/* 821BA9D4h case    2:*/		cpu::op::rlwimi<0,0,0,26>(regs,&regs.R11,regs.R9);
		/* 821BA9D4h case    2:*/		return 0x821BA9D8;
		  /* 821BA9D8h */ case    3:  		/* stw R11, <#[R31]> */
		/* 821BA9D8h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821BA9D8h case    3:*/		return 0x821BA9DC;
	}
	return 0x821BA9DC;
} // Block from 821BA9CCh-821BA9DCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BA9DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA9DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA9DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA9DC);
		  /* 821BA9DCh */ case    0:  		/* lwz R29, <#[R31 + 12]> */
		/* 821BA9DCh case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x0000000C) );
		/* 821BA9DCh case    0:*/		return 0x821BA9E0;
		  /* 821BA9E0h */ case    1:  		/* lwz R11, <#[R29 + 8]> */
		/* 821BA9E0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 821BA9E0h case    1:*/		return 0x821BA9E4;
		  /* 821BA9E4h */ case    2:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821BA9E4h case    2:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821BA9E4h case    2:*/		return 0x821BA9E8;
		  /* 821BA9E8h */ case    3:  		/* cmplwi CR6, R11, 14080 */
		/* 821BA9E8h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003700);
		/* 821BA9E8h case    3:*/		return 0x821BA9EC;
		  /* 821BA9ECh */ case    4:  		/* bc 12, CR6_EQ, -296 */
		/* 821BA9ECh case    4:*/		if ( regs.CR[6].eq ) { return 0x821BA8C4;  }
		/* 821BA9ECh case    4:*/		return 0x821BA9F0;
		  /* 821BA9F0h */ case    5:  		/* b 224 */
		/* 821BA9F0h case    5:*/		return 0x821BAAD0;
		/* 821BA9F0h case    5:*/		return 0x821BA9F4;
	}
	return 0x821BA9F4;
} // Block from 821BA9DCh-821BA9F4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BA9F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BA9F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BA9F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BA9F4);
		  /* 821BA9F4h */ case    0:  		/* li R5, 0 */
		/* 821BA9F4h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821BA9F4h case    0:*/		return 0x821BA9F8;
		  /* 821BA9F8h */ case    1:  		/* mr R6, R7 */
		/* 821BA9F8h case    1:*/		regs.R6 = regs.R7;
		/* 821BA9F8h case    1:*/		return 0x821BA9FC;
		  /* 821BA9FCh */ case    2:  		/* mr R4, R23 */
		/* 821BA9FCh case    2:*/		regs.R4 = regs.R23;
		/* 821BA9FCh case    2:*/		return 0x821BAA00;
		  /* 821BAA00h */ case    3:  		/* mr R3, R15 */
		/* 821BAA00h case    3:*/		regs.R3 = regs.R15;
		/* 821BAA00h case    3:*/		return 0x821BAA04;
		  /* 821BAA04h */ case    4:  		/* bl -265164 */
		/* 821BAA04h case    4:*/		regs.LR = 0x821BAA08; return 0x82179E38;
		/* 821BAA04h case    4:*/		return 0x821BAA08;
		  /* 821BAA08h */ case    5:  		/* lwz R28, <#[R29]> */
		/* 821BAA08h case    5:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R29 + 0x00000000) );
		/* 821BAA08h case    5:*/		return 0x821BAA0C;
		  /* 821BAA0Ch */ case    6:  		/* mr R30, R3 */
		/* 821BAA0Ch case    6:*/		regs.R30 = regs.R3;
		/* 821BAA0Ch case    6:*/		return 0x821BAA10;
		  /* 821BAA10h */ case    7:  		/* cmplwi CR6, R28, 0 */
		/* 821BAA10h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 821BAA10h case    7:*/		return 0x821BAA14;
		  /* 821BAA14h */ case    8:  		/* bc 12, CR6_EQ, 36 */
		/* 821BAA14h case    8:*/		if ( regs.CR[6].eq ) { return 0x821BAA38;  }
		/* 821BAA14h case    8:*/		return 0x821BAA18;
		  /* 821BAA18h */ case    9:  		/* lwz R11, <#[R28]> */
		/* 821BAA18h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 821BAA18h case    9:*/		return 0x821BAA1C;
		  /* 821BAA1Ch */ case   10:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 821BAA1Ch case   10:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 821BAA1Ch case   10:*/		return 0x821BAA20;
		  /* 821BAA20h */ case   11:  		/* bc 4, CR0_EQ, 16 */
		/* 821BAA20h case   11:*/		if ( !regs.CR[0].eq ) { return 0x821BAA30;  }
		/* 821BAA20h case   11:*/		return 0x821BAA24;
		  /* 821BAA24h */ case   12:  		/* mr R4, R28 */
		/* 821BAA24h case   12:*/		regs.R4 = regs.R28;
		/* 821BAA24h case   12:*/		return 0x821BAA28;
		  /* 821BAA28h */ case   13:  		/* mr R3, R30 */
		/* 821BAA28h case   13:*/		regs.R3 = regs.R30;
		/* 821BAA28h case   13:*/		return 0x821BAA2C;
		  /* 821BAA2Ch */ case   14:  		/* bl -272484 */
		/* 821BAA2Ch case   14:*/		regs.LR = 0x821BAA30; return 0x821781C8;
		/* 821BAA2Ch case   14:*/		return 0x821BAA30;
	}
	return 0x821BAA30;
} // Block from 821BA9F4h-821BAA30h (15 instructions)

//////////////////////////////////////////////////////
// Block at 821BAA30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BAA30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BAA30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BAA30);
		  /* 821BAA30h */ case    0:  		/* lwz R28, <#[R28 + 4]> */
		/* 821BAA30h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R28 + 0x00000004) );
		/* 821BAA30h case    0:*/		return 0x821BAA34;
		  /* 821BAA34h */ case    1:  		/* b -36 */
		/* 821BAA34h case    1:*/		return 0x821BAA10;
		/* 821BAA34h case    1:*/		return 0x821BAA38;
	}
	return 0x821BAA38;
} // Block from 821BAA30h-821BAA38h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BAA38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BAA38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BAA38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BAA38);
		  /* 821BAA38h */ case    0:  		/* rlwinm R11, R29, 0, 0, 30 */
		/* 821BAA38h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R29);
		/* 821BAA38h case    0:*/		return 0x821BAA3C;
		  /* 821BAA3Ch */ case    1:  		/* rlwinm R10, R30, 0, 0, 30 */
		/* 821BAA3Ch case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R30);
		/* 821BAA3Ch case    1:*/		return 0x821BAA40;
		  /* 821BAA40h */ case    2:  		/* addi R11, R11, 36 */
		/* 821BAA40h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821BAA40h case    2:*/		return 0x821BAA44;
		  /* 821BAA44h */ case    3:  		/* addi R10, R10, 36 */
		/* 821BAA44h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 821BAA44h case    3:*/		return 0x821BAA48;
		  /* 821BAA48h */ case    4:  		/* addi R9, R11, 4 */
		/* 821BAA48h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821BAA48h case    4:*/		return 0x821BAA4C;
		  /* 821BAA4Ch */ case    5:  		/* addi R8, R10, 4 */
		/* 821BAA4Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x4);
		/* 821BAA4Ch case    5:*/		return 0x821BAA50;
		  /* 821BAA50h */ case    6:  		/* addi R7, R10, -36 */
		/* 821BAA50h case    6:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0xFFFFFFDC);
		/* 821BAA50h case    6:*/		return 0x821BAA54;
		  /* 821BAA54h */ case    7:  		/* lwz R6, <#[R11 + 4]> */
		/* 821BAA54h case    7:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821BAA54h case    7:*/		return 0x821BAA58;
		  /* 821BAA58h */ case    8:  		/* stw R6, <#[R10 + 4]> */
		/* 821BAA58h case    8:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 821BAA58h case    8:*/		return 0x821BAA5C;
		  /* 821BAA5Ch */ case    9:  		/* lwz R6, <#[R11 + 4]> */
		/* 821BAA5Ch case    9:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821BAA5Ch case    9:*/		return 0x821BAA60;
		  /* 821BAA60h */ case   10:  		/* rlwinm R6, R6, 0, 0, 30 */
		/* 821BAA60h case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R6);
		/* 821BAA60h case   10:*/		return 0x821BAA64;
		  /* 821BAA64h */ case   11:  		/* stw R8, <#[R6 + 36]> */
		/* 821BAA64h case   11:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R6 + 0x00000024) );
		/* 821BAA64h case   11:*/		return 0x821BAA68;
		  /* 821BAA68h */ case   12:  		/* stw R9, <#[R10]> */
		/* 821BAA68h case   12:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821BAA68h case   12:*/		return 0x821BAA6C;
		  /* 821BAA6Ch */ case   13:  		/* stw R7, <#[R11 + 4]> */
		/* 821BAA6Ch case   13:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + 0x00000004) );
		/* 821BAA6Ch case   13:*/		return 0x821BAA70;
		  /* 821BAA70h */ case   14:  		/* lwz R11, <#[R31 + 12]> */
		/* 821BAA70h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 821BAA70h case   14:*/		return 0x821BAA74;
		  /* 821BAA74h */ case   15:  		/* addi R11, R11, 4 */
		/* 821BAA74h case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821BAA74h case   15:*/		return 0x821BAA78;
		  /* 821BAA78h */ case   16:  		/* lwz R10, <#[R11]> */
		/* 821BAA78h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821BAA78h case   16:*/		return 0x821BAA7C;
		  /* 821BAA7Ch */ case   17:  		/* b 12 */
		/* 821BAA7Ch case   17:*/		return 0x821BAA88;
		/* 821BAA7Ch case   17:*/		return 0x821BAA80;
		  /* 821BAA80h */ case   18:  		/* addi R11, R10, 8 */
		/* 821BAA80h case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 821BAA80h case   18:*/		return 0x821BAA84;
		  /* 821BAA84h */ case   19:  		/* lwz R10, <#[R10 + 8]> */
		/* 821BAA84h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 821BAA84h case   19:*/		return 0x821BAA88;
	}
	return 0x821BAA88;
} // Block from 821BAA38h-821BAA88h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821BAA88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BAA88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BAA88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BAA88);
		  /* 821BAA88h */ case    0:  		/* cmplw CR6, R10, R31 */
		/* 821BAA88h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 821BAA88h case    0:*/		return 0x821BAA8C;
		  /* 821BAA8Ch */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 821BAA8Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BAA80;  }
		/* 821BAA8Ch case    1:*/		return 0x821BAA90;
		  /* 821BAA90h */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 821BAA90h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 821BAA90h case    2:*/		return 0x821BAA94;
		  /* 821BAA94h */ case    3:  		/* mr R3, R30 */
		/* 821BAA94h case    3:*/		regs.R3 = regs.R30;
		/* 821BAA94h case    3:*/		return 0x821BAA98;
		  /* 821BAA98h */ case    4:  		/* stw R10, <#[R11]> */
		/* 821BAA98h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821BAA98h case    4:*/		return 0x821BAA9C;
		  /* 821BAA9Ch */ case    5:  		/* lwz R11, <#[R30 + 4]> */
		/* 821BAA9Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 821BAA9Ch case    5:*/		return 0x821BAAA0;
		  /* 821BAAA0h */ case    6:  		/* stw R11, <#[R31 + 8]> */
		/* 821BAAA0h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821BAAA0h case    6:*/		return 0x821BAAA4;
		  /* 821BAAA4h */ case    7:  		/* stw R31, <#[R30 + 4]> */
		/* 821BAAA4h case    7:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000004) );
		/* 821BAAA4h case    7:*/		return 0x821BAAA8;
		  /* 821BAAA8h */ case    8:  		/* stw R30, <#[R31 + 12]> */
		/* 821BAAA8h case    8:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000000C) );
		/* 821BAAA8h case    8:*/		return 0x821BAAAC;
		  /* 821BAAACh */ case    9:  		/* lwz R11, <#[R31]> */
		/* 821BAAACh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821BAAACh case    9:*/		return 0x821BAAB0;
		  /* 821BAAB0h */ case   10:  		/* rlwimi R11, R20, 7, 19, 26 */
		/* 821BAAB0h case   10:*/		cpu::op::rlwimi<0,7,19,26>(regs,&regs.R11,regs.R20);
		/* 821BAAB0h case   10:*/		return 0x821BAAB4;
		  /* 821BAAB4h */ case   11:  		/* stw R11, <#[R31]> */
		/* 821BAAB4h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821BAAB4h case   11:*/		return 0x821BAAB8;
		  /* 821BAAB8h */ case   12:  		/* bl -272192 */
		/* 821BAAB8h case   12:*/		regs.LR = 0x821BAABC; return 0x82178378;
		/* 821BAAB8h case   12:*/		return 0x821BAABC;
		  /* 821BAABCh */ case   13:  		/* mr R3, R30 */
		/* 821BAABCh case   13:*/		regs.R3 = regs.R30;
		/* 821BAABCh case   13:*/		return 0x821BAAC0;
		  /* 821BAAC0h */ case   14:  		/* bl -176184 */
		/* 821BAAC0h case   14:*/		regs.LR = 0x821BAAC4; return 0x8218FA88;
		/* 821BAAC0h case   14:*/		return 0x821BAAC4;
		  /* 821BAAC4h */ case   15:  		/* lwz R11, <#[R30 + 8]> */
		/* 821BAAC4h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821BAAC4h case   15:*/		return 0x821BAAC8;
		  /* 821BAAC8h */ case   16:  		/* oris R11, R11, 256 */
		/* 821BAAC8h case   16:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x100);
		/* 821BAAC8h case   16:*/		return 0x821BAACC;
		  /* 821BAACCh */ case   17:  		/* stw R11, <#[R30 + 8]> */
		/* 821BAACCh case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821BAACCh case   17:*/		return 0x821BAAD0;
	}
	return 0x821BAAD0;
} // Block from 821BAA88h-821BAAD0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821BAAD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BAAD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BAAD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BAAD0);
		  /* 821BAAD0h */ case    0:  		/* addi R27, R27, 1 */
		/* 821BAAD0h case    0:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R27,0x1);
		/* 821BAAD0h case    0:*/		return 0x821BAAD4;
		  /* 821BAAD4h */ case    1:  		/* addi R26, R26, 4 */
		/* 821BAAD4h case    1:*/		cpu::op::addi<0>(regs,&regs.R26,regs.R26,0x4);
		/* 821BAAD4h case    1:*/		return 0x821BAAD8;
		  /* 821BAAD8h */ case    2:  		/* b -556 */
		/* 821BAAD8h case    2:*/		return 0x821BA8AC;
		/* 821BAAD8h case    2:*/		return 0x821BAADC;
	}
	return 0x821BAADC;
} // Block from 821BAAD0h-821BAADCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BAADCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BAADC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BAADC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BAADC);
		  /* 821BAADCh */ case    0:  		/* rlwinm R9, R11, 25, 25, 31 */
		/* 821BAADCh case    0:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R9,regs.R11);
		/* 821BAADCh case    0:*/		return 0x821BAAE0;
		  /* 821BAAE0h */ case    1:  		/* cmplwi CR6, R9, 1 */
		/* 821BAAE0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000001);
		/* 821BAAE0h case    1:*/		return 0x821BAAE4;
		  /* 821BAAE4h */ case    2:  		/* bc 12, CR6_LT, 16 */
		/* 821BAAE4h case    2:*/		if ( regs.CR[6].lt ) { return 0x821BAAF4;  }
		/* 821BAAE4h case    2:*/		return 0x821BAAE8;
		  /* 821BAAE8h */ case    3:  		/* cmplwi CR6, R9, 102 */
		/* 821BAAE8h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000066);
		/* 821BAAE8h case    3:*/		return 0x821BAAEC;
		  /* 821BAAECh */ case    4:  		/* mr R10, R21 */
		/* 821BAAECh case    4:*/		regs.R10 = regs.R21;
		/* 821BAAECh case    4:*/		return 0x821BAAF0;
		  /* 821BAAF0h */ case    5:  		/* bc 4, CR6_GT, 8 */
		/* 821BAAF0h case    5:*/		if ( !regs.CR[6].gt ) { return 0x821BAAF8;  }
		/* 821BAAF0h case    5:*/		return 0x821BAAF4;
	}
	return 0x821BAAF4;
} // Block from 821BAADCh-821BAAF4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BAAF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BAAF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BAAF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BAAF4);
		  /* 821BAAF4h */ case    0:  		/* li R10, 0 */
		/* 821BAAF4h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821BAAF4h case    0:*/		return 0x821BAAF8;
	}
	return 0x821BAAF8;
} // Block from 821BAAF4h-821BAAF8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BAAF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BAAF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BAAF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BAAF8);
		  /* 821BAAF8h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 821BAAF8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 821BAAF8h case    0:*/		return 0x821BAAFC;
		  /* 821BAAFCh */ case    1:  		/* bc 4, CR0_EQ, 20 */
		/* 821BAAFCh case    1:*/		if ( !regs.CR[0].eq ) { return 0x821BAB10;  }
		/* 821BAAFCh case    1:*/		return 0x821BAB00;
		  /* 821BAB00h */ case    2:  		/* cmplwi CR6, R9, 105 */
		/* 821BAB00h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000069);
		/* 821BAB00h case    2:*/		return 0x821BAB04;
		  /* 821BAB04h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 821BAB04h case    3:*/		if ( regs.CR[6].eq ) { return 0x821BAB10;  }
		/* 821BAB04h case    3:*/		return 0x821BAB08;
		  /* 821BAB08h */ case    4:  		/* cmplwi CR6, R9, 104 */
		/* 821BAB08h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000068);
		/* 821BAB08h case    4:*/		return 0x821BAB0C;
		  /* 821BAB0Ch */ case    5:  		/* bc 4, CR6_EQ, 1380 */
		/* 821BAB0Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x821BB070;  }
		/* 821BAB0Ch case    5:*/		return 0x821BAB10;
	}
	return 0x821BAB10;
} // Block from 821BAAF8h-821BAB10h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BAB10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BAB10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BAB10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BAB10);
		  /* 821BAB10h */ case    0:  		/* rlwinm. R11, R11, 0, 10, 12 */
		/* 821BAB10h case    0:*/		cpu::op::rlwinm<1,0,10,12>(regs,&regs.R11,regs.R11);
		/* 821BAB10h case    0:*/		return 0x821BAB14;
		  /* 821BAB14h */ case    1:  		/* li R18, 0 */
		/* 821BAB14h case    1:*/		cpu::op::li<0>(regs,&regs.R18,0x0);
		/* 821BAB14h case    1:*/		return 0x821BAB18;
		  /* 821BAB18h */ case    2:  		/* li R23, 0 */
		/* 821BAB18h case    2:*/		cpu::op::li<0>(regs,&regs.R23,0x0);
		/* 821BAB18h case    2:*/		return 0x821BAB1C;
		  /* 821BAB1Ch */ case    3:  		/* li R22, 0 */
		/* 821BAB1Ch case    3:*/		cpu::op::li<0>(regs,&regs.R22,0x0);
		/* 821BAB1Ch case    3:*/		return 0x821BAB20;
		  /* 821BAB20h */ case    4:  		/* li R20, 0 */
		/* 821BAB20h case    4:*/		cpu::op::li<0>(regs,&regs.R20,0x0);
		/* 821BAB20h case    4:*/		return 0x821BAB24;
		  /* 821BAB24h */ case    5:  		/* li R17, 0 */
		/* 821BAB24h case    5:*/		cpu::op::li<0>(regs,&regs.R17,0x0);
		/* 821BAB24h case    5:*/		return 0x821BAB28;
		  /* 821BAB28h */ case    6:  		/* li R19, 0 */
		/* 821BAB28h case    6:*/		cpu::op::li<0>(regs,&regs.R19,0x0);
		/* 821BAB28h case    6:*/		return 0x821BAB2C;
		  /* 821BAB2Ch */ case    7:  		/* li R24, 0 */
		/* 821BAB2Ch case    7:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 821BAB2Ch case    7:*/		return 0x821BAB30;
		  /* 821BAB30h */ case    8:  		/* bc 12, CR0_EQ, 644 */
		/* 821BAB30h case    8:*/		if ( regs.CR[0].eq ) { return 0x821BADB4;  }
		/* 821BAB30h case    8:*/		return 0x821BAB34;
		  /* 821BAB34h */ case    9:  		/* addi R21, R16, 44 */
		/* 821BAB34h case    9:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R16,0x2C);
		/* 821BAB34h case    9:*/		return 0x821BAB38;
		  /* 821BAB38h */ case   10:  		/* lwz R29, <#[R21]> */
		/* 821BAB38h case   10:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R21 + 0x00000000) );
		/* 821BAB38h case   10:*/		return 0x821BAB3C;
		  /* 821BAB3Ch */ case   11:  		/* lwz R28, <#[R29]> */
		/* 821BAB3Ch case   11:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R29 + 0x00000000) );
		/* 821BAB3Ch case   11:*/		return 0x821BAB40;
		  /* 821BAB40h */ case   12:  		/* rlwinm. R27, R28, 7, 29, 31 */
		/* 821BAB40h case   12:*/		cpu::op::rlwinm<1,7,29,31>(regs,&regs.R27,regs.R28);
		/* 821BAB40h case   12:*/		return 0x821BAB44;
		  /* 821BAB44h */ case   13:  		/* bc 12, CR0_EQ, 600 */
		/* 821BAB44h case   13:*/		if ( regs.CR[0].eq ) { return 0x821BAD9C;  }
		/* 821BAB44h case   13:*/		return 0x821BAB48;
		  /* 821BAB48h */ case   14:  		/* rlwinm R25, R28, 0, 27, 31 */
		/* 821BAB48h case   14:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R25,regs.R28);
		/* 821BAB48h case   14:*/		return 0x821BAB4C;
		  /* 821BAB4Ch */ case   15:  		/* lwz R30, <#[R29 + 12]> */
		/* 821BAB4Ch case   15:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R29 + 0x0000000C) );
		/* 821BAB4Ch case   15:*/		return 0x821BAB50;
		  /* 821BAB50h */ case   16:  		/* mr R3, R16 */
		/* 821BAB50h case   16:*/		regs.R3 = regs.R16;
		/* 821BAB50h case   16:*/		return 0x821BAB54;
		  /* 821BAB54h */ case   17:  		/* mr R4, R25 */
		/* 821BAB54h case   17:*/		regs.R4 = regs.R25;
		/* 821BAB54h case   17:*/		return 0x821BAB58;
		  /* 821BAB58h */ case   18:  		/* bl -149704 */
		/* 821BAB58h case   18:*/		regs.LR = 0x821BAB5C; return 0x82196290;
		/* 821BAB58h case   18:*/		return 0x821BAB5C;
		  /* 821BAB5Ch */ case   19:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821BAB5Ch case   19:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821BAB5Ch case   19:*/		return 0x821BAB60;
		  /* 821BAB60h */ case   20:  		/* lwz R11, <#[R30 + 8]> */
		/* 821BAB60h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821BAB60h case   20:*/		return 0x821BAB64;
		  /* 821BAB64h */ case   21:  		/* bc 4, CR0_EQ, 148 */
		/* 821BAB64h case   21:*/		if ( !regs.CR[0].eq ) { return 0x821BABF8;  }
		/* 821BAB64h case   21:*/		return 0x821BAB68;
		  /* 821BAB68h */ case   22:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821BAB68h case   22:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821BAB68h case   22:*/		return 0x821BAB6C;
		  /* 821BAB6Ch */ case   23:  		/* cmplwi CR6, R11, 125 */
		/* 821BAB6Ch case   23:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 821BAB6Ch case   23:*/		return 0x821BAB70;
		  /* 821BAB70h */ case   24:  		/* bc 12, CR6_EQ, 16 */
		/* 821BAB70h case   24:*/		if ( regs.CR[6].eq ) { return 0x821BAB80;  }
		/* 821BAB70h case   24:*/		return 0x821BAB74;
		  /* 821BAB74h */ case   25:  		/* cmplwi CR6, R11, 124 */
		/* 821BAB74h case   25:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 821BAB74h case   25:*/		return 0x821BAB78;
		  /* 821BAB78h */ case   26:  		/* li R11, 0 */
		/* 821BAB78h case   26:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BAB78h case   26:*/		return 0x821BAB7C;
		  /* 821BAB7Ch */ case   27:  		/* bc 4, CR6_EQ, 8 */
		/* 821BAB7Ch case   27:*/		if ( !regs.CR[6].eq ) { return 0x821BAB84;  }
		/* 821BAB7Ch case   27:*/		return 0x821BAB80;
	}
	return 0x821BAB80;
} // Block from 821BAB10h-821BAB80h (28 instructions)

//////////////////////////////////////////////////////
// Block at 821BAB80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BAB80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BAB80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BAB80);
		  /* 821BAB80h */ case    0:  		/* li R11, 1 */
		/* 821BAB80h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821BAB80h case    0:*/		return 0x821BAB84;
	}
	return 0x821BAB84;
} // Block from 821BAB80h-821BAB84h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BAB84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BAB84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BAB84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BAB84);
		  /* 821BAB84h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821BAB84h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821BAB84h case    0:*/		return 0x821BAB88;
		  /* 821BAB88h */ case    1:  		/* bc 4, CR0_EQ, 268 */
		/* 821BAB88h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821BAC94;  }
		/* 821BAB88h case    1:*/		return 0x821BAB8C;
		  /* 821BAB8Ch */ case    2:  		/* mr R3, R30 */
		/* 821BAB8Ch case    2:*/		regs.R3 = regs.R30;
		/* 821BAB8Ch case    2:*/		return 0x821BAB90;
		  /* 821BAB90h */ case    3:  		/* bl -300008 */
		/* 821BAB90h case    3:*/		regs.LR = 0x821BAB94; return 0x821717A8;
		/* 821BAB90h case    3:*/		return 0x821BAB94;
		  /* 821BAB94h */ case    4:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821BAB94h case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821BAB94h case    4:*/		return 0x821BAB98;
		  /* 821BAB98h */ case    5:  		/* bc 12, CR0_EQ, 20 */
		/* 821BAB98h case    5:*/		if ( regs.CR[0].eq ) { return 0x821BABAC;  }
		/* 821BAB98h case    5:*/		return 0x821BAB9C;
		  /* 821BAB9Ch */ case    6:  		/* li R11, 1 */
		/* 821BAB9Ch case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821BAB9Ch case    6:*/		return 0x821BABA0;
		  /* 821BABA0h */ case    7:  		/* rlwimi R30, R11, 0, 30, 31 */
		/* 821BABA0h case    7:*/		cpu::op::rlwimi<0,0,30,31>(regs,&regs.R30,regs.R11);
		/* 821BABA0h case    7:*/		return 0x821BABA4;
		  /* 821BABA4h */ case    8:  		/* mr R5, R30 */
		/* 821BABA4h case    8:*/		regs.R5 = regs.R30;
		/* 821BABA4h case    8:*/		return 0x821BABA8;
		  /* 821BABA8h */ case    9:  		/* b 20 */
		/* 821BABA8h case    9:*/		return 0x821BABBC;
		/* 821BABA8h case    9:*/		return 0x821BABAC;
	}
	return 0x821BABAC;
} // Block from 821BAB84h-821BABACh (10 instructions)

//////////////////////////////////////////////////////
// Block at 821BABACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BABAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BABAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BABAC);
		  /* 821BABACh */ case    0:  		/* lwz R11, <#[R1 + 316]> */
		/* 821BABACh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000013C) );
		/* 821BABACh case    0:*/		return 0x821BABB0;
		  /* 821BABB0h */ case    1:  		/* addi R11, R11, 24 */
		/* 821BABB0h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x18);
		/* 821BABB0h case    1:*/		return 0x821BABB4;
		  /* 821BABB4h */ case    2:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821BABB4h case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821BABB4h case    2:*/		return 0x821BABB8;
		  /* 821BABB8h */ case    3:  		/* ori R5, R11, 2 */
		/* 821BABB8h case    3:*/		cpu::op::ori<0>(regs,&regs.R5,regs.R11,0x2);
		/* 821BABB8h case    3:*/		return 0x821BABBC;
	}
	return 0x821BABBC;
} // Block from 821BABACh-821BABBCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BABBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BABBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BABBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BABBC);
		  /* 821BABBCh */ case    0:  		/* mr R6, R29 */
		/* 821BABBCh case    0:*/		regs.R6 = regs.R29;
		/* 821BABBCh case    0:*/		return 0x821BABC0;
		  /* 821BABC0h */ case    1:  		/* lwz R4, <#[R1 + 316]> */
		/* 821BABC0h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x0000013C) );
		/* 821BABC0h case    1:*/		return 0x821BABC4;
		  /* 821BABC4h */ case    2:  		/* mr R3, R15 */
		/* 821BABC4h case    2:*/		regs.R3 = regs.R15;
		/* 821BABC4h case    2:*/		return 0x821BABC8;
		  /* 821BABC8h */ case    3:  		/* bl 455672 */
		/* 821BABC8h case    3:*/		regs.LR = 0x821BABCC; return 0x82229FC0;
		/* 821BABC8h case    3:*/		return 0x821BABCC;
		  /* 821BABCCh */ case    4:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821BABCCh case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821BABCCh case    4:*/		return 0x821BABD0;
		  /* 821BABD0h */ case    5:  		/* bc 4, CR0_EQ, 460 */
		/* 821BABD0h case    5:*/		if ( !regs.CR[0].eq ) { return 0x821BAD9C;  }
		/* 821BABD0h case    5:*/		return 0x821BABD4;
		  /* 821BABD4h */ case    6:  		/* lwz R31, <#[R29 + 12]> */
		/* 821BABD4h case    6:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R29 + 0x0000000C) );
		/* 821BABD4h case    6:*/		return 0x821BABD8;
		  /* 821BABD8h */ case    7:  		/* mr R3, R31 */
		/* 821BABD8h case    7:*/		regs.R3 = regs.R31;
		/* 821BABD8h case    7:*/		return 0x821BABDC;
		  /* 821BABDCh */ case    8:  		/* bl -272484 */
		/* 821BABDCh case    8:*/		regs.LR = 0x821BABE0; return 0x82178378;
		/* 821BABDCh case    8:*/		return 0x821BABE0;
		  /* 821BABE0h */ case    9:  		/* mr R3, R31 */
		/* 821BABE0h case    9:*/		regs.R3 = regs.R31;
		/* 821BABE0h case    9:*/		return 0x821BABE4;
		  /* 821BABE4h */ case   10:  		/* bl -176476 */
		/* 821BABE4h case   10:*/		regs.LR = 0x821BABE8; return 0x8218FA88;
		/* 821BABE4h case   10:*/		return 0x821BABE8;
		  /* 821BABE8h */ case   11:  		/* lwz R11, <#[R31 + 8]> */
		/* 821BABE8h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821BABE8h case   11:*/		return 0x821BABEC;
		  /* 821BABECh */ case   12:  		/* oris R11, R11, 256 */
		/* 821BABECh case   12:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x100);
		/* 821BABECh case   12:*/		return 0x821BABF0;
		  /* 821BABF0h */ case   13:  		/* stw R11, <#[R31 + 8]> */
		/* 821BABF0h case   13:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821BABF0h case   13:*/		return 0x821BABF4;
		  /* 821BABF4h */ case   14:  		/* b 424 */
		/* 821BABF4h case   14:*/		return 0x821BAD9C;
		/* 821BABF4h case   14:*/		return 0x821BABF8;
	}
	return 0x821BABF8;
} // Block from 821BABBCh-821BABF8h (15 instructions)

//////////////////////////////////////////////////////
// Block at 821BABF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BABF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BABF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BABF8);
		  /* 821BABF8h */ case    0:  		/* rlwinm R26, R11, 25, 25, 31 */
		/* 821BABF8h case    0:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R26,regs.R11);
		/* 821BABF8h case    0:*/		return 0x821BABFC;
		  /* 821BABFCh */ case    1:  		/* cmplwi CR6, R26, 125 */
		/* 821BABFCh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x0000007D);
		/* 821BABFCh case    1:*/		return 0x821BAC00;
		  /* 821BAC00h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 821BAC00h case    2:*/		if ( regs.CR[6].eq ) { return 0x821BAC10;  }
		/* 821BAC00h case    2:*/		return 0x821BAC04;
		  /* 821BAC04h */ case    3:  		/* cmplwi CR6, R26, 124 */
		/* 821BAC04h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x0000007C);
		/* 821BAC04h case    3:*/		return 0x821BAC08;
		  /* 821BAC08h */ case    4:  		/* li R11, 0 */
		/* 821BAC08h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BAC08h case    4:*/		return 0x821BAC0C;
		  /* 821BAC0Ch */ case    5:  		/* bc 4, CR6_EQ, 8 */
		/* 821BAC0Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x821BAC14;  }
		/* 821BAC0Ch case    5:*/		return 0x821BAC10;
	}
	return 0x821BAC10;
} // Block from 821BABF8h-821BAC10h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BAC10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BAC10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BAC10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BAC10);
		  /* 821BAC10h */ case    0:  		/* li R11, 1 */
		/* 821BAC10h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821BAC10h case    0:*/		return 0x821BAC14;
	}
	return 0x821BAC14;
} // Block from 821BAC10h-821BAC14h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BAC14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BAC14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BAC14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BAC14);
		  /* 821BAC14h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821BAC14h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821BAC14h case    0:*/		return 0x821BAC18;
		  /* 821BAC18h */ case    1:  		/* bc 12, CR0_EQ, 168 */
		/* 821BAC18h case    1:*/		if ( regs.CR[0].eq ) { return 0x821BACC0;  }
		/* 821BAC18h case    1:*/		return 0x821BAC1C;
		  /* 821BAC1Ch */ case    2:  		/* lwz R11, <#[R16 + 8]> */
		/* 821BAC1Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000008) );
		/* 821BAC1Ch case    2:*/		return 0x821BAC20;
		  /* 821BAC20h */ case    3:  		/* rlwinm R31, R11, 25, 25, 31 */
		/* 821BAC20h case    3:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R31,regs.R11);
		/* 821BAC20h case    3:*/		return 0x821BAC24;
		  /* 821BAC24h */ case    4:  		/* cmplwi CR6, R31, 96 */
		/* 821BAC24h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000060);
		/* 821BAC24h case    4:*/		return 0x821BAC28;
		  /* 821BAC28h */ case    5:  		/* bc 12, CR6_LT, 16 */
		/* 821BAC28h case    5:*/		if ( regs.CR[6].lt ) { return 0x821BAC38;  }
		/* 821BAC28h case    5:*/		return 0x821BAC2C;
		  /* 821BAC2Ch */ case    6:  		/* cmplwi CR6, R31, 102 */
		/* 821BAC2Ch case    6:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000066);
		/* 821BAC2Ch case    6:*/		return 0x821BAC30;
		  /* 821BAC30h */ case    7:  		/* li R11, 1 */
		/* 821BAC30h case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821BAC30h case    7:*/		return 0x821BAC34;
		  /* 821BAC34h */ case    8:  		/* bc 4, CR6_GT, 8 */
		/* 821BAC34h case    8:*/		if ( !regs.CR[6].gt ) { return 0x821BAC3C;  }
		/* 821BAC34h case    8:*/		return 0x821BAC38;
	}
	return 0x821BAC38;
} // Block from 821BAC14h-821BAC38h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821BAC38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BAC38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BAC38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BAC38);
		  /* 821BAC38h */ case    0:  		/* li R11, 0 */
		/* 821BAC38h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BAC38h case    0:*/		return 0x821BAC3C;
	}
	return 0x821BAC3C;
} // Block from 821BAC38h-821BAC3Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BAC3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BAC3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BAC3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BAC3C);
		  /* 821BAC3Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821BAC3Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821BAC3Ch case    0:*/		return 0x821BAC40;
		  /* 821BAC40h */ case    1:  		/* bc 12, CR0_EQ, 76 */
		/* 821BAC40h case    1:*/		if ( regs.CR[0].eq ) { return 0x821BAC8C;  }
		/* 821BAC40h case    1:*/		return 0x821BAC44;
		  /* 821BAC44h */ case    2:  		/* cmplwi CR6, R26, 124 */
		/* 821BAC44h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x0000007C);
		/* 821BAC44h case    2:*/		return 0x821BAC48;
		  /* 821BAC48h */ case    3:  		/* bc 4, CR6_EQ, 76 */
		/* 821BAC48h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821BAC94;  }
		/* 821BAC48h case    3:*/		return 0x821BAC4C;
		  /* 821BAC4Ch */ case    4:  		/* lwz R11, <#[R30 + 8]> */
		/* 821BAC4Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821BAC4Ch case    4:*/		return 0x821BAC50;
		  /* 821BAC50h */ case    5:  		/* mr R3, R15 */
		/* 821BAC50h case    5:*/		regs.R3 = regs.R15;
		/* 821BAC50h case    5:*/		return 0x821BAC54;
		  /* 821BAC54h */ case    6:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 821BAC54h case    6:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 821BAC54h case    6:*/		return 0x821BAC58;
		  /* 821BAC58h */ case    7:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 821BAC58h case    7:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 821BAC58h case    7:*/		return 0x821BAC5C;
		  /* 821BAC5Ch */ case    8:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 821BAC5Ch case    8:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 821BAC5Ch case    8:*/		return 0x821BAC60;
		  /* 821BAC60h */ case    9:  		/* bl -354352 */
		/* 821BAC60h case    9:*/		regs.LR = 0x821BAC64; return 0x82164430;
		/* 821BAC60h case    9:*/		return 0x821BAC64;
		  /* 821BAC64h */ case   10:  		/* addi R10, R30, -8 */
		/* 821BAC64h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0xFFFFFFF8);
		/* 821BAC64h case   10:*/		return 0x821BAC68;
		  /* 821BAC68h */ case   11:  		/* lwz R11, <#[R15 + 12]> */
		/* 821BAC68h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x0000000C) );
		/* 821BAC68h case   11:*/		return 0x821BAC6C;
		  /* 821BAC6Ch */ case   12:  		/* lwzx R10, <#[R3 + R10]> */
		/* 821BAC6Ch case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + regs.R10 + 0x00000000) );
		/* 821BAC6Ch case   12:*/		return 0x821BAC70;
		  /* 821BAC70h */ case   13:  		/* rlwinm R10, R10, 0, 17, 31 */
		/* 821BAC70h case   13:*/		cpu::op::rlwinm<0,0,17,31>(regs,&regs.R10,regs.R10);
		/* 821BAC70h case   13:*/		return 0x821BAC74;
		  /* 821BAC74h */ case   14:  		/* mulli R10, R10, 40 */
		/* 821BAC74h case   14:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x28);
		/* 821BAC74h case   14:*/		return 0x821BAC78;
		  /* 821BAC78h */ case   15:  		/* add R11, R10, R11 */
		/* 821BAC78h case   15:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821BAC78h case   15:*/		return 0x821BAC7C;
		  /* 821BAC7Ch */ case   16:  		/* lwz R11, <#[R11 + 4]> */
		/* 821BAC7Ch case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821BAC7Ch case   16:*/		return 0x821BAC80;
		  /* 821BAC80h */ case   17:  		/* rlwinm R11, R11, 0, 25, 27 */
		/* 821BAC80h case   17:*/		cpu::op::rlwinm<0,0,25,27>(regs,&regs.R11,regs.R11);
		/* 821BAC80h case   17:*/		return 0x821BAC84;
		  /* 821BAC84h */ case   18:  		/* cmplwi CR6, R11, 48 */
		/* 821BAC84h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000030);
		/* 821BAC84h case   18:*/		return 0x821BAC88;
		  /* 821BAC88h */ case   19:  		/* bc 4, CR6_EQ, 12 */
		/* 821BAC88h case   19:*/		if ( !regs.CR[6].eq ) { return 0x821BAC94;  }
		/* 821BAC88h case   19:*/		return 0x821BAC8C;
	}
	return 0x821BAC8C;
} // Block from 821BAC3Ch-821BAC8Ch (20 instructions)

//////////////////////////////////////////////////////
// Block at 821BAC8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BAC8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BAC8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BAC8C);
		  /* 821BAC8Ch */ case    0:  		/* cmplwi CR6, R31, 104 */
		/* 821BAC8Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000068);
		/* 821BAC8Ch case    0:*/		return 0x821BAC90;
		  /* 821BAC90h */ case    1:  		/* bc 4, CR6_EQ, 40 */
		/* 821BAC90h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BACB8;  }
		/* 821BAC90h case    1:*/		return 0x821BAC94;
	}
	return 0x821BAC94;
} // Block from 821BAC8Ch-821BAC94h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BAC94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BAC94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BAC94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BAC94);
		  /* 821BAC94h */ case    0:  		/* mr R6, R29 */
		/* 821BAC94h case    0:*/		regs.R6 = regs.R29;
		/* 821BAC94h case    0:*/		return 0x821BAC98;
		  /* 821BAC98h */ case    1:  		/* mr R5, R24 */
		/* 821BAC98h case    1:*/		regs.R5 = regs.R24;
		/* 821BAC98h case    1:*/		return 0x821BAC9C;
		  /* 821BAC9Ch */ case    2:  		/* mr R4, R16 */
		/* 821BAC9Ch case    2:*/		regs.R4 = regs.R16;
		/* 821BAC9Ch case    2:*/		return 0x821BACA0;
		  /* 821BACA0h */ case    3:  		/* mr R3, R15 */
		/* 821BACA0h case    3:*/		regs.R3 = regs.R15;
		/* 821BACA0h case    3:*/		return 0x821BACA4;
		  /* 821BACA4h */ case    4:  		/* bl -13116 */
		/* 821BACA4h case    4:*/		regs.LR = 0x821BACA8; return 0x821B7968;
		/* 821BACA4h case    4:*/		return 0x821BACA8;
		  /* 821BACA8h */ case    5:  		/* rlwinm R11, R3, 0, 24, 31 */
		/* 821BACA8h case    5:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821BACA8h case    5:*/		return 0x821BACAC;
		  /* 821BACACh */ case    6:  		/* rlwinm R10, R17, 0, 24, 31 */
		/* 821BACACh case    6:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R17);
		/* 821BACACh case    6:*/		return 0x821BACB0;
		  /* 821BACB0h */ case    7:  		/* or R17, R11, R10 */
		/* 821BACB0h case    7:*/		cpu::op::or<0>(regs,&regs.R17,regs.R11,regs.R10);
		/* 821BACB0h case    7:*/		return 0x821BACB4;
		  /* 821BACB4h */ case    8:  		/* b 232 */
		/* 821BACB4h case    8:*/		return 0x821BAD9C;
		/* 821BACB4h case    8:*/		return 0x821BACB8;
	}
	return 0x821BACB8;
} // Block from 821BAC94h-821BACB8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821BACB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BACB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BACB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BACB8);
		  /* 821BACB8h */ case    0:  		/* mr R10, R30 */
		/* 821BACB8h case    0:*/		regs.R10 = regs.R30;
		/* 821BACB8h case    0:*/		return 0x821BACBC;
		  /* 821BACBCh */ case    1:  		/* b 60 */
		/* 821BACBCh case    1:*/		return 0x821BACF8;
		/* 821BACBCh case    1:*/		return 0x821BACC0;
	}
	return 0x821BACC0;
} // Block from 821BACB8h-821BACC0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BACC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BACC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BACC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BACC0);
		  /* 821BACC0h */ case    0:  		/* cmplwi CR6, R26, 118 */
		/* 821BACC0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000076);
		/* 821BACC0h case    0:*/		return 0x821BACC4;
		  /* 821BACC4h */ case    1:  		/* bc 4, CR6_EQ, 188 */
		/* 821BACC4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BAD80;  }
		/* 821BACC4h case    1:*/		return 0x821BACC8;
		  /* 821BACC8h */ case    2:  		/* lwz R11, <#[R30 + 44]> */
		/* 821BACC8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000002C) );
		/* 821BACC8h case    2:*/		return 0x821BACCC;
		  /* 821BACCCh */ case    3:  		/* lwz R10, <#[R11 + 12]> */
		/* 821BACCCh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 821BACCCh case    3:*/		return 0x821BACD0;
		  /* 821BACD0h */ case    4:  		/* lwz R11, <#[R10 + 8]> */
		/* 821BACD0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 821BACD0h case    4:*/		return 0x821BACD4;
		  /* 821BACD4h */ case    5:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821BACD4h case    5:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821BACD4h case    5:*/		return 0x821BACD8;
		  /* 821BACD8h */ case    6:  		/* cmplwi CR6, R11, 125 */
		/* 821BACD8h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 821BACD8h case    6:*/		return 0x821BACDC;
		  /* 821BACDCh */ case    7:  		/* bc 12, CR6_EQ, 16 */
		/* 821BACDCh case    7:*/		if ( regs.CR[6].eq ) { return 0x821BACEC;  }
		/* 821BACDCh case    7:*/		return 0x821BACE0;
		  /* 821BACE0h */ case    8:  		/* cmplwi CR6, R11, 124 */
		/* 821BACE0h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 821BACE0h case    8:*/		return 0x821BACE4;
		  /* 821BACE4h */ case    9:  		/* li R11, 0 */
		/* 821BACE4h case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BACE4h case    9:*/		return 0x821BACE8;
		  /* 821BACE8h */ case   10:  		/* bc 4, CR6_EQ, 8 */
		/* 821BACE8h case   10:*/		if ( !regs.CR[6].eq ) { return 0x821BACF0;  }
		/* 821BACE8h case   10:*/		return 0x821BACEC;
	}
	return 0x821BACEC;
} // Block from 821BACC0h-821BACECh (11 instructions)

//////////////////////////////////////////////////////
// Block at 821BACECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BACEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BACEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BACEC);
		  /* 821BACECh */ case    0:  		/* li R11, 1 */
		/* 821BACECh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821BACECh case    0:*/		return 0x821BACF0;
	}
	return 0x821BACF0;
} // Block from 821BACECh-821BACF0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BACF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BACF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BACF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BACF0);
		  /* 821BACF0h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821BACF0h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821BACF0h case    0:*/		return 0x821BACF4;
		  /* 821BACF4h */ case    1:  		/* bc 12, CR0_EQ, 2636 */
		/* 821BACF4h case    1:*/		if ( regs.CR[0].eq ) { return 0x821BB740;  }
		/* 821BACF4h case    1:*/		return 0x821BACF8;
	}
	return 0x821BACF8;
} // Block from 821BACF0h-821BACF8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BACF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BACF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BACF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BACF8);
		  /* 821BACF8h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 821BACF8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821BACF8h case    0:*/		return 0x821BACFC;
		  /* 821BACFCh */ case    1:  		/* bc 12, CR6_EQ, 132 */
		/* 821BACFCh case    1:*/		if ( regs.CR[6].eq ) { return 0x821BAD80;  }
		/* 821BACFCh case    1:*/		return 0x821BAD00;
		  /* 821BAD00h */ case    2:  		/* li R11, 1 */
		/* 821BAD00h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821BAD00h case    2:*/		return 0x821BAD04;
		  /* 821BAD04h */ case    3:  		/* rlwinm. R9, R28, 31, 31, 31 */
		/* 821BAD04h case    3:*/		cpu::op::rlwinm<1,31,31,31>(regs,&regs.R9,regs.R28);
		/* 821BAD04h case    3:*/		return 0x821BAD08;
		  /* 821BAD08h */ case    4:  		/* slw R8, R11, R24 */
		/* 821BAD08h case    4:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R11,regs.R24);
		/* 821BAD08h case    4:*/		return 0x821BAD0C;
		  /* 821BAD0Ch */ case    5:  		/* or R18, R18, R8 */
		/* 821BAD0Ch case    5:*/		cpu::op::or<0>(regs,&regs.R18,regs.R18,regs.R8);
		/* 821BAD0Ch case    5:*/		return 0x821BAD10;
		  /* 821BAD10h */ case    6:  		/* bc 12, CR0_EQ, 8 */
		/* 821BAD10h case    6:*/		if ( regs.CR[0].eq ) { return 0x821BAD18;  }
		/* 821BAD10h case    6:*/		return 0x821BAD14;
		  /* 821BAD14h */ case    7:  		/* or R23, R23, R8 */
		/* 821BAD14h case    7:*/		cpu::op::or<0>(regs,&regs.R23,regs.R23,regs.R8);
		/* 821BAD14h case    7:*/		return 0x821BAD18;
	}
	return 0x821BAD18;
} // Block from 821BACF8h-821BAD18h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821BAD18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BAD18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BAD18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BAD18);
		  /* 821BAD18h */ case    0:  		/* lwz R11, <#[R10 + 8]> */
		/* 821BAD18h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 821BAD18h case    0:*/		return 0x821BAD1C;
		  /* 821BAD1Ch */ case    1:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821BAD1Ch case    1:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821BAD1Ch case    1:*/		return 0x821BAD20;
		  /* 821BAD20h */ case    2:  		/* cmplwi CR6, R11, 15872 */
		/* 821BAD20h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E00);
		/* 821BAD20h case    2:*/		return 0x821BAD24;
		  /* 821BAD24h */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 821BAD24h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821BAD30;  }
		/* 821BAD24h case    3:*/		return 0x821BAD28;
		  /* 821BAD28h */ case    4:  		/* or R22, R22, R8 */
		/* 821BAD28h case    4:*/		cpu::op::or<0>(regs,&regs.R22,regs.R22,regs.R8);
		/* 821BAD28h case    4:*/		return 0x821BAD2C;
		  /* 821BAD2Ch */ case    5:  		/* b 84 */
		/* 821BAD2Ch case    5:*/		return 0x821BAD80;
		/* 821BAD2Ch case    5:*/		return 0x821BAD30;
	}
	return 0x821BAD30;
} // Block from 821BAD18h-821BAD30h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BAD30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BAD30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BAD30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BAD30);
		  /* 821BAD30h */ case    0:  		/* cmplw CR6, R10, R30 */
		/* 821BAD30h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R30);
		/* 821BAD30h case    0:*/		return 0x821BAD34;
		  /* 821BAD34h */ case    1:  		/* bc 4, CR6_EQ, 76 */
		/* 821BAD34h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BAD80;  }
		/* 821BAD34h case    1:*/		return 0x821BAD38;
		  /* 821BAD38h */ case    2:  		/* li R9, 0 */
		/* 821BAD38h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821BAD38h case    2:*/		return 0x821BAD3C;
		  /* 821BAD3Ch */ case    3:  		/* cmplwi CR6, R27, 0 */
		/* 821BAD3Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 821BAD3Ch case    3:*/		return 0x821BAD40;
		  /* 821BAD40h */ case    4:  		/* bc 12, CR6_EQ, 64 */
		/* 821BAD40h case    4:*/		if ( regs.CR[6].eq ) { return 0x821BAD80;  }
		/* 821BAD40h case    4:*/		return 0x821BAD44;
		  /* 821BAD44h */ case    5:  		/* li R11, 0 */
		/* 821BAD44h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BAD44h case    5:*/		return 0x821BAD48;
		  /* 821BAD48h */ case    6:  		/* rlwinm R10, R28, 27, 24, 31 */
		/* 821BAD48h case    6:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R10,regs.R28);
		/* 821BAD48h case    6:*/		return 0x821BAD4C;
		  /* 821BAD4Ch */ case    7:  		/* srw R10, R10, R11 */
		/* 821BAD4Ch case    7:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 821BAD4Ch case    7:*/		return 0x821BAD50;
		  /* 821BAD50h */ case    8:  		/* rlwinm R10, R10, 0, 30, 31 */
		/* 821BAD50h case    8:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R10,regs.R10);
		/* 821BAD50h case    8:*/		return 0x821BAD54;
		  /* 821BAD54h */ case    9:  		/* addi R10, R10, 11 */
		/* 821BAD54h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xB);
		/* 821BAD54h case    9:*/		return 0x821BAD58;
		  /* 821BAD58h */ case   10:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821BAD58h case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821BAD58h case   10:*/		return 0x821BAD5C;
		  /* 821BAD5Ch */ case   11:  		/* lfsx FR0, <#[R10 + R30]> */
		/* 821BAD5Ch case   11:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R10 + regs.R30 + 0x00000000) );
		/* 821BAD5Ch case   11:*/		return 0x821BAD60;
		  /* 821BAD60h */ case   12:  		/* fcmpu CR6, FR0, FR31 */
		/* 821BAD60h case   12:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 821BAD60h case   12:*/		return 0x821BAD64;
		  /* 821BAD64h */ case   13:  		/* bc 12, CR6_LT, 24 */
		/* 821BAD64h case   13:*/		if ( regs.CR[6].lt ) { return 0x821BAD7C;  }
		/* 821BAD64h case   13:*/		return 0x821BAD68;
		  /* 821BAD68h */ case   14:  		/* addi R9, R9, 1 */
		/* 821BAD68h case   14:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 821BAD68h case   14:*/		return 0x821BAD6C;
		  /* 821BAD6Ch */ case   15:  		/* addi R11, R11, 2 */
		/* 821BAD6Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 821BAD6Ch case   15:*/		return 0x821BAD70;
		  /* 821BAD70h */ case   16:  		/* cmplw CR6, R9, R27 */
		/* 821BAD70h case   16:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R27);
		/* 821BAD70h case   16:*/		return 0x821BAD74;
		  /* 821BAD74h */ case   17:  		/* bc 12, CR6_LT, -44 */
		/* 821BAD74h case   17:*/		if ( regs.CR[6].lt ) { return 0x821BAD48;  }
		/* 821BAD74h case   17:*/		return 0x821BAD78;
		  /* 821BAD78h */ case   18:  		/* b 8 */
		/* 821BAD78h case   18:*/		return 0x821BAD80;
		/* 821BAD78h case   18:*/		return 0x821BAD7C;
	}
	return 0x821BAD7C;
} // Block from 821BAD30h-821BAD7Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 821BAD7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BAD7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BAD7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BAD7C);
		  /* 821BAD7Ch */ case    0:  		/* or R20, R20, R8 */
		/* 821BAD7Ch case    0:*/		cpu::op::or<0>(regs,&regs.R20,regs.R20,regs.R8);
		/* 821BAD7Ch case    0:*/		return 0x821BAD80;
	}
	return 0x821BAD80;
} // Block from 821BAD7Ch-821BAD80h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BAD80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BAD80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BAD80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BAD80);
		  /* 821BAD80h */ case    0:  		/* rlwinm. R11, R25, 0, 27, 27 */
		/* 821BAD80h case    0:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R25);
		/* 821BAD80h case    0:*/		return 0x821BAD84;
		  /* 821BAD84h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 821BAD84h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821BAD90;  }
		/* 821BAD84h case    1:*/		return 0x821BAD88;
		  /* 821BAD88h */ case    2:  		/* cmplwi CR6, R26, 118 */
		/* 821BAD88h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000076);
		/* 821BAD88h case    2:*/		return 0x821BAD8C;
		  /* 821BAD8Ch */ case    3:  		/* bc 4, CR6_EQ, 16 */
		/* 821BAD8Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x821BAD9C;  }
		/* 821BAD8Ch case    3:*/		return 0x821BAD90;
	}
	return 0x821BAD90;
} // Block from 821BAD80h-821BAD90h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BAD90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BAD90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BAD90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BAD90);
		  /* 821BAD90h */ case    0:  		/* li R11, 1 */
		/* 821BAD90h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821BAD90h case    0:*/		return 0x821BAD94;
		  /* 821BAD94h */ case    1:  		/* slw R11, R11, R24 */
		/* 821BAD94h case    1:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R11,regs.R24);
		/* 821BAD94h case    1:*/		return 0x821BAD98;
		  /* 821BAD98h */ case    2:  		/* or R19, R11, R19 */
		/* 821BAD98h case    2:*/		cpu::op::or<0>(regs,&regs.R19,regs.R11,regs.R19);
		/* 821BAD98h case    2:*/		return 0x821BAD9C;
	}
	return 0x821BAD9C;
} // Block from 821BAD90h-821BAD9Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BAD9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BAD9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BAD9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BAD9C);
		  /* 821BAD9Ch */ case    0:  		/* lwz R11, <#[R16 + 8]> */
		/* 821BAD9Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000008) );
		/* 821BAD9Ch case    0:*/		return 0x821BADA0;
		  /* 821BADA0h */ case    1:  		/* addi R24, R24, 1 */
		/* 821BADA0h case    1:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x1);
		/* 821BADA0h case    1:*/		return 0x821BADA4;
		  /* 821BADA4h */ case    2:  		/* addi R21, R21, 4 */
		/* 821BADA4h case    2:*/		cpu::op::addi<0>(regs,&regs.R21,regs.R21,0x4);
		/* 821BADA4h case    2:*/		return 0x821BADA8;
		  /* 821BADA8h */ case    3:  		/* rlwinm R11, R11, 13, 29, 31 */
		/* 821BADA8h case    3:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R11,regs.R11);
		/* 821BADA8h case    3:*/		return 0x821BADAC;
		  /* 821BADACh */ case    4:  		/* cmplw CR6, R24, R11 */
		/* 821BADACh case    4:*/		cpu::op::cmplw<6>(regs,regs.R24,regs.R11);
		/* 821BADACh case    4:*/		return 0x821BADB0;
		  /* 821BADB0h */ case    5:  		/* bc 12, CR6_LT, -632 */
		/* 821BADB0h case    5:*/		if ( regs.CR[6].lt ) { return 0x821BAB38;  }
		/* 821BADB0h case    5:*/		return 0x821BADB4;
	}
	return 0x821BADB4;
} // Block from 821BAD9Ch-821BADB4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BADB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BADB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BADB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BADB4);
		  /* 821BADB4h */ case    0:  		/* li R24, 0 */
		/* 821BADB4h case    0:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 821BADB4h case    0:*/		return 0x821BADB8;
		  /* 821BADB8h */ case    1:  		/* cmplwi CR6, R23, 0 */
		/* 821BADB8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R23,0x00000000);
		/* 821BADB8h case    1:*/		return 0x821BADBC;
		  /* 821BADBCh */ case    2:  		/* bc 12, CR6_EQ, 352 */
		/* 821BADBCh case    2:*/		if ( regs.CR[6].eq ) { return 0x821BAF1C;  }
		/* 821BADBCh case    2:*/		return 0x821BADC0;
		  /* 821BADC0h */ case    3:  		/* cmplw CR6, R23, R18 */
		/* 821BADC0h case    3:*/		cpu::op::cmplw<6>(regs,regs.R23,regs.R18);
		/* 821BADC0h case    3:*/		return 0x821BADC4;
		  /* 821BADC4h */ case    4:  		/* bc 12, CR6_EQ, 344 */
		/* 821BADC4h case    4:*/		if ( regs.CR[6].eq ) { return 0x821BAF1C;  }
		/* 821BADC4h case    4:*/		return 0x821BADC8;
		  /* 821BADC8h */ case    5:  		/* and R11, R22, R23 */
		/* 821BADC8h case    5:*/		cpu::op::and<0>(regs,&regs.R11,regs.R22,regs.R23);
		/* 821BADC8h case    5:*/		return 0x821BADCC;
		  /* 821BADCCh */ case    6:  		/* cmplw CR6, R11, R22 */
		/* 821BADCCh case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R22);
		/* 821BADCCh case    6:*/		return 0x821BADD0;
		  /* 821BADD0h */ case    7:  		/* bc 4, CR6_EQ, 12 */
		/* 821BADD0h case    7:*/		if ( !regs.CR[6].eq ) { return 0x821BADDC;  }
		/* 821BADD0h case    7:*/		return 0x821BADD4;
		  /* 821BADD4h */ case    8:  		/* andc. R10, R20, R23 */
		/* 821BADD4h case    8:*/		cpu::op::andc<1>(regs,&regs.R10,regs.R20,regs.R23);
		/* 821BADD4h case    8:*/		return 0x821BADD8;
		  /* 821BADD8h */ case    9:  		/* bc 12, CR0_EQ, 12 */
		/* 821BADD8h case    9:*/		if ( regs.CR[0].eq ) { return 0x821BADE4;  }
		/* 821BADD8h case    9:*/		return 0x821BADDC;
	}
	return 0x821BADDC;
} // Block from 821BADB4h-821BADDCh (10 instructions)

//////////////////////////////////////////////////////
// Block at 821BADDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BADDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BADDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BADDC);
		  /* 821BADDCh */ case    0:  		/* mr R24, R11 */
		/* 821BADDCh case    0:*/		regs.R24 = regs.R11;
		/* 821BADDCh case    0:*/		return 0x821BADE0;
		  /* 821BADE0h */ case    1:  		/* subf R23, R11, R23 */
		/* 821BADE0h case    1:*/		cpu::op::subf<0>(regs,&regs.R23,regs.R11,regs.R23);
		/* 821BADE0h case    1:*/		return 0x821BADE4;
	}
	return 0x821BADE4;
} // Block from 821BADDCh-821BADE4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BADE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BADE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BADE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BADE4);
		  /* 821BADE4h */ case    0:  		/* and. R25, R22, R23 */
		/* 821BADE4h case    0:*/		cpu::op::and<1>(regs,&regs.R25,regs.R22,regs.R23);
		/* 821BADE4h case    0:*/		return 0x821BADE8;
		  /* 821BADE8h */ case    1:  		/* nor R11, R22, R23 */
		/* 821BADE8h case    1:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R22,regs.R23);
		/* 821BADE8h case    1:*/		return 0x821BADEC;
		  /* 821BADECh */ case    2:  		/* bc 4, CR0_EQ, 8 */
		/* 821BADECh case    2:*/		if ( !regs.CR[0].eq ) { return 0x821BADF4;  }
		/* 821BADECh case    2:*/		return 0x821BADF0;
		  /* 821BADF0h */ case    3:  		/* andc R11, R23, R22 */
		/* 821BADF0h case    3:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R23,regs.R22);
		/* 821BADF0h case    3:*/		return 0x821BADF4;
	}
	return 0x821BADF4;
} // Block from 821BADE4h-821BADF4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BADF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BADF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BADF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BADF4);
		  /* 821BADF4h */ case    0:  		/* and R26, R11, R18 */
		/* 821BADF4h case    0:*/		cpu::op::and<0>(regs,&regs.R26,regs.R11,regs.R18);
		/* 821BADF4h case    0:*/		return 0x821BADF8;
		  /* 821BADF8h */ case    1:  		/* cmplwi CR6, R26, 0 */
		/* 821BADF8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 821BADF8h case    1:*/		return 0x821BADFC;
		  /* 821BADFCh */ case    2:  		/* bc 12, CR6_EQ, 288 */
		/* 821BADFCh case    2:*/		if ( regs.CR[6].eq ) { return 0x821BAF1C;  }
		/* 821BADFCh case    2:*/		return 0x821BAE00;
		  /* 821BAE00h */ case    3:  		/* li R20, 57 */
		/* 821BAE00h case    3:*/		cpu::op::li<0>(regs,&regs.R20,0x39);
		/* 821BAE00h case    3:*/		return 0x821BAE04;
		  /* 821BAE04h */ case    4:  		/* addi R11, R26, -1 */
		/* 821BAE04h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R26,0xFFFFFFFF);
		/* 821BAE04h case    4:*/		return 0x821BAE08;
		  /* 821BAE08h */ case    5:  		/* li R29, 0 */
		/* 821BAE08h case    5:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 821BAE08h case    5:*/		return 0x821BAE0C;
		  /* 821BAE0Ch */ case    6:  		/* andc R11, R26, R11 */
		/* 821BAE0Ch case    6:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R26,regs.R11);
		/* 821BAE0Ch case    6:*/		return 0x821BAE10;
		  /* 821BAE10h */ case    7:  		/* cntlzw R10, R11 */
		/* 821BAE10h case    7:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R11);
		/* 821BAE10h case    7:*/		return 0x821BAE14;
		  /* 821BAE14h */ case    8:  		/* subf R26, R11, R26 */
		/* 821BAE14h case    8:*/		cpu::op::subf<0>(regs,&regs.R26,regs.R11,regs.R26);
		/* 821BAE14h case    8:*/		return 0x821BAE18;
		  /* 821BAE18h */ case    9:  		/* subfic R11, R10, 42 */
		/* 821BAE18h case    9:*/		cpu::op::subfic<0>(regs,&regs.R11,regs.R10,0x2A);
		/* 821BAE18h case    9:*/		return 0x821BAE1C;
		  /* 821BAE1Ch */ case   10:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821BAE1Ch case   10:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821BAE1Ch case   10:*/		return 0x821BAE20;
		  /* 821BAE20h */ case   11:  		/* lwzx R31, <#[R11 + R16]> */
		/* 821BAE20h case   11:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + regs.R16 + 0x00000000) );
		/* 821BAE20h case   11:*/		return 0x821BAE24;
		  /* 821BAE24h */ case   12:  		/* lwz R11, <#[R31]> */
		/* 821BAE24h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821BAE24h case   12:*/		return 0x821BAE28;
		  /* 821BAE28h */ case   13:  		/* lwz R27, <#[R31 + 12]> */
		/* 821BAE28h case   13:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R31 + 0x0000000C) );
		/* 821BAE28h case   13:*/		return 0x821BAE2C;
		  /* 821BAE2Ch */ case   14:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 821BAE2Ch case   14:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 821BAE2Ch case   14:*/		return 0x821BAE30;
		  /* 821BAE30h */ case   15:  		/* bc 12, CR0_EQ, 72 */
		/* 821BAE30h case   15:*/		if ( regs.CR[0].eq ) { return 0x821BAE78;  }
		/* 821BAE30h case   15:*/		return 0x821BAE34;
		  /* 821BAE34h */ case   16:  		/* addi R11, R1, 112 */
		/* 821BAE34h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x70);
		/* 821BAE34h case   16:*/		return 0x821BAE38;
		  /* 821BAE38h */ case   17:  		/* li R30, 0 */
		/* 821BAE38h case   17:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 821BAE38h case   17:*/		return 0x821BAE3C;
		  /* 821BAE3Ch */ case   18:  		/* addi R28, R11, -4 */
		/* 821BAE3Ch case   18:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R11,0xFFFFFFFC);
		/* 821BAE3Ch case   18:*/		return 0x821BAE40;
		  /* 821BAE40h */ case   19:  		/* lwz R11, <#[R31]> */
		/* 821BAE40h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821BAE40h case   19:*/		return 0x821BAE44;
		  /* 821BAE44h */ case   20:  		/* li R5, 2 */
		/* 821BAE44h case   20:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 821BAE44h case   20:*/		return 0x821BAE48;
		  /* 821BAE48h */ case   21:  		/* mr R3, R27 */
		/* 821BAE48h case   21:*/		regs.R3 = regs.R27;
		/* 821BAE48h case   21:*/		return 0x821BAE4C;
		  /* 821BAE4Ch */ case   22:  		/* rlwinm R11, R11, 27, 24, 31 */
		/* 821BAE4Ch case   22:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R11,regs.R11);
		/* 821BAE4Ch case   22:*/		return 0x821BAE50;
		  /* 821BAE50h */ case   23:  		/* srw R11, R11, R30 */
		/* 821BAE50h case   23:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R30);
		/* 821BAE50h case   23:*/		return 0x821BAE54;
		  /* 821BAE54h */ case   24:  		/* rlwinm R4, R11, 0, 30, 31 */
		/* 821BAE54h case   24:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R4,regs.R11);
		/* 821BAE54h case   24:*/		return 0x821BAE58;
		  /* 821BAE58h */ case   25:  		/* bl 419888 */
		/* 821BAE58h case   25:*/		regs.LR = 0x821BAE5C; return 0x82221688;
		/* 821BAE58h case   25:*/		return 0x821BAE5C;
		  /* 821BAE5Ch */ case   26:  		/* stfsu FR1, <#[R28 + 4]> */
		/* 821BAE5Ch case   26:*/		cpu::mem::store32f( regs, regs.FR1, (uint32)(regs.R28 + 0x00000004) );
		regs.R28 = (uint32)(regs.R28 + 0x00000004);
		/* 821BAE5Ch case   26:*/		return 0x821BAE60;
		  /* 821BAE60h */ case   27:  		/* addi R29, R29, 1 */
		/* 821BAE60h case   27:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 821BAE60h case   27:*/		return 0x821BAE64;
		  /* 821BAE64h */ case   28:  		/* addi R30, R30, 2 */
		/* 821BAE64h case   28:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R30,0x2);
		/* 821BAE64h case   28:*/		return 0x821BAE68;
		  /* 821BAE68h */ case   29:  		/* lwz R11, <#[R31]> */
		/* 821BAE68h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821BAE68h case   29:*/		return 0x821BAE6C;
		  /* 821BAE6Ch */ case   30:  		/* rlwinm R11, R11, 7, 29, 31 */
		/* 821BAE6Ch case   30:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R11,regs.R11);
		/* 821BAE6Ch case   30:*/		return 0x821BAE70;
		  /* 821BAE70h */ case   31:  		/* cmplw CR6, R29, R11 */
		/* 821BAE70h case   31:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 821BAE70h case   31:*/		return 0x821BAE74;
		  /* 821BAE74h */ case   32:  		/* bc 12, CR6_LT, -52 */
		/* 821BAE74h case   32:*/		if ( regs.CR[6].lt ) { return 0x821BAE40;  }
		/* 821BAE74h case   32:*/		return 0x821BAE78;
	}
	return 0x821BAE78;
} // Block from 821BADF4h-821BAE78h (33 instructions)

//////////////////////////////////////////////////////
// Block at 821BAE78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BAE78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BAE78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BAE78);
		  /* 821BAE78h */ case    0:  		/* addi R11, R1, 96 */
		/* 821BAE78h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R1,0x60);
		/* 821BAE78h case    0:*/		return 0x821BAE7C;
		  /* 821BAE7Ch */ case    1:  		/* lwz R10, <#[R31]> */
		/* 821BAE7Ch case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 821BAE7Ch case    1:*/		return 0x821BAE80;
		  /* 821BAE80h */ case    2:  		/* li R9, 0 */
		/* 821BAE80h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821BAE80h case    2:*/		return 0x821BAE84;
		  /* 821BAE84h */ case    3:  		/* rlwinm R4, R10, 7, 29, 31 */
		/* 821BAE84h case    3:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R4,regs.R10);
		/* 821BAE84h case    3:*/		return 0x821BAE88;
		  /* 821BAE88h */ case    4:  		/* addi R5, R1, 112 */
		/* 821BAE88h case    4:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x70);
		/* 821BAE88h case    4:*/		return 0x821BAE8C;
		  /* 821BAE8Ch */ case    5:  		/* mr R3, R15 */
		/* 821BAE8Ch case    5:*/		regs.R3 = regs.R15;
		/* 821BAE8Ch case    5:*/		return 0x821BAE90;
		  /* 821BAE90h */ case    6:  		/* stw R9, <#[R11]> */
		/* 821BAE90h case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821BAE90h case    6:*/		return 0x821BAE94;
		  /* 821BAE94h */ case    7:  		/* lwz R6, <#[R1 + 96]> */
		/* 821BAE94h case    7:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R1 + 0x00000060) );
		/* 821BAE94h case    7:*/		return 0x821BAE98;
		  /* 821BAE98h */ case    8:  		/* bl 442784 */
		/* 821BAE98h case    8:*/		regs.LR = 0x821BAE9C; return 0x82227038;
		/* 821BAE98h case    8:*/		return 0x821BAE9C;
		  /* 821BAE9Ch */ case    9:  		/* lwz R11, <#[R31 + 12]> */
		/* 821BAE9Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 821BAE9Ch case    9:*/		return 0x821BAEA0;
		  /* 821BAEA0h */ case   10:  		/* mr R30, R3 */
		/* 821BAEA0h case   10:*/		regs.R30 = regs.R3;
		/* 821BAEA0h case   10:*/		return 0x821BAEA4;
		  /* 821BAEA4h */ case   11:  		/* addi R11, R11, 4 */
		/* 821BAEA4h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821BAEA4h case   11:*/		return 0x821BAEA8;
		  /* 821BAEA8h */ case   12:  		/* lwz R10, <#[R11]> */
		/* 821BAEA8h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821BAEA8h case   12:*/		return 0x821BAEAC;
		  /* 821BAEACh */ case   13:  		/* b 12 */
		/* 821BAEACh case   13:*/		return 0x821BAEB8;
		/* 821BAEACh case   13:*/		return 0x821BAEB0;
		  /* 821BAEB0h */ case   14:  		/* addi R11, R10, 8 */
		/* 821BAEB0h case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 821BAEB0h case   14:*/		return 0x821BAEB4;
		  /* 821BAEB4h */ case   15:  		/* lwz R10, <#[R10 + 8]> */
		/* 821BAEB4h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 821BAEB4h case   15:*/		return 0x821BAEB8;
	}
	return 0x821BAEB8;
} // Block from 821BAE78h-821BAEB8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821BAEB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BAEB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BAEB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BAEB8);
		  /* 821BAEB8h */ case    0:  		/* cmplw CR6, R10, R31 */
		/* 821BAEB8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 821BAEB8h case    0:*/		return 0x821BAEBC;
		  /* 821BAEBCh */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 821BAEBCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BAEB0;  }
		/* 821BAEBCh case    1:*/		return 0x821BAEC0;
		  /* 821BAEC0h */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 821BAEC0h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 821BAEC0h case    2:*/		return 0x821BAEC4;
		  /* 821BAEC4h */ case    3:  		/* cmplwi CR6, R25, 0 */
		/* 821BAEC4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R25,0x00000000);
		/* 821BAEC4h case    3:*/		return 0x821BAEC8;
		  /* 821BAEC8h */ case    4:  		/* stw R10, <#[R11]> */
		/* 821BAEC8h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821BAEC8h case    4:*/		return 0x821BAECC;
		  /* 821BAECCh */ case    5:  		/* lwz R11, <#[R30 + 4]> */
		/* 821BAECCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000004) );
		/* 821BAECCh case    5:*/		return 0x821BAED0;
		  /* 821BAED0h */ case    6:  		/* stw R11, <#[R31 + 8]> */
		/* 821BAED0h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821BAED0h case    6:*/		return 0x821BAED4;
		  /* 821BAED4h */ case    7:  		/* stw R31, <#[R30 + 4]> */
		/* 821BAED4h case    7:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000004) );
		/* 821BAED4h case    7:*/		return 0x821BAED8;
		  /* 821BAED8h */ case    8:  		/* lwz R11, <#[R31]> */
		/* 821BAED8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821BAED8h case    8:*/		return 0x821BAEDC;
		  /* 821BAEDCh */ case    9:  		/* rlwimi R11, R20, 7, 19, 26 */
		/* 821BAEDCh case    9:*/		cpu::op::rlwimi<0,7,19,26>(regs,&regs.R11,regs.R20);
		/* 821BAEDCh case    9:*/		return 0x821BAEE0;
		  /* 821BAEE0h */ case   10:  		/* stw R30, <#[R31 + 12]> */
		/* 821BAEE0h case   10:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x0000000C) );
		/* 821BAEE0h case   10:*/		return 0x821BAEE4;
		  /* 821BAEE4h */ case   11:  		/* stw R11, <#[R31]> */
		/* 821BAEE4h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821BAEE4h case   11:*/		return 0x821BAEE8;
		  /* 821BAEE8h */ case   12:  		/* bc 12, CR6_EQ, 12 */
		/* 821BAEE8h case   12:*/		if ( regs.CR[6].eq ) { return 0x821BAEF4;  }
		/* 821BAEE8h case   12:*/		return 0x821BAEEC;
		  /* 821BAEECh */ case   13:  		/* ori R11, R11, 2 */
		/* 821BAEECh case   13:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x2);
		/* 821BAEECh case   13:*/		return 0x821BAEF0;
		  /* 821BAEF0h */ case   14:  		/* b 8 */
		/* 821BAEF0h case   14:*/		return 0x821BAEF8;
		/* 821BAEF0h case   14:*/		return 0x821BAEF4;
	}
	return 0x821BAEF4;
} // Block from 821BAEB8h-821BAEF4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 821BAEF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BAEF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BAEF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BAEF4);
		  /* 821BAEF4h */ case    0:  		/* rlwinm R11, R11, 0, 31, 29 */
		/* 821BAEF4h case    0:*/		cpu::op::rlwinm<0,0,31,29>(regs,&regs.R11,regs.R11);
		/* 821BAEF4h case    0:*/		return 0x821BAEF8;
	}
	return 0x821BAEF8;
} // Block from 821BAEF4h-821BAEF8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BAEF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BAEF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BAEF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BAEF8);
		  /* 821BAEF8h */ case    0:  		/* stw R11, <#[R31]> */
		/* 821BAEF8h case    0:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821BAEF8h case    0:*/		return 0x821BAEFC;
		  /* 821BAEFCh */ case    1:  		/* mr R3, R30 */
		/* 821BAEFCh case    1:*/		regs.R3 = regs.R30;
		/* 821BAEFCh case    1:*/		return 0x821BAF00;
		  /* 821BAF00h */ case    2:  		/* bl -150352 */
		/* 821BAF00h case    2:*/		regs.LR = 0x821BAF04; return 0x821963B0;
		/* 821BAF00h case    2:*/		return 0x821BAF04;
		  /* 821BAF04h */ case    3:  		/* lwz R11, <#[R30 + 8]> */
		/* 821BAF04h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821BAF04h case    3:*/		return 0x821BAF08;
		  /* 821BAF08h */ case    4:  		/* cmplwi CR6, R26, 0 */
		/* 821BAF08h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 821BAF08h case    4:*/		return 0x821BAF0C;
		  /* 821BAF0Ch */ case    5:  		/* oris R11, R11, 256 */
		/* 821BAF0Ch case    5:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x100);
		/* 821BAF0Ch case    5:*/		return 0x821BAF10;
		  /* 821BAF10h */ case    6:  		/* stw R11, <#[R30 + 8]> */
		/* 821BAF10h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821BAF10h case    6:*/		return 0x821BAF14;
		  /* 821BAF14h */ case    7:  		/* bc 4, CR6_EQ, -272 */
		/* 821BAF14h case    7:*/		if ( !regs.CR[6].eq ) { return 0x821BAE04;  }
		/* 821BAF14h case    7:*/		return 0x821BAF18;
		  /* 821BAF18h */ case    8:  		/* b 8 */
		/* 821BAF18h case    8:*/		return 0x821BAF20;
		/* 821BAF18h case    8:*/		return 0x821BAF1C;
	}
	return 0x821BAF1C;
} // Block from 821BAEF8h-821BAF1Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 821BAF1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BAF1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BAF1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BAF1C);
		  /* 821BAF1Ch */ case    0:  		/* li R20, 57 */
		/* 821BAF1Ch case    0:*/		cpu::op::li<0>(regs,&regs.R20,0x39);
		/* 821BAF1Ch case    0:*/		return 0x821BAF20;
	}
	return 0x821BAF20;
} // Block from 821BAF1Ch-821BAF20h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BAF20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BAF20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BAF20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BAF20);
		  /* 821BAF20h */ case    0:  		/* andc. R4, R19, R24 */
		/* 821BAF20h case    0:*/		cpu::op::andc<1>(regs,&regs.R4,regs.R19,regs.R24);
		/* 821BAF20h case    0:*/		return 0x821BAF24;
		  /* 821BAF24h */ case    1:  		/* bc 12, CR0_EQ, 32 */
		/* 821BAF24h case    1:*/		if ( regs.CR[0].eq ) { return 0x821BAF44;  }
		/* 821BAF24h case    1:*/		return 0x821BAF28;
		  /* 821BAF28h */ case    2:  		/* addi R11, R4, -1 */
		/* 821BAF28h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R4,0xFFFFFFFF);
		/* 821BAF28h case    2:*/		return 0x821BAF2C;
		  /* 821BAF2Ch */ case    3:  		/* andc R11, R4, R11 */
		/* 821BAF2Ch case    3:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R4,regs.R11);
		/* 821BAF2Ch case    3:*/		return 0x821BAF30;
		  /* 821BAF30h */ case    4:  		/* subf. R11, R11, R4 */
		/* 821BAF30h case    4:*/		cpu::op::subf<1>(regs,&regs.R11,regs.R11,regs.R4);
		/* 821BAF30h case    4:*/		return 0x821BAF34;
		  /* 821BAF34h */ case    5:  		/* bc 4, CR0_EQ, 16 */
		/* 821BAF34h case    5:*/		if ( !regs.CR[0].eq ) { return 0x821BAF44;  }
		/* 821BAF34h case    5:*/		return 0x821BAF38;
		  /* 821BAF38h */ case    6:  		/* li R21, 1 */
		/* 821BAF38h case    6:*/		cpu::op::li<0>(regs,&regs.R21,0x1);
		/* 821BAF38h case    6:*/		return 0x821BAF3C;
		  /* 821BAF3Ch */ case    7:  		/* mr R11, R21 */
		/* 821BAF3Ch case    7:*/		regs.R11 = regs.R21;
		/* 821BAF3Ch case    7:*/		return 0x821BAF40;
		  /* 821BAF40h */ case    8:  		/* b 12 */
		/* 821BAF40h case    8:*/		return 0x821BAF4C;
		/* 821BAF40h case    8:*/		return 0x821BAF44;
	}
	return 0x821BAF44;
} // Block from 821BAF20h-821BAF44h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821BAF44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BAF44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BAF44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BAF44);
		  /* 821BAF44h */ case    0:  		/* li R11, 0 */
		/* 821BAF44h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BAF44h case    0:*/		return 0x821BAF48;
		  /* 821BAF48h */ case    1:  		/* li R21, 1 */
		/* 821BAF48h case    1:*/		cpu::op::li<0>(regs,&regs.R21,0x1);
		/* 821BAF48h case    1:*/		return 0x821BAF4C;
	}
	return 0x821BAF4C;
} // Block from 821BAF44h-821BAF4Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BAF4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BAF4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BAF4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BAF4C);
		  /* 821BAF4Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821BAF4Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821BAF4Ch case    0:*/		return 0x821BAF50;
		  /* 821BAF50h */ case    1:  		/* bc 4, CR0_EQ, 164 */
		/* 821BAF50h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821BAFF4;  }
		/* 821BAF50h case    1:*/		return 0x821BAF54;
		  /* 821BAF54h */ case    2:  		/* lwz R11, <#[R16 + 8]> */
		/* 821BAF54h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000008) );
		/* 821BAF54h case    2:*/		return 0x821BAF58;
		  /* 821BAF58h */ case    3:  		/* li R8, 0 */
		/* 821BAF58h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821BAF58h case    3:*/		return 0x821BAF5C;
		  /* 821BAF5Ch */ case    4:  		/* li R6, 0 */
		/* 821BAF5Ch case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821BAF5Ch case    4:*/		return 0x821BAF60;
		  /* 821BAF60h */ case    5:  		/* li R9, 0 */
		/* 821BAF60h case    5:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821BAF60h case    5:*/		return 0x821BAF64;
		  /* 821BAF64h */ case    6:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 821BAF64h case    6:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 821BAF64h case    6:*/		return 0x821BAF68;
		  /* 821BAF68h */ case    7:  		/* addi R7, R16, 44 */
		/* 821BAF68h case    7:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R16,0x2C);
		/* 821BAF68h case    7:*/		return 0x821BAF6C;
		  /* 821BAF6Ch */ case    8:  		/* cmplw CR6, R9, R5 */
		/* 821BAF6Ch case    8:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R5);
		/* 821BAF6Ch case    8:*/		return 0x821BAF70;
		  /* 821BAF70h */ case    9:  		/* bc 4, CR6_LT, 132 */
		/* 821BAF70h case    9:*/		if ( !regs.CR[6].lt ) { return 0x821BAFF4;  }
		/* 821BAF70h case    9:*/		return 0x821BAF74;
		  /* 821BAF74h */ case   10:  		/* lwz R10, <#[R7]> */
		/* 821BAF74h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + 0x00000000) );
		/* 821BAF74h case   10:*/		return 0x821BAF78;
		  /* 821BAF78h */ case   11:  		/* lwz R11, <#[R10]> */
		/* 821BAF78h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 821BAF78h case   11:*/		return 0x821BAF7C;
		  /* 821BAF7Ch */ case   12:  		/* rlwinm. R3, R11, 0, 4, 6 */
		/* 821BAF7Ch case   12:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R3,regs.R11);
		/* 821BAF7Ch case   12:*/		return 0x821BAF80;
		  /* 821BAF80h */ case   13:  		/* bc 12, CR0_EQ, 104 */
		/* 821BAF80h case   13:*/		if ( regs.CR[0].eq ) { return 0x821BAFE8;  }
		/* 821BAF80h case   13:*/		return 0x821BAF84;
		  /* 821BAF84h */ case   14:  		/* rlwinm. R3, R11, 0, 27, 28 */
		/* 821BAF84h case   14:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R3,regs.R11);
		/* 821BAF84h case   14:*/		return 0x821BAF88;
		  /* 821BAF88h */ case   15:  		/* bc 12, CR0_EQ, 96 */
		/* 821BAF88h case   15:*/		if ( regs.CR[0].eq ) { return 0x821BAFE8;  }
		/* 821BAF88h case   15:*/		return 0x821BAF8C;
		  /* 821BAF8Ch */ case   16:  		/* rlwinm. R11, R11, 0, 27, 27 */
		/* 821BAF8Ch case   16:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R11);
		/* 821BAF8Ch case   16:*/		return 0x821BAF90;
		  /* 821BAF90h */ case   17:  		/* bc 12, CR0_EQ, 20 */
		/* 821BAF90h case   17:*/		if ( regs.CR[0].eq ) { return 0x821BAFA4;  }
		/* 821BAF90h case   17:*/		return 0x821BAF94;
		  /* 821BAF94h */ case   18:  		/* cmplwi CR6, R8, 0 */
		/* 821BAF94h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 821BAF94h case   18:*/		return 0x821BAF98;
		  /* 821BAF98h */ case   19:  		/* bc 4, CR6_EQ, 72 */
		/* 821BAF98h case   19:*/		if ( !regs.CR[6].eq ) { return 0x821BAFE0;  }
		/* 821BAF98h case   19:*/		return 0x821BAF9C;
		  /* 821BAF9Ch */ case   20:  		/* mr R6, R21 */
		/* 821BAF9Ch case   20:*/		regs.R6 = regs.R21;
		/* 821BAF9Ch case   20:*/		return 0x821BAFA0;
		  /* 821BAFA0h */ case   21:  		/* b 72 */
		/* 821BAFA0h case   21:*/		return 0x821BAFE8;
		/* 821BAFA0h case   21:*/		return 0x821BAFA4;
	}
	return 0x821BAFA4;
} // Block from 821BAF4Ch-821BAFA4h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821BAFA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BAFA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BAFA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BAFA4);
		  /* 821BAFA4h */ case    0:  		/* rlwinm. R11, R6, 0, 24, 31 */
		/* 821BAFA4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R6);
		/* 821BAFA4h case    0:*/		return 0x821BAFA8;
		  /* 821BAFA8h */ case    1:  		/* bc 4, CR0_EQ, 56 */
		/* 821BAFA8h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821BAFE0;  }
		/* 821BAFA8h case    1:*/		return 0x821BAFAC;
		  /* 821BAFACh */ case    2:  		/* lwz R11, <#[R10 + 12]> */
		/* 821BAFACh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		/* 821BAFACh case    2:*/		return 0x821BAFB0;
		  /* 821BAFB0h */ case    3:  		/* lwz R10, <#[R11 + 8]> */
		/* 821BAFB0h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821BAFB0h case    3:*/		return 0x821BAFB4;
		  /* 821BAFB4h */ case    4:  		/* rlwinm R10, R10, 0, 18, 24 */
		/* 821BAFB4h case    4:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R10);
		/* 821BAFB4h case    4:*/		return 0x821BAFB8;
		  /* 821BAFB8h */ case    5:  		/* cmplwi CR6, R10, 15104 */
		/* 821BAFB8h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003B00);
		/* 821BAFB8h case    5:*/		return 0x821BAFBC;
		  /* 821BAFBCh */ case    6:  		/* bc 4, CR6_EQ, 44 */
		/* 821BAFBCh case    6:*/		if ( !regs.CR[6].eq ) { return 0x821BAFE8;  }
		/* 821BAFBCh case    6:*/		return 0x821BAFC0;
		  /* 821BAFC0h */ case    7:  		/* lwz R11, <#[R11 + 48]> */
		/* 821BAFC0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 821BAFC0h case    7:*/		return 0x821BAFC4;
		  /* 821BAFC4h */ case    8:  		/* cmplwi CR6, R8, 0 */
		/* 821BAFC4h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 821BAFC4h case    8:*/		return 0x821BAFC8;
		  /* 821BAFC8h */ case    9:  		/* lwz R11, <#[R11 + 12]> */
		/* 821BAFC8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 821BAFC8h case    9:*/		return 0x821BAFCC;
		  /* 821BAFCCh */ case   10:  		/* bc 4, CR6_EQ, 12 */
		/* 821BAFCCh case   10:*/		if ( !regs.CR[6].eq ) { return 0x821BAFD8;  }
		/* 821BAFCCh case   10:*/		return 0x821BAFD0;
		  /* 821BAFD0h */ case   11:  		/* mr R8, R11 */
		/* 821BAFD0h case   11:*/		regs.R8 = regs.R11;
		/* 821BAFD0h case   11:*/		return 0x821BAFD4;
		  /* 821BAFD4h */ case   12:  		/* b 20 */
		/* 821BAFD4h case   12:*/		return 0x821BAFE8;
		/* 821BAFD4h case   12:*/		return 0x821BAFD8;
	}
	return 0x821BAFD8;
} // Block from 821BAFA4h-821BAFD8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821BAFD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BAFD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BAFD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BAFD8);
		  /* 821BAFD8h */ case    0:  		/* cmplw CR6, R11, R8 */
		/* 821BAFD8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 821BAFD8h case    0:*/		return 0x821BAFDC;
		  /* 821BAFDCh */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 821BAFDCh case    1:*/		if ( regs.CR[6].eq ) { return 0x821BAFE8;  }
		/* 821BAFDCh case    1:*/		return 0x821BAFE0;
	}
	return 0x821BAFE0;
} // Block from 821BAFD8h-821BAFE0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BAFE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BAFE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BAFE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BAFE0);
		  /* 821BAFE0h */ case    0:  		/* slw R11, R21, R9 */
		/* 821BAFE0h case    0:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R21,regs.R9);
		/* 821BAFE0h case    0:*/		return 0x821BAFE4;
		  /* 821BAFE4h */ case    1:  		/* or R24, R11, R24 */
		/* 821BAFE4h case    1:*/		cpu::op::or<0>(regs,&regs.R24,regs.R11,regs.R24);
		/* 821BAFE4h case    1:*/		return 0x821BAFE8;
	}
	return 0x821BAFE8;
} // Block from 821BAFE0h-821BAFE8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BAFE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BAFE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BAFE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BAFE8);
		  /* 821BAFE8h */ case    0:  		/* addi R9, R9, 1 */
		/* 821BAFE8h case    0:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 821BAFE8h case    0:*/		return 0x821BAFEC;
		  /* 821BAFECh */ case    1:  		/* addi R7, R7, 4 */
		/* 821BAFECh case    1:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R7,0x4);
		/* 821BAFECh case    1:*/		return 0x821BAFF0;
		  /* 821BAFF0h */ case    2:  		/* b -132 */
		/* 821BAFF0h case    2:*/		return 0x821BAF6C;
		/* 821BAFF0h case    2:*/		return 0x821BAFF4;
	}
	return 0x821BAFF4;
} // Block from 821BAFE8h-821BAFF4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BAFF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BAFF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BAFF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BAFF4);
		  /* 821BAFF4h */ case    0:  		/* nor R11, R24, R24 */
		/* 821BAFF4h case    0:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R24,regs.R24);
		/* 821BAFF4h case    0:*/		return 0x821BAFF8;
		  /* 821BAFF8h */ case    1:  		/* and. R10, R4, R11 */
		/* 821BAFF8h case    1:*/		cpu::op::and<1>(regs,&regs.R10,regs.R4,regs.R11);
		/* 821BAFF8h case    1:*/		return 0x821BAFFC;
		  /* 821BAFFCh */ case    2:  		/* bc 12, CR0_EQ, 92 */
		/* 821BAFFCh case    2:*/		if ( regs.CR[0].eq ) { return 0x821BB058;  }
		/* 821BAFFCh case    2:*/		return 0x821BB000;
		  /* 821BB000h */ case    3:  		/* and R11, R18, R11 */
		/* 821BB000h case    3:*/		cpu::op::and<0>(regs,&regs.R11,regs.R18,regs.R11);
		/* 821BB000h case    3:*/		return 0x821BB004;
		  /* 821BB004h */ case    4:  		/* cmplwi CR6, R11, 7 */
		/* 821BB004h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000007);
		/* 821BB004h case    4:*/		return 0x821BB008;
		  /* 821BB008h */ case    5:  		/* bc 4, CR6_EQ, 80 */
		/* 821BB008h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821BB058;  }
		/* 821BB008h case    5:*/		return 0x821BB00C;
		  /* 821BB00Ch */ case    6:  		/* rlwinm R11, R10, 0, 29, 30 */
		/* 821BB00Ch case    6:*/		cpu::op::rlwinm<0,0,29,30>(regs,&regs.R11,regs.R10);
		/* 821BB00Ch case    6:*/		return 0x821BB010;
		  /* 821BB010h */ case    7:  		/* cmplwi CR6, R11, 6 */
		/* 821BB010h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000006);
		/* 821BB010h case    7:*/		return 0x821BB014;
		  /* 821BB014h */ case    8:  		/* bc 12, CR6_EQ, 68 */
		/* 821BB014h case    8:*/		if ( regs.CR[6].eq ) { return 0x821BB058;  }
		/* 821BB014h case    8:*/		return 0x821BB018;
		  /* 821BB018h */ case    9:  		/* ori R24, R24, 4 */
		/* 821BB018h case    9:*/		cpu::op::ori<0>(regs,&regs.R24,regs.R24,0x4);
		/* 821BB018h case    9:*/		return 0x821BB01C;
		  /* 821BB01Ch */ case   10:  		/* b 60 */
		/* 821BB01Ch case   10:*/		return 0x821BB058;
		/* 821BB01Ch case   10:*/		return 0x821BB020;
		  /* 821BB020h */ case   11:  		/* addi R11, R24, -1 */
		/* 821BB020h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R24,0xFFFFFFFF);
		/* 821BB020h case   11:*/		return 0x821BB024;
		  /* 821BB024h */ case   12:  		/* mr R4, R16 */
		/* 821BB024h case   12:*/		regs.R4 = regs.R16;
		/* 821BB024h case   12:*/		return 0x821BB028;
		  /* 821BB028h */ case   13:  		/* andc R11, R24, R11 */
		/* 821BB028h case   13:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R24,regs.R11);
		/* 821BB028h case   13:*/		return 0x821BB02C;
		  /* 821BB02Ch */ case   14:  		/* mr R3, R15 */
		/* 821BB02Ch case   14:*/		regs.R3 = regs.R15;
		/* 821BB02Ch case   14:*/		return 0x821BB030;
		  /* 821BB030h */ case   15:  		/* cntlzw R10, R11 */
		/* 821BB030h case   15:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R11);
		/* 821BB030h case   15:*/		return 0x821BB034;
		  /* 821BB034h */ case   16:  		/* subf R24, R11, R24 */
		/* 821BB034h case   16:*/		cpu::op::subf<0>(regs,&regs.R24,regs.R11,regs.R24);
		/* 821BB034h case   16:*/		return 0x821BB038;
		  /* 821BB038h */ case   17:  		/* subfic R5, R10, 31 */
		/* 821BB038h case   17:*/		cpu::op::subfic<0>(regs,&regs.R5,regs.R10,0x1F);
		/* 821BB038h case   17:*/		return 0x821BB03C;
		  /* 821BB03Ch */ case   18:  		/* addi R11, R5, 11 */
		/* 821BB03Ch case   18:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R5,0xB);
		/* 821BB03Ch case   18:*/		return 0x821BB040;
		  /* 821BB040h */ case   19:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821BB040h case   19:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821BB040h case   19:*/		return 0x821BB044;
		  /* 821BB044h */ case   20:  		/* lwzx R6, <#[R11 + R16]> */
		/* 821BB044h case   20:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R16 + 0x00000000) );
		/* 821BB044h case   20:*/		return 0x821BB048;
		  /* 821BB048h */ case   21:  		/* bl -14048 */
		/* 821BB048h case   21:*/		regs.LR = 0x821BB04C; return 0x821B7968;
		/* 821BB048h case   21:*/		return 0x821BB04C;
		  /* 821BB04Ch */ case   22:  		/* rlwinm R11, R3, 0, 24, 31 */
		/* 821BB04Ch case   22:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821BB04Ch case   22:*/		return 0x821BB050;
		  /* 821BB050h */ case   23:  		/* rlwinm R10, R17, 0, 24, 31 */
		/* 821BB050h case   23:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R10,regs.R17);
		/* 821BB050h case   23:*/		return 0x821BB054;
		  /* 821BB054h */ case   24:  		/* or R17, R11, R10 */
		/* 821BB054h case   24:*/		cpu::op::or<0>(regs,&regs.R17,regs.R11,regs.R10);
		/* 821BB054h case   24:*/		return 0x821BB058;
	}
	return 0x821BB058;
} // Block from 821BAFF4h-821BB058h (25 instructions)

//////////////////////////////////////////////////////
// Block at 821BB058h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB058( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB058) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB058);
		  /* 821BB058h */ case    0:  		/* cmplwi CR6, R24, 0 */
		/* 821BB058h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 821BB058h case    0:*/		return 0x821BB05C;
		  /* 821BB05Ch */ case    1:  		/* bc 4, CR6_EQ, -60 */
		/* 821BB05Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BB020;  }
		/* 821BB05Ch case    1:*/		return 0x821BB060;
		  /* 821BB060h */ case    2:  		/* lwz R23, <#[R1 + 316]> */
		/* 821BB060h case    2:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R1 + 0x0000013C) );
		/* 821BB060h case    2:*/		return 0x821BB064;
		  /* 821BB064h */ case    3:  		/* rlwinm. R11, R17, 0, 24, 31 */
		/* 821BB064h case    3:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R17);
		/* 821BB064h case    3:*/		return 0x821BB068;
		  /* 821BB068h */ case    4:  		/* bc 4, CR0_EQ, -5940 */
		/* 821BB068h case    4:*/		if ( !regs.CR[0].eq ) { return 0x821B9934;  }
		/* 821BB068h case    4:*/		return 0x821BB06C;
		  /* 821BB06Ch */ case    5:  		/* lwz R22, <#[R1 + 80]> */
		/* 821BB06Ch case    5:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R1 + 0x00000050) );
		/* 821BB06Ch case    5:*/		return 0x821BB070;
	}
	return 0x821BB070;
} // Block from 821BB058h-821BB070h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BB070h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB070( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB070) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB070);
		  /* 821BB070h */ case    0:  		/* lwz R11, <#[R16 + 8]> */
		/* 821BB070h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000008) );
		/* 821BB070h case    0:*/		return 0x821BB074;
		  /* 821BB074h */ case    1:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821BB074h case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821BB074h case    1:*/		return 0x821BB078;
		  /* 821BB078h */ case    2:  		/* cmpwi CR6, R11, 48 */
		/* 821BB078h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000030);
		/* 821BB078h case    2:*/		return 0x821BB07C;
		  /* 821BB07Ch */ case    3:  		/* bc 12, CR6_EQ, 20 */
		/* 821BB07Ch case    3:*/		if ( regs.CR[6].eq ) { return 0x821BB090;  }
		/* 821BB07Ch case    3:*/		return 0x821BB080;
		  /* 821BB080h */ case    4:  		/* cmpwi CR6, R11, 54 */
		/* 821BB080h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000036);
		/* 821BB080h case    4:*/		return 0x821BB084;
		  /* 821BB084h */ case    5:  		/* bc 12, CR6_EQ, 12 */
		/* 821BB084h case    5:*/		if ( regs.CR[6].eq ) { return 0x821BB090;  }
		/* 821BB084h case    5:*/		return 0x821BB088;
		  /* 821BB088h */ case    6:  		/* cmpwi CR6, R11, 72 */
		/* 821BB088h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000048);
		/* 821BB088h case    6:*/		return 0x821BB08C;
		  /* 821BB08Ch */ case    7:  		/* bc 4, CR6_EQ, 16 */
		/* 821BB08Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x821BB09C;  }
		/* 821BB08Ch case    7:*/		return 0x821BB090;
	}
	return 0x821BB090;
} // Block from 821BB070h-821BB090h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821BB090h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB090( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB090) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB090);
		  /* 821BB090h */ case    0:  		/* li R4, 2 */
		/* 821BB090h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x2);
		/* 821BB090h case    0:*/		return 0x821BB094;
		  /* 821BB094h */ case    1:  		/* lwz R3, <#[R16 + 44]> */
		/* 821BB094h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R16 + 0x0000002C) );
		/* 821BB094h case    1:*/		return 0x821BB098;
		  /* 821BB098h */ case    2:  		/* bl -275928 */
		/* 821BB098h case    2:*/		regs.LR = 0x821BB09C; return 0x82177AC0;
		/* 821BB098h case    2:*/		return 0x821BB09C;
	}
	return 0x821BB09C;
} // Block from 821BB090h-821BB09Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BB09Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB09C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB09C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB09C);
		  /* 821BB09Ch */ case    0:  		/* lwz R11, <#[R16 + 8]> */
		/* 821BB09Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000008) );
		/* 821BB09Ch case    0:*/		return 0x821BB0A0;
		  /* 821BB0A0h */ case    1:  		/* rlwinm R10, R11, 25, 25, 31 */
		/* 821BB0A0h case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R11);
		/* 821BB0A0h case    1:*/		return 0x821BB0A4;
		  /* 821BB0A4h */ case    2:  		/* cmpwi CR6, R10, 110 */
		/* 821BB0A4h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000006E);
		/* 821BB0A4h case    2:*/		return 0x821BB0A8;
		  /* 821BB0A8h */ case    3:  		/* bc 12, CR6_GT, 236 */
		/* 821BB0A8h case    3:*/		if ( regs.CR[6].gt ) { return 0x821BB194;  }
		/* 821BB0A8h case    3:*/		return 0x821BB0AC;
		  /* 821BB0ACh */ case    4:  		/* bc 12, CR6_EQ, 204 */
		/* 821BB0ACh case    4:*/		if ( regs.CR[6].eq ) { return 0x821BB178;  }
		/* 821BB0ACh case    4:*/		return 0x821BB0B0;
		  /* 821BB0B0h */ case    5:  		/* cmpwi CR6, R10, 25 */
		/* 821BB0B0h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000019);
		/* 821BB0B0h case    5:*/		return 0x821BB0B4;
		  /* 821BB0B4h */ case    6:  		/* bc 12, CR6_LT, 12 */
		/* 821BB0B4h case    6:*/		if ( regs.CR[6].lt ) { return 0x821BB0C0;  }
		/* 821BB0B4h case    6:*/		return 0x821BB0B8;
		  /* 821BB0B8h */ case    7:  		/* cmpwi CR6, R10, 28 */
		/* 821BB0B8h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000001C);
		/* 821BB0B8h case    7:*/		return 0x821BB0BC;
		  /* 821BB0BCh */ case    8:  		/* bc 4, CR6_GT, 16 */
		/* 821BB0BCh case    8:*/		if ( !regs.CR[6].gt ) { return 0x821BB0CC;  }
		/* 821BB0BCh case    8:*/		return 0x821BB0C0;
	}
	return 0x821BB0C0;
} // Block from 821BB09Ch-821BB0C0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821BB0C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB0C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB0C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB0C0);
		  /* 821BB0C0h */ case    0:  		/* mr R3, R16 */
		/* 821BB0C0h case    0:*/		regs.R3 = regs.R16;
		/* 821BB0C0h case    0:*/		return 0x821BB0C4;
		  /* 821BB0C4h */ case    1:  		/* bl -273740 */
		/* 821BB0C4h case    1:*/		regs.LR = 0x821BB0C8; return 0x82178378;
		/* 821BB0C4h case    1:*/		return 0x821BB0C8;
		  /* 821BB0C8h */ case    2:  		/* b 320 */
		/* 821BB0C8h case    2:*/		return 0x821BB208;
		/* 821BB0C8h case    2:*/		return 0x821BB0CC;
	}
	return 0x821BB0CC;
} // Block from 821BB0C0h-821BB0CCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BB0CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB0CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB0CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB0CC);
		  /* 821BB0CCh */ case    0:  		/* lwz R4, <#[R16 + 44]> */
		/* 821BB0CCh case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R16 + 0x0000002C) );
		/* 821BB0CCh case    0:*/		return 0x821BB0D0;
		  /* 821BB0D0h */ case    1:  		/* lwz R7, <#[R4]> */
		/* 821BB0D0h case    1:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R4 + 0x00000000) );
		/* 821BB0D0h case    1:*/		return 0x821BB0D4;
		  /* 821BB0D4h */ case    2:  		/* rlwinm R11, R7, 7, 29, 31 */
		/* 821BB0D4h case    2:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R11,regs.R7);
		/* 821BB0D4h case    2:*/		return 0x821BB0D8;
		  /* 821BB0D8h */ case    3:  		/* cmplwi CR6, R11, 4 */
		/* 821BB0D8h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 821BB0D8h case    3:*/		return 0x821BB0DC;
		  /* 821BB0DCh */ case    4:  		/* bc 4, CR6_LT, -28 */
		/* 821BB0DCh case    4:*/		if ( !regs.CR[6].lt ) { return 0x821BB0C0;  }
		/* 821BB0DCh case    4:*/		return 0x821BB0E0;
		  /* 821BB0E0h */ case    5:  		/* lwz R8, <#[R16 + 48]> */
		/* 821BB0E0h case    5:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R16 + 0x00000030) );
		/* 821BB0E0h case    5:*/		return 0x821BB0E4;
		  /* 821BB0E4h */ case    6:  		/* subfic R9, R11, 4 */
		/* 821BB0E4h case    6:*/		cpu::op::subfic<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821BB0E4h case    6:*/		return 0x821BB0E8;
		  /* 821BB0E8h */ case    7:  		/* addi R6, R11, -1 */
		/* 821BB0E8h case    7:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R11,0xFFFFFFFF);
		/* 821BB0E8h case    7:*/		return 0x821BB0EC;
		  /* 821BB0ECh */ case    8:  		/* rlwinm R10, R7, 27, 24, 31 */
		/* 821BB0ECh case    8:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R10,regs.R7);
		/* 821BB0ECh case    8:*/		return 0x821BB0F0;
		  /* 821BB0F0h */ case    9:  		/* rlwinm R5, R6, 1, 0, 30 */
		/* 821BB0F0h case    9:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R5,regs.R6);
		/* 821BB0F0h case    9:*/		return 0x821BB0F4;
		  /* 821BB0F4h */ case   10:  		/* rlwinm R11, R11, 1, 0, 30 */
		/* 821BB0F4h case   10:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R11,regs.R11);
		/* 821BB0F4h case   10:*/		return 0x821BB0F8;
		  /* 821BB0F8h */ case   11:  		/* lwz R6, <#[R8]> */
		/* 821BB0F8h case   11:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R8 + 0x00000000) );
		/* 821BB0F8h case   11:*/		return 0x821BB0FC;
		  /* 821BB0FCh */ case   12:  		/* mtspr CTR, R9 */
		/* 821BB0FCh case   12:*/		regs.CTR = regs.R9;
		/* 821BB0FCh case   12:*/		return 0x821BB100;
		  /* 821BB100h */ case   13:  		/* srw R3, R10, R5 */
		/* 821BB100h case   13:*/		cpu::op::srw<0>(regs,&regs.R3,regs.R10,regs.R5);
		/* 821BB100h case   13:*/		return 0x821BB104;
		  /* 821BB104h */ case   14:  		/* rlwinm R9, R6, 27, 24, 31 */
		/* 821BB104h case   14:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R9,regs.R6);
		/* 821BB104h case   14:*/		return 0x821BB108;
		  /* 821BB108h */ case   15:  		/* rlwinm R6, R3, 0, 30, 31 */
		/* 821BB108h case   15:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R6,regs.R3);
		/* 821BB108h case   15:*/		return 0x821BB10C;
		  /* 821BB10Ch */ case   16:  		/* srw R5, R9, R5 */
		/* 821BB10Ch case   16:*/		cpu::op::srw<0>(regs,&regs.R5,regs.R9,regs.R5);
		/* 821BB10Ch case   16:*/		return 0x821BB110;
		  /* 821BB110h */ case   17:  		/* rlwinm R5, R5, 0, 30, 31 */
		/* 821BB110h case   17:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R5,regs.R5);
		/* 821BB110h case   17:*/		return 0x821BB114;
		  /* 821BB114h */ case   18:  		/* li R3, 3 */
		/* 821BB114h case   18:*/		cpu::op::li<0>(regs,&regs.R3,0x3);
		/* 821BB114h case   18:*/		return 0x821BB118;
		  /* 821BB118h */ case   19:  		/* slw R31, R6, R11 */
		/* 821BB118h case   19:*/		cpu::op::slw<0>(regs,&regs.R31,regs.R6,regs.R11);
		/* 821BB118h case   19:*/		return 0x821BB11C;
		  /* 821BB11Ch */ case   20:  		/* slw R3, R3, R11 */
		/* 821BB11Ch case   20:*/		cpu::op::slw<0>(regs,&regs.R3,regs.R3,regs.R11);
		/* 821BB11Ch case   20:*/		return 0x821BB120;
		  /* 821BB120h */ case   21:  		/* nor R3, R3, R3 */
		/* 821BB120h case   21:*/		cpu::op::nor<0>(regs,&regs.R3,regs.R3,regs.R3);
		/* 821BB120h case   21:*/		return 0x821BB124;
		  /* 821BB124h */ case   22:  		/* slw R30, R5, R11 */
		/* 821BB124h case   22:*/		cpu::op::slw<0>(regs,&regs.R30,regs.R5,regs.R11);
		/* 821BB124h case   22:*/		return 0x821BB128;
		  /* 821BB128h */ case   23:  		/* and R10, R3, R10 */
		/* 821BB128h case   23:*/		cpu::op::and<0>(regs,&regs.R10,regs.R3,regs.R10);
		/* 821BB128h case   23:*/		return 0x821BB12C;
		  /* 821BB12Ch */ case   24:  		/* and R9, R3, R9 */
		/* 821BB12Ch case   24:*/		cpu::op::and<0>(regs,&regs.R9,regs.R3,regs.R9);
		/* 821BB12Ch case   24:*/		return 0x821BB130;
		  /* 821BB130h */ case   25:  		/* or R10, R31, R10 */
		/* 821BB130h case   25:*/		cpu::op::or<0>(regs,&regs.R10,regs.R31,regs.R10);
		/* 821BB130h case   25:*/		return 0x821BB134;
		  /* 821BB134h */ case   26:  		/* or R9, R30, R9 */
		/* 821BB134h case   26:*/		cpu::op::or<0>(regs,&regs.R9,regs.R30,regs.R9);
		/* 821BB134h case   26:*/		return 0x821BB138;
		  /* 821BB138h */ case   27:  		/* addi R11, R11, 2 */
		/* 821BB138h case   27:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 821BB138h case   27:*/		return 0x821BB13C;
		  /* 821BB13Ch */ case   28:  		/* bc 16, CR0_LT, -40 */
		/* 821BB13Ch case   28:*/		regs.CTR -= 1;
		if ( (uint32)regs.CTR != 0 ) { return 0x821BB114;  }
		/* 821BB13Ch case   28:*/		return 0x821BB140;
		  /* 821BB140h */ case   29:  		/* lis R11, 2048 */
		/* 821BB140h case   29:*/		cpu::op::lis<0>(regs,&regs.R11,0x800);
		/* 821BB140h case   29:*/		return 0x821BB144;
		  /* 821BB144h */ case   30:  		/* rlwinm R7, R7, 0, 27, 18 */
		/* 821BB144h case   30:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R7,regs.R7);
		/* 821BB144h case   30:*/		return 0x821BB148;
		  /* 821BB148h */ case   31:  		/* rlwimi R11, R10, 5, 19, 26 */
		/* 821BB148h case   31:*/		cpu::op::rlwimi<0,5,19,26>(regs,&regs.R11,regs.R10);
		/* 821BB148h case   31:*/		return 0x821BB14C;
		  /* 821BB14Ch */ case   32:  		/* rlwinm R7, R7, 0, 7, 4 */
		/* 821BB14Ch case   32:*/		cpu::op::rlwinm<0,0,7,4>(regs,&regs.R7,regs.R7);
		/* 821BB14Ch case   32:*/		return 0x821BB150;
		  /* 821BB150h */ case   33:  		/* lis R10, 2048 */
		/* 821BB150h case   33:*/		cpu::op::lis<0>(regs,&regs.R10,0x800);
		/* 821BB150h case   33:*/		return 0x821BB154;
		  /* 821BB154h */ case   34:  		/* or R11, R11, R7 */
		/* 821BB154h case   34:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R7);
		/* 821BB154h case   34:*/		return 0x821BB158;
		  /* 821BB158h */ case   35:  		/* rlwimi R10, R9, 5, 19, 26 */
		/* 821BB158h case   35:*/		cpu::op::rlwimi<0,5,19,26>(regs,&regs.R10,regs.R9);
		/* 821BB158h case   35:*/		return 0x821BB15C;
		  /* 821BB15Ch */ case   36:  		/* stw R11, <#[R4]> */
		/* 821BB15Ch case   36:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 821BB15Ch case   36:*/		return 0x821BB160;
		  /* 821BB160h */ case   37:  		/* lwz R11, <#[R8]> */
		/* 821BB160h case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 821BB160h case   37:*/		return 0x821BB164;
		  /* 821BB164h */ case   38:  		/* rlwinm R11, R11, 0, 27, 18 */
		/* 821BB164h case   38:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R11,regs.R11);
		/* 821BB164h case   38:*/		return 0x821BB168;
		  /* 821BB168h */ case   39:  		/* rlwinm R11, R11, 0, 7, 4 */
		/* 821BB168h case   39:*/		cpu::op::rlwinm<0,0,7,4>(regs,&regs.R11,regs.R11);
		/* 821BB168h case   39:*/		return 0x821BB16C;
		  /* 821BB16Ch */ case   40:  		/* or R11, R10, R11 */
		/* 821BB16Ch case   40:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821BB16Ch case   40:*/		return 0x821BB170;
		  /* 821BB170h */ case   41:  		/* stw R11, <#[R8]> */
		/* 821BB170h case   41:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 821BB170h case   41:*/		return 0x821BB174;
		  /* 821BB174h */ case   42:  		/* b -180 */
		/* 821BB174h case   42:*/		return 0x821BB0C0;
		/* 821BB174h case   42:*/		return 0x821BB178;
	}
	return 0x821BB178;
} // Block from 821BB0CCh-821BB178h (43 instructions)

//////////////////////////////////////////////////////
// Block at 821BB178h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB178( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB178) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB178);
		  /* 821BB178h */ case    0:  		/* mr R5, R16 */
		/* 821BB178h case    0:*/		regs.R5 = regs.R16;
		/* 821BB178h case    0:*/		return 0x821BB17C;
		  /* 821BB17Ch */ case    1:  		/* mr R4, R23 */
		/* 821BB17Ch case    1:*/		regs.R4 = regs.R23;
		/* 821BB17Ch case    1:*/		return 0x821BB180;
		  /* 821BB180h */ case    2:  		/* mr R3, R15 */
		/* 821BB180h case    2:*/		regs.R3 = regs.R15;
		/* 821BB180h case    2:*/		return 0x821BB184;
		  /* 821BB184h */ case    3:  		/* bl -14052 */
		/* 821BB184h case    3:*/		regs.LR = 0x821BB188; return 0x821B7AA0;
		/* 821BB184h case    3:*/		return 0x821BB188;
		  /* 821BB188h */ case    4:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821BB188h case    4:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821BB188h case    4:*/		return 0x821BB18C;
		  /* 821BB18Ch */ case    5:  		/* bc 4, CR0_EQ, -6232 */
		/* 821BB18Ch case    5:*/		if ( !regs.CR[0].eq ) { return 0x821B9934;  }
		/* 821BB18Ch case    5:*/		return 0x821BB190;
		  /* 821BB190h */ case    6:  		/* b 120 */
		/* 821BB190h case    6:*/		return 0x821BB208;
		/* 821BB190h case    6:*/		return 0x821BB194;
	}
	return 0x821BB194;
} // Block from 821BB178h-821BB194h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BB194h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB194( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB194) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB194);
		  /* 821BB194h */ case    0:  		/* cmpwi CR6, R10, 113 */
		/* 821BB194h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000071);
		/* 821BB194h case    0:*/		return 0x821BB198;
		  /* 821BB198h */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 821BB198h case    1:*/		if ( regs.CR[6].eq ) { return 0x821BB1B8;  }
		/* 821BB198h case    1:*/		return 0x821BB19C;
		  /* 821BB19Ch */ case    2:  		/* cmpwi CR6, R10, 124 */
		/* 821BB19Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000007C);
		/* 821BB19Ch case    2:*/		return 0x821BB1A0;
		  /* 821BB1A0h */ case    3:  		/* bc 12, CR6_EQ, 24 */
		/* 821BB1A0h case    3:*/		if ( regs.CR[6].eq ) { return 0x821BB1B8;  }
		/* 821BB1A0h case    3:*/		return 0x821BB1A4;
		  /* 821BB1A4h */ case    4:  		/* cmpwi CR6, R10, 125 */
		/* 821BB1A4h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x0000007D);
		/* 821BB1A4h case    4:*/		return 0x821BB1A8;
		  /* 821BB1A8h */ case    5:  		/* bc 4, CR6_EQ, -232 */
		/* 821BB1A8h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821BB0C0;  }
		/* 821BB1A8h case    5:*/		return 0x821BB1AC;
		  /* 821BB1ACh */ case    6:  		/* mr R3, R16 */
		/* 821BB1ACh case    6:*/		regs.R3 = regs.R16;
		/* 821BB1ACh case    6:*/		return 0x821BB1B0;
		  /* 821BB1B0h */ case    7:  		/* bl -151040 */
		/* 821BB1B0h case    7:*/		regs.LR = 0x821BB1B4; return 0x821963B0;
		/* 821BB1B0h case    7:*/		return 0x821BB1B4;
		  /* 821BB1B4h */ case    8:  		/* b 84 */
		/* 821BB1B4h case    8:*/		return 0x821BB208;
		/* 821BB1B4h case    8:*/		return 0x821BB1B8;
	}
	return 0x821BB1B8;
} // Block from 821BB194h-821BB1B8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821BB1B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB1B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB1B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB1B8);
		  /* 821BB1B8h */ case    0:  		/* rlwinm R10, R11, 18, 29, 31 */
		/* 821BB1B8h case    0:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R10,regs.R11);
		/* 821BB1B8h case    0:*/		return 0x821BB1BC;
		  /* 821BB1BCh */ case    1:  		/* lwz R9, <#[R16 + 16]> */
		/* 821BB1BCh case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R16 + 0x00000010) );
		/* 821BB1BCh case    1:*/		return 0x821BB1C0;
		  /* 821BB1C0h */ case    2:  		/* lis R8, -28311 */
		/* 821BB1C0h case    2:*/		cpu::op::lis<0>(regs,&regs.R8,0xFFFF9169);
		/* 821BB1C0h case    2:*/		return 0x821BB1C4;
		  /* 821BB1C4h */ case    3:  		/* lis R7, 0 */
		/* 821BB1C4h case    3:*/		cpu::op::lis<0>(regs,&regs.R7,0x0);
		/* 821BB1C4h case    3:*/		return 0x821BB1C8;
		  /* 821BB1C8h */ case    4:  		/* slw R10, R21, R10 */
		/* 821BB1C8h case    4:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R21,regs.R10);
		/* 821BB1C8h case    4:*/		return 0x821BB1CC;
		  /* 821BB1CCh */ case    5:  		/* ori R8, R8, 5192 */
		/* 821BB1CCh case    5:*/		cpu::op::ori<0>(regs,&regs.R8,regs.R8,0x1448);
		/* 821BB1CCh case    5:*/		return 0x821BB1D0;
		  /* 821BB1D0h */ case    6:  		/* ori R7, R7, 36262 */
		/* 821BB1D0h case    6:*/		cpu::op::ori<0>(regs,&regs.R7,regs.R7,0x8DA6);
		/* 821BB1D0h case    6:*/		return 0x821BB1D4;
		  /* 821BB1D4h */ case    7:  		/* addi R10, R10, -1 */
		/* 821BB1D4h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 821BB1D4h case    7:*/		return 0x821BB1D8;
		  /* 821BB1D8h */ case    8:  		/* rldimi R8, R7, 32, 0 */
		/* 821BB1D8h case    8:*/		cpu::op::rldimi<0,32,0>(regs,&regs.R8,regs.R7);
		/* 821BB1D8h case    8:*/		return 0x821BB1DC;
		  /* 821BB1DCh */ case    9:  		/* rldicl R7, R10, 0, 32 */
		/* 821BB1DCh case    9:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R7,regs.R10);
		/* 821BB1DCh case    9:*/		return 0x821BB1E0;
		  /* 821BB1E0h */ case   10:  		/* srd R8, R8, R7 */
		/* 821BB1E0h case   10:*/		cpu::op::srd<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 821BB1E0h case   10:*/		return 0x821BB1E4;
		  /* 821BB1E4h */ case   11:  		/* srd R8, R8, R7 */
		/* 821BB1E4h case   11:*/		cpu::op::srd<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 821BB1E4h case   11:*/		return 0x821BB1E8;
		  /* 821BB1E8h */ case   12:  		/* srd R8, R8, R7 */
		/* 821BB1E8h case   12:*/		cpu::op::srd<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 821BB1E8h case   12:*/		return 0x821BB1EC;
		  /* 821BB1ECh */ case   13:  		/* rlwinm R8, R8, 0, 0, 31 */
		/* 821BB1ECh case   13:*/		cpu::op::rlwinm<0,0,0,31>(regs,&regs.R8,regs.R8);
		/* 821BB1ECh case   13:*/		return 0x821BB1F0;
		  /* 821BB1F0h */ case   14:  		/* rlwimi R10, R8, 13, 16, 18 */
		/* 821BB1F0h case   14:*/		cpu::op::rlwimi<0,13,16,18>(regs,&regs.R10,regs.R8);
		/* 821BB1F0h case   14:*/		return 0x821BB1F4;
		  /* 821BB1F4h */ case   15:  		/* rlwimi R11, R10, 1, 27, 30 */
		/* 821BB1F4h case   15:*/		cpu::op::rlwimi<0,1,27,30>(regs,&regs.R11,regs.R10);
		/* 821BB1F4h case   15:*/		return 0x821BB1F8;
		  /* 821BB1F8h */ case   16:  		/* rlwimi R11, R10, 1, 15, 17 */
		/* 821BB1F8h case   16:*/		cpu::op::rlwimi<0,1,15,17>(regs,&regs.R11,regs.R10);
		/* 821BB1F8h case   16:*/		return 0x821BB1FC;
		  /* 821BB1FCh */ case   17:  		/* rlwimi R9, R11, 2, 13, 15 */
		/* 821BB1FCh case   17:*/		cpu::op::rlwimi<0,2,13,15>(regs,&regs.R9,regs.R11);
		/* 821BB1FCh case   17:*/		return 0x821BB200;
		  /* 821BB200h */ case   18:  		/* stw R11, <#[R16 + 8]> */
		/* 821BB200h case   18:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R16 + 0x00000008) );
		/* 821BB200h case   18:*/		return 0x821BB204;
		  /* 821BB204h */ case   19:  		/* stw R9, <#[R16 + 16]> */
		/* 821BB204h case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R16 + 0x00000010) );
		/* 821BB204h case   19:*/		return 0x821BB208;
	}
	return 0x821BB208;
} // Block from 821BB1B8h-821BB208h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821BB208h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB208( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB208) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB208);
		  /* 821BB208h */ case    0:  		/* lwz R11, <#[R16 + 8]> */
		/* 821BB208h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000008) );
		/* 821BB208h case    0:*/		return 0x821BB20C;
		  /* 821BB20Ch */ case    1:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821BB20Ch case    1:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821BB20Ch case    1:*/		return 0x821BB210;
		  /* 821BB210h */ case    2:  		/* cmplwi CR6, R11, 14336 */
		/* 821BB210h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003800);
		/* 821BB210h case    2:*/		return 0x821BB214;
		  /* 821BB214h */ case    3:  		/* bc 12, CR6_EQ, 12 */
		/* 821BB214h case    3:*/		if ( regs.CR[6].eq ) { return 0x821BB220;  }
		/* 821BB214h case    3:*/		return 0x821BB218;
		  /* 821BB218h */ case    4:  		/* mr R3, R16 */
		/* 821BB218h case    4:*/		regs.R3 = regs.R16;
		/* 821BB218h case    4:*/		return 0x821BB21C;
		  /* 821BB21Ch */ case    5:  		/* bl -178068 */
		/* 821BB21Ch case    5:*/		regs.LR = 0x821BB220; return 0x8218FA88;
		/* 821BB21Ch case    5:*/		return 0x821BB220;
	}
	return 0x821BB220;
} // Block from 821BB208h-821BB220h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BB220h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB220( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB220) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB220);
		  /* 821BB220h */ case    0:  		/* lwz R11, <#[R16 + 8]> */
		/* 821BB220h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000008) );
		/* 821BB220h case    0:*/		return 0x821BB224;
		  /* 821BB224h */ case    1:  		/* oris R9, R11, 256 */
		/* 821BB224h case    1:*/		cpu::op::oris<0>(regs,&regs.R9,regs.R11,0x100);
		/* 821BB224h case    1:*/		return 0x821BB228;
		  /* 821BB228h */ case    2:  		/* rlwinm R11, R9, 25, 25, 31 */
		/* 821BB228h case    2:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R9);
		/* 821BB228h case    2:*/		return 0x821BB22C;
		  /* 821BB22Ch */ case    3:  		/* stw R9, <#[R16 + 8]> */
		/* 821BB22Ch case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R16 + 0x00000008) );
		/* 821BB22Ch case    3:*/		return 0x821BB230;
		  /* 821BB230h */ case    4:  		/* cmpwi CR6, R11, 105 */
		/* 821BB230h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000069);
		/* 821BB230h case    4:*/		return 0x821BB234;
		  /* 821BB234h */ case    5:  		/* bc 12, CR6_GT, 160 */
		/* 821BB234h case    5:*/		if ( regs.CR[6].gt ) { return 0x821BB2D4;  }
		/* 821BB234h case    5:*/		return 0x821BB238;
		  /* 821BB238h */ case    6:  		/* bc 12, CR6_EQ, 140 */
		/* 821BB238h case    6:*/		if ( regs.CR[6].eq ) { return 0x821BB2C4;  }
		/* 821BB238h case    6:*/		return 0x821BB23C;
		  /* 821BB23Ch */ case    7:  		/* cmpwi CR6, R11, 19 */
		/* 821BB23Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000013);
		/* 821BB23Ch case    7:*/		return 0x821BB240;
		  /* 821BB240h */ case    8:  		/* bc 12, CR6_EQ, 36 */
		/* 821BB240h case    8:*/		if ( regs.CR[6].eq ) { return 0x821BB264;  }
		/* 821BB240h case    8:*/		return 0x821BB244;
		  /* 821BB244h */ case    9:  		/* cmpwi CR6, R11, 29 */
		/* 821BB244h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000001D);
		/* 821BB244h case    9:*/		return 0x821BB248;
		  /* 821BB248h */ case   10:  		/* bc 12, CR6_EQ, 28 */
		/* 821BB248h case   10:*/		if ( regs.CR[6].eq ) { return 0x821BB264;  }
		/* 821BB248h case   10:*/		return 0x821BB24C;
		  /* 821BB24Ch */ case   11:  		/* cmpwi CR6, R11, 94 */
		/* 821BB24Ch case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000005E);
		/* 821BB24Ch case   11:*/		return 0x821BB250;
		  /* 821BB250h */ case   12:  		/* bc 12, CR6_EQ, 116 */
		/* 821BB250h case   12:*/		if ( regs.CR[6].eq ) { return 0x821BB2C4;  }
		/* 821BB250h case   12:*/		return 0x821BB254;
		  /* 821BB254h */ case   13:  		/* cmpwi CR6, R11, 100 */
		/* 821BB254h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000064);
		/* 821BB254h case   13:*/		return 0x821BB258;
		  /* 821BB258h */ case   14:  		/* bc 12, CR6_EQ, 92 */
		/* 821BB258h case   14:*/		if ( regs.CR[6].eq ) { return 0x821BB2B4;  }
		/* 821BB258h case   14:*/		return 0x821BB25C;
		  /* 821BB25Ch */ case   15:  		/* cmpwi CR6, R11, 104 */
		/* 821BB25Ch case   15:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000068);
		/* 821BB25Ch case   15:*/		return 0x821BB260;
		  /* 821BB260h */ case   16:  		/* bc 4, CR6_EQ, 36 */
		/* 821BB260h case   16:*/		if ( !regs.CR[6].eq ) { return 0x821BB284;  }
		/* 821BB260h case   16:*/		return 0x821BB264;
	}
	return 0x821BB264;
} // Block from 821BB220h-821BB264h (17 instructions)

//////////////////////////////////////////////////////
// Block at 821BB264h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB264( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB264) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB264);
		  /* 821BB264h */ case    0:  		/* lwz R11, <#[R16 + 16]> */
		/* 821BB264h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000010) );
		/* 821BB264h case    0:*/		return 0x821BB268;
		  /* 821BB268h */ case    1:  		/* rlwinm. R10, R9, 9, 31, 31 */
		/* 821BB268h case    1:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R10,regs.R9);
		/* 821BB268h case    1:*/		return 0x821BB26C;
		  /* 821BB26Ch */ case    2:  		/* oris R11, R11, 16 */
		/* 821BB26Ch case    2:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x10);
		/* 821BB26Ch case    2:*/		return 0x821BB270;
		  /* 821BB270h */ case    3:  		/* stw R11, <#[R16 + 16]> */
		/* 821BB270h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R16 + 0x00000010) );
		/* 821BB270h case    3:*/		return 0x821BB274;
		  /* 821BB274h */ case    4:  		/* bc 4, CR0_EQ, 16 */
		/* 821BB274h case    4:*/		if ( !regs.CR[0].eq ) { return 0x821BB284;  }
		/* 821BB274h case    4:*/		return 0x821BB278;
		  /* 821BB278h */ case    5:  		/* mr R4, R16 */
		/* 821BB278h case    5:*/		regs.R4 = regs.R16;
		/* 821BB278h case    5:*/		return 0x821BB27C;
		  /* 821BB27Ch */ case    6:  		/* mr R3, R15 */
		/* 821BB27Ch case    6:*/		regs.R3 = regs.R15;
		/* 821BB27Ch case    6:*/		return 0x821BB280;
		  /* 821BB280h */ case    7:  		/* bl -19928 */
		/* 821BB280h case    7:*/		regs.LR = 0x821BB284; return 0x821B64A8;
		/* 821BB280h case    7:*/		return 0x821BB284;
	}
	return 0x821BB284;
} // Block from 821BB264h-821BB284h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821BB284h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB284( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB284) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB284);
		  /* 821BB284h */ case    0:  		/* lwz R11, <#[R16 + 8]> */
		/* 821BB284h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000008) );
		/* 821BB284h case    0:*/		return 0x821BB288;
		  /* 821BB288h */ case    1:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821BB288h case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821BB288h case    1:*/		return 0x821BB28C;
		  /* 821BB28Ch */ case    2:  		/* cmplwi CR6, R11, 25 */
		/* 821BB28Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000019);
		/* 821BB28Ch case    2:*/		return 0x821BB290;
		  /* 821BB290h */ case    3:  		/* bc 12, CR6_LT, 12 */
		/* 821BB290h case    3:*/		if ( regs.CR[6].lt ) { return 0x821BB29C;  }
		/* 821BB290h case    3:*/		return 0x821BB294;
		  /* 821BB294h */ case    4:  		/* cmplwi CR6, R11, 28 */
		/* 821BB294h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000001C);
		/* 821BB294h case    4:*/		return 0x821BB298;
		  /* 821BB298h */ case    5:  		/* bc 4, CR6_GT, 20 */
		/* 821BB298h case    5:*/		if ( !regs.CR[6].gt ) { return 0x821BB2AC;  }
		/* 821BB298h case    5:*/		return 0x821BB29C;
	}
	return 0x821BB29C;
} // Block from 821BB284h-821BB29Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BB29Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB29C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB29C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB29C);
		  /* 821BB29Ch */ case    0:  		/* cmplwi CR6, R11, 67 */
		/* 821BB29Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000043);
		/* 821BB29Ch case    0:*/		return 0x821BB2A0;
		  /* 821BB2A0h */ case    1:  		/* bc 12, CR6_LT, 308 */
		/* 821BB2A0h case    1:*/		if ( regs.CR[6].lt ) { return 0x821BB3D4;  }
		/* 821BB2A0h case    1:*/		return 0x821BB2A4;
		  /* 821BB2A4h */ case    2:  		/* cmplwi CR6, R11, 71 */
		/* 821BB2A4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000047);
		/* 821BB2A4h case    2:*/		return 0x821BB2A8;
		  /* 821BB2A8h */ case    3:  		/* bc 12, CR6_GT, 300 */
		/* 821BB2A8h case    3:*/		if ( regs.CR[6].gt ) { return 0x821BB3D4;  }
		/* 821BB2A8h case    3:*/		return 0x821BB2AC;
	}
	return 0x821BB2AC;
} // Block from 821BB29Ch-821BB2ACh (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BB2ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB2AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB2AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB2AC);
		  /* 821BB2ACh */ case    0:  		/* mr R11, R21 */
		/* 821BB2ACh case    0:*/		regs.R11 = regs.R21;
		/* 821BB2ACh case    0:*/		return 0x821BB2B0;
		  /* 821BB2B0h */ case    1:  		/* b 296 */
		/* 821BB2B0h case    1:*/		return 0x821BB3D8;
		/* 821BB2B0h case    1:*/		return 0x821BB2B4;
	}
	return 0x821BB2B4;
} // Block from 821BB2ACh-821BB2B4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BB2B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB2B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB2B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB2B4);
		  /* 821BB2B4h */ case    0:  		/* lwz R11, <#[R15 + 44]> */
		/* 821BB2B4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x0000002C) );
		/* 821BB2B4h case    0:*/		return 0x821BB2B8;
		  /* 821BB2B8h */ case    1:  		/* ori R11, R11, 8 */
		/* 821BB2B8h case    1:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x8);
		/* 821BB2B8h case    1:*/		return 0x821BB2BC;
		  /* 821BB2BCh */ case    2:  		/* stw R11, <#[R15 + 44]> */
		/* 821BB2BCh case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R15 + 0x0000002C) );
		/* 821BB2BCh case    2:*/		return 0x821BB2C0;
		  /* 821BB2C0h */ case    3:  		/* b -60 */
		/* 821BB2C0h case    3:*/		return 0x821BB284;
		/* 821BB2C0h case    3:*/		return 0x821BB2C4;
	}
	return 0x821BB2C4;
} // Block from 821BB2B4h-821BB2C4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BB2C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB2C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB2C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB2C4);
		  /* 821BB2C4h */ case    0:  		/* lwz R11, <#[R23 + 48]> */
		/* 821BB2C4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000030) );
		/* 821BB2C4h case    0:*/		return 0x821BB2C8;
		  /* 821BB2C8h */ case    1:  		/* oris R11, R11, 512 */
		/* 821BB2C8h case    1:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x200);
		/* 821BB2C8h case    1:*/		return 0x821BB2CC;
		  /* 821BB2CCh */ case    2:  		/* stw R11, <#[R23 + 48]> */
		/* 821BB2CCh case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R23 + 0x00000030) );
		/* 821BB2CCh case    2:*/		return 0x821BB2D0;
		  /* 821BB2D0h */ case    3:  		/* b -76 */
		/* 821BB2D0h case    3:*/		return 0x821BB284;
		/* 821BB2D0h case    3:*/		return 0x821BB2D4;
	}
	return 0x821BB2D4;
} // Block from 821BB2C4h-821BB2D4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BB2D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB2D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB2D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB2D4);
		  /* 821BB2D4h */ case    0:  		/* cmpwi CR6, R11, 108 */
		/* 821BB2D4h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000006C);
		/* 821BB2D4h case    0:*/		return 0x821BB2D8;
		  /* 821BB2D8h */ case    1:  		/* bc 12, CR6_LT, -84 */
		/* 821BB2D8h case    1:*/		if ( regs.CR[6].lt ) { return 0x821BB284;  }
		/* 821BB2D8h case    1:*/		return 0x821BB2DC;
		  /* 821BB2DCh */ case    2:  		/* cmpwi CR6, R11, 109 */
		/* 821BB2DCh case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000006D);
		/* 821BB2DCh case    2:*/		return 0x821BB2E0;
		  /* 821BB2E0h */ case    3:  		/* bc 4, CR6_GT, -124 */
		/* 821BB2E0h case    3:*/		if ( !regs.CR[6].gt ) { return 0x821BB264;  }
		/* 821BB2E0h case    3:*/		return 0x821BB2E4;
		  /* 821BB2E4h */ case    4:  		/* cmpwi CR6, R11, 110 */
		/* 821BB2E4h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000006E);
		/* 821BB2E4h case    4:*/		return 0x821BB2E8;
		  /* 821BB2E8h */ case    5:  		/* bc 12, CR6_EQ, 124 */
		/* 821BB2E8h case    5:*/		if ( regs.CR[6].eq ) { return 0x821BB364;  }
		/* 821BB2E8h case    5:*/		return 0x821BB2EC;
		  /* 821BB2ECh */ case    6:  		/* cmpwi CR6, R11, 113 */
		/* 821BB2ECh case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000071);
		/* 821BB2ECh case    6:*/		return 0x821BB2F0;
		  /* 821BB2F0h */ case    7:  		/* bc 12, CR6_EQ, 80 */
		/* 821BB2F0h case    7:*/		if ( regs.CR[6].eq ) { return 0x821BB340;  }
		/* 821BB2F0h case    7:*/		return 0x821BB2F4;
		  /* 821BB2F4h */ case    8:  		/* cmpwi CR6, R11, 116 */
		/* 821BB2F4h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000074);
		/* 821BB2F4h case    8:*/		return 0x821BB2F8;
		  /* 821BB2F8h */ case    9:  		/* bc 12, CR6_EQ, -148 */
		/* 821BB2F8h case    9:*/		if ( regs.CR[6].eq ) { return 0x821BB264;  }
		/* 821BB2F8h case    9:*/		return 0x821BB2FC;
		  /* 821BB2FCh */ case   10:  		/* cmpwi CR6, R11, 120 */
		/* 821BB2FCh case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000078);
		/* 821BB2FCh case   10:*/		return 0x821BB300;
		  /* 821BB300h */ case   11:  		/* bc 4, CR6_EQ, -124 */
		/* 821BB300h case   11:*/		if ( !regs.CR[6].eq ) { return 0x821BB284;  }
		/* 821BB300h case   11:*/		return 0x821BB304;
		  /* 821BB304h */ case   12:  		/* lwz R11, <#[R14]> */
		/* 821BB304h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R14 + 0x00000000) );
		/* 821BB304h case   12:*/		return 0x821BB308;
		  /* 821BB308h */ case   13:  		/* cmplwi CR6, R11, 0 */
		/* 821BB308h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BB308h case   13:*/		return 0x821BB30C;
		  /* 821BB30Ch */ case   14:  		/* bc 12, CR6_EQ, 36 */
		/* 821BB30Ch case   14:*/		if ( regs.CR[6].eq ) { return 0x821BB330;  }
		/* 821BB30Ch case   14:*/		return 0x821BB310;
		  /* 821BB310h */ case   15:  		/* lwz R10, <#[R11]> */
		/* 821BB310h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821BB310h case   15:*/		return 0x821BB314;
		  /* 821BB314h */ case   16:  		/* rlwinm. R8, R10, 0, 4, 6 */
		/* 821BB314h case   16:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R8,regs.R10);
		/* 821BB314h case   16:*/		return 0x821BB318;
		  /* 821BB318h */ case   17:  		/* bc 4, CR0_EQ, 12 */
		/* 821BB318h case   17:*/		if ( !regs.CR[0].eq ) { return 0x821BB324;  }
		/* 821BB318h case   17:*/		return 0x821BB31C;
		  /* 821BB31Ch */ case   18:  		/* lwz R11, <#[R11 + 8]> */
		/* 821BB31Ch case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821BB31Ch case   18:*/		return 0x821BB320;
		  /* 821BB320h */ case   19:  		/* b -24 */
		/* 821BB320h case   19:*/		return 0x821BB308;
		/* 821BB320h case   19:*/		return 0x821BB324;
	}
	return 0x821BB324;
} // Block from 821BB2D4h-821BB324h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821BB324h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB324( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB324) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB324);
		  /* 821BB324h */ case    0:  		/* rlwinm. R11, R10, 2, 31, 31 */
		/* 821BB324h case    0:*/		cpu::op::rlwinm<1,2,31,31>(regs,&regs.R11,regs.R10);
		/* 821BB324h case    0:*/		return 0x821BB328;
		  /* 821BB328h */ case    1:  		/* mr R11, R21 */
		/* 821BB328h case    1:*/		regs.R11 = regs.R21;
		/* 821BB328h case    1:*/		return 0x821BB32C;
		  /* 821BB32Ch */ case    2:  		/* bc 4, CR0_EQ, 8 */
		/* 821BB32Ch case    2:*/		if ( !regs.CR[0].eq ) { return 0x821BB334;  }
		/* 821BB32Ch case    2:*/		return 0x821BB330;
	}
	return 0x821BB330;
} // Block from 821BB324h-821BB330h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BB330h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB330( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB330) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB330);
		  /* 821BB330h */ case    0:  		/* li R11, 0 */
		/* 821BB330h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BB330h case    0:*/		return 0x821BB334;
	}
	return 0x821BB334;
} // Block from 821BB330h-821BB334h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BB334h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB334( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB334) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB334);
		  /* 821BB334h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821BB334h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821BB334h case    0:*/		return 0x821BB338;
		  /* 821BB338h */ case    1:  		/* bc 4, CR0_EQ, -180 */
		/* 821BB338h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821BB284;  }
		/* 821BB338h case    1:*/		return 0x821BB33C;
		  /* 821BB33Ch */ case    2:  		/* b -216 */
		/* 821BB33Ch case    2:*/		return 0x821BB264;
		/* 821BB33Ch case    2:*/		return 0x821BB340;
	}
	return 0x821BB340;
} // Block from 821BB334h-821BB340h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BB340h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB340( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB340) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB340);
		  /* 821BB340h */ case    0:  		/* lwz R11, <#[R15 + 116]> */
		/* 821BB340h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000074) );
		/* 821BB340h case    0:*/		return 0x821BB344;
		  /* 821BB344h */ case    1:  		/* lhz R10, <#[R16 + 16]> */
		/* 821BB344h case    1:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R16 + 0x00000010) );
		/* 821BB344h case    1:*/		return 0x821BB348;
		  /* 821BB348h */ case    2:  		/* addi R11, R11, 1 */
		/* 821BB348h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821BB348h case    2:*/		return 0x821BB34C;
		  /* 821BB34Ch */ case    3:  		/* rlwinm R10, R10, 0, 29, 31 */
		/* 821BB34Ch case    3:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R10,regs.R10);
		/* 821BB34Ch case    3:*/		return 0x821BB350;
		  /* 821BB350h */ case    4:  		/* sth R11, <#[R16 + 18]> */
		/* 821BB350h case    4:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R16 + 0x00000012) );
		/* 821BB350h case    4:*/		return 0x821BB354;
		  /* 821BB354h */ case    5:  		/* lwz R11, <#[R15 + 116]> */
		/* 821BB354h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000074) );
		/* 821BB354h case    5:*/		return 0x821BB358;
		  /* 821BB358h */ case    6:  		/* add R11, R10, R11 */
		/* 821BB358h case    6:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821BB358h case    6:*/		return 0x821BB35C;
		  /* 821BB35Ch */ case    7:  		/* stw R11, <#[R15 + 116]> */
		/* 821BB35Ch case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R15 + 0x00000074) );
		/* 821BB35Ch case    7:*/		return 0x821BB360;
		  /* 821BB360h */ case    8:  		/* b -220 */
		/* 821BB360h case    8:*/		return 0x821BB284;
		/* 821BB360h case    8:*/		return 0x821BB364;
	}
	return 0x821BB364;
} // Block from 821BB340h-821BB364h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821BB364h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB364( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB364) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB364);
		  /* 821BB364h */ case    0:  		/* rlwinm. R11, R9, 9, 31, 31 */
		/* 821BB364h case    0:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R9);
		/* 821BB364h case    0:*/		return 0x821BB368;
		  /* 821BB368h */ case    1:  		/* bc 4, CR0_EQ, 52 */
		/* 821BB368h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821BB39C;  }
		/* 821BB368h case    1:*/		return 0x821BB36C;
		  /* 821BB36Ch */ case    2:  		/* lwz R11, <#[R16]> */
		/* 821BB36Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000000) );
		/* 821BB36Ch case    2:*/		return 0x821BB370;
		  /* 821BB370h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 821BB370h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BB370h case    3:*/		return 0x821BB374;
		  /* 821BB374h */ case    4:  		/* bc 12, CR6_EQ, 40 */
		/* 821BB374h case    4:*/		if ( regs.CR[6].eq ) { return 0x821BB39C;  }
		/* 821BB374h case    4:*/		return 0x821BB378;
		  /* 821BB378h */ case    5:  		/* lwz R10, <#[R11 + 12]> */
		/* 821BB378h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 821BB378h case    5:*/		return 0x821BB37C;
		  /* 821BB37Ch */ case    6:  		/* lwz R10, <#[R10 + 8]> */
		/* 821BB37Ch case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 821BB37Ch case    6:*/		return 0x821BB380;
		  /* 821BB380h */ case    7:  		/* rlwinm. R10, R10, 9, 31, 31 */
		/* 821BB380h case    7:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R10,regs.R10);
		/* 821BB380h case    7:*/		return 0x821BB384;
		  /* 821BB384h */ case    8:  		/* bc 4, CR0_EQ, 12 */
		/* 821BB384h case    8:*/		if ( !regs.CR[0].eq ) { return 0x821BB390;  }
		/* 821BB384h case    8:*/		return 0x821BB388;
		  /* 821BB388h */ case    9:  		/* lwz R11, <#[R11 + 4]> */
		/* 821BB388h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821BB388h case    9:*/		return 0x821BB38C;
		  /* 821BB38Ch */ case   10:  		/* b -28 */
		/* 821BB38Ch case   10:*/		return 0x821BB370;
		/* 821BB38Ch case   10:*/		return 0x821BB390;
	}
	return 0x821BB390;
} // Block from 821BB364h-821BB390h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821BB390h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB390( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB390) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB390);
		  /* 821BB390h */ case    0:  		/* mr R4, R16 */
		/* 821BB390h case    0:*/		regs.R4 = regs.R16;
		/* 821BB390h case    0:*/		return 0x821BB394;
		  /* 821BB394h */ case    1:  		/* mr R3, R15 */
		/* 821BB394h case    1:*/		regs.R3 = regs.R15;
		/* 821BB394h case    1:*/		return 0x821BB398;
		  /* 821BB398h */ case    2:  		/* bl -20208 */
		/* 821BB398h case    2:*/		regs.LR = 0x821BB39C; return 0x821B64A8;
		/* 821BB398h case    2:*/		return 0x821BB39C;
	}
	return 0x821BB39C;
} // Block from 821BB390h-821BB39Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BB39Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB39C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB39C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB39C);
		  /* 821BB39Ch */ case    0:  		/* lwz R11, <#[R16 + 8]> */
		/* 821BB39Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000008) );
		/* 821BB39Ch case    0:*/		return 0x821BB3A0;
		  /* 821BB3A0h */ case    1:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 821BB3A0h case    1:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 821BB3A0h case    1:*/		return 0x821BB3A4;
		  /* 821BB3A4h */ case    2:  		/* bc 12, CR0_EQ, -288 */
		/* 821BB3A4h case    2:*/		if ( regs.CR[0].eq ) { return 0x821BB284;  }
		/* 821BB3A4h case    2:*/		return 0x821BB3A8;
		  /* 821BB3A8h */ case    3:  		/* lwz R31, <#[R16]> */
		/* 821BB3A8h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R16 + 0x00000000) );
		/* 821BB3A8h case    3:*/		return 0x821BB3AC;
		  /* 821BB3ACh */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 821BB3ACh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821BB3ACh case    4:*/		return 0x821BB3B0;
		  /* 821BB3B0h */ case    5:  		/* bc 12, CR6_EQ, -300 */
		/* 821BB3B0h case    5:*/		if ( regs.CR[6].eq ) { return 0x821BB284;  }
		/* 821BB3B0h case    5:*/		return 0x821BB3B4;
		  /* 821BB3B4h */ case    6:  		/* lwz R4, <#[R31 + 12]> */
		/* 821BB3B4h case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 821BB3B4h case    6:*/		return 0x821BB3B8;
		  /* 821BB3B8h */ case    7:  		/* lwz R11, <#[R4 + 8]> */
		/* 821BB3B8h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821BB3B8h case    7:*/		return 0x821BB3BC;
		  /* 821BB3BCh */ case    8:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 821BB3BCh case    8:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 821BB3BCh case    8:*/		return 0x821BB3C0;
		  /* 821BB3C0h */ case    9:  		/* bc 4, CR0_EQ, 12 */
		/* 821BB3C0h case    9:*/		if ( !regs.CR[0].eq ) { return 0x821BB3CC;  }
		/* 821BB3C0h case    9:*/		return 0x821BB3C4;
		  /* 821BB3C4h */ case   10:  		/* mr R3, R15 */
		/* 821BB3C4h case   10:*/		regs.R3 = regs.R15;
		/* 821BB3C4h case   10:*/		return 0x821BB3C8;
		  /* 821BB3C8h */ case   11:  		/* bl -20256 */
		/* 821BB3C8h case   11:*/		regs.LR = 0x821BB3CC; return 0x821B64A8;
		/* 821BB3C8h case   11:*/		return 0x821BB3CC;
	}
	return 0x821BB3CC;
} // Block from 821BB39Ch-821BB3CCh (12 instructions)

//////////////////////////////////////////////////////
// Block at 821BB3CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB3CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB3CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB3CC);
		  /* 821BB3CCh */ case    0:  		/* lwz R31, <#[R31 + 4]> */
		/* 821BB3CCh case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000004) );
		/* 821BB3CCh case    0:*/		return 0x821BB3D0;
		  /* 821BB3D0h */ case    1:  		/* b -36 */
		/* 821BB3D0h case    1:*/		return 0x821BB3AC;
		/* 821BB3D0h case    1:*/		return 0x821BB3D4;
	}
	return 0x821BB3D4;
} // Block from 821BB3CCh-821BB3D4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BB3D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB3D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB3D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB3D4);
		  /* 821BB3D4h */ case    0:  		/* li R11, 0 */
		/* 821BB3D4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BB3D4h case    0:*/		return 0x821BB3D8;
	}
	return 0x821BB3D8;
} // Block from 821BB3D4h-821BB3D8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BB3D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB3D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB3D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB3D8);
		  /* 821BB3D8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821BB3D8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821BB3D8h case    0:*/		return 0x821BB3DC;
		  /* 821BB3DCh */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 821BB3DCh case    1:*/		if ( regs.CR[0].eq ) { return 0x821BB3EC;  }
		/* 821BB3DCh case    1:*/		return 0x821BB3E0;
		  /* 821BB3E0h */ case    2:  		/* lwz R11, <#[R15 + 40]> */
		/* 821BB3E0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000028) );
		/* 821BB3E0h case    2:*/		return 0x821BB3E4;
		  /* 821BB3E4h */ case    3:  		/* oris R11, R11, 256 */
		/* 821BB3E4h case    3:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x100);
		/* 821BB3E4h case    3:*/		return 0x821BB3E8;
		  /* 821BB3E8h */ case    4:  		/* stw R11, <#[R15 + 40]> */
		/* 821BB3E8h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R15 + 0x00000028) );
		/* 821BB3E8h case    4:*/		return 0x821BB3EC;
	}
	return 0x821BB3EC;
} // Block from 821BB3D8h-821BB3ECh (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BB3ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB3EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB3EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB3EC);
		  /* 821BB3ECh */ case    0:  		/* lwz R11, <#[R15 + 40]> */
		/* 821BB3ECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000028) );
		/* 821BB3ECh case    0:*/		return 0x821BB3F0;
		  /* 821BB3F0h */ case    1:  		/* rlwinm. R11, R11, 0, 29, 29 */
		/* 821BB3F0h case    1:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R11,regs.R11);
		/* 821BB3F0h case    1:*/		return 0x821BB3F4;
		  /* 821BB3F4h */ case    2:  		/* bc 12, CR0_EQ, 304 */
		/* 821BB3F4h case    2:*/		if ( regs.CR[0].eq ) { return 0x821BB524;  }
		/* 821BB3F4h case    2:*/		return 0x821BB3F8;
		  /* 821BB3F8h */ case    3:  		/* lwz R11, <#[R16 + 8]> */
		/* 821BB3F8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000008) );
		/* 821BB3F8h case    3:*/		return 0x821BB3FC;
		  /* 821BB3FCh */ case    4:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 821BB3FCh case    4:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 821BB3FCh case    4:*/		return 0x821BB400;
		  /* 821BB400h */ case    5:  		/* cmplwi CR6, R4, 86 */
		/* 821BB400h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000056);
		/* 821BB400h case    5:*/		return 0x821BB404;
		  /* 821BB404h */ case    6:  		/* bc 12, CR6_EQ, 48 */
		/* 821BB404h case    6:*/		if ( regs.CR[6].eq ) { return 0x821BB434;  }
		/* 821BB404h case    6:*/		return 0x821BB408;
		  /* 821BB408h */ case    7:  		/* cmplwi CR6, R4, 87 */
		/* 821BB408h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000057);
		/* 821BB408h case    7:*/		return 0x821BB40C;
		  /* 821BB40Ch */ case    8:  		/* bc 12, CR6_EQ, 40 */
		/* 821BB40Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x821BB434;  }
		/* 821BB40Ch case    8:*/		return 0x821BB410;
		  /* 821BB410h */ case    9:  		/* cmplwi CR6, R4, 89 */
		/* 821BB410h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000059);
		/* 821BB410h case    9:*/		return 0x821BB414;
		  /* 821BB414h */ case   10:  		/* bc 12, CR6_EQ, 32 */
		/* 821BB414h case   10:*/		if ( regs.CR[6].eq ) { return 0x821BB434;  }
		/* 821BB414h case   10:*/		return 0x821BB418;
		  /* 821BB418h */ case   11:  		/* cmplwi CR6, R4, 90 */
		/* 821BB418h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x0000005A);
		/* 821BB418h case   11:*/		return 0x821BB41C;
		  /* 821BB41Ch */ case   12:  		/* bc 12, CR6_EQ, 24 */
		/* 821BB41Ch case   12:*/		if ( regs.CR[6].eq ) { return 0x821BB434;  }
		/* 821BB41Ch case   12:*/		return 0x821BB420;
		  /* 821BB420h */ case   13:  		/* cmplwi CR6, R4, 84 */
		/* 821BB420h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000054);
		/* 821BB420h case   13:*/		return 0x821BB424;
		  /* 821BB424h */ case   14:  		/* bc 12, CR6_EQ, 16 */
		/* 821BB424h case   14:*/		if ( regs.CR[6].eq ) { return 0x821BB434;  }
		/* 821BB424h case   14:*/		return 0x821BB428;
		  /* 821BB428h */ case   15:  		/* cmplwi CR6, R4, 85 */
		/* 821BB428h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000055);
		/* 821BB428h case   15:*/		return 0x821BB42C;
		  /* 821BB42Ch */ case   16:  		/* li R10, 0 */
		/* 821BB42Ch case   16:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821BB42Ch case   16:*/		return 0x821BB430;
		  /* 821BB430h */ case   17:  		/* bc 4, CR6_EQ, 8 */
		/* 821BB430h case   17:*/		if ( !regs.CR[6].eq ) { return 0x821BB438;  }
		/* 821BB430h case   17:*/		return 0x821BB434;
	}
	return 0x821BB434;
} // Block from 821BB3ECh-821BB434h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821BB434h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB434( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB434) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB434);
		  /* 821BB434h */ case    0:  		/* mr R10, R21 */
		/* 821BB434h case    0:*/		regs.R10 = regs.R21;
		/* 821BB434h case    0:*/		return 0x821BB438;
	}
	return 0x821BB438;
} // Block from 821BB434h-821BB438h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BB438h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB438( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB438) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB438);
		  /* 821BB438h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 821BB438h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 821BB438h case    0:*/		return 0x821BB43C;
		  /* 821BB43Ch */ case    1:  		/* bc 12, CR0_EQ, 232 */
		/* 821BB43Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x821BB524;  }
		/* 821BB43Ch case    1:*/		return 0x821BB440;
		  /* 821BB440h */ case    2:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 821BB440h case    2:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 821BB440h case    2:*/		return 0x821BB444;
		  /* 821BB444h */ case    3:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 821BB444h case    3:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 821BB444h case    3:*/		return 0x821BB448;
		  /* 821BB448h */ case    4:  		/* mr R3, R15 */
		/* 821BB448h case    4:*/		regs.R3 = regs.R15;
		/* 821BB448h case    4:*/		return 0x821BB44C;
		  /* 821BB44Ch */ case    5:  		/* bl -356380 */
		/* 821BB44Ch case    5:*/		regs.LR = 0x821BB450; return 0x82164430;
		/* 821BB44Ch case    5:*/		return 0x821BB450;
		  /* 821BB450h */ case    6:  		/* addi R11, R16, -16 */
		/* 821BB450h case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R16,0xFFFFFFF0);
		/* 821BB450h case    6:*/		return 0x821BB454;
		  /* 821BB454h */ case    7:  		/* add R31, R3, R11 */
		/* 821BB454h case    7:*/		cpu::op::add<0>(regs,&regs.R31,regs.R3,regs.R11);
		/* 821BB454h case    7:*/		return 0x821BB458;
		  /* 821BB458h */ case    8:  		/* lwz R11, <#[R31 + 8]> */
		/* 821BB458h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821BB458h case    8:*/		return 0x821BB45C;
		  /* 821BB45Ch */ case    9:  		/* rlwinm. R11, R11, 0, 30, 31 */
		/* 821BB45Ch case    9:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R11,regs.R11);
		/* 821BB45Ch case    9:*/		return 0x821BB460;
		  /* 821BB460h */ case   10:  		/* bc 12, CR0_EQ, 40 */
		/* 821BB460h case   10:*/		if ( regs.CR[0].eq ) { return 0x821BB488;  }
		/* 821BB460h case   10:*/		return 0x821BB464;
		  /* 821BB464h */ case   11:  		/* lwz R11, <#[R31 + 4]> */
		/* 821BB464h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 821BB464h case   11:*/		return 0x821BB468;
		  /* 821BB468h */ case   12:  		/* mr R5, R15 */
		/* 821BB468h case   12:*/		regs.R5 = regs.R15;
		/* 821BB468h case   12:*/		return 0x821BB46C;
		  /* 821BB46Ch */ case   13:  		/* mr R3, R16 */
		/* 821BB46Ch case   13:*/		regs.R3 = regs.R16;
		/* 821BB46Ch case   13:*/		return 0x821BB470;
		  /* 821BB470h */ case   14:  		/* rlwinm R4, R11, 0, 0, 29 */
		/* 821BB470h case   14:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R4,regs.R11);
		/* 821BB470h case   14:*/		return 0x821BB474;
		  /* 821BB474h */ case   15:  		/* bl -273252 */
		/* 821BB474h case   15:*/		regs.LR = 0x821BB478; return 0x82178910;
		/* 821BB474h case   15:*/		return 0x821BB478;
		  /* 821BB478h */ case   16:  		/* lwz R10, <#[R31 + 8]> */
		/* 821BB478h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 821BB478h case   16:*/		return 0x821BB47C;
		  /* 821BB47Ch */ case   17:  		/* li R11, 3 */
		/* 821BB47Ch case   17:*/		cpu::op::li<0>(regs,&regs.R11,0x3);
		/* 821BB47Ch case   17:*/		return 0x821BB480;
		  /* 821BB480h */ case   18:  		/* rlwimi R10, R11, 6, 23, 31 */
		/* 821BB480h case   18:*/		cpu::op::rlwimi<0,6,23,31>(regs,&regs.R10,regs.R11);
		/* 821BB480h case   18:*/		return 0x821BB484;
		  /* 821BB484h */ case   19:  		/* stw R10, <#[R31 + 8]> */
		/* 821BB484h case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 821BB484h case   19:*/		return 0x821BB488;
	}
	return 0x821BB488;
} // Block from 821BB438h-821BB488h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821BB488h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB488( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB488) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB488);
		  /* 821BB488h */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 821BB488h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821BB488h case    0:*/		return 0x821BB48C;
		  /* 821BB48Ch */ case    1:  		/* rlwinm. R10, R11, 0, 30, 31 */
		/* 821BB48Ch case    1:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R10,regs.R11);
		/* 821BB48Ch case    1:*/		return 0x821BB490;
		  /* 821BB490h */ case    2:  		/* bc 4, CR0_EQ, 148 */
		/* 821BB490h case    2:*/		if ( !regs.CR[0].eq ) { return 0x821BB524;  }
		/* 821BB490h case    2:*/		return 0x821BB494;
		  /* 821BB494h */ case    3:  		/* rlwinm R11, R11, 30, 28, 31 */
		/* 821BB494h case    3:*/		cpu::op::rlwinm<0,30,28,31>(regs,&regs.R11,regs.R11);
		/* 821BB494h case    3:*/		return 0x821BB498;
		  /* 821BB498h */ case    4:  		/* cmpwi CR6, R11, 3 */
		/* 821BB498h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 821BB498h case    4:*/		return 0x821BB49C;
		  /* 821BB49Ch */ case    5:  		/* bc 4, CR6_EQ, 136 */
		/* 821BB49Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x821BB524;  }
		/* 821BB49Ch case    5:*/		return 0x821BB4A0;
		  /* 821BB4A0h */ case    6:  		/* lwz R11, <#[R23 + 48]> */
		/* 821BB4A0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000030) );
		/* 821BB4A0h case    6:*/		return 0x821BB4A4;
		  /* 821BB4A4h */ case    7:  		/* rlwinm. R11, R11, 6, 31, 31 */
		/* 821BB4A4h case    7:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R11,regs.R11);
		/* 821BB4A4h case    7:*/		return 0x821BB4A8;
		  /* 821BB4A8h */ case    8:  		/* bc 12, CR0_EQ, 124 */
		/* 821BB4A8h case    8:*/		if ( regs.CR[0].eq ) { return 0x821BB524;  }
		/* 821BB4A8h case    8:*/		return 0x821BB4AC;
		  /* 821BB4ACh */ case    9:  		/* lwz R11, <#[R15 + 4]> */
		/* 821BB4ACh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R15 + 0x00000004) );
		/* 821BB4ACh case    9:*/		return 0x821BB4B0;
		  /* 821BB4B0h */ case   10:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BB4B0h case   10:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BB4B0h case   10:*/		return 0x821BB4B4;
		  /* 821BB4B4h */ case   11:  		/* bc 4, CR0_EQ, 112 */
		/* 821BB4B4h case   11:*/		if ( !regs.CR[0].eq ) { return 0x821BB524;  }
		/* 821BB4B4h case   11:*/		return 0x821BB4B8;
		  /* 821BB4B8h */ case   12:  		/* cmplwi CR0, R11, 0 */
		/* 821BB4B8h case   12:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821BB4B8h case   12:*/		return 0x821BB4BC;
		  /* 821BB4BCh */ case   13:  		/* bc 12, CR0_EQ, 104 */
		/* 821BB4BCh case   13:*/		if ( regs.CR[0].eq ) { return 0x821BB524;  }
		/* 821BB4BCh case   13:*/		return 0x821BB4C0;
		  /* 821BB4C0h */ case   14:  		/* lwz R8, <#[R11 + 40]> */
		/* 821BB4C0h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000028) );
		/* 821BB4C0h case   14:*/		return 0x821BB4C4;
		  /* 821BB4C4h */ case   15:  		/* lwz R10, <#[R23 + 48]> */
		/* 821BB4C4h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R23 + 0x00000030) );
		/* 821BB4C4h case   15:*/		return 0x821BB4C8;
		  /* 821BB4C8h */ case   16:  		/* rlwinm R9, R10, 0, 13, 31 */
		/* 821BB4C8h case   16:*/		cpu::op::rlwinm<0,0,13,31>(regs,&regs.R9,regs.R10);
		/* 821BB4C8h case   16:*/		return 0x821BB4CC;
		  /* 821BB4CCh */ case   17:  		/* lwz R7, <#[R8]> */
		/* 821BB4CCh case   17:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R8 + 0x00000000) );
		/* 821BB4CCh case   17:*/		return 0x821BB4D0;
		  /* 821BB4D0h */ case   18:  		/* rlwinm R10, R9, 27, 5, 31 */
		/* 821BB4D0h case   18:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R9);
		/* 821BB4D0h case   18:*/		return 0x821BB4D4;
		  /* 821BB4D4h */ case   19:  		/* rlwinm R6, R9, 0, 27, 31 */
		/* 821BB4D4h case   19:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R6,regs.R9);
		/* 821BB4D4h case   19:*/		return 0x821BB4D8;
		  /* 821BB4D8h */ case   20:  		/* rlwinm R9, R7, 0, 13, 31 */
		/* 821BB4D8h case   20:*/		cpu::op::rlwinm<0,0,13,31>(regs,&regs.R9,regs.R7);
		/* 821BB4D8h case   20:*/		return 0x821BB4DC;
		  /* 821BB4DCh */ case   21:  		/* addi R10, R10, 1 */
		/* 821BB4DCh case   21:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821BB4DCh case   21:*/		return 0x821BB4E0;
		  /* 821BB4E0h */ case   22:  		/* addi R9, R9, 31 */
		/* 821BB4E0h case   22:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1F);
		/* 821BB4E0h case   22:*/		return 0x821BB4E4;
		  /* 821BB4E4h */ case   23:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821BB4E4h case   23:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821BB4E4h case   23:*/		return 0x821BB4E8;
		  /* 821BB4E8h */ case   24:  		/* rlwinm R9, R9, 29, 3, 29 */
		/* 821BB4E8h case   24:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R9,regs.R9);
		/* 821BB4E8h case   24:*/		return 0x821BB4EC;
		  /* 821BB4ECh */ case   25:  		/* slw R7, R21, R6 */
		/* 821BB4ECh case   25:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R21,regs.R6);
		/* 821BB4ECh case   25:*/		return 0x821BB4F0;
		  /* 821BB4F0h */ case   26:  		/* add R10, R9, R10 */
		/* 821BB4F0h case   26:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 821BB4F0h case   26:*/		return 0x821BB4F4;
		  /* 821BB4F4h */ case   27:  		/* lwzx R10, <#[R10 + R8]> */
		/* 821BB4F4h case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R8 + 0x00000000) );
		/* 821BB4F4h case   27:*/		return 0x821BB4F8;
		  /* 821BB4F8h */ case   28:  		/* and. R10, R10, R7 */
		/* 821BB4F8h case   28:*/		cpu::op::and<1>(regs,&regs.R10,regs.R10,regs.R7);
		/* 821BB4F8h case   28:*/		return 0x821BB4FC;
		  /* 821BB4FCh */ case   29:  		/* bc 12, CR0_EQ, 16 */
		/* 821BB4FCh case   29:*/		if ( regs.CR[0].eq ) { return 0x821BB50C;  }
		/* 821BB4FCh case   29:*/		return 0x821BB500;
		  /* 821BB500h */ case   30:  		/* lwz R10, <#[R11 + 48]> */
		/* 821BB500h case   30:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 821BB500h case   30:*/		return 0x821BB504;
		  /* 821BB504h */ case   31:  		/* oris R10, R10, 512 */
		/* 821BB504h case   31:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x200);
		/* 821BB504h case   31:*/		return 0x821BB508;
		  /* 821BB508h */ case   32:  		/* stw R10, <#[R11 + 48]> */
		/* 821BB508h case   32:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 821BB508h case   32:*/		return 0x821BB50C;
	}
	return 0x821BB50C;
} // Block from 821BB488h-821BB50Ch (33 instructions)

//////////////////////////////////////////////////////
// Block at 821BB50Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB50C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB50C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB50C);
		  /* 821BB50Ch */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821BB50Ch case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821BB50Ch case    0:*/		return 0x821BB510;
		  /* 821BB510h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 821BB510h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821BB510h case    1:*/		return 0x821BB514;
		  /* 821BB514h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BB514h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BB514h case    2:*/		return 0x821BB518;
		  /* 821BB518h */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 821BB518h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BB524;  }
		/* 821BB518h case    3:*/		return 0x821BB51C;
		  /* 821BB51Ch */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 821BB51Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BB51Ch case    4:*/		return 0x821BB520;
		  /* 821BB520h */ case    5:  		/* bc 4, CR6_EQ, -96 */
		/* 821BB520h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821BB4C0;  }
		/* 821BB520h case    5:*/		return 0x821BB524;
	}
	return 0x821BB524;
} // Block from 821BB50Ch-821BB524h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BB524h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB524( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB524) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB524);
		  /* 821BB524h */ case    0:  		/* rlwinm R11, R16, 0, 0, 30 */
		/* 821BB524h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R16);
		/* 821BB524h case    0:*/		return 0x821BB528;
		  /* 821BB528h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 821BB528h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 821BB528h case    1:*/		return 0x821BB52C;
		  /* 821BB52Ch */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BB52Ch case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BB52Ch case    2:*/		return 0x821BB530;
		  /* 821BB530h */ case    3:  		/* bc 12, CR0_EQ, 12 */
		/* 821BB530h case    3:*/		if ( regs.CR[0].eq ) { return 0x821BB53C;  }
		/* 821BB530h case    3:*/		return 0x821BB534;
		  /* 821BB534h */ case    4:  		/* li R16, 0 */
		/* 821BB534h case    4:*/		cpu::op::li<0>(regs,&regs.R16,0x0);
		/* 821BB534h case    4:*/		return 0x821BB538;
		  /* 821BB538h */ case    5:  		/* b 16 */
		/* 821BB538h case    5:*/		return 0x821BB548;
		/* 821BB538h case    5:*/		return 0x821BB53C;
	}
	return 0x821BB53C;
} // Block from 821BB524h-821BB53Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BB53Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB53C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB53C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB53C);
		  /* 821BB53Ch */ case    0:  		/* mr R16, R11 */
		/* 821BB53Ch case    0:*/		regs.R16 = regs.R11;
		/* 821BB53Ch case    0:*/		return 0x821BB540;
		  /* 821BB540h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 821BB540h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BB540h case    1:*/		return 0x821BB544;
		  /* 821BB544h */ case    2:  		/* bc 4, CR6_EQ, -7116 */
		/* 821BB544h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821B9978;  }
		/* 821BB544h case    2:*/		return 0x821BB548;
	}
	return 0x821BB548;
} // Block from 821BB53Ch-821BB548h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BB548h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB548( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB548) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB548);
		  /* 821BB548h */ case    0:  		/* addi R10, R23, 32 */
		/* 821BB548h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R23,0x20);
		/* 821BB548h case    0:*/		return 0x821BB54C;
		  /* 821BB54Ch */ case    1:  		/* cmplw CR6, R22, R10 */
		/* 821BB54Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R10);
		/* 821BB54Ch case    1:*/		return 0x821BB550;
		  /* 821BB550h */ case    2:  		/* bc 12, CR6_EQ, -7128 */
		/* 821BB550h case    2:*/		if ( regs.CR[6].eq ) { return 0x821B9978;  }
		/* 821BB550h case    2:*/		return 0x821BB554;
		  /* 821BB554h */ case    3:  		/* addi R11, R23, 24 */
		/* 821BB554h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R23,0x18);
		/* 821BB554h case    3:*/		return 0x821BB558;
		  /* 821BB558h */ case    4:  		/* cmplw CR6, R22, R11 */
		/* 821BB558h case    4:*/		cpu::op::cmplw<6>(regs,regs.R22,regs.R11);
		/* 821BB558h case    4:*/		return 0x821BB55C;
		  /* 821BB55Ch */ case    5:  		/* bc 12, CR6_EQ, 44 */
		/* 821BB55Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x821BB588;  }
		/* 821BB55Ch case    5:*/		return 0x821BB560;
		  /* 821BB560h */ case    6:  		/* lwz R9, <#[R23 + 28]> */
		/* 821BB560h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R23 + 0x0000001C) );
		/* 821BB560h case    6:*/		return 0x821BB564;
		  /* 821BB564h */ case    7:  		/* rlwinm. R9, R9, 0, 31, 31 */
		/* 821BB564h case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R9);
		/* 821BB564h case    7:*/		return 0x821BB568;
		  /* 821BB568h */ case    8:  		/* bc 4, CR0_EQ, 32 */
		/* 821BB568h case    8:*/		if ( !regs.CR[0].eq ) { return 0x821BB588;  }
		/* 821BB568h case    8:*/		return 0x821BB56C;
		  /* 821BB56Ch */ case    9:  		/* lwz R10, <#[R11 + 4]> */
		/* 821BB56Ch case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821BB56Ch case    9:*/		return 0x821BB570;
		  /* 821BB570h */ case   10:  		/* mr R22, R11 */
		/* 821BB570h case   10:*/		regs.R22 = regs.R11;
		/* 821BB570h case   10:*/		return 0x821BB574;
		  /* 821BB574h */ case   11:  		/* rlwinm R11, R10, 0, 31, 31 */
		/* 821BB574h case   11:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R11,regs.R10);
		/* 821BB574h case   11:*/		return 0x821BB578;
		  /* 821BB578h */ case   12:  		/* addic R11, R11, -1 */
		/* 821BB578h case   12:*/		cpu::op::addic<0>(regs,&regs.R11,regs.R11,0xFFFFFFFF);
		/* 821BB578h case   12:*/		return 0x821BB57C;
		  /* 821BB57Ch */ case   13:  		/* subfe R11, R11, R11 */
		/* 821BB57Ch case   13:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 821BB57Ch case   13:*/		return 0x821BB580;
		  /* 821BB580h */ case   14:  		/* and R16, R11, R10 */
		/* 821BB580h case   14:*/		cpu::op::and<0>(regs,&regs.R16,regs.R11,regs.R10);
		/* 821BB580h case   14:*/		return 0x821BB584;
		  /* 821BB584h */ case   15:  		/* b -7184 */
		/* 821BB584h case   15:*/		return 0x821B9974;
		/* 821BB584h case   15:*/		return 0x821BB588;
	}
	return 0x821BB588;
} // Block from 821BB548h-821BB588h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821BB588h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB588( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB588) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB588);
		  /* 821BB588h */ case    0:  		/* lwz R11, <#[R10 + 4]> */
		/* 821BB588h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 821BB588h case    0:*/		return 0x821BB58C;
		  /* 821BB58Ch */ case    1:  		/* mr R22, R10 */
		/* 821BB58Ch case    1:*/		regs.R22 = regs.R10;
		/* 821BB58Ch case    1:*/		return 0x821BB590;
		  /* 821BB590h */ case    2:  		/* b -7212 */
		/* 821BB590h case    2:*/		return 0x821B9964;
		/* 821BB590h case    2:*/		return 0x821BB594;
	}
	return 0x821BB594;
} // Block from 821BB588h-821BB594h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BB594h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB594( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB594) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB594);
		  /* 821BB594h */ case    0:  		/* li R4, 1 */
		/* 821BB594h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 821BB594h case    0:*/		return 0x821BB598;
		  /* 821BB598h */ case    1:  		/* fmr FR4, FR31 */
		/* 821BB598h case    1:*/		cpu::op::fmr<0>(regs,&regs.FR4,regs.FR31);
		/* 821BB598h case    1:*/		return 0x821BB59C;
		  /* 821BB59Ch */ case    2:  		/* mr R3, R15 */
		/* 821BB59Ch case    2:*/		regs.R3 = regs.R15;
		/* 821BB59Ch case    2:*/		return 0x821BB5A0;
		  /* 821BB5A0h */ case    3:  		/* fmr FR3, FR31 */
		/* 821BB5A0h case    3:*/		cpu::op::fmr<0>(regs,&regs.FR3,regs.FR31);
		/* 821BB5A0h case    3:*/		return 0x821BB5A4;
		  /* 821BB5A4h */ case    4:  		/* fmr FR2, FR31 */
		/* 821BB5A4h case    4:*/		cpu::op::fmr<0>(regs,&regs.FR2,regs.FR31);
		/* 821BB5A4h case    4:*/		return 0x821BB5A8;
		  /* 821BB5A8h */ case    5:  		/* fmr FR1, FR31 */
		/* 821BB5A8h case    5:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR31);
		/* 821BB5A8h case    5:*/		return 0x821BB5AC;
		  /* 821BB5ACh */ case    6:  		/* bl 456108 */
		/* 821BB5ACh case    6:*/		regs.LR = 0x821BB5B0; return 0x8222AB58;
		/* 821BB5ACh case    6:*/		return 0x821BB5B0;
		  /* 821BB5B0h */ case    7:  		/* mr R31, R3 */
		/* 821BB5B0h case    7:*/		regs.R31 = regs.R3;
		/* 821BB5B0h case    7:*/		return 0x821BB5B4;
		  /* 821BB5B4h */ case    8:  		/* mr R7, R3 */
		/* 821BB5B4h case    8:*/		regs.R7 = regs.R3;
		/* 821BB5B4h case    8:*/		return 0x821BB5B8;
		  /* 821BB5B8h */ case    9:  		/* mr R6, R3 */
		/* 821BB5B8h case    9:*/		regs.R6 = regs.R3;
		/* 821BB5B8h case    9:*/		return 0x821BB5BC;
		  /* 821BB5BCh */ case   10:  		/* li R5, 0 */
		/* 821BB5BCh case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821BB5BCh case   10:*/		return 0x821BB5C0;
		  /* 821BB5C0h */ case   11:  		/* mr R4, R23 */
		/* 821BB5C0h case   11:*/		regs.R4 = regs.R23;
		/* 821BB5C0h case   11:*/		return 0x821BB5C4;
		  /* 821BB5C4h */ case   12:  		/* mr R3, R15 */
		/* 821BB5C4h case   12:*/		regs.R3 = regs.R15;
		/* 821BB5C4h case   12:*/		return 0x821BB5C8;
		  /* 821BB5C8h */ case   13:  		/* bl -18128 */
		/* 821BB5C8h case   13:*/		regs.LR = 0x821BB5CC; return 0x821B6EF8;
		/* 821BB5C8h case   13:*/		return 0x821BB5CC;
		  /* 821BB5CCh */ case   14:  		/* addi R11, R23, 24 */
		/* 821BB5CCh case   14:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R23,0x18);
		/* 821BB5CCh case   14:*/		return 0x821BB5D0;
		  /* 821BB5D0h */ case   15:  		/* rlwinm R10, R3, 0, 0, 30 */
		/* 821BB5D0h case   15:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R3);
		/* 821BB5D0h case   15:*/		return 0x821BB5D4;
		  /* 821BB5D4h */ case   16:  		/* addi R11, R11, 4 */
		/* 821BB5D4h case   16:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821BB5D4h case   16:*/		return 0x821BB5D8;
		  /* 821BB5D8h */ case   17:  		/* addi R10, R10, 36 */
		/* 821BB5D8h case   17:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 821BB5D8h case   17:*/		return 0x821BB5DC;
		  /* 821BB5DCh */ case   18:  		/* ori R7, R11, 1 */
		/* 821BB5DCh case   18:*/		cpu::op::ori<0>(regs,&regs.R7,regs.R11,0x1);
		/* 821BB5DCh case   18:*/		return 0x821BB5E0;
		  /* 821BB5E0h */ case   19:  		/* addi R9, R10, 4 */
		/* 821BB5E0h case   19:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 821BB5E0h case   19:*/		return 0x821BB5E4;
		  /* 821BB5E4h */ case   20:  		/* addi R5, R10, -36 */
		/* 821BB5E4h case   20:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R10,0xFFFFFFDC);
		/* 821BB5E4h case   20:*/		return 0x821BB5E8;
		  /* 821BB5E8h */ case   21:  		/* lwz R6, <#[R11]> */
		/* 821BB5E8h case   21:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 821BB5E8h case   21:*/		return 0x821BB5EC;
		  /* 821BB5ECh */ case   22:  		/* addi R8, R16, 4 */
		/* 821BB5ECh case   22:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R16,0x4);
		/* 821BB5ECh case   22:*/		return 0x821BB5F0;
		  /* 821BB5F0h */ case   23:  		/* stw R6, <#[R10 + 4]> */
		/* 821BB5F0h case   23:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 821BB5F0h case   23:*/		return 0x821BB5F4;
		  /* 821BB5F4h */ case   24:  		/* lwz R6, <#[R11]> */
		/* 821BB5F4h case   24:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000000) );
		/* 821BB5F4h case   24:*/		return 0x821BB5F8;
		  /* 821BB5F8h */ case   25:  		/* rlwinm R6, R6, 0, 0, 30 */
		/* 821BB5F8h case   25:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R6);
		/* 821BB5F8h case   25:*/		return 0x821BB5FC;
		  /* 821BB5FCh */ case   26:  		/* stw R9, <#[R6 + 36]> */
		/* 821BB5FCh case   26:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R6 + 0x00000024) );
		/* 821BB5FCh case   26:*/		return 0x821BB600;
		  /* 821BB600h */ case   27:  		/* stw R7, <#[R10]> */
		/* 821BB600h case   27:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821BB600h case   27:*/		return 0x821BB604;
		  /* 821BB604h */ case   28:  		/* stw R5, <#[R11]> */
		/* 821BB604h case   28:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R11 + 0x00000000) );
		/* 821BB604h case   28:*/		return 0x821BB608;
		  /* 821BB608h */ case   29:  		/* lwz R11, <#[R8]> */
		/* 821BB608h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 821BB608h case   29:*/		return 0x821BB60C;
		  /* 821BB60Ch */ case   30:  		/* cmplwi CR6, R11, 0 */
		/* 821BB60Ch case   30:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BB60Ch case   30:*/		return 0x821BB610;
		  /* 821BB610h */ case   31:  		/* bc 12, CR6_EQ, 92 */
		/* 821BB610h case   31:*/		if ( regs.CR[6].eq ) { return 0x821BB66C;  }
		/* 821BB610h case   31:*/		return 0x821BB614;
		  /* 821BB614h */ case   32:  		/* lwz R10, <#[R11 + 16]> */
		/* 821BB614h case   32:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 821BB614h case   32:*/		return 0x821BB618;
		  /* 821BB618h */ case   33:  		/* cmplwi CR6, R10, 0 */
		/* 821BB618h case   33:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821BB618h case   33:*/		return 0x821BB61C;
		  /* 821BB61Ch */ case   34:  		/* bc 12, CR6_EQ, 60 */
		/* 821BB61Ch case   34:*/		if ( regs.CR[6].eq ) { return 0x821BB658;  }
		/* 821BB61Ch case   34:*/		return 0x821BB620;
		  /* 821BB620h */ case   35:  		/* lwz R10, <#[R11 + 12]> */
		/* 821BB620h case   35:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 821BB620h case   35:*/		return 0x821BB624;
		  /* 821BB624h */ case   36:  		/* addi R10, R10, 4 */
		/* 821BB624h case   36:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821BB624h case   36:*/		return 0x821BB628;
		  /* 821BB628h */ case   37:  		/* lwz R9, <#[R10]> */
		/* 821BB628h case   37:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821BB628h case   37:*/		return 0x821BB62C;
		  /* 821BB62Ch */ case   38:  		/* b 12 */
		/* 821BB62Ch case   38:*/		return 0x821BB638;
		/* 821BB62Ch case   38:*/		return 0x821BB630;
		  /* 821BB630h */ case   39:  		/* addi R10, R9, 8 */
		/* 821BB630h case   39:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x8);
		/* 821BB630h case   39:*/		return 0x821BB634;
		  /* 821BB634h */ case   40:  		/* lwz R9, <#[R9 + 8]> */
		/* 821BB634h case   40:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 821BB634h case   40:*/		return 0x821BB638;
	}
	return 0x821BB638;
} // Block from 821BB594h-821BB638h (41 instructions)

//////////////////////////////////////////////////////
// Block at 821BB638h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB638( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB638) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB638);
		  /* 821BB638h */ case    0:  		/* cmplw CR6, R9, R11 */
		/* 821BB638h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 821BB638h case    0:*/		return 0x821BB63C;
		  /* 821BB63Ch */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 821BB63Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BB630;  }
		/* 821BB63Ch case    1:*/		return 0x821BB640;
		  /* 821BB640h */ case    2:  		/* lwz R9, <#[R11 + 8]> */
		/* 821BB640h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 821BB640h case    2:*/		return 0x821BB644;
		  /* 821BB644h */ case    3:  		/* stw R9, <#[R10]> */
		/* 821BB644h case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821BB644h case    3:*/		return 0x821BB648;
		  /* 821BB648h */ case    4:  		/* lwz R10, <#[R3 + 4]> */
		/* 821BB648h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 821BB648h case    4:*/		return 0x821BB64C;
		  /* 821BB64Ch */ case    5:  		/* stw R10, <#[R11 + 8]> */
		/* 821BB64Ch case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821BB64Ch case    5:*/		return 0x821BB650;
		  /* 821BB650h */ case    6:  		/* stw R11, <#[R3 + 4]> */
		/* 821BB650h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821BB650h case    6:*/		return 0x821BB654;
		  /* 821BB654h */ case    7:  		/* stw R3, <#[R11 + 12]> */
		/* 821BB654h case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x0000000C) );
		/* 821BB654h case    7:*/		return 0x821BB658;
	}
	return 0x821BB658;
} // Block from 821BB638h-821BB658h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821BB658h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB658( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB658) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB658);
		  /* 821BB658h */ case    0:  		/* lwz R10, <#[R8]> */
		/* 821BB658h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 821BB658h case    0:*/		return 0x821BB65C;
		  /* 821BB65Ch */ case    1:  		/* cmplw CR6, R10, R11 */
		/* 821BB65Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 821BB65Ch case    1:*/		return 0x821BB660;
		  /* 821BB660h */ case    2:  		/* bc 4, CR6_EQ, -88 */
		/* 821BB660h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821BB608;  }
		/* 821BB660h case    2:*/		return 0x821BB664;
		  /* 821BB664h */ case    3:  		/* addi R8, R11, 8 */
		/* 821BB664h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x8);
		/* 821BB664h case    3:*/		return 0x821BB668;
		  /* 821BB668h */ case    4:  		/* b -96 */
		/* 821BB668h case    4:*/		return 0x821BB608;
		/* 821BB668h case    4:*/		return 0x821BB66C;
	}
	return 0x821BB66C;
} // Block from 821BB658h-821BB66Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BB66Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB66C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB66C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB66C);
		  /* 821BB66Ch */ case    0:  		/* mr R3, R31 */
		/* 821BB66Ch case    0:*/		regs.R3 = regs.R31;
		/* 821BB66Ch case    0:*/		return 0x821BB670;
		  /* 821BB670h */ case    1:  		/* bl -152256 */
		/* 821BB670h case    1:*/		regs.LR = 0x821BB674; return 0x821963B0;
		/* 821BB670h case    1:*/		return 0x821BB674;
		  /* 821BB674h */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 821BB674h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821BB674h case    2:*/		return 0x821BB678;
		  /* 821BB678h */ case    3:  		/* li R6, 1 */
		/* 821BB678h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821BB678h case    3:*/		return 0x821BB67C;
		  /* 821BB67Ch */ case    4:  		/* oris R11, R11, 256 */
		/* 821BB67Ch case    4:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x100);
		/* 821BB67Ch case    4:*/		return 0x821BB680;
		  /* 821BB680h */ case    5:  		/* li R5, 0 */
		/* 821BB680h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821BB680h case    5:*/		return 0x821BB684;
		  /* 821BB684h */ case    6:  		/* stw R11, <#[R31 + 8]> */
		/* 821BB684h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821BB684h case    6:*/		return 0x821BB688;
		  /* 821BB688h */ case    7:  		/* mr R4, R16 */
		/* 821BB688h case    7:*/		regs.R4 = regs.R16;
		/* 821BB688h case    7:*/		return 0x821BB68C;
		  /* 821BB68Ch */ case    8:  		/* mr R3, R15 */
		/* 821BB68Ch case    8:*/		regs.R3 = regs.R15;
		/* 821BB68Ch case    8:*/		return 0x821BB690;
		  /* 821BB690h */ case    9:  		/* bl 458040 */
		/* 821BB690h case    9:*/		regs.LR = 0x821BB694; return 0x8222B3C8;
		/* 821BB690h case    9:*/		return 0x821BB694;
		  /* 821BB694h */ case   10:  		/* b -7520 */
		/* 821BB694h case   10:*/		return 0x821B9934;
		/* 821BB694h case   10:*/		return 0x821BB698;
	}
	return 0x821BB698;
} // Block from 821BB66Ch-821BB698h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821BB698h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB698( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB698) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB698);
		  /* 821BB698h */ case    0:  		/* lwz R11, <#[R16 + 8]> */
		/* 821BB698h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R16 + 0x00000008) );
		/* 821BB698h case    0:*/		return 0x821BB69C;
		  /* 821BB69Ch */ case    1:  		/* rlwinm R11, R11, 0, 7, 5 */
		/* 821BB69Ch case    1:*/		cpu::op::rlwinm<0,0,7,5>(regs,&regs.R11,regs.R11);
		/* 821BB69Ch case    1:*/		return 0x821BB6A0;
		  /* 821BB6A0h */ case    2:  		/* stw R11, <#[R16 + 8]> */
		/* 821BB6A0h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R16 + 0x00000008) );
		/* 821BB6A0h case    2:*/		return 0x821BB6A4;
	}
	return 0x821BB6A4;
} // Block from 821BB698h-821BB6A4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BB6A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB6A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB6A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB6A4);
		  /* 821BB6A4h */ case    0:  		/* mr R3, R15 */
		/* 821BB6A4h case    0:*/		regs.R3 = regs.R15;
		/* 821BB6A4h case    0:*/		return 0x821BB6A8;
		  /* 821BB6A8h */ case    1:  		/* mr R4, R16 */
		/* 821BB6A8h case    1:*/		regs.R4 = regs.R16;
		/* 821BB6A8h case    1:*/		return 0x821BB6AC;
		  /* 821BB6ACh */ case    2:  		/* bl 458660 */
		/* 821BB6ACh case    2:*/		regs.LR = 0x821BB6B0; return 0x8222B650;
		/* 821BB6ACh case    2:*/		return 0x821BB6B0;
		  /* 821BB6B0h */ case    3:  		/* b -7548 */
		/* 821BB6B0h case    3:*/		return 0x821B9934;
		/* 821BB6B0h case    3:*/		return 0x821BB6B4;
	}
	return 0x821BB6B4;
} // Block from 821BB6A4h-821BB6B4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BB6B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB6B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB6B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB6B4);
		  /* 821BB6B4h */ case    0:  		/* mr R8, R14 */
		/* 821BB6B4h case    0:*/		regs.R8 = regs.R14;
		/* 821BB6B4h case    0:*/		return 0x821BB6B8;
		  /* 821BB6B8h */ case    1:  		/* lwz R11, <#[R8]> */
		/* 821BB6B8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 821BB6B8h case    1:*/		return 0x821BB6BC;
		  /* 821BB6BCh */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 821BB6BCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BB6BCh case    2:*/		return 0x821BB6C0;
		  /* 821BB6C0h */ case    3:  		/* bc 12, CR6_EQ, -28 */
		/* 821BB6C0h case    3:*/		if ( regs.CR[6].eq ) { return 0x821BB6A4;  }
		/* 821BB6C0h case    3:*/		return 0x821BB6C4;
		  /* 821BB6C4h */ case    4:  		/* lwz R10, <#[R11 + 16]> */
		/* 821BB6C4h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 821BB6C4h case    4:*/		return 0x821BB6C8;
		  /* 821BB6C8h */ case    5:  		/* cmplwi CR6, R10, 0 */
		/* 821BB6C8h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821BB6C8h case    5:*/		return 0x821BB6CC;
		  /* 821BB6CCh */ case    6:  		/* bc 12, CR6_EQ, 76 */
		/* 821BB6CCh case    6:*/		if ( regs.CR[6].eq ) { return 0x821BB718;  }
		/* 821BB6CCh case    6:*/		return 0x821BB6D0;
		  /* 821BB6D0h */ case    7:  		/* lwz R10, <#[R11 + 12]> */
		/* 821BB6D0h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 821BB6D0h case    7:*/		return 0x821BB6D4;
		  /* 821BB6D4h */ case    8:  		/* addi R10, R10, 4 */
		/* 821BB6D4h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821BB6D4h case    8:*/		return 0x821BB6D8;
		  /* 821BB6D8h */ case    9:  		/* lwz R9, <#[R10]> */
		/* 821BB6D8h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821BB6D8h case    9:*/		return 0x821BB6DC;
		  /* 821BB6DCh */ case   10:  		/* b 12 */
		/* 821BB6DCh case   10:*/		return 0x821BB6E8;
		/* 821BB6DCh case   10:*/		return 0x821BB6E0;
		  /* 821BB6E0h */ case   11:  		/* addi R10, R9, 8 */
		/* 821BB6E0h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x8);
		/* 821BB6E0h case   11:*/		return 0x821BB6E4;
		  /* 821BB6E4h */ case   12:  		/* lwz R9, <#[R9 + 8]> */
		/* 821BB6E4h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 821BB6E4h case   12:*/		return 0x821BB6E8;
	}
	return 0x821BB6E8;
} // Block from 821BB6B4h-821BB6E8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821BB6E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB6E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB6E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB6E8);
		  /* 821BB6E8h */ case    0:  		/* cmplw CR6, R9, R11 */
		/* 821BB6E8h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 821BB6E8h case    0:*/		return 0x821BB6EC;
		  /* 821BB6ECh */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 821BB6ECh case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BB6E0;  }
		/* 821BB6ECh case    1:*/		return 0x821BB6F0;
		  /* 821BB6F0h */ case    2:  		/* lwz R9, <#[R11 + 8]> */
		/* 821BB6F0h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 821BB6F0h case    2:*/		return 0x821BB6F4;
		  /* 821BB6F4h */ case    3:  		/* stw R9, <#[R10]> */
		/* 821BB6F4h case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821BB6F4h case    3:*/		return 0x821BB6F8;
		  /* 821BB6F8h */ case    4:  		/* lwz R10, <#[R3 + 4]> */
		/* 821BB6F8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000004) );
		/* 821BB6F8h case    4:*/		return 0x821BB6FC;
		  /* 821BB6FCh */ case    5:  		/* stw R10, <#[R11 + 8]> */
		/* 821BB6FCh case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821BB6FCh case    5:*/		return 0x821BB700;
		  /* 821BB700h */ case    6:  		/* stw R11, <#[R3 + 4]> */
		/* 821BB700h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821BB700h case    6:*/		return 0x821BB704;
		  /* 821BB704h */ case    7:  		/* stw R3, <#[R11 + 12]> */
		/* 821BB704h case    7:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R11 + 0x0000000C) );
		/* 821BB704h case    7:*/		return 0x821BB708;
		  /* 821BB708h */ case    8:  		/* lwz R10, <#[R11]> */
		/* 821BB708h case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821BB708h case    8:*/		return 0x821BB70C;
		  /* 821BB70Ch */ case    9:  		/* rlwimi R10, R7, 0, 27, 31 */
		/* 821BB70Ch case    9:*/		cpu::op::rlwimi<0,0,27,31>(regs,&regs.R10,regs.R7);
		/* 821BB70Ch case    9:*/		return 0x821BB710;
		  /* 821BB710h */ case   10:  		/* rlwimi R10, R20, 7, 19, 26 */
		/* 821BB710h case   10:*/		cpu::op::rlwimi<0,7,19,26>(regs,&regs.R10,regs.R20);
		/* 821BB710h case   10:*/		return 0x821BB714;
		  /* 821BB714h */ case   11:  		/* stw R10, <#[R11]> */
		/* 821BB714h case   11:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821BB714h case   11:*/		return 0x821BB718;
	}
	return 0x821BB718;
} // Block from 821BB6E8h-821BB718h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821BB718h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB718( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB718) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB718);
		  /* 821BB718h */ case    0:  		/* lwz R10, <#[R8]> */
		/* 821BB718h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 821BB718h case    0:*/		return 0x821BB71C;
		  /* 821BB71Ch */ case    1:  		/* cmplw CR6, R10, R11 */
		/* 821BB71Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 821BB71Ch case    1:*/		return 0x821BB720;
		  /* 821BB720h */ case    2:  		/* bc 4, CR6_EQ, -104 */
		/* 821BB720h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821BB6B8;  }
		/* 821BB720h case    2:*/		return 0x821BB724;
		  /* 821BB724h */ case    3:  		/* addi R8, R11, 8 */
		/* 821BB724h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x8);
		/* 821BB724h case    3:*/		return 0x821BB728;
		  /* 821BB728h */ case    4:  		/* b -112 */
		/* 821BB728h case    4:*/		return 0x821BB6B8;
		/* 821BB728h case    4:*/		return 0x821BB72C;
	}
	return 0x821BB72C;
} // Block from 821BB718h-821BB72Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BB72Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB72C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB72C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB72C);
		  /* 821BB72Ch */ case    0:  		/* lis R11, -32252 */
		/* 821BB72Ch case    0:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8204);
		/* 821BB72Ch case    0:*/		return 0x821BB730;
		  /* 821BB730h */ case    1:  		/* li R4, 3500 */
		/* 821BB730h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0xDAC);
		/* 821BB730h case    1:*/		return 0x821BB734;
		  /* 821BB734h */ case    2:  		/* addi R5, R11, -16532 */
		/* 821BB734h case    2:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R11,0xFFFFBF6C);
		/* 821BB734h case    2:*/		return 0x821BB738;
		  /* 821BB738h */ case    3:  		/* mr R3, R15 */
		/* 821BB738h case    3:*/		regs.R3 = regs.R15;
		/* 821BB738h case    3:*/		return 0x821BB73C;
		  /* 821BB73Ch */ case    4:  		/* bl -432340 */
		/* 821BB73Ch case    4:*/		regs.LR = 0x821BB740; return 0x82151E68;
		/* 821BB73Ch case    4:*/		return 0x821BB740;
	}
	return 0x821BB740;
} // Block from 821BB72Ch-821BB740h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BB740h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB740( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB740) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB740);
		  /* 821BB740h */ case    0:  		/* li R4, 4800 */
		/* 821BB740h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 821BB740h case    0:*/		return 0x821BB744;
		  /* 821BB744h */ case    1:  		/* mr R3, R15 */
		/* 821BB744h case    1:*/		regs.R3 = regs.R15;
		/* 821BB744h case    1:*/		return 0x821BB748;
		  /* 821BB748h */ case    2:  		/* bl -432352 */
		/* 821BB748h case    2:*/		regs.LR = 0x821BB74C; return 0x82151E68;
		/* 821BB748h case    2:*/		return 0x821BB74C;
	}
	return 0x821BB74C;
} // Block from 821BB740h-821BB74Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BB74Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB74C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB74C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB74C);
		  /* 821BB74Ch */ case    0:  		/* addi R1, R1, 288 */
		/* 821BB74Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x120);
		/* 821BB74Ch case    0:*/		return 0x821BB750;
		  /* 821BB750h */ case    1:  		/* lfd FR31, <#[R1 - 160]> */
		/* 821BB750h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFF60) );
		/* 821BB750h case    1:*/		return 0x821BB754;
		  /* 821BB754h */ case    2:  		/* b -1221860 */
		/* 821BB754h case    2:*/		return 0x82091270;
		/* 821BB754h case    2:*/		return 0x821BB758;
	}
	return 0x821BB758;
} // Block from 821BB74Ch-821BB758h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BB758h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB758( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB758) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB758);
		  /* 821BB758h */ case    0:  		/* mfspr R12, LR */
		/* 821BB758h case    0:*/		regs.R12 = regs.LR;
		/* 821BB758h case    0:*/		return 0x821BB75C;
		  /* 821BB75Ch */ case    1:  		/* bl -1221920 */
		/* 821BB75Ch case    1:*/		regs.LR = 0x821BB760; return 0x8209123C;
		/* 821BB75Ch case    1:*/		return 0x821BB760;
		  /* 821BB760h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 821BB760h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 821BB760h case    2:*/		return 0x821BB764;
		  /* 821BB764h */ case    3:  		/* lwz R11, <#[R3 + 48]> */
		/* 821BB764h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000030) );
		/* 821BB764h case    3:*/		return 0x821BB768;
		  /* 821BB768h */ case    4:  		/* lis R22, -1 */
		/* 821BB768h case    4:*/		cpu::op::lis<0>(regs,&regs.R22,0xFFFFFFFF);
		/* 821BB768h case    4:*/		return 0x821BB76C;
		  /* 821BB76Ch */ case    5:  		/* mr R21, R3 */
		/* 821BB76Ch case    5:*/		regs.R21 = regs.R3;
		/* 821BB76Ch case    5:*/		return 0x821BB770;
		  /* 821BB770h */ case    6:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 821BB770h case    6:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 821BB770h case    6:*/		return 0x821BB774;
		  /* 821BB774h */ case    7:  		/* cmplw CR6, R11, R22 */
		/* 821BB774h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R22);
		/* 821BB774h case    7:*/		return 0x821BB778;
		  /* 821BB778h */ case    8:  		/* bc 12, CR6_EQ, 800 */
		/* 821BB778h case    8:*/		if ( regs.CR[6].eq ) { return 0x821BBA98;  }
		/* 821BB778h case    8:*/		return 0x821BB77C;
		  /* 821BB77Ch */ case    9:  		/* lwz R11, <#[R3 + 4]> */
		/* 821BB77Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821BB77Ch case    9:*/		return 0x821BB780;
		  /* 821BB780h */ case   10:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BB780h case   10:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BB780h case   10:*/		return 0x821BB784;
		  /* 821BB784h */ case   11:  		/* bc 4, CR0_EQ, 788 */
		/* 821BB784h case   11:*/		if ( !regs.CR[0].eq ) { return 0x821BBA98;  }
		/* 821BB784h case   11:*/		return 0x821BB788;
		  /* 821BB788h */ case   12:  		/* mr R27, R11 */
		/* 821BB788h case   12:*/		regs.R27 = regs.R11;
		/* 821BB788h case   12:*/		return 0x821BB78C;
		  /* 821BB78Ch */ case   13:  		/* cmplwi CR0, R11, 0 */
		/* 821BB78Ch case   13:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821BB78Ch case   13:*/		return 0x821BB790;
		  /* 821BB790h */ case   14:  		/* bc 12, CR0_EQ, 776 */
		/* 821BB790h case   14:*/		if ( regs.CR[0].eq ) { return 0x821BBA98;  }
		/* 821BB790h case   14:*/		return 0x821BB794;
		  /* 821BB794h */ case   15:  		/* lis R26, 124 */
		/* 821BB794h case   15:*/		cpu::op::lis<0>(regs,&regs.R26,0x7C);
		/* 821BB794h case   15:*/		return 0x821BB798;
		  /* 821BB798h */ case   16:  		/* lwz R11, <#[R27 + 36]> */
		/* 821BB798h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000024) );
		/* 821BB798h case   16:*/		return 0x821BB79C;
		  /* 821BB79Ch */ case   17:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BB79Ch case   17:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BB79Ch case   17:*/		return 0x821BB7A0;
		  /* 821BB7A0h */ case   18:  		/* bc 4, CR0_EQ, 732 */
		/* 821BB7A0h case   18:*/		if ( !regs.CR[0].eq ) { return 0x821BBA7C;  }
		/* 821BB7A0h case   18:*/		return 0x821BB7A4;
		  /* 821BB7A4h */ case   19:  		/* mr R28, R11 */
		/* 821BB7A4h case   19:*/		regs.R28 = regs.R11;
		/* 821BB7A4h case   19:*/		return 0x821BB7A8;
		  /* 821BB7A8h */ case   20:  		/* cmplwi CR0, R11, 0 */
		/* 821BB7A8h case   20:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821BB7A8h case   20:*/		return 0x821BB7AC;
		  /* 821BB7ACh */ case   21:  		/* bc 12, CR0_EQ, 720 */
		/* 821BB7ACh case   21:*/		if ( regs.CR[0].eq ) { return 0x821BBA7C;  }
		/* 821BB7ACh case   21:*/		return 0x821BB7B0;
		  /* 821BB7B0h */ case   22:  		/* lwz R11, <#[R28 + 8]> */
		/* 821BB7B0h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 821BB7B0h case   22:*/		return 0x821BB7B4;
		  /* 821BB7B4h */ case   23:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821BB7B4h case   23:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821BB7B4h case   23:*/		return 0x821BB7B8;
		  /* 821BB7B8h */ case   24:  		/* cmplwi CR6, R11, 10624 */
		/* 821BB7B8h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00002980);
		/* 821BB7B8h case   24:*/		return 0x821BB7BC;
		  /* 821BB7BCh */ case   25:  		/* bc 4, CR6_EQ, 676 */
		/* 821BB7BCh case   25:*/		if ( !regs.CR[6].eq ) { return 0x821BBA60;  }
		/* 821BB7BCh case   25:*/		return 0x821BB7C0;
		  /* 821BB7C0h */ case   26:  		/* lwz R10, <#[R28]> */
		/* 821BB7C0h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000000) );
		/* 821BB7C0h case   26:*/		return 0x821BB7C4;
		  /* 821BB7C4h */ case   27:  		/* mr R11, R10 */
		/* 821BB7C4h case   27:*/		regs.R11 = regs.R10;
		/* 821BB7C4h case   27:*/		return 0x821BB7C8;
		  /* 821BB7C8h */ case   28:  		/* cmplwi CR6, R11, 0 */
		/* 821BB7C8h case   28:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BB7C8h case   28:*/		return 0x821BB7CC;
		  /* 821BB7CCh */ case   29:  		/* bc 12, CR6_EQ, 120 */
		/* 821BB7CCh case   29:*/		if ( regs.CR[6].eq ) { return 0x821BB844;  }
		/* 821BB7CCh case   29:*/		return 0x821BB7D0;
		  /* 821BB7D0h */ case   30:  		/* lwz R9, <#[R11]> */
		/* 821BB7D0h case   30:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821BB7D0h case   30:*/		return 0x821BB7D4;
		  /* 821BB7D4h */ case   31:  		/* rlwinm. R9, R9, 0, 4, 6 */
		/* 821BB7D4h case   31:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R9,regs.R9);
		/* 821BB7D4h case   31:*/		return 0x821BB7D8;
		  /* 821BB7D8h */ case   32:  		/* bc 12, CR0_EQ, 20 */
		/* 821BB7D8h case   32:*/		if ( regs.CR[0].eq ) { return 0x821BB7EC;  }
		/* 821BB7D8h case   32:*/		return 0x821BB7DC;
		  /* 821BB7DCh */ case   33:  		/* lwz R9, <#[R11 + 12]> */
		/* 821BB7DCh case   33:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 821BB7DCh case   33:*/		return 0x821BB7E0;
		  /* 821BB7E0h */ case   34:  		/* lwz R9, <#[R9 + 8]> */
		/* 821BB7E0h case   34:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 821BB7E0h case   34:*/		return 0x821BB7E4;
		  /* 821BB7E4h */ case   35:  		/* rlwinm. R9, R9, 27, 31, 31 */
		/* 821BB7E4h case   35:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R9,regs.R9);
		/* 821BB7E4h case   35:*/		return 0x821BB7E8;
		  /* 821BB7E8h */ case   36:  		/* bc 4, CR0_EQ, 12 */
		/* 821BB7E8h case   36:*/		if ( !regs.CR[0].eq ) { return 0x821BB7F4;  }
		/* 821BB7E8h case   36:*/		return 0x821BB7EC;
	}
	return 0x821BB7EC;
} // Block from 821BB758h-821BB7ECh (37 instructions)

//////////////////////////////////////////////////////
// Block at 821BB7ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB7EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB7EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB7EC);
		  /* 821BB7ECh */ case    0:  		/* lwz R11, <#[R11 + 4]> */
		/* 821BB7ECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821BB7ECh case    0:*/		return 0x821BB7F0;
		  /* 821BB7F0h */ case    1:  		/* b -40 */
		/* 821BB7F0h case    1:*/		return 0x821BB7C8;
		/* 821BB7F0h case    1:*/		return 0x821BB7F4;
	}
	return 0x821BB7F4;
} // Block from 821BB7ECh-821BB7F4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BB7F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB7F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB7F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB7F4);
		  /* 821BB7F4h */ case    0:  		/* li R6, 0 */
		/* 821BB7F4h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821BB7F4h case    0:*/		return 0x821BB7F8;
		  /* 821BB7F8h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 821BB7F8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821BB7F8h case    1:*/		return 0x821BB7FC;
		  /* 821BB7FCh */ case    2:  		/* bc 12, CR6_EQ, 60 */
		/* 821BB7FCh case    2:*/		if ( regs.CR[6].eq ) { return 0x821BB838;  }
		/* 821BB7FCh case    2:*/		return 0x821BB800;
		  /* 821BB800h */ case    3:  		/* lwz R11, <#[R10]> */
		/* 821BB800h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 821BB800h case    3:*/		return 0x821BB804;
		  /* 821BB804h */ case    4:  		/* rlwinm. R9, R11, 0, 4, 6 */
		/* 821BB804h case    4:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R9,regs.R11);
		/* 821BB804h case    4:*/		return 0x821BB808;
		  /* 821BB808h */ case    5:  		/* bc 12, CR0_EQ, 40 */
		/* 821BB808h case    5:*/		if ( regs.CR[0].eq ) { return 0x821BB830;  }
		/* 821BB808h case    5:*/		return 0x821BB80C;
		  /* 821BB80Ch */ case    6:  		/* lwz R9, <#[R10 + 12]> */
		/* 821BB80Ch case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x0000000C) );
		/* 821BB80Ch case    6:*/		return 0x821BB810;
		  /* 821BB810h */ case    7:  		/* lwz R9, <#[R9 + 8]> */
		/* 821BB810h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 821BB810h case    7:*/		return 0x821BB814;
		  /* 821BB814h */ case    8:  		/* rlwinm. R9, R9, 27, 31, 31 */
		/* 821BB814h case    8:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R9,regs.R9);
		/* 821BB814h case    8:*/		return 0x821BB818;
		  /* 821BB818h */ case    9:  		/* bc 12, CR0_EQ, 24 */
		/* 821BB818h case    9:*/		if ( regs.CR[0].eq ) { return 0x821BB830;  }
		/* 821BB818h case    9:*/		return 0x821BB81C;
		  /* 821BB81Ch */ case   10:  		/* rlwinm R9, R11, 0, 7, 14 */
		/* 821BB81Ch case   10:*/		cpu::op::rlwinm<0,0,7,14>(regs,&regs.R9,regs.R11);
		/* 821BB81Ch case   10:*/		return 0x821BB820;
		  /* 821BB820h */ case   11:  		/* cmplw CR6, R9, R26 */
		/* 821BB820h case   11:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R26);
		/* 821BB820h case   11:*/		return 0x821BB824;
		  /* 821BB824h */ case   12:  		/* bc 4, CR6_EQ, 12 */
		/* 821BB824h case   12:*/		if ( !regs.CR[6].eq ) { return 0x821BB830;  }
		/* 821BB824h case   12:*/		return 0x821BB828;
		  /* 821BB828h */ case   13:  		/* rlwinm R11, R11, 19, 28, 31 */
		/* 821BB828h case   13:*/		cpu::op::rlwinm<0,19,28,31>(regs,&regs.R11,regs.R11);
		/* 821BB828h case   13:*/		return 0x821BB82C;
		  /* 821BB82Ch */ case   14:  		/* or R6, R11, R6 */
		/* 821BB82Ch case   14:*/		cpu::op::or<0>(regs,&regs.R6,regs.R11,regs.R6);
		/* 821BB82Ch case   14:*/		return 0x821BB830;
	}
	return 0x821BB830;
} // Block from 821BB7F4h-821BB830h (15 instructions)

//////////////////////////////////////////////////////
// Block at 821BB830h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB830( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB830) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB830);
		  /* 821BB830h */ case    0:  		/* lwz R10, <#[R10 + 4]> */
		/* 821BB830h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000004) );
		/* 821BB830h case    0:*/		return 0x821BB834;
		  /* 821BB834h */ case    1:  		/* b -60 */
		/* 821BB834h case    1:*/		return 0x821BB7F8;
		/* 821BB834h case    1:*/		return 0x821BB838;
	}
	return 0x821BB838;
} // Block from 821BB830h-821BB838h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BB838h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB838( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB838) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB838);
		  /* 821BB838h */ case    0:  		/* cmplwi CR6, R6, 15 */
		/* 821BB838h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x0000000F);
		/* 821BB838h case    0:*/		return 0x821BB83C;
		  /* 821BB83Ch */ case    1:  		/* bc 12, CR6_EQ, 548 */
		/* 821BB83Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x821BBA60;  }
		/* 821BB83Ch case    1:*/		return 0x821BB840;
		  /* 821BB840h */ case    2:  		/* b 528 */
		/* 821BB840h case    2:*/		return 0x821BBA50;
		/* 821BB840h case    2:*/		return 0x821BB844;
	}
	return 0x821BB844;
} // Block from 821BB838h-821BB844h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BB844h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB844( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB844) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB844);
		  /* 821BB844h */ case    0:  		/* lwz R11, <#[R27 + 8]> */
		/* 821BB844h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 821BB844h case    0:*/		return 0x821BB848;
		  /* 821BB848h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 821BB848h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BB848h case    1:*/		return 0x821BB84C;
		  /* 821BB84Ch */ case    2:  		/* bc 12, CR6_EQ, 512 */
		/* 821BB84Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x821BBA4C;  }
		/* 821BB84Ch case    2:*/		return 0x821BB850;
		  /* 821BB850h */ case    3:  		/* lwz R11, <#[R11 + 4]> */
		/* 821BB850h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821BB850h case    3:*/		return 0x821BB854;
		  /* 821BB854h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 821BB854h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BB854h case    4:*/		return 0x821BB858;
		  /* 821BB858h */ case    5:  		/* bc 12, CR6_EQ, 500 */
		/* 821BB858h case    5:*/		if ( regs.CR[6].eq ) { return 0x821BBA4C;  }
		/* 821BB858h case    5:*/		return 0x821BB85C;
		  /* 821BB85Ch */ case    6:  		/* lwz R11, <#[R21 + 4]> */
		/* 821BB85Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000004) );
		/* 821BB85Ch case    6:*/		return 0x821BB860;
		  /* 821BB860h */ case    7:  		/* li R29, 0 */
		/* 821BB860h case    7:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 821BB860h case    7:*/		return 0x821BB864;
		  /* 821BB864h */ case    8:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BB864h case    8:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BB864h case    8:*/		return 0x821BB868;
		  /* 821BB868h */ case    9:  		/* bc 4, CR0_EQ, 476 */
		/* 821BB868h case    9:*/		if ( !regs.CR[0].eq ) { return 0x821BBA44;  }
		/* 821BB868h case    9:*/		return 0x821BB86C;
		  /* 821BB86Ch */ case   10:  		/* mr R30, R11 */
		/* 821BB86Ch case   10:*/		regs.R30 = regs.R11;
		/* 821BB86Ch case   10:*/		return 0x821BB870;
		  /* 821BB870h */ case   11:  		/* cmplwi CR0, R11, 0 */
		/* 821BB870h case   11:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821BB870h case   11:*/		return 0x821BB874;
		  /* 821BB874h */ case   12:  		/* bc 12, CR0_EQ, 464 */
		/* 821BB874h case   12:*/		if ( regs.CR[0].eq ) { return 0x821BBA44;  }
		/* 821BB874h case   12:*/		return 0x821BB878;
		  /* 821BB878h */ case   13:  		/* lwz R11, <#[R30 + 12]> */
		/* 821BB878h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 821BB878h case   13:*/		return 0x821BB87C;
		  /* 821BB87Ch */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 821BB87Ch case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BB87Ch case   14:*/		return 0x821BB880;
		  /* 821BB880h */ case   15:  		/* bc 12, CR6_EQ, 424 */
		/* 821BB880h case   15:*/		if ( regs.CR[6].eq ) { return 0x821BBA28;  }
		/* 821BB880h case   15:*/		return 0x821BB884;
		  /* 821BB884h */ case   16:  		/* lwz R11, <#[R11]> */
		/* 821BB884h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821BB884h case   16:*/		return 0x821BB888;
		  /* 821BB888h */ case   17:  		/* cmplwi CR6, R11, 0 */
		/* 821BB888h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BB888h case   17:*/		return 0x821BB88C;
		  /* 821BB88Ch */ case   18:  		/* bc 12, CR6_EQ, 412 */
		/* 821BB88Ch case   18:*/		if ( regs.CR[6].eq ) { return 0x821BBA28;  }
		/* 821BB88Ch case   18:*/		return 0x821BB890;
		  /* 821BB890h */ case   19:  		/* lwz R11, <#[R30 + 28]> */
		/* 821BB890h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 821BB890h case   19:*/		return 0x821BB894;
		  /* 821BB894h */ case   20:  		/* li R31, 0 */
		/* 821BB894h case   20:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 821BB894h case   20:*/		return 0x821BB898;
		  /* 821BB898h */ case   21:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BB898h case   21:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BB898h case   21:*/		return 0x821BB89C;
		  /* 821BB89Ch */ case   22:  		/* bc 4, CR0_EQ, 396 */
		/* 821BB89Ch case   22:*/		if ( !regs.CR[0].eq ) { return 0x821BBA28;  }
		/* 821BB89Ch case   22:*/		return 0x821BB8A0;
		  /* 821BB8A0h */ case   23:  		/* mr R9, R11 */
		/* 821BB8A0h case   23:*/		regs.R9 = regs.R11;
		/* 821BB8A0h case   23:*/		return 0x821BB8A4;
		  /* 821BB8A4h */ case   24:  		/* cmplwi CR0, R11, 0 */
		/* 821BB8A4h case   24:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821BB8A4h case   24:*/		return 0x821BB8A8;
		  /* 821BB8A8h */ case   25:  		/* bc 12, CR0_EQ, 384 */
		/* 821BB8A8h case   25:*/		if ( regs.CR[0].eq ) { return 0x821BBA28;  }
		/* 821BB8A8h case   25:*/		return 0x821BB8AC;
		  /* 821BB8ACh */ case   26:  		/* lwz R11, <#[R9 + 8]> */
		/* 821BB8ACh case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000008) );
		/* 821BB8ACh case   26:*/		return 0x821BB8B0;
		  /* 821BB8B0h */ case   27:  		/* rlwinm. R11, R11, 27, 31, 31 */
		/* 821BB8B0h case   27:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R11,regs.R11);
		/* 821BB8B0h case   27:*/		return 0x821BB8B4;
		  /* 821BB8B4h */ case   28:  		/* bc 12, CR0_EQ, 68 */
		/* 821BB8B4h case   28:*/		if ( regs.CR[0].eq ) { return 0x821BB8F8;  }
		/* 821BB8B4h case   28:*/		return 0x821BB8B8;
		  /* 821BB8B8h */ case   29:  		/* lwz R11, <#[R9 + 4]> */
		/* 821BB8B8h case   29:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 821BB8B8h case   29:*/		return 0x821BB8BC;
		  /* 821BB8BCh */ case   30:  		/* cmplwi CR6, R11, 0 */
		/* 821BB8BCh case   30:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BB8BCh case   30:*/		return 0x821BB8C0;
		  /* 821BB8C0h */ case   31:  		/* bc 12, CR6_EQ, 612 */
		/* 821BB8C0h case   31:*/		if ( regs.CR[6].eq ) { return 0x821BBB24;  }
		/* 821BB8C0h case   31:*/		return 0x821BB8C4;
		  /* 821BB8C4h */ case   32:  		/* lwz R10, <#[R11 + 16]> */
		/* 821BB8C4h case   32:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 821BB8C4h case   32:*/		return 0x821BB8C8;
		  /* 821BB8C8h */ case   33:  		/* cmplwi CR6, R10, 0 */
		/* 821BB8C8h case   33:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821BB8C8h case   33:*/		return 0x821BB8CC;
		  /* 821BB8CCh */ case   34:  		/* bc 12, CR6_EQ, 16 */
		/* 821BB8CCh case   34:*/		if ( regs.CR[6].eq ) { return 0x821BB8DC;  }
		/* 821BB8CCh case   34:*/		return 0x821BB8D0;
		  /* 821BB8D0h */ case   35:  		/* lwz R10, <#[R11]> */
		/* 821BB8D0h case   35:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821BB8D0h case   35:*/		return 0x821BB8D4;
		  /* 821BB8D4h */ case   36:  		/* rlwinm. R8, R10, 0, 4, 6 */
		/* 821BB8D4h case   36:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R8,regs.R10);
		/* 821BB8D4h case   36:*/		return 0x821BB8D8;
		  /* 821BB8D8h */ case   37:  		/* bc 4, CR0_EQ, 12 */
		/* 821BB8D8h case   37:*/		if ( !regs.CR[0].eq ) { return 0x821BB8E4;  }
		/* 821BB8D8h case   37:*/		return 0x821BB8DC;
	}
	return 0x821BB8DC;
} // Block from 821BB844h-821BB8DCh (38 instructions)

//////////////////////////////////////////////////////
// Block at 821BB8DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB8DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB8DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB8DC);
		  /* 821BB8DCh */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 821BB8DCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821BB8DCh case    0:*/		return 0x821BB8E0;
		  /* 821BB8E0h */ case    1:  		/* b -36 */
		/* 821BB8E0h case    1:*/		return 0x821BB8BC;
		/* 821BB8E0h case    1:*/		return 0x821BB8E4;
	}
	return 0x821BB8E4;
} // Block from 821BB8DCh-821BB8E4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BB8E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB8E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB8E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB8E4);
		  /* 821BB8E4h */ case    0:  		/* rlwinm R11, R10, 0, 7, 14 */
		/* 821BB8E4h case    0:*/		cpu::op::rlwinm<0,0,7,14>(regs,&regs.R11,regs.R10);
		/* 821BB8E4h case    0:*/		return 0x821BB8E8;
		  /* 821BB8E8h */ case    1:  		/* cmplw CR6, R11, R26 */
		/* 821BB8E8h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 821BB8E8h case    1:*/		return 0x821BB8EC;
		  /* 821BB8ECh */ case    2:  		/* bc 4, CR6_EQ, 12 */
		/* 821BB8ECh case    2:*/		if ( !regs.CR[6].eq ) { return 0x821BB8F8;  }
		/* 821BB8ECh case    2:*/		return 0x821BB8F0;
		  /* 821BB8F0h */ case    3:  		/* rlwinm R11, R10, 19, 28, 31 */
		/* 821BB8F0h case    3:*/		cpu::op::rlwinm<0,19,28,31>(regs,&regs.R11,regs.R10);
		/* 821BB8F0h case    3:*/		return 0x821BB8F4;
		  /* 821BB8F4h */ case    4:  		/* or R31, R11, R31 */
		/* 821BB8F4h case    4:*/		cpu::op::or<0>(regs,&regs.R31,regs.R11,regs.R31);
		/* 821BB8F4h case    4:*/		return 0x821BB8F8;
	}
	return 0x821BB8F8;
} // Block from 821BB8E4h-821BB8F8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BB8F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB8F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB8F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB8F8);
		  /* 821BB8F8h */ case    0:  		/* rlwinm R11, R9, 0, 0, 30 */
		/* 821BB8F8h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R9);
		/* 821BB8F8h case    0:*/		return 0x821BB8FC;
		  /* 821BB8FCh */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 821BB8FCh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 821BB8FCh case    1:*/		return 0x821BB900;
		  /* 821BB900h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BB900h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BB900h case    2:*/		return 0x821BB904;
		  /* 821BB904h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 821BB904h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BB914;  }
		/* 821BB904h case    3:*/		return 0x821BB908;
		  /* 821BB908h */ case    4:  		/* mr R9, R11 */
		/* 821BB908h case    4:*/		regs.R9 = regs.R11;
		/* 821BB908h case    4:*/		return 0x821BB90C;
		  /* 821BB90Ch */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821BB90Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BB90Ch case    5:*/		return 0x821BB910;
		  /* 821BB910h */ case    6:  		/* bc 4, CR6_EQ, -100 */
		/* 821BB910h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821BB8AC;  }
		/* 821BB910h case    6:*/		return 0x821BB914;
	}
	return 0x821BB914;
} // Block from 821BB8F8h-821BB914h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BB914h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB914( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB914) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB914);
		  /* 821BB914h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 821BB914h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821BB914h case    0:*/		return 0x821BB918;
		  /* 821BB918h */ case    1:  		/* bc 12, CR6_EQ, 272 */
		/* 821BB918h case    1:*/		if ( regs.CR[6].eq ) { return 0x821BBA28;  }
		/* 821BB918h case    1:*/		return 0x821BB91C;
		  /* 821BB91Ch */ case    2:  		/* lwz R11, <#[R30 + 48]> */
		/* 821BB91Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000030) );
		/* 821BB91Ch case    2:*/		return 0x821BB920;
		  /* 821BB920h */ case    3:  		/* li R4, 1 */
		/* 821BB920h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 821BB920h case    3:*/		return 0x821BB924;
		  /* 821BB924h */ case    4:  		/* mr R3, R21 */
		/* 821BB924h case    4:*/		regs.R3 = regs.R21;
		/* 821BB924h case    4:*/		return 0x821BB928;
		  /* 821BB928h */ case    5:  		/* oris R11, R11, 16384 */
		/* 821BB928h case    5:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x4000);
		/* 821BB928h case    5:*/		return 0x821BB92C;
		  /* 821BB92Ch */ case    6:  		/* stw R11, <#[R30 + 48]> */
		/* 821BB92Ch case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000030) );
		/* 821BB92Ch case    6:*/		return 0x821BB930;
		  /* 821BB930h */ case    7:  		/* bl 16008 */
		/* 821BB930h case    7:*/		regs.LR = 0x821BB934; return 0x821BF7B8;
		/* 821BB930h case    7:*/		return 0x821BB934;
		  /* 821BB934h */ case    8:  		/* lwz R11, <#[R27 + 48]> */
		/* 821BB934h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000030) );
		/* 821BB934h case    8:*/		return 0x821BB938;
		  /* 821BB938h */ case    9:  		/* rlwinm. R11, R11, 2, 31, 31 */
		/* 821BB938h case    9:*/		cpu::op::rlwinm<1,2,31,31>(regs,&regs.R11,regs.R11);
		/* 821BB938h case    9:*/		return 0x821BB93C;
		  /* 821BB93Ch */ case   10:  		/* bc 12, CR0_EQ, 172 */
		/* 821BB93Ch case   10:*/		if ( regs.CR[0].eq ) { return 0x821BB9E8;  }
		/* 821BB93Ch case   10:*/		return 0x821BB940;
		  /* 821BB940h */ case   11:  		/* li R29, 1 */
		/* 821BB940h case   11:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 821BB940h case   11:*/		return 0x821BB944;
		  /* 821BB944h */ case   12:  		/* cmplwi CR6, R31, 15 */
		/* 821BB944h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x0000000F);
		/* 821BB944h case   12:*/		return 0x821BB948;
		  /* 821BB948h */ case   13:  		/* bc 12, CR6_EQ, 160 */
		/* 821BB948h case   13:*/		if ( regs.CR[6].eq ) { return 0x821BB9E8;  }
		/* 821BB948h case   13:*/		return 0x821BB94C;
		  /* 821BB94Ch */ case   14:  		/* lwz R11, <#[R30 + 36]> */
		/* 821BB94Ch case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000024) );
		/* 821BB94Ch case   14:*/		return 0x821BB950;
		  /* 821BB950h */ case   15:  		/* li R5, 0 */
		/* 821BB950h case   15:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821BB950h case   15:*/		return 0x821BB954;
		  /* 821BB954h */ case   16:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BB954h case   16:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BB954h case   16:*/		return 0x821BB958;
		  /* 821BB958h */ case   17:  		/* bc 4, CR0_EQ, 472 */
		/* 821BB958h case   17:*/		if ( !regs.CR[0].eq ) { return 0x821BBB30;  }
		/* 821BB958h case   17:*/		return 0x821BB95C;
		  /* 821BB95Ch */ case   18:  		/* mr R10, R11 */
		/* 821BB95Ch case   18:*/		regs.R10 = regs.R11;
		/* 821BB95Ch case   18:*/		return 0x821BB960;
		  /* 821BB960h */ case   19:  		/* cmplwi CR0, R11, 0 */
		/* 821BB960h case   19:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821BB960h case   19:*/		return 0x821BB964;
		  /* 821BB964h */ case   20:  		/* bc 12, CR0_EQ, 460 */
		/* 821BB964h case   20:*/		if ( regs.CR[0].eq ) { return 0x821BBB30;  }
		/* 821BB964h case   20:*/		return 0x821BB968;
		  /* 821BB968h */ case   21:  		/* lwz R11, <#[R10 + 8]> */
		/* 821BB968h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 821BB968h case   21:*/		return 0x821BB96C;
		  /* 821BB96Ch */ case   22:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821BB96Ch case   22:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821BB96Ch case   22:*/		return 0x821BB970;
		  /* 821BB970h */ case   23:  		/* cmplwi CR6, R11, 14976 */
		/* 821BB970h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003A80);
		/* 821BB970h case   23:*/		return 0x821BB974;
		  /* 821BB974h */ case   24:  		/* bc 4, CR6_EQ, 64 */
		/* 821BB974h case   24:*/		if ( !regs.CR[6].eq ) { return 0x821BB9B4;  }
		/* 821BB974h case   24:*/		return 0x821BB978;
		  /* 821BB978h */ case   25:  		/* lwz R11, <#[R10]> */
		/* 821BB978h case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 821BB978h case   25:*/		return 0x821BB97C;
		  /* 821BB97Ch */ case   26:  		/* cmplwi CR6, R11, 0 */
		/* 821BB97Ch case   26:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BB97Ch case   26:*/		return 0x821BB980;
		  /* 821BB980h */ case   27:  		/* bc 12, CR6_EQ, 44 */
		/* 821BB980h case   27:*/		if ( regs.CR[6].eq ) { return 0x821BB9AC;  }
		/* 821BB980h case   27:*/		return 0x821BB984;
		  /* 821BB984h */ case   28:  		/* lwz R9, <#[R11]> */
		/* 821BB984h case   28:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821BB984h case   28:*/		return 0x821BB988;
		  /* 821BB988h */ case   29:  		/* rlwinm. R9, R9, 0, 4, 6 */
		/* 821BB988h case   29:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R9,regs.R9);
		/* 821BB988h case   29:*/		return 0x821BB98C;
		  /* 821BB98Ch */ case   30:  		/* bc 12, CR0_EQ, 20 */
		/* 821BB98Ch case   30:*/		if ( regs.CR[0].eq ) { return 0x821BB9A0;  }
		/* 821BB98Ch case   30:*/		return 0x821BB990;
		  /* 821BB990h */ case   31:  		/* lwz R9, <#[R11 + 12]> */
		/* 821BB990h case   31:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 821BB990h case   31:*/		return 0x821BB994;
		  /* 821BB994h */ case   32:  		/* lwz R9, <#[R9 + 8]> */
		/* 821BB994h case   32:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 821BB994h case   32:*/		return 0x821BB998;
		  /* 821BB998h */ case   33:  		/* rlwinm. R9, R9, 27, 31, 31 */
		/* 821BB998h case   33:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R9,regs.R9);
		/* 821BB998h case   33:*/		return 0x821BB99C;
		  /* 821BB99Ch */ case   34:  		/* bc 4, CR0_EQ, 12 */
		/* 821BB99Ch case   34:*/		if ( !regs.CR[0].eq ) { return 0x821BB9A8;  }
		/* 821BB99Ch case   34:*/		return 0x821BB9A0;
	}
	return 0x821BB9A0;
} // Block from 821BB914h-821BB9A0h (35 instructions)

//////////////////////////////////////////////////////
// Block at 821BB9A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB9A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB9A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB9A0);
		  /* 821BB9A0h */ case    0:  		/* lwz R11, <#[R11 + 4]> */
		/* 821BB9A0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821BB9A0h case    0:*/		return 0x821BB9A4;
		  /* 821BB9A4h */ case    1:  		/* b -40 */
		/* 821BB9A4h case    1:*/		return 0x821BB97C;
		/* 821BB9A4h case    1:*/		return 0x821BB9A8;
	}
	return 0x821BB9A8;
} // Block from 821BB9A0h-821BB9A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BB9A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB9A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB9A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB9A8);
		  /* 821BB9A8h */ case    0:  		/* mr R5, R10 */
		/* 821BB9A8h case    0:*/		regs.R5 = regs.R10;
		/* 821BB9A8h case    0:*/		return 0x821BB9AC;
	}
	return 0x821BB9AC;
} // Block from 821BB9A8h-821BB9ACh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BB9ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB9AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB9AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB9AC);
		  /* 821BB9ACh */ case    0:  		/* cmplwi CR6, R5, 0 */
		/* 821BB9ACh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 821BB9ACh case    0:*/		return 0x821BB9B0;
		  /* 821BB9B0h */ case    1:  		/* bc 4, CR6_EQ, 40 */
		/* 821BB9B0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BB9D8;  }
		/* 821BB9B0h case    1:*/		return 0x821BB9B4;
	}
	return 0x821BB9B4;
} // Block from 821BB9ACh-821BB9B4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BB9B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB9B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB9B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB9B4);
		  /* 821BB9B4h */ case    0:  		/* rlwinm R11, R10, 0, 0, 30 */
		/* 821BB9B4h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R10);
		/* 821BB9B4h case    0:*/		return 0x821BB9B8;
		  /* 821BB9B8h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 821BB9B8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 821BB9B8h case    1:*/		return 0x821BB9BC;
		  /* 821BB9BCh */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BB9BCh case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BB9BCh case    2:*/		return 0x821BB9C0;
		  /* 821BB9C0h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 821BB9C0h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BB9D0;  }
		/* 821BB9C0h case    3:*/		return 0x821BB9C4;
		  /* 821BB9C4h */ case    4:  		/* mr R10, R11 */
		/* 821BB9C4h case    4:*/		regs.R10 = regs.R11;
		/* 821BB9C4h case    4:*/		return 0x821BB9C8;
		  /* 821BB9C8h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821BB9C8h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BB9C8h case    5:*/		return 0x821BB9CC;
		  /* 821BB9CCh */ case    6:  		/* bc 4, CR6_EQ, -100 */
		/* 821BB9CCh case    6:*/		if ( !regs.CR[6].eq ) { return 0x821BB968;  }
		/* 821BB9CCh case    6:*/		return 0x821BB9D0;
	}
	return 0x821BB9D0;
} // Block from 821BB9B4h-821BB9D0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BB9D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB9D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB9D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB9D0);
		  /* 821BB9D0h */ case    0:  		/* cmplwi CR6, R5, 0 */
		/* 821BB9D0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 821BB9D0h case    0:*/		return 0x821BB9D4;
		  /* 821BB9D4h */ case    1:  		/* bc 12, CR6_EQ, 348 */
		/* 821BB9D4h case    1:*/		if ( regs.CR[6].eq ) { return 0x821BBB30;  }
		/* 821BB9D4h case    1:*/		return 0x821BB9D8;
	}
	return 0x821BB9D8;
} // Block from 821BB9D0h-821BB9D8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BB9D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB9D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB9D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB9D8);
		  /* 821BB9D8h */ case    0:  		/* mr R6, R31 */
		/* 821BB9D8h case    0:*/		regs.R6 = regs.R31;
		/* 821BB9D8h case    0:*/		return 0x821BB9DC;
		  /* 821BB9DCh */ case    1:  		/* mr R4, R30 */
		/* 821BB9DCh case    1:*/		regs.R4 = regs.R30;
		/* 821BB9DCh case    1:*/		return 0x821BB9E0;
		  /* 821BB9E0h */ case    2:  		/* mr R3, R21 */
		/* 821BB9E0h case    2:*/		regs.R3 = regs.R21;
		/* 821BB9E0h case    2:*/		return 0x821BB9E4;
		  /* 821BB9E4h */ case    3:  		/* bl -18972 */
		/* 821BB9E4h case    3:*/		regs.LR = 0x821BB9E8; return 0x821B6FC8;
		/* 821BB9E4h case    3:*/		return 0x821BB9E8;
	}
	return 0x821BB9E8;
} // Block from 821BB9D8h-821BB9E8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BB9E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BB9E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BB9E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BB9E8);
		  /* 821BB9E8h */ case    0:  		/* lwz R11, <#[R21 + 4]> */
		/* 821BB9E8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000004) );
		/* 821BB9E8h case    0:*/		return 0x821BB9EC;
		  /* 821BB9ECh */ case    1:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BB9ECh case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BB9ECh case    1:*/		return 0x821BB9F0;
		  /* 821BB9F0h */ case    2:  		/* bc 4, CR0_EQ, 56 */
		/* 821BB9F0h case    2:*/		if ( !regs.CR[0].eq ) { return 0x821BBA28;  }
		/* 821BB9F0h case    2:*/		return 0x821BB9F4;
		  /* 821BB9F4h */ case    3:  		/* cmplwi CR0, R11, 0 */
		/* 821BB9F4h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821BB9F4h case    3:*/		return 0x821BB9F8;
		  /* 821BB9F8h */ case    4:  		/* bc 12, CR0_EQ, 48 */
		/* 821BB9F8h case    4:*/		if ( regs.CR[0].eq ) { return 0x821BBA28;  }
		/* 821BB9F8h case    4:*/		return 0x821BB9FC;
		  /* 821BB9FCh */ case    5:  		/* lwz R10, <#[R11 + 48]> */
		/* 821BB9FCh case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 821BB9FCh case    5:*/		return 0x821BBA00;
		  /* 821BBA00h */ case    6:  		/* rlwinm. R9, R10, 2, 31, 31 */
		/* 821BBA00h case    6:*/		cpu::op::rlwinm<1,2,31,31>(regs,&regs.R9,regs.R10);
		/* 821BBA00h case    6:*/		return 0x821BBA04;
		  /* 821BBA04h */ case    7:  		/* bc 12, CR0_EQ, 12 */
		/* 821BBA04h case    7:*/		if ( regs.CR[0].eq ) { return 0x821BBA10;  }
		/* 821BBA04h case    7:*/		return 0x821BBA08;
		  /* 821BBA08h */ case    8:  		/* rlwinm R10, R10, 0, 2, 0 */
		/* 821BBA08h case    8:*/		cpu::op::rlwinm<0,0,2,0>(regs,&regs.R10,regs.R10);
		/* 821BBA08h case    8:*/		return 0x821BBA0C;
		  /* 821BBA0Ch */ case    9:  		/* stw R10, <#[R11 + 48]> */
		/* 821BBA0Ch case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 821BBA0Ch case    9:*/		return 0x821BBA10;
	}
	return 0x821BBA10;
} // Block from 821BB9E8h-821BBA10h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821BBA10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBA10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBA10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBA10);
		  /* 821BBA10h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821BBA10h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821BBA10h case    0:*/		return 0x821BBA14;
		  /* 821BBA14h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 821BBA14h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821BBA14h case    1:*/		return 0x821BBA18;
		  /* 821BBA18h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BBA18h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BBA18h case    2:*/		return 0x821BBA1C;
		  /* 821BBA1Ch */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 821BBA1Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BBA28;  }
		/* 821BBA1Ch case    3:*/		return 0x821BBA20;
		  /* 821BBA20h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 821BBA20h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BBA20h case    4:*/		return 0x821BBA24;
		  /* 821BBA24h */ case    5:  		/* bc 4, CR6_EQ, -40 */
		/* 821BBA24h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821BB9FC;  }
		/* 821BBA24h case    5:*/		return 0x821BBA28;
	}
	return 0x821BBA28;
} // Block from 821BBA10h-821BBA28h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BBA28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBA28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBA28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBA28);
		  /* 821BBA28h */ case    0:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 821BBA28h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 821BBA28h case    0:*/		return 0x821BBA2C;
		  /* 821BBA2Ch */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 821BBA2Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821BBA2Ch case    1:*/		return 0x821BBA30;
		  /* 821BBA30h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BBA30h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BBA30h case    2:*/		return 0x821BBA34;
		  /* 821BBA34h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 821BBA34h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BBA44;  }
		/* 821BBA34h case    3:*/		return 0x821BBA38;
		  /* 821BBA38h */ case    4:  		/* mr R30, R11 */
		/* 821BBA38h case    4:*/		regs.R30 = regs.R11;
		/* 821BBA38h case    4:*/		return 0x821BBA3C;
		  /* 821BBA3Ch */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821BBA3Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BBA3Ch case    5:*/		return 0x821BBA40;
		  /* 821BBA40h */ case    6:  		/* bc 4, CR6_EQ, -456 */
		/* 821BBA40h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821BB878;  }
		/* 821BBA40h case    6:*/		return 0x821BBA44;
	}
	return 0x821BBA44;
} // Block from 821BBA28h-821BBA44h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BBA44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBA44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBA44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBA44);
		  /* 821BBA44h */ case    0:  		/* rlwinm. R11, R29, 0, 24, 31 */
		/* 821BBA44h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R29);
		/* 821BBA44h case    0:*/		return 0x821BBA48;
		  /* 821BBA48h */ case    1:  		/* bc 4, CR0_EQ, 24 */
		/* 821BBA48h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821BBA60;  }
		/* 821BBA48h case    1:*/		return 0x821BBA4C;
	}
	return 0x821BBA4C;
} // Block from 821BBA44h-821BBA4Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BBA4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBA4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBA4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBA4C);
		  /* 821BBA4Ch */ case    0:  		/* li R6, 0 */
		/* 821BBA4Ch case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821BBA4Ch case    0:*/		return 0x821BBA50;
	}
	return 0x821BBA50;
} // Block from 821BBA4Ch-821BBA50h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BBA50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBA50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBA50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBA50);
		  /* 821BBA50h */ case    0:  		/* mr R5, R28 */
		/* 821BBA50h case    0:*/		regs.R5 = regs.R28;
		/* 821BBA50h case    0:*/		return 0x821BBA54;
		  /* 821BBA54h */ case    1:  		/* mr R4, R27 */
		/* 821BBA54h case    1:*/		regs.R4 = regs.R27;
		/* 821BBA54h case    1:*/		return 0x821BBA58;
		  /* 821BBA58h */ case    2:  		/* mr R3, R21 */
		/* 821BBA58h case    2:*/		regs.R3 = regs.R21;
		/* 821BBA58h case    2:*/		return 0x821BBA5C;
		  /* 821BBA5Ch */ case    3:  		/* bl -19092 */
		/* 821BBA5Ch case    3:*/		regs.LR = 0x821BBA60; return 0x821B6FC8;
		/* 821BBA5Ch case    3:*/		return 0x821BBA60;
	}
	return 0x821BBA60;
} // Block from 821BBA50h-821BBA60h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BBA60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBA60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBA60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBA60);
		  /* 821BBA60h */ case    0:  		/* rlwinm R11, R28, 0, 0, 30 */
		/* 821BBA60h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R28);
		/* 821BBA60h case    0:*/		return 0x821BBA64;
		  /* 821BBA64h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 821BBA64h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 821BBA64h case    1:*/		return 0x821BBA68;
		  /* 821BBA68h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BBA68h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BBA68h case    2:*/		return 0x821BBA6C;
		  /* 821BBA6Ch */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 821BBA6Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BBA7C;  }
		/* 821BBA6Ch case    3:*/		return 0x821BBA70;
		  /* 821BBA70h */ case    4:  		/* mr R28, R11 */
		/* 821BBA70h case    4:*/		regs.R28 = regs.R11;
		/* 821BBA70h case    4:*/		return 0x821BBA74;
		  /* 821BBA74h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821BBA74h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BBA74h case    5:*/		return 0x821BBA78;
		  /* 821BBA78h */ case    6:  		/* bc 4, CR6_EQ, -712 */
		/* 821BBA78h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821BB7B0;  }
		/* 821BBA78h case    6:*/		return 0x821BBA7C;
	}
	return 0x821BBA7C;
} // Block from 821BBA60h-821BBA7Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BBA7Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBA7C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBA7C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBA7C);
		  /* 821BBA7Ch */ case    0:  		/* rlwinm R11, R27, 0, 0, 30 */
		/* 821BBA7Ch case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R27);
		/* 821BBA7Ch case    0:*/		return 0x821BBA80;
		  /* 821BBA80h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 821BBA80h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821BBA80h case    1:*/		return 0x821BBA84;
		  /* 821BBA84h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BBA84h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BBA84h case    2:*/		return 0x821BBA88;
		  /* 821BBA88h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 821BBA88h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BBA98;  }
		/* 821BBA88h case    3:*/		return 0x821BBA8C;
		  /* 821BBA8Ch */ case    4:  		/* mr R27, R11 */
		/* 821BBA8Ch case    4:*/		regs.R27 = regs.R11;
		/* 821BBA8Ch case    4:*/		return 0x821BBA90;
		  /* 821BBA90h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821BBA90h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BBA90h case    5:*/		return 0x821BBA94;
		  /* 821BBA94h */ case    6:  		/* bc 4, CR6_EQ, -764 */
		/* 821BBA94h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821BB798;  }
		/* 821BBA94h case    6:*/		return 0x821BBA98;
	}
	return 0x821BBA98;
} // Block from 821BBA7Ch-821BBA98h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BBA98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBA98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBA98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBA98);
		  /* 821BBA98h */ case    0:  		/* lwz R11, <#[R21 + 4]> */
		/* 821BBA98h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000004) );
		/* 821BBA98h case    0:*/		return 0x821BBA9C;
		  /* 821BBA9Ch */ case    1:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BBA9Ch case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BBA9Ch case    1:*/		return 0x821BBAA0;
		  /* 821BBAA0h */ case    2:  		/* bc 4, CR0_EQ, 272 */
		/* 821BBAA0h case    2:*/		if ( !regs.CR[0].eq ) { return 0x821BBBB0;  }
		/* 821BBAA0h case    2:*/		return 0x821BBAA4;
		  /* 821BBAA4h */ case    3:  		/* mr R8, R11 */
		/* 821BBAA4h case    3:*/		regs.R8 = regs.R11;
		/* 821BBAA4h case    3:*/		return 0x821BBAA8;
		  /* 821BBAA8h */ case    4:  		/* cmplwi CR0, R11, 0 */
		/* 821BBAA8h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821BBAA8h case    4:*/		return 0x821BBAAC;
		  /* 821BBAACh */ case    5:  		/* bc 12, CR0_EQ, 260 */
		/* 821BBAACh case    5:*/		if ( regs.CR[0].eq ) { return 0x821BBBB0;  }
		/* 821BBAACh case    5:*/		return 0x821BBAB0;
		  /* 821BBAB0h */ case    6:  		/* lwz R11, <#[R8 + 36]> */
		/* 821BBAB0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000024) );
		/* 821BBAB0h case    6:*/		return 0x821BBAB4;
		  /* 821BBAB4h */ case    7:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BBAB4h case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BBAB4h case    7:*/		return 0x821BBAB8;
		  /* 821BBAB8h */ case    8:  		/* bc 4, CR0_EQ, 220 */
		/* 821BBAB8h case    8:*/		if ( !regs.CR[0].eq ) { return 0x821BBB94;  }
		/* 821BBAB8h case    8:*/		return 0x821BBABC;
		  /* 821BBABCh */ case    9:  		/* mr R9, R11 */
		/* 821BBABCh case    9:*/		regs.R9 = regs.R11;
		/* 821BBABCh case    9:*/		return 0x821BBAC0;
		  /* 821BBAC0h */ case   10:  		/* cmplwi CR0, R11, 0 */
		/* 821BBAC0h case   10:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821BBAC0h case   10:*/		return 0x821BBAC4;
		  /* 821BBAC4h */ case   11:  		/* bc 12, CR0_EQ, 208 */
		/* 821BBAC4h case   11:*/		if ( regs.CR[0].eq ) { return 0x821BBB94;  }
		/* 821BBAC4h case   11:*/		return 0x821BBAC8;
		  /* 821BBAC8h */ case   12:  		/* lwz R11, <#[R9 + 8]> */
		/* 821BBAC8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000008) );
		/* 821BBAC8h case   12:*/		return 0x821BBACC;
		  /* 821BBACCh */ case   13:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821BBACCh case   13:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821BBACCh case   13:*/		return 0x821BBAD0;
		  /* 821BBAD0h */ case   14:  		/* cmplwi CR6, R11, 83 */
		/* 821BBAD0h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000053);
		/* 821BBAD0h case   14:*/		return 0x821BBAD4;
		  /* 821BBAD4h */ case   15:  		/* bc 12, CR6_EQ, 12 */
		/* 821BBAD4h case   15:*/		if ( regs.CR[6].eq ) { return 0x821BBAE0;  }
		/* 821BBAD4h case   15:*/		return 0x821BBAD8;
		  /* 821BBAD8h */ case   16:  		/* cmplwi CR6, R11, 117 */
		/* 821BBAD8h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000075);
		/* 821BBAD8h case   16:*/		return 0x821BBADC;
		  /* 821BBADCh */ case   17:  		/* bc 4, CR6_EQ, 96 */
		/* 821BBADCh case   17:*/		if ( !regs.CR[6].eq ) { return 0x821BBB3C;  }
		/* 821BBADCh case   17:*/		return 0x821BBAE0;
	}
	return 0x821BBAE0;
} // Block from 821BBA98h-821BBAE0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821BBAE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBAE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBAE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBAE0);
		  /* 821BBAE0h */ case    0:  		/* lwz R11, <#[R9]> */
		/* 821BBAE0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000000) );
		/* 821BBAE0h case    0:*/		return 0x821BBAE4;
		  /* 821BBAE4h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 821BBAE4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BBAE4h case    1:*/		return 0x821BBAE8;
		  /* 821BBAE8h */ case    2:  		/* bc 12, CR6_EQ, 84 */
		/* 821BBAE8h case    2:*/		if ( regs.CR[6].eq ) { return 0x821BBB3C;  }
		/* 821BBAE8h case    2:*/		return 0x821BBAEC;
		  /* 821BBAECh */ case    3:  		/* lwz R10, <#[R11]> */
		/* 821BBAECh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821BBAECh case    3:*/		return 0x821BBAF0;
		  /* 821BBAF0h */ case    4:  		/* rlwinm. R7, R10, 0, 4, 6 */
		/* 821BBAF0h case    4:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R7,regs.R10);
		/* 821BBAF0h case    4:*/		return 0x821BBAF4;
		  /* 821BBAF4h */ case    5:  		/* bc 12, CR0_EQ, 40 */
		/* 821BBAF4h case    5:*/		if ( regs.CR[0].eq ) { return 0x821BBB1C;  }
		/* 821BBAF4h case    5:*/		return 0x821BBAF8;
		  /* 821BBAF8h */ case    6:  		/* lwz R7, <#[R11 + 12]> */
		/* 821BBAF8h case    6:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x0000000C) );
		/* 821BBAF8h case    6:*/		return 0x821BBAFC;
		  /* 821BBAFCh */ case    7:  		/* lwz R7, <#[R7 + 8]> */
		/* 821BBAFCh case    7:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000008) );
		/* 821BBAFCh case    7:*/		return 0x821BBB00;
		  /* 821BBB00h */ case    8:  		/* rlwinm. R7, R7, 27, 31, 31 */
		/* 821BBB00h case    8:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R7,regs.R7);
		/* 821BBB00h case    8:*/		return 0x821BBB04;
		  /* 821BBB04h */ case    9:  		/* bc 12, CR0_EQ, 24 */
		/* 821BBB04h case    9:*/		if ( regs.CR[0].eq ) { return 0x821BBB1C;  }
		/* 821BBB04h case    9:*/		return 0x821BBB08;
		  /* 821BBB08h */ case   10:  		/* rlwinm R10, R10, 15, 24, 31 */
		/* 821BBB08h case   10:*/		cpu::op::rlwinm<0,15,24,31>(regs,&regs.R10,regs.R10);
		/* 821BBB08h case   10:*/		return 0x821BBB0C;
		  /* 821BBB0Ch */ case   11:  		/* cmplwi CR6, R10, 32 */
		/* 821BBB0Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000020);
		/* 821BBB0Ch case   11:*/		return 0x821BBB10;
		  /* 821BBB10h */ case   12:  		/* bc 12, CR6_LT, 76 */
		/* 821BBB10h case   12:*/		if ( regs.CR[6].lt ) { return 0x821BBB5C;  }
		/* 821BBB10h case   12:*/		return 0x821BBB14;
		  /* 821BBB14h */ case   13:  		/* cmplwi CR6, R10, 37 */
		/* 821BBB14h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000025);
		/* 821BBB14h case   13:*/		return 0x821BBB18;
		  /* 821BBB18h */ case   14:  		/* bc 12, CR6_GT, 68 */
		/* 821BBB18h case   14:*/		if ( regs.CR[6].gt ) { return 0x821BBB5C;  }
		/* 821BBB18h case   14:*/		return 0x821BBB1C;
	}
	return 0x821BBB1C;
} // Block from 821BBAE0h-821BBB1Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 821BBB1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBB1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBB1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBB1C);
		  /* 821BBB1Ch */ case    0:  		/* lwz R11, <#[R11 + 4]> */
		/* 821BBB1Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821BBB1Ch case    0:*/		return 0x821BBB20;
		  /* 821BBB20h */ case    1:  		/* b -60 */
		/* 821BBB20h case    1:*/		return 0x821BBAE4;
		/* 821BBB20h case    1:*/		return 0x821BBB24;
	}
	return 0x821BBB24;
} // Block from 821BBB1Ch-821BBB24h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BBB24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBB24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBB24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBB24);
		  /* 821BBB24h */ case    0:  		/* li R4, 4800 */
		/* 821BBB24h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 821BBB24h case    0:*/		return 0x821BBB28;
		  /* 821BBB28h */ case    1:  		/* mr R3, R21 */
		/* 821BBB28h case    1:*/		regs.R3 = regs.R21;
		/* 821BBB28h case    1:*/		return 0x821BBB2C;
		  /* 821BBB2Ch */ case    2:  		/* bl -433348 */
		/* 821BBB2Ch case    2:*/		regs.LR = 0x821BBB30; return 0x82151E68;
		/* 821BBB2Ch case    2:*/		return 0x821BBB30;
	}
	return 0x821BBB30;
} // Block from 821BBB24h-821BBB30h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BBB30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBB30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBB30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBB30);
		  /* 821BBB30h */ case    0:  		/* li R4, 4800 */
		/* 821BBB30h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 821BBB30h case    0:*/		return 0x821BBB34;
		  /* 821BBB34h */ case    1:  		/* mr R3, R21 */
		/* 821BBB34h case    1:*/		regs.R3 = regs.R21;
		/* 821BBB34h case    1:*/		return 0x821BBB38;
		  /* 821BBB38h */ case    2:  		/* bl -433360 */
		/* 821BBB38h case    2:*/		regs.LR = 0x821BBB3C; return 0x82151E68;
		/* 821BBB38h case    2:*/		return 0x821BBB3C;
	}
	return 0x821BBB3C;
} // Block from 821BBB30h-821BBB3Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BBB3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBB3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBB3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBB3C);
		  /* 821BBB3Ch */ case    0:  		/* rlwinm R11, R9, 0, 0, 30 */
		/* 821BBB3Ch case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R9);
		/* 821BBB3Ch case    0:*/		return 0x821BBB40;
		  /* 821BBB40h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 821BBB40h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 821BBB40h case    1:*/		return 0x821BBB44;
		  /* 821BBB44h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BBB44h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BBB44h case    2:*/		return 0x821BBB48;
		  /* 821BBB48h */ case    3:  		/* bc 4, CR0_EQ, 76 */
		/* 821BBB48h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BBB94;  }
		/* 821BBB48h case    3:*/		return 0x821BBB4C;
		  /* 821BBB4Ch */ case    4:  		/* mr R9, R11 */
		/* 821BBB4Ch case    4:*/		regs.R9 = regs.R11;
		/* 821BBB4Ch case    4:*/		return 0x821BBB50;
		  /* 821BBB50h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821BBB50h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BBB50h case    5:*/		return 0x821BBB54;
		  /* 821BBB54h */ case    6:  		/* bc 4, CR6_EQ, -140 */
		/* 821BBB54h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821BBAC8;  }
		/* 821BBB54h case    6:*/		return 0x821BBB58;
		  /* 821BBB58h */ case    7:  		/* b 60 */
		/* 821BBB58h case    7:*/		return 0x821BBB94;
		/* 821BBB58h case    7:*/		return 0x821BBB5C;
	}
	return 0x821BBB5C;
} // Block from 821BBB3Ch-821BBB5Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 821BBB5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBB5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBB5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBB5C);
		  /* 821BBB5Ch */ case    0:  		/* addi R11, R8, 48 */
		/* 821BBB5Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R8,0x30);
		/* 821BBB5Ch case    0:*/		return 0x821BBB60;
		  /* 821BBB60h */ case    1:  		/* mr R10, R8 */
		/* 821BBB60h case    1:*/		regs.R10 = regs.R8;
		/* 821BBB60h case    1:*/		return 0x821BBB64;
		  /* 821BBB64h */ case    2:  		/* lwz R9, <#[R11]> */
		/* 821BBB64h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821BBB64h case    2:*/		return 0x821BBB68;
		  /* 821BBB68h */ case    3:  		/* b 24 */
		/* 821BBB68h case    3:*/		return 0x821BBB80;
		/* 821BBB68h case    3:*/		return 0x821BBB6C;
		  /* 821BBB6Ch */ case    4:  		/* lwz R10, <#[R10 + 52]> */
		/* 821BBB6Ch case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000034) );
		/* 821BBB6Ch case    4:*/		return 0x821BBB70;
		  /* 821BBB70h */ case    5:  		/* cmplwi CR6, R10, 0 */
		/* 821BBB70h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821BBB70h case    5:*/		return 0x821BBB74;
		  /* 821BBB74h */ case    6:  		/* bc 12, CR6_EQ, 1044 */
		/* 821BBB74h case    6:*/		if ( regs.CR[6].eq ) { return 0x821BBF88;  }
		/* 821BBB74h case    6:*/		return 0x821BBB78;
		  /* 821BBB78h */ case    7:  		/* lwz R9, <#[R10 + 48]> */
		/* 821BBB78h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000030) );
		/* 821BBB78h case    7:*/		return 0x821BBB7C;
		  /* 821BBB7Ch */ case    8:  		/* addi R11, R10, 48 */
		/* 821BBB7Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x30);
		/* 821BBB7Ch case    8:*/		return 0x821BBB80;
	}
	return 0x821BBB80;
} // Block from 821BBB5Ch-821BBB80h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821BBB80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBB80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBB80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBB80);
		  /* 821BBB80h */ case    0:  		/* rlwinm. R9, R9, 9, 31, 31 */
		/* 821BBB80h case    0:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R9,regs.R9);
		/* 821BBB80h case    0:*/		return 0x821BBB84;
		  /* 821BBB84h */ case    1:  		/* bc 4, CR0_EQ, -24 */
		/* 821BBB84h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821BBB6C;  }
		/* 821BBB84h case    1:*/		return 0x821BBB88;
		  /* 821BBB88h */ case    2:  		/* lwz R10, <#[R11]> */
		/* 821BBB88h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821BBB88h case    2:*/		return 0x821BBB8C;
		  /* 821BBB8Ch */ case    3:  		/* oris R10, R10, 16384 */
		/* 821BBB8Ch case    3:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x4000);
		/* 821BBB8Ch case    3:*/		return 0x821BBB90;
		  /* 821BBB90h */ case    4:  		/* stw R10, <#[R11]> */
		/* 821BBB90h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821BBB90h case    4:*/		return 0x821BBB94;
	}
	return 0x821BBB94;
} // Block from 821BBB80h-821BBB94h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BBB94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBB94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBB94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBB94);
		  /* 821BBB94h */ case    0:  		/* rlwinm R11, R8, 0, 0, 30 */
		/* 821BBB94h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R8);
		/* 821BBB94h case    0:*/		return 0x821BBB98;
		  /* 821BBB98h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 821BBB98h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821BBB98h case    1:*/		return 0x821BBB9C;
		  /* 821BBB9Ch */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BBB9Ch case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BBB9Ch case    2:*/		return 0x821BBBA0;
		  /* 821BBBA0h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 821BBBA0h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BBBB0;  }
		/* 821BBBA0h case    3:*/		return 0x821BBBA4;
		  /* 821BBBA4h */ case    4:  		/* mr R8, R11 */
		/* 821BBBA4h case    4:*/		regs.R8 = regs.R11;
		/* 821BBBA4h case    4:*/		return 0x821BBBA8;
		  /* 821BBBA8h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821BBBA8h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BBBA8h case    5:*/		return 0x821BBBAC;
		  /* 821BBBACh */ case    6:  		/* bc 4, CR6_EQ, -252 */
		/* 821BBBACh case    6:*/		if ( !regs.CR[6].eq ) { return 0x821BBAB0;  }
		/* 821BBBACh case    6:*/		return 0x821BBBB0;
	}
	return 0x821BBBB0;
} // Block from 821BBB94h-821BBBB0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BBBB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBBB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBBB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBBB0);
		  /* 821BBBB0h */ case    0:  		/* lwz R11, <#[R21 + 4]> */
		/* 821BBBB0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000004) );
		/* 821BBBB0h case    0:*/		return 0x821BBBB4;
		  /* 821BBBB4h */ case    1:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BBBB4h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BBBB4h case    1:*/		return 0x821BBBB8;
		  /* 821BBBB8h */ case    2:  		/* bc 4, CR0_EQ, 136 */
		/* 821BBBB8h case    2:*/		if ( !regs.CR[0].eq ) { return 0x821BBC40;  }
		/* 821BBBB8h case    2:*/		return 0x821BBBBC;
		  /* 821BBBBCh */ case    3:  		/* mr R9, R11 */
		/* 821BBBBCh case    3:*/		regs.R9 = regs.R11;
		/* 821BBBBCh case    3:*/		return 0x821BBBC0;
		  /* 821BBBC0h */ case    4:  		/* cmplwi CR0, R11, 0 */
		/* 821BBBC0h case    4:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821BBBC0h case    4:*/		return 0x821BBBC4;
		  /* 821BBBC4h */ case    5:  		/* bc 12, CR0_EQ, 124 */
		/* 821BBBC4h case    5:*/		if ( regs.CR[0].eq ) { return 0x821BBC40;  }
		/* 821BBBC4h case    5:*/		return 0x821BBBC8;
		  /* 821BBBC8h */ case    6:  		/* mr R11, R9 */
		/* 821BBBC8h case    6:*/		regs.R11 = regs.R9;
		/* 821BBBC8h case    6:*/		return 0x821BBBCC;
		  /* 821BBBCCh */ case    7:  		/* cmplwi CR6, R9, 0 */
		/* 821BBBCCh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 821BBBCCh case    7:*/		return 0x821BBBD0;
		  /* 821BBBD0h */ case    8:  		/* bc 12, CR6_EQ, 84 */
		/* 821BBBD0h case    8:*/		if ( regs.CR[6].eq ) { return 0x821BBC24;  }
		/* 821BBBD0h case    8:*/		return 0x821BBBD4;
		  /* 821BBBD4h */ case    9:  		/* lwz R10, <#[R11 + 48]> */
		/* 821BBBD4h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 821BBBD4h case    9:*/		return 0x821BBBD8;
		  /* 821BBBD8h */ case   10:  		/* rlwinm. R10, R10, 2, 31, 31 */
		/* 821BBBD8h case   10:*/		cpu::op::rlwinm<1,2,31,31>(regs,&regs.R10,regs.R10);
		/* 821BBBD8h case   10:*/		return 0x821BBBDC;
		  /* 821BBBDCh */ case   11:  		/* bc 4, CR0_EQ, 16 */
		/* 821BBBDCh case   11:*/		if ( !regs.CR[0].eq ) { return 0x821BBBEC;  }
		/* 821BBBDCh case   11:*/		return 0x821BBBE0;
		  /* 821BBBE0h */ case   12:  		/* lwz R11, <#[R11 + 52]> */
		/* 821BBBE0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000034) );
		/* 821BBBE0h case   12:*/		return 0x821BBBE4;
		  /* 821BBBE4h */ case   13:  		/* cmplwi CR6, R11, 0 */
		/* 821BBBE4h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BBBE4h case   13:*/		return 0x821BBBE8;
		  /* 821BBBE8h */ case   14:  		/* bc 4, CR6_EQ, -20 */
		/* 821BBBE8h case   14:*/		if ( !regs.CR[6].eq ) { return 0x821BBBD4;  }
		/* 821BBBE8h case   14:*/		return 0x821BBBEC;
	}
	return 0x821BBBEC;
} // Block from 821BBBB0h-821BBBECh (15 instructions)

//////////////////////////////////////////////////////
// Block at 821BBBECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBBEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBBEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBBEC);
		  /* 821BBBECh */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 821BBBECh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BBBECh case    0:*/		return 0x821BBBF0;
		  /* 821BBBF0h */ case    1:  		/* bc 12, CR6_EQ, 52 */
		/* 821BBBF0h case    1:*/		if ( regs.CR[6].eq ) { return 0x821BBC24;  }
		/* 821BBBF0h case    1:*/		return 0x821BBBF4;
		  /* 821BBBF4h */ case    2:  		/* lwz R10, <#[R11 + 52]> */
		/* 821BBBF4h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000034) );
		/* 821BBBF4h case    2:*/		return 0x821BBBF8;
		  /* 821BBBF8h */ case    3:  		/* b 36 */
		/* 821BBBF8h case    3:*/		return 0x821BBC1C;
		/* 821BBBF8h case    3:*/		return 0x821BBBFC;
		  /* 821BBBFCh */ case    4:  		/* lwz R8, <#[R10 + 48]> */
		/* 821BBBFCh case    4:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000030) );
		/* 821BBBFCh case    4:*/		return 0x821BBC00;
		  /* 821BBC00h */ case    5:  		/* rlwinm. R8, R8, 2, 31, 31 */
		/* 821BBC00h case    5:*/		cpu::op::rlwinm<1,2,31,31>(regs,&regs.R8,regs.R8);
		/* 821BBC00h case    5:*/		return 0x821BBC04;
		  /* 821BBC04h */ case    6:  		/* bc 12, CR0_EQ, 20 */
		/* 821BBC04h case    6:*/		if ( regs.CR[0].eq ) { return 0x821BBC18;  }
		/* 821BBC04h case    6:*/		return 0x821BBC08;
		  /* 821BBC08h */ case    7:  		/* lwz R8, <#[R11 + 48]> */
		/* 821BBC08h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000030) );
		/* 821BBC08h case    7:*/		return 0x821BBC0C;
		  /* 821BBC0Ch */ case    8:  		/* rlwinm R8, R8, 0, 2, 0 */
		/* 821BBC0Ch case    8:*/		cpu::op::rlwinm<0,0,2,0>(regs,&regs.R8,regs.R8);
		/* 821BBC0Ch case    8:*/		return 0x821BBC10;
		  /* 821BBC10h */ case    9:  		/* stw R8, <#[R11 + 48]> */
		/* 821BBC10h case    9:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000030) );
		/* 821BBC10h case    9:*/		return 0x821BBC14;
		  /* 821BBC14h */ case   10:  		/* mr R11, R10 */
		/* 821BBC14h case   10:*/		regs.R11 = regs.R10;
		/* 821BBC14h case   10:*/		return 0x821BBC18;
	}
	return 0x821BBC18;
} // Block from 821BBBECh-821BBC18h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821BBC18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBC18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBC18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBC18);
		  /* 821BBC18h */ case    0:  		/* lwz R10, <#[R10 + 52]> */
		/* 821BBC18h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000034) );
		/* 821BBC18h case    0:*/		return 0x821BBC1C;
	}
	return 0x821BBC1C;
} // Block from 821BBC18h-821BBC1Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BBC1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBC1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBC1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBC1C);
		  /* 821BBC1Ch */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 821BBC1Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821BBC1Ch case    0:*/		return 0x821BBC20;
		  /* 821BBC20h */ case    1:  		/* bc 4, CR6_EQ, -36 */
		/* 821BBC20h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BBBFC;  }
		/* 821BBC20h case    1:*/		return 0x821BBC24;
	}
	return 0x821BBC24;
} // Block from 821BBC1Ch-821BBC24h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BBC24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBC24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBC24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBC24);
		  /* 821BBC24h */ case    0:  		/* rlwinm R11, R9, 0, 0, 30 */
		/* 821BBC24h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R9);
		/* 821BBC24h case    0:*/		return 0x821BBC28;
		  /* 821BBC28h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 821BBC28h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821BBC28h case    1:*/		return 0x821BBC2C;
		  /* 821BBC2Ch */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BBC2Ch case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BBC2Ch case    2:*/		return 0x821BBC30;
		  /* 821BBC30h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 821BBC30h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BBC40;  }
		/* 821BBC30h case    3:*/		return 0x821BBC34;
		  /* 821BBC34h */ case    4:  		/* mr R9, R11 */
		/* 821BBC34h case    4:*/		regs.R9 = regs.R11;
		/* 821BBC34h case    4:*/		return 0x821BBC38;
		  /* 821BBC38h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821BBC38h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BBC38h case    5:*/		return 0x821BBC3C;
		  /* 821BBC3Ch */ case    6:  		/* bc 4, CR6_EQ, -116 */
		/* 821BBC3Ch case    6:*/		if ( !regs.CR[6].eq ) { return 0x821BBBC8;  }
		/* 821BBC3Ch case    6:*/		return 0x821BBC40;
	}
	return 0x821BBC40;
} // Block from 821BBC24h-821BBC40h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BBC40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBC40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBC40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBC40);
		  /* 821BBC40h */ case    0:  		/* lwz R23, <#[R21 + 4]> */
		/* 821BBC40h case    0:*/		cpu::mem::load32z( regs, &regs.R23, (uint32)(regs.R21 + 0x00000004) );
		/* 821BBC40h case    0:*/		return 0x821BBC44;
		  /* 821BBC44h */ case    1:  		/* rlwinm. R26, R23, 0, 31, 31 */
		/* 821BBC44h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R26,regs.R23);
		/* 821BBC44h case    1:*/		return 0x821BBC48;
		  /* 821BBC48h */ case    2:  		/* bc 4, CR0_EQ, 724 */
		/* 821BBC48h case    2:*/		if ( !regs.CR[0].eq ) { return 0x821BBF1C;  }
		/* 821BBC48h case    2:*/		return 0x821BBC4C;
		  /* 821BBC4Ch */ case    3:  		/* lwz R11, <#[R21]> */
		/* 821BBC4Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 821BBC4Ch case    3:*/		return 0x821BBC50;
		  /* 821BBC50h */ case    4:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821BBC50h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821BBC50h case    4:*/		return 0x821BBC54;
		  /* 821BBC54h */ case    5:  		/* addi R27, R11, -4 */
		/* 821BBC54h case    5:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R11,0xFFFFFFFC);
		/* 821BBC54h case    5:*/		return 0x821BBC58;
		  /* 821BBC58h */ case    6:  		/* cmplwi CR6, R27, 0 */
		/* 821BBC58h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 821BBC58h case    6:*/		return 0x821BBC5C;
		  /* 821BBC5Ch */ case    7:  		/* bc 12, CR6_EQ, 848 */
		/* 821BBC5Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x821BBFAC;  }
		/* 821BBC5Ch case    7:*/		return 0x821BBC60;
		  /* 821BBC60h */ case    8:  		/* lwz R11, <#[R27 + 36]> */
		/* 821BBC60h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000024) );
		/* 821BBC60h case    8:*/		return 0x821BBC64;
		  /* 821BBC64h */ case    9:  		/* li R6, 0 */
		/* 821BBC64h case    9:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821BBC64h case    9:*/		return 0x821BBC68;
		  /* 821BBC68h */ case   10:  		/* li R5, 0 */
		/* 821BBC68h case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821BBC68h case   10:*/		return 0x821BBC6C;
		  /* 821BBC6Ch */ case   11:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BBC6Ch case   11:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BBC6Ch case   11:*/		return 0x821BBC70;
		  /* 821BBC70h */ case   12:  		/* bc 4, CR0_EQ, 184 */
		/* 821BBC70h case   12:*/		if ( !regs.CR[0].eq ) { return 0x821BBD28;  }
		/* 821BBC70h case   12:*/		return 0x821BBC74;
		  /* 821BBC74h */ case   13:  		/* mr R7, R11 */
		/* 821BBC74h case   13:*/		regs.R7 = regs.R11;
		/* 821BBC74h case   13:*/		return 0x821BBC78;
		  /* 821BBC78h */ case   14:  		/* cmplwi CR0, R11, 0 */
		/* 821BBC78h case   14:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821BBC78h case   14:*/		return 0x821BBC7C;
		  /* 821BBC7Ch */ case   15:  		/* bc 12, CR0_EQ, 172 */
		/* 821BBC7Ch case   15:*/		if ( regs.CR[0].eq ) { return 0x821BBD28;  }
		/* 821BBC7Ch case   15:*/		return 0x821BBC80;
		  /* 821BBC80h */ case   16:  		/* lwz R11, <#[R7 + 8]> */
		/* 821BBC80h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000008) );
		/* 821BBC80h case   16:*/		return 0x821BBC84;
		  /* 821BBC84h */ case   17:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821BBC84h case   17:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821BBC84h case   17:*/		return 0x821BBC88;
		  /* 821BBC88h */ case   18:  		/* cmplwi CR6, R11, 14976 */
		/* 821BBC88h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003A80);
		/* 821BBC88h case   18:*/		return 0x821BBC8C;
		  /* 821BBC8Ch */ case   19:  		/* bc 4, CR6_EQ, 128 */
		/* 821BBC8Ch case   19:*/		if ( !regs.CR[6].eq ) { return 0x821BBD0C;  }
		/* 821BBC8Ch case   19:*/		return 0x821BBC90;
		  /* 821BBC90h */ case   20:  		/* lwz R8, <#[R7]> */
		/* 821BBC90h case   20:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R7 + 0x00000000) );
		/* 821BBC90h case   20:*/		return 0x821BBC94;
		  /* 821BBC94h */ case   21:  		/* cmplwi CR6, R8, 0 */
		/* 821BBC94h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 821BBC94h case   21:*/		return 0x821BBC98;
		  /* 821BBC98h */ case   22:  		/* bc 12, CR6_EQ, 116 */
		/* 821BBC98h case   22:*/		if ( regs.CR[6].eq ) { return 0x821BBD0C;  }
		/* 821BBC98h case   22:*/		return 0x821BBC9C;
		  /* 821BBC9Ch */ case   23:  		/* lwz R11, <#[R8]> */
		/* 821BBC9Ch case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 821BBC9Ch case   23:*/		return 0x821BBCA0;
		  /* 821BBCA0h */ case   24:  		/* rlwinm. R10, R11, 0, 4, 6 */
		/* 821BBCA0h case   24:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R11);
		/* 821BBCA0h case   24:*/		return 0x821BBCA4;
		  /* 821BBCA4h */ case   25:  		/* bc 12, CR0_EQ, 96 */
		/* 821BBCA4h case   25:*/		if ( regs.CR[0].eq ) { return 0x821BBD04;  }
		/* 821BBCA4h case   25:*/		return 0x821BBCA8;
		  /* 821BBCA8h */ case   26:  		/* lwz R10, <#[R8 + 12]> */
		/* 821BBCA8h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x0000000C) );
		/* 821BBCA8h case   26:*/		return 0x821BBCAC;
		  /* 821BBCACh */ case   27:  		/* lwz R10, <#[R10 + 8]> */
		/* 821BBCACh case   27:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 821BBCACh case   27:*/		return 0x821BBCB0;
		  /* 821BBCB0h */ case   28:  		/* rlwinm. R9, R10, 27, 31, 31 */
		/* 821BBCB0h case   28:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R9,regs.R10);
		/* 821BBCB0h case   28:*/		return 0x821BBCB4;
		  /* 821BBCB4h */ case   29:  		/* bc 12, CR0_EQ, 80 */
		/* 821BBCB4h case   29:*/		if ( regs.CR[0].eq ) { return 0x821BBD04;  }
		/* 821BBCB4h case   29:*/		return 0x821BBCB8;
		  /* 821BBCB8h */ case   30:  		/* rlwinm R9, R11, 15, 24, 31 */
		/* 821BBCB8h case   30:*/		cpu::op::rlwinm<0,15,24,31>(regs,&regs.R9,regs.R11);
		/* 821BBCB8h case   30:*/		return 0x821BBCBC;
		  /* 821BBCBCh */ case   31:  		/* cmplwi CR6, R9, 32 */
		/* 821BBCBCh case   31:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000020);
		/* 821BBCBCh case   31:*/		return 0x821BBCC0;
		  /* 821BBCC0h */ case   32:  		/* bc 12, CR6_LT, 12 */
		/* 821BBCC0h case   32:*/		if ( regs.CR[6].lt ) { return 0x821BBCCC;  }
		/* 821BBCC0h case   32:*/		return 0x821BBCC4;
		  /* 821BBCC4h */ case   33:  		/* cmplwi CR6, R9, 37 */
		/* 821BBCC4h case   33:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000025);
		/* 821BBCC4h case   33:*/		return 0x821BBCC8;
		  /* 821BBCC8h */ case   34:  		/* bc 4, CR6_GT, 60 */
		/* 821BBCC8h case   34:*/		if ( !regs.CR[6].gt ) { return 0x821BBD04;  }
		/* 821BBCC8h case   34:*/		return 0x821BBCCC;
	}
	return 0x821BBCCC;
} // Block from 821BBC40h-821BBCCCh (35 instructions)

//////////////////////////////////////////////////////
// Block at 821BBCCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBCCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBCCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBCCC);
		  /* 821BBCCCh */ case    0:  		/* rlwinm R11, R10, 25, 25, 31 */
		/* 821BBCCCh case    0:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R10);
		/* 821BBCCCh case    0:*/		return 0x821BBCD0;
		  /* 821BBCD0h */ case    1:  		/* cmplwi CR6, R11, 1 */
		/* 821BBCD0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 821BBCD0h case    1:*/		return 0x821BBCD4;
		  /* 821BBCD4h */ case    2:  		/* bc 12, CR6_LT, 16 */
		/* 821BBCD4h case    2:*/		if ( regs.CR[6].lt ) { return 0x821BBCE4;  }
		/* 821BBCD4h case    2:*/		return 0x821BBCD8;
		  /* 821BBCD8h */ case    3:  		/* cmplwi CR6, R11, 102 */
		/* 821BBCD8h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000066);
		/* 821BBCD8h case    3:*/		return 0x821BBCDC;
		  /* 821BBCDCh */ case    4:  		/* li R11, 1 */
		/* 821BBCDCh case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821BBCDCh case    4:*/		return 0x821BBCE0;
		  /* 821BBCE0h */ case    5:  		/* bc 4, CR6_GT, 8 */
		/* 821BBCE0h case    5:*/		if ( !regs.CR[6].gt ) { return 0x821BBCE8;  }
		/* 821BBCE0h case    5:*/		return 0x821BBCE4;
	}
	return 0x821BBCE4;
} // Block from 821BBCCCh-821BBCE4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BBCE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBCE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBCE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBCE4);
		  /* 821BBCE4h */ case    0:  		/* li R11, 0 */
		/* 821BBCE4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BBCE4h case    0:*/		return 0x821BBCE8;
	}
	return 0x821BBCE8;
} // Block from 821BBCE4h-821BBCE8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BBCE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBCE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBCE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBCE8);
		  /* 821BBCE8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821BBCE8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821BBCE8h case    0:*/		return 0x821BBCEC;
		  /* 821BBCECh */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 821BBCECh case    1:*/		if ( regs.CR[0].eq ) { return 0x821BBD04;  }
		/* 821BBCECh case    1:*/		return 0x821BBCF0;
		  /* 821BBCF0h */ case    2:  		/* cmplwi CR6, R9, 61 */
		/* 821BBCF0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x0000003D);
		/* 821BBCF0h case    2:*/		return 0x821BBCF4;
		  /* 821BBCF4h */ case    3:  		/* bc 12, CR6_LT, 12 */
		/* 821BBCF4h case    3:*/		if ( regs.CR[6].lt ) { return 0x821BBD00;  }
		/* 821BBCF4h case    3:*/		return 0x821BBCF8;
		  /* 821BBCF8h */ case    4:  		/* li R6, 1 */
		/* 821BBCF8h case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821BBCF8h case    4:*/		return 0x821BBCFC;
		  /* 821BBCFCh */ case    5:  		/* b 8 */
		/* 821BBCFCh case    5:*/		return 0x821BBD04;
		/* 821BBCFCh case    5:*/		return 0x821BBD00;
	}
	return 0x821BBD00;
} // Block from 821BBCE8h-821BBD00h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BBD00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBD00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBD00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBD00);
		  /* 821BBD00h */ case    0:  		/* li R5, 1 */
		/* 821BBD00h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 821BBD00h case    0:*/		return 0x821BBD04;
	}
	return 0x821BBD04;
} // Block from 821BBD00h-821BBD04h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BBD04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBD04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBD04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBD04);
		  /* 821BBD04h */ case    0:  		/* lwz R8, <#[R8 + 4]> */
		/* 821BBD04h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000004) );
		/* 821BBD04h case    0:*/		return 0x821BBD08;
		  /* 821BBD08h */ case    1:  		/* b -116 */
		/* 821BBD08h case    1:*/		return 0x821BBC94;
		/* 821BBD08h case    1:*/		return 0x821BBD0C;
	}
	return 0x821BBD0C;
} // Block from 821BBD04h-821BBD0Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BBD0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBD0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBD0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBD0C);
		  /* 821BBD0Ch */ case    0:  		/* rlwinm R11, R7, 0, 0, 30 */
		/* 821BBD0Ch case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R7);
		/* 821BBD0Ch case    0:*/		return 0x821BBD10;
		  /* 821BBD10h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 821BBD10h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 821BBD10h case    1:*/		return 0x821BBD14;
		  /* 821BBD14h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BBD14h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BBD14h case    2:*/		return 0x821BBD18;
		  /* 821BBD18h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 821BBD18h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BBD28;  }
		/* 821BBD18h case    3:*/		return 0x821BBD1C;
		  /* 821BBD1Ch */ case    4:  		/* mr R7, R11 */
		/* 821BBD1Ch case    4:*/		regs.R7 = regs.R11;
		/* 821BBD1Ch case    4:*/		return 0x821BBD20;
		  /* 821BBD20h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821BBD20h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BBD20h case    5:*/		return 0x821BBD24;
		  /* 821BBD24h */ case    6:  		/* bc 4, CR6_EQ, -164 */
		/* 821BBD24h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821BBC80;  }
		/* 821BBD24h case    6:*/		return 0x821BBD28;
	}
	return 0x821BBD28;
} // Block from 821BBD0Ch-821BBD28h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BBD28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBD28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBD28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBD28);
		  /* 821BBD28h */ case    0:  		/* rlwinm. R10, R6, 0, 24, 31 */
		/* 821BBD28h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R6);
		/* 821BBD28h case    0:*/		return 0x821BBD2C;
		  /* 821BBD2Ch */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 821BBD2Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x821BBD38;  }
		/* 821BBD2Ch case    1:*/		return 0x821BBD30;
		  /* 821BBD30h */ case    2:  		/* rlwinm. R11, R5, 0, 24, 31 */
		/* 821BBD30h case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R5);
		/* 821BBD30h case    2:*/		return 0x821BBD34;
		  /* 821BBD34h */ case    3:  		/* bc 12, CR0_EQ, 472 */
		/* 821BBD34h case    3:*/		if ( regs.CR[0].eq ) { return 0x821BBF0C;  }
		/* 821BBD34h case    3:*/		return 0x821BBD38;
	}
	return 0x821BBD38;
} // Block from 821BBD28h-821BBD38h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BBD38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBD38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBD38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBD38);
		  /* 821BBD38h */ case    0:  		/* lwz R9, <#[R27 + 48]> */
		/* 821BBD38h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x00000030) );
		/* 821BBD38h case    0:*/		return 0x821BBD3C;
		  /* 821BBD3Ch */ case    1:  		/* mr R11, R27 */
		/* 821BBD3Ch case    1:*/		regs.R11 = regs.R27;
		/* 821BBD3Ch case    1:*/		return 0x821BBD40;
		  /* 821BBD40h */ case    2:  		/* rlwinm. R9, R9, 2, 31, 31 */
		/* 821BBD40h case    2:*/		cpu::op::rlwinm<1,2,31,31>(regs,&regs.R9,regs.R9);
		/* 821BBD40h case    2:*/		return 0x821BBD44;
		  /* 821BBD44h */ case    3:  		/* bc 4, CR0_EQ, 456 */
		/* 821BBD44h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BBF0C;  }
		/* 821BBD44h case    3:*/		return 0x821BBD48;
		  /* 821BBD48h */ case    4:  		/* lwz R11, <#[R11 + 52]> */
		/* 821BBD48h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000034) );
		/* 821BBD48h case    4:*/		return 0x821BBD4C;
		  /* 821BBD4Ch */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821BBD4Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BBD4Ch case    5:*/		return 0x821BBD50;
		  /* 821BBD50h */ case    6:  		/* bc 12, CR6_EQ, 580 */
		/* 821BBD50h case    6:*/		if ( regs.CR[6].eq ) { return 0x821BBF94;  }
		/* 821BBD50h case    6:*/		return 0x821BBD54;
		  /* 821BBD54h */ case    7:  		/* lwz R9, <#[R11 + 48]> */
		/* 821BBD54h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000030) );
		/* 821BBD54h case    7:*/		return 0x821BBD58;
		  /* 821BBD58h */ case    8:  		/* rlwinm. R9, R9, 2, 31, 31 */
		/* 821BBD58h case    8:*/		cpu::op::rlwinm<1,2,31,31>(regs,&regs.R9,regs.R9);
		/* 821BBD58h case    8:*/		return 0x821BBD5C;
		  /* 821BBD5Ch */ case    9:  		/* bc 12, CR0_EQ, -20 */
		/* 821BBD5Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x821BBD48;  }
		/* 821BBD5Ch case    9:*/		return 0x821BBD60;
		  /* 821BBD60h */ case   10:  		/* cmplw CR6, R11, R27 */
		/* 821BBD60h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R27);
		/* 821BBD60h case   10:*/		return 0x821BBD64;
		  /* 821BBD64h */ case   11:  		/* bc 12, CR6_EQ, 424 */
		/* 821BBD64h case   11:*/		if ( regs.CR[6].eq ) { return 0x821BBF0C;  }
		/* 821BBD64h case   11:*/		return 0x821BBD68;
		  /* 821BBD68h */ case   12:  		/* lwz R9, <#[R21 + 48]> */
		/* 821BBD68h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R21 + 0x00000030) );
		/* 821BBD68h case   12:*/		return 0x821BBD6C;
		  /* 821BBD6Ch */ case   13:  		/* li R29, 0 */
		/* 821BBD6Ch case   13:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 821BBD6Ch case   13:*/		return 0x821BBD70;
		  /* 821BBD70h */ case   14:  		/* rlwinm R28, R9, 0, 0, 15 */
		/* 821BBD70h case   14:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R28,regs.R9);
		/* 821BBD70h case   14:*/		return 0x821BBD74;
		  /* 821BBD74h */ case   15:  		/* cmplw CR6, R28, R22 */
		/* 821BBD74h case   15:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R22);
		/* 821BBD74h case   15:*/		return 0x821BBD78;
		  /* 821BBD78h */ case   16:  		/* bc 12, CR6_EQ, 24 */
		/* 821BBD78h case   16:*/		if ( regs.CR[6].eq ) { return 0x821BBD90;  }
		/* 821BBD78h case   16:*/		return 0x821BBD7C;
		  /* 821BBD7Ch */ case   17:  		/* cmplwi CR6, R10, 0 */
		/* 821BBD7Ch case   17:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821BBD7Ch case   17:*/		return 0x821BBD80;
		  /* 821BBD80h */ case   18:  		/* bc 12, CR6_EQ, 16 */
		/* 821BBD80h case   18:*/		if ( regs.CR[6].eq ) { return 0x821BBD90;  }
		/* 821BBD80h case   18:*/		return 0x821BBD84;
		  /* 821BBD84h */ case   19:  		/* rlwinm. R10, R5, 0, 24, 31 */
		/* 821BBD84h case   19:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R5);
		/* 821BBD84h case   19:*/		return 0x821BBD88;
		  /* 821BBD88h */ case   20:  		/* bc 12, CR0_EQ, 8 */
		/* 821BBD88h case   20:*/		if ( regs.CR[0].eq ) { return 0x821BBD90;  }
		/* 821BBD88h case   20:*/		return 0x821BBD8C;
		  /* 821BBD8Ch */ case   21:  		/* li R29, 1 */
		/* 821BBD8Ch case   21:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 821BBD8Ch case   21:*/		return 0x821BBD90;
	}
	return 0x821BBD90;
} // Block from 821BBD38h-821BBD90h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821BBD90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBD90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBD90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBD90);
		  /* 821BBD90h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821BBD90h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821BBD90h case    0:*/		return 0x821BBD94;
		  /* 821BBD94h */ case    1:  		/* b 344 */
		/* 821BBD94h case    1:*/		return 0x821BBEEC;
		/* 821BBD94h case    1:*/		return 0x821BBD98;
		  /* 821BBD98h */ case    2:  		/* lwz R11, <#[R30 + 28]> */
		/* 821BBD98h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 821BBD98h case    2:*/		return 0x821BBD9C;
		  /* 821BBD9Ch */ case    3:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BBD9Ch case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BBD9Ch case    3:*/		return 0x821BBDA0;
		  /* 821BBDA0h */ case    4:  		/* bc 4, CR0_EQ, 140 */
		/* 821BBDA0h case    4:*/		if ( !regs.CR[0].eq ) { return 0x821BBE2C;  }
		/* 821BBDA0h case    4:*/		return 0x821BBDA4;
		  /* 821BBDA4h */ case    5:  		/* mr R10, R11 */
		/* 821BBDA4h case    5:*/		regs.R10 = regs.R11;
		/* 821BBDA4h case    5:*/		return 0x821BBDA8;
		  /* 821BBDA8h */ case    6:  		/* cmplwi CR0, R11, 0 */
		/* 821BBDA8h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821BBDA8h case    6:*/		return 0x821BBDAC;
		  /* 821BBDACh */ case    7:  		/* bc 12, CR0_EQ, 128 */
		/* 821BBDACh case    7:*/		if ( regs.CR[0].eq ) { return 0x821BBE2C;  }
		/* 821BBDACh case    7:*/		return 0x821BBDB0;
		  /* 821BBDB0h */ case    8:  		/* cmplw CR6, R28, R22 */
		/* 821BBDB0h case    8:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R22);
		/* 821BBDB0h case    8:*/		return 0x821BBDB4;
		  /* 821BBDB4h */ case    9:  		/* bc 12, CR6_EQ, 44 */
		/* 821BBDB4h case    9:*/		if ( regs.CR[6].eq ) { return 0x821BBDE0;  }
		/* 821BBDB4h case    9:*/		return 0x821BBDB8;
		  /* 821BBDB8h */ case   10:  		/* lwz R11, <#[R10 + 8]> */
		/* 821BBDB8h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 821BBDB8h case   10:*/		return 0x821BBDBC;
		  /* 821BBDBCh */ case   11:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821BBDBCh case   11:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821BBDBCh case   11:*/		return 0x821BBDC0;
		  /* 821BBDC0h */ case   12:  		/* cmplwi CR6, R11, 96 */
		/* 821BBDC0h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000060);
		/* 821BBDC0h case   12:*/		return 0x821BBDC4;
		  /* 821BBDC4h */ case   13:  		/* bc 12, CR6_LT, 16 */
		/* 821BBDC4h case   13:*/		if ( regs.CR[6].lt ) { return 0x821BBDD4;  }
		/* 821BBDC4h case   13:*/		return 0x821BBDC8;
		  /* 821BBDC8h */ case   14:  		/* cmplwi CR6, R11, 102 */
		/* 821BBDC8h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000066);
		/* 821BBDC8h case   14:*/		return 0x821BBDCC;
		  /* 821BBDCCh */ case   15:  		/* li R11, 1 */
		/* 821BBDCCh case   15:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821BBDCCh case   15:*/		return 0x821BBDD0;
		  /* 821BBDD0h */ case   16:  		/* bc 4, CR6_GT, 8 */
		/* 821BBDD0h case   16:*/		if ( !regs.CR[6].gt ) { return 0x821BBDD8;  }
		/* 821BBDD0h case   16:*/		return 0x821BBDD4;
	}
	return 0x821BBDD4;
} // Block from 821BBD90h-821BBDD4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 821BBDD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBDD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBDD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBDD4);
		  /* 821BBDD4h */ case    0:  		/* li R11, 0 */
		/* 821BBDD4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BBDD4h case    0:*/		return 0x821BBDD8;
	}
	return 0x821BBDD8;
} // Block from 821BBDD4h-821BBDD8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BBDD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBDD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBDD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBDD8);
		  /* 821BBDD8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821BBDD8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821BBDD8h case    0:*/		return 0x821BBDDC;
		  /* 821BBDDCh */ case    1:  		/* bc 4, CR0_EQ, 76 */
		/* 821BBDDCh case    1:*/		if ( !regs.CR[0].eq ) { return 0x821BBE28;  }
		/* 821BBDDCh case    1:*/		return 0x821BBDE0;
	}
	return 0x821BBDE0;
} // Block from 821BBDD8h-821BBDE0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BBDE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBDE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBDE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBDE0);
		  /* 821BBDE0h */ case    0:  		/* lwz R11, <#[R10 + 8]> */
		/* 821BBDE0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000008) );
		/* 821BBDE0h case    0:*/		return 0x821BBDE4;
		  /* 821BBDE4h */ case    1:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821BBDE4h case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821BBDE4h case    1:*/		return 0x821BBDE8;
		  /* 821BBDE8h */ case    2:  		/* cmplwi CR6, R11, 91 */
		/* 821BBDE8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005B);
		/* 821BBDE8h case    2:*/		return 0x821BBDEC;
		  /* 821BBDECh */ case    3:  		/* bc 12, CR6_LT, 16 */
		/* 821BBDECh case    3:*/		if ( regs.CR[6].lt ) { return 0x821BBDFC;  }
		/* 821BBDECh case    3:*/		return 0x821BBDF0;
		  /* 821BBDF0h */ case    4:  		/* cmplwi CR6, R11, 94 */
		/* 821BBDF0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005E);
		/* 821BBDF0h case    4:*/		return 0x821BBDF4;
		  /* 821BBDF4h */ case    5:  		/* li R11, 1 */
		/* 821BBDF4h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821BBDF4h case    5:*/		return 0x821BBDF8;
		  /* 821BBDF8h */ case    6:  		/* bc 4, CR6_GT, 8 */
		/* 821BBDF8h case    6:*/		if ( !regs.CR[6].gt ) { return 0x821BBE00;  }
		/* 821BBDF8h case    6:*/		return 0x821BBDFC;
	}
	return 0x821BBDFC;
} // Block from 821BBDE0h-821BBDFCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BBDFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBDFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBDFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBDFC);
		  /* 821BBDFCh */ case    0:  		/* li R11, 0 */
		/* 821BBDFCh case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BBDFCh case    0:*/		return 0x821BBE00;
	}
	return 0x821BBE00;
} // Block from 821BBDFCh-821BBE00h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BBE00h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBE00( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBE00) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBE00);
		  /* 821BBE00h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821BBE00h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821BBE00h case    0:*/		return 0x821BBE04;
		  /* 821BBE04h */ case    1:  		/* bc 4, CR0_EQ, 36 */
		/* 821BBE04h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821BBE28;  }
		/* 821BBE04h case    1:*/		return 0x821BBE08;
		  /* 821BBE08h */ case    2:  		/* rlwinm R11, R10, 0, 0, 30 */
		/* 821BBE08h case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R10);
		/* 821BBE08h case    2:*/		return 0x821BBE0C;
		  /* 821BBE0Ch */ case    3:  		/* lwz R11, <#[R11 + 40]> */
		/* 821BBE0Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 821BBE0Ch case    3:*/		return 0x821BBE10;
		  /* 821BBE10h */ case    4:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BBE10h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BBE10h case    4:*/		return 0x821BBE14;
		  /* 821BBE14h */ case    5:  		/* bc 4, CR0_EQ, 24 */
		/* 821BBE14h case    5:*/		if ( !regs.CR[0].eq ) { return 0x821BBE2C;  }
		/* 821BBE14h case    5:*/		return 0x821BBE18;
		  /* 821BBE18h */ case    6:  		/* mr R10, R11 */
		/* 821BBE18h case    6:*/		regs.R10 = regs.R11;
		/* 821BBE18h case    6:*/		return 0x821BBE1C;
		  /* 821BBE1Ch */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 821BBE1Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BBE1Ch case    7:*/		return 0x821BBE20;
		  /* 821BBE20h */ case    8:  		/* bc 4, CR6_EQ, -112 */
		/* 821BBE20h case    8:*/		if ( !regs.CR[6].eq ) { return 0x821BBDB0;  }
		/* 821BBE20h case    8:*/		return 0x821BBE24;
		  /* 821BBE24h */ case    9:  		/* b 8 */
		/* 821BBE24h case    9:*/		return 0x821BBE2C;
		/* 821BBE24h case    9:*/		return 0x821BBE28;
	}
	return 0x821BBE28;
} // Block from 821BBE00h-821BBE28h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821BBE28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBE28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBE28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBE28);
		  /* 821BBE28h */ case    0:  		/* li R29, 1 */
		/* 821BBE28h case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 821BBE28h case    0:*/		return 0x821BBE2C;
	}
	return 0x821BBE2C;
} // Block from 821BBE28h-821BBE2Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BBE2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBE2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBE2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBE2C);
		  /* 821BBE2Ch */ case    0:  		/* cmplw CR6, R28, R22 */
		/* 821BBE2Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R22);
		/* 821BBE2Ch case    0:*/		return 0x821BBE30;
		  /* 821BBE30h */ case    1:  		/* bc 12, CR6_EQ, 176 */
		/* 821BBE30h case    1:*/		if ( regs.CR[6].eq ) { return 0x821BBEE0;  }
		/* 821BBE30h case    1:*/		return 0x821BBE34;
		  /* 821BBE34h */ case    2:  		/* lwz R11, <#[R30 + 36]> */
		/* 821BBE34h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000024) );
		/* 821BBE34h case    2:*/		return 0x821BBE38;
		  /* 821BBE38h */ case    3:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BBE38h case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BBE38h case    3:*/		return 0x821BBE3C;
		  /* 821BBE3Ch */ case    4:  		/* bc 4, CR0_EQ, 164 */
		/* 821BBE3Ch case    4:*/		if ( !regs.CR[0].eq ) { return 0x821BBEE0;  }
		/* 821BBE3Ch case    4:*/		return 0x821BBE40;
		  /* 821BBE40h */ case    5:  		/* mr R31, R11 */
		/* 821BBE40h case    5:*/		regs.R31 = regs.R11;
		/* 821BBE40h case    5:*/		return 0x821BBE44;
		  /* 821BBE44h */ case    6:  		/* cmplwi CR0, R11, 0 */
		/* 821BBE44h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821BBE44h case    6:*/		return 0x821BBE48;
		  /* 821BBE48h */ case    7:  		/* bc 12, CR0_EQ, 152 */
		/* 821BBE48h case    7:*/		if ( regs.CR[0].eq ) { return 0x821BBEE0;  }
		/* 821BBE48h case    7:*/		return 0x821BBE4C;
		  /* 821BBE4Ch */ case    8:  		/* lwz R9, <#[R31 + 8]> */
		/* 821BBE4Ch case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000008) );
		/* 821BBE4Ch case    8:*/		return 0x821BBE50;
		  /* 821BBE50h */ case    9:  		/* rlwinm R10, R9, 25, 25, 31 */
		/* 821BBE50h case    9:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R9);
		/* 821BBE50h case    9:*/		return 0x821BBE54;
		  /* 821BBE54h */ case   10:  		/* cmplwi CR6, R10, 83 */
		/* 821BBE54h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000053);
		/* 821BBE54h case   10:*/		return 0x821BBE58;
		  /* 821BBE58h */ case   11:  		/* bc 12, CR6_LT, 16 */
		/* 821BBE58h case   11:*/		if ( regs.CR[6].lt ) { return 0x821BBE68;  }
		/* 821BBE58h case   11:*/		return 0x821BBE5C;
		  /* 821BBE5Ch */ case   12:  		/* cmplwi CR6, R10, 95 */
		/* 821BBE5Ch case   12:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000005F);
		/* 821BBE5Ch case   12:*/		return 0x821BBE60;
		  /* 821BBE60h */ case   13:  		/* li R11, 1 */
		/* 821BBE60h case   13:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821BBE60h case   13:*/		return 0x821BBE64;
		  /* 821BBE64h */ case   14:  		/* bc 4, CR6_GT, 8 */
		/* 821BBE64h case   14:*/		if ( !regs.CR[6].gt ) { return 0x821BBE6C;  }
		/* 821BBE64h case   14:*/		return 0x821BBE68;
	}
	return 0x821BBE68;
} // Block from 821BBE2Ch-821BBE68h (15 instructions)

//////////////////////////////////////////////////////
// Block at 821BBE68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBE68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBE68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBE68);
		  /* 821BBE68h */ case    0:  		/* li R11, 0 */
		/* 821BBE68h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BBE68h case    0:*/		return 0x821BBE6C;
	}
	return 0x821BBE6C;
} // Block from 821BBE68h-821BBE6Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BBE6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBE6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBE6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBE6C);
		  /* 821BBE6Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821BBE6Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821BBE6Ch case    0:*/		return 0x821BBE70;
		  /* 821BBE70h */ case    1:  		/* bc 12, CR0_EQ, 76 */
		/* 821BBE70h case    1:*/		if ( regs.CR[0].eq ) { return 0x821BBEBC;  }
		/* 821BBE70h case    1:*/		return 0x821BBE74;
		  /* 821BBE74h */ case    2:  		/* rlwinm. R11, R9, 15, 31, 31 */
		/* 821BBE74h case    2:*/		cpu::op::rlwinm<1,15,31,31>(regs,&regs.R11,regs.R9);
		/* 821BBE74h case    2:*/		return 0x821BBE78;
		  /* 821BBE78h */ case    3:  		/* bc 12, CR0_EQ, 68 */
		/* 821BBE78h case    3:*/		if ( regs.CR[0].eq ) { return 0x821BBEBC;  }
		/* 821BBE78h case    3:*/		return 0x821BBE7C;
		  /* 821BBE7Ch */ case    4:  		/* cmplwi CR6, R10, 90 */
		/* 821BBE7Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000005A);
		/* 821BBE7Ch case    4:*/		return 0x821BBE80;
		  /* 821BBE80h */ case    5:  		/* bc 4, CR6_EQ, 92 */
		/* 821BBE80h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821BBEDC;  }
		/* 821BBE80h case    5:*/		return 0x821BBE84;
		  /* 821BBE84h */ case    6:  		/* lwz R11, <#[R30 + 76]> */
		/* 821BBE84h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000004C) );
		/* 821BBE84h case    6:*/		return 0x821BBE88;
		  /* 821BBE88h */ case    7:  		/* rlwinm. R11, R11, 10, 31, 31 */
		/* 821BBE88h case    7:*/		cpu::op::rlwinm<1,10,31,31>(regs,&regs.R11,regs.R11);
		/* 821BBE88h case    7:*/		return 0x821BBE8C;
		  /* 821BBE8Ch */ case    8:  		/* bc 12, CR0_EQ, 80 */
		/* 821BBE8Ch case    8:*/		if ( regs.CR[0].eq ) { return 0x821BBEDC;  }
		/* 821BBE8Ch case    8:*/		return 0x821BBE90;
		  /* 821BBE90h */ case    9:  		/* mr R4, R21 */
		/* 821BBE90h case    9:*/		regs.R4 = regs.R21;
		/* 821BBE90h case    9:*/		return 0x821BBE94;
		  /* 821BBE94h */ case   10:  		/* mr R3, R31 */
		/* 821BBE94h case   10:*/		regs.R3 = regs.R31;
		/* 821BBE94h case   10:*/		return 0x821BBE98;
		  /* 821BBE98h */ case   11:  		/* bl -358160 */
		/* 821BBE98h case   11:*/		regs.LR = 0x821BBE9C; return 0x82164788;
		/* 821BBE98h case   11:*/		return 0x821BBE9C;
		  /* 821BBE9Ch */ case   12:  		/* cmpwi CR6, R3, 4 */
		/* 821BBE9Ch case   12:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000004);
		/* 821BBE9Ch case   12:*/		return 0x821BBEA0;
		  /* 821BBEA0h */ case   13:  		/* bc 12, CR6_EQ, 60 */
		/* 821BBEA0h case   13:*/		if ( regs.CR[6].eq ) { return 0x821BBEDC;  }
		/* 821BBEA0h case   13:*/		return 0x821BBEA4;
		  /* 821BBEA4h */ case   14:  		/* cmpwi CR6, R3, 1 */
		/* 821BBEA4h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000001);
		/* 821BBEA4h case   14:*/		return 0x821BBEA8;
		  /* 821BBEA8h */ case   15:  		/* bc 12, CR6_EQ, 52 */
		/* 821BBEA8h case   15:*/		if ( regs.CR[6].eq ) { return 0x821BBEDC;  }
		/* 821BBEA8h case   15:*/		return 0x821BBEAC;
		  /* 821BBEACh */ case   16:  		/* cmpwi CR6, R3, 9 */
		/* 821BBEACh case   16:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000009);
		/* 821BBEACh case   16:*/		return 0x821BBEB0;
		  /* 821BBEB0h */ case   17:  		/* bc 12, CR6_EQ, 44 */
		/* 821BBEB0h case   17:*/		if ( regs.CR[6].eq ) { return 0x821BBEDC;  }
		/* 821BBEB0h case   17:*/		return 0x821BBEB4;
		  /* 821BBEB4h */ case   18:  		/* cmpwi CR6, R3, 8 */
		/* 821BBEB4h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000008);
		/* 821BBEB4h case   18:*/		return 0x821BBEB8;
		  /* 821BBEB8h */ case   19:  		/* bc 12, CR6_EQ, 36 */
		/* 821BBEB8h case   19:*/		if ( regs.CR[6].eq ) { return 0x821BBEDC;  }
		/* 821BBEB8h case   19:*/		return 0x821BBEBC;
	}
	return 0x821BBEBC;
} // Block from 821BBE6Ch-821BBEBCh (20 instructions)

//////////////////////////////////////////////////////
// Block at 821BBEBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBEBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBEBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBEBC);
		  /* 821BBEBCh */ case    0:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821BBEBCh case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821BBEBCh case    0:*/		return 0x821BBEC0;
		  /* 821BBEC0h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 821BBEC0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 821BBEC0h case    1:*/		return 0x821BBEC4;
		  /* 821BBEC4h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BBEC4h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BBEC4h case    2:*/		return 0x821BBEC8;
		  /* 821BBEC8h */ case    3:  		/* bc 4, CR0_EQ, 24 */
		/* 821BBEC8h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BBEE0;  }
		/* 821BBEC8h case    3:*/		return 0x821BBECC;
		  /* 821BBECCh */ case    4:  		/* mr R31, R11 */
		/* 821BBECCh case    4:*/		regs.R31 = regs.R11;
		/* 821BBECCh case    4:*/		return 0x821BBED0;
		  /* 821BBED0h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821BBED0h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BBED0h case    5:*/		return 0x821BBED4;
		  /* 821BBED4h */ case    6:  		/* bc 4, CR6_EQ, -136 */
		/* 821BBED4h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821BBE4C;  }
		/* 821BBED4h case    6:*/		return 0x821BBED8;
		  /* 821BBED8h */ case    7:  		/* b 8 */
		/* 821BBED8h case    7:*/		return 0x821BBEE0;
		/* 821BBED8h case    7:*/		return 0x821BBEDC;
	}
	return 0x821BBEDC;
} // Block from 821BBEBCh-821BBEDCh (8 instructions)

//////////////////////////////////////////////////////
// Block at 821BBEDCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBEDC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBEDC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBEDC);
		  /* 821BBEDCh */ case    0:  		/* li R29, 1 */
		/* 821BBEDCh case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x1);
		/* 821BBEDCh case    0:*/		return 0x821BBEE0;
	}
	return 0x821BBEE0;
} // Block from 821BBEDCh-821BBEE0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BBEE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBEE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBEE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBEE0);
		  /* 821BBEE0h */ case    0:  		/* cmplw CR6, R30, R27 */
		/* 821BBEE0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R27);
		/* 821BBEE0h case    0:*/		return 0x821BBEE4;
		  /* 821BBEE4h */ case    1:  		/* bc 12, CR6_EQ, 32 */
		/* 821BBEE4h case    1:*/		if ( regs.CR[6].eq ) { return 0x821BBF04;  }
		/* 821BBEE4h case    1:*/		return 0x821BBEE8;
		  /* 821BBEE8h */ case    2:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 821BBEE8h case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 821BBEE8h case    2:*/		return 0x821BBEEC;
	}
	return 0x821BBEEC;
} // Block from 821BBEE0h-821BBEECh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BBEECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBEEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBEEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBEEC);
		  /* 821BBEECh */ case    0:  		/* lwz R11, <#[R11 + 4]> */
		/* 821BBEECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821BBEECh case    0:*/		return 0x821BBEF0;
		  /* 821BBEF0h */ case    1:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BBEF0h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BBEF0h case    1:*/		return 0x821BBEF4;
		  /* 821BBEF4h */ case    2:  		/* bc 4, CR0_EQ, 16 */
		/* 821BBEF4h case    2:*/		if ( !regs.CR[0].eq ) { return 0x821BBF04;  }
		/* 821BBEF4h case    2:*/		return 0x821BBEF8;
		  /* 821BBEF8h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 821BBEF8h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BBEF8h case    3:*/		return 0x821BBEFC;
		  /* 821BBEFCh */ case    4:  		/* mr R30, R11 */
		/* 821BBEFCh case    4:*/		regs.R30 = regs.R11;
		/* 821BBEFCh case    4:*/		return 0x821BBF00;
		  /* 821BBF00h */ case    5:  		/* bc 4, CR6_EQ, -360 */
		/* 821BBF00h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821BBD98;  }
		/* 821BBF00h case    5:*/		return 0x821BBF04;
	}
	return 0x821BBF04;
} // Block from 821BBEECh-821BBF04h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BBF04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBF04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBF04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBF04);
		  /* 821BBF04h */ case    0:  		/* rlwinm. R11, R29, 0, 24, 31 */
		/* 821BBF04h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R29);
		/* 821BBF04h case    0:*/		return 0x821BBF08;
		  /* 821BBF08h */ case    1:  		/* bc 4, CR0_EQ, 28 */
		/* 821BBF08h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821BBF24;  }
		/* 821BBF08h case    1:*/		return 0x821BBF0C;
	}
	return 0x821BBF0C;
} // Block from 821BBF04h-821BBF0Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BBF0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBF0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBF0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBF0C);
		  /* 821BBF0Ch */ case    0:  		/* rlwinm R11, R27, 0, 0, 30 */
		/* 821BBF0Ch case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R27);
		/* 821BBF0Ch case    0:*/		return 0x821BBF10;
		  /* 821BBF10h */ case    1:  		/* lwz R11, <#[R11]> */
		/* 821BBF10h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821BBF10h case    1:*/		return 0x821BBF14;
		  /* 821BBF14h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BBF14h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BBF14h case    2:*/		return 0x821BBF18;
		  /* 821BBF18h */ case    3:  		/* bc 12, CR0_EQ, -712 */
		/* 821BBF18h case    3:*/		if ( regs.CR[0].eq ) { return 0x821BBC50;  }
		/* 821BBF18h case    3:*/		return 0x821BBF1C;
	}
	return 0x821BBF1C;
} // Block from 821BBF0Ch-821BBF1Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BBF1Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBF1C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBF1C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBF1C);
		  /* 821BBF1Ch */ case    0:  		/* li R27, 0 */
		/* 821BBF1Ch case    0:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 821BBF1Ch case    0:*/		return 0x821BBF20;
		  /* 821BBF20h */ case    1:  		/* b -712 */
		/* 821BBF20h case    1:*/		return 0x821BBC58;
		/* 821BBF20h case    1:*/		return 0x821BBF24;
	}
	return 0x821BBF24;
} // Block from 821BBF1Ch-821BBF24h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BBF24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBF24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBF24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBF24);
		  /* 821BBF24h */ case    0:  		/* lwz R11, <#[R27 + 12]> */
		/* 821BBF24h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000000C) );
		/* 821BBF24h case    0:*/		return 0x821BBF28;
		  /* 821BBF28h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 821BBF28h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BBF28h case    1:*/		return 0x821BBF2C;
		  /* 821BBF2Ch */ case    2:  		/* bc 12, CR6_EQ, 116 */
		/* 821BBF2Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x821BBFA0;  }
		/* 821BBF2Ch case    2:*/		return 0x821BBF30;
		  /* 821BBF30h */ case    3:  		/* lwz R4, <#[R11]> */
		/* 821BBF30h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000000) );
		/* 821BBF30h case    3:*/		return 0x821BBF34;
		  /* 821BBF34h */ case    4:  		/* cmplwi CR6, R4, 0 */
		/* 821BBF34h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 821BBF34h case    4:*/		return 0x821BBF38;
		  /* 821BBF38h */ case    5:  		/* bc 12, CR6_EQ, 104 */
		/* 821BBF38h case    5:*/		if ( regs.CR[6].eq ) { return 0x821BBFA0;  }
		/* 821BBF38h case    5:*/		return 0x821BBF3C;
		  /* 821BBF3Ch */ case    6:  		/* mr R3, R21 */
		/* 821BBF3Ch case    6:*/		regs.R3 = regs.R21;
		/* 821BBF3Ch case    6:*/		return 0x821BBF40;
		  /* 821BBF40h */ case    7:  		/* bl -252760 */
		/* 821BBF40h case    7:*/		regs.LR = 0x821BBF44; return 0x8217E3E8;
		/* 821BBF40h case    7:*/		return 0x821BBF44;
		  /* 821BBF44h */ case    8:  		/* lwz R11, <#[R21 + 4]> */
		/* 821BBF44h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000004) );
		/* 821BBF44h case    8:*/		return 0x821BBF48;
		  /* 821BBF48h */ case    9:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BBF48h case    9:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BBF48h case    9:*/		return 0x821BBF4C;
		  /* 821BBF4Ch */ case   10:  		/* bc 4, CR0_EQ, -1204 */
		/* 821BBF4Ch case   10:*/		if ( !regs.CR[0].eq ) { return 0x821BBA98;  }
		/* 821BBF4Ch case   10:*/		return 0x821BBF50;
		  /* 821BBF50h */ case   11:  		/* cmplwi CR0, R11, 0 */
		/* 821BBF50h case   11:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821BBF50h case   11:*/		return 0x821BBF54;
		  /* 821BBF54h */ case   12:  		/* bc 12, CR0_EQ, -1212 */
		/* 821BBF54h case   12:*/		if ( regs.CR[0].eq ) { return 0x821BBA98;  }
		/* 821BBF54h case   12:*/		return 0x821BBF58;
		  /* 821BBF58h */ case   13:  		/* lwz R10, <#[R11 + 48]> */
		/* 821BBF58h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 821BBF58h case   13:*/		return 0x821BBF5C;
		  /* 821BBF5Ch */ case   14:  		/* rlwinm. R9, R10, 2, 31, 31 */
		/* 821BBF5Ch case   14:*/		cpu::op::rlwinm<1,2,31,31>(regs,&regs.R9,regs.R10);
		/* 821BBF5Ch case   14:*/		return 0x821BBF60;
		  /* 821BBF60h */ case   15:  		/* bc 12, CR0_EQ, 12 */
		/* 821BBF60h case   15:*/		if ( regs.CR[0].eq ) { return 0x821BBF6C;  }
		/* 821BBF60h case   15:*/		return 0x821BBF64;
		  /* 821BBF64h */ case   16:  		/* rlwinm R10, R10, 0, 2, 0 */
		/* 821BBF64h case   16:*/		cpu::op::rlwinm<0,0,2,0>(regs,&regs.R10,regs.R10);
		/* 821BBF64h case   16:*/		return 0x821BBF68;
		  /* 821BBF68h */ case   17:  		/* stw R10, <#[R11 + 48]> */
		/* 821BBF68h case   17:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 821BBF68h case   17:*/		return 0x821BBF6C;
	}
	return 0x821BBF6C;
} // Block from 821BBF24h-821BBF6Ch (18 instructions)

//////////////////////////////////////////////////////
// Block at 821BBF6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBF6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBF6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBF6C);
		  /* 821BBF6Ch */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821BBF6Ch case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821BBF6Ch case    0:*/		return 0x821BBF70;
		  /* 821BBF70h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 821BBF70h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821BBF70h case    1:*/		return 0x821BBF74;
		  /* 821BBF74h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BBF74h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BBF74h case    2:*/		return 0x821BBF78;
		  /* 821BBF78h */ case    3:  		/* bc 4, CR0_EQ, -1248 */
		/* 821BBF78h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BBA98;  }
		/* 821BBF78h case    3:*/		return 0x821BBF7C;
		  /* 821BBF7Ch */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 821BBF7Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BBF7Ch case    4:*/		return 0x821BBF80;
		  /* 821BBF80h */ case    5:  		/* bc 4, CR6_EQ, -40 */
		/* 821BBF80h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821BBF58;  }
		/* 821BBF80h case    5:*/		return 0x821BBF84;
		  /* 821BBF84h */ case    6:  		/* b -1260 */
		/* 821BBF84h case    6:*/		return 0x821BBA98;
		/* 821BBF84h case    6:*/		return 0x821BBF88;
	}
	return 0x821BBF88;
} // Block from 821BBF6Ch-821BBF88h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BBF88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBF88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBF88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBF88);
		  /* 821BBF88h */ case    0:  		/* li R4, 4800 */
		/* 821BBF88h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 821BBF88h case    0:*/		return 0x821BBF8C;
		  /* 821BBF8Ch */ case    1:  		/* mr R3, R21 */
		/* 821BBF8Ch case    1:*/		regs.R3 = regs.R21;
		/* 821BBF8Ch case    1:*/		return 0x821BBF90;
		  /* 821BBF90h */ case    2:  		/* bl -434472 */
		/* 821BBF90h case    2:*/		regs.LR = 0x821BBF94; return 0x82151E68;
		/* 821BBF90h case    2:*/		return 0x821BBF94;
	}
	return 0x821BBF94;
} // Block from 821BBF88h-821BBF94h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BBF94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBF94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBF94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBF94);
		  /* 821BBF94h */ case    0:  		/* li R4, 4800 */
		/* 821BBF94h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 821BBF94h case    0:*/		return 0x821BBF98;
		  /* 821BBF98h */ case    1:  		/* mr R3, R21 */
		/* 821BBF98h case    1:*/		regs.R3 = regs.R21;
		/* 821BBF98h case    1:*/		return 0x821BBF9C;
		  /* 821BBF9Ch */ case    2:  		/* bl -434484 */
		/* 821BBF9Ch case    2:*/		regs.LR = 0x821BBFA0; return 0x82151E68;
		/* 821BBF9Ch case    2:*/		return 0x821BBFA0;
	}
	return 0x821BBFA0;
} // Block from 821BBF94h-821BBFA0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BBFA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBFA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBFA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBFA0);
		  /* 821BBFA0h */ case    0:  		/* li R4, 4800 */
		/* 821BBFA0h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 821BBFA0h case    0:*/		return 0x821BBFA4;
		  /* 821BBFA4h */ case    1:  		/* mr R3, R21 */
		/* 821BBFA4h case    1:*/		regs.R3 = regs.R21;
		/* 821BBFA4h case    1:*/		return 0x821BBFA8;
		  /* 821BBFA8h */ case    2:  		/* bl -434496 */
		/* 821BBFA8h case    2:*/		regs.LR = 0x821BBFAC; return 0x82151E68;
		/* 821BBFA8h case    2:*/		return 0x821BBFAC;
	}
	return 0x821BBFAC;
} // Block from 821BBFA0h-821BBFACh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BBFACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBFAC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBFAC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBFAC);
		  /* 821BBFACh */ case    0:  		/* cmplwi CR6, R26, 0 */
		/* 821BBFACh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 821BBFACh case    0:*/		return 0x821BBFB0;
		  /* 821BBFB0h */ case    1:  		/* bc 4, CR6_EQ, 840 */
		/* 821BBFB0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BC2F8;  }
		/* 821BBFB0h case    1:*/		return 0x821BBFB4;
		  /* 821BBFB4h */ case    2:  		/* cmplwi CR0, R23, 0 */
		/* 821BBFB4h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R23,0x00000000);
		/* 821BBFB4h case    2:*/		return 0x821BBFB8;
		  /* 821BBFB8h */ case    3:  		/* bc 12, CR0_EQ, 832 */
		/* 821BBFB8h case    3:*/		if ( regs.CR[0].eq ) { return 0x821BC2F8;  }
		/* 821BBFB8h case    3:*/		return 0x821BBFBC;
		  /* 821BBFBCh */ case    4:  		/* lwz R11, <#[R23 + 36]> */
		/* 821BBFBCh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000024) );
		/* 821BBFBCh case    4:*/		return 0x821BBFC0;
		  /* 821BBFC0h */ case    5:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BBFC0h case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BBFC0h case    5:*/		return 0x821BBFC4;
		  /* 821BBFC4h */ case    6:  		/* bc 4, CR0_EQ, 792 */
		/* 821BBFC4h case    6:*/		if ( !regs.CR[0].eq ) { return 0x821BC2DC;  }
		/* 821BBFC4h case    6:*/		return 0x821BBFC8;
	}
	return 0x821BBFC8;
} // Block from 821BBFACh-821BBFC8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BBFC8h
// Function '?Clean@Compiler@D3DXShader@@AAAXXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBFC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBFC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBFC8);
		  /* 821BBFC8h */ case    0:  		/* mr R24, R11 */
		/* 821BBFC8h case    0:*/		regs.R24 = regs.R11;
		/* 821BBFC8h case    0:*/		return 0x821BBFCC;
		  /* 821BBFCCh */ case    1:  		/* cmplwi CR0, R11, 0 */
		/* 821BBFCCh case    1:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821BBFCCh case    1:*/		return 0x821BBFD0;
		  /* 821BBFD0h */ case    2:  		/* bc 12, CR0_EQ, 780 */
		/* 821BBFD0h case    2:*/		if ( regs.CR[0].eq ) { return 0x821BC2DC;  }
		/* 821BBFD0h case    2:*/		return 0x821BBFD4;
		  /* 821BBFD4h */ case    3:  		/* lwz R11, <#[R24 + 8]> */
		/* 821BBFD4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000008) );
		/* 821BBFD4h case    3:*/		return 0x821BBFD8;
		  /* 821BBFD8h */ case    4:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821BBFD8h case    4:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821BBFD8h case    4:*/		return 0x821BBFDC;
		  /* 821BBFDCh */ case    5:  		/* cmplwi CR6, R11, 83 */
		/* 821BBFDCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000053);
		/* 821BBFDCh case    5:*/		return 0x821BBFE0;
		  /* 821BBFE0h */ case    6:  		/* bc 12, CR6_EQ, 12 */
		/* 821BBFE0h case    6:*/		if ( regs.CR[6].eq ) { return 0x821BBFEC;  }
		/* 821BBFE0h case    6:*/		return 0x821BBFE4;
		  /* 821BBFE4h */ case    7:  		/* cmplwi CR6, R11, 117 */
		/* 821BBFE4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000075);
		/* 821BBFE4h case    7:*/		return 0x821BBFE8;
		  /* 821BBFE8h */ case    8:  		/* bc 4, CR6_EQ, 728 */
		/* 821BBFE8h case    8:*/		if ( !regs.CR[6].eq ) { return 0x821BC2C0;  }
		/* 821BBFE8h case    8:*/		return 0x821BBFEC;
	}
	return 0x821BBFEC;
} // Block from 821BBFC8h-821BBFECh (9 instructions)

//////////////////////////////////////////////////////
// Block at 821BBFECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BBFEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BBFEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BBFEC);
		  /* 821BBFECh */ case    0:  		/* li R26, 0 */
		/* 821BBFECh case    0:*/		cpu::op::li<0>(regs,&regs.R26,0x0);
		/* 821BBFECh case    0:*/		return 0x821BBFF0;
		  /* 821BBFF0h */ case    1:  		/* lwz R27, <#[R24]> */
		/* 821BBFF0h case    1:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R24 + 0x00000000) );
		/* 821BBFF0h case    1:*/		return 0x821BBFF4;
		  /* 821BBFF4h */ case    2:  		/* li R30, 0 */
		/* 821BBFF4h case    2:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 821BBFF4h case    2:*/		return 0x821BBFF8;
		  /* 821BBFF8h */ case    3:  		/* stw R26, <#[R1 + 80]> */
		/* 821BBFF8h case    3:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R1 + 0x00000050) );
		/* 821BBFF8h case    3:*/		return 0x821BBFFC;
		  /* 821BBFFCh */ case    4:  		/* li R28, 0 */
		/* 821BBFFCh case    4:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 821BBFFCh case    4:*/		return 0x821BC000;
		  /* 821BC000h */ case    5:  		/* stw R30, <#[R1 + 84]> */
		/* 821BC000h case    5:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000054) );
		/* 821BC000h case    5:*/		return 0x821BC004;
		  /* 821BC004h */ case    6:  		/* li R25, 0 */
		/* 821BC004h case    6:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 821BC004h case    6:*/		return 0x821BC008;
		  /* 821BC008h */ case    7:  		/* cmplwi CR6, R27, 0 */
		/* 821BC008h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 821BC008h case    7:*/		return 0x821BC00C;
		  /* 821BC00Ch */ case    8:  		/* bc 12, CR6_EQ, 352 */
		/* 821BC00Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x821BC16C;  }
		/* 821BC00Ch case    8:*/		return 0x821BC010;
		  /* 821BC010h */ case    9:  		/* lwz R10, <#[R27]> */
		/* 821BC010h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000000) );
		/* 821BC010h case    9:*/		return 0x821BC014;
		  /* 821BC014h */ case   10:  		/* rlwinm. R11, R10, 0, 4, 6 */
		/* 821BC014h case   10:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R10);
		/* 821BC014h case   10:*/		return 0x821BC018;
		  /* 821BC018h */ case   11:  		/* bc 12, CR0_EQ, 332 */
		/* 821BC018h case   11:*/		if ( regs.CR[0].eq ) { return 0x821BC164;  }
		/* 821BC018h case   11:*/		return 0x821BC01C;
		  /* 821BC01Ch */ case   12:  		/* lwz R31, <#[R27 + 12]> */
		/* 821BC01Ch case   12:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R27 + 0x0000000C) );
		/* 821BC01Ch case   12:*/		return 0x821BC020;
		  /* 821BC020h */ case   13:  		/* lwz R11, <#[R31 + 8]> */
		/* 821BC020h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821BC020h case   13:*/		return 0x821BC024;
		  /* 821BC024h */ case   14:  		/* rlwinm. R9, R11, 27, 31, 31 */
		/* 821BC024h case   14:*/		cpu::op::rlwinm<1,27,31,31>(regs,&regs.R9,regs.R11);
		/* 821BC024h case   14:*/		return 0x821BC028;
		  /* 821BC028h */ case   15:  		/* bc 12, CR0_EQ, 316 */
		/* 821BC028h case   15:*/		if ( regs.CR[0].eq ) { return 0x821BC164;  }
		/* 821BC028h case   15:*/		return 0x821BC02C;
		  /* 821BC02Ch */ case   16:  		/* rlwinm R29, R10, 15, 24, 31 */
		/* 821BC02Ch case   16:*/		cpu::op::rlwinm<0,15,24,31>(regs,&regs.R29,regs.R10);
		/* 821BC02Ch case   16:*/		return 0x821BC030;
		  /* 821BC030h */ case   17:  		/* cmplwi CR6, R29, 32 */
		/* 821BC030h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000020);
		/* 821BC030h case   17:*/		return 0x821BC034;
		  /* 821BC034h */ case   18:  		/* bc 12, CR6_LT, 12 */
		/* 821BC034h case   18:*/		if ( regs.CR[6].lt ) { return 0x821BC040;  }
		/* 821BC034h case   18:*/		return 0x821BC038;
		  /* 821BC038h */ case   19:  		/* cmplwi CR6, R29, 37 */
		/* 821BC038h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000025);
		/* 821BC038h case   19:*/		return 0x821BC03C;
		  /* 821BC03Ch */ case   20:  		/* bc 4, CR6_GT, 296 */
		/* 821BC03Ch case   20:*/		if ( !regs.CR[6].gt ) { return 0x821BC164;  }
		/* 821BC03Ch case   20:*/		return 0x821BC040;
	}
	return 0x821BC040;
} // Block from 821BBFECh-821BC040h (21 instructions)

//////////////////////////////////////////////////////
// Block at 821BC040h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC040( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC040) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC040);
		  /* 821BC040h */ case    0:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821BC040h case    0:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821BC040h case    0:*/		return 0x821BC044;
		  /* 821BC044h */ case    1:  		/* cmplwi CR6, R11, 1 */
		/* 821BC044h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 821BC044h case    1:*/		return 0x821BC048;
		  /* 821BC048h */ case    2:  		/* bc 12, CR6_LT, 16 */
		/* 821BC048h case    2:*/		if ( regs.CR[6].lt ) { return 0x821BC058;  }
		/* 821BC048h case    2:*/		return 0x821BC04C;
		  /* 821BC04Ch */ case    3:  		/* cmplwi CR6, R11, 102 */
		/* 821BC04Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000066);
		/* 821BC04Ch case    3:*/		return 0x821BC050;
		  /* 821BC050h */ case    4:  		/* li R11, 1 */
		/* 821BC050h case    4:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821BC050h case    4:*/		return 0x821BC054;
		  /* 821BC054h */ case    5:  		/* bc 4, CR6_GT, 8 */
		/* 821BC054h case    5:*/		if ( !regs.CR[6].gt ) { return 0x821BC05C;  }
		/* 821BC054h case    5:*/		return 0x821BC058;
	}
	return 0x821BC058;
} // Block from 821BC040h-821BC058h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BC058h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC058( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC058) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC058);
		  /* 821BC058h */ case    0:  		/* li R11, 0 */
		/* 821BC058h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BC058h case    0:*/		return 0x821BC05C;
	}
	return 0x821BC05C;
} // Block from 821BC058h-821BC05Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BC05Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC05C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC05C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC05C);
		  /* 821BC05Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821BC05Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821BC05Ch case    0:*/		return 0x821BC060;
		  /* 821BC060h */ case    1:  		/* bc 12, CR0_EQ, 260 */
		/* 821BC060h case    1:*/		if ( regs.CR[0].eq ) { return 0x821BC164;  }
		/* 821BC060h case    1:*/		return 0x821BC064;
		  /* 821BC064h */ case    2:  		/* cmplwi CR6, R28, 0 */
		/* 821BC064h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 821BC064h case    2:*/		return 0x821BC068;
		  /* 821BC068h */ case    3:  		/* bc 4, CR6_EQ, 36 */
		/* 821BC068h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821BC08C;  }
		/* 821BC068h case    3:*/		return 0x821BC06C;
		  /* 821BC06Ch */ case    4:  		/* addi R6, R1, 84 */
		/* 821BC06Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x54);
		/* 821BC06Ch case    4:*/		return 0x821BC070;
		  /* 821BC070h */ case    5:  		/* addi R5, R1, 80 */
		/* 821BC070h case    5:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 821BC070h case    5:*/		return 0x821BC074;
		  /* 821BC074h */ case    6:  		/* mr R4, R23 */
		/* 821BC074h case    6:*/		regs.R4 = regs.R23;
		/* 821BC074h case    6:*/		return 0x821BC078;
		  /* 821BC078h */ case    7:  		/* mr R3, R21 */
		/* 821BC078h case    7:*/		regs.R3 = regs.R21;
		/* 821BC078h case    7:*/		return 0x821BC07C;
		  /* 821BC07Ch */ case    8:  		/* bl -20260 */
		/* 821BC07Ch case    8:*/		regs.LR = 0x821BC080; return 0x821B7158;
		/* 821BC07Ch case    8:*/		return 0x821BC080;
		  /* 821BC080h */ case    9:  		/* lwz R26, <#[R1 + 80]> */
		/* 821BC080h case    9:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R1 + 0x00000050) );
		/* 821BC080h case    9:*/		return 0x821BC084;
		  /* 821BC084h */ case   10:  		/* lwz R30, <#[R1 + 84]> */
		/* 821BC084h case   10:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000054) );
		/* 821BC084h case   10:*/		return 0x821BC088;
		  /* 821BC088h */ case   11:  		/* mr R28, R3 */
		/* 821BC088h case   11:*/		regs.R28 = regs.R3;
		/* 821BC088h case   11:*/		return 0x821BC08C;
	}
	return 0x821BC08C;
} // Block from 821BC05Ch-821BC08Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 821BC08Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC08C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC08C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC08C);
		  /* 821BC08Ch */ case    0:  		/* cmplw CR6, R28, R23 */
		/* 821BC08Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R23);
		/* 821BC08Ch case    0:*/		return 0x821BC090;
		  /* 821BC090h */ case    1:  		/* bc 4, CR6_EQ, 212 */
		/* 821BC090h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BC164;  }
		/* 821BC090h case    1:*/		return 0x821BC094;
		  /* 821BC094h */ case    2:  		/* lwz R11, <#[R21 + 48]> */
		/* 821BC094h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000030) );
		/* 821BC094h case    2:*/		return 0x821BC098;
		  /* 821BC098h */ case    3:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 821BC098h case    3:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 821BC098h case    3:*/		return 0x821BC09C;
		  /* 821BC09Ch */ case    4:  		/* cmplw CR6, R11, R22 */
		/* 821BC09Ch case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R22);
		/* 821BC09Ch case    4:*/		return 0x821BC0A0;
		  /* 821BC0A0h */ case    5:  		/* bc 12, CR6_EQ, 100 */
		/* 821BC0A0h case    5:*/		if ( regs.CR[6].eq ) { return 0x821BC104;  }
		/* 821BC0A0h case    5:*/		return 0x821BC0A4;
		  /* 821BC0A4h */ case    6:  		/* cmplwi CR6, R29, 15 */
		/* 821BC0A4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x0000000F);
		/* 821BC0A4h case    6:*/		return 0x821BC0A8;
		  /* 821BC0A8h */ case    7:  		/* li R7, 0 */
		/* 821BC0A8h case    7:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821BC0A8h case    7:*/		return 0x821BC0AC;
		  /* 821BC0ACh */ case    8:  		/* li R6, 1 */
		/* 821BC0ACh case    8:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821BC0ACh case    8:*/		return 0x821BC0B0;
		  /* 821BC0B0h */ case    9:  		/* mr R3, R21 */
		/* 821BC0B0h case    9:*/		regs.R3 = regs.R21;
		/* 821BC0B0h case    9:*/		return 0x821BC0B4;
		  /* 821BC0B4h */ case   10:  		/* bc 12, CR6_GT, 52 */
		/* 821BC0B4h case   10:*/		if ( regs.CR[6].gt ) { return 0x821BC0E8;  }
		/* 821BC0B4h case   10:*/		return 0x821BC0B8;
		  /* 821BC0B8h */ case   11:  		/* mr R5, R31 */
		/* 821BC0B8h case   11:*/		regs.R5 = regs.R31;
		/* 821BC0B8h case   11:*/		return 0x821BC0BC;
		  /* 821BC0BCh */ case   12:  		/* mr R4, R30 */
		/* 821BC0BCh case   12:*/		regs.R4 = regs.R30;
		/* 821BC0BCh case   12:*/		return 0x821BC0C0;
		  /* 821BC0C0h */ case   13:  		/* bl 465608 */
		/* 821BC0C0h case   13:*/		regs.LR = 0x821BC0C4; return 0x8222DB88;
		/* 821BC0C0h case   13:*/		return 0x821BC0C4;
		  /* 821BC0C4h */ case   14:  		/* li R5, 8 */
		/* 821BC0C4h case   14:*/		cpu::op::li<0>(regs,&regs.R5,0x8);
		/* 821BC0C4h case   14:*/		return 0x821BC0C8;
		  /* 821BC0C8h */ case   15:  		/* mr R4, R30 */
		/* 821BC0C8h case   15:*/		regs.R4 = regs.R30;
		/* 821BC0C8h case   15:*/		return 0x821BC0CC;
		  /* 821BC0CCh */ case   16:  		/* mr R3, R21 */
		/* 821BC0CCh case   16:*/		regs.R3 = regs.R21;
		/* 821BC0CCh case   16:*/		return 0x821BC0D0;
		  /* 821BC0D0h */ case   17:  		/* bl -309632 */
		/* 821BC0D0h case   17:*/		regs.LR = 0x821BC0D4; return 0x82170750;
		/* 821BC0D0h case   17:*/		return 0x821BC0D4;
		  /* 821BC0D4h */ case   18:  		/* mr R4, R3 */
		/* 821BC0D4h case   18:*/		regs.R4 = regs.R3;
		/* 821BC0D4h case   18:*/		return 0x821BC0D8;
		  /* 821BC0D8h */ case   19:  		/* mr R3, R31 */
		/* 821BC0D8h case   19:*/		regs.R3 = regs.R31;
		/* 821BC0D8h case   19:*/		return 0x821BC0DC;
		  /* 821BC0DCh */ case   20:  		/* bl -278292 */
		/* 821BC0DCh case   20:*/		regs.LR = 0x821BC0E0; return 0x821781C8;
		/* 821BC0DCh case   20:*/		return 0x821BC0E0;
		  /* 821BC0E0h */ case   21:  		/* li R25, 1 */
		/* 821BC0E0h case   21:*/		cpu::op::li<0>(regs,&regs.R25,0x1);
		/* 821BC0E0h case   21:*/		return 0x821BC0E4;
		  /* 821BC0E4h */ case   22:  		/* b 128 */
		/* 821BC0E4h case   22:*/		return 0x821BC164;
		/* 821BC0E4h case   22:*/		return 0x821BC0E8;
	}
	return 0x821BC0E8;
} // Block from 821BC08Ch-821BC0E8h (23 instructions)

//////////////////////////////////////////////////////
// Block at 821BC0E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC0E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC0E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC0E8);
		  /* 821BC0E8h */ case    0:  		/* mr R5, R30 */
		/* 821BC0E8h case    0:*/		regs.R5 = regs.R30;
		/* 821BC0E8h case    0:*/		return 0x821BC0EC;
		  /* 821BC0ECh */ case    1:  		/* mr R4, R31 */
		/* 821BC0ECh case    1:*/		regs.R4 = regs.R31;
		/* 821BC0ECh case    1:*/		return 0x821BC0F0;
		  /* 821BC0F0h */ case    2:  		/* bl 465560 */
		/* 821BC0F0h case    2:*/		regs.LR = 0x821BC0F4; return 0x8222DB88;
		/* 821BC0F0h case    2:*/		return 0x821BC0F4;
		  /* 821BC0F4h */ case    3:  		/* mr R5, R21 */
		/* 821BC0F4h case    3:*/		regs.R5 = regs.R21;
		/* 821BC0F4h case    3:*/		return 0x821BC0F8;
		  /* 821BC0F8h */ case    4:  		/* mr R4, R31 */
		/* 821BC0F8h case    4:*/		regs.R4 = regs.R31;
		/* 821BC0F8h case    4:*/		return 0x821BC0FC;
		  /* 821BC0FCh */ case    5:  		/* mr R3, R30 */
		/* 821BC0FCh case    5:*/		regs.R3 = regs.R30;
		/* 821BC0FCh case    5:*/		return 0x821BC100;
		  /* 821BC100h */ case    6:  		/* bl -278128 */
		/* 821BC100h case    6:*/		regs.LR = 0x821BC104; return 0x82178290;
		/* 821BC100h case    6:*/		return 0x821BC104;
	}
	return 0x821BC104;
} // Block from 821BC0E8h-821BC104h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BC104h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC104( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC104) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC104);
		  /* 821BC104h */ case    0:  		/* li R7, 0 */
		/* 821BC104h case    0:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821BC104h case    0:*/		return 0x821BC108;
		  /* 821BC108h */ case    1:  		/* li R6, 1 */
		/* 821BC108h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821BC108h case    1:*/		return 0x821BC10C;
		  /* 821BC10Ch */ case    2:  		/* mr R5, R31 */
		/* 821BC10Ch case    2:*/		regs.R5 = regs.R31;
		/* 821BC10Ch case    2:*/		return 0x821BC110;
		  /* 821BC110h */ case    3:  		/* mr R4, R26 */
		/* 821BC110h case    3:*/		regs.R4 = regs.R26;
		/* 821BC110h case    3:*/		return 0x821BC114;
		  /* 821BC114h */ case    4:  		/* mr R3, R21 */
		/* 821BC114h case    4:*/		regs.R3 = regs.R21;
		/* 821BC114h case    4:*/		return 0x821BC118;
		  /* 821BC118h */ case    5:  		/* bl 465520 */
		/* 821BC118h case    5:*/		regs.LR = 0x821BC11C; return 0x8222DB88;
		/* 821BC118h case    5:*/		return 0x821BC11C;
		  /* 821BC11Ch */ case    6:  		/* li R5, 8 */
		/* 821BC11Ch case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x8);
		/* 821BC11Ch case    6:*/		return 0x821BC120;
		  /* 821BC120h */ case    7:  		/* mr R4, R26 */
		/* 821BC120h case    7:*/		regs.R4 = regs.R26;
		/* 821BC120h case    7:*/		return 0x821BC124;
		  /* 821BC124h */ case    8:  		/* mr R3, R21 */
		/* 821BC124h case    8:*/		regs.R3 = regs.R21;
		/* 821BC124h case    8:*/		return 0x821BC128;
		  /* 821BC128h */ case    9:  		/* bl -309720 */
		/* 821BC128h case    9:*/		regs.LR = 0x821BC12C; return 0x82170750;
		/* 821BC128h case    9:*/		return 0x821BC12C;
		  /* 821BC12Ch */ case   10:  		/* mr R4, R3 */
		/* 821BC12Ch case   10:*/		regs.R4 = regs.R3;
		/* 821BC12Ch case   10:*/		return 0x821BC130;
		  /* 821BC130h */ case   11:  		/* mr R3, R31 */
		/* 821BC130h case   11:*/		regs.R3 = regs.R31;
		/* 821BC130h case   11:*/		return 0x821BC134;
		  /* 821BC134h */ case   12:  		/* bl -278380 */
		/* 821BC134h case   12:*/		regs.LR = 0x821BC138; return 0x821781C8;
		/* 821BC134h case   12:*/		return 0x821BC138;
		  /* 821BC138h */ case   13:  		/* lwz R11, <#[R26 + 8]> */
		/* 821BC138h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 821BC138h case   13:*/		return 0x821BC13C;
		  /* 821BC13Ch */ case   14:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821BC13Ch case   14:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821BC13Ch case   14:*/		return 0x821BC140;
		  /* 821BC140h */ case   15:  		/* cmplwi CR6, R11, 11648 */
		/* 821BC140h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00002D80);
		/* 821BC140h case   15:*/		return 0x821BC144;
		  /* 821BC144h */ case   16:  		/* bc 4, CR6_EQ, 32 */
		/* 821BC144h case   16:*/		if ( !regs.CR[6].eq ) { return 0x821BC164;  }
		/* 821BC144h case   16:*/		return 0x821BC148;
		  /* 821BC148h */ case   17:  		/* li R5, 5 */
		/* 821BC148h case   17:*/		cpu::op::li<0>(regs,&regs.R5,0x5);
		/* 821BC148h case   17:*/		return 0x821BC14C;
		  /* 821BC14Ch */ case   18:  		/* mr R4, R26 */
		/* 821BC14Ch case   18:*/		regs.R4 = regs.R26;
		/* 821BC14Ch case   18:*/		return 0x821BC150;
		  /* 821BC150h */ case   19:  		/* mr R3, R21 */
		/* 821BC150h case   19:*/		regs.R3 = regs.R21;
		/* 821BC150h case   19:*/		return 0x821BC154;
		  /* 821BC154h */ case   20:  		/* bl -309764 */
		/* 821BC154h case   20:*/		regs.LR = 0x821BC158; return 0x82170750;
		/* 821BC154h case   20:*/		return 0x821BC158;
		  /* 821BC158h */ case   21:  		/* mr R4, R3 */
		/* 821BC158h case   21:*/		regs.R4 = regs.R3;
		/* 821BC158h case   21:*/		return 0x821BC15C;
		  /* 821BC15Ch */ case   22:  		/* mr R3, R31 */
		/* 821BC15Ch case   22:*/		regs.R3 = regs.R31;
		/* 821BC15Ch case   22:*/		return 0x821BC160;
		  /* 821BC160h */ case   23:  		/* bl -278424 */
		/* 821BC160h case   23:*/		regs.LR = 0x821BC164; return 0x821781C8;
		/* 821BC160h case   23:*/		return 0x821BC164;
	}
	return 0x821BC164;
} // Block from 821BC104h-821BC164h (24 instructions)

//////////////////////////////////////////////////////
// Block at 821BC164h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC164( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC164) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC164);
		  /* 821BC164h */ case    0:  		/* lwz R27, <#[R27 + 4]> */
		/* 821BC164h case    0:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R27 + 0x00000004) );
		/* 821BC164h case    0:*/		return 0x821BC168;
		  /* 821BC168h */ case    1:  		/* b -352 */
		/* 821BC168h case    1:*/		return 0x821BC008;
		/* 821BC168h case    1:*/		return 0x821BC16C;
	}
	return 0x821BC16C;
} // Block from 821BC164h-821BC16Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BC16Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC16C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC16C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC16C);
		  /* 821BC16Ch */ case    0:  		/* lwz R11, <#[R21 + 48]> */
		/* 821BC16Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000030) );
		/* 821BC16Ch case    0:*/		return 0x821BC170;
		  /* 821BC170h */ case    1:  		/* rlwinm R11, R11, 0, 0, 15 */
		/* 821BC170h case    1:*/		cpu::op::rlwinm<0,0,0,15>(regs,&regs.R11,regs.R11);
		/* 821BC170h case    1:*/		return 0x821BC174;
		  /* 821BC174h */ case    2:  		/* cmplw CR6, R11, R22 */
		/* 821BC174h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R22);
		/* 821BC174h case    2:*/		return 0x821BC178;
		  /* 821BC178h */ case    3:  		/* bc 12, CR6_EQ, 328 */
		/* 821BC178h case    3:*/		if ( regs.CR[6].eq ) { return 0x821BC2C0;  }
		/* 821BC178h case    3:*/		return 0x821BC17C;
		  /* 821BC17Ch */ case    4:  		/* cmplwi CR6, R28, 0 */
		/* 821BC17Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 821BC17Ch case    4:*/		return 0x821BC180;
		  /* 821BC180h */ case    5:  		/* bc 12, CR6_EQ, 320 */
		/* 821BC180h case    5:*/		if ( regs.CR[6].eq ) { return 0x821BC2C0;  }
		/* 821BC180h case    5:*/		return 0x821BC184;
		  /* 821BC184h */ case    6:  		/* cmplw CR6, R28, R23 */
		/* 821BC184h case    6:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R23);
		/* 821BC184h case    6:*/		return 0x821BC188;
		  /* 821BC188h */ case    7:  		/* bc 12, CR6_EQ, 312 */
		/* 821BC188h case    7:*/		if ( regs.CR[6].eq ) { return 0x821BC2C0;  }
		/* 821BC188h case    7:*/		return 0x821BC18C;
		  /* 821BC18Ch */ case    8:  		/* rlwinm. R11, R25, 0, 24, 31 */
		/* 821BC18Ch case    8:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R25);
		/* 821BC18Ch case    8:*/		return 0x821BC190;
		  /* 821BC190h */ case    9:  		/* bc 4, CR0_EQ, 304 */
		/* 821BC190h case    9:*/		if ( !regs.CR[0].eq ) { return 0x821BC2C0;  }
		/* 821BC190h case    9:*/		return 0x821BC194;
		  /* 821BC194h */ case   10:  		/* addi R28, R26, 4 */
		/* 821BC194h case   10:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R26,0x4);
		/* 821BC194h case   10:*/		return 0x821BC198;
		  /* 821BC198h */ case   11:  		/* mr R29, R28 */
		/* 821BC198h case   11:*/		regs.R29 = regs.R28;
		/* 821BC198h case   11:*/		return 0x821BC19C;
		  /* 821BC19Ch */ case   12:  		/* lwz R31, <#[R29]> */
		/* 821BC19Ch case   12:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R29 + 0x00000000) );
		/* 821BC19Ch case   12:*/		return 0x821BC1A0;
		  /* 821BC1A0h */ case   13:  		/* cmplwi CR6, R31, 0 */
		/* 821BC1A0h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821BC1A0h case   13:*/		return 0x821BC1A4;
		  /* 821BC1A4h */ case   14:  		/* bc 12, CR6_EQ, 60 */
		/* 821BC1A4h case   14:*/		if ( regs.CR[6].eq ) { return 0x821BC1E0;  }
		/* 821BC1A4h case   14:*/		return 0x821BC1A8;
		  /* 821BC1A8h */ case   15:  		/* lwz R11, <#[R31 + 16]> */
		/* 821BC1A8h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 821BC1A8h case   15:*/		return 0x821BC1AC;
		  /* 821BC1ACh */ case   16:  		/* cmplwi CR6, R11, 0 */
		/* 821BC1ACh case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BC1ACh case   16:*/		return 0x821BC1B0;
		  /* 821BC1B0h */ case   17:  		/* bc 12, CR6_EQ, 28 */
		/* 821BC1B0h case   17:*/		if ( regs.CR[6].eq ) { return 0x821BC1CC;  }
		/* 821BC1B0h case   17:*/		return 0x821BC1B4;
		  /* 821BC1B4h */ case   18:  		/* cmplw CR6, R11, R30 */
		/* 821BC1B4h case   18:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 821BC1B4h case   18:*/		return 0x821BC1B8;
		  /* 821BC1B8h */ case   19:  		/* bc 4, CR6_EQ, 20 */
		/* 821BC1B8h case   19:*/		if ( !regs.CR[6].eq ) { return 0x821BC1CC;  }
		/* 821BC1B8h case   19:*/		return 0x821BC1BC;
		  /* 821BC1BCh */ case   20:  		/* mr R5, R21 */
		/* 821BC1BCh case   20:*/		regs.R5 = regs.R21;
		/* 821BC1BCh case   20:*/		return 0x821BC1C0;
		  /* 821BC1C0h */ case   21:  		/* mr R4, R31 */
		/* 821BC1C0h case   21:*/		regs.R4 = regs.R31;
		/* 821BC1C0h case   21:*/		return 0x821BC1C4;
		  /* 821BC1C4h */ case   22:  		/* mr R3, R30 */
		/* 821BC1C4h case   22:*/		regs.R3 = regs.R30;
		/* 821BC1C4h case   22:*/		return 0x821BC1C8;
		  /* 821BC1C8h */ case   23:  		/* bl -276664 */
		/* 821BC1C8h case   23:*/		regs.LR = 0x821BC1CC; return 0x82178910;
		/* 821BC1C8h case   23:*/		return 0x821BC1CC;
	}
	return 0x821BC1CC;
} // Block from 821BC16Ch-821BC1CCh (24 instructions)

//////////////////////////////////////////////////////
// Block at 821BC1CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC1CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC1CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC1CC);
		  /* 821BC1CCh */ case    0:  		/* lwz R11, <#[R29]> */
		/* 821BC1CCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 821BC1CCh case    0:*/		return 0x821BC1D0;
		  /* 821BC1D0h */ case    1:  		/* cmplw CR6, R11, R31 */
		/* 821BC1D0h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 821BC1D0h case    1:*/		return 0x821BC1D4;
		  /* 821BC1D4h */ case    2:  		/* bc 4, CR6_EQ, -56 */
		/* 821BC1D4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821BC19C;  }
		/* 821BC1D4h case    2:*/		return 0x821BC1D8;
		  /* 821BC1D8h */ case    3:  		/* addi R29, R31, 8 */
		/* 821BC1D8h case    3:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R31,0x8);
		/* 821BC1D8h case    3:*/		return 0x821BC1DC;
		  /* 821BC1DCh */ case    4:  		/* b -64 */
		/* 821BC1DCh case    4:*/		return 0x821BC19C;
		/* 821BC1DCh case    4:*/		return 0x821BC1E0;
	}
	return 0x821BC1E0;
} // Block from 821BC1CCh-821BC1E0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BC1E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC1E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC1E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC1E0);
		  /* 821BC1E0h */ case    0:  		/* rlwinm R11, R26, 0, 0, 30 */
		/* 821BC1E0h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R26);
		/* 821BC1E0h case    0:*/		return 0x821BC1E4;
		  /* 821BC1E4h */ case    1:  		/* rlwinm R10, R30, 0, 0, 30 */
		/* 821BC1E4h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R30);
		/* 821BC1E4h case    1:*/		return 0x821BC1E8;
		  /* 821BC1E8h */ case    2:  		/* addi R11, R11, 36 */
		/* 821BC1E8h case    2:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x24);
		/* 821BC1E8h case    2:*/		return 0x821BC1EC;
		  /* 821BC1ECh */ case    3:  		/* addi R10, R10, 36 */
		/* 821BC1ECh case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x24);
		/* 821BC1ECh case    3:*/		return 0x821BC1F0;
		  /* 821BC1F0h */ case    4:  		/* addi R9, R11, 4 */
		/* 821BC1F0h case    4:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x4);
		/* 821BC1F0h case    4:*/		return 0x821BC1F4;
		  /* 821BC1F4h */ case    5:  		/* addi R8, R10, 4 */
		/* 821BC1F4h case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x4);
		/* 821BC1F4h case    5:*/		return 0x821BC1F8;
		  /* 821BC1F8h */ case    6:  		/* addi R7, R11, -36 */
		/* 821BC1F8h case    6:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R11,0xFFFFFFDC);
		/* 821BC1F8h case    6:*/		return 0x821BC1FC;
		  /* 821BC1FCh */ case    7:  		/* lwz R6, <#[R11 + 4]> */
		/* 821BC1FCh case    7:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821BC1FCh case    7:*/		return 0x821BC200;
		  /* 821BC200h */ case    8:  		/* mr R5, R21 */
		/* 821BC200h case    8:*/		regs.R5 = regs.R21;
		/* 821BC200h case    8:*/		return 0x821BC204;
		  /* 821BC204h */ case    9:  		/* lwz R31, <#[R11]> */
		/* 821BC204h case    9:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000000) );
		/* 821BC204h case    9:*/		return 0x821BC208;
		  /* 821BC208h */ case   10:  		/* mr R4, R30 */
		/* 821BC208h case   10:*/		regs.R4 = regs.R30;
		/* 821BC208h case   10:*/		return 0x821BC20C;
		  /* 821BC20Ch */ case   11:  		/* rlwinm R6, R6, 0, 0, 30 */
		/* 821BC20Ch case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R6);
		/* 821BC20Ch case   11:*/		return 0x821BC210;
		  /* 821BC210h */ case   12:  		/* mr R3, R26 */
		/* 821BC210h case   12:*/		regs.R3 = regs.R26;
		/* 821BC210h case   12:*/		return 0x821BC214;
		  /* 821BC214h */ case   13:  		/* stw R31, <#[R6 + 36]> */
		/* 821BC214h case   13:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R6 + 0x00000024) );
		/* 821BC214h case   13:*/		return 0x821BC218;
		  /* 821BC218h */ case   14:  		/* lwz R6, <#[R11 + 4]> */
		/* 821BC218h case   14:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821BC218h case   14:*/		return 0x821BC21C;
		  /* 821BC21Ch */ case   15:  		/* lwz R31, <#[R11]> */
		/* 821BC21Ch case   15:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000000) );
		/* 821BC21Ch case   15:*/		return 0x821BC220;
		  /* 821BC220h */ case   16:  		/* rlwinm R31, R31, 0, 0, 30 */
		/* 821BC220h case   16:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R31,regs.R31);
		/* 821BC220h case   16:*/		return 0x821BC224;
		  /* 821BC224h */ case   17:  		/* stw R6, <#[R31]> */
		/* 821BC224h case   17:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R31 + 0x00000000) );
		/* 821BC224h case   17:*/		return 0x821BC228;
		  /* 821BC228h */ case   18:  		/* lwz R6, <#[R10 + 4]> */
		/* 821BC228h case   18:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 821BC228h case   18:*/		return 0x821BC22C;
		  /* 821BC22Ch */ case   19:  		/* stw R6, <#[R11 + 4]> */
		/* 821BC22Ch case   19:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R11 + 0x00000004) );
		/* 821BC22Ch case   19:*/		return 0x821BC230;
		  /* 821BC230h */ case   20:  		/* lwz R6, <#[R10 + 4]> */
		/* 821BC230h case   20:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R10 + 0x00000004) );
		/* 821BC230h case   20:*/		return 0x821BC234;
		  /* 821BC234h */ case   21:  		/* rlwinm R6, R6, 0, 0, 30 */
		/* 821BC234h case   21:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R6,regs.R6);
		/* 821BC234h case   21:*/		return 0x821BC238;
		  /* 821BC238h */ case   22:  		/* stw R9, <#[R6 + 36]> */
		/* 821BC238h case   22:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R6 + 0x00000024) );
		/* 821BC238h case   22:*/		return 0x821BC23C;
		  /* 821BC23Ch */ case   23:  		/* stw R8, <#[R11]> */
		/* 821BC23Ch case   23:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 821BC23Ch case   23:*/		return 0x821BC240;
		  /* 821BC240h */ case   24:  		/* stw R7, <#[R10 + 4]> */
		/* 821BC240h case   24:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R10 + 0x00000004) );
		/* 821BC240h case   24:*/		return 0x821BC244;
		  /* 821BC244h */ case   25:  		/* bl -278452 */
		/* 821BC244h case   25:*/		regs.LR = 0x821BC248; return 0x82178290;
		/* 821BC244h case   25:*/		return 0x821BC248;
		  /* 821BC248h */ case   26:  		/* addi R8, R30, 4 */
		/* 821BC248h case   26:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R30,0x4);
		/* 821BC248h case   26:*/		return 0x821BC24C;
		  /* 821BC24Ch */ case   27:  		/* lwz R11, <#[R8]> */
		/* 821BC24Ch case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 821BC24Ch case   27:*/		return 0x821BC250;
		  /* 821BC250h */ case   28:  		/* cmplwi CR6, R11, 0 */
		/* 821BC250h case   28:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BC250h case   28:*/		return 0x821BC254;
		  /* 821BC254h */ case   29:  		/* bc 12, CR6_EQ, 108 */
		/* 821BC254h case   29:*/		if ( regs.CR[6].eq ) { return 0x821BC2C0;  }
		/* 821BC254h case   29:*/		return 0x821BC258;
		  /* 821BC258h */ case   30:  		/* lwz R10, <#[R11 + 16]> */
		/* 821BC258h case   30:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000010) );
		/* 821BC258h case   30:*/		return 0x821BC25C;
		  /* 821BC25Ch */ case   31:  		/* cmplwi CR6, R10, 0 */
		/* 821BC25Ch case   31:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821BC25Ch case   31:*/		return 0x821BC260;
		  /* 821BC260h */ case   32:  		/* bc 12, CR6_EQ, 76 */
		/* 821BC260h case   32:*/		if ( regs.CR[6].eq ) { return 0x821BC2AC;  }
		/* 821BC260h case   32:*/		return 0x821BC264;
		  /* 821BC264h */ case   33:  		/* lwz R10, <#[R10 + 8]> */
		/* 821BC264h case   33:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 821BC264h case   33:*/		return 0x821BC268;
		  /* 821BC268h */ case   34:  		/* rlwinm R10, R10, 0, 18, 24 */
		/* 821BC268h case   34:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R10);
		/* 821BC268h case   34:*/		return 0x821BC26C;
		  /* 821BC26Ch */ case   35:  		/* cmplwi CR6, R10, 14976 */
		/* 821BC26Ch case   35:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003A80);
		/* 821BC26Ch case   35:*/		return 0x821BC270;
		  /* 821BC270h */ case   36:  		/* bc 4, CR6_EQ, 60 */
		/* 821BC270h case   36:*/		if ( !regs.CR[6].eq ) { return 0x821BC2AC;  }
		/* 821BC270h case   36:*/		return 0x821BC274;
		  /* 821BC274h */ case   37:  		/* lwz R10, <#[R11 + 12]> */
		/* 821BC274h case   37:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 821BC274h case   37:*/		return 0x821BC278;
		  /* 821BC278h */ case   38:  		/* addi R10, R10, 4 */
		/* 821BC278h case   38:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821BC278h case   38:*/		return 0x821BC27C;
		  /* 821BC27Ch */ case   39:  		/* lwz R9, <#[R10]> */
		/* 821BC27Ch case   39:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821BC27Ch case   39:*/		return 0x821BC280;
		  /* 821BC280h */ case   40:  		/* b 12 */
		/* 821BC280h case   40:*/		return 0x821BC28C;
		/* 821BC280h case   40:*/		return 0x821BC284;
		  /* 821BC284h */ case   41:  		/* addi R10, R9, 8 */
		/* 821BC284h case   41:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0x8);
		/* 821BC284h case   41:*/		return 0x821BC288;
		  /* 821BC288h */ case   42:  		/* lwz R9, <#[R9 + 8]> */
		/* 821BC288h case   42:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000008) );
		/* 821BC288h case   42:*/		return 0x821BC28C;
	}
	return 0x821BC28C;
} // Block from 821BC1E0h-821BC28Ch (43 instructions)

//////////////////////////////////////////////////////
// Block at 821BC28Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC28C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC28C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC28C);
		  /* 821BC28Ch */ case    0:  		/* cmplw CR6, R9, R11 */
		/* 821BC28Ch case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R11);
		/* 821BC28Ch case    0:*/		return 0x821BC290;
		  /* 821BC290h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 821BC290h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BC284;  }
		/* 821BC290h case    1:*/		return 0x821BC294;
		  /* 821BC294h */ case    2:  		/* lwz R9, <#[R11 + 8]> */
		/* 821BC294h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 821BC294h case    2:*/		return 0x821BC298;
		  /* 821BC298h */ case    3:  		/* stw R9, <#[R10]> */
		/* 821BC298h case    3:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821BC298h case    3:*/		return 0x821BC29C;
		  /* 821BC29Ch */ case    4:  		/* lwz R10, <#[R28]> */
		/* 821BC29Ch case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000000) );
		/* 821BC29Ch case    4:*/		return 0x821BC2A0;
		  /* 821BC2A0h */ case    5:  		/* stw R10, <#[R11 + 8]> */
		/* 821BC2A0h case    5:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821BC2A0h case    5:*/		return 0x821BC2A4;
		  /* 821BC2A4h */ case    6:  		/* stw R11, <#[R28]> */
		/* 821BC2A4h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 821BC2A4h case    6:*/		return 0x821BC2A8;
		  /* 821BC2A8h */ case    7:  		/* stw R26, <#[R11 + 12]> */
		/* 821BC2A8h case    7:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + 0x0000000C) );
		/* 821BC2A8h case    7:*/		return 0x821BC2AC;
	}
	return 0x821BC2AC;
} // Block from 821BC28Ch-821BC2ACh (8 instructions)

//////////////////////////////////////////////////////
// Block at 821BC2ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC2AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC2AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC2AC);
		  /* 821BC2ACh */ case    0:  		/* lwz R10, <#[R8]> */
		/* 821BC2ACh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000000) );
		/* 821BC2ACh case    0:*/		return 0x821BC2B0;
		  /* 821BC2B0h */ case    1:  		/* cmplw CR6, R10, R11 */
		/* 821BC2B0h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 821BC2B0h case    1:*/		return 0x821BC2B4;
		  /* 821BC2B4h */ case    2:  		/* bc 4, CR6_EQ, -104 */
		/* 821BC2B4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821BC24C;  }
		/* 821BC2B4h case    2:*/		return 0x821BC2B8;
		  /* 821BC2B8h */ case    3:  		/* addi R8, R11, 8 */
		/* 821BC2B8h case    3:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R11,0x8);
		/* 821BC2B8h case    3:*/		return 0x821BC2BC;
		  /* 821BC2BCh */ case    4:  		/* b -112 */
		/* 821BC2BCh case    4:*/		return 0x821BC24C;
		/* 821BC2BCh case    4:*/		return 0x821BC2C0;
	}
	return 0x821BC2C0;
} // Block from 821BC2ACh-821BC2C0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BC2C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC2C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC2C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC2C0);
		  /* 821BC2C0h */ case    0:  		/* rlwinm R11, R24, 0, 0, 30 */
		/* 821BC2C0h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R24);
		/* 821BC2C0h case    0:*/		return 0x821BC2C4;
		  /* 821BC2C4h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 821BC2C4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 821BC2C4h case    1:*/		return 0x821BC2C8;
		  /* 821BC2C8h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BC2C8h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BC2C8h case    2:*/		return 0x821BC2CC;
		  /* 821BC2CCh */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 821BC2CCh case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BC2DC;  }
		/* 821BC2CCh case    3:*/		return 0x821BC2D0;
		  /* 821BC2D0h */ case    4:  		/* mr R24, R11 */
		/* 821BC2D0h case    4:*/		regs.R24 = regs.R11;
		/* 821BC2D0h case    4:*/		return 0x821BC2D4;
		  /* 821BC2D4h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821BC2D4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BC2D4h case    5:*/		return 0x821BC2D8;
		  /* 821BC2D8h */ case    6:  		/* bc 4, CR6_EQ, -772 */
		/* 821BC2D8h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821BBFD4;  }
		/* 821BC2D8h case    6:*/		return 0x821BC2DC;
	}
	return 0x821BC2DC;
} // Block from 821BC2C0h-821BC2DCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BC2DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC2DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC2DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC2DC);
		  /* 821BC2DCh */ case    0:  		/* rlwinm R11, R23, 0, 0, 30 */
		/* 821BC2DCh case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R23);
		/* 821BC2DCh case    0:*/		return 0x821BC2E0;
		  /* 821BC2E0h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 821BC2E0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821BC2E0h case    1:*/		return 0x821BC2E4;
		  /* 821BC2E4h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BC2E4h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BC2E4h case    2:*/		return 0x821BC2E8;
		  /* 821BC2E8h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 821BC2E8h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BC2F8;  }
		/* 821BC2E8h case    3:*/		return 0x821BC2EC;
		  /* 821BC2ECh */ case    4:  		/* mr R23, R11 */
		/* 821BC2ECh case    4:*/		regs.R23 = regs.R11;
		/* 821BC2ECh case    4:*/		return 0x821BC2F0;
		  /* 821BC2F0h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821BC2F0h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BC2F0h case    5:*/		return 0x821BC2F4;
		  /* 821BC2F4h */ case    6:  		/* bc 4, CR6_EQ, -824 */
		/* 821BC2F4h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821BBFBC;  }
		/* 821BC2F4h case    6:*/		return 0x821BC2F8;
	}
	return 0x821BC2F8;
} // Block from 821BC2DCh-821BC2F8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BC2F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC2F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC2F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC2F8);
		  /* 821BC2F8h */ case    0:  		/* lwz R11, <#[R21 + 4]> */
		/* 821BC2F8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000004) );
		/* 821BC2F8h case    0:*/		return 0x821BC2FC;
		  /* 821BC2FCh */ case    1:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BC2FCh case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BC2FCh case    1:*/		return 0x821BC300;
		  /* 821BC300h */ case    2:  		/* bc 4, CR0_EQ, 56 */
		/* 821BC300h case    2:*/		if ( !regs.CR[0].eq ) { return 0x821BC338;  }
		/* 821BC300h case    2:*/		return 0x821BC304;
		  /* 821BC304h */ case    3:  		/* cmplwi CR0, R11, 0 */
		/* 821BC304h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821BC304h case    3:*/		return 0x821BC308;
		  /* 821BC308h */ case    4:  		/* bc 12, CR0_EQ, 48 */
		/* 821BC308h case    4:*/		if ( regs.CR[0].eq ) { return 0x821BC338;  }
		/* 821BC308h case    4:*/		return 0x821BC30C;
		  /* 821BC30Ch */ case    5:  		/* lwz R10, <#[R11 + 48]> */
		/* 821BC30Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 821BC30Ch case    5:*/		return 0x821BC310;
		  /* 821BC310h */ case    6:  		/* rlwinm. R9, R10, 2, 31, 31 */
		/* 821BC310h case    6:*/		cpu::op::rlwinm<1,2,31,31>(regs,&regs.R9,regs.R10);
		/* 821BC310h case    6:*/		return 0x821BC314;
		  /* 821BC314h */ case    7:  		/* bc 12, CR0_EQ, 12 */
		/* 821BC314h case    7:*/		if ( regs.CR[0].eq ) { return 0x821BC320;  }
		/* 821BC314h case    7:*/		return 0x821BC318;
		  /* 821BC318h */ case    8:  		/* rlwinm R10, R10, 0, 2, 0 */
		/* 821BC318h case    8:*/		cpu::op::rlwinm<0,0,2,0>(regs,&regs.R10,regs.R10);
		/* 821BC318h case    8:*/		return 0x821BC31C;
		  /* 821BC31Ch */ case    9:  		/* stw R10, <#[R11 + 48]> */
		/* 821BC31Ch case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 821BC31Ch case    9:*/		return 0x821BC320;
	}
	return 0x821BC320;
} // Block from 821BC2F8h-821BC320h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821BC320h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC320( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC320) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC320);
		  /* 821BC320h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821BC320h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821BC320h case    0:*/		return 0x821BC324;
		  /* 821BC324h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 821BC324h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821BC324h case    1:*/		return 0x821BC328;
		  /* 821BC328h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BC328h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BC328h case    2:*/		return 0x821BC32C;
		  /* 821BC32Ch */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 821BC32Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BC338;  }
		/* 821BC32Ch case    3:*/		return 0x821BC330;
		  /* 821BC330h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 821BC330h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BC330h case    4:*/		return 0x821BC334;
		  /* 821BC334h */ case    5:  		/* bc 4, CR6_EQ, -40 */
		/* 821BC334h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821BC30C;  }
		/* 821BC334h case    5:*/		return 0x821BC338;
	}
	return 0x821BC338;
} // Block from 821BC320h-821BC338h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BC338h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC338( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC338) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC338);
		  /* 821BC338h */ case    0:  		/* lwz R11, <#[R21 + 44]> */
		/* 821BC338h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x0000002C) );
		/* 821BC338h case    0:*/		return 0x821BC33C;
		  /* 821BC33Ch */ case    1:  		/* rlwinm. R11, R11, 0, 19, 19 */
		/* 821BC33Ch case    1:*/		cpu::op::rlwinm<1,0,19,19>(regs,&regs.R11,regs.R11);
		/* 821BC33Ch case    1:*/		return 0x821BC340;
		  /* 821BC340h */ case    2:  		/* bc 12, CR0_EQ, 488 */
		/* 821BC340h case    2:*/		if ( regs.CR[0].eq ) { return 0x821BC528;  }
		/* 821BC340h case    2:*/		return 0x821BC344;
		  /* 821BC344h */ case    3:  		/* lwz R11, <#[R21 + 4]> */
		/* 821BC344h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000004) );
		/* 821BC344h case    3:*/		return 0x821BC348;
		  /* 821BC348h */ case    4:  		/* li R8, 0 */
		/* 821BC348h case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821BC348h case    4:*/		return 0x821BC34C;
		  /* 821BC34Ch */ case    5:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821BC34Ch case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821BC34Ch case    5:*/		return 0x821BC350;
		  /* 821BC350h */ case    6:  		/* bc 4, CR0_EQ, 180 */
		/* 821BC350h case    6:*/		if ( !regs.CR[0].eq ) { return 0x821BC404;  }
		/* 821BC350h case    6:*/		return 0x821BC354;
		  /* 821BC354h */ case    7:  		/* lwz R11, <#[R21]> */
		/* 821BC354h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000000) );
		/* 821BC354h case    7:*/		return 0x821BC358;
		  /* 821BC358h */ case    8:  		/* b 160 */
		/* 821BC358h case    8:*/		return 0x821BC3F8;
		/* 821BC358h case    8:*/		return 0x821BC35C;
		  /* 821BC35Ch */ case    9:  		/* lwz R9, <#[R11 + 76]> */
		/* 821BC35Ch case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000004C) );
		/* 821BC35Ch case    9:*/		return 0x821BC360;
		  /* 821BC360h */ case   10:  		/* rlwinm. R10, R9, 0, 4, 4 */
		/* 821BC360h case   10:*/		cpu::op::rlwinm<1,0,4,4>(regs,&regs.R10,regs.R9);
		/* 821BC360h case   10:*/		return 0x821BC364;
		  /* 821BC364h */ case   11:  		/* bc 4, CR0_EQ, 132 */
		/* 821BC364h case   11:*/		if ( !regs.CR[0].eq ) { return 0x821BC3E8;  }
		/* 821BC364h case   11:*/		return 0x821BC368;
		  /* 821BC368h */ case   12:  		/* lwz R10, <#[R11 + 12]> */
		/* 821BC368h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 821BC368h case   12:*/		return 0x821BC36C;
		  /* 821BC36Ch */ case   13:  		/* cmplwi CR6, R10, 0 */
		/* 821BC36Ch case   13:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821BC36Ch case   13:*/		return 0x821BC370;
		  /* 821BC370h */ case   14:  		/* bc 12, CR6_EQ, 40 */
		/* 821BC370h case   14:*/		if ( regs.CR[6].eq ) { return 0x821BC398;  }
		/* 821BC370h case   14:*/		return 0x821BC374;
		  /* 821BC374h */ case   15:  		/* lwz R7, <#[R10]> */
		/* 821BC374h case   15:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821BC374h case   15:*/		return 0x821BC378;
		  /* 821BC378h */ case   16:  		/* lwz R7, <#[R7 + 76]> */
		/* 821BC378h case   16:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x0000004C) );
		/* 821BC378h case   16:*/		return 0x821BC37C;
		  /* 821BC37Ch */ case   17:  		/* rlwinm. R7, R7, 0, 4, 4 */
		/* 821BC37Ch case   17:*/		cpu::op::rlwinm<1,0,4,4>(regs,&regs.R7,regs.R7);
		/* 821BC37Ch case   17:*/		return 0x821BC380;
		  /* 821BC380h */ case   18:  		/* bc 4, CR0_EQ, 12 */
		/* 821BC380h case   18:*/		if ( !regs.CR[0].eq ) { return 0x821BC38C;  }
		/* 821BC380h case   18:*/		return 0x821BC384;
		  /* 821BC384h */ case   19:  		/* lwz R10, <#[R10 + 8]> */
		/* 821BC384h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 821BC384h case   19:*/		return 0x821BC388;
		  /* 821BC388h */ case   20:  		/* b -28 */
		/* 821BC388h case   20:*/		return 0x821BC36C;
		/* 821BC388h case   20:*/		return 0x821BC38C;
	}
	return 0x821BC38C;
} // Block from 821BC338h-821BC38Ch (21 instructions)

//////////////////////////////////////////////////////
// Block at 821BC38Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC38C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC38C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC38C);
		  /* 821BC38Ch */ case    0:  		/* oris R10, R9, 2048 */
		/* 821BC38Ch case    0:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R9,0x800);
		/* 821BC38Ch case    0:*/		return 0x821BC390;
		  /* 821BC390h */ case    1:  		/* li R8, 1 */
		/* 821BC390h case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 821BC390h case    1:*/		return 0x821BC394;
		  /* 821BC394h */ case    2:  		/* stw R10, <#[R11 + 76]> */
		/* 821BC394h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000004C) );
		/* 821BC394h case    2:*/		return 0x821BC398;
	}
	return 0x821BC398;
} // Block from 821BC38Ch-821BC398h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BC398h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC398( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC398) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC398);
		  /* 821BC398h */ case    0:  		/* lwz R10, <#[R11 + 28]> */
		/* 821BC398h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000001C) );
		/* 821BC398h case    0:*/		return 0x821BC39C;
		  /* 821BC39Ch */ case    1:  		/* rlwinm. R9, R10, 0, 31, 31 */
		/* 821BC39Ch case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R10);
		/* 821BC39Ch case    1:*/		return 0x821BC3A0;
		  /* 821BC3A0h */ case    2:  		/* bc 4, CR0_EQ, 72 */
		/* 821BC3A0h case    2:*/		if ( !regs.CR[0].eq ) { return 0x821BC3E8;  }
		/* 821BC3A0h case    2:*/		return 0x821BC3A4;
		  /* 821BC3A4h */ case    3:  		/* cmplwi CR0, R10, 0 */
		/* 821BC3A4h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 821BC3A4h case    3:*/		return 0x821BC3A8;
		  /* 821BC3A8h */ case    4:  		/* bc 12, CR0_EQ, 64 */
		/* 821BC3A8h case    4:*/		if ( regs.CR[0].eq ) { return 0x821BC3E8;  }
		/* 821BC3A8h case    4:*/		return 0x821BC3AC;
		  /* 821BC3ACh */ case    5:  		/* lwz R9, <#[R10 + 8]> */
		/* 821BC3ACh case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 821BC3ACh case    5:*/		return 0x821BC3B0;
		  /* 821BC3B0h */ case    6:  		/* rlwinm R9, R9, 0, 18, 24 */
		/* 821BC3B0h case    6:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R9,regs.R9);
		/* 821BC3B0h case    6:*/		return 0x821BC3B4;
		  /* 821BC3B4h */ case    7:  		/* cmplwi CR6, R9, 12288 */
		/* 821BC3B4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00003000);
		/* 821BC3B4h case    7:*/		return 0x821BC3B8;
		  /* 821BC3B8h */ case    8:  		/* bc 12, CR6_EQ, 32 */
		/* 821BC3B8h case    8:*/		if ( regs.CR[6].eq ) { return 0x821BC3D8;  }
		/* 821BC3B8h case    8:*/		return 0x821BC3BC;
		  /* 821BC3BCh */ case    9:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 821BC3BCh case    9:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 821BC3BCh case    9:*/		return 0x821BC3C0;
		  /* 821BC3C0h */ case   10:  		/* lwz R10, <#[R10 + 40]> */
		/* 821BC3C0h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000028) );
		/* 821BC3C0h case   10:*/		return 0x821BC3C4;
		  /* 821BC3C4h */ case   11:  		/* rlwinm. R9, R10, 0, 31, 31 */
		/* 821BC3C4h case   11:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R10);
		/* 821BC3C4h case   11:*/		return 0x821BC3C8;
		  /* 821BC3C8h */ case   12:  		/* bc 4, CR0_EQ, 32 */
		/* 821BC3C8h case   12:*/		if ( !regs.CR[0].eq ) { return 0x821BC3E8;  }
		/* 821BC3C8h case   12:*/		return 0x821BC3CC;
		  /* 821BC3CCh */ case   13:  		/* cmplwi CR6, R10, 0 */
		/* 821BC3CCh case   13:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821BC3CCh case   13:*/		return 0x821BC3D0;
		  /* 821BC3D0h */ case   14:  		/* bc 4, CR6_EQ, -36 */
		/* 821BC3D0h case   14:*/		if ( !regs.CR[6].eq ) { return 0x821BC3AC;  }
		/* 821BC3D0h case   14:*/		return 0x821BC3D4;
		  /* 821BC3D4h */ case   15:  		/* b 20 */
		/* 821BC3D4h case   15:*/		return 0x821BC3E8;
		/* 821BC3D4h case   15:*/		return 0x821BC3D8;
	}
	return 0x821BC3D8;
} // Block from 821BC398h-821BC3D8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821BC3D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC3D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC3D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC3D8);
		  /* 821BC3D8h */ case    0:  		/* lwz R10, <#[R11 + 76]> */
		/* 821BC3D8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000004C) );
		/* 821BC3D8h case    0:*/		return 0x821BC3DC;
		  /* 821BC3DCh */ case    1:  		/* li R8, 1 */
		/* 821BC3DCh case    1:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 821BC3DCh case    1:*/		return 0x821BC3E0;
		  /* 821BC3E0h */ case    2:  		/* oris R10, R10, 2048 */
		/* 821BC3E0h case    2:*/		cpu::op::oris<0>(regs,&regs.R10,regs.R10,0x800);
		/* 821BC3E0h case    2:*/		return 0x821BC3E4;
		  /* 821BC3E4h */ case    3:  		/* stw R10, <#[R11 + 76]> */
		/* 821BC3E4h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x0000004C) );
		/* 821BC3E4h case    3:*/		return 0x821BC3E8;
	}
	return 0x821BC3E8;
} // Block from 821BC3D8h-821BC3E8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BC3E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC3E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC3E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC3E8);
		  /* 821BC3E8h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821BC3E8h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821BC3E8h case    0:*/		return 0x821BC3EC;
		  /* 821BC3ECh */ case    1:  		/* lwz R11, <#[R11]> */
		/* 821BC3ECh case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821BC3ECh case    1:*/		return 0x821BC3F0;
		  /* 821BC3F0h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BC3F0h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BC3F0h case    2:*/		return 0x821BC3F4;
		  /* 821BC3F4h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 821BC3F4h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BC404;  }
		/* 821BC3F4h case    3:*/		return 0x821BC3F8;
	}
	return 0x821BC3F8;
} // Block from 821BC3E8h-821BC3F8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BC3F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC3F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC3F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC3F8);
		  /* 821BC3F8h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821BC3F8h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821BC3F8h case    0:*/		return 0x821BC3FC;
		  /* 821BC3FCh */ case    1:  		/* addic. R11, R11, -4 */
		/* 821BC3FCh case    1:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 821BC3FCh case    1:*/		return 0x821BC400;
		  /* 821BC400h */ case    2:  		/* bc 4, CR0_EQ, -164 */
		/* 821BC400h case    2:*/		if ( !regs.CR[0].eq ) { return 0x821BC35C;  }
		/* 821BC400h case    2:*/		return 0x821BC404;
	}
	return 0x821BC404;
} // Block from 821BC3F8h-821BC404h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BC404h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC404( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC404) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC404);
		  /* 821BC404h */ case    0:  		/* rlwinm. R11, R8, 0, 24, 31 */
		/* 821BC404h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R8);
		/* 821BC404h case    0:*/		return 0x821BC408;
		  /* 821BC408h */ case    1:  		/* bc 4, CR0_EQ, -196 */
		/* 821BC408h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821BC344;  }
		/* 821BC408h case    1:*/		return 0x821BC40C;
		  /* 821BC40Ch */ case    2:  		/* lwz R11, <#[R21 + 4]> */
		/* 821BC40Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000004) );
		/* 821BC40Ch case    2:*/		return 0x821BC410;
		  /* 821BC410h */ case    3:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 821BC410h case    3:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BC410h case    3:*/		return 0x821BC414;
		  /* 821BC414h */ case    4:  		/* addic R9, R10, -1 */
		/* 821BC414h case    4:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R10,0xFFFFFFFF);
		/* 821BC414h case    4:*/		return 0x821BC418;
		  /* 821BC418h */ case    5:  		/* subfe R9, R9, R9 */
		/* 821BC418h case    5:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 821BC418h case    5:*/		return 0x821BC41C;
		  /* 821BC41Ch */ case    6:  		/* and R9, R9, R11 */
		/* 821BC41Ch case    6:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 821BC41Ch case    6:*/		return 0x821BC420;
		  /* 821BC420h */ case    7:  		/* lwz R9, <#[R9 + 76]> */
		/* 821BC420h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x0000004C) );
		/* 821BC420h case    7:*/		return 0x821BC424;
		  /* 821BC424h */ case    8:  		/* rlwinm. R9, R9, 0, 4, 4 */
		/* 821BC424h case    8:*/		cpu::op::rlwinm<1,0,4,4>(regs,&regs.R9,regs.R9);
		/* 821BC424h case    8:*/		return 0x821BC428;
		  /* 821BC428h */ case    9:  		/* bc 12, CR0_EQ, 256 */
		/* 821BC428h case    9:*/		if ( regs.CR[0].eq ) { return 0x821BC528;  }
		/* 821BC428h case    9:*/		return 0x821BC42C;
		  /* 821BC42Ch */ case   10:  		/* cmplwi CR6, R10, 0 */
		/* 821BC42Ch case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821BC42Ch case   10:*/		return 0x821BC430;
		  /* 821BC430h */ case   11:  		/* bc 4, CR6_EQ, 248 */
		/* 821BC430h case   11:*/		if ( !regs.CR[6].eq ) { return 0x821BC528;  }
		/* 821BC430h case   11:*/		return 0x821BC434;
		  /* 821BC434h */ case   12:  		/* mr R29, R11 */
		/* 821BC434h case   12:*/		regs.R29 = regs.R11;
		/* 821BC434h case   12:*/		return 0x821BC438;
		  /* 821BC438h */ case   13:  		/* cmplwi CR0, R11, 0 */
		/* 821BC438h case   13:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821BC438h case   13:*/		return 0x821BC43C;
		  /* 821BC43Ch */ case   14:  		/* bc 12, CR0_EQ, 236 */
		/* 821BC43Ch case   14:*/		if ( regs.CR[0].eq ) { return 0x821BC528;  }
		/* 821BC43Ch case   14:*/		return 0x821BC440;
		  /* 821BC440h */ case   15:  		/* lwz R11, <#[R29 + 36]> */
		/* 821BC440h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000024) );
		/* 821BC440h case   15:*/		return 0x821BC444;
		  /* 821BC444h */ case   16:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821BC444h case   16:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821BC444h case   16:*/		return 0x821BC448;
		  /* 821BC448h */ case   17:  		/* bc 4, CR0_EQ, 196 */
		/* 821BC448h case   17:*/		if ( !regs.CR[0].eq ) { return 0x821BC50C;  }
		/* 821BC448h case   17:*/		return 0x821BC44C;
		  /* 821BC44Ch */ case   18:  		/* lwz R11, <#[R29 + 32]> */
		/* 821BC44Ch case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000020) );
		/* 821BC44Ch case   18:*/		return 0x821BC450;
		  /* 821BC450h */ case   19:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821BC450h case   19:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821BC450h case   19:*/		return 0x821BC454;
		  /* 821BC454h */ case   20:  		/* addic. R11, R11, -40 */
		/* 821BC454h case   20:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFD8);
		/* 821BC454h case   20:*/		return 0x821BC458;
		  /* 821BC458h */ case   21:  		/* bc 12, CR0_EQ, 180 */
		/* 821BC458h case   21:*/		if ( regs.CR[0].eq ) { return 0x821BC50C;  }
		/* 821BC458h case   21:*/		return 0x821BC45C;
		  /* 821BC45Ch */ case   22:  		/* lwz R11, <#[R11 + 8]> */
		/* 821BC45Ch case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821BC45Ch case   22:*/		return 0x821BC460;
		  /* 821BC460h */ case   23:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821BC460h case   23:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821BC460h case   23:*/		return 0x821BC464;
		  /* 821BC464h */ case   24:  		/* cmplwi CR6, R11, 10624 */
		/* 821BC464h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00002980);
		/* 821BC464h case   24:*/		return 0x821BC468;
		  /* 821BC468h */ case   25:  		/* bc 4, CR6_EQ, 164 */
		/* 821BC468h case   25:*/		if ( !regs.CR[6].eq ) { return 0x821BC50C;  }
		/* 821BC468h case   25:*/		return 0x821BC46C;
		  /* 821BC46Ch */ case   26:  		/* lwz R11, <#[R29 + 76]> */
		/* 821BC46Ch case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000004C) );
		/* 821BC46Ch case   26:*/		return 0x821BC470;
		  /* 821BC470h */ case   27:  		/* mr R30, R29 */
		/* 821BC470h case   27:*/		regs.R30 = regs.R29;
		/* 821BC470h case   27:*/		return 0x821BC474;
		  /* 821BC474h */ case   28:  		/* rlwinm. R11, R11, 0, 4, 4 */
		/* 821BC474h case   28:*/		cpu::op::rlwinm<1,0,4,4>(regs,&regs.R11,regs.R11);
		/* 821BC474h case   28:*/		return 0x821BC478;
		  /* 821BC478h */ case   29:  		/* bc 4, CR0_EQ, 76 */
		/* 821BC478h case   29:*/		if ( !regs.CR[0].eq ) { return 0x821BC4C4;  }
		/* 821BC478h case   29:*/		return 0x821BC47C;
		  /* 821BC47Ch */ case   30:  		/* lwz R11, <#[R30 + 52]> */
		/* 821BC47Ch case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000034) );
		/* 821BC47Ch case   30:*/		return 0x821BC480;
		  /* 821BC480h */ case   31:  		/* cmplwi CR6, R11, 0 */
		/* 821BC480h case   31:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BC480h case   31:*/		return 0x821BC484;
		  /* 821BC484h */ case   32:  		/* bc 12, CR6_EQ, 64 */
		/* 821BC484h case   32:*/		if ( regs.CR[6].eq ) { return 0x821BC4C4;  }
		/* 821BC484h case   32:*/		return 0x821BC488;
		  /* 821BC488h */ case   33:  		/* lwz R10, <#[R11 + 76]> */
		/* 821BC488h case   33:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000004C) );
		/* 821BC488h case   33:*/		return 0x821BC48C;
		  /* 821BC48Ch */ case   34:  		/* rlwinm. R10, R10, 0, 4, 4 */
		/* 821BC48Ch case   34:*/		cpu::op::rlwinm<1,0,4,4>(regs,&regs.R10,regs.R10);
		/* 821BC48Ch case   34:*/		return 0x821BC490;
		  /* 821BC490h */ case   35:  		/* bc 4, CR0_EQ, 12 */
		/* 821BC490h case   35:*/		if ( !regs.CR[0].eq ) { return 0x821BC49C;  }
		/* 821BC490h case   35:*/		return 0x821BC494;
		  /* 821BC494h */ case   36:  		/* mr R30, R11 */
		/* 821BC494h case   36:*/		regs.R30 = regs.R11;
		/* 821BC494h case   36:*/		return 0x821BC498;
		  /* 821BC498h */ case   37:  		/* b -28 */
		/* 821BC498h case   37:*/		return 0x821BC47C;
		/* 821BC498h case   37:*/		return 0x821BC49C;
	}
	return 0x821BC49C;
} // Block from 821BC404h-821BC49Ch (38 instructions)

//////////////////////////////////////////////////////
// Block at 821BC49Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC49C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC49C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC49C);
		  /* 821BC49Ch */ case    0:  		/* lwz R10, <#[R11 + 12]> */
		/* 821BC49Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 821BC49Ch case    0:*/		return 0x821BC4A0;
		  /* 821BC4A0h */ case    1:  		/* cmplwi CR6, R10, 0 */
		/* 821BC4A0h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821BC4A0h case    1:*/		return 0x821BC4A4;
		  /* 821BC4A4h */ case    2:  		/* bc 12, CR6_EQ, 28 */
		/* 821BC4A4h case    2:*/		if ( regs.CR[6].eq ) { return 0x821BC4C0;  }
		/* 821BC4A4h case    2:*/		return 0x821BC4A8;
		  /* 821BC4A8h */ case    3:  		/* lwz R9, <#[R10]> */
		/* 821BC4A8h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821BC4A8h case    3:*/		return 0x821BC4AC;
		  /* 821BC4ACh */ case    4:  		/* lwz R9, <#[R9 + 76]> */
		/* 821BC4ACh case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x0000004C) );
		/* 821BC4ACh case    4:*/		return 0x821BC4B0;
		  /* 821BC4B0h */ case    5:  		/* rlwinm. R9, R9, 0, 4, 4 */
		/* 821BC4B0h case    5:*/		cpu::op::rlwinm<1,0,4,4>(regs,&regs.R9,regs.R9);
		/* 821BC4B0h case    5:*/		return 0x821BC4B4;
		  /* 821BC4B4h */ case    6:  		/* bc 4, CR0_EQ, 16 */
		/* 821BC4B4h case    6:*/		if ( !regs.CR[0].eq ) { return 0x821BC4C4;  }
		/* 821BC4B4h case    6:*/		return 0x821BC4B8;
		  /* 821BC4B8h */ case    7:  		/* lwz R10, <#[R10 + 8]> */
		/* 821BC4B8h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 821BC4B8h case    7:*/		return 0x821BC4BC;
		  /* 821BC4BCh */ case    8:  		/* b -28 */
		/* 821BC4BCh case    8:*/		return 0x821BC4A0;
		/* 821BC4BCh case    8:*/		return 0x821BC4C0;
	}
	return 0x821BC4C0;
} // Block from 821BC49Ch-821BC4C0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821BC4C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC4C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC4C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC4C0);
		  /* 821BC4C0h */ case    0:  		/* mr R30, R11 */
		/* 821BC4C0h case    0:*/		regs.R30 = regs.R11;
		/* 821BC4C0h case    0:*/		return 0x821BC4C4;
	}
	return 0x821BC4C4;
} // Block from 821BC4C0h-821BC4C4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BC4C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC4C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC4C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC4C4);
		  /* 821BC4C4h */ case    0:  		/* li R8, 0 */
		/* 821BC4C4h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821BC4C4h case    0:*/		return 0x821BC4C8;
		  /* 821BC4C8h */ case    1:  		/* li R7, 0 */
		/* 821BC4C8h case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821BC4C8h case    1:*/		return 0x821BC4CC;
		  /* 821BC4CCh */ case    2:  		/* li R6, 95 */
		/* 821BC4CCh case    2:*/		cpu::op::li<0>(regs,&regs.R6,0x5F);
		/* 821BC4CCh case    2:*/		return 0x821BC4D0;
		  /* 821BC4D0h */ case    3:  		/* addi R5, R30, 24 */
		/* 821BC4D0h case    3:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R30,0x18);
		/* 821BC4D0h case    3:*/		return 0x821BC4D4;
		  /* 821BC4D4h */ case    4:  		/* mr R4, R30 */
		/* 821BC4D4h case    4:*/		regs.R4 = regs.R30;
		/* 821BC4D4h case    4:*/		return 0x821BC4D8;
		  /* 821BC4D8h */ case    5:  		/* mr R3, R21 */
		/* 821BC4D8h case    5:*/		regs.R3 = regs.R21;
		/* 821BC4D8h case    5:*/		return 0x821BC4DC;
		  /* 821BC4DCh */ case    6:  		/* bl 427196 */
		/* 821BC4DCh case    6:*/		regs.LR = 0x821BC4E0; return 0x82224998;
		/* 821BC4DCh case    6:*/		return 0x821BC4E0;
		  /* 821BC4E0h */ case    7:  		/* lwz R5, <#[R30 + 104]> */
		/* 821BC4E0h case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R30 + 0x00000068) );
		/* 821BC4E0h case    7:*/		return 0x821BC4E4;
		  /* 821BC4E4h */ case    8:  		/* mr R31, R3 */
		/* 821BC4E4h case    8:*/		regs.R31 = regs.R3;
		/* 821BC4E4h case    8:*/		return 0x821BC4E8;
		  /* 821BC4E8h */ case    9:  		/* cmplwi CR6, R5, 0 */
		/* 821BC4E8h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 821BC4E8h case    9:*/		return 0x821BC4EC;
		  /* 821BC4ECh */ case   10:  		/* bc 12, CR6_EQ, 16 */
		/* 821BC4ECh case   10:*/		if ( regs.CR[6].eq ) { return 0x821BC4FC;  }
		/* 821BC4ECh case   10:*/		return 0x821BC4F0;
		  /* 821BC4F0h */ case   11:  		/* mr R6, R21 */
		/* 821BC4F0h case   11:*/		regs.R6 = regs.R21;
		/* 821BC4F0h case   11:*/		return 0x821BC4F4;
		  /* 821BC4F4h */ case   12:  		/* li R4, 3 */
		/* 821BC4F4h case   12:*/		cpu::op::li<0>(regs,&regs.R4,0x3);
		/* 821BC4F4h case   12:*/		return 0x821BC4F8;
		  /* 821BC4F8h */ case   13:  		/* bl -277376 */
		/* 821BC4F8h case   13:*/		regs.LR = 0x821BC4FC; return 0x82178978;
		/* 821BC4F8h case   13:*/		return 0x821BC4FC;
	}
	return 0x821BC4FC;
} // Block from 821BC4C4h-821BC4FCh (14 instructions)

//////////////////////////////////////////////////////
// Block at 821BC4FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC4FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC4FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC4FC);
		  /* 821BC4FCh */ case    0:  		/* stw R31, <#[R30 + 104]> */
		/* 821BC4FCh case    0:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x00000068) );
		/* 821BC4FCh case    0:*/		return 0x821BC500;
		  /* 821BC500h */ case    1:  		/* lwz R11, <#[R31 + 8]> */
		/* 821BC500h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821BC500h case    1:*/		return 0x821BC504;
		  /* 821BC504h */ case    2:  		/* oris R11, R11, 512 */
		/* 821BC504h case    2:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x200);
		/* 821BC504h case    2:*/		return 0x821BC508;
		  /* 821BC508h */ case    3:  		/* stw R11, <#[R31 + 8]> */
		/* 821BC508h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821BC508h case    3:*/		return 0x821BC50C;
	}
	return 0x821BC50C;
} // Block from 821BC4FCh-821BC50Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BC50Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC50C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC50C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC50C);
		  /* 821BC50Ch */ case    0:  		/* rlwinm R11, R29, 0, 0, 30 */
		/* 821BC50Ch case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R29);
		/* 821BC50Ch case    0:*/		return 0x821BC510;
		  /* 821BC510h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 821BC510h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821BC510h case    1:*/		return 0x821BC514;
		  /* 821BC514h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BC514h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BC514h case    2:*/		return 0x821BC518;
		  /* 821BC518h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 821BC518h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BC528;  }
		/* 821BC518h case    3:*/		return 0x821BC51C;
		  /* 821BC51Ch */ case    4:  		/* mr R29, R11 */
		/* 821BC51Ch case    4:*/		regs.R29 = regs.R11;
		/* 821BC51Ch case    4:*/		return 0x821BC520;
		  /* 821BC520h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821BC520h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BC520h case    5:*/		return 0x821BC524;
		  /* 821BC524h */ case    6:  		/* bc 4, CR6_EQ, -228 */
		/* 821BC524h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821BC440;  }
		/* 821BC524h case    6:*/		return 0x821BC528;
	}
	return 0x821BC528;
} // Block from 821BC50Ch-821BC528h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BC528h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC528( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC528) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC528);
		  /* 821BC528h */ case    0:  		/* lwz R11, <#[R21 + 40]> */
		/* 821BC528h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000028) );
		/* 821BC528h case    0:*/		return 0x821BC52C;
		  /* 821BC52Ch */ case    1:  		/* lwz R31, <#[R21 + 4]> */
		/* 821BC52Ch case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R21 + 0x00000004) );
		/* 821BC52Ch case    1:*/		return 0x821BC530;
		  /* 821BC530h */ case    2:  		/* ori R11, R11, 16384 */
		/* 821BC530h case    2:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x4000);
		/* 821BC530h case    2:*/		return 0x821BC534;
		  /* 821BC534h */ case    3:  		/* rlwinm. R10, R31, 0, 31, 31 */
		/* 821BC534h case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R31);
		/* 821BC534h case    3:*/		return 0x821BC538;
		  /* 821BC538h */ case    4:  		/* stw R11, <#[R21 + 40]> */
		/* 821BC538h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R21 + 0x00000028) );
		/* 821BC538h case    4:*/		return 0x821BC53C;
		  /* 821BC53Ch */ case    5:  		/* bc 4, CR0_EQ, 48 */
		/* 821BC53Ch case    5:*/		if ( !regs.CR[0].eq ) { return 0x821BC56C;  }
		/* 821BC53Ch case    5:*/		return 0x821BC540;
		  /* 821BC540h */ case    6:  		/* cmplwi CR0, R31, 0 */
		/* 821BC540h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R31,0x00000000);
		/* 821BC540h case    6:*/		return 0x821BC544;
		  /* 821BC544h */ case    7:  		/* bc 12, CR0_EQ, 40 */
		/* 821BC544h case    7:*/		if ( regs.CR[0].eq ) { return 0x821BC56C;  }
		/* 821BC544h case    7:*/		return 0x821BC548;
		  /* 821BC548h */ case    8:  		/* mr R4, R31 */
		/* 821BC548h case    8:*/		regs.R4 = regs.R31;
		/* 821BC548h case    8:*/		return 0x821BC54C;
		  /* 821BC54Ch */ case    9:  		/* mr R3, R21 */
		/* 821BC54Ch case    9:*/		regs.R3 = regs.R21;
		/* 821BC54Ch case    9:*/		return 0x821BC550;
		  /* 821BC550h */ case   10:  		/* bl -11360 */
		/* 821BC550h case   10:*/		regs.LR = 0x821BC554; return 0x821B98F0;
		/* 821BC550h case   10:*/		return 0x821BC554;
		  /* 821BC554h */ case   11:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821BC554h case   11:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821BC554h case   11:*/		return 0x821BC558;
		  /* 821BC558h */ case   12:  		/* lwz R31, <#[R11 + 4]> */
		/* 821BC558h case   12:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000004) );
		/* 821BC558h case   12:*/		return 0x821BC55C;
		  /* 821BC55Ch */ case   13:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 821BC55Ch case   13:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 821BC55Ch case   13:*/		return 0x821BC560;
		  /* 821BC560h */ case   14:  		/* bc 4, CR0_EQ, 12 */
		/* 821BC560h case   14:*/		if ( !regs.CR[0].eq ) { return 0x821BC56C;  }
		/* 821BC560h case   14:*/		return 0x821BC564;
		  /* 821BC564h */ case   15:  		/* cmplwi CR6, R31, 0 */
		/* 821BC564h case   15:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821BC564h case   15:*/		return 0x821BC568;
		  /* 821BC568h */ case   16:  		/* bc 4, CR6_EQ, -32 */
		/* 821BC568h case   16:*/		if ( !regs.CR[6].eq ) { return 0x821BC548;  }
		/* 821BC568h case   16:*/		return 0x821BC56C;
	}
	return 0x821BC56C;
} // Block from 821BC528h-821BC56Ch (17 instructions)

//////////////////////////////////////////////////////
// Block at 821BC56Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC56C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC56C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC56C);
		  /* 821BC56Ch */ case    0:  		/* lwz R11, <#[R21 + 40]> */
		/* 821BC56Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000028) );
		/* 821BC56Ch case    0:*/		return 0x821BC570;
		  /* 821BC570h */ case    1:  		/* rlwinm. R11, R11, 0, 27, 27 */
		/* 821BC570h case    1:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R11,regs.R11);
		/* 821BC570h case    1:*/		return 0x821BC574;
		  /* 821BC574h */ case    2:  		/* bc 12, CR0_EQ, 764 */
		/* 821BC574h case    2:*/		if ( regs.CR[0].eq ) { return 0x821BC870;  }
		/* 821BC574h case    2:*/		return 0x821BC578;
		  /* 821BC578h */ case    3:  		/* lwz R11, <#[R21 + 4]> */
		/* 821BC578h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000004) );
		/* 821BC578h case    3:*/		return 0x821BC57C;
		  /* 821BC57Ch */ case    4:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BC57Ch case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BC57Ch case    4:*/		return 0x821BC580;
		  /* 821BC580h */ case    5:  		/* bc 4, CR0_EQ, 752 */
		/* 821BC580h case    5:*/		if ( !regs.CR[0].eq ) { return 0x821BC870;  }
		/* 821BC580h case    5:*/		return 0x821BC584;
		  /* 821BC584h */ case    6:  		/* mr R23, R11 */
		/* 821BC584h case    6:*/		regs.R23 = regs.R11;
		/* 821BC584h case    6:*/		return 0x821BC588;
		  /* 821BC588h */ case    7:  		/* cmplwi CR0, R11, 0 */
		/* 821BC588h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821BC588h case    7:*/		return 0x821BC58C;
		  /* 821BC58Ch */ case    8:  		/* bc 12, CR0_EQ, 740 */
		/* 821BC58Ch case    8:*/		if ( regs.CR[0].eq ) { return 0x821BC870;  }
		/* 821BC58Ch case    8:*/		return 0x821BC590;
		  /* 821BC590h */ case    9:  		/* lwz R11, <#[R23 + 28]> */
		/* 821BC590h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x0000001C) );
		/* 821BC590h case    9:*/		return 0x821BC594;
		  /* 821BC594h */ case   10:  		/* addi R22, R23, 24 */
		/* 821BC594h case   10:*/		cpu::op::addi<0>(regs,&regs.R22,regs.R23,0x18);
		/* 821BC594h case   10:*/		return 0x821BC598;
		  /* 821BC598h */ case   11:  		/* li R24, 0 */
		/* 821BC598h case   11:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 821BC598h case   11:*/		return 0x821BC59C;
		  /* 821BC59Ch */ case   12:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BC59Ch case   12:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BC59Ch case   12:*/		return 0x821BC5A0;
		  /* 821BC5A0h */ case   13:  		/* bc 4, CR0_EQ, 692 */
		/* 821BC5A0h case   13:*/		if ( !regs.CR[0].eq ) { return 0x821BC854;  }
		/* 821BC5A0h case   13:*/		return 0x821BC5A4;
		  /* 821BC5A4h */ case   14:  		/* mr R30, R11 */
		/* 821BC5A4h case   14:*/		regs.R30 = regs.R11;
		/* 821BC5A4h case   14:*/		return 0x821BC5A8;
		  /* 821BC5A8h */ case   15:  		/* cmplwi CR0, R11, 0 */
		/* 821BC5A8h case   15:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821BC5A8h case   15:*/		return 0x821BC5AC;
		  /* 821BC5ACh */ case   16:  		/* bc 12, CR0_EQ, 680 */
		/* 821BC5ACh case   16:*/		if ( regs.CR[0].eq ) { return 0x821BC854;  }
		/* 821BC5ACh case   16:*/		return 0x821BC5B0;
		  /* 821BC5B0h */ case   17:  		/* lwz R11, <#[R30 + 8]> */
		/* 821BC5B0h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821BC5B0h case   17:*/		return 0x821BC5B4;
		  /* 821BC5B4h */ case   18:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821BC5B4h case   18:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821BC5B4h case   18:*/		return 0x821BC5B8;
		  /* 821BC5B8h */ case   19:  		/* cmplwi CR6, R11, 15104 */
		/* 821BC5B8h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003B00);
		/* 821BC5B8h case   19:*/		return 0x821BC5BC;
		  /* 821BC5BCh */ case   20:  		/* bc 4, CR6_EQ, 552 */
		/* 821BC5BCh case   20:*/		if ( !regs.CR[6].eq ) { return 0x821BC7E4;  }
		/* 821BC5BCh case   20:*/		return 0x821BC5C0;
		  /* 821BC5C0h */ case   21:  		/* lwz R11, <#[R30 + 48]> */
		/* 821BC5C0h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000030) );
		/* 821BC5C0h case   21:*/		return 0x821BC5C4;
		  /* 821BC5C4h */ case   22:  		/* addi R25, R30, 4 */
		/* 821BC5C4h case   22:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R30,0x4);
		/* 821BC5C4h case   22:*/		return 0x821BC5C8;
		  /* 821BC5C8h */ case   23:  		/* lwz R10, <#[R30 + 44]> */
		/* 821BC5C8h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000002C) );
		/* 821BC5C8h case   23:*/		return 0x821BC5CC;
		  /* 821BC5CCh */ case   24:  		/* lwz R26, <#[R11 + 12]> */
		/* 821BC5CCh case   24:*/		cpu::mem::load32z( regs, &regs.R26, (uint32)(regs.R11 + 0x0000000C) );
		/* 821BC5CCh case   24:*/		return 0x821BC5D0;
		  /* 821BC5D0h */ case   25:  		/* lwz R28, <#[R10 + 12]> */
		/* 821BC5D0h case   25:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R10 + 0x0000000C) );
		/* 821BC5D0h case   25:*/		return 0x821BC5D4;
		  /* 821BC5D4h */ case   26:  		/* lwz R31, <#[R25]> */
		/* 821BC5D4h case   26:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R25 + 0x00000000) );
		/* 821BC5D4h case   26:*/		return 0x821BC5D8;
		  /* 821BC5D8h */ case   27:  		/* cmplwi CR6, R31, 0 */
		/* 821BC5D8h case   27:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821BC5D8h case   27:*/		return 0x821BC5DC;
		  /* 821BC5DCh */ case   28:  		/* bc 12, CR6_EQ, 500 */
		/* 821BC5DCh case   28:*/		if ( regs.CR[6].eq ) { return 0x821BC7D0;  }
		/* 821BC5DCh case   28:*/		return 0x821BC5E0;
		  /* 821BC5E0h */ case   29:  		/* lwz R29, <#[R31 + 16]> */
		/* 821BC5E0h case   29:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R31 + 0x00000010) );
		/* 821BC5E0h case   29:*/		return 0x821BC5E4;
		  /* 821BC5E4h */ case   30:  		/* cmplwi CR6, R29, 0 */
		/* 821BC5E4h case   30:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 821BC5E4h case   30:*/		return 0x821BC5E8;
		  /* 821BC5E8h */ case   31:  		/* bc 12, CR6_EQ, 468 */
		/* 821BC5E8h case   31:*/		if ( regs.CR[6].eq ) { return 0x821BC7BC;  }
		/* 821BC5E8h case   31:*/		return 0x821BC5EC;
		  /* 821BC5ECh */ case   32:  		/* lwz R11, <#[R31 + 12]> */
		/* 821BC5ECh case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 821BC5ECh case   32:*/		return 0x821BC5F0;
		  /* 821BC5F0h */ case   33:  		/* addi R11, R11, 4 */
		/* 821BC5F0h case   33:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821BC5F0h case   33:*/		return 0x821BC5F4;
		  /* 821BC5F4h */ case   34:  		/* lwz R10, <#[R11]> */
		/* 821BC5F4h case   34:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821BC5F4h case   34:*/		return 0x821BC5F8;
		  /* 821BC5F8h */ case   35:  		/* b 12 */
		/* 821BC5F8h case   35:*/		return 0x821BC604;
		/* 821BC5F8h case   35:*/		return 0x821BC5FC;
		  /* 821BC5FCh */ case   36:  		/* addi R11, R10, 8 */
		/* 821BC5FCh case   36:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 821BC5FCh case   36:*/		return 0x821BC600;
		  /* 821BC600h */ case   37:  		/* lwz R10, <#[R10 + 8]> */
		/* 821BC600h case   37:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 821BC600h case   37:*/		return 0x821BC604;
	}
	return 0x821BC604;
} // Block from 821BC56Ch-821BC604h (38 instructions)

//////////////////////////////////////////////////////
// Block at 821BC604h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC604( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC604) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC604);
		  /* 821BC604h */ case    0:  		/* cmplw CR6, R10, R31 */
		/* 821BC604h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 821BC604h case    0:*/		return 0x821BC608;
		  /* 821BC608h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 821BC608h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BC5FC;  }
		/* 821BC608h case    1:*/		return 0x821BC60C;
		  /* 821BC60Ch */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 821BC60Ch case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 821BC60Ch case    2:*/		return 0x821BC610;
		  /* 821BC610h */ case    3:  		/* li R5, 0 */
		/* 821BC610h case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821BC610h case    3:*/		return 0x821BC614;
		  /* 821BC614h */ case    4:  		/* mr R4, R26 */
		/* 821BC614h case    4:*/		regs.R4 = regs.R26;
		/* 821BC614h case    4:*/		return 0x821BC618;
		  /* 821BC618h */ case    5:  		/* mr R3, R21 */
		/* 821BC618h case    5:*/		regs.R3 = regs.R21;
		/* 821BC618h case    5:*/		return 0x821BC61C;
		  /* 821BC61Ch */ case    6:  		/* stw R10, <#[R11]> */
		/* 821BC61Ch case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821BC61Ch case    6:*/		return 0x821BC620;
		  /* 821BC620h */ case    7:  		/* lwz R11, <#[R28 + 4]> */
		/* 821BC620h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000004) );
		/* 821BC620h case    7:*/		return 0x821BC624;
		  /* 821BC624h */ case    8:  		/* stw R11, <#[R31 + 8]> */
		/* 821BC624h case    8:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821BC624h case    8:*/		return 0x821BC628;
		  /* 821BC628h */ case    9:  		/* stw R31, <#[R28 + 4]> */
		/* 821BC628h case    9:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R28 + 0x00000004) );
		/* 821BC628h case    9:*/		return 0x821BC62C;
		  /* 821BC62Ch */ case   10:  		/* stw R28, <#[R31 + 12]> */
		/* 821BC62Ch case   10:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R31 + 0x0000000C) );
		/* 821BC62Ch case   10:*/		return 0x821BC630;
		  /* 821BC630h */ case   11:  		/* lwz R11, <#[R30 + 44]> */
		/* 821BC630h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000002C) );
		/* 821BC630h case   11:*/		return 0x821BC634;
		  /* 821BC634h */ case   12:  		/* lwz R10, <#[R31]> */
		/* 821BC634h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 821BC634h case   12:*/		return 0x821BC638;
		  /* 821BC638h */ case   13:  		/* lwz R11, <#[R11]> */
		/* 821BC638h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821BC638h case   13:*/		return 0x821BC63C;
		  /* 821BC63Ch */ case   14:  		/* rlwinm R11, R11, 27, 24, 31 */
		/* 821BC63Ch case   14:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R11,regs.R11);
		/* 821BC63Ch case   14:*/		return 0x821BC640;
		  /* 821BC640h */ case   15:  		/* rlwinm R9, R10, 22, 29, 30 */
		/* 821BC640h case   15:*/		cpu::op::rlwinm<0,22,29,30>(regs,&regs.R9,regs.R10);
		/* 821BC640h case   15:*/		return 0x821BC644;
		  /* 821BC644h */ case   16:  		/* rlwinm R8, R10, 24, 29, 30 */
		/* 821BC644h case   16:*/		cpu::op::rlwinm<0,24,29,30>(regs,&regs.R8,regs.R10);
		/* 821BC644h case   16:*/		return 0x821BC648;
		  /* 821BC648h */ case   17:  		/* srw R9, R11, R9 */
		/* 821BC648h case   17:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R11,regs.R9);
		/* 821BC648h case   17:*/		return 0x821BC64C;
		  /* 821BC64Ch */ case   18:  		/* srw R8, R11, R8 */
		/* 821BC64Ch case   18:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R11,regs.R8);
		/* 821BC64Ch case   18:*/		return 0x821BC650;
		  /* 821BC650h */ case   19:  		/* rlwinm R7, R10, 26, 29, 30 */
		/* 821BC650h case   19:*/		cpu::op::rlwinm<0,26,29,30>(regs,&regs.R7,regs.R10);
		/* 821BC650h case   19:*/		return 0x821BC654;
		  /* 821BC654h */ case   20:  		/* rlwimi R8, R9, 2, 28, 29 */
		/* 821BC654h case   20:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R8,regs.R9);
		/* 821BC654h case   20:*/		return 0x821BC658;
		  /* 821BC658h */ case   21:  		/* srw R7, R11, R7 */
		/* 821BC658h case   21:*/		cpu::op::srw<0>(regs,&regs.R7,regs.R11,regs.R7);
		/* 821BC658h case   21:*/		return 0x821BC65C;
		  /* 821BC65Ch */ case   22:  		/* rlwinm R9, R10, 28, 29, 30 */
		/* 821BC65Ch case   22:*/		cpu::op::rlwinm<0,28,29,30>(regs,&regs.R9,regs.R10);
		/* 821BC65Ch case   22:*/		return 0x821BC660;
		  /* 821BC660h */ case   23:  		/* rlwinm R8, R8, 0, 28, 31 */
		/* 821BC660h case   23:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R8,regs.R8);
		/* 821BC660h case   23:*/		return 0x821BC664;
		  /* 821BC664h */ case   24:  		/* srw R11, R11, R9 */
		/* 821BC664h case   24:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R9);
		/* 821BC664h case   24:*/		return 0x821BC668;
		  /* 821BC668h */ case   25:  		/* rlwimi R7, R8, 2, 0, 29 */
		/* 821BC668h case   25:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R7,regs.R8);
		/* 821BC668h case   25:*/		return 0x821BC66C;
		  /* 821BC66Ch */ case   26:  		/* rlwinm R10, R10, 0, 27, 18 */
		/* 821BC66Ch case   26:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R10,regs.R10);
		/* 821BC66Ch case   26:*/		return 0x821BC670;
		  /* 821BC670h */ case   27:  		/* rlwimi R11, R7, 2, 0, 29 */
		/* 821BC670h case   27:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R11,regs.R7);
		/* 821BC670h case   27:*/		return 0x821BC674;
		  /* 821BC674h */ case   28:  		/* rlwinm R11, R11, 5, 0, 26 */
		/* 821BC674h case   28:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R11);
		/* 821BC674h case   28:*/		return 0x821BC678;
		  /* 821BC678h */ case   29:  		/* or R11, R11, R10 */
		/* 821BC678h case   29:*/		cpu::op::or<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821BC678h case   29:*/		return 0x821BC67C;
		  /* 821BC67Ch */ case   30:  		/* stw R11, <#[R31]> */
		/* 821BC67Ch case   30:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821BC67Ch case   30:*/		return 0x821BC680;
		  /* 821BC680h */ case   31:  		/* bl -311088 */
		/* 821BC680h case   31:*/		regs.LR = 0x821BC684; return 0x82170750;
		/* 821BC680h case   31:*/		return 0x821BC684;
		  /* 821BC684h */ case   32:  		/* lwz R11, <#[R29]> */
		/* 821BC684h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 821BC684h case   32:*/		return 0x821BC688;
		  /* 821BC688h */ case   33:  		/* mr R27, R3 */
		/* 821BC688h case   33:*/		regs.R27 = regs.R3;
		/* 821BC688h case   33:*/		return 0x821BC68C;
		  /* 821BC68Ch */ case   34:  		/* li R8, 0 */
		/* 821BC68Ch case   34:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821BC68Ch case   34:*/		return 0x821BC690;
		  /* 821BC690h */ case   35:  		/* cmplwi CR6, R11, 0 */
		/* 821BC690h case   35:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BC690h case   35:*/		return 0x821BC694;
		  /* 821BC694h */ case   36:  		/* bc 12, CR6_EQ, 88 */
		/* 821BC694h case   36:*/		if ( regs.CR[6].eq ) { return 0x821BC6EC;  }
		/* 821BC694h case   36:*/		return 0x821BC698;
		  /* 821BC698h */ case   37:  		/* lwz R9, <#[R11]> */
		/* 821BC698h case   37:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821BC698h case   37:*/		return 0x821BC69C;
		  /* 821BC69Ch */ case   38:  		/* rlwinm. R10, R9, 7, 29, 31 */
		/* 821BC69Ch case   38:*/		cpu::op::rlwinm<1,7,29,31>(regs,&regs.R10,regs.R9);
		/* 821BC69Ch case   38:*/		return 0x821BC6A0;
		  /* 821BC6A0h */ case   39:  		/* bc 12, CR0_EQ, 12 */
		/* 821BC6A0h case   39:*/		if ( regs.CR[0].eq ) { return 0x821BC6AC;  }
		/* 821BC6A0h case   39:*/		return 0x821BC6A4;
		  /* 821BC6A4h */ case   40:  		/* rlwinm. R7, R9, 0, 27, 27 */
		/* 821BC6A4h case   40:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R7,regs.R9);
		/* 821BC6A4h case   40:*/		return 0x821BC6A8;
		  /* 821BC6A8h */ case   41:  		/* bc 4, CR0_EQ, 64 */
		/* 821BC6A8h case   41:*/		if ( !regs.CR[0].eq ) { return 0x821BC6E8;  }
		/* 821BC6A8h case   41:*/		return 0x821BC6AC;
	}
	return 0x821BC6AC;
} // Block from 821BC604h-821BC6ACh (42 instructions)

//////////////////////////////////////////////////////
// Block at 821BC6ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC6AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC6AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC6AC);
		  /* 821BC6ACh */ case    0:  		/* rlwinm. R7, R9, 0, 1, 1 */
		/* 821BC6ACh case    0:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R7,regs.R9);
		/* 821BC6ACh case    0:*/		return 0x821BC6B0;
		  /* 821BC6B0h */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 821BC6B0h case    1:*/		if ( regs.CR[0].eq ) { return 0x821BC6C0;  }
		/* 821BC6B0h case    1:*/		return 0x821BC6B4;
		  /* 821BC6B4h */ case    2:  		/* cmplwi CR6, R10, 0 */
		/* 821BC6B4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821BC6B4h case    2:*/		return 0x821BC6B8;
		  /* 821BC6B8h */ case    3:  		/* li R10, 1 */
		/* 821BC6B8h case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 821BC6B8h case    3:*/		return 0x821BC6BC;
		  /* 821BC6BCh */ case    4:  		/* bc 12, CR6_EQ, 8 */
		/* 821BC6BCh case    4:*/		if ( regs.CR[6].eq ) { return 0x821BC6C4;  }
		/* 821BC6BCh case    4:*/		return 0x821BC6C0;
	}
	return 0x821BC6C0;
} // Block from 821BC6ACh-821BC6C0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BC6C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC6C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC6C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC6C0);
		  /* 821BC6C0h */ case    0:  		/* li R10, 0 */
		/* 821BC6C0h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821BC6C0h case    0:*/		return 0x821BC6C4;
	}
	return 0x821BC6C4;
} // Block from 821BC6C0h-821BC6C4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BC6C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC6C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC6C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC6C4);
		  /* 821BC6C4h */ case    0:  		/* rlwinm. R10, R10, 0, 24, 31 */
		/* 821BC6C4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R10);
		/* 821BC6C4h case    0:*/		return 0x821BC6C8;
		  /* 821BC6C8h */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 821BC6C8h case    1:*/		if ( regs.CR[0].eq ) { return 0x821BC6E0;  }
		/* 821BC6C8h case    1:*/		return 0x821BC6CC;
		  /* 821BC6CCh */ case    2:  		/* rlwinm. R10, R9, 0, 7, 18 */
		/* 821BC6CCh case    2:*/		cpu::op::rlwinm<1,0,7,18>(regs,&regs.R10,regs.R9);
		/* 821BC6CCh case    2:*/		return 0x821BC6D0;
		  /* 821BC6D0h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 821BC6D0h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BC6E0;  }
		/* 821BC6D0h case    3:*/		return 0x821BC6D4;
		  /* 821BC6D4h */ case    4:  		/* lwz R10, <#[R11 + 12]> */
		/* 821BC6D4h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 821BC6D4h case    4:*/		return 0x821BC6D8;
		  /* 821BC6D8h */ case    5:  		/* cmplw CR6, R10, R26 */
		/* 821BC6D8h case    5:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R26);
		/* 821BC6D8h case    5:*/		return 0x821BC6DC;
		  /* 821BC6DCh */ case    6:  		/* bc 4, CR6_EQ, 12 */
		/* 821BC6DCh case    6:*/		if ( !regs.CR[6].eq ) { return 0x821BC6E8;  }
		/* 821BC6DCh case    6:*/		return 0x821BC6E0;
	}
	return 0x821BC6E0;
} // Block from 821BC6C4h-821BC6E0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BC6E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC6E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC6E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC6E0);
		  /* 821BC6E0h */ case    0:  		/* lwz R11, <#[R11 + 4]> */
		/* 821BC6E0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821BC6E0h case    0:*/		return 0x821BC6E4;
		  /* 821BC6E4h */ case    1:  		/* b -84 */
		/* 821BC6E4h case    1:*/		return 0x821BC690;
		/* 821BC6E4h case    1:*/		return 0x821BC6E8;
	}
	return 0x821BC6E8;
} // Block from 821BC6E0h-821BC6E8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BC6E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC6E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC6E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC6E8);
		  /* 821BC6E8h */ case    0:  		/* li R8, 1 */
		/* 821BC6E8h case    0:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 821BC6E8h case    0:*/		return 0x821BC6EC;
	}
	return 0x821BC6EC;
} // Block from 821BC6E8h-821BC6ECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BC6ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC6EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC6EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC6EC);
		  /* 821BC6ECh */ case    0:  		/* rlwinm. R11, R8, 0, 24, 31 */
		/* 821BC6ECh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R8);
		/* 821BC6ECh case    0:*/		return 0x821BC6F0;
		  /* 821BC6F0h */ case    1:  		/* bc 4, CR0_EQ, 156 */
		/* 821BC6F0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821BC78C;  }
		/* 821BC6F0h case    1:*/		return 0x821BC6F4;
		  /* 821BC6F4h */ case    2:  		/* lwz R11, <#[R29 + 8]> */
		/* 821BC6F4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 821BC6F4h case    2:*/		return 0x821BC6F8;
		  /* 821BC6F8h */ case    3:  		/* lis R10, 16 */
		/* 821BC6F8h case    3:*/		cpu::op::lis<0>(regs,&regs.R10,0x10);
		/* 821BC6F8h case    3:*/		return 0x821BC6FC;
		  /* 821BC6FCh */ case    4:  		/* rlwinm R11, R11, 0, 10, 12 */
		/* 821BC6FCh case    4:*/		cpu::op::rlwinm<0,0,10,12>(regs,&regs.R11,regs.R11);
		/* 821BC6FCh case    4:*/		return 0x821BC700;
		  /* 821BC700h */ case    5:  		/* cmplw CR6, R11, R10 */
		/* 821BC700h case    5:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821BC700h case    5:*/		return 0x821BC704;
		  /* 821BC704h */ case    6:  		/* bc 4, CR6_GT, 136 */
		/* 821BC704h case    6:*/		if ( !regs.CR[6].gt ) { return 0x821BC78C;  }
		/* 821BC704h case    6:*/		return 0x821BC708;
		  /* 821BC708h */ case    7:  		/* lwz R11, <#[R29 + 52]> */
		/* 821BC708h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000034) );
		/* 821BC708h case    7:*/		return 0x821BC70C;
		  /* 821BC70Ch */ case    8:  		/* cmplw CR6, R31, R11 */
		/* 821BC70Ch case    8:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 821BC70Ch case    8:*/		return 0x821BC710;
		  /* 821BC710h */ case    9:  		/* bc 4, CR6_EQ, 124 */
		/* 821BC710h case    9:*/		if ( !regs.CR[6].eq ) { return 0x821BC78C;  }
		/* 821BC710h case    9:*/		return 0x821BC714;
		  /* 821BC714h */ case   10:  		/* lwz R11, <#[R29 + 44]> */
		/* 821BC714h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000002C) );
		/* 821BC714h case   10:*/		return 0x821BC718;
		  /* 821BC718h */ case   11:  		/* lwz R11, <#[R11 + 12]> */
		/* 821BC718h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 821BC718h case   11:*/		return 0x821BC71C;
		  /* 821BC71Ch */ case   12:  		/* lwz R11, <#[R11 + 8]> */
		/* 821BC71Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821BC71Ch case   12:*/		return 0x821BC720;
		  /* 821BC720h */ case   13:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821BC720h case   13:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821BC720h case   13:*/		return 0x821BC724;
		  /* 821BC724h */ case   14:  		/* cmplwi CR6, R11, 125 */
		/* 821BC724h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 821BC724h case   14:*/		return 0x821BC728;
		  /* 821BC728h */ case   15:  		/* bc 12, CR6_EQ, 16 */
		/* 821BC728h case   15:*/		if ( regs.CR[6].eq ) { return 0x821BC738;  }
		/* 821BC728h case   15:*/		return 0x821BC72C;
		  /* 821BC72Ch */ case   16:  		/* cmplwi CR6, R11, 124 */
		/* 821BC72Ch case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 821BC72Ch case   16:*/		return 0x821BC730;
		  /* 821BC730h */ case   17:  		/* li R11, 0 */
		/* 821BC730h case   17:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BC730h case   17:*/		return 0x821BC734;
		  /* 821BC734h */ case   18:  		/* bc 4, CR6_EQ, 8 */
		/* 821BC734h case   18:*/		if ( !regs.CR[6].eq ) { return 0x821BC73C;  }
		/* 821BC734h case   18:*/		return 0x821BC738;
	}
	return 0x821BC738;
} // Block from 821BC6ECh-821BC738h (19 instructions)

//////////////////////////////////////////////////////
// Block at 821BC738h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC738( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC738) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC738);
		  /* 821BC738h */ case    0:  		/* li R11, 1 */
		/* 821BC738h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821BC738h case    0:*/		return 0x821BC73C;
	}
	return 0x821BC73C;
} // Block from 821BC738h-821BC73Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BC73Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC73C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC73C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC73C);
		  /* 821BC73Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821BC73Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821BC73Ch case    0:*/		return 0x821BC740;
		  /* 821BC740h */ case    1:  		/* bc 12, CR0_EQ, 76 */
		/* 821BC740h case    1:*/		if ( regs.CR[0].eq ) { return 0x821BC78C;  }
		/* 821BC740h case    1:*/		return 0x821BC744;
		  /* 821BC744h */ case    2:  		/* lwz R10, <#[R29 + 48]> */
		/* 821BC744h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000030) );
		/* 821BC744h case    2:*/		return 0x821BC748;
		  /* 821BC748h */ case    3:  		/* lwz R11, <#[R10 + 12]> */
		/* 821BC748h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		/* 821BC748h case    3:*/		return 0x821BC74C;
		  /* 821BC74Ch */ case    4:  		/* lwz R11, <#[R11 + 8]> */
		/* 821BC74Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821BC74Ch case    4:*/		return 0x821BC750;
		  /* 821BC750h */ case    5:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821BC750h case    5:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821BC750h case    5:*/		return 0x821BC754;
		  /* 821BC754h */ case    6:  		/* cmplwi CR6, R11, 125 */
		/* 821BC754h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 821BC754h case    6:*/		return 0x821BC758;
		  /* 821BC758h */ case    7:  		/* bc 12, CR6_EQ, 16 */
		/* 821BC758h case    7:*/		if ( regs.CR[6].eq ) { return 0x821BC768;  }
		/* 821BC758h case    7:*/		return 0x821BC75C;
		  /* 821BC75Ch */ case    8:  		/* cmplwi CR6, R11, 124 */
		/* 821BC75Ch case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 821BC75Ch case    8:*/		return 0x821BC760;
		  /* 821BC760h */ case    9:  		/* li R11, 0 */
		/* 821BC760h case    9:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BC760h case    9:*/		return 0x821BC764;
		  /* 821BC764h */ case   10:  		/* bc 4, CR6_EQ, 8 */
		/* 821BC764h case   10:*/		if ( !regs.CR[6].eq ) { return 0x821BC76C;  }
		/* 821BC764h case   10:*/		return 0x821BC768;
	}
	return 0x821BC768;
} // Block from 821BC73Ch-821BC768h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821BC768h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC768( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC768) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC768);
		  /* 821BC768h */ case    0:  		/* li R11, 1 */
		/* 821BC768h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821BC768h case    0:*/		return 0x821BC76C;
	}
	return 0x821BC76C;
} // Block from 821BC768h-821BC76Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BC76Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC76C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC76C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC76C);
		  /* 821BC76Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821BC76Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821BC76Ch case    0:*/		return 0x821BC770;
		  /* 821BC770h */ case    1:  		/* bc 12, CR0_EQ, 28 */
		/* 821BC770h case    1:*/		if ( regs.CR[0].eq ) { return 0x821BC78C;  }
		/* 821BC770h case    1:*/		return 0x821BC774;
		  /* 821BC774h */ case    2:  		/* lwz R11, <#[R31]> */
		/* 821BC774h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821BC774h case    2:*/		return 0x821BC778;
		  /* 821BC778h */ case    3:  		/* lwz R10, <#[R10]> */
		/* 821BC778h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821BC778h case    3:*/		return 0x821BC77C;
		  /* 821BC77Ch */ case    4:  		/* xor R11, R11, R10 */
		/* 821BC77Ch case    4:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821BC77Ch case    4:*/		return 0x821BC780;
		  /* 821BC780h */ case    5:  		/* rlwinm. R11, R11, 0, 27, 28 */
		/* 821BC780h case    5:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R11,regs.R11);
		/* 821BC780h case    5:*/		return 0x821BC784;
		  /* 821BC784h */ case    6:  		/* bc 12, CR0_EQ, 8 */
		/* 821BC784h case    6:*/		if ( regs.CR[0].eq ) { return 0x821BC78C;  }
		/* 821BC784h case    6:*/		return 0x821BC788;
		  /* 821BC788h */ case    7:  		/* li R8, 1 */
		/* 821BC788h case    7:*/		cpu::op::li<0>(regs,&regs.R8,0x1);
		/* 821BC788h case    7:*/		return 0x821BC78C;
	}
	return 0x821BC78C;
} // Block from 821BC76Ch-821BC78Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 821BC78Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC78C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC78C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC78C);
		  /* 821BC78Ch */ case    0:  		/* rlwinm. R11, R8, 0, 24, 31 */
		/* 821BC78Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R8);
		/* 821BC78Ch case    0:*/		return 0x821BC790;
		  /* 821BC790h */ case    1:  		/* bc 12, CR0_EQ, 32 */
		/* 821BC790h case    1:*/		if ( regs.CR[0].eq ) { return 0x821BC7B0;  }
		/* 821BC790h case    1:*/		return 0x821BC794;
		  /* 821BC794h */ case    2:  		/* rlwinm R5, R30, 0, 0, 29 */
		/* 821BC794h case    2:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R5,regs.R30);
		/* 821BC794h case    2:*/		return 0x821BC798;
		  /* 821BC798h */ case    3:  		/* mr R6, R31 */
		/* 821BC798h case    3:*/		regs.R6 = regs.R31;
		/* 821BC798h case    3:*/		return 0x821BC79C;
		  /* 821BC79Ch */ case    4:  		/* mr R4, R23 */
		/* 821BC79Ch case    4:*/		regs.R4 = regs.R23;
		/* 821BC79Ch case    4:*/		return 0x821BC7A0;
		  /* 821BC7A0h */ case    5:  		/* mr R3, R21 */
		/* 821BC7A0h case    5:*/		regs.R3 = regs.R21;
		/* 821BC7A0h case    5:*/		return 0x821BC7A4;
		  /* 821BC7A4h */ case    6:  		/* bl 447700 */
		/* 821BC7A4h case    6:*/		regs.LR = 0x821BC7A8; return 0x82229C78;
		/* 821BC7A4h case    6:*/		return 0x821BC7A8;
		  /* 821BC7A8h */ case    7:  		/* lwz R3, <#[R31 + 12]> */
		/* 821BC7A8h case    7:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000000C) );
		/* 821BC7A8h case    7:*/		return 0x821BC7AC;
		  /* 821BC7ACh */ case    8:  		/* b 8 */
		/* 821BC7ACh case    8:*/		return 0x821BC7B4;
		/* 821BC7ACh case    8:*/		return 0x821BC7B0;
	}
	return 0x821BC7B0;
} // Block from 821BC78Ch-821BC7B0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821BC7B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC7B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC7B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC7B0);
		  /* 821BC7B0h */ case    0:  		/* mr R3, R29 */
		/* 821BC7B0h case    0:*/		regs.R3 = regs.R29;
		/* 821BC7B0h case    0:*/		return 0x821BC7B4;
	}
	return 0x821BC7B4;
} // Block from 821BC7B0h-821BC7B4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BC7B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC7B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC7B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC7B4);
		  /* 821BC7B4h */ case    0:  		/* mr R4, R27 */
		/* 821BC7B4h case    0:*/		regs.R4 = regs.R27;
		/* 821BC7B4h case    0:*/		return 0x821BC7B8;
		  /* 821BC7B8h */ case    1:  		/* bl -280048 */
		/* 821BC7B8h case    1:*/		regs.LR = 0x821BC7BC; return 0x821781C8;
		/* 821BC7B8h case    1:*/		return 0x821BC7BC;
	}
	return 0x821BC7BC;
} // Block from 821BC7B4h-821BC7BCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BC7BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC7BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC7BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC7BC);
		  /* 821BC7BCh */ case    0:  		/* lwz R11, <#[R25]> */
		/* 821BC7BCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 821BC7BCh case    0:*/		return 0x821BC7C0;
		  /* 821BC7C0h */ case    1:  		/* cmplw CR6, R11, R31 */
		/* 821BC7C0h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 821BC7C0h case    1:*/		return 0x821BC7C4;
		  /* 821BC7C4h */ case    2:  		/* bc 4, CR6_EQ, -496 */
		/* 821BC7C4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821BC5D4;  }
		/* 821BC7C4h case    2:*/		return 0x821BC7C8;
		  /* 821BC7C8h */ case    3:  		/* addi R25, R31, 8 */
		/* 821BC7C8h case    3:*/		cpu::op::addi<0>(regs,&regs.R25,regs.R31,0x8);
		/* 821BC7C8h case    3:*/		return 0x821BC7CC;
		  /* 821BC7CCh */ case    4:  		/* b -504 */
		/* 821BC7CCh case    4:*/		return 0x821BC5D4;
		/* 821BC7CCh case    4:*/		return 0x821BC7D0;
	}
	return 0x821BC7D0;
} // Block from 821BC7BCh-821BC7D0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BC7D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC7D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC7D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC7D0);
		  /* 821BC7D0h */ case    0:  		/* li R6, 1 */
		/* 821BC7D0h case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821BC7D0h case    0:*/		return 0x821BC7D4;
		  /* 821BC7D4h */ case    1:  		/* li R5, 0 */
		/* 821BC7D4h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821BC7D4h case    1:*/		return 0x821BC7D8;
		  /* 821BC7D8h */ case    2:  		/* mr R4, R30 */
		/* 821BC7D8h case    2:*/		regs.R4 = regs.R30;
		/* 821BC7D8h case    2:*/		return 0x821BC7DC;
		  /* 821BC7DCh */ case    3:  		/* mr R3, R21 */
		/* 821BC7DCh case    3:*/		regs.R3 = regs.R21;
		/* 821BC7DCh case    3:*/		return 0x821BC7E0;
		  /* 821BC7E0h */ case    4:  		/* bl 453608 */
		/* 821BC7E0h case    4:*/		regs.LR = 0x821BC7E4; return 0x8222B3C8;
		/* 821BC7E0h case    4:*/		return 0x821BC7E4;
	}
	return 0x821BC7E4;
} // Block from 821BC7D0h-821BC7E4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BC7E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC7E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC7E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC7E4);
		  /* 821BC7E4h */ case    0:  		/* cmplwi CR6, R24, 0 */
		/* 821BC7E4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R24,0x00000000);
		/* 821BC7E4h case    0:*/		return 0x821BC7E8;
		  /* 821BC7E8h */ case    1:  		/* bc 12, CR6_EQ, 60 */
		/* 821BC7E8h case    1:*/		if ( regs.CR[6].eq ) { return 0x821BC824;  }
		/* 821BC7E8h case    1:*/		return 0x821BC7EC;
		  /* 821BC7ECh */ case    2:  		/* rlwinm R11, R24, 0, 0, 30 */
		/* 821BC7ECh case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R24);
		/* 821BC7ECh case    2:*/		return 0x821BC7F0;
		  /* 821BC7F0h */ case    3:  		/* lwz R11, <#[R11 + 40]> */
		/* 821BC7F0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 821BC7F0h case    3:*/		return 0x821BC7F4;
		  /* 821BC7F4h */ case    4:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 821BC7F4h case    4:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BC7F4h case    4:*/		return 0x821BC7F8;
		  /* 821BC7F8h */ case    5:  		/* addic R10, R10, -1 */
		/* 821BC7F8h case    5:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 821BC7F8h case    5:*/		return 0x821BC7FC;
		  /* 821BC7FCh */ case    6:  		/* subfe R10, R10, R10 */
		/* 821BC7FCh case    6:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 821BC7FCh case    6:*/		return 0x821BC800;
		  /* 821BC800h */ case    7:  		/* and R10, R10, R11 */
		/* 821BC800h case    7:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 821BC800h case    7:*/		return 0x821BC804;
		  /* 821BC804h */ case    8:  		/* cmplw CR6, R30, R10 */
		/* 821BC804h case    8:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R10);
		/* 821BC804h case    8:*/		return 0x821BC808;
		  /* 821BC808h */ case    9:  		/* bc 4, CR6_EQ, 16 */
		/* 821BC808h case    9:*/		if ( !regs.CR[6].eq ) { return 0x821BC818;  }
		/* 821BC808h case    9:*/		return 0x821BC80C;
		  /* 821BC80Ch */ case   10:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 821BC80Ch case   10:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 821BC80Ch case   10:*/		return 0x821BC810;
		  /* 821BC810h */ case   11:  		/* mr R24, R30 */
		/* 821BC810h case   11:*/		regs.R24 = regs.R30;
		/* 821BC810h case   11:*/		return 0x821BC814;
		  /* 821BC814h */ case   12:  		/* lwz R11, <#[R11 + 40]> */
		/* 821BC814h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 821BC814h case   12:*/		return 0x821BC818;
	}
	return 0x821BC818;
} // Block from 821BC7E4h-821BC818h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821BC818h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC818( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC818) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC818);
		  /* 821BC818h */ case    0:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BC818h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BC818h case    0:*/		return 0x821BC81C;
		  /* 821BC81Ch */ case    1:  		/* bc 4, CR0_EQ, 56 */
		/* 821BC81Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x821BC854;  }
		/* 821BC81Ch case    1:*/		return 0x821BC820;
		  /* 821BC820h */ case    2:  		/* b 40 */
		/* 821BC820h case    2:*/		return 0x821BC848;
		/* 821BC820h case    2:*/		return 0x821BC824;
	}
	return 0x821BC824;
} // Block from 821BC818h-821BC824h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BC824h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC824( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC824) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC824);
		  /* 821BC824h */ case    0:  		/* lwz R11, <#[R22 + 4]> */
		/* 821BC824h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R22 + 0x00000004) );
		/* 821BC824h case    0:*/		return 0x821BC828;
		  /* 821BC828h */ case    1:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 821BC828h case    1:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BC828h case    1:*/		return 0x821BC82C;
		  /* 821BC82Ch */ case    2:  		/* addic R9, R10, -1 */
		/* 821BC82Ch case    2:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R10,0xFFFFFFFF);
		/* 821BC82Ch case    2:*/		return 0x821BC830;
		  /* 821BC830h */ case    3:  		/* subfe R9, R9, R9 */
		/* 821BC830h case    3:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 821BC830h case    3:*/		return 0x821BC834;
		  /* 821BC834h */ case    4:  		/* and R9, R9, R11 */
		/* 821BC834h case    4:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 821BC834h case    4:*/		return 0x821BC838;
		  /* 821BC838h */ case    5:  		/* cmplw CR6, R30, R9 */
		/* 821BC838h case    5:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R9);
		/* 821BC838h case    5:*/		return 0x821BC83C;
		  /* 821BC83Ch */ case    6:  		/* bc 12, CR6_EQ, -48 */
		/* 821BC83Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x821BC80C;  }
		/* 821BC83Ch case    6:*/		return 0x821BC840;
		  /* 821BC840h */ case    7:  		/* cmplwi CR6, R10, 0 */
		/* 821BC840h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821BC840h case    7:*/		return 0x821BC844;
		  /* 821BC844h */ case    8:  		/* bc 4, CR6_EQ, 16 */
		/* 821BC844h case    8:*/		if ( !regs.CR[6].eq ) { return 0x821BC854;  }
		/* 821BC844h case    8:*/		return 0x821BC848;
	}
	return 0x821BC848;
} // Block from 821BC824h-821BC848h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821BC848h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC848( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC848) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC848);
		  /* 821BC848h */ case    0:  		/* mr R30, R11 */
		/* 821BC848h case    0:*/		regs.R30 = regs.R11;
		/* 821BC848h case    0:*/		return 0x821BC84C;
		  /* 821BC84Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 821BC84Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BC84Ch case    1:*/		return 0x821BC850;
		  /* 821BC850h */ case    2:  		/* bc 4, CR6_EQ, -672 */
		/* 821BC850h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821BC5B0;  }
		/* 821BC850h case    2:*/		return 0x821BC854;
	}
	return 0x821BC854;
} // Block from 821BC848h-821BC854h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BC854h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC854( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC854) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC854);
		  /* 821BC854h */ case    0:  		/* rlwinm R11, R23, 0, 0, 30 */
		/* 821BC854h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R23);
		/* 821BC854h case    0:*/		return 0x821BC858;
		  /* 821BC858h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 821BC858h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821BC858h case    1:*/		return 0x821BC85C;
		  /* 821BC85Ch */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BC85Ch case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BC85Ch case    2:*/		return 0x821BC860;
		  /* 821BC860h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 821BC860h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BC870;  }
		/* 821BC860h case    3:*/		return 0x821BC864;
		  /* 821BC864h */ case    4:  		/* mr R23, R11 */
		/* 821BC864h case    4:*/		regs.R23 = regs.R11;
		/* 821BC864h case    4:*/		return 0x821BC868;
		  /* 821BC868h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821BC868h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BC868h case    5:*/		return 0x821BC86C;
		  /* 821BC86Ch */ case    6:  		/* bc 4, CR6_EQ, -732 */
		/* 821BC86Ch case    6:*/		if ( !regs.CR[6].eq ) { return 0x821BC590;  }
		/* 821BC86Ch case    6:*/		return 0x821BC870;
	}
	return 0x821BC870;
} // Block from 821BC854h-821BC870h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BC870h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC870( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC870) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC870);
		  /* 821BC870h */ case    0:  		/* lwz R31, <#[R21 + 100]> */
		/* 821BC870h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R21 + 0x00000064) );
		/* 821BC870h case    0:*/		return 0x821BC874;
		  /* 821BC874h */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 821BC874h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821BC874h case    1:*/		return 0x821BC878;
		  /* 821BC878h */ case    2:  		/* bc 12, CR6_EQ, 216 */
		/* 821BC878h case    2:*/		if ( regs.CR[6].eq ) { return 0x821BC950;  }
		/* 821BC878h case    2:*/		return 0x821BC87C;
		  /* 821BC87Ch */ case    3:  		/* li R6, 1 */
		/* 821BC87Ch case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821BC87Ch case    3:*/		return 0x821BC880;
		  /* 821BC880h */ case    4:  		/* li R5, 0 */
		/* 821BC880h case    4:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821BC880h case    4:*/		return 0x821BC884;
		  /* 821BC884h */ case    5:  		/* li R4, 112 */
		/* 821BC884h case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x70);
		/* 821BC884h case    5:*/		return 0x821BC888;
		  /* 821BC888h */ case    6:  		/* mr R3, R21 */
		/* 821BC888h case    6:*/		regs.R3 = regs.R21;
		/* 821BC888h case    6:*/		return 0x821BC88C;
		  /* 821BC88Ch */ case    7:  		/* bl -361564 */
		/* 821BC88Ch case    7:*/		regs.LR = 0x821BC890; return 0x82164430;
		/* 821BC88Ch case    7:*/		return 0x821BC890;
		  /* 821BC890h */ case    8:  		/* addi R28, R3, -8 */
		/* 821BC890h case    8:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R3,0xFFFFFFF8);
		/* 821BC890h case    8:*/		return 0x821BC894;
		  /* 821BC894h */ case    9:  		/* lwz R11, <#[R31 + 8]> */
		/* 821BC894h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821BC894h case    9:*/		return 0x821BC898;
		  /* 821BC898h */ case   10:  		/* add R29, R31, R28 */
		/* 821BC898h case   10:*/		cpu::op::add<0>(regs,&regs.R29,regs.R31,regs.R28);
		/* 821BC898h case   10:*/		return 0x821BC89C;
		  /* 821BC89Ch */ case   11:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821BC89Ch case   11:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821BC89Ch case   11:*/		return 0x821BC8A0;
		  /* 821BC8A0h */ case   12:  		/* cmplwi CR6, R11, 14720 */
		/* 821BC8A0h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003980);
		/* 821BC8A0h case   12:*/		return 0x821BC8A4;
		  /* 821BC8A4h */ case   13:  		/* bc 12, CR6_EQ, 160 */
		/* 821BC8A4h case   13:*/		if ( regs.CR[6].eq ) { return 0x821BC944;  }
		/* 821BC8A4h case   13:*/		return 0x821BC8A8;
		  /* 821BC8A8h */ case   14:  		/* lwz R11, <#[R31 + 16]> */
		/* 821BC8A8h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 821BC8A8h case   14:*/		return 0x821BC8AC;
		  /* 821BC8ACh */ case   15:  		/* li R10, 1 */
		/* 821BC8ACh case   15:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 821BC8ACh case   15:*/		return 0x821BC8B0;
		  /* 821BC8B0h */ case   16:  		/* rlwimi R11, R10, 16, 13, 15 */
		/* 821BC8B0h case   16:*/		cpu::op::rlwimi<0,16,13,15>(regs,&regs.R11,regs.R10);
		/* 821BC8B0h case   16:*/		return 0x821BC8B4;
		  /* 821BC8B4h */ case   17:  		/* stw R11, <#[R31 + 16]> */
		/* 821BC8B4h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 821BC8B4h case   17:*/		return 0x821BC8B8;
		  /* 821BC8B8h */ case   18:  		/* lhz R11, <#[R31 + 16]> */
		/* 821BC8B8h case   18:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 821BC8B8h case   18:*/		return 0x821BC8BC;
		  /* 821BC8BCh */ case   19:  		/* rlwinm R10, R11, 0, 29, 31 */
		/* 821BC8BCh case   19:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R10,regs.R11);
		/* 821BC8BCh case   19:*/		return 0x821BC8C0;
		  /* 821BC8C0h */ case   20:  		/* lwz R11, <#[R21 + 116]> */
		/* 821BC8C0h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000074) );
		/* 821BC8C0h case   20:*/		return 0x821BC8C4;
		  /* 821BC8C4h */ case   21:  		/* addi R11, R11, 1 */
		/* 821BC8C4h case   21:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821BC8C4h case   21:*/		return 0x821BC8C8;
		  /* 821BC8C8h */ case   22:  		/* sth R11, <#[R31 + 18]> */
		/* 821BC8C8h case   22:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R31 + 0x00000012) );
		/* 821BC8C8h case   22:*/		return 0x821BC8CC;
		  /* 821BC8CCh */ case   23:  		/* lwz R11, <#[R21 + 116]> */
		/* 821BC8CCh case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R21 + 0x00000074) );
		/* 821BC8CCh case   23:*/		return 0x821BC8D0;
		  /* 821BC8D0h */ case   24:  		/* add R11, R10, R11 */
		/* 821BC8D0h case   24:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821BC8D0h case   24:*/		return 0x821BC8D4;
		  /* 821BC8D4h */ case   25:  		/* stw R11, <#[R21 + 116]> */
		/* 821BC8D4h case   25:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R21 + 0x00000074) );
		/* 821BC8D4h case   25:*/		return 0x821BC8D8;
		  /* 821BC8D8h */ case   26:  		/* lwz R30, <#[R31]> */
		/* 821BC8D8h case   26:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000000) );
		/* 821BC8D8h case   26:*/		return 0x821BC8DC;
		  /* 821BC8DCh */ case   27:  		/* cmplwi CR6, R30, 0 */
		/* 821BC8DCh case   27:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821BC8DCh case   27:*/		return 0x821BC8E0;
		  /* 821BC8E0h */ case   28:  		/* bc 12, CR6_EQ, 36 */
		/* 821BC8E0h case   28:*/		if ( regs.CR[6].eq ) { return 0x821BC904;  }
		/* 821BC8E0h case   28:*/		return 0x821BC8E4;
		  /* 821BC8E4h */ case   29:  		/* lwz R4, <#[R30 + 12]> */
		/* 821BC8E4h case   29:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x0000000C) );
		/* 821BC8E4h case   29:*/		return 0x821BC8E8;
		  /* 821BC8E8h */ case   30:  		/* lwz R11, <#[R4 + 8]> */
		/* 821BC8E8h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821BC8E8h case   30:*/		return 0x821BC8EC;
		  /* 821BC8ECh */ case   31:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 821BC8ECh case   31:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 821BC8ECh case   31:*/		return 0x821BC8F0;
		  /* 821BC8F0h */ case   32:  		/* bc 4, CR0_EQ, 12 */
		/* 821BC8F0h case   32:*/		if ( !regs.CR[0].eq ) { return 0x821BC8FC;  }
		/* 821BC8F0h case   32:*/		return 0x821BC8F4;
		  /* 821BC8F4h */ case   33:  		/* mr R3, R21 */
		/* 821BC8F4h case   33:*/		regs.R3 = regs.R21;
		/* 821BC8F4h case   33:*/		return 0x821BC8F8;
		  /* 821BC8F8h */ case   34:  		/* bl -24240 */
		/* 821BC8F8h case   34:*/		regs.LR = 0x821BC8FC; return 0x821B6A48;
		/* 821BC8F8h case   34:*/		return 0x821BC8FC;
	}
	return 0x821BC8FC;
} // Block from 821BC870h-821BC8FCh (35 instructions)

//////////////////////////////////////////////////////
// Block at 821BC8FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC8FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC8FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC8FC);
		  /* 821BC8FCh */ case    0:  		/* lwz R30, <#[R30 + 4]> */
		/* 821BC8FCh case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000004) );
		/* 821BC8FCh case    0:*/		return 0x821BC900;
		  /* 821BC900h */ case    1:  		/* b -36 */
		/* 821BC900h case    1:*/		return 0x821BC8DC;
		/* 821BC900h case    1:*/		return 0x821BC904;
	}
	return 0x821BC904;
} // Block from 821BC8FCh-821BC904h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BC904h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC904( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC904) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC904);
		  /* 821BC904h */ case    0:  		/* lwz R31, <#[R31 + 4]> */
		/* 821BC904h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000004) );
		/* 821BC904h case    0:*/		return 0x821BC908;
		  /* 821BC908h */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 821BC908h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821BC908h case    1:*/		return 0x821BC90C;
		  /* 821BC90Ch */ case    2:  		/* bc 12, CR6_EQ, 56 */
		/* 821BC90Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x821BC944;  }
		/* 821BC90Ch case    2:*/		return 0x821BC910;
		  /* 821BC910h */ case    3:  		/* lwz R4, <#[R31 + 16]> */
		/* 821BC910h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000010) );
		/* 821BC910h case    3:*/		return 0x821BC914;
		  /* 821BC914h */ case    4:  		/* cmplwi CR6, R4, 0 */
		/* 821BC914h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 821BC914h case    4:*/		return 0x821BC918;
		  /* 821BC918h */ case    5:  		/* bc 12, CR6_EQ, 36 */
		/* 821BC918h case    5:*/		if ( regs.CR[6].eq ) { return 0x821BC93C;  }
		/* 821BC918h case    5:*/		return 0x821BC91C;
		  /* 821BC91Ch */ case    6:  		/* lwz R11, <#[R4 + 8]> */
		/* 821BC91Ch case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821BC91Ch case    6:*/		return 0x821BC920;
		  /* 821BC920h */ case    7:  		/* rlwinm R10, R11, 0, 18, 24 */
		/* 821BC920h case    7:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R11);
		/* 821BC920h case    7:*/		return 0x821BC924;
		  /* 821BC924h */ case    8:  		/* cmplwi CR6, R10, 14080 */
		/* 821BC924h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003700);
		/* 821BC924h case    8:*/		return 0x821BC928;
		  /* 821BC928h */ case    9:  		/* bc 4, CR6_EQ, 20 */
		/* 821BC928h case    9:*/		if ( !regs.CR[6].eq ) { return 0x821BC93C;  }
		/* 821BC928h case    9:*/		return 0x821BC92C;
		  /* 821BC92Ch */ case   10:  		/* rlwinm. R11, R11, 9, 31, 31 */
		/* 821BC92Ch case   10:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R11,regs.R11);
		/* 821BC92Ch case   10:*/		return 0x821BC930;
		  /* 821BC930h */ case   11:  		/* bc 4, CR0_EQ, 12 */
		/* 821BC930h case   11:*/		if ( !regs.CR[0].eq ) { return 0x821BC93C;  }
		/* 821BC930h case   11:*/		return 0x821BC934;
		  /* 821BC934h */ case   12:  		/* mr R3, R21 */
		/* 821BC934h case   12:*/		regs.R3 = regs.R21;
		/* 821BC934h case   12:*/		return 0x821BC938;
		  /* 821BC938h */ case   13:  		/* bl -24304 */
		/* 821BC938h case   13:*/		regs.LR = 0x821BC93C; return 0x821B6A48;
		/* 821BC938h case   13:*/		return 0x821BC93C;
	}
	return 0x821BC93C;
} // Block from 821BC904h-821BC93Ch (14 instructions)

//////////////////////////////////////////////////////
// Block at 821BC93Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC93C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC93C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC93C);
		  /* 821BC93Ch */ case    0:  		/* lwz R31, <#[R31 + 8]> */
		/* 821BC93Ch case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000008) );
		/* 821BC93Ch case    0:*/		return 0x821BC940;
		  /* 821BC940h */ case    1:  		/* b -56 */
		/* 821BC940h case    1:*/		return 0x821BC908;
		/* 821BC940h case    1:*/		return 0x821BC944;
	}
	return 0x821BC944;
} // Block from 821BC93Ch-821BC944h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BC944h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC944( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC944) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC944);
		  /* 821BC944h */ case    0:  		/* lwz R31, <#[R29 + 4]> */
		/* 821BC944h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R29 + 0x00000004) );
		/* 821BC944h case    0:*/		return 0x821BC948;
		  /* 821BC948h */ case    1:  		/* cmplwi CR6, R31, 0 */
		/* 821BC948h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821BC948h case    1:*/		return 0x821BC94C;
		  /* 821BC94Ch */ case    2:  		/* bc 4, CR6_EQ, -184 */
		/* 821BC94Ch case    2:*/		if ( !regs.CR[6].eq ) { return 0x821BC894;  }
		/* 821BC94Ch case    2:*/		return 0x821BC950;
	}
	return 0x821BC950;
} // Block from 821BC944h-821BC950h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BC950h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC950( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC950) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC950);
		  /* 821BC950h */ case    0:  		/* addi R1, R1, 192 */
		/* 821BC950h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 821BC950h case    0:*/		return 0x821BC954;
		  /* 821BC954h */ case    1:  		/* b -1226440 */
		/* 821BC954h case    1:*/		return 0x8209128C;
		/* 821BC954h case    1:*/		return 0x821BC958;
	}
	return 0x821BC958;
} // Block from 821BC950h-821BC958h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BC958h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BC958( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BC958) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BC958);
		  /* 821BC958h */ case    0:  		/* mfspr R12, LR */
		/* 821BC958h case    0:*/		regs.R12 = regs.LR;
		/* 821BC958h case    0:*/		return 0x821BC95C;
		  /* 821BC95Ch */ case    1:  		/* bl -1226512 */
		/* 821BC95Ch case    1:*/		regs.LR = 0x821BC960; return 0x8209124C;
		/* 821BC95Ch case    1:*/		return 0x821BC960;
		  /* 821BC960h */ case    2:  		/* stwu R1, <#[R1 - 208]> */
		/* 821BC960h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF30) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF30);
		/* 821BC960h case    2:*/		return 0x821BC964;
		  /* 821BC964h */ case    3:  		/* lwz R10, <#[R4 + 8]> */
		/* 821BC964h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000008) );
		/* 821BC964h case    3:*/		return 0x821BC968;
		  /* 821BC968h */ case    4:  		/* mr R26, R3 */
		/* 821BC968h case    4:*/		regs.R26 = regs.R3;
		/* 821BC968h case    4:*/		return 0x821BC96C;
		  /* 821BC96Ch */ case    5:  		/* mr R28, R4 */
		/* 821BC96Ch case    5:*/		regs.R28 = regs.R4;
		/* 821BC96Ch case    5:*/		return 0x821BC970;
		  /* 821BC970h */ case    6:  		/* rlwinm R11, R10, 25, 25, 31 */
		/* 821BC970h case    6:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R10);
		/* 821BC970h case    6:*/		return 0x821BC974;
		  /* 821BC974h */ case    7:  		/* mr R25, R5 */
		/* 821BC974h case    7:*/		regs.R25 = regs.R5;
		/* 821BC974h case    7:*/		return 0x821BC978;
		  /* 821BC978h */ case    8:  		/* cmpwi CR6, R11, 110 */
		/* 821BC978h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000006E);
		/* 821BC978h case    8:*/		return 0x821BC97C;
		  /* 821BC97Ch */ case    9:  		/* bc 12, CR6_EQ, 192 */
		/* 821BC97Ch case    9:*/		if ( regs.CR[6].eq ) { return 0x821BCA3C;  }
		/* 821BC97Ch case    9:*/		return 0x821BC980;
		  /* 821BC980h */ case   10:  		/* cmpwi CR6, R11, 113 */
		/* 821BC980h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000071);
		/* 821BC980h case   10:*/		return 0x821BC984;
		  /* 821BC984h */ case   11:  		/* bc 12, CR6_EQ, 164 */
		/* 821BC984h case   11:*/		if ( regs.CR[6].eq ) { return 0x821BCA28;  }
		/* 821BC984h case   11:*/		return 0x821BC988;
		  /* 821BC988h */ case   12:  		/* cmpwi CR6, R11, 124 */
		/* 821BC988h case   12:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000007C);
		/* 821BC988h case   12:*/		return 0x821BC98C;
		  /* 821BC98Ch */ case   13:  		/* bc 12, CR6_EQ, 156 */
		/* 821BC98Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x821BCA28;  }
		/* 821BC98Ch case   13:*/		return 0x821BC990;
		  /* 821BC990h */ case   14:  		/* cmpwi CR6, R11, 125 */
		/* 821BC990h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000007D);
		/* 821BC990h case   14:*/		return 0x821BC994;
		  /* 821BC994h */ case   15:  		/* mr R3, R4 */
		/* 821BC994h case   15:*/		regs.R3 = regs.R4;
		/* 821BC994h case   15:*/		return 0x821BC998;
		  /* 821BC998h */ case   16:  		/* bc 12, CR6_EQ, 156 */
		/* 821BC998h case   16:*/		if ( regs.CR[6].eq ) { return 0x821BCA34;  }
		/* 821BC998h case   16:*/		return 0x821BC99C;
		  /* 821BC99Ch */ case   17:  		/* rlwinm R31, R10, 31, 28, 31 */
		/* 821BC99Ch case   17:*/		cpu::op::rlwinm<0,31,28,31>(regs,&regs.R31,regs.R10);
		/* 821BC99Ch case   17:*/		return 0x821BC9A0;
		  /* 821BC9A0h */ case   18:  		/* bl -280104 */
		/* 821BC9A0h case   18:*/		regs.LR = 0x821BC9A4; return 0x82178378;
		/* 821BC9A0h case   18:*/		return 0x821BC9A4;
		  /* 821BC9A4h */ case   19:  		/* lwz R11, <#[R28 + 8]> */
		/* 821BC9A4h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 821BC9A4h case   19:*/		return 0x821BC9A8;
		  /* 821BC9A8h */ case   20:  		/* rlwinm R10, R11, 31, 28, 31 */
		/* 821BC9A8h case   20:*/		cpu::op::rlwinm<0,31,28,31>(regs,&regs.R10,regs.R11);
		/* 821BC9A8h case   20:*/		return 0x821BC9AC;
		  /* 821BC9ACh */ case   21:  		/* cmplw CR6, R31, R10 */
		/* 821BC9ACh case   21:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R10);
		/* 821BC9ACh case   21:*/		return 0x821BC9B0;
		  /* 821BC9B0h */ case   22:  		/* bc 12, CR6_EQ, 120 */
		/* 821BC9B0h case   22:*/		if ( regs.CR[6].eq ) { return 0x821BCA28;  }
		/* 821BC9B0h case   22:*/		return 0x821BC9B4;
		  /* 821BC9B4h */ case   23:  		/* lwz R10, <#[R26 + 652]> */
		/* 821BC9B4h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x0000028C) );
		/* 821BC9B4h case   23:*/		return 0x821BC9B8;
		  /* 821BC9B8h */ case   24:  		/* cmplwi CR6, R10, 0 */
		/* 821BC9B8h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821BC9B8h case   24:*/		return 0x821BC9BC;
		  /* 821BC9BCh */ case   25:  		/* bc 12, CR6_EQ, 108 */
		/* 821BC9BCh case   25:*/		if ( regs.CR[6].eq ) { return 0x821BCA28;  }
		/* 821BC9BCh case   25:*/		return 0x821BC9C0;
		  /* 821BC9C0h */ case   26:  		/* rlwinm. R10, R11, 6, 31, 31 */
		/* 821BC9C0h case   26:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R10,regs.R11);
		/* 821BC9C0h case   26:*/		return 0x821BC9C4;
		  /* 821BC9C4h */ case   27:  		/* bc 4, CR0_EQ, 100 */
		/* 821BC9C4h case   27:*/		if ( !regs.CR[0].eq ) { return 0x821BCA28;  }
		/* 821BC9C4h case   27:*/		return 0x821BC9C8;
		  /* 821BC9C8h */ case   28:  		/* oris R11, R11, 1024 */
		/* 821BC9C8h case   28:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x400);
		/* 821BC9C8h case   28:*/		return 0x821BC9CC;
		  /* 821BC9CCh */ case   29:  		/* stw R11, <#[R28 + 8]> */
		/* 821BC9CCh case   29:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 821BC9CCh case   29:*/		return 0x821BC9D0;
		  /* 821BC9D0h */ case   30:  		/* lwz R3, <#[R26 + 652]> */
		/* 821BC9D0h case   30:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R26 + 0x0000028C) );
		/* 821BC9D0h case   30:*/		return 0x821BC9D4;
		  /* 821BC9D4h */ case   31:  		/* lwz R11, <#[R3 + 4]> */
		/* 821BC9D4h case   31:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821BC9D4h case   31:*/		return 0x821BC9D8;
		  /* 821BC9D8h */ case   32:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821BC9D8h case   32:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821BC9D8h case   32:*/		return 0x821BC9DC;
		  /* 821BC9DCh */ case   33:  		/* bc 4, CR0_EQ, 40 */
		/* 821BC9DCh case   33:*/		if ( !regs.CR[0].eq ) { return 0x821BCA04;  }
		/* 821BC9DCh case   33:*/		return 0x821BC9E0;
		  /* 821BC9E0h */ case   34:  		/* lwz R11, <#[R3]> */
		/* 821BC9E0h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821BC9E0h case   34:*/		return 0x821BC9E4;
		  /* 821BC9E4h */ case   35:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821BC9E4h case   35:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821BC9E4h case   35:*/		return 0x821BC9E8;
		  /* 821BC9E8h */ case   36:  		/* addic. R11, R11, -4 */
		/* 821BC9E8h case   36:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 821BC9E8h case   36:*/		return 0x821BC9EC;
		  /* 821BC9ECh */ case   37:  		/* bc 12, CR0_EQ, 24 */
		/* 821BC9ECh case   37:*/		if ( regs.CR[0].eq ) { return 0x821BCA04;  }
		/* 821BC9ECh case   37:*/		return 0x821BC9F0;
		  /* 821BC9F0h */ case   38:  		/* lwz R10, <#[R11 + 8]> */
		/* 821BC9F0h case   38:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821BC9F0h case   38:*/		return 0x821BC9F4;
		  /* 821BC9F4h */ case   39:  		/* lwz R9, <#[R11 + 12]> */
		/* 821BC9F4h case   39:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 821BC9F4h case   39:*/		return 0x821BC9F8;
		  /* 821BC9F8h */ case   40:  		/* addi R10, R10, 1 */
		/* 821BC9F8h case   40:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821BC9F8h case   40:*/		return 0x821BC9FC;
		  /* 821BC9FCh */ case   41:  		/* cmplw CR6, R10, R9 */
		/* 821BC9FCh case   41:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 821BC9FCh case   41:*/		return 0x821BCA00;
		  /* 821BCA00h */ case   42:  		/* bc 4, CR6_GT, 16 */
		/* 821BCA00h case   42:*/		if ( !regs.CR[6].gt ) { return 0x821BCA10;  }
		/* 821BCA00h case   42:*/		return 0x821BCA04;
	}
	return 0x821BCA04;
} // Block from 821BC958h-821BCA04h (43 instructions)

//////////////////////////////////////////////////////
// Block at 821BCA04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCA04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCA04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCA04);
		  /* 821BCA04h */ case    0:  		/* li R4, 1 */
		/* 821BCA04h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 821BCA04h case    0:*/		return 0x821BCA08;
		  /* 821BCA08h */ case    1:  		/* bl -194880 */
		/* 821BCA08h case    1:*/		regs.LR = 0x821BCA0C; return 0x8218D0C8;
		/* 821BCA08h case    1:*/		return 0x821BCA0C;
		  /* 821BCA0Ch */ case    2:  		/* mr R11, R3 */
		/* 821BCA0Ch case    2:*/		regs.R11 = regs.R3;
		/* 821BCA0Ch case    2:*/		return 0x821BCA10;
	}
	return 0x821BCA10;
} // Block from 821BCA04h-821BCA10h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BCA10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCA10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCA10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCA10);
		  /* 821BCA10h */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 821BCA10h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821BCA10h case    0:*/		return 0x821BCA14;
		  /* 821BCA14h */ case    1:  		/* addi R9, R10, 4 */
		/* 821BCA14h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 821BCA14h case    1:*/		return 0x821BCA18;
		  /* 821BCA18h */ case    2:  		/* addi R8, R10, 1 */
		/* 821BCA18h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x1);
		/* 821BCA18h case    2:*/		return 0x821BCA1C;
		  /* 821BCA1Ch */ case    3:  		/* rlwinm R10, R9, 2, 0, 29 */
		/* 821BCA1Ch case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R9);
		/* 821BCA1Ch case    3:*/		return 0x821BCA20;
		  /* 821BCA20h */ case    4:  		/* stw R8, <#[R11 + 8]> */
		/* 821BCA20h case    4:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000008) );
		/* 821BCA20h case    4:*/		return 0x821BCA24;
		  /* 821BCA24h */ case    5:  		/* stwx R28, <#[R10 + R11]> */
		/* 821BCA24h case    5:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821BCA24h case    5:*/		return 0x821BCA28;
	}
	return 0x821BCA28;
} // Block from 821BCA10h-821BCA28h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BCA28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCA28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCA28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCA28);
		  /* 821BCA28h */ case    0:  		/* mr R3, R28 */
		/* 821BCA28h case    0:*/		regs.R3 = regs.R28;
		/* 821BCA28h case    0:*/		return 0x821BCA2C;
		  /* 821BCA2Ch */ case    1:  		/* addi R1, R1, 208 */
		/* 821BCA2Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xD0);
		/* 821BCA2Ch case    1:*/		return 0x821BCA30;
		  /* 821BCA30h */ case    2:  		/* b -1226644 */
		/* 821BCA30h case    2:*/		return 0x8209129C;
		/* 821BCA30h case    2:*/		return 0x821BCA34;
	}
	return 0x821BCA34;
} // Block from 821BCA28h-821BCA34h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BCA34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCA34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCA34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCA34);
		  /* 821BCA34h */ case    0:  		/* bl -157316 */
		/* 821BCA34h case    0:*/		regs.LR = 0x821BCA38; return 0x821963B0;
		/* 821BCA34h case    0:*/		return 0x821BCA38;
		  /* 821BCA38h */ case    1:  		/* b -16 */
		/* 821BCA38h case    1:*/		return 0x821BCA28;
		/* 821BCA38h case    1:*/		return 0x821BCA3C;
	}
	return 0x821BCA3C;
} // Block from 821BCA34h-821BCA3Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BCA3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCA3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCA3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCA3C);
		  /* 821BCA3Ch */ case    0:  		/* mr R4, R28 */
		/* 821BCA3Ch case    0:*/		regs.R4 = regs.R28;
		/* 821BCA3Ch case    0:*/		return 0x821BCA40;
		  /* 821BCA40h */ case    1:  		/* mr R3, R26 */
		/* 821BCA40h case    1:*/		regs.R3 = regs.R26;
		/* 821BCA40h case    1:*/		return 0x821BCA44;
		  /* 821BCA44h */ case    2:  		/* bl -26204 */
		/* 821BCA44h case    2:*/		regs.LR = 0x821BCA48; return 0x821B63E8;
		/* 821BCA44h case    2:*/		return 0x821BCA48;
		  /* 821BCA48h */ case    3:  		/* lwz R11, <#[R28 + 8]> */
		/* 821BCA48h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 821BCA48h case    3:*/		return 0x821BCA4C;
		  /* 821BCA4Ch */ case    4:  		/* rlwinm R10, R11, 27, 15, 17 */
		/* 821BCA4Ch case    4:*/		cpu::op::rlwinm<0,27,15,17>(regs,&regs.R10,regs.R11);
		/* 821BCA4Ch case    4:*/		return 0x821BCA50;
		  /* 821BCA50h */ case    5:  		/* rlwinm R11, R11, 0, 15, 17 */
		/* 821BCA50h case    5:*/		cpu::op::rlwinm<0,0,15,17>(regs,&regs.R11,regs.R11);
		/* 821BCA50h case    5:*/		return 0x821BCA54;
		  /* 821BCA54h */ case    6:  		/* cmplw CR6, R11, R10 */
		/* 821BCA54h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821BCA54h case    6:*/		return 0x821BCA58;
		  /* 821BCA58h */ case    7:  		/* bc 4, CR6_GT, 400 */
		/* 821BCA58h case    7:*/		if ( !regs.CR[6].gt ) { return 0x821BCBE8;  }
		/* 821BCA58h case    7:*/		return 0x821BCA5C;
		  /* 821BCA5Ch */ case    8:  		/* mr R4, R28 */
		/* 821BCA5Ch case    8:*/		regs.R4 = regs.R28;
		/* 821BCA5Ch case    8:*/		return 0x821BCA60;
		  /* 821BCA60h */ case    9:  		/* mr R3, R26 */
		/* 821BCA60h case    9:*/		regs.R3 = regs.R26;
		/* 821BCA60h case    9:*/		return 0x821BCA64;
		  /* 821BCA64h */ case   10:  		/* bl -24380 */
		/* 821BCA64h case   10:*/		regs.LR = 0x821BCA68; return 0x821B6B28;
		/* 821BCA64h case   10:*/		return 0x821BCA68;
		  /* 821BCA68h */ case   11:  		/* mr R31, R3 */
		/* 821BCA68h case   11:*/		regs.R31 = regs.R3;
		/* 821BCA68h case   11:*/		return 0x821BCA6C;
		  /* 821BCA6Ch */ case   12:  		/* mr R4, R31 */
		/* 821BCA6Ch case   12:*/		regs.R4 = regs.R31;
		/* 821BCA6Ch case   12:*/		return 0x821BCA70;
		  /* 821BCA70h */ case   13:  		/* mr R3, R26 */
		/* 821BCA70h case   13:*/		regs.R3 = regs.R26;
		/* 821BCA70h case   13:*/		return 0x821BCA74;
		  /* 821BCA74h */ case   14:  		/* bl -26252 */
		/* 821BCA74h case   14:*/		regs.LR = 0x821BCA78; return 0x821B63E8;
		/* 821BCA74h case   14:*/		return 0x821BCA78;
		  /* 821BCA78h */ case   15:  		/* lwz R11, <#[R31 + 8]> */
		/* 821BCA78h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821BCA78h case   15:*/		return 0x821BCA7C;
		  /* 821BCA7Ch */ case   16:  		/* oris R11, R11, 256 */
		/* 821BCA7Ch case   16:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x100);
		/* 821BCA7Ch case   16:*/		return 0x821BCA80;
		  /* 821BCA80h */ case   17:  		/* stw R11, <#[R31 + 8]> */
		/* 821BCA80h case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821BCA80h case   17:*/		return 0x821BCA84;
		  /* 821BCA84h */ case   18:  		/* lwz R10, <#[R28 + 8]> */
		/* 821BCA84h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000008) );
		/* 821BCA84h case   18:*/		return 0x821BCA88;
		  /* 821BCA88h */ case   19:  		/* rlwinm. R10, R10, 9, 31, 31 */
		/* 821BCA88h case   19:*/		cpu::op::rlwinm<1,9,31,31>(regs,&regs.R10,regs.R10);
		/* 821BCA88h case   19:*/		return 0x821BCA8C;
		  /* 821BCA8Ch */ case   20:  		/* bc 12, CR0_EQ, 208 */
		/* 821BCA8Ch case   20:*/		if ( regs.CR[0].eq ) { return 0x821BCB5C;  }
		/* 821BCA8Ch case   20:*/		return 0x821BCA90;
		  /* 821BCA90h */ case   21:  		/* oris R11, R11, 128 */
		/* 821BCA90h case   21:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x80);
		/* 821BCA90h case   21:*/		return 0x821BCA94;
		  /* 821BCA94h */ case   22:  		/* lwz R10, <#[R31 + 16]> */
		/* 821BCA94h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 821BCA94h case   22:*/		return 0x821BCA98;
		  /* 821BCA98h */ case   23:  		/* mr R3, R28 */
		/* 821BCA98h case   23:*/		regs.R3 = regs.R28;
		/* 821BCA98h case   23:*/		return 0x821BCA9C;
		  /* 821BCA9Ch */ case   24:  		/* stw R11, <#[R31 + 8]> */
		/* 821BCA9Ch case   24:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821BCA9Ch case   24:*/		return 0x821BCAA0;
		  /* 821BCAA0h */ case   25:  		/* lhz R11, <#[R28 + 16]> */
		/* 821BCAA0h case   25:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000010) );
		/* 821BCAA0h case   25:*/		return 0x821BCAA4;
		  /* 821BCAA4h */ case   26:  		/* rlwimi R10, R11, 16, 13, 15 */
		/* 821BCAA4h case   26:*/		cpu::op::rlwimi<0,16,13,15>(regs,&regs.R10,regs.R11);
		/* 821BCAA4h case   26:*/		return 0x821BCAA8;
		  /* 821BCAA8h */ case   27:  		/* stw R10, <#[R31 + 16]> */
		/* 821BCAA8h case   27:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000010) );
		/* 821BCAA8h case   27:*/		return 0x821BCAAC;
		  /* 821BCAACh */ case   28:  		/* bl -233924 */
		/* 821BCAACh case   28:*/		regs.LR = 0x821BCAB0; return 0x821838E8;
		/* 821BCAACh case   28:*/		return 0x821BCAB0;
		  /* 821BCAB0h */ case   29:  		/* sth R3, <#[R31 + 18]> */
		/* 821BCAB0h case   29:*/		cpu::mem::store16( regs, regs.R3, (uint32)(regs.R31 + 0x00000012) );
		/* 821BCAB0h case   29:*/		return 0x821BCAB4;
		  /* 821BCAB4h */ case   30:  		/* lwz R11, <#[R25 + 4]> */
		/* 821BCAB4h case   30:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000004) );
		/* 821BCAB4h case   30:*/		return 0x821BCAB8;
		  /* 821BCAB8h */ case   31:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821BCAB8h case   31:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821BCAB8h case   31:*/		return 0x821BCABC;
		  /* 821BCABCh */ case   32:  		/* bc 4, CR0_EQ, 40 */
		/* 821BCABCh case   32:*/		if ( !regs.CR[0].eq ) { return 0x821BCAE4;  }
		/* 821BCABCh case   32:*/		return 0x821BCAC0;
		  /* 821BCAC0h */ case   33:  		/* lwz R11, <#[R25]> */
		/* 821BCAC0h case   33:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000000) );
		/* 821BCAC0h case   33:*/		return 0x821BCAC4;
		  /* 821BCAC4h */ case   34:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821BCAC4h case   34:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821BCAC4h case   34:*/		return 0x821BCAC8;
		  /* 821BCAC8h */ case   35:  		/* addic. R3, R11, -4 */
		/* 821BCAC8h case   35:*/		cpu::op::addic<1>(regs,&regs.R3,regs.R11,0xFFFFFFFC);
		/* 821BCAC8h case   35:*/		return 0x821BCACC;
		  /* 821BCACCh */ case   36:  		/* bc 12, CR0_EQ, 24 */
		/* 821BCACCh case   36:*/		if ( regs.CR[0].eq ) { return 0x821BCAE4;  }
		/* 821BCACCh case   36:*/		return 0x821BCAD0;
		  /* 821BCAD0h */ case   37:  		/* lwz R11, <#[R3 + 8]> */
		/* 821BCAD0h case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821BCAD0h case   37:*/		return 0x821BCAD4;
		  /* 821BCAD4h */ case   38:  		/* lwz R10, <#[R3 + 12]> */
		/* 821BCAD4h case   38:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 821BCAD4h case   38:*/		return 0x821BCAD8;
		  /* 821BCAD8h */ case   39:  		/* addi R11, R11, 1 */
		/* 821BCAD8h case   39:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821BCAD8h case   39:*/		return 0x821BCADC;
		  /* 821BCADCh */ case   40:  		/* cmplw CR6, R11, R10 */
		/* 821BCADCh case   40:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821BCADCh case   40:*/		return 0x821BCAE0;
		  /* 821BCAE0h */ case   41:  		/* bc 4, CR6_GT, 16 */
		/* 821BCAE0h case   41:*/		if ( !regs.CR[6].gt ) { return 0x821BCAF0;  }
		/* 821BCAE0h case   41:*/		return 0x821BCAE4;
	}
	return 0x821BCAE4;
} // Block from 821BCA3Ch-821BCAE4h (42 instructions)

//////////////////////////////////////////////////////
// Block at 821BCAE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCAE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCAE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCAE4);
		  /* 821BCAE4h */ case    0:  		/* li R4, 1 */
		/* 821BCAE4h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 821BCAE4h case    0:*/		return 0x821BCAE8;
		  /* 821BCAE8h */ case    1:  		/* mr R3, R25 */
		/* 821BCAE8h case    1:*/		regs.R3 = regs.R25;
		/* 821BCAE8h case    1:*/		return 0x821BCAEC;
		  /* 821BCAECh */ case    2:  		/* bl -195108 */
		/* 821BCAECh case    2:*/		regs.LR = 0x821BCAF0; return 0x8218D0C8;
		/* 821BCAECh case    2:*/		return 0x821BCAF0;
	}
	return 0x821BCAF0;
} // Block from 821BCAE4h-821BCAF0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BCAF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCAF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCAF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCAF0);
		  /* 821BCAF0h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 821BCAF0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821BCAF0h case    0:*/		return 0x821BCAF4;
		  /* 821BCAF4h */ case    1:  		/* addi R10, R11, 4 */
		/* 821BCAF4h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x4);
		/* 821BCAF4h case    1:*/		return 0x821BCAF8;
		  /* 821BCAF8h */ case    2:  		/* addi R9, R11, 1 */
		/* 821BCAF8h case    2:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R11,0x1);
		/* 821BCAF8h case    2:*/		return 0x821BCAFC;
		  /* 821BCAFCh */ case    3:  		/* rlwinm R11, R10, 2, 0, 29 */
		/* 821BCAFCh case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R10);
		/* 821BCAFCh case    3:*/		return 0x821BCB00;
		  /* 821BCB00h */ case    4:  		/* stw R9, <#[R3 + 8]> */
		/* 821BCB00h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000008) );
		/* 821BCB00h case    4:*/		return 0x821BCB04;
		  /* 821BCB04h */ case    5:  		/* stwx R31, <#[R11 + R3]> */
		/* 821BCB04h case    5:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + regs.R3 + 0x00000000) );
		/* 821BCB04h case    5:*/		return 0x821BCB08;
		  /* 821BCB08h */ case    6:  		/* lwz R11, <#[R26 + 708]> */
		/* 821BCB08h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x000002C4) );
		/* 821BCB08h case    6:*/		return 0x821BCB0C;
		  /* 821BCB0Ch */ case    7:  		/* cmplwi CR6, R11, 0 */
		/* 821BCB0Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BCB0Ch case    7:*/		return 0x821BCB10;
		  /* 821BCB10h */ case    8:  		/* bc 12, CR6_EQ, 76 */
		/* 821BCB10h case    8:*/		if ( regs.CR[6].eq ) { return 0x821BCB5C;  }
		/* 821BCB10h case    8:*/		return 0x821BCB14;
		  /* 821BCB14h */ case    9:  		/* lwz R10, <#[R28 + 16]> */
		/* 821BCB14h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000010) );
		/* 821BCB14h case    9:*/		return 0x821BCB18;
		  /* 821BCB18h */ case   10:  		/* rlwinm. R11, R10, 0, 13, 15 */
		/* 821BCB18h case   10:*/		cpu::op::rlwinm<1,0,13,15>(regs,&regs.R11,regs.R10);
		/* 821BCB18h case   10:*/		return 0x821BCB1C;
		  /* 821BCB1Ch */ case   11:  		/* bc 12, CR0_EQ, 64 */
		/* 821BCB1Ch case   11:*/		if ( regs.CR[0].eq ) { return 0x821BCB5C;  }
		/* 821BCB1Ch case   11:*/		return 0x821BCB20;
		  /* 821BCB20h */ case   12:  		/* lwz R9, <#[R26 + 708]> */
		/* 821BCB20h case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R26 + 0x000002C4) );
		/* 821BCB20h case   12:*/		return 0x821BCB24;
		  /* 821BCB24h */ case   13:  		/* rlwinm R11, R10, 2, 14, 29 */
		/* 821BCB24h case   13:*/		cpu::op::rlwinm<0,2,14,29>(regs,&regs.R11,regs.R10);
		/* 821BCB24h case   13:*/		return 0x821BCB28;
		  /* 821BCB28h */ case   14:  		/* rlwinm R10, R10, 0, 16, 31 */
		/* 821BCB28h case   14:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R10,regs.R10);
		/* 821BCB28h case   14:*/		return 0x821BCB2C;
		  /* 821BCB2Ch */ case   15:  		/* addi R8, R10, 2 */
		/* 821BCB2Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x2);
		/* 821BCB2Ch case   15:*/		return 0x821BCB30;
		  /* 821BCB30h */ case   16:  		/* addi R7, R10, 3 */
		/* 821BCB30h case   16:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R10,0x3);
		/* 821BCB30h case   16:*/		return 0x821BCB34;
		  /* 821BCB34h */ case   17:  		/* stwx R31, <#[R9 + R11]> */
		/* 821BCB34h case   17:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 821BCB34h case   17:*/		return 0x821BCB38;
		  /* 821BCB38h */ case   18:  		/* rlwinm R9, R8, 2, 0, 29 */
		/* 821BCB38h case   18:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R8);
		/* 821BCB38h case   18:*/		return 0x821BCB3C;
		  /* 821BCB3Ch */ case   19:  		/* lwz R10, <#[R26 + 708]> */
		/* 821BCB3Ch case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x000002C4) );
		/* 821BCB3Ch case   19:*/		return 0x821BCB40;
		  /* 821BCB40h */ case   20:  		/* add R11, R10, R11 */
		/* 821BCB40h case   20:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821BCB40h case   20:*/		return 0x821BCB44;
		  /* 821BCB44h */ case   21:  		/* stw R31, <#[R11 + 4]> */
		/* 821BCB44h case   21:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + 0x00000004) );
		/* 821BCB44h case   21:*/		return 0x821BCB48;
		  /* 821BCB48h */ case   22:  		/* rlwinm R11, R7, 2, 0, 29 */
		/* 821BCB48h case   22:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R7);
		/* 821BCB48h case   22:*/		return 0x821BCB4C;
		  /* 821BCB4Ch */ case   23:  		/* lwz R10, <#[R26 + 708]> */
		/* 821BCB4Ch case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x000002C4) );
		/* 821BCB4Ch case   23:*/		return 0x821BCB50;
		  /* 821BCB50h */ case   24:  		/* stwx R31, <#[R9 + R10]> */
		/* 821BCB50h case   24:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R9 + regs.R10 + 0x00000000) );
		/* 821BCB50h case   24:*/		return 0x821BCB54;
		  /* 821BCB54h */ case   25:  		/* lwz R10, <#[R26 + 708]> */
		/* 821BCB54h case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x000002C4) );
		/* 821BCB54h case   25:*/		return 0x821BCB58;
		  /* 821BCB58h */ case   26:  		/* stwx R31, <#[R11 + R10]> */
		/* 821BCB58h case   26:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R11 + regs.R10 + 0x00000000) );
		/* 821BCB58h case   26:*/		return 0x821BCB5C;
	}
	return 0x821BCB5C;
} // Block from 821BCAF0h-821BCB5Ch (27 instructions)

//////////////////////////////////////////////////////
// Block at 821BCB5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCB5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCB5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCB5C);
		  /* 821BCB5Ch */ case    0:  		/* li R6, 1 */
		/* 821BCB5Ch case    0:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821BCB5Ch case    0:*/		return 0x821BCB60;
		  /* 821BCB60h */ case    1:  		/* li R5, 0 */
		/* 821BCB60h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821BCB60h case    1:*/		return 0x821BCB64;
		  /* 821BCB64h */ case    2:  		/* mr R4, R28 */
		/* 821BCB64h case    2:*/		regs.R4 = regs.R28;
		/* 821BCB64h case    2:*/		return 0x821BCB68;
		  /* 821BCB68h */ case    3:  		/* mr R3, R26 */
		/* 821BCB68h case    3:*/		regs.R3 = regs.R26;
		/* 821BCB68h case    3:*/		return 0x821BCB6C;
		  /* 821BCB6Ch */ case    4:  		/* bl 452700 */
		/* 821BCB6Ch case    4:*/		regs.LR = 0x821BCB70; return 0x8222B3C8;
		/* 821BCB6Ch case    4:*/		return 0x821BCB70;
		  /* 821BCB70h */ case    5:  		/* lwz R11, <#[R26 + 652]> */
		/* 821BCB70h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000028C) );
		/* 821BCB70h case    5:*/		return 0x821BCB74;
		  /* 821BCB74h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 821BCB74h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BCB74h case    6:*/		return 0x821BCB78;
		  /* 821BCB78h */ case    7:  		/* bc 12, CR6_EQ, 104 */
		/* 821BCB78h case    7:*/		if ( regs.CR[6].eq ) { return 0x821BCBE0;  }
		/* 821BCB78h case    7:*/		return 0x821BCB7C;
		  /* 821BCB7Ch */ case    8:  		/* lwz R11, <#[R31 + 8]> */
		/* 821BCB7Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821BCB7Ch case    8:*/		return 0x821BCB80;
		  /* 821BCB80h */ case    9:  		/* oris R11, R11, 1024 */
		/* 821BCB80h case    9:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x400);
		/* 821BCB80h case    9:*/		return 0x821BCB84;
		  /* 821BCB84h */ case   10:  		/* stw R11, <#[R31 + 8]> */
		/* 821BCB84h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821BCB84h case   10:*/		return 0x821BCB88;
		  /* 821BCB88h */ case   11:  		/* lwz R3, <#[R26 + 652]> */
		/* 821BCB88h case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R26 + 0x0000028C) );
		/* 821BCB88h case   11:*/		return 0x821BCB8C;
		  /* 821BCB8Ch */ case   12:  		/* lwz R11, <#[R3 + 4]> */
		/* 821BCB8Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821BCB8Ch case   12:*/		return 0x821BCB90;
		  /* 821BCB90h */ case   13:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821BCB90h case   13:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821BCB90h case   13:*/		return 0x821BCB94;
		  /* 821BCB94h */ case   14:  		/* bc 4, CR0_EQ, 40 */
		/* 821BCB94h case   14:*/		if ( !regs.CR[0].eq ) { return 0x821BCBBC;  }
		/* 821BCB94h case   14:*/		return 0x821BCB98;
		  /* 821BCB98h */ case   15:  		/* lwz R11, <#[R3]> */
		/* 821BCB98h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821BCB98h case   15:*/		return 0x821BCB9C;
		  /* 821BCB9Ch */ case   16:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821BCB9Ch case   16:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821BCB9Ch case   16:*/		return 0x821BCBA0;
		  /* 821BCBA0h */ case   17:  		/* addic. R11, R11, -4 */
		/* 821BCBA0h case   17:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 821BCBA0h case   17:*/		return 0x821BCBA4;
		  /* 821BCBA4h */ case   18:  		/* bc 12, CR0_EQ, 24 */
		/* 821BCBA4h case   18:*/		if ( regs.CR[0].eq ) { return 0x821BCBBC;  }
		/* 821BCBA4h case   18:*/		return 0x821BCBA8;
		  /* 821BCBA8h */ case   19:  		/* lwz R10, <#[R11 + 8]> */
		/* 821BCBA8h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821BCBA8h case   19:*/		return 0x821BCBAC;
		  /* 821BCBACh */ case   20:  		/* lwz R9, <#[R11 + 12]> */
		/* 821BCBACh case   20:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 821BCBACh case   20:*/		return 0x821BCBB0;
		  /* 821BCBB0h */ case   21:  		/* addi R10, R10, 1 */
		/* 821BCBB0h case   21:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821BCBB0h case   21:*/		return 0x821BCBB4;
		  /* 821BCBB4h */ case   22:  		/* cmplw CR6, R10, R9 */
		/* 821BCBB4h case   22:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 821BCBB4h case   22:*/		return 0x821BCBB8;
		  /* 821BCBB8h */ case   23:  		/* bc 4, CR6_GT, 16 */
		/* 821BCBB8h case   23:*/		if ( !regs.CR[6].gt ) { return 0x821BCBC8;  }
		/* 821BCBB8h case   23:*/		return 0x821BCBBC;
	}
	return 0x821BCBBC;
} // Block from 821BCB5Ch-821BCBBCh (24 instructions)

//////////////////////////////////////////////////////
// Block at 821BCBBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCBBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCBBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCBBC);
		  /* 821BCBBCh */ case    0:  		/* li R4, 1 */
		/* 821BCBBCh case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 821BCBBCh case    0:*/		return 0x821BCBC0;
		  /* 821BCBC0h */ case    1:  		/* bl -195320 */
		/* 821BCBC0h case    1:*/		regs.LR = 0x821BCBC4; return 0x8218D0C8;
		/* 821BCBC0h case    1:*/		return 0x821BCBC4;
		  /* 821BCBC4h */ case    2:  		/* mr R11, R3 */
		/* 821BCBC4h case    2:*/		regs.R11 = regs.R3;
		/* 821BCBC4h case    2:*/		return 0x821BCBC8;
	}
	return 0x821BCBC8;
} // Block from 821BCBBCh-821BCBC8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BCBC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCBC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCBC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCBC8);
		  /* 821BCBC8h */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 821BCBC8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821BCBC8h case    0:*/		return 0x821BCBCC;
		  /* 821BCBCCh */ case    1:  		/* addi R9, R10, 4 */
		/* 821BCBCCh case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 821BCBCCh case    1:*/		return 0x821BCBD0;
		  /* 821BCBD0h */ case    2:  		/* addi R8, R10, 1 */
		/* 821BCBD0h case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x1);
		/* 821BCBD0h case    2:*/		return 0x821BCBD4;
		  /* 821BCBD4h */ case    3:  		/* rlwinm R10, R9, 2, 0, 29 */
		/* 821BCBD4h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R9);
		/* 821BCBD4h case    3:*/		return 0x821BCBD8;
		  /* 821BCBD8h */ case    4:  		/* stw R8, <#[R11 + 8]> */
		/* 821BCBD8h case    4:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000008) );
		/* 821BCBD8h case    4:*/		return 0x821BCBDC;
		  /* 821BCBDCh */ case    5:  		/* stwx R31, <#[R10 + R11]> */
		/* 821BCBDCh case    5:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821BCBDCh case    5:*/		return 0x821BCBE0;
	}
	return 0x821BCBE0;
} // Block from 821BCBC8h-821BCBE0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BCBE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCBE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCBE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCBE0);
		  /* 821BCBE0h */ case    0:  		/* mr R28, R31 */
		/* 821BCBE0h case    0:*/		regs.R28 = regs.R31;
		/* 821BCBE0h case    0:*/		return 0x821BCBE4;
		  /* 821BCBE4h */ case    1:  		/* b -412 */
		/* 821BCBE4h case    1:*/		return 0x821BCA48;
		/* 821BCBE4h case    1:*/		return 0x821BCBE8;
	}
	return 0x821BCBE8;
} // Block from 821BCBE0h-821BCBE8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BCBE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCBE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCBE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCBE8);
		  /* 821BCBE8h */ case    0:  		/* lwz R10, <#[R28 + 8]> */
		/* 821BCBE8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000008) );
		/* 821BCBE8h case    0:*/		return 0x821BCBEC;
		  /* 821BCBECh */ case    1:  		/* li R5, 0 */
		/* 821BCBECh case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821BCBECh case    1:*/		return 0x821BCBF0;
		  /* 821BCBF0h */ case    2:  		/* li R11, 0 */
		/* 821BCBF0h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BCBF0h case    2:*/		return 0x821BCBF4;
		  /* 821BCBF4h */ case    3:  		/* rlwinm R3, R10, 13, 29, 31 */
		/* 821BCBF4h case    3:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R3,regs.R10);
		/* 821BCBF4h case    3:*/		return 0x821BCBF8;
		  /* 821BCBF8h */ case    4:  		/* addi R4, R28, 44 */
		/* 821BCBF8h case    4:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R28,0x2C);
		/* 821BCBF8h case    4:*/		return 0x821BCBFC;
		  /* 821BCBFCh */ case    5:  		/* cmplw CR6, R5, R3 */
		/* 821BCBFCh case    5:*/		cpu::op::cmplw<6>(regs,regs.R5,regs.R3);
		/* 821BCBFCh case    5:*/		return 0x821BCC00;
		  /* 821BCC00h */ case    6:  		/* bc 4, CR6_LT, -472 */
		/* 821BCC00h case    6:*/		if ( !regs.CR[6].lt ) { return 0x821BCA28;  }
		/* 821BCC00h case    6:*/		return 0x821BCC04;
		  /* 821BCC04h */ case    7:  		/* lwzx R10, <#[R4 + R11]> */
		/* 821BCC04h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + regs.R11 + 0x00000000) );
		/* 821BCC04h case    7:*/		return 0x821BCC08;
		  /* 821BCC08h */ case    8:  		/* addi R31, R1, 96 */
		/* 821BCC08h case    8:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0x60);
		/* 821BCC08h case    8:*/		return 0x821BCC0C;
		  /* 821BCC0Ch */ case    9:  		/* addi R30, R1, 112 */
		/* 821BCC0Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R1,0x70);
		/* 821BCC0Ch case    9:*/		return 0x821BCC10;
		  /* 821BCC10h */ case   10:  		/* addi R29, R1, 128 */
		/* 821BCC10h case   10:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R1,0x80);
		/* 821BCC10h case   10:*/		return 0x821BCC14;
		  /* 821BCC14h */ case   11:  		/* li R6, 0 */
		/* 821BCC14h case   11:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821BCC14h case   11:*/		return 0x821BCC18;
		  /* 821BCC18h */ case   12:  		/* cmplwi CR6, R5, 0 */
		/* 821BCC18h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 821BCC18h case   12:*/		return 0x821BCC1C;
		  /* 821BCC1Ch */ case   13:  		/* lwz R7, <#[R10]> */
		/* 821BCC1Ch case   13:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R10 + 0x00000000) );
		/* 821BCC1Ch case   13:*/		return 0x821BCC20;
		  /* 821BCC20h */ case   14:  		/* lwz R9, <#[R10 + 12]> */
		/* 821BCC20h case   14:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x0000000C) );
		/* 821BCC20h case   14:*/		return 0x821BCC24;
		  /* 821BCC24h */ case   15:  		/* rlwinm R8, R7, 0, 27, 31 */
		/* 821BCC24h case   15:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R8,regs.R7);
		/* 821BCC24h case   15:*/		return 0x821BCC28;
		  /* 821BCC28h */ case   16:  		/* rlwinm R7, R7, 27, 30, 31 */
		/* 821BCC28h case   16:*/		cpu::op::rlwinm<0,27,30,31>(regs,&regs.R7,regs.R7);
		/* 821BCC28h case   16:*/		return 0x821BCC2C;
		  /* 821BCC2Ch */ case   17:  		/* stwx R8, <#[R11 + R30]> */
		/* 821BCC2Ch case   17:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + regs.R30 + 0x00000000) );
		/* 821BCC2Ch case   17:*/		return 0x821BCC30;
		  /* 821BCC30h */ case   18:  		/* stwx R7, <#[R11 + R29]> */
		/* 821BCC30h case   18:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R11 + regs.R29 + 0x00000000) );
		/* 821BCC30h case   18:*/		return 0x821BCC34;
		  /* 821BCC34h */ case   19:  		/* stwx R9, <#[R11 + R31]> */
		/* 821BCC34h case   19:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 821BCC34h case   19:*/		return 0x821BCC38;
		  /* 821BCC38h */ case   20:  		/* bc 12, CR6_EQ, 80 */
		/* 821BCC38h case   20:*/		if ( regs.CR[6].eq ) { return 0x821BCC88;  }
		/* 821BCC38h case   20:*/		return 0x821BCC3C;
		  /* 821BCC3Ch */ case   21:  		/* li R10, 0 */
		/* 821BCC3Ch case   21:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821BCC3Ch case   21:*/		return 0x821BCC40;
		  /* 821BCC40h */ case   22:  		/* addi R31, R1, 96 */
		/* 821BCC40h case   22:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0x60);
		/* 821BCC40h case   22:*/		return 0x821BCC44;
		  /* 821BCC44h */ case   23:  		/* lwzx R31, <#[R10 + R31]> */
		/* 821BCC44h case   23:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 821BCC44h case   23:*/		return 0x821BCC48;
		  /* 821BCC48h */ case   24:  		/* cmplw CR6, R31, R9 */
		/* 821BCC48h case   24:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R9);
		/* 821BCC48h case   24:*/		return 0x821BCC4C;
		  /* 821BCC4Ch */ case   25:  		/* bc 4, CR6_EQ, 36 */
		/* 821BCC4Ch case   25:*/		if ( !regs.CR[6].eq ) { return 0x821BCC70;  }
		/* 821BCC4Ch case   25:*/		return 0x821BCC50;
		  /* 821BCC50h */ case   26:  		/* addi R31, R1, 112 */
		/* 821BCC50h case   26:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0x70);
		/* 821BCC50h case   26:*/		return 0x821BCC54;
		  /* 821BCC54h */ case   27:  		/* lwzx R31, <#[R10 + R31]> */
		/* 821BCC54h case   27:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 821BCC54h case   27:*/		return 0x821BCC58;
		  /* 821BCC58h */ case   28:  		/* cmplw CR6, R31, R8 */
		/* 821BCC58h case   28:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R8);
		/* 821BCC58h case   28:*/		return 0x821BCC5C;
		  /* 821BCC5Ch */ case   29:  		/* bc 4, CR6_EQ, 20 */
		/* 821BCC5Ch case   29:*/		if ( !regs.CR[6].eq ) { return 0x821BCC70;  }
		/* 821BCC5Ch case   29:*/		return 0x821BCC60;
		  /* 821BCC60h */ case   30:  		/* addi R31, R1, 128 */
		/* 821BCC60h case   30:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R1,0x80);
		/* 821BCC60h case   30:*/		return 0x821BCC64;
		  /* 821BCC64h */ case   31:  		/* lwzx R31, <#[R10 + R31]> */
		/* 821BCC64h case   31:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 821BCC64h case   31:*/		return 0x821BCC68;
		  /* 821BCC68h */ case   32:  		/* cmpw CR6, R31, R7 */
		/* 821BCC68h case   32:*/		cpu::op::cmpw<6>(regs,regs.R31,regs.R7);
		/* 821BCC68h case   32:*/		return 0x821BCC6C;
		  /* 821BCC6Ch */ case   33:  		/* bc 12, CR6_EQ, 20 */
		/* 821BCC6Ch case   33:*/		if ( regs.CR[6].eq ) { return 0x821BCC80;  }
		/* 821BCC6Ch case   33:*/		return 0x821BCC70;
	}
	return 0x821BCC70;
} // Block from 821BCBE8h-821BCC70h (34 instructions)

//////////////////////////////////////////////////////
// Block at 821BCC70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCC70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCC70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCC70);
		  /* 821BCC70h */ case    0:  		/* addi R6, R6, 1 */
		/* 821BCC70h case    0:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R6,0x1);
		/* 821BCC70h case    0:*/		return 0x821BCC74;
		  /* 821BCC74h */ case    1:  		/* addi R10, R10, 4 */
		/* 821BCC74h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821BCC74h case    1:*/		return 0x821BCC78;
		  /* 821BCC78h */ case    2:  		/* cmplw CR6, R6, R5 */
		/* 821BCC78h case    2:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R5);
		/* 821BCC78h case    2:*/		return 0x821BCC7C;
		  /* 821BCC7Ch */ case    3:  		/* bc 12, CR6_LT, -60 */
		/* 821BCC7Ch case    3:*/		if ( regs.CR[6].lt ) { return 0x821BCC40;  }
		/* 821BCC7Ch case    3:*/		return 0x821BCC80;
	}
	return 0x821BCC80;
} // Block from 821BCC70h-821BCC80h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BCC80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCC80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCC80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCC80);
		  /* 821BCC80h */ case    0:  		/* cmplw CR6, R6, R5 */
		/* 821BCC80h case    0:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R5);
		/* 821BCC80h case    0:*/		return 0x821BCC84;
		  /* 821BCC84h */ case    1:  		/* bc 12, CR6_LT, 16 */
		/* 821BCC84h case    1:*/		if ( regs.CR[6].lt ) { return 0x821BCC94;  }
		/* 821BCC84h case    1:*/		return 0x821BCC88;
	}
	return 0x821BCC88;
} // Block from 821BCC80h-821BCC88h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BCC88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCC88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCC88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCC88);
		  /* 821BCC88h */ case    0:  		/* addi R5, R5, 1 */
		/* 821BCC88h case    0:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R5,0x1);
		/* 821BCC88h case    0:*/		return 0x821BCC8C;
		  /* 821BCC8Ch */ case    1:  		/* addi R11, R11, 4 */
		/* 821BCC8Ch case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821BCC8Ch case    1:*/		return 0x821BCC90;
		  /* 821BCC90h */ case    2:  		/* b -148 */
		/* 821BCC90h case    2:*/		return 0x821BCBFC;
		/* 821BCC90h case    2:*/		return 0x821BCC94;
	}
	return 0x821BCC94;
} // Block from 821BCC88h-821BCC94h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BCC94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCC94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCC94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCC94);
		  /* 821BCC94h */ case    0:  		/* addi R11, R6, 11 */
		/* 821BCC94h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R6,0xB);
		/* 821BCC94h case    0:*/		return 0x821BCC98;
		  /* 821BCC98h */ case    1:  		/* rlwinm R10, R6, 2, 0, 29 */
		/* 821BCC98h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R6);
		/* 821BCC98h case    1:*/		return 0x821BCC9C;
		  /* 821BCC9Ch */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821BCC9Ch case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821BCC9Ch case    2:*/		return 0x821BCCA0;
		  /* 821BCCA0h */ case    3:  		/* addi R9, R1, 96 */
		/* 821BCCA0h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R1,0x60);
		/* 821BCCA0h case    3:*/		return 0x821BCCA4;
		  /* 821BCCA4h */ case    4:  		/* lwzx R11, <#[R11 + R28]> */
		/* 821BCCA4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R28 + 0x00000000) );
		/* 821BCCA4h case    4:*/		return 0x821BCCA8;
		  /* 821BCCA8h */ case    5:  		/* lwzx R10, <#[R10 + R9]> */
		/* 821BCCA8h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R9 + 0x00000000) );
		/* 821BCCA8h case    5:*/		return 0x821BCCAC;
		  /* 821BCCACh */ case    6:  		/* lwz R11, <#[R11 + 12]> */
		/* 821BCCACh case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 821BCCACh case    6:*/		return 0x821BCCB0;
		  /* 821BCCB0h */ case    7:  		/* cmplw CR6, R11, R10 */
		/* 821BCCB0h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821BCCB0h case    7:*/		return 0x821BCCB4;
		  /* 821BCCB4h */ case    8:  		/* bc 12, CR6_EQ, 16 */
		/* 821BCCB4h case    8:*/		if ( regs.CR[6].eq ) { return 0x821BCCC4;  }
		/* 821BCCB4h case    8:*/		return 0x821BCCB8;
		  /* 821BCCB8h */ case    9:  		/* mr R11, R5 */
		/* 821BCCB8h case    9:*/		regs.R11 = regs.R5;
		/* 821BCCB8h case    9:*/		return 0x821BCCBC;
		  /* 821BCCBCh */ case   10:  		/* mr R5, R6 */
		/* 821BCCBCh case   10:*/		regs.R5 = regs.R6;
		/* 821BCCBCh case   10:*/		return 0x821BCCC0;
		  /* 821BCCC0h */ case   11:  		/* mr R6, R11 */
		/* 821BCCC0h case   11:*/		regs.R6 = regs.R11;
		/* 821BCCC0h case   11:*/		return 0x821BCCC4;
	}
	return 0x821BCCC4;
} // Block from 821BCC94h-821BCCC4h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821BCCC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCCC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCCC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCCC4);
		  /* 821BCCC4h */ case    0:  		/* addi R7, R1, 80 */
		/* 821BCCC4h case    0:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 821BCCC4h case    0:*/		return 0x821BCCC8;
		  /* 821BCCC8h */ case    1:  		/* mr R4, R28 */
		/* 821BCCC8h case    1:*/		regs.R4 = regs.R28;
		/* 821BCCC8h case    1:*/		return 0x821BCCCC;
		  /* 821BCCCCh */ case    2:  		/* mr R3, R26 */
		/* 821BCCCCh case    2:*/		regs.R3 = regs.R26;
		/* 821BCCCCh case    2:*/		return 0x821BCCD0;
		  /* 821BCCD0h */ case    3:  		/* bl 34256 */
		/* 821BCCD0h case    3:*/		regs.LR = 0x821BCCD4; return 0x821C52A0;
		/* 821BCCD0h case    3:*/		return 0x821BCCD4;
		  /* 821BCCD4h */ case    4:  		/* mr R31, R3 */
		/* 821BCCD4h case    4:*/		regs.R31 = regs.R3;
		/* 821BCCD4h case    4:*/		return 0x821BCCD8;
		  /* 821BCCD8h */ case    5:  		/* addi R27, R28, 4 */
		/* 821BCCD8h case    5:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R28,0x4);
		/* 821BCCD8h case    5:*/		return 0x821BCCDC;
		  /* 821BCCDCh */ case    6:  		/* lwz R30, <#[R27]> */
		/* 821BCCDCh case    6:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R27 + 0x00000000) );
		/* 821BCCDCh case    6:*/		return 0x821BCCE0;
		  /* 821BCCE0h */ case    7:  		/* cmplwi CR6, R30, 0 */
		/* 821BCCE0h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821BCCE0h case    7:*/		return 0x821BCCE4;
		  /* 821BCCE4h */ case    8:  		/* bc 12, CR6_EQ, -632 */
		/* 821BCCE4h case    8:*/		if ( regs.CR[6].eq ) { return 0x821BCA6C;  }
		/* 821BCCE4h case    8:*/		return 0x821BCCE8;
		  /* 821BCCE8h */ case    9:  		/* lwz R29, <#[R30 + 16]> */
		/* 821BCCE8h case    9:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R30 + 0x00000010) );
		/* 821BCCE8h case    9:*/		return 0x821BCCEC;
		  /* 821BCCECh */ case   10:  		/* cmplwi CR6, R29, 0 */
		/* 821BCCECh case   10:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 821BCCECh case   10:*/		return 0x821BCCF0;
		  /* 821BCCF0h */ case   11:  		/* bc 12, CR6_EQ, 260 */
		/* 821BCCF0h case   11:*/		if ( regs.CR[6].eq ) { return 0x821BCDF4;  }
		/* 821BCCF0h case   11:*/		return 0x821BCCF4;
		  /* 821BCCF4h */ case   12:  		/* lwz R11, <#[R30]> */
		/* 821BCCF4h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821BCCF4h case   12:*/		return 0x821BCCF8;
		  /* 821BCCF8h */ case   13:  		/* rlwinm. R10, R11, 0, 4, 6 */
		/* 821BCCF8h case   13:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R10,regs.R11);
		/* 821BCCF8h case   13:*/		return 0x821BCCFC;
		  /* 821BCCFCh */ case   14:  		/* bc 12, CR0_EQ, 192 */
		/* 821BCCFCh case   14:*/		if ( regs.CR[0].eq ) { return 0x821BCDBC;  }
		/* 821BCCFCh case   14:*/		return 0x821BCD00;
		  /* 821BCD00h */ case   15:  		/* lwz R10, <#[R1 + 80]> */
		/* 821BCD00h case   15:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 821BCD00h case   15:*/		return 0x821BCD04;
		  /* 821BCD04h */ case   16:  		/* rlwinm R9, R11, 22, 29, 30 */
		/* 821BCD04h case   16:*/		cpu::op::rlwinm<0,22,29,30>(regs,&regs.R9,regs.R11);
		/* 821BCD04h case   16:*/		return 0x821BCD08;
		  /* 821BCD08h */ case   17:  		/* rlwinm R8, R11, 24, 29, 30 */
		/* 821BCD08h case   17:*/		cpu::op::rlwinm<0,24,29,30>(regs,&regs.R8,regs.R11);
		/* 821BCD08h case   17:*/		return 0x821BCD0C;
		  /* 821BCD0Ch */ case   18:  		/* srw R9, R10, R9 */
		/* 821BCD0Ch case   18:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 821BCD0Ch case   18:*/		return 0x821BCD10;
		  /* 821BCD10h */ case   19:  		/* srw R8, R10, R8 */
		/* 821BCD10h case   19:*/		cpu::op::srw<0>(regs,&regs.R8,regs.R10,regs.R8);
		/* 821BCD10h case   19:*/		return 0x821BCD14;
		  /* 821BCD14h */ case   20:  		/* rlwimi R8, R9, 2, 28, 29 */
		/* 821BCD14h case   20:*/		cpu::op::rlwimi<0,2,28,29>(regs,&regs.R8,regs.R9);
		/* 821BCD14h case   20:*/		return 0x821BCD18;
		  /* 821BCD18h */ case   21:  		/* rlwinm R9, R11, 26, 29, 30 */
		/* 821BCD18h case   21:*/		cpu::op::rlwinm<0,26,29,30>(regs,&regs.R9,regs.R11);
		/* 821BCD18h case   21:*/		return 0x821BCD1C;
		  /* 821BCD1Ch */ case   22:  		/* rlwinm R7, R11, 28, 29, 30 */
		/* 821BCD1Ch case   22:*/		cpu::op::rlwinm<0,28,29,30>(regs,&regs.R7,regs.R11);
		/* 821BCD1Ch case   22:*/		return 0x821BCD20;
		  /* 821BCD20h */ case   23:  		/* srw R9, R10, R9 */
		/* 821BCD20h case   23:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R10,regs.R9);
		/* 821BCD20h case   23:*/		return 0x821BCD24;
		  /* 821BCD24h */ case   24:  		/* rlwinm R8, R8, 0, 28, 31 */
		/* 821BCD24h case   24:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R8,regs.R8);
		/* 821BCD24h case   24:*/		return 0x821BCD28;
		  /* 821BCD28h */ case   25:  		/* srw R10, R10, R7 */
		/* 821BCD28h case   25:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R10,regs.R7);
		/* 821BCD28h case   25:*/		return 0x821BCD2C;
		  /* 821BCD2Ch */ case   26:  		/* rlwimi R9, R8, 2, 0, 29 */
		/* 821BCD2Ch case   26:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R9,regs.R8);
		/* 821BCD2Ch case   26:*/		return 0x821BCD30;
		  /* 821BCD30h */ case   27:  		/* rlwinm R11, R11, 0, 27, 18 */
		/* 821BCD30h case   27:*/		cpu::op::rlwinm<0,0,27,18>(regs,&regs.R11,regs.R11);
		/* 821BCD30h case   27:*/		return 0x821BCD34;
		  /* 821BCD34h */ case   28:  		/* rlwimi R10, R9, 2, 0, 29 */
		/* 821BCD34h case   28:*/		cpu::op::rlwimi<0,2,0,29>(regs,&regs.R10,regs.R9);
		/* 821BCD34h case   28:*/		return 0x821BCD38;
		  /* 821BCD38h */ case   29:  		/* rlwinm R10, R10, 5, 0, 26 */
		/* 821BCD38h case   29:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R10,regs.R10);
		/* 821BCD38h case   29:*/		return 0x821BCD3C;
		  /* 821BCD3Ch */ case   30:  		/* or R11, R10, R11 */
		/* 821BCD3Ch case   30:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821BCD3Ch case   30:*/		return 0x821BCD40;
		  /* 821BCD40h */ case   31:  		/* stw R11, <#[R30]> */
		/* 821BCD40h case   31:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821BCD40h case   31:*/		return 0x821BCD44;
		  /* 821BCD44h */ case   32:  		/* lwz R11, <#[R26 + 652]> */
		/* 821BCD44h case   32:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x0000028C) );
		/* 821BCD44h case   32:*/		return 0x821BCD48;
		  /* 821BCD48h */ case   33:  		/* cmplwi CR6, R11, 0 */
		/* 821BCD48h case   33:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BCD48h case   33:*/		return 0x821BCD4C;
		  /* 821BCD4Ch */ case   34:  		/* bc 12, CR6_EQ, 112 */
		/* 821BCD4Ch case   34:*/		if ( regs.CR[6].eq ) { return 0x821BCDBC;  }
		/* 821BCD4Ch case   34:*/		return 0x821BCD50;
		  /* 821BCD50h */ case   35:  		/* lwz R11, <#[R29 + 8]> */
		/* 821BCD50h case   35:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 821BCD50h case   35:*/		return 0x821BCD54;
		  /* 821BCD54h */ case   36:  		/* rlwinm. R10, R11, 6, 31, 31 */
		/* 821BCD54h case   36:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R10,regs.R11);
		/* 821BCD54h case   36:*/		return 0x821BCD58;
		  /* 821BCD58h */ case   37:  		/* bc 4, CR0_EQ, 100 */
		/* 821BCD58h case   37:*/		if ( !regs.CR[0].eq ) { return 0x821BCDBC;  }
		/* 821BCD58h case   37:*/		return 0x821BCD5C;
		  /* 821BCD5Ch */ case   38:  		/* oris R11, R11, 1024 */
		/* 821BCD5Ch case   38:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x400);
		/* 821BCD5Ch case   38:*/		return 0x821BCD60;
		  /* 821BCD60h */ case   39:  		/* stw R11, <#[R29 + 8]> */
		/* 821BCD60h case   39:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 821BCD60h case   39:*/		return 0x821BCD64;
		  /* 821BCD64h */ case   40:  		/* lwz R3, <#[R26 + 652]> */
		/* 821BCD64h case   40:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R26 + 0x0000028C) );
		/* 821BCD64h case   40:*/		return 0x821BCD68;
		  /* 821BCD68h */ case   41:  		/* lwz R11, <#[R3 + 4]> */
		/* 821BCD68h case   41:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821BCD68h case   41:*/		return 0x821BCD6C;
		  /* 821BCD6Ch */ case   42:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821BCD6Ch case   42:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821BCD6Ch case   42:*/		return 0x821BCD70;
		  /* 821BCD70h */ case   43:  		/* bc 4, CR0_EQ, 40 */
		/* 821BCD70h case   43:*/		if ( !regs.CR[0].eq ) { return 0x821BCD98;  }
		/* 821BCD70h case   43:*/		return 0x821BCD74;
		  /* 821BCD74h */ case   44:  		/* lwz R11, <#[R3]> */
		/* 821BCD74h case   44:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821BCD74h case   44:*/		return 0x821BCD78;
		  /* 821BCD78h */ case   45:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821BCD78h case   45:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821BCD78h case   45:*/		return 0x821BCD7C;
		  /* 821BCD7Ch */ case   46:  		/* addic. R11, R11, -4 */
		/* 821BCD7Ch case   46:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFFC);
		/* 821BCD7Ch case   46:*/		return 0x821BCD80;
		  /* 821BCD80h */ case   47:  		/* bc 12, CR0_EQ, 24 */
		/* 821BCD80h case   47:*/		if ( regs.CR[0].eq ) { return 0x821BCD98;  }
		/* 821BCD80h case   47:*/		return 0x821BCD84;
		  /* 821BCD84h */ case   48:  		/* lwz R10, <#[R11 + 8]> */
		/* 821BCD84h case   48:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821BCD84h case   48:*/		return 0x821BCD88;
		  /* 821BCD88h */ case   49:  		/* lwz R9, <#[R11 + 12]> */
		/* 821BCD88h case   49:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000000C) );
		/* 821BCD88h case   49:*/		return 0x821BCD8C;
		  /* 821BCD8Ch */ case   50:  		/* addi R10, R10, 1 */
		/* 821BCD8Ch case   50:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821BCD8Ch case   50:*/		return 0x821BCD90;
		  /* 821BCD90h */ case   51:  		/* cmplw CR6, R10, R9 */
		/* 821BCD90h case   51:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 821BCD90h case   51:*/		return 0x821BCD94;
		  /* 821BCD94h */ case   52:  		/* bc 4, CR6_GT, 16 */
		/* 821BCD94h case   52:*/		if ( !regs.CR[6].gt ) { return 0x821BCDA4;  }
		/* 821BCD94h case   52:*/		return 0x821BCD98;
	}
	return 0x821BCD98;
} // Block from 821BCCC4h-821BCD98h (53 instructions)

//////////////////////////////////////////////////////
// Block at 821BCD98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCD98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCD98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCD98);
		  /* 821BCD98h */ case    0:  		/* li R4, 1 */
		/* 821BCD98h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x1);
		/* 821BCD98h case    0:*/		return 0x821BCD9C;
		  /* 821BCD9Ch */ case    1:  		/* bl -195796 */
		/* 821BCD9Ch case    1:*/		regs.LR = 0x821BCDA0; return 0x8218D0C8;
		/* 821BCD9Ch case    1:*/		return 0x821BCDA0;
		  /* 821BCDA0h */ case    2:  		/* mr R11, R3 */
		/* 821BCDA0h case    2:*/		regs.R11 = regs.R3;
		/* 821BCDA0h case    2:*/		return 0x821BCDA4;
	}
	return 0x821BCDA4;
} // Block from 821BCD98h-821BCDA4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BCDA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCDA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCDA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCDA4);
		  /* 821BCDA4h */ case    0:  		/* lwz R10, <#[R11 + 8]> */
		/* 821BCDA4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821BCDA4h case    0:*/		return 0x821BCDA8;
		  /* 821BCDA8h */ case    1:  		/* addi R9, R10, 4 */
		/* 821BCDA8h case    1:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R10,0x4);
		/* 821BCDA8h case    1:*/		return 0x821BCDAC;
		  /* 821BCDACh */ case    2:  		/* addi R8, R10, 1 */
		/* 821BCDACh case    2:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x1);
		/* 821BCDACh case    2:*/		return 0x821BCDB0;
		  /* 821BCDB0h */ case    3:  		/* rlwinm R10, R9, 2, 0, 29 */
		/* 821BCDB0h case    3:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R9);
		/* 821BCDB0h case    3:*/		return 0x821BCDB4;
		  /* 821BCDB4h */ case    4:  		/* stw R8, <#[R11 + 8]> */
		/* 821BCDB4h case    4:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R11 + 0x00000008) );
		/* 821BCDB4h case    4:*/		return 0x821BCDB8;
		  /* 821BCDB8h */ case    5:  		/* stwx R29, <#[R10 + R11]> */
		/* 821BCDB8h case    5:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821BCDB8h case    5:*/		return 0x821BCDBC;
	}
	return 0x821BCDBC;
} // Block from 821BCDA4h-821BCDBCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BCDBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCDBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCDBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCDBC);
		  /* 821BCDBCh */ case    0:  		/* lwz R11, <#[R30 + 12]> */
		/* 821BCDBCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 821BCDBCh case    0:*/		return 0x821BCDC0;
		  /* 821BCDC0h */ case    1:  		/* addi R11, R11, 4 */
		/* 821BCDC0h case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821BCDC0h case    1:*/		return 0x821BCDC4;
		  /* 821BCDC4h */ case    2:  		/* lwz R10, <#[R11]> */
		/* 821BCDC4h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821BCDC4h case    2:*/		return 0x821BCDC8;
		  /* 821BCDC8h */ case    3:  		/* b 12 */
		/* 821BCDC8h case    3:*/		return 0x821BCDD4;
		/* 821BCDC8h case    3:*/		return 0x821BCDCC;
		  /* 821BCDCCh */ case    4:  		/* addi R11, R10, 8 */
		/* 821BCDCCh case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 821BCDCCh case    4:*/		return 0x821BCDD0;
		  /* 821BCDD0h */ case    5:  		/* lwz R10, <#[R10 + 8]> */
		/* 821BCDD0h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 821BCDD0h case    5:*/		return 0x821BCDD4;
	}
	return 0x821BCDD4;
} // Block from 821BCDBCh-821BCDD4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BCDD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCDD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCDD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCDD4);
		  /* 821BCDD4h */ case    0:  		/* cmplw CR6, R10, R30 */
		/* 821BCDD4h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R30);
		/* 821BCDD4h case    0:*/		return 0x821BCDD8;
		  /* 821BCDD8h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 821BCDD8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BCDCC;  }
		/* 821BCDD8h case    1:*/		return 0x821BCDDC;
		  /* 821BCDDCh */ case    2:  		/* lwz R10, <#[R30 + 8]> */
		/* 821BCDDCh case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x00000008) );
		/* 821BCDDCh case    2:*/		return 0x821BCDE0;
		  /* 821BCDE0h */ case    3:  		/* stw R10, <#[R11]> */
		/* 821BCDE0h case    3:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821BCDE0h case    3:*/		return 0x821BCDE4;
		  /* 821BCDE4h */ case    4:  		/* lwz R11, <#[R31 + 4]> */
		/* 821BCDE4h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 821BCDE4h case    4:*/		return 0x821BCDE8;
		  /* 821BCDE8h */ case    5:  		/* stw R11, <#[R30 + 8]> */
		/* 821BCDE8h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821BCDE8h case    5:*/		return 0x821BCDEC;
		  /* 821BCDECh */ case    6:  		/* stw R30, <#[R31 + 4]> */
		/* 821BCDECh case    6:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R31 + 0x00000004) );
		/* 821BCDECh case    6:*/		return 0x821BCDF0;
		  /* 821BCDF0h */ case    7:  		/* stw R31, <#[R30 + 12]> */
		/* 821BCDF0h case    7:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R30 + 0x0000000C) );
		/* 821BCDF0h case    7:*/		return 0x821BCDF4;
	}
	return 0x821BCDF4;
} // Block from 821BCDD4h-821BCDF4h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821BCDF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCDF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCDF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCDF4);
		  /* 821BCDF4h */ case    0:  		/* lwz R11, <#[R27]> */
		/* 821BCDF4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 821BCDF4h case    0:*/		return 0x821BCDF8;
		  /* 821BCDF8h */ case    1:  		/* cmplw CR6, R11, R30 */
		/* 821BCDF8h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 821BCDF8h case    1:*/		return 0x821BCDFC;
		  /* 821BCDFCh */ case    2:  		/* bc 4, CR6_EQ, -288 */
		/* 821BCDFCh case    2:*/		if ( !regs.CR[6].eq ) { return 0x821BCCDC;  }
		/* 821BCDFCh case    2:*/		return 0x821BCE00;
		  /* 821BCE00h */ case    3:  		/* addi R27, R30, 8 */
		/* 821BCE00h case    3:*/		cpu::op::addi<0>(regs,&regs.R27,regs.R30,0x8);
		/* 821BCE00h case    3:*/		return 0x821BCE04;
		  /* 821BCE04h */ case    4:  		/* b -296 */
		/* 821BCE04h case    4:*/		return 0x821BCCDC;
		/* 821BCE04h case    4:*/		return 0x821BCE08;
	}
	return 0x821BCE08;
} // Block from 821BCDF4h-821BCE08h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BCE08h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCE08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCE08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCE08);
		  /* 821BCE08h */ case    0:  		/* mfspr R12, LR */
		/* 821BCE08h case    0:*/		regs.R12 = regs.LR;
		/* 821BCE08h case    0:*/		return 0x821BCE0C;
		  /* 821BCE0Ch */ case    1:  		/* bl -1227696 */
		/* 821BCE0Ch case    1:*/		regs.LR = 0x821BCE10; return 0x8209125C;
		/* 821BCE0Ch case    1:*/		return 0x821BCE10;
		  /* 821BCE10h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821BCE10h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821BCE10h case    2:*/		return 0x821BCE14;
		  /* 821BCE14h */ case    3:  		/* mr R30, R4 */
		/* 821BCE14h case    3:*/		regs.R30 = regs.R4;
		/* 821BCE14h case    3:*/		return 0x821BCE18;
		  /* 821BCE18h */ case    4:  		/* mr R31, R3 */
		/* 821BCE18h case    4:*/		regs.R31 = regs.R3;
		/* 821BCE18h case    4:*/		return 0x821BCE1C;
		  /* 821BCE1Ch */ case    5:  		/* mr R4, R3 */
		/* 821BCE1Ch case    5:*/		regs.R4 = regs.R3;
		/* 821BCE1Ch case    5:*/		return 0x821BCE20;
		  /* 821BCE20h */ case    6:  		/* mr R3, R30 */
		/* 821BCE20h case    6:*/		regs.R3 = regs.R30;
		/* 821BCE20h case    6:*/		return 0x821BCE24;
		  /* 821BCE24h */ case    7:  		/* mr R29, R5 */
		/* 821BCE24h case    7:*/		regs.R29 = regs.R5;
		/* 821BCE24h case    7:*/		return 0x821BCE28;
		  /* 821BCE28h */ case    8:  		/* bl -156288 */
		/* 821BCE28h case    8:*/		regs.LR = 0x821BCE2C; return 0x82196BA8;
		/* 821BCE28h case    8:*/		return 0x821BCE2C;
		  /* 821BCE2Ch */ case    9:  		/* mr R5, R29 */
		/* 821BCE2Ch case    9:*/		regs.R5 = regs.R29;
		/* 821BCE2Ch case    9:*/		return 0x821BCE30;
		  /* 821BCE30h */ case   10:  		/* mr R4, R30 */
		/* 821BCE30h case   10:*/		regs.R4 = regs.R30;
		/* 821BCE30h case   10:*/		return 0x821BCE34;
		  /* 821BCE34h */ case   11:  		/* mr R3, R31 */
		/* 821BCE34h case   11:*/		regs.R3 = regs.R31;
		/* 821BCE34h case   11:*/		return 0x821BCE38;
		  /* 821BCE38h */ case   12:  		/* bl -1248 */
		/* 821BCE38h case   12:*/		regs.LR = 0x821BCE3C; return 0x821BC958;
		/* 821BCE38h case   12:*/		return 0x821BCE3C;
		  /* 821BCE3Ch */ case   13:  		/* addi R1, R1, 112 */
		/* 821BCE3Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821BCE3Ch case   13:*/		return 0x821BCE40;
		  /* 821BCE40h */ case   14:  		/* b -1227668 */
		/* 821BCE40h case   14:*/		return 0x820912AC;
		/* 821BCE40h case   14:*/		return 0x821BCE44;
		  /* 821BCE44h */ case   15:  		/* nop */
		/* 821BCE44h case   15:*/		cpu::op::nop();
		/* 821BCE44h case   15:*/		return 0x821BCE48;
		  /* 821BCE48h */ case   16:  		/* lwz R11, <#[R3 + 8]> */
		/* 821BCE48h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821BCE48h case   16:*/		return 0x821BCE4C;
		  /* 821BCE4Ch */ case   17:  		/* rlwinm R10, R11, 25, 25, 31 */
		/* 821BCE4Ch case   17:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R11);
		/* 821BCE4Ch case   17:*/		return 0x821BCE50;
		  /* 821BCE50h */ case   18:  		/* cmplwi CR6, R10, 16 */
		/* 821BCE50h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000010);
		/* 821BCE50h case   18:*/		return 0x821BCE54;
		  /* 821BCE54h */ case   19:  		/* bc 12, CR6_LT, 16 */
		/* 821BCE54h case   19:*/		if ( regs.CR[6].lt ) { return 0x821BCE64;  }
		/* 821BCE54h case   19:*/		return 0x821BCE58;
		  /* 821BCE58h */ case   20:  		/* cmplwi CR6, R10, 18 */
		/* 821BCE58h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000012);
		/* 821BCE58h case   20:*/		return 0x821BCE5C;
		  /* 821BCE5Ch */ case   21:  		/* li R11, 1 */
		/* 821BCE5Ch case   21:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821BCE5Ch case   21:*/		return 0x821BCE60;
		  /* 821BCE60h */ case   22:  		/* bc 4, CR6_GT, 8 */
		/* 821BCE60h case   22:*/		if ( !regs.CR[6].gt ) { return 0x821BCE68;  }
		/* 821BCE60h case   22:*/		return 0x821BCE64;
	}
	return 0x821BCE64;
} // Block from 821BCE08h-821BCE64h (23 instructions)

//////////////////////////////////////////////////////
// Block at 821BCE64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCE64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCE64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCE64);
		  /* 821BCE64h */ case    0:  		/* li R11, 0 */
		/* 821BCE64h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BCE64h case    0:*/		return 0x821BCE68;
	}
	return 0x821BCE68;
} // Block from 821BCE64h-821BCE68h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BCE68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCE68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCE68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCE68);
		  /* 821BCE68h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821BCE68h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821BCE68h case    0:*/		return 0x821BCE6C;
		  /* 821BCE6Ch */ case    1:  		/* bc 4, CR0_EQ, 24 */
		/* 821BCE6Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x821BCE84;  }
		/* 821BCE6Ch case    1:*/		return 0x821BCE70;
		  /* 821BCE70h */ case    2:  		/* cmplwi CR6, R10, 2 */
		/* 821BCE70h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000002);
		/* 821BCE70h case    2:*/		return 0x821BCE74;
		  /* 821BCE74h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 821BCE74h case    3:*/		if ( regs.CR[6].eq ) { return 0x821BCE84;  }
		/* 821BCE74h case    3:*/		return 0x821BCE78;
		  /* 821BCE78h */ case    4:  		/* cmplwi CR6, R10, 12 */
		/* 821BCE78h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000000C);
		/* 821BCE78h case    4:*/		return 0x821BCE7C;
		  /* 821BCE7Ch */ case    5:  		/* li R11, 0 */
		/* 821BCE7Ch case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BCE7Ch case    5:*/		return 0x821BCE80;
		  /* 821BCE80h */ case    6:  		/* bc 4, CR6_EQ, 8 */
		/* 821BCE80h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821BCE88;  }
		/* 821BCE80h case    6:*/		return 0x821BCE84;
	}
	return 0x821BCE84;
} // Block from 821BCE68h-821BCE84h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BCE84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCE84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCE84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCE84);
		  /* 821BCE84h */ case    0:  		/* li R11, 1 */
		/* 821BCE84h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821BCE84h case    0:*/		return 0x821BCE88;
	}
	return 0x821BCE88;
} // Block from 821BCE84h-821BCE88h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BCE88h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCE88( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCE88) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCE88);
		  /* 821BCE88h */ case    0:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 821BCE88h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 821BCE88h case    0:*/		return 0x821BCE8C;
		  /* 821BCE8Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 821BCE8Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BCE8Ch case    1:*/		return 0x821BCE90;
	}
	return 0x821BCE90;
} // Block from 821BCE88h-821BCE90h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BCE90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCE90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCE90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCE90);
		  /* 821BCE90h */ case    0:  		/* stfd FR1, <#[R1 + 16]> */
		/* 821BCE90h case    0:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0x00000010) );
		/* 821BCE90h case    0:*/		return 0x821BCE94;
		  /* 821BCE94h */ case    1:  		/* stfd FR1, <#[R1 - 16]> */
		/* 821BCE94h case    1:*/		cpu::mem::store64f( regs, regs.FR1, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821BCE94h case    1:*/		return 0x821BCE98;
		  /* 821BCE98h */ case    2:  		/* ld R11, <#[R1 - 16]> */
		/* 821BCE98h case    2:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821BCE98h case    2:*/		return 0x821BCE9C;
		  /* 821BCE9Ch */ case    3:  		/* rldicl R10, R11, 0, 1 */
		/* 821BCE9Ch case    3:*/		cpu::op::rldicl<0,0,1>(regs,&regs.R10,regs.R11);
		/* 821BCE9Ch case    3:*/		return 0x821BCEA0;
		  /* 821BCEA0h */ case    4:  		/* cmpdi CR6, R10, 0 */
		/* 821BCEA0h case    4:*/		cpu::op::cmpdi<6>(regs,regs.R10,0x00000000);
		/* 821BCEA0h case    4:*/		return 0x821BCEA4;
		  /* 821BCEA4h */ case    5:  		/* bc 12, CR6_EQ, 28 */
		/* 821BCEA4h case    5:*/		if ( regs.CR[6].eq ) { return 0x821BCEC0;  }
		/* 821BCEA4h case    5:*/		return 0x821BCEA8;
		  /* 821BCEA8h */ case    6:  		/* li R12, 2047 */
		/* 821BCEA8h case    6:*/		cpu::op::li<0>(regs,&regs.R12,0x7FF);
		/* 821BCEA8h case    6:*/		return 0x821BCEAC;
		  /* 821BCEACh */ case    7:  		/* rldicr R12, R12, 52, 11 */
		/* 821BCEACh case    7:*/		cpu::op::rldicr<0,52,11>(regs,&regs.R12,regs.R12);
		/* 821BCEACh case    7:*/		return 0x821BCEB0;
		  /* 821BCEB0h */ case    8:  		/* and R11, R11, R12 */
		/* 821BCEB0h case    8:*/		cpu::op::and<0>(regs,&regs.R11,regs.R11,regs.R12);
		/* 821BCEB0h case    8:*/		return 0x821BCEB4;
		  /* 821BCEB4h */ case    9:  		/* cmpdi CR6, R11, 0 */
		/* 821BCEB4h case    9:*/		cpu::op::cmpdi<6>(regs,regs.R11,0x00000000);
		/* 821BCEB4h case    9:*/		return 0x821BCEB8;
		  /* 821BCEB8h */ case   10:  		/* li R11, 0 */
		/* 821BCEB8h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BCEB8h case   10:*/		return 0x821BCEBC;
		  /* 821BCEBCh */ case   11:  		/* bc 12, CR6_EQ, 8 */
		/* 821BCEBCh case   11:*/		if ( regs.CR[6].eq ) { return 0x821BCEC4;  }
		/* 821BCEBCh case   11:*/		return 0x821BCEC0;
	}
	return 0x821BCEC0;
} // Block from 821BCE90h-821BCEC0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821BCEC0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCEC0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCEC0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCEC0);
		  /* 821BCEC0h */ case    0:  		/* li R11, 1 */
		/* 821BCEC0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821BCEC0h case    0:*/		return 0x821BCEC4;
	}
	return 0x821BCEC4;
} // Block from 821BCEC0h-821BCEC4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BCEC4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCEC4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCEC4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCEC4);
		  /* 821BCEC4h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821BCEC4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821BCEC4h case    0:*/		return 0x821BCEC8;
		  /* 821BCEC8h */ case    1:  		/* bclr 4, CR0_EQ */
		/* 821BCEC8h case    1:*/		if ( !regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 821BCEC8h case    1:*/		return 0x821BCECC;
	}
	return 0x821BCECC;
} // Block from 821BCEC4h-821BCECCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BCECCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCECC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCECC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCECC);
		  /* 821BCECCh */ case    0:  		/* ld R11, <#[R1 + 16]> */
		/* 821BCECCh case    0:*/		cpu::mem::load64( regs, &regs.R11, (uint32)(regs.R1 + 0x00000010) );
		/* 821BCECCh case    0:*/		return 0x821BCED0;
		  /* 821BCED0h */ case    1:  		/* rldicr R11, R11, 0, 0 */
		/* 821BCED0h case    1:*/		cpu::op::rldicr<0,0,0>(regs,&regs.R11,regs.R11);
		/* 821BCED0h case    1:*/		return 0x821BCED4;
		  /* 821BCED4h */ case    2:  		/* std R11, <#[R1 + 16]> */
		/* 821BCED4h case    2:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000010) );
		/* 821BCED4h case    2:*/		return 0x821BCED8;
		  /* 821BCED8h */ case    3:  		/* lfd FR1, <#[R1 + 16]> */
		/* 821BCED8h case    3:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R1 + 0x00000010) );
		/* 821BCED8h case    3:*/		return 0x821BCEDC;
		  /* 821BCEDCh */ case    4:  		/* bclr 20, CR0_LT */
		/* 821BCEDCh case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BCEDCh case    4:*/		return 0x821BCEE0;
	}
	return 0x821BCEE0;
} // Block from 821BCECCh-821BCEE0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BCEE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCEE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCEE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCEE0);
		  /* 821BCEE0h */ case    0:  		/* mfspr R12, LR */
		/* 821BCEE0h case    0:*/		regs.R12 = regs.LR;
		/* 821BCEE0h case    0:*/		return 0x821BCEE4;
		  /* 821BCEE4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821BCEE4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821BCEE4h case    1:*/		return 0x821BCEE8;
		  /* 821BCEE8h */ case    2:  		/* stfd FR30, <#[R1 - 24]> */
		/* 821BCEE8h case    2:*/		cpu::mem::store64f( regs, regs.FR30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821BCEE8h case    2:*/		return 0x821BCEEC;
		  /* 821BCEECh */ case    3:  		/* stfd FR31, <#[R1 - 16]> */
		/* 821BCEECh case    3:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821BCEECh case    3:*/		return 0x821BCEF0;
		  /* 821BCEF0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 821BCEF0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821BCEF0h case    4:*/		return 0x821BCEF4;
		  /* 821BCEF4h */ case    5:  		/* addi R4, R1, 80 */
		/* 821BCEF4h case    5:*/		cpu::op::addi<0>(regs,&regs.R4,regs.R1,0x50);
		/* 821BCEF4h case    5:*/		return 0x821BCEF8;
		  /* 821BCEF8h */ case    6:  		/* fmr FR31, FR1 */
		/* 821BCEF8h case    6:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR1);
		/* 821BCEF8h case    6:*/		return 0x821BCEFC;
		  /* 821BCEFCh */ case    7:  		/* bl 705956 */
		/* 821BCEFCh case    7:*/		regs.LR = 0x821BCF00; return 0x822694A0;
		/* 821BCEFCh case    7:*/		return 0x821BCF00;
		  /* 821BCF00h */ case    8:  		/* lis R11, -32256 */
		/* 821BCF00h case    8:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 821BCF00h case    8:*/		return 0x821BCF04;
		  /* 821BCF04h */ case    9:  		/* lfd FR0, <#[R11 + 1808]> */
		/* 821BCF04h case    9:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000710) );
		/* 821BCF04h case    9:*/		return 0x821BCF08;
		  /* 821BCF08h */ case   10:  		/* fcmpu CR6, FR31, FR0 */
		/* 821BCF08h case   10:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR0);
		/* 821BCF08h case   10:*/		return 0x821BCF0C;
		  /* 821BCF0Ch */ case   11:  		/* lfd FR30, <#[R1 + 80]> */
		/* 821BCF0Ch case   11:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R1 + 0x00000050) );
		/* 821BCF0Ch case   11:*/		return 0x821BCF10;
		  /* 821BCF10h */ case   12:  		/* fmr FR1, FR30 */
		/* 821BCF10h case   12:*/		cpu::op::fmr<0>(regs,&regs.FR1,regs.FR30);
		/* 821BCF10h case   12:*/		return 0x821BCF14;
		  /* 821BCF14h */ case   13:  		/* bc 4, CR6_LT, 32 */
		/* 821BCF14h case   13:*/		if ( !regs.CR[6].lt ) { return 0x821BCF34;  }
		/* 821BCF14h case   13:*/		return 0x821BCF18;
		  /* 821BCF18h */ case   14:  		/* fcmpu CR6, FR31, FR30 */
		/* 821BCF18h case   14:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR30);
		/* 821BCF18h case   14:*/		return 0x821BCF1C;
		  /* 821BCF1Ch */ case   15:  		/* bc 12, CR6_EQ, 24 */
		/* 821BCF1Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x821BCF34;  }
		/* 821BCF1Ch case   15:*/		return 0x821BCF20;
		  /* 821BCF20h */ case   16:  		/* lis R11, -32256 */
		/* 821BCF20h case   16:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 821BCF20h case   16:*/		return 0x821BCF24;
		  /* 821BCF24h */ case   17:  		/* lfd FR1, <#[R11 + 1848]> */
		/* 821BCF24h case   17:*/		cpu::mem::load64f( regs, &regs.FR1, (uint32)(regs.R11 + 0x00000738) );
		/* 821BCF24h case   17:*/		return 0x821BCF28;
		  /* 821BCF28h */ case   18:  		/* bl -1200008 */
		/* 821BCF28h case   18:*/		regs.LR = 0x821BCF2C; return 0x82097FA0;
		/* 821BCF28h case   18:*/		return 0x821BCF2C;
		  /* 821BCF2Ch */ case   19:  		/* fadd FR1, FR1, FR30 */
		/* 821BCF2Ch case   19:*/		cpu::op::fadd<0>(regs,&regs.FR1,regs.FR1,regs.FR30);
		/* 821BCF2Ch case   19:*/		return 0x821BCF30;
		  /* 821BCF30h */ case   20:  		/* bl -160 */
		/* 821BCF30h case   20:*/		regs.LR = 0x821BCF34; return 0x821BCE90;
		/* 821BCF30h case   20:*/		return 0x821BCF34;
	}
	return 0x821BCF34;
} // Block from 821BCEE0h-821BCF34h (21 instructions)

//////////////////////////////////////////////////////
// Block at 821BCF34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCF34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCF34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCF34);
		  /* 821BCF34h */ case    0:  		/* addi R1, R1, 112 */
		/* 821BCF34h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821BCF34h case    0:*/		return 0x821BCF38;
		  /* 821BCF38h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 821BCF38h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821BCF38h case    1:*/		return 0x821BCF3C;
		  /* 821BCF3Ch */ case    2:  		/* mtspr LR, R12 */
		/* 821BCF3Ch case    2:*/		regs.LR = regs.R12;
		/* 821BCF3Ch case    2:*/		return 0x821BCF40;
		  /* 821BCF40h */ case    3:  		/* lfd FR30, <#[R1 - 24]> */
		/* 821BCF40h case    3:*/		cpu::mem::load64f( regs, &regs.FR30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821BCF40h case    3:*/		return 0x821BCF44;
		  /* 821BCF44h */ case    4:  		/* lfd FR31, <#[R1 - 16]> */
		/* 821BCF44h case    4:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821BCF44h case    4:*/		return 0x821BCF48;
		  /* 821BCF48h */ case    5:  		/* bclr 20, CR0_LT */
		/* 821BCF48h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BCF48h case    5:*/		return 0x821BCF4C;
	}
	return 0x821BCF4C;
} // Block from 821BCF34h-821BCF4Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BCF4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCF4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCF4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCF4C);
		  /* 821BCF4Ch */ case    0:  		/* nop */
		/* 821BCF4Ch case    0:*/		cpu::op::nop();
		/* 821BCF4Ch case    0:*/		return 0x821BCF50;
	}
	return 0x821BCF50;
} // Block from 821BCF4Ch-821BCF50h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BCF50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCF50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCF50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCF50);
		  /* 821BCF50h */ case    0:  		/* mfspr R12, LR */
		/* 821BCF50h case    0:*/		regs.R12 = regs.LR;
		/* 821BCF50h case    0:*/		return 0x821BCF54;
		  /* 821BCF54h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821BCF54h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821BCF54h case    1:*/		return 0x821BCF58;
		  /* 821BCF58h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 821BCF58h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 821BCF58h case    2:*/		return 0x821BCF5C;
		  /* 821BCF5Ch */ case    3:  		/* rlwinm R10, R3, 0, 0, 19 */
		/* 821BCF5Ch case    3:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R10,regs.R3);
		/* 821BCF5Ch case    3:*/		return 0x821BCF60;
		  /* 821BCF60h */ case    4:  		/* mr R11, R3 */
		/* 821BCF60h case    4:*/		regs.R11 = regs.R3;
		/* 821BCF60h case    4:*/		return 0x821BCF64;
		  /* 821BCF64h */ case    5:  		/* lwz R10, <#[R10]> */
		/* 821BCF64h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821BCF64h case    5:*/		return 0x821BCF68;
		  /* 821BCF68h */ case    6:  		/* lwz R3, <#[R10 + 148]> */
		/* 821BCF68h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R10 + 0x00000094) );
		/* 821BCF68h case    6:*/		return 0x821BCF6C;
		  /* 821BCF6Ch */ case    7:  		/* lwz R10, <#[R3 + 40]> */
		/* 821BCF6Ch case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000028) );
		/* 821BCF6Ch case    7:*/		return 0x821BCF70;
		  /* 821BCF70h */ case    8:  		/* nor R10, R10, R10 */
		/* 821BCF70h case    8:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 821BCF70h case    8:*/		return 0x821BCF74;
		  /* 821BCF74h */ case    9:  		/* rlwinm. R10, R10, 18, 31, 31 */
		/* 821BCF74h case    9:*/		cpu::op::rlwinm<1,18,31,31>(regs,&regs.R10,regs.R10);
		/* 821BCF74h case    9:*/		return 0x821BCF78;
		  /* 821BCF78h */ case   10:  		/* bc 4, CR0_EQ, 12 */
		/* 821BCF78h case   10:*/		if ( !regs.CR[0].eq ) { return 0x821BCF84;  }
		/* 821BCF78h case   10:*/		return 0x821BCF7C;
		  /* 821BCF7Ch */ case   11:  		/* li R10, 0 */
		/* 821BCF7Ch case   11:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821BCF7Ch case   11:*/		return 0x821BCF80;
		  /* 821BCF80h */ case   12:  		/* b 24 */
		/* 821BCF80h case   12:*/		return 0x821BCF98;
		/* 821BCF80h case   12:*/		return 0x821BCF84;
	}
	return 0x821BCF84;
} // Block from 821BCF50h-821BCF84h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821BCF84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCF84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCF84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCF84);
		  /* 821BCF84h */ case    0:  		/* lwz R10, <#[R11 + 20]> */
		/* 821BCF84h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000014) );
		/* 821BCF84h case    0:*/		return 0x821BCF88;
		  /* 821BCF88h */ case    1:  		/* rlwinm R9, R4, 1, 0, 30 */
		/* 821BCF88h case    1:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R9,regs.R4);
		/* 821BCF88h case    1:*/		return 0x821BCF8C;
		  /* 821BCF8Ch */ case    2:  		/* rlwinm R10, R10, 30, 24, 31 */
		/* 821BCF8Ch case    2:*/		cpu::op::rlwinm<0,30,24,31>(regs,&regs.R10,regs.R10);
		/* 821BCF8Ch case    2:*/		return 0x821BCF90;
		  /* 821BCF90h */ case    3:  		/* srw R10, R10, R9 */
		/* 821BCF90h case    3:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 821BCF90h case    3:*/		return 0x821BCF94;
		  /* 821BCF94h */ case    4:  		/* rlwinm R10, R10, 0, 30, 31 */
		/* 821BCF94h case    4:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R10,regs.R10);
		/* 821BCF94h case    4:*/		return 0x821BCF98;
	}
	return 0x821BCF98;
} // Block from 821BCF84h-821BCF98h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BCF98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCF98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCF98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCF98);
		  /* 821BCF98h */ case    0:  		/* cmplwi CR6, R10, 1 */
		/* 821BCF98h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000001);
		/* 821BCF98h case    0:*/		return 0x821BCF9C;
		  /* 821BCF9Ch */ case    1:  		/* bc 12, CR6_LT, 76 */
		/* 821BCF9Ch case    1:*/		if ( regs.CR[6].lt ) { return 0x821BCFE8;  }
		/* 821BCF9Ch case    1:*/		return 0x821BCFA0;
		  /* 821BCFA0h */ case    2:  		/* bc 12, CR6_EQ, 44 */
		/* 821BCFA0h case    2:*/		if ( regs.CR[6].eq ) { return 0x821BCFCC;  }
		/* 821BCFA0h case    2:*/		return 0x821BCFA4;
		  /* 821BCFA4h */ case    3:  		/* cmplwi CR6, R10, 3 */
		/* 821BCFA4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000003);
		/* 821BCFA4h case    3:*/		return 0x821BCFA8;
		  /* 821BCFA8h */ case    4:  		/* bc 12, CR6_LT, 12 */
		/* 821BCFA8h case    4:*/		if ( regs.CR[6].lt ) { return 0x821BCFB4;  }
		/* 821BCFA8h case    4:*/		return 0x821BCFAC;
		  /* 821BCFACh */ case    5:  		/* li R4, 4800 */
		/* 821BCFACh case    5:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 821BCFACh case    5:*/		return 0x821BCFB0;
		  /* 821BCFB0h */ case    6:  		/* bl -438600 */
		/* 821BCFB0h case    6:*/		regs.LR = 0x821BCFB4; return 0x82151E68;
		/* 821BCFB0h case    6:*/		return 0x821BCFB4;
	}
	return 0x821BCFB4;
} // Block from 821BCF98h-821BCFB4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BCFB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCFB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCFB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCFB4);
		  /* 821BCFB4h */ case    0:  		/* addi R10, R4, 11 */
		/* 821BCFB4h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0xB);
		/* 821BCFB4h case    0:*/		return 0x821BCFB8;
		  /* 821BCFB8h */ case    1:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821BCFB8h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821BCFB8h case    1:*/		return 0x821BCFBC;
		  /* 821BCFBCh */ case    2:  		/* lwzx R11, <#[R10 + R11]> */
		/* 821BCFBCh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821BCFBCh case    2:*/		return 0x821BCFC0;
		  /* 821BCFC0h */ case    3:  		/* std R11, <#[R1 + 80]> */
		/* 821BCFC0h case    3:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 821BCFC0h case    3:*/		return 0x821BCFC4;
		  /* 821BCFC4h */ case    4:  		/* lfd FR0, <#[R1 + 80]> */
		/* 821BCFC4h case    4:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 821BCFC4h case    4:*/		return 0x821BCFC8;
		  /* 821BCFC8h */ case    5:  		/* b 24 */
		/* 821BCFC8h case    5:*/		return 0x821BCFE0;
		/* 821BCFC8h case    5:*/		return 0x821BCFCC;
	}
	return 0x821BCFCC;
} // Block from 821BCFB4h-821BCFCCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BCFCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCFCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCFCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCFCC);
		  /* 821BCFCCh */ case    0:  		/* addi R10, R4, 11 */
		/* 821BCFCCh case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0xB);
		/* 821BCFCCh case    0:*/		return 0x821BCFD0;
		  /* 821BCFD0h */ case    1:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821BCFD0h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821BCFD0h case    1:*/		return 0x821BCFD4;
		  /* 821BCFD4h */ case    2:  		/* lwax R11, <#[R10 + R11]> */
		/* 821BCFD4h case    2:*/		cpu::mem::load32a( regs, &regs.R11, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821BCFD4h case    2:*/		return 0x821BCFD8;
		  /* 821BCFD8h */ case    3:  		/* std R11, <#[R1 + 80]> */
		/* 821BCFD8h case    3:*/		cpu::mem::store64( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 821BCFD8h case    3:*/		return 0x821BCFDC;
		  /* 821BCFDCh */ case    4:  		/* lfd FR0, <#[R1 + 80]> */
		/* 821BCFDCh case    4:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R1 + 0x00000050) );
		/* 821BCFDCh case    4:*/		return 0x821BCFE0;
	}
	return 0x821BCFE0;
} // Block from 821BCFCCh-821BCFE0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BCFE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCFE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCFE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCFE0);
		  /* 821BCFE0h */ case    0:  		/* fcfid FR1, FR0 */
		/* 821BCFE0h case    0:*/		cpu::op::fcfid<0>(regs,&regs.FR1,regs.FR0);
		/* 821BCFE0h case    0:*/		return 0x821BCFE4;
		  /* 821BCFE4h */ case    1:  		/* b 16 */
		/* 821BCFE4h case    1:*/		return 0x821BCFF4;
		/* 821BCFE4h case    1:*/		return 0x821BCFE8;
	}
	return 0x821BCFE8;
} // Block from 821BCFE0h-821BCFE8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BCFE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCFE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCFE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCFE8);
		  /* 821BCFE8h */ case    0:  		/* addi R10, R4, 11 */
		/* 821BCFE8h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0xB);
		/* 821BCFE8h case    0:*/		return 0x821BCFEC;
		  /* 821BCFECh */ case    1:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821BCFECh case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821BCFECh case    1:*/		return 0x821BCFF0;
		  /* 821BCFF0h */ case    2:  		/* lfsx FR1, <#[R10 + R11]> */
		/* 821BCFF0h case    2:*/		cpu::mem::load32f( regs, &regs.FR1, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821BCFF0h case    2:*/		return 0x821BCFF4;
	}
	return 0x821BCFF4;
} // Block from 821BCFE8h-821BCFF4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BCFF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BCFF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BCFF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BCFF4);
		  /* 821BCFF4h */ case    0:  		/* addi R1, R1, 96 */
		/* 821BCFF4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 821BCFF4h case    0:*/		return 0x821BCFF8;
		  /* 821BCFF8h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 821BCFF8h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821BCFF8h case    1:*/		return 0x821BCFFC;
		  /* 821BCFFCh */ case    2:  		/* mtspr LR, R12 */
		/* 821BCFFCh case    2:*/		regs.LR = regs.R12;
		/* 821BCFFCh case    2:*/		return 0x821BD000;
		  /* 821BD000h */ case    3:  		/* bclr 20, CR0_LT */
		/* 821BD000h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BD000h case    3:*/		return 0x821BD004;
	}
	return 0x821BD004;
} // Block from 821BCFF4h-821BD004h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BD004h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD004( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD004) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD004);
		  /* 821BD004h */ case    0:  		/* nop */
		/* 821BD004h case    0:*/		cpu::op::nop();
		/* 821BD004h case    0:*/		return 0x821BD008;
		  /* 821BD008h */ case    1:  		/* lwz R11, <#[R3 + 16]> */
		/* 821BD008h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 821BD008h case    1:*/		return 0x821BD00C;
		  /* 821BD00Ch */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 821BD00Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BD00Ch case    2:*/		return 0x821BD010;
		  /* 821BD010h */ case    3:  		/* bclr 12, CR6_EQ */
		/* 821BD010h case    3:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 821BD010h case    3:*/		return 0x821BD014;
	}
	return 0x821BD014;
} // Block from 821BD004h-821BD014h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BD014h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD014( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD014) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD014);
		  /* 821BD014h */ case    0:  		/* lwz R10, <#[R11]> */
		/* 821BD014h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821BD014h case    0:*/		return 0x821BD018;
		  /* 821BD018h */ case    1:  		/* cmpwi CR6, R10, 1 */
		/* 821BD018h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000001);
		/* 821BD018h case    1:*/		return 0x821BD01C;
		  /* 821BD01Ch */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 821BD01Ch case    2:*/		if ( regs.CR[6].eq ) { return 0x821BD02C;  }
		/* 821BD01Ch case    2:*/		return 0x821BD020;
		  /* 821BD020h */ case    3:  		/* lwz R11, <#[R11 + 4]> */
		/* 821BD020h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821BD020h case    3:*/		return 0x821BD024;
		  /* 821BD024h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 821BD024h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BD024h case    4:*/		return 0x821BD028;
		  /* 821BD028h */ case    5:  		/* bc 4, CR6_EQ, -20 */
		/* 821BD028h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821BD014;  }
		/* 821BD028h case    5:*/		return 0x821BD02C;
	}
	return 0x821BD02C;
} // Block from 821BD014h-821BD02Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BD02Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD02C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD02C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD02C);
		  /* 821BD02Ch */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 821BD02Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BD02Ch case    0:*/		return 0x821BD030;
		  /* 821BD030h */ case    1:  		/* bclr 12, CR6_EQ */
		/* 821BD030h case    1:*/		if ( regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 821BD030h case    1:*/		return 0x821BD034;
	}
	return 0x821BD034;
} // Block from 821BD02Ch-821BD034h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BD034h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD034( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD034) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD034);
		  /* 821BD034h */ case    0:  		/* lis R10, -128 */
		/* 821BD034h case    0:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFFFF80);
		/* 821BD034h case    0:*/		return 0x821BD038;
		  /* 821BD038h */ case    1:  		/* lis R8, 32640 */
		/* 821BD038h case    1:*/		cpu::op::lis<0>(regs,&regs.R8,0x7F80);
		/* 821BD038h case    1:*/		return 0x821BD03C;
		  /* 821BD03Ch */ case    2:  		/* stw R10, <#[R1 - 16]> */
		/* 821BD03Ch case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821BD03Ch case    2:*/		return 0x821BD040;
		  /* 821BD040h */ case    3:  		/* lfs FR0, <#[R1 - 16]> */
		/* 821BD040h case    3:*/		cpu::mem::load32f( regs, &regs.FR0, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821BD040h case    3:*/		return 0x821BD044;
		  /* 821BD044h */ case    4:  		/* stw R8, <#[R1 - 16]> */
		/* 821BD044h case    4:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821BD044h case    4:*/		return 0x821BD048;
		  /* 821BD048h */ case    5:  		/* lfs FR13, <#[R1 - 16]> */
		/* 821BD048h case    5:*/		cpu::mem::load32f( regs, &regs.FR13, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821BD048h case    5:*/		return 0x821BD04C;
		  /* 821BD04Ch */ case    6:  		/* addi R9, R4, 1 */
		/* 821BD04Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R4,0x1);
		/* 821BD04Ch case    6:*/		return 0x821BD050;
		  /* 821BD050h */ case    7:  		/* addi R10, R4, 5 */
		/* 821BD050h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x5);
		/* 821BD050h case    7:*/		return 0x821BD054;
		  /* 821BD054h */ case    8:  		/* rlwinm R9, R9, 3, 0, 28 */
		/* 821BD054h case    8:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R9,regs.R9);
		/* 821BD054h case    8:*/		return 0x821BD058;
		  /* 821BD058h */ case    9:  		/* rlwinm R10, R10, 3, 0, 28 */
		/* 821BD058h case    9:*/		cpu::op::rlwinm<0,3,0,28>(regs,&regs.R10,regs.R10);
		/* 821BD058h case    9:*/		return 0x821BD05C;
		  /* 821BD05Ch */ case   10:  		/* stfdx FR0, <#[R9 + R11]> */
		/* 821BD05Ch case   10:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R9 + regs.R11 + 0x00000000) );
		/* 821BD05Ch case   10:*/		return 0x821BD060;
		  /* 821BD060h */ case   11:  		/* stfdx FR13, <#[R10 + R11]> */
		/* 821BD060h case   11:*/		cpu::mem::store64f( regs, regs.FR13, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821BD060h case   11:*/		return 0x821BD064;
		  /* 821BD064h */ case   12:  		/* bclr 20, CR0_LT */
		/* 821BD064h case   12:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BD064h case   12:*/		return 0x821BD068;
	}
	return 0x821BD068;
} // Block from 821BD034h-821BD068h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821BD068h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD068( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD068) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD068);
		  /* 821BD068h */ case    0:  		/* lhz R11, <#[R3 + 14]> */
		/* 821BD068h case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000E) );
		/* 821BD068h case    0:*/		return 0x821BD06C;
		  /* 821BD06Ch */ case    1:  		/* rlwinm R10, R4, 2, 16, 29 */
		/* 821BD06Ch case    1:*/		cpu::op::rlwinm<0,2,16,29>(regs,&regs.R10,regs.R4);
		/* 821BD06Ch case    1:*/		return 0x821BD070;
		  /* 821BD070h */ case    2:  		/* srw R11, R11, R10 */
		/* 821BD070h case    2:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821BD070h case    2:*/		return 0x821BD074;
		  /* 821BD074h */ case    3:  		/* rlwinm R3, R11, 0, 28, 31 */
		/* 821BD074h case    3:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R3,regs.R11);
		/* 821BD074h case    3:*/		return 0x821BD078;
		  /* 821BD078h */ case    4:  		/* bclr 20, CR0_LT */
		/* 821BD078h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BD078h case    4:*/		return 0x821BD07C;
	}
	return 0x821BD07C;
} // Block from 821BD068h-821BD07Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BD07Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD07C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD07C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD07C);
		  /* 821BD07Ch */ case    0:  		/* nop */
		/* 821BD07Ch case    0:*/		cpu::op::nop();
		/* 821BD07Ch case    0:*/		return 0x821BD080;
	}
	return 0x821BD080;
} // Block from 821BD07Ch-821BD080h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BD080h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD080( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD080) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD080);
		  /* 821BD080h */ case    0:  		/* rlwinm R8, R4, 2, 0, 29 */
		/* 821BD080h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R4);
		/* 821BD080h case    0:*/		return 0x821BD084;
		  /* 821BD084h */ case    1:  		/* lwz R10, <#[R3 + 12]> */
		/* 821BD084h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 821BD084h case    1:*/		return 0x821BD088;
		  /* 821BD088h */ case    2:  		/* mr R11, R3 */
		/* 821BD088h case    2:*/		regs.R11 = regs.R3;
		/* 821BD088h case    2:*/		return 0x821BD08C;
		  /* 821BD08Ch */ case    3:  		/* slw R9, R5, R8 */
		/* 821BD08Ch case    3:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R5,regs.R8);
		/* 821BD08Ch case    3:*/		return 0x821BD090;
		  /* 821BD090h */ case    4:  		/* and R7, R10, R9 */
		/* 821BD090h case    4:*/		cpu::op::and<0>(regs,&regs.R7,regs.R10,regs.R9);
		/* 821BD090h case    4:*/		return 0x821BD094;
		  /* 821BD094h */ case    5:  		/* slw R8, R6, R8 */
		/* 821BD094h case    5:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R6,regs.R8);
		/* 821BD094h case    5:*/		return 0x821BD098;
		  /* 821BD098h */ case    6:  		/* rlwinm R7, R7, 0, 16, 31 */
		/* 821BD098h case    6:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R7,regs.R7);
		/* 821BD098h case    6:*/		return 0x821BD09C;
		  /* 821BD09Ch */ case    7:  		/* cmplw CR6, R7, R8 */
		/* 821BD09Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R8);
		/* 821BD09Ch case    7:*/		return 0x821BD0A0;
		  /* 821BD0A0h */ case    8:  		/* bc 4, CR6_EQ, 12 */
		/* 821BD0A0h case    8:*/		if ( !regs.CR[6].eq ) { return 0x821BD0AC;  }
		/* 821BD0A0h case    8:*/		return 0x821BD0A4;
		  /* 821BD0A4h */ case    9:  		/* li R3, 0 */
		/* 821BD0A4h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821BD0A4h case    9:*/		return 0x821BD0A8;
		  /* 821BD0A8h */ case   10:  		/* bclr 20, CR0_LT */
		/* 821BD0A8h case   10:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BD0A8h case   10:*/		return 0x821BD0AC;
	}
	return 0x821BD0AC;
} // Block from 821BD080h-821BD0ACh (11 instructions)

//////////////////////////////////////////////////////
// Block at 821BD0ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD0AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD0AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD0AC);
		  /* 821BD0ACh */ case    0:  		/* andc R10, R10, R9 */
		/* 821BD0ACh case    0:*/		cpu::op::andc<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 821BD0ACh case    0:*/		return 0x821BD0B0;
		  /* 821BD0B0h */ case    1:  		/* li R3, 1 */
		/* 821BD0B0h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821BD0B0h case    1:*/		return 0x821BD0B4;
		  /* 821BD0B4h */ case    2:  		/* or R10, R10, R8 */
		/* 821BD0B4h case    2:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 821BD0B4h case    2:*/		return 0x821BD0B8;
		  /* 821BD0B8h */ case    3:  		/* sth R10, <#[R11 + 14]> */
		/* 821BD0B8h case    3:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R11 + 0x0000000E) );
		/* 821BD0B8h case    3:*/		return 0x821BD0BC;
		  /* 821BD0BCh */ case    4:  		/* bclr 20, CR0_LT */
		/* 821BD0BCh case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BD0BCh case    4:*/		return 0x821BD0C0;
	}
	return 0x821BD0C0;
} // Block from 821BD0ACh-821BD0C0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BD0C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD0C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD0C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD0C0);
		  /* 821BD0C0h */ case    0:  		/* rlwinm R8, R4, 2, 0, 29 */
		/* 821BD0C0h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R4);
		/* 821BD0C0h case    0:*/		return 0x821BD0C4;
		  /* 821BD0C4h */ case    1:  		/* lwz R10, <#[R3 + 12]> */
		/* 821BD0C4h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 821BD0C4h case    1:*/		return 0x821BD0C8;
		  /* 821BD0C8h */ case    2:  		/* li R7, 15 */
		/* 821BD0C8h case    2:*/		cpu::op::li<0>(regs,&regs.R7,0xF);
		/* 821BD0C8h case    2:*/		return 0x821BD0CC;
		  /* 821BD0CCh */ case    3:  		/* slw R9, R5, R8 */
		/* 821BD0CCh case    3:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R5,regs.R8);
		/* 821BD0CCh case    3:*/		return 0x821BD0D0;
		  /* 821BD0D0h */ case    4:  		/* slw R8, R7, R8 */
		/* 821BD0D0h case    4:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R7,regs.R8);
		/* 821BD0D0h case    4:*/		return 0x821BD0D4;
		  /* 821BD0D4h */ case    5:  		/* and R7, R10, R8 */
		/* 821BD0D4h case    5:*/		cpu::op::and<0>(regs,&regs.R7,regs.R10,regs.R8);
		/* 821BD0D4h case    5:*/		return 0x821BD0D8;
		  /* 821BD0D8h */ case    6:  		/* mr R11, R3 */
		/* 821BD0D8h case    6:*/		regs.R11 = regs.R3;
		/* 821BD0D8h case    6:*/		return 0x821BD0DC;
		  /* 821BD0DCh */ case    7:  		/* rlwinm R7, R7, 0, 16, 31 */
		/* 821BD0DCh case    7:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R7,regs.R7);
		/* 821BD0DCh case    7:*/		return 0x821BD0E0;
		  /* 821BD0E0h */ case    8:  		/* cmplw CR6, R7, R9 */
		/* 821BD0E0h case    8:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R9);
		/* 821BD0E0h case    8:*/		return 0x821BD0E4;
		  /* 821BD0E4h */ case    9:  		/* bc 4, CR6_EQ, 12 */
		/* 821BD0E4h case    9:*/		if ( !regs.CR[6].eq ) { return 0x821BD0F0;  }
		/* 821BD0E4h case    9:*/		return 0x821BD0E8;
		  /* 821BD0E8h */ case   10:  		/* li R3, 0 */
		/* 821BD0E8h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821BD0E8h case   10:*/		return 0x821BD0EC;
		  /* 821BD0ECh */ case   11:  		/* bclr 20, CR0_LT */
		/* 821BD0ECh case   11:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BD0ECh case   11:*/		return 0x821BD0F0;
	}
	return 0x821BD0F0;
} // Block from 821BD0C0h-821BD0F0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821BD0F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD0F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD0F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD0F0);
		  /* 821BD0F0h */ case    0:  		/* andc R10, R10, R8 */
		/* 821BD0F0h case    0:*/		cpu::op::andc<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 821BD0F0h case    0:*/		return 0x821BD0F4;
		  /* 821BD0F4h */ case    1:  		/* li R3, 1 */
		/* 821BD0F4h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821BD0F4h case    1:*/		return 0x821BD0F8;
		  /* 821BD0F8h */ case    2:  		/* or R10, R10, R9 */
		/* 821BD0F8h case    2:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 821BD0F8h case    2:*/		return 0x821BD0FC;
		  /* 821BD0FCh */ case    3:  		/* sth R10, <#[R11 + 14]> */
		/* 821BD0FCh case    3:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R11 + 0x0000000E) );
		/* 821BD0FCh case    3:*/		return 0x821BD100;
		  /* 821BD100h */ case    4:  		/* bclr 20, CR0_LT */
		/* 821BD100h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BD100h case    4:*/		return 0x821BD104;
	}
	return 0x821BD104;
} // Block from 821BD0F0h-821BD104h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BD104h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD104( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD104) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD104);
		  /* 821BD104h */ case    0:  		/* nop */
		/* 821BD104h case    0:*/		cpu::op::nop();
		/* 821BD104h case    0:*/		return 0x821BD108;
	}
	return 0x821BD108;
} // Block from 821BD104h-821BD108h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BD108h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD108( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD108) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD108);
		  /* 821BD108h */ case    0:  		/* rlwinm R11, R4, 2, 0, 29 */
		/* 821BD108h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R4);
		/* 821BD108h case    0:*/		return 0x821BD10C;
		  /* 821BD10Ch */ case    1:  		/* lwz R9, <#[R3 + 12]> */
		/* 821BD10Ch case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x0000000C) );
		/* 821BD10Ch case    1:*/		return 0x821BD110;
		  /* 821BD110h */ case    2:  		/* mr R10, R3 */
		/* 821BD110h case    2:*/		regs.R10 = regs.R3;
		/* 821BD110h case    2:*/		return 0x821BD114;
		  /* 821BD114h */ case    3:  		/* slw R11, R5, R11 */
		/* 821BD114h case    3:*/		cpu::op::slw<0>(regs,&regs.R11,regs.R5,regs.R11);
		/* 821BD114h case    3:*/		return 0x821BD118;
		  /* 821BD118h */ case    4:  		/* and R8, R9, R11 */
		/* 821BD118h case    4:*/		cpu::op::and<0>(regs,&regs.R8,regs.R9,regs.R11);
		/* 821BD118h case    4:*/		return 0x821BD11C;
		  /* 821BD11Ch */ case    5:  		/* rlwinm R8, R8, 0, 16, 31 */
		/* 821BD11Ch case    5:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R8,regs.R8);
		/* 821BD11Ch case    5:*/		return 0x821BD120;
		  /* 821BD120h */ case    6:  		/* cmplw CR6, R8, R11 */
		/* 821BD120h case    6:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R11);
		/* 821BD120h case    6:*/		return 0x821BD124;
		  /* 821BD124h */ case    7:  		/* bc 4, CR6_EQ, 12 */
		/* 821BD124h case    7:*/		if ( !regs.CR[6].eq ) { return 0x821BD130;  }
		/* 821BD124h case    7:*/		return 0x821BD128;
		  /* 821BD128h */ case    8:  		/* li R3, 0 */
		/* 821BD128h case    8:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821BD128h case    8:*/		return 0x821BD12C;
		  /* 821BD12Ch */ case    9:  		/* bclr 20, CR0_LT */
		/* 821BD12Ch case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BD12Ch case    9:*/		return 0x821BD130;
	}
	return 0x821BD130;
} // Block from 821BD108h-821BD130h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821BD130h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD130( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD130) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD130);
		  /* 821BD130h */ case    0:  		/* or R11, R9, R11 */
		/* 821BD130h case    0:*/		cpu::op::or<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 821BD130h case    0:*/		return 0x821BD134;
		  /* 821BD134h */ case    1:  		/* li R3, 1 */
		/* 821BD134h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821BD134h case    1:*/		return 0x821BD138;
		  /* 821BD138h */ case    2:  		/* sth R11, <#[R10 + 14]> */
		/* 821BD138h case    2:*/		cpu::mem::store16( regs, regs.R11, (uint32)(regs.R10 + 0x0000000E) );
		/* 821BD138h case    2:*/		return 0x821BD13C;
		  /* 821BD13Ch */ case    3:  		/* bclr 20, CR0_LT */
		/* 821BD13Ch case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BD13Ch case    3:*/		return 0x821BD140;
	}
	return 0x821BD140;
} // Block from 821BD130h-821BD140h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BD140h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD140( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD140) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD140);
		  /* 821BD140h */ case    0:  		/* rlwinm R8, R4, 2, 0, 29 */
		/* 821BD140h case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R8,regs.R4);
		/* 821BD140h case    0:*/		return 0x821BD144;
		  /* 821BD144h */ case    1:  		/* lwz R10, <#[R3 + 12]> */
		/* 821BD144h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x0000000C) );
		/* 821BD144h case    1:*/		return 0x821BD148;
		  /* 821BD148h */ case    2:  		/* li R9, 3 */
		/* 821BD148h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x3);
		/* 821BD148h case    2:*/		return 0x821BD14C;
		  /* 821BD14Ch */ case    3:  		/* li R7, 2 */
		/* 821BD14Ch case    3:*/		cpu::op::li<0>(regs,&regs.R7,0x2);
		/* 821BD14Ch case    3:*/		return 0x821BD150;
		  /* 821BD150h */ case    4:  		/* slw R9, R9, R8 */
		/* 821BD150h case    4:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R9,regs.R8);
		/* 821BD150h case    4:*/		return 0x821BD154;
		  /* 821BD154h */ case    5:  		/* and R6, R10, R9 */
		/* 821BD154h case    5:*/		cpu::op::and<0>(regs,&regs.R6,regs.R10,regs.R9);
		/* 821BD154h case    5:*/		return 0x821BD158;
		  /* 821BD158h */ case    6:  		/* slw R8, R7, R8 */
		/* 821BD158h case    6:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R7,regs.R8);
		/* 821BD158h case    6:*/		return 0x821BD15C;
		  /* 821BD15Ch */ case    7:  		/* rlwinm R7, R6, 0, 16, 31 */
		/* 821BD15Ch case    7:*/		cpu::op::rlwinm<0,0,16,31>(regs,&regs.R7,regs.R6);
		/* 821BD15Ch case    7:*/		return 0x821BD160;
		  /* 821BD160h */ case    8:  		/* mr R11, R3 */
		/* 821BD160h case    8:*/		regs.R11 = regs.R3;
		/* 821BD160h case    8:*/		return 0x821BD164;
		  /* 821BD164h */ case    9:  		/* cmplw CR6, R7, R8 */
		/* 821BD164h case    9:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R8);
		/* 821BD164h case    9:*/		return 0x821BD168;
		  /* 821BD168h */ case   10:  		/* bc 4, CR6_EQ, 12 */
		/* 821BD168h case   10:*/		if ( !regs.CR[6].eq ) { return 0x821BD174;  }
		/* 821BD168h case   10:*/		return 0x821BD16C;
		  /* 821BD16Ch */ case   11:  		/* li R3, 0 */
		/* 821BD16Ch case   11:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821BD16Ch case   11:*/		return 0x821BD170;
		  /* 821BD170h */ case   12:  		/* bclr 20, CR0_LT */
		/* 821BD170h case   12:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BD170h case   12:*/		return 0x821BD174;
	}
	return 0x821BD174;
} // Block from 821BD140h-821BD174h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821BD174h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD174( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD174) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD174);
		  /* 821BD174h */ case    0:  		/* andc R10, R10, R9 */
		/* 821BD174h case    0:*/		cpu::op::andc<0>(regs,&regs.R10,regs.R10,regs.R9);
		/* 821BD174h case    0:*/		return 0x821BD178;
		  /* 821BD178h */ case    1:  		/* li R3, 1 */
		/* 821BD178h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821BD178h case    1:*/		return 0x821BD17C;
		  /* 821BD17Ch */ case    2:  		/* or R10, R10, R8 */
		/* 821BD17Ch case    2:*/		cpu::op::or<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 821BD17Ch case    2:*/		return 0x821BD180;
		  /* 821BD180h */ case    3:  		/* sth R10, <#[R11 + 14]> */
		/* 821BD180h case    3:*/		cpu::mem::store16( regs, regs.R10, (uint32)(regs.R11 + 0x0000000E) );
		/* 821BD180h case    3:*/		return 0x821BD184;
		  /* 821BD184h */ case    4:  		/* bclr 20, CR0_LT */
		/* 821BD184h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BD184h case    4:*/		return 0x821BD188;
	}
	return 0x821BD188;
} // Block from 821BD174h-821BD188h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BD188h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD188( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD188) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD188);
		  /* 821BD188h */ case    0:  		/* mfspr R12, LR */
		/* 821BD188h case    0:*/		regs.R12 = regs.LR;
		/* 821BD188h case    0:*/		return 0x821BD18C;
		  /* 821BD18Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821BD18Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821BD18Ch case    1:*/		return 0x821BD190;
		  /* 821BD190h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 821BD190h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821BD190h case    2:*/		return 0x821BD194;
		  /* 821BD194h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 821BD194h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821BD194h case    3:*/		return 0x821BD198;
		  /* 821BD198h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 821BD198h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821BD198h case    4:*/		return 0x821BD19C;
		  /* 821BD19Ch */ case    5:  		/* mr R11, R3 */
		/* 821BD19Ch case    5:*/		regs.R11 = regs.R3;
		/* 821BD19Ch case    5:*/		return 0x821BD1A0;
		  /* 821BD1A0h */ case    6:  		/* lwz R3, <#[R3 + 12]> */
		/* 821BD1A0h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x0000000C) );
		/* 821BD1A0h case    6:*/		return 0x821BD1A4;
		  /* 821BD1A4h */ case    7:  		/* rlwinm R10, R4, 1, 0, 30 */
		/* 821BD1A4h case    7:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R4);
		/* 821BD1A4h case    7:*/		return 0x821BD1A8;
		  /* 821BD1A8h */ case    8:  		/* rlwinm R9, R3, 0, 0, 19 */
		/* 821BD1A8h case    8:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R9,regs.R3);
		/* 821BD1A8h case    8:*/		return 0x821BD1AC;
		  /* 821BD1ACh */ case    9:  		/* lwz R11, <#[R11]> */
		/* 821BD1ACh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821BD1ACh case    9:*/		return 0x821BD1B0;
		  /* 821BD1B0h */ case   10:  		/* rlwinm R8, R11, 27, 24, 31 */
		/* 821BD1B0h case   10:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R8,regs.R11);
		/* 821BD1B0h case   10:*/		return 0x821BD1B4;
		  /* 821BD1B4h */ case   11:  		/* rlwinm R30, R11, 0, 27, 31 */
		/* 821BD1B4h case   11:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R30,regs.R11);
		/* 821BD1B4h case   11:*/		return 0x821BD1B8;
		  /* 821BD1B8h */ case   12:  		/* srw R11, R8, R10 */
		/* 821BD1B8h case   12:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R8,regs.R10);
		/* 821BD1B8h case   12:*/		return 0x821BD1BC;
		  /* 821BD1BCh */ case   13:  		/* lwz R10, <#[R9]> */
		/* 821BD1BCh case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000000) );
		/* 821BD1BCh case   13:*/		return 0x821BD1C0;
		  /* 821BD1C0h */ case   14:  		/* rlwinm R4, R11, 0, 30, 31 */
		/* 821BD1C0h case   14:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R4,regs.R11);
		/* 821BD1C0h case   14:*/		return 0x821BD1C4;
		  /* 821BD1C4h */ case   15:  		/* lwz R11, <#[R10 + 148]> */
		/* 821BD1C4h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000094) );
		/* 821BD1C4h case   15:*/		return 0x821BD1C8;
	}
	return 0x821BD1C8;
} // Block from 821BD188h-821BD1C8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821BD1C8h
// Function '?UpdateOutputComponentCount@Compiler@D3DXShader@@AAAPAVInstruction@2@PAV32@PAV?$Stack@PAVInstruction@D3DXShader@@$1?AllocInContext@CompilerHeap@2@SAPAXPAXK@Z$1?FreeInContext@42@SAX00K@Z@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD1C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD1C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD1C8);
		  /* 821BD1C8h */ case    0:  		/* lwz R11, <#[R11 + 40]> */
		/* 821BD1C8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 821BD1C8h case    0:*/		return 0x821BD1CC;
		  /* 821BD1CCh */ case    1:  		/* nor R11, R11, R11 */
		/* 821BD1CCh case    1:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 821BD1CCh case    1:*/		return 0x821BD1D0;
		  /* 821BD1D0h */ case    2:  		/* rlwinm. R11, R11, 18, 31, 31 */
		/* 821BD1D0h case    2:*/		cpu::op::rlwinm<1,18,31,31>(regs,&regs.R11,regs.R11);
		/* 821BD1D0h case    2:*/		return 0x821BD1D4;
		  /* 821BD1D4h */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 821BD1D4h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BD1E0;  }
		/* 821BD1D4h case    3:*/		return 0x821BD1D8;
		  /* 821BD1D8h */ case    4:  		/* li R31, 0 */
		/* 821BD1D8h case    4:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 821BD1D8h case    4:*/		return 0x821BD1DC;
		  /* 821BD1DCh */ case    5:  		/* b 24 */
		/* 821BD1DCh case    5:*/		return 0x821BD1F4;
		/* 821BD1DCh case    5:*/		return 0x821BD1E0;
	}
	return 0x821BD1E0;
} // Block from 821BD1C8h-821BD1E0h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BD1E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD1E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD1E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD1E0);
		  /* 821BD1E0h */ case    0:  		/* lwz R11, <#[R3 + 20]> */
		/* 821BD1E0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000014) );
		/* 821BD1E0h case    0:*/		return 0x821BD1E4;
		  /* 821BD1E4h */ case    1:  		/* rlwinm R10, R4, 1, 0, 30 */
		/* 821BD1E4h case    1:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R4);
		/* 821BD1E4h case    1:*/		return 0x821BD1E8;
		  /* 821BD1E8h */ case    2:  		/* rlwinm R11, R11, 30, 24, 31 */
		/* 821BD1E8h case    2:*/		cpu::op::rlwinm<0,30,24,31>(regs,&regs.R11,regs.R11);
		/* 821BD1E8h case    2:*/		return 0x821BD1EC;
		  /* 821BD1ECh */ case    3:  		/* srw R11, R11, R10 */
		/* 821BD1ECh case    3:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821BD1ECh case    3:*/		return 0x821BD1F0;
		  /* 821BD1F0h */ case    4:  		/* rlwinm R31, R11, 0, 30, 31 */
		/* 821BD1F0h case    4:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R31,regs.R11);
		/* 821BD1F0h case    4:*/		return 0x821BD1F4;
	}
	return 0x821BD1F4;
} // Block from 821BD1E0h-821BD1F4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BD1F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD1F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD1F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD1F4);
		  /* 821BD1F4h */ case    0:  		/* bl -676 */
		/* 821BD1F4h case    0:*/		regs.LR = 0x821BD1F8; return 0x821BCF50;
		/* 821BD1F4h case    0:*/		return 0x821BD1F8;
		  /* 821BD1F8h */ case    1:  		/* mr R5, R30 */
		/* 821BD1F8h case    1:*/		regs.R5 = regs.R30;
		/* 821BD1F8h case    1:*/		return 0x821BD1FC;
		  /* 821BD1FCh */ case    2:  		/* mr R4, R31 */
		/* 821BD1FCh case    2:*/		regs.R4 = regs.R31;
		/* 821BD1FCh case    2:*/		return 0x821BD200;
		  /* 821BD200h */ case    3:  		/* bl 410232 */
		/* 821BD200h case    3:*/		regs.LR = 0x821BD204; return 0x82221478;
		/* 821BD200h case    3:*/		return 0x821BD204;
		  /* 821BD204h */ case    4:  		/* addi R1, R1, 112 */
		/* 821BD204h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821BD204h case    4:*/		return 0x821BD208;
		  /* 821BD208h */ case    5:  		/* lwz R12, <#[R1 - 8]> */
		/* 821BD208h case    5:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821BD208h case    5:*/		return 0x821BD20C;
		  /* 821BD20Ch */ case    6:  		/* mtspr LR, R12 */
		/* 821BD20Ch case    6:*/		regs.LR = regs.R12;
		/* 821BD20Ch case    6:*/		return 0x821BD210;
		  /* 821BD210h */ case    7:  		/* ld R30, <#[R1 - 24]> */
		/* 821BD210h case    7:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821BD210h case    7:*/		return 0x821BD214;
		  /* 821BD214h */ case    8:  		/* ld R31, <#[R1 - 16]> */
		/* 821BD214h case    8:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821BD214h case    8:*/		return 0x821BD218;
		  /* 821BD218h */ case    9:  		/* bclr 20, CR0_LT */
		/* 821BD218h case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BD218h case    9:*/		return 0x821BD21C;
	}
	return 0x821BD21C;
} // Block from 821BD1F4h-821BD21Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 821BD21Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD21C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD21C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD21C);
		  /* 821BD21Ch */ case    0:  		/* nop */
		/* 821BD21Ch case    0:*/		cpu::op::nop();
		/* 821BD21Ch case    0:*/		return 0x821BD220;
	}
	return 0x821BD220;
} // Block from 821BD21Ch-821BD220h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BD220h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD220( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD220) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD220);
		  /* 821BD220h */ case    0:  		/* mfspr R12, LR */
		/* 821BD220h case    0:*/		regs.R12 = regs.LR;
		/* 821BD220h case    0:*/		return 0x821BD224;
		  /* 821BD224h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821BD224h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821BD224h case    1:*/		return 0x821BD228;
		  /* 821BD228h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 821BD228h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 821BD228h case    2:*/		return 0x821BD22C;
		  /* 821BD22Ch */ case    3:  		/* lwz R11, <#[R3]> */
		/* 821BD22Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821BD22Ch case    3:*/		return 0x821BD230;
		  /* 821BD230h */ case    4:  		/* rlwinm R10, R4, 1, 0, 30 */
		/* 821BD230h case    4:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R4);
		/* 821BD230h case    4:*/		return 0x821BD234;
		  /* 821BD234h */ case    5:  		/* lwz R9, <#[R3 + 12]> */
		/* 821BD234h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x0000000C) );
		/* 821BD234h case    5:*/		return 0x821BD238;
		  /* 821BD238h */ case    6:  		/* rlwinm R8, R11, 27, 24, 31 */
		/* 821BD238h case    6:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R8,regs.R11);
		/* 821BD238h case    6:*/		return 0x821BD23C;
		  /* 821BD23Ch */ case    7:  		/* rlwinm R4, R11, 0, 27, 31 */
		/* 821BD23Ch case    7:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R4,regs.R11);
		/* 821BD23Ch case    7:*/		return 0x821BD240;
		  /* 821BD240h */ case    8:  		/* srw R11, R8, R10 */
		/* 821BD240h case    8:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R8,regs.R10);
		/* 821BD240h case    8:*/		return 0x821BD244;
		  /* 821BD244h */ case    9:  		/* lhz R10, <#[R9 + 14]> */
		/* 821BD244h case    9:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R9 + 0x0000000E) );
		/* 821BD244h case    9:*/		return 0x821BD248;
		  /* 821BD248h */ case   10:  		/* rlwinm R11, R11, 2, 28, 29 */
		/* 821BD248h case   10:*/		cpu::op::rlwinm<0,2,28,29>(regs,&regs.R11,regs.R11);
		/* 821BD248h case   10:*/		return 0x821BD24C;
		  /* 821BD24Ch */ case   11:  		/* srw R11, R10, R11 */
		/* 821BD24Ch case   11:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821BD24Ch case   11:*/		return 0x821BD250;
		  /* 821BD250h */ case   12:  		/* rlwinm R3, R11, 0, 28, 31 */
		/* 821BD250h case   12:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R3,regs.R11);
		/* 821BD250h case   12:*/		return 0x821BD254;
		  /* 821BD254h */ case   13:  		/* bl -139732 */
		/* 821BD254h case   13:*/		regs.LR = 0x821BD258; return 0x8219B080;
		/* 821BD254h case   13:*/		return 0x821BD258;
		  /* 821BD258h */ case   14:  		/* rlwinm R3, R3, 31, 31, 31 */
		/* 821BD258h case   14:*/		cpu::op::rlwinm<0,31,31,31>(regs,&regs.R3,regs.R3);
		/* 821BD258h case   14:*/		return 0x821BD25C;
		  /* 821BD25Ch */ case   15:  		/* addi R1, R1, 96 */
		/* 821BD25Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 821BD25Ch case   15:*/		return 0x821BD260;
		  /* 821BD260h */ case   16:  		/* lwz R12, <#[R1 - 8]> */
		/* 821BD260h case   16:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821BD260h case   16:*/		return 0x821BD264;
		  /* 821BD264h */ case   17:  		/* mtspr LR, R12 */
		/* 821BD264h case   17:*/		regs.LR = regs.R12;
		/* 821BD264h case   17:*/		return 0x821BD268;
		  /* 821BD268h */ case   18:  		/* bclr 20, CR0_LT */
		/* 821BD268h case   18:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BD268h case   18:*/		return 0x821BD26C;
	}
	return 0x821BD26C;
} // Block from 821BD220h-821BD26Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 821BD26Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD26C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD26C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD26C);
		  /* 821BD26Ch */ case    0:  		/* nop */
		/* 821BD26Ch case    0:*/		cpu::op::nop();
		/* 821BD26Ch case    0:*/		return 0x821BD270;
	}
	return 0x821BD270;
} // Block from 821BD26Ch-821BD270h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BD270h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD270( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD270) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD270);
		  /* 821BD270h */ case    0:  		/* mfspr R12, LR */
		/* 821BD270h case    0:*/		regs.R12 = regs.LR;
		/* 821BD270h case    0:*/		return 0x821BD274;
		  /* 821BD274h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821BD274h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821BD274h case    1:*/		return 0x821BD278;
		  /* 821BD278h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 821BD278h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 821BD278h case    2:*/		return 0x821BD27C;
		  /* 821BD27Ch */ case    3:  		/* lwz R11, <#[R3]> */
		/* 821BD27Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821BD27Ch case    3:*/		return 0x821BD280;
		  /* 821BD280h */ case    4:  		/* rlwinm R10, R4, 1, 0, 30 */
		/* 821BD280h case    4:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R4);
		/* 821BD280h case    4:*/		return 0x821BD284;
		  /* 821BD284h */ case    5:  		/* lwz R9, <#[R3 + 12]> */
		/* 821BD284h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x0000000C) );
		/* 821BD284h case    5:*/		return 0x821BD288;
		  /* 821BD288h */ case    6:  		/* rlwinm R8, R11, 27, 24, 31 */
		/* 821BD288h case    6:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R8,regs.R11);
		/* 821BD288h case    6:*/		return 0x821BD28C;
		  /* 821BD28Ch */ case    7:  		/* rlwinm R4, R11, 0, 27, 31 */
		/* 821BD28Ch case    7:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R4,regs.R11);
		/* 821BD28Ch case    7:*/		return 0x821BD290;
		  /* 821BD290h */ case    8:  		/* srw R11, R8, R10 */
		/* 821BD290h case    8:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R8,regs.R10);
		/* 821BD290h case    8:*/		return 0x821BD294;
		  /* 821BD294h */ case    9:  		/* lhz R10, <#[R9 + 14]> */
		/* 821BD294h case    9:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R9 + 0x0000000E) );
		/* 821BD294h case    9:*/		return 0x821BD298;
		  /* 821BD298h */ case   10:  		/* rlwinm R11, R11, 2, 28, 29 */
		/* 821BD298h case   10:*/		cpu::op::rlwinm<0,2,28,29>(regs,&regs.R11,regs.R11);
		/* 821BD298h case   10:*/		return 0x821BD29C;
		  /* 821BD29Ch */ case   11:  		/* srw R11, R10, R11 */
		/* 821BD29Ch case   11:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821BD29Ch case   11:*/		return 0x821BD2A0;
		  /* 821BD2A0h */ case   12:  		/* rlwinm R3, R11, 0, 28, 31 */
		/* 821BD2A0h case   12:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R3,regs.R11);
		/* 821BD2A0h case   12:*/		return 0x821BD2A4;
		  /* 821BD2A4h */ case   13:  		/* bl -139812 */
		/* 821BD2A4h case   13:*/		regs.LR = 0x821BD2A8; return 0x8219B080;
		/* 821BD2A4h case   13:*/		return 0x821BD2A8;
		  /* 821BD2A8h */ case   14:  		/* rlwinm R3, R3, 0, 31, 31 */
		/* 821BD2A8h case   14:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R3,regs.R3);
		/* 821BD2A8h case   14:*/		return 0x821BD2AC;
		  /* 821BD2ACh */ case   15:  		/* addi R1, R1, 96 */
		/* 821BD2ACh case   15:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 821BD2ACh case   15:*/		return 0x821BD2B0;
		  /* 821BD2B0h */ case   16:  		/* lwz R12, <#[R1 - 8]> */
		/* 821BD2B0h case   16:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821BD2B0h case   16:*/		return 0x821BD2B4;
		  /* 821BD2B4h */ case   17:  		/* mtspr LR, R12 */
		/* 821BD2B4h case   17:*/		regs.LR = regs.R12;
		/* 821BD2B4h case   17:*/		return 0x821BD2B8;
		  /* 821BD2B8h */ case   18:  		/* bclr 20, CR0_LT */
		/* 821BD2B8h case   18:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BD2B8h case   18:*/		return 0x821BD2BC;
	}
	return 0x821BD2BC;
} // Block from 821BD270h-821BD2BCh (19 instructions)

//////////////////////////////////////////////////////
// Block at 821BD2BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD2BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD2BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD2BC);
		  /* 821BD2BCh */ case    0:  		/* nop */
		/* 821BD2BCh case    0:*/		cpu::op::nop();
		/* 821BD2BCh case    0:*/		return 0x821BD2C0;
	}
	return 0x821BD2C0;
} // Block from 821BD2BCh-821BD2C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BD2C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD2C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD2C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD2C0);
		  /* 821BD2C0h */ case    0:  		/* mfspr R12, LR */
		/* 821BD2C0h case    0:*/		regs.R12 = regs.LR;
		/* 821BD2C0h case    0:*/		return 0x821BD2C4;
		  /* 821BD2C4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821BD2C4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821BD2C4h case    1:*/		return 0x821BD2C8;
		  /* 821BD2C8h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 821BD2C8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 821BD2C8h case    2:*/		return 0x821BD2CC;
		  /* 821BD2CCh */ case    3:  		/* lwz R11, <#[R3]> */
		/* 821BD2CCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821BD2CCh case    3:*/		return 0x821BD2D0;
		  /* 821BD2D0h */ case    4:  		/* rlwinm R10, R4, 1, 0, 30 */
		/* 821BD2D0h case    4:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R4);
		/* 821BD2D0h case    4:*/		return 0x821BD2D4;
		  /* 821BD2D4h */ case    5:  		/* lwz R9, <#[R3 + 12]> */
		/* 821BD2D4h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R3 + 0x0000000C) );
		/* 821BD2D4h case    5:*/		return 0x821BD2D8;
		  /* 821BD2D8h */ case    6:  		/* rlwinm R8, R11, 27, 24, 31 */
		/* 821BD2D8h case    6:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R8,regs.R11);
		/* 821BD2D8h case    6:*/		return 0x821BD2DC;
		  /* 821BD2DCh */ case    7:  		/* rlwinm R4, R11, 0, 27, 31 */
		/* 821BD2DCh case    7:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R4,regs.R11);
		/* 821BD2DCh case    7:*/		return 0x821BD2E0;
		  /* 821BD2E0h */ case    8:  		/* srw R11, R8, R10 */
		/* 821BD2E0h case    8:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R8,regs.R10);
		/* 821BD2E0h case    8:*/		return 0x821BD2E4;
		  /* 821BD2E4h */ case    9:  		/* lhz R10, <#[R9 + 14]> */
		/* 821BD2E4h case    9:*/		cpu::mem::load16z( regs, &regs.R10, (uint32)(regs.R9 + 0x0000000E) );
		/* 821BD2E4h case    9:*/		return 0x821BD2E8;
		  /* 821BD2E8h */ case   10:  		/* rlwinm R11, R11, 2, 28, 29 */
		/* 821BD2E8h case   10:*/		cpu::op::rlwinm<0,2,28,29>(regs,&regs.R11,regs.R11);
		/* 821BD2E8h case   10:*/		return 0x821BD2EC;
		  /* 821BD2ECh */ case   11:  		/* srw R11, R10, R11 */
		/* 821BD2ECh case   11:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821BD2ECh case   11:*/		return 0x821BD2F0;
		  /* 821BD2F0h */ case   12:  		/* rlwinm R3, R11, 0, 28, 31 */
		/* 821BD2F0h case   12:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R3,regs.R11);
		/* 821BD2F0h case   12:*/		return 0x821BD2F4;
		  /* 821BD2F4h */ case   13:  		/* bl -139892 */
		/* 821BD2F4h case   13:*/		regs.LR = 0x821BD2F8; return 0x8219B080;
		/* 821BD2F4h case   13:*/		return 0x821BD2F8;
		  /* 821BD2F8h */ case   14:  		/* rlwinm R3, R3, 30, 31, 31 */
		/* 821BD2F8h case   14:*/		cpu::op::rlwinm<0,30,31,31>(regs,&regs.R3,regs.R3);
		/* 821BD2F8h case   14:*/		return 0x821BD2FC;
		  /* 821BD2FCh */ case   15:  		/* addi R1, R1, 96 */
		/* 821BD2FCh case   15:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 821BD2FCh case   15:*/		return 0x821BD300;
		  /* 821BD300h */ case   16:  		/* lwz R12, <#[R1 - 8]> */
		/* 821BD300h case   16:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821BD300h case   16:*/		return 0x821BD304;
		  /* 821BD304h */ case   17:  		/* mtspr LR, R12 */
		/* 821BD304h case   17:*/		regs.LR = regs.R12;
		/* 821BD304h case   17:*/		return 0x821BD308;
		  /* 821BD308h */ case   18:  		/* bclr 20, CR0_LT */
		/* 821BD308h case   18:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BD308h case   18:*/		return 0x821BD30C;
	}
	return 0x821BD30C;
} // Block from 821BD2C0h-821BD30Ch (19 instructions)

//////////////////////////////////////////////////////
// Block at 821BD30Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD30C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD30C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD30C);
		  /* 821BD30Ch */ case    0:  		/* nop */
		/* 821BD30Ch case    0:*/		cpu::op::nop();
		/* 821BD30Ch case    0:*/		return 0x821BD310;
	}
	return 0x821BD310;
} // Block from 821BD30Ch-821BD310h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BD310h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD310( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD310) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD310);
		  /* 821BD310h */ case    0:  		/* mfspr R12, LR */
		/* 821BD310h case    0:*/		regs.R12 = regs.LR;
		/* 821BD310h case    0:*/		return 0x821BD314;
		  /* 821BD314h */ case    1:  		/* bl -1229004 */
		/* 821BD314h case    1:*/		regs.LR = 0x821BD318; return 0x82091248;
		/* 821BD314h case    1:*/		return 0x821BD318;
		  /* 821BD318h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 821BD318h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 821BD318h case    2:*/		return 0x821BD31C;
		  /* 821BD31Ch */ case    3:  		/* mr R30, R3 */
		/* 821BD31Ch case    3:*/		regs.R30 = regs.R3;
		/* 821BD31Ch case    3:*/		return 0x821BD320;
		  /* 821BD320h */ case    4:  		/* mr R31, R4 */
		/* 821BD320h case    4:*/		regs.R31 = regs.R4;
		/* 821BD320h case    4:*/		return 0x821BD324;
		  /* 821BD324h */ case    5:  		/* mr R26, R5 */
		/* 821BD324h case    5:*/		regs.R26 = regs.R5;
		/* 821BD324h case    5:*/		return 0x821BD328;
		  /* 821BD328h */ case    6:  		/* cmplwi CR6, R4, 0 */
		/* 821BD328h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 821BD328h case    6:*/		return 0x821BD32C;
		  /* 821BD32Ch */ case    7:  		/* bc 4, CR6_EQ, 20 */
		/* 821BD32Ch case    7:*/		if ( !regs.CR[6].eq ) { return 0x821BD340;  }
		/* 821BD32Ch case    7:*/		return 0x821BD330;
		  /* 821BD330h */ case    8:  		/* cmplwi CR6, R5, 0 */
		/* 821BD330h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R5,0x00000000);
		/* 821BD330h case    8:*/		return 0x821BD334;
		  /* 821BD334h */ case    9:  		/* bc 4, CR6_EQ, 324 */
		/* 821BD334h case    9:*/		if ( !regs.CR[6].eq ) { return 0x821BD478;  }
		/* 821BD334h case    9:*/		return 0x821BD338;
		  /* 821BD338h */ case   10:  		/* li R3, 1 */
		/* 821BD338h case   10:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821BD338h case   10:*/		return 0x821BD33C;
		  /* 821BD33Ch */ case   11:  		/* b 320 */
		/* 821BD33Ch case   11:*/		return 0x821BD47C;
		/* 821BD33Ch case   11:*/		return 0x821BD340;
	}
	return 0x821BD340;
} // Block from 821BD310h-821BD340h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821BD340h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD340( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD340) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD340);
		  /* 821BD340h */ case    0:  		/* cmplwi CR6, R26, 0 */
		/* 821BD340h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R26,0x00000000);
		/* 821BD340h case    0:*/		return 0x821BD344;
		  /* 821BD344h */ case    1:  		/* bc 12, CR6_EQ, 308 */
		/* 821BD344h case    1:*/		if ( regs.CR[6].eq ) { return 0x821BD478;  }
		/* 821BD344h case    1:*/		return 0x821BD348;
		  /* 821BD348h */ case    2:  		/* lwz R11, <#[R31 + 4]> */
		/* 821BD348h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 821BD348h case    2:*/		return 0x821BD34C;
		  /* 821BD34Ch */ case    3:  		/* lwz R10, <#[R26 + 4]> */
		/* 821BD34Ch case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000004) );
		/* 821BD34Ch case    3:*/		return 0x821BD350;
		  /* 821BD350h */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 821BD350h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821BD350h case    4:*/		return 0x821BD354;
		  /* 821BD354h */ case    5:  		/* bc 4, CR6_EQ, 292 */
		/* 821BD354h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821BD478;  }
		/* 821BD354h case    5:*/		return 0x821BD358;
		  /* 821BD358h */ case    6:  		/* lwz R11, <#[R31]> */
		/* 821BD358h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821BD358h case    6:*/		return 0x821BD35C;
		  /* 821BD35Ch */ case    7:  		/* mr R3, R30 */
		/* 821BD35Ch case    7:*/		regs.R3 = regs.R30;
		/* 821BD35Ch case    7:*/		return 0x821BD360;
		  /* 821BD360h */ case    8:  		/* lwz R4, <#[R11 + 120]> */
		/* 821BD360h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000078) );
		/* 821BD360h case    8:*/		return 0x821BD364;
		  /* 821BD364h */ case    9:  		/* bl 190940 */
		/* 821BD364h case    9:*/		regs.LR = 0x821BD368; return 0x821EBD40;
		/* 821BD364h case    9:*/		return 0x821BD368;
		  /* 821BD368h */ case   10:  		/* or. R25, R3, R3 */
		/* 821BD368h case   10:*/		cpu::op::or<1>(regs,&regs.R25,regs.R3,regs.R3);
		/* 821BD368h case   10:*/		return 0x821BD36C;
		  /* 821BD36Ch */ case   11:  		/* bc 12, CR0_EQ, -52 */
		/* 821BD36Ch case   11:*/		if ( regs.CR[0].eq ) { return 0x821BD338;  }
		/* 821BD36Ch case   11:*/		return 0x821BD370;
		  /* 821BD370h */ case   12:  		/* addi R24, R31, 8 */
		/* 821BD370h case   12:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R31,0x8);
		/* 821BD370h case   12:*/		return 0x821BD374;
		  /* 821BD374h */ case   13:  		/* mr R3, R30 */
		/* 821BD374h case   13:*/		regs.R3 = regs.R30;
		/* 821BD374h case   13:*/		return 0x821BD378;
		  /* 821BD378h */ case   14:  		/* lwz R4, <#[R25 + 8]> */
		/* 821BD378h case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R25 + 0x00000008) );
		/* 821BD378h case   14:*/		return 0x821BD37C;
		  /* 821BD37Ch */ case   15:  		/* bl 190916 */
		/* 821BD37Ch case   15:*/		regs.LR = 0x821BD380; return 0x821EBD40;
		/* 821BD37Ch case   15:*/		return 0x821BD380;
		  /* 821BD380h */ case   16:  		/* lwz R11, <#[R3 + 12]> */
		/* 821BD380h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 821BD380h case   16:*/		return 0x821BD384;
		  /* 821BD384h */ case   17:  		/* cmplwi CR6, R11, 0 */
		/* 821BD384h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BD384h case   17:*/		return 0x821BD388;
		  /* 821BD388h */ case   18:  		/* bc 12, CR6_EQ, 216 */
		/* 821BD388h case   18:*/		if ( regs.CR[6].eq ) { return 0x821BD460;  }
		/* 821BD388h case   18:*/		return 0x821BD38C;
		  /* 821BD38Ch */ case   19:  		/* lwz R11, <#[R11 + 4]> */
		/* 821BD38Ch case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821BD38Ch case   19:*/		return 0x821BD390;
		  /* 821BD390h */ case   20:  		/* cmpwi CR6, R11, 3 */
		/* 821BD390h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 821BD390h case   20:*/		return 0x821BD394;
		  /* 821BD394h */ case   21:  		/* bc 12, CR6_EQ, 204 */
		/* 821BD394h case   21:*/		if ( regs.CR[6].eq ) { return 0x821BD460;  }
		/* 821BD394h case   21:*/		return 0x821BD398;
		  /* 821BD398h */ case   22:  		/* lwz R11, <#[R3 + 8]> */
		/* 821BD398h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821BD398h case   22:*/		return 0x821BD39C;
		  /* 821BD39Ch */ case   23:  		/* mr R3, R30 */
		/* 821BD39Ch case   23:*/		regs.R3 = regs.R30;
		/* 821BD39Ch case   23:*/		return 0x821BD3A0;
		  /* 821BD3A0h */ case   24:  		/* lwz R10, <#[R26]> */
		/* 821BD3A0h case   24:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000000) );
		/* 821BD3A0h case   24:*/		return 0x821BD3A4;
		  /* 821BD3A4h */ case   25:  		/* li R27, 0 */
		/* 821BD3A4h case   25:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 821BD3A4h case   25:*/		return 0x821BD3A8;
		  /* 821BD3A8h */ case   26:  		/* li R28, 0 */
		/* 821BD3A8h case   26:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 821BD3A8h case   26:*/		return 0x821BD3AC;
		  /* 821BD3ACh */ case   27:  		/* lwz R29, <#[R11 + 24]> */
		/* 821BD3ACh case   27:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x00000018) );
		/* 821BD3ACh case   27:*/		return 0x821BD3B0;
		  /* 821BD3B0h */ case   28:  		/* lwz R4, <#[R10 + 120]> */
		/* 821BD3B0h case   28:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000078) );
		/* 821BD3B0h case   28:*/		return 0x821BD3B4;
		  /* 821BD3B4h */ case   29:  		/* bl 190860 */
		/* 821BD3B4h case   29:*/		regs.LR = 0x821BD3B8; return 0x821EBD40;
		/* 821BD3B4h case   29:*/		return 0x821BD3B8;
		  /* 821BD3B8h */ case   30:  		/* b 112 */
		/* 821BD3B8h case   30:*/		return 0x821BD428;
		/* 821BD3B8h case   30:*/		return 0x821BD3BC;
		  /* 821BD3BCh */ case   31:  		/* mr R3, R30 */
		/* 821BD3BCh case   31:*/		regs.R3 = regs.R30;
		/* 821BD3BCh case   31:*/		return 0x821BD3C0;
		  /* 821BD3C0h */ case   32:  		/* lwz R4, <#[R31 + 8]> */
		/* 821BD3C0h case   32:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000008) );
		/* 821BD3C0h case   32:*/		return 0x821BD3C4;
		  /* 821BD3C4h */ case   33:  		/* bl 190844 */
		/* 821BD3C4h case   33:*/		regs.LR = 0x821BD3C8; return 0x821EBD40;
		/* 821BD3C4h case   33:*/		return 0x821BD3C8;
		  /* 821BD3C8h */ case   34:  		/* lwz R11, <#[R3 + 12]> */
		/* 821BD3C8h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 821BD3C8h case   34:*/		return 0x821BD3CC;
		  /* 821BD3CCh */ case   35:  		/* cmplwi CR6, R11, 0 */
		/* 821BD3CCh case   35:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BD3CCh case   35:*/		return 0x821BD3D0;
		  /* 821BD3D0h */ case   36:  		/* bc 12, CR6_EQ, 76 */
		/* 821BD3D0h case   36:*/		if ( regs.CR[6].eq ) { return 0x821BD41C;  }
		/* 821BD3D0h case   36:*/		return 0x821BD3D4;
		  /* 821BD3D4h */ case   37:  		/* lwz R11, <#[R11 + 4]> */
		/* 821BD3D4h case   37:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821BD3D4h case   37:*/		return 0x821BD3D8;
		  /* 821BD3D8h */ case   38:  		/* cmpwi CR6, R11, 3 */
		/* 821BD3D8h case   38:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 821BD3D8h case   38:*/		return 0x821BD3DC;
		  /* 821BD3DCh */ case   39:  		/* bc 12, CR6_EQ, 64 */
		/* 821BD3DCh case   39:*/		if ( regs.CR[6].eq ) { return 0x821BD41C;  }
		/* 821BD3DCh case   39:*/		return 0x821BD3E0;
		  /* 821BD3E0h */ case   40:  		/* lwz R10, <#[R3 + 8]> */
		/* 821BD3E0h case   40:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 821BD3E0h case   40:*/		return 0x821BD3E4;
		  /* 821BD3E4h */ case   41:  		/* mr R11, R29 */
		/* 821BD3E4h case   41:*/		regs.R11 = regs.R29;
		/* 821BD3E4h case   41:*/		return 0x821BD3E8;
		  /* 821BD3E8h */ case   42:  		/* lwz R10, <#[R10 + 24]> */
		/* 821BD3E8h case   42:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000018) );
		/* 821BD3E8h case   42:*/		return 0x821BD3EC;
		  /* 821BD3ECh */ case   43:  		/* lbz R9, <#[R11]> */
		/* 821BD3ECh case   43:*/		cpu::mem::load8z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821BD3ECh case   43:*/		return 0x821BD3F0;
		  /* 821BD3F0h */ case   44:  		/* lbz R8, <#[R10]> */
		/* 821BD3F0h case   44:*/		cpu::mem::load8z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 821BD3F0h case   44:*/		return 0x821BD3F4;
		  /* 821BD3F4h */ case   45:  		/* cmpwi CR0, R9, 0 */
		/* 821BD3F4h case   45:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 821BD3F4h case   45:*/		return 0x821BD3F8;
		  /* 821BD3F8h */ case   46:  		/* subf R9, R8, R9 */
		/* 821BD3F8h case   46:*/		cpu::op::subf<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 821BD3F8h case   46:*/		return 0x821BD3FC;
		  /* 821BD3FCh */ case   47:  		/* bc 12, CR0_EQ, 20 */
		/* 821BD3FCh case   47:*/		if ( regs.CR[0].eq ) { return 0x821BD410;  }
		/* 821BD3FCh case   47:*/		return 0x821BD400;
		  /* 821BD400h */ case   48:  		/* addi R11, R11, 1 */
		/* 821BD400h case   48:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821BD400h case   48:*/		return 0x821BD404;
		  /* 821BD404h */ case   49:  		/* addi R10, R10, 1 */
		/* 821BD404h case   49:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821BD404h case   49:*/		return 0x821BD408;
		  /* 821BD408h */ case   50:  		/* cmpwi CR6, R9, 0 */
		/* 821BD408h case   50:*/		cpu::op::cmpwi<6>(regs,regs.R9,0x00000000);
		/* 821BD408h case   50:*/		return 0x821BD40C;
		  /* 821BD40Ch */ case   51:  		/* bc 12, CR6_EQ, -32 */
		/* 821BD40Ch case   51:*/		if ( regs.CR[6].eq ) { return 0x821BD3EC;  }
		/* 821BD40Ch case   51:*/		return 0x821BD410;
	}
	return 0x821BD410;
} // Block from 821BD340h-821BD410h (52 instructions)

//////////////////////////////////////////////////////
// Block at 821BD410h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD410( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD410) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD410);
		  /* 821BD410h */ case    0:  		/* cmpwi CR0, R9, 0 */
		/* 821BD410h case    0:*/		cpu::op::cmpwi<0>(regs,regs.R9,0x00000000);
		/* 821BD410h case    0:*/		return 0x821BD414;
		  /* 821BD414h */ case    1:  		/* bc 12, CR0_EQ, 32 */
		/* 821BD414h case    1:*/		if ( regs.CR[0].eq ) { return 0x821BD434;  }
		/* 821BD414h case    1:*/		return 0x821BD418;
		  /* 821BD418h */ case    2:  		/* addi R28, R28, 1 */
		/* 821BD418h case    2:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R28,0x1);
		/* 821BD418h case    2:*/		return 0x821BD41C;
	}
	return 0x821BD41C;
} // Block from 821BD410h-821BD41Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BD41Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD41C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD41C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD41C);
		  /* 821BD41Ch */ case    0:  		/* mr R3, R30 */
		/* 821BD41Ch case    0:*/		regs.R3 = regs.R30;
		/* 821BD41Ch case    0:*/		return 0x821BD420;
		  /* 821BD420h */ case    1:  		/* lwz R4, <#[R31 + 12]> */
		/* 821BD420h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x0000000C) );
		/* 821BD420h case    1:*/		return 0x821BD424;
		  /* 821BD424h */ case    2:  		/* bl 190788 */
		/* 821BD424h case    2:*/		regs.LR = 0x821BD428; return 0x821EBD68;
		/* 821BD424h case    2:*/		return 0x821BD428;
	}
	return 0x821BD428;
} // Block from 821BD41Ch-821BD428h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BD428h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD428( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD428) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD428);
		  /* 821BD428h */ case    0:  		/* or. R31, R3, R3 */
		/* 821BD428h case    0:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 821BD428h case    0:*/		return 0x821BD42C;
		  /* 821BD42Ch */ case    1:  		/* bc 4, CR0_EQ, -112 */
		/* 821BD42Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x821BD3BC;  }
		/* 821BD42Ch case    1:*/		return 0x821BD430;
		  /* 821BD430h */ case    2:  		/* b 36 */
		/* 821BD430h case    2:*/		return 0x821BD454;
		/* 821BD430h case    2:*/		return 0x821BD434;
	}
	return 0x821BD434;
} // Block from 821BD428h-821BD434h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BD434h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD434( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD434) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD434);
		  /* 821BD434h */ case    0:  		/* addi R11, R28, 2 */
		/* 821BD434h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R28,0x2);
		/* 821BD434h case    0:*/		return 0x821BD438;
		  /* 821BD438h */ case    1:  		/* lwz R3, <#[R24]> */
		/* 821BD438h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R24 + 0x00000000) );
		/* 821BD438h case    1:*/		return 0x821BD43C;
		  /* 821BD43Ch */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821BD43Ch case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821BD43Ch case    2:*/		return 0x821BD440;
		  /* 821BD440h */ case    3:  		/* lwzx R4, <#[R11 + R26]> */
		/* 821BD440h case    3:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + regs.R26 + 0x00000000) );
		/* 821BD440h case    3:*/		return 0x821BD444;
		  /* 821BD444h */ case    4:  		/* bl -364988 */
		/* 821BD444h case    4:*/		regs.LR = 0x821BD448; return 0x82164288;
		/* 821BD444h case    4:*/		return 0x821BD448;
		  /* 821BD448h */ case    5:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821BD448h case    5:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821BD448h case    5:*/		return 0x821BD44C;
		  /* 821BD44Ch */ case    6:  		/* bc 12, CR0_EQ, 44 */
		/* 821BD44Ch case    6:*/		if ( regs.CR[0].eq ) { return 0x821BD478;  }
		/* 821BD44Ch case    6:*/		return 0x821BD450;
		  /* 821BD450h */ case    7:  		/* li R27, 1 */
		/* 821BD450h case    7:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 821BD450h case    7:*/		return 0x821BD454;
	}
	return 0x821BD454;
} // Block from 821BD434h-821BD454h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821BD454h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD454( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD454) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD454);
		  /* 821BD454h */ case    0:  		/* rlwinm. R11, R27, 0, 24, 31 */
		/* 821BD454h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R27);
		/* 821BD454h case    0:*/		return 0x821BD458;
		  /* 821BD458h */ case    1:  		/* bc 12, CR0_EQ, 32 */
		/* 821BD458h case    1:*/		if ( regs.CR[0].eq ) { return 0x821BD478;  }
		/* 821BD458h case    1:*/		return 0x821BD45C;
		  /* 821BD45Ch */ case    2:  		/* addi R24, R24, 4 */
		/* 821BD45Ch case    2:*/		cpu::op::addi<0>(regs,&regs.R24,regs.R24,0x4);
		/* 821BD45Ch case    2:*/		return 0x821BD460;
	}
	return 0x821BD460;
} // Block from 821BD454h-821BD460h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BD460h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD460( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD460) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD460);
		  /* 821BD460h */ case    0:  		/* mr R3, R30 */
		/* 821BD460h case    0:*/		regs.R3 = regs.R30;
		/* 821BD460h case    0:*/		return 0x821BD464;
		  /* 821BD464h */ case    1:  		/* lwz R4, <#[R25 + 12]> */
		/* 821BD464h case    1:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R25 + 0x0000000C) );
		/* 821BD464h case    1:*/		return 0x821BD468;
		  /* 821BD468h */ case    2:  		/* bl 190720 */
		/* 821BD468h case    2:*/		regs.LR = 0x821BD46C; return 0x821EBD68;
		/* 821BD468h case    2:*/		return 0x821BD46C;
		  /* 821BD46Ch */ case    3:  		/* or. R25, R3, R3 */
		/* 821BD46Ch case    3:*/		cpu::op::or<1>(regs,&regs.R25,regs.R3,regs.R3);
		/* 821BD46Ch case    3:*/		return 0x821BD470;
		  /* 821BD470h */ case    4:  		/* bc 4, CR0_EQ, -252 */
		/* 821BD470h case    4:*/		if ( !regs.CR[0].eq ) { return 0x821BD374;  }
		/* 821BD470h case    4:*/		return 0x821BD474;
		  /* 821BD474h */ case    5:  		/* b -316 */
		/* 821BD474h case    5:*/		return 0x821BD338;
		/* 821BD474h case    5:*/		return 0x821BD478;
	}
	return 0x821BD478;
} // Block from 821BD460h-821BD478h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BD478h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD478( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD478) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD478);
		  /* 821BD478h */ case    0:  		/* li R3, 0 */
		/* 821BD478h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821BD478h case    0:*/		return 0x821BD47C;
	}
	return 0x821BD47C;
} // Block from 821BD478h-821BD47Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BD47Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD47C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD47C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD47C);
		  /* 821BD47Ch */ case    0:  		/* addi R1, R1, 160 */
		/* 821BD47Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 821BD47Ch case    0:*/		return 0x821BD480;
		  /* 821BD480h */ case    1:  		/* b -1229288 */
		/* 821BD480h case    1:*/		return 0x82091298;
		/* 821BD480h case    1:*/		return 0x821BD484;
		  /* 821BD484h */ case    2:  		/* nop */
		/* 821BD484h case    2:*/		cpu::op::nop();
		/* 821BD484h case    2:*/		return 0x821BD488;
	}
	return 0x821BD488;
} // Block from 821BD47Ch-821BD488h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BD488h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD488( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD488) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD488);
		  /* 821BD488h */ case    0:  		/* mfspr R12, LR */
		/* 821BD488h case    0:*/		regs.R12 = regs.LR;
		/* 821BD488h case    0:*/		return 0x821BD48C;
		  /* 821BD48Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821BD48Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821BD48Ch case    1:*/		return 0x821BD490;
		  /* 821BD490h */ case    2:  		/* stwu R1, <#[R1 - 96]> */
		/* 821BD490h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 821BD490h case    2:*/		return 0x821BD494;
		  /* 821BD494h */ case    3:  		/* lwz R11, <#[R4]> */
		/* 821BD494h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000000) );
		/* 821BD494h case    3:*/		return 0x821BD498;
		  /* 821BD498h */ case    4:  		/* mr R3, R4 */
		/* 821BD498h case    4:*/		regs.R3 = regs.R4;
		/* 821BD498h case    4:*/		return 0x821BD49C;
		  /* 821BD49Ch */ case    5:  		/* lwz R10, <#[R5]> */
		/* 821BD49Ch case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x00000000) );
		/* 821BD49Ch case    5:*/		return 0x821BD4A0;
		  /* 821BD4A0h */ case    6:  		/* xor R9, R10, R11 */
		/* 821BD4A0h case    6:*/		cpu::op::xor<0>(regs,&regs.R9,regs.R10,regs.R11);
		/* 821BD4A0h case    6:*/		return 0x821BD4A4;
		  /* 821BD4A4h */ case    7:  		/* rlwinm. R9, R9, 0, 1, 1 */
		/* 821BD4A4h case    7:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R9,regs.R9);
		/* 821BD4A4h case    7:*/		return 0x821BD4A8;
		  /* 821BD4A8h */ case    8:  		/* bc 4, CR0_EQ, 172 */
		/* 821BD4A8h case    8:*/		if ( !regs.CR[0].eq ) { return 0x821BD554;  }
		/* 821BD4A8h case    8:*/		return 0x821BD4AC;
		  /* 821BD4ACh */ case    9:  		/* rlwinm R9, R11, 7, 29, 31 */
		/* 821BD4ACh case    9:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R9,regs.R11);
		/* 821BD4ACh case    9:*/		return 0x821BD4B0;
		  /* 821BD4B0h */ case   10:  		/* rlwinm R8, R10, 7, 29, 31 */
		/* 821BD4B0h case   10:*/		cpu::op::rlwinm<0,7,29,31>(regs,&regs.R8,regs.R10);
		/* 821BD4B0h case   10:*/		return 0x821BD4B4;
		  /* 821BD4B4h */ case   11:  		/* cmplw CR6, R9, R8 */
		/* 821BD4B4h case   11:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 821BD4B4h case   11:*/		return 0x821BD4B8;
		  /* 821BD4B8h */ case   12:  		/* bc 4, CR6_EQ, 156 */
		/* 821BD4B8h case   12:*/		if ( !regs.CR[6].eq ) { return 0x821BD554;  }
		/* 821BD4B8h case   12:*/		return 0x821BD4BC;
		  /* 821BD4BCh */ case   13:  		/* xor R7, R10, R11 */
		/* 821BD4BCh case   13:*/		cpu::op::xor<0>(regs,&regs.R7,regs.R10,regs.R11);
		/* 821BD4BCh case   13:*/		return 0x821BD4C0;
		  /* 821BD4C0h */ case   14:  		/* rlwinm. R7, R7, 0, 7, 18 */
		/* 821BD4C0h case   14:*/		cpu::op::rlwinm<1,0,7,18>(regs,&regs.R7,regs.R7);
		/* 821BD4C0h case   14:*/		return 0x821BD4C4;
		  /* 821BD4C4h */ case   15:  		/* bc 4, CR0_EQ, 144 */
		/* 821BD4C4h case   15:*/		if ( !regs.CR[0].eq ) { return 0x821BD554;  }
		/* 821BD4C4h case   15:*/		return 0x821BD4C8;
		  /* 821BD4C8h */ case   16:  		/* cmplwi CR6, R9, 0 */
		/* 821BD4C8h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 821BD4C8h case   16:*/		return 0x821BD4CC;
		  /* 821BD4CCh */ case   17:  		/* bc 12, CR6_EQ, 72 */
		/* 821BD4CCh case   17:*/		if ( regs.CR[6].eq ) { return 0x821BD514;  }
		/* 821BD4CCh case   17:*/		return 0x821BD4D0;
		  /* 821BD4D0h */ case   18:  		/* rlwinm R9, R9, 1, 0, 30 */
		/* 821BD4D0h case   18:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R9,regs.R9);
		/* 821BD4D0h case   18:*/		return 0x821BD4D4;
		  /* 821BD4D4h */ case   19:  		/* li R7, 1 */
		/* 821BD4D4h case   19:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821BD4D4h case   19:*/		return 0x821BD4D8;
		  /* 821BD4D8h */ case   20:  		/* rlwinm R8, R8, 1, 0, 30 */
		/* 821BD4D8h case   20:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R8,regs.R8);
		/* 821BD4D8h case   20:*/		return 0x821BD4DC;
		  /* 821BD4DCh */ case   21:  		/* slw R9, R7, R9 */
		/* 821BD4DCh case   21:*/		cpu::op::slw<0>(regs,&regs.R9,regs.R7,regs.R9);
		/* 821BD4DCh case   21:*/		return 0x821BD4E0;
		  /* 821BD4E0h */ case   22:  		/* slw R8, R7, R8 */
		/* 821BD4E0h case   22:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R7,regs.R8);
		/* 821BD4E0h case   22:*/		return 0x821BD4E4;
		  /* 821BD4E4h */ case   23:  		/* addi R9, R9, -1 */
		/* 821BD4E4h case   23:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 821BD4E4h case   23:*/		return 0x821BD4E8;
		  /* 821BD4E8h */ case   24:  		/* addi R8, R8, -1 */
		/* 821BD4E8h case   24:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 821BD4E8h case   24:*/		return 0x821BD4EC;
		  /* 821BD4ECh */ case   25:  		/* rlwinm R7, R10, 27, 5, 31 */
		/* 821BD4ECh case   25:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R7,regs.R10);
		/* 821BD4ECh case   25:*/		return 0x821BD4F0;
		  /* 821BD4F0h */ case   26:  		/* rlwinm R6, R11, 27, 5, 31 */
		/* 821BD4F0h case   26:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R6,regs.R11);
		/* 821BD4F0h case   26:*/		return 0x821BD4F4;
		  /* 821BD4F4h */ case   27:  		/* and R8, R8, R7 */
		/* 821BD4F4h case   27:*/		cpu::op::and<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 821BD4F4h case   27:*/		return 0x821BD4F8;
		  /* 821BD4F8h */ case   28:  		/* and R9, R9, R6 */
		/* 821BD4F8h case   28:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R6);
		/* 821BD4F8h case   28:*/		return 0x821BD4FC;
		  /* 821BD4FCh */ case   29:  		/* xor R9, R8, R9 */
		/* 821BD4FCh case   29:*/		cpu::op::xor<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 821BD4FCh case   29:*/		return 0x821BD500;
		  /* 821BD500h */ case   30:  		/* rlwinm. R9, R9, 0, 24, 31 */
		/* 821BD500h case   30:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R9,regs.R9);
		/* 821BD500h case   30:*/		return 0x821BD504;
		  /* 821BD504h */ case   31:  		/* bc 4, CR0_EQ, 80 */
		/* 821BD504h case   31:*/		if ( !regs.CR[0].eq ) { return 0x821BD554;  }
		/* 821BD504h case   31:*/		return 0x821BD508;
		  /* 821BD508h */ case   32:  		/* xor R11, R10, R11 */
		/* 821BD508h case   32:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821BD508h case   32:*/		return 0x821BD50C;
		  /* 821BD50Ch */ case   33:  		/* rlwinm. R11, R11, 0, 27, 31 */
		/* 821BD50Ch case   33:*/		cpu::op::rlwinm<1,0,27,31>(regs,&regs.R11,regs.R11);
		/* 821BD50Ch case   33:*/		return 0x821BD510;
		  /* 821BD510h */ case   34:  		/* bc 4, CR0_EQ, 68 */
		/* 821BD510h case   34:*/		if ( !regs.CR[0].eq ) { return 0x821BD554;  }
		/* 821BD510h case   34:*/		return 0x821BD514;
	}
	return 0x821BD514;
} // Block from 821BD488h-821BD514h (35 instructions)

//////////////////////////////////////////////////////
// Block at 821BD514h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD514( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD514) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD514);
		  /* 821BD514h */ case    0:  		/* lwz R11, <#[R3 + 12]> */
		/* 821BD514h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 821BD514h case    0:*/		return 0x821BD518;
		  /* 821BD518h */ case    1:  		/* lwz R10, <#[R5 + 12]> */
		/* 821BD518h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R5 + 0x0000000C) );
		/* 821BD518h case    1:*/		return 0x821BD51C;
		  /* 821BD51Ch */ case    2:  		/* lwz R9, <#[R11 + 8]> */
		/* 821BD51Ch case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 821BD51Ch case    2:*/		return 0x821BD520;
		  /* 821BD520h */ case    3:  		/* lwz R8, <#[R10 + 8]> */
		/* 821BD520h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000008) );
		/* 821BD520h case    3:*/		return 0x821BD524;
		  /* 821BD524h */ case    4:  		/* rlwinm R9, R9, 3, 31, 31 */
		/* 821BD524h case    4:*/		cpu::op::rlwinm<0,3,31,31>(regs,&regs.R9,regs.R9);
		/* 821BD524h case    4:*/		return 0x821BD528;
		  /* 821BD528h */ case    5:  		/* rlwinm R8, R8, 3, 31, 31 */
		/* 821BD528h case    5:*/		cpu::op::rlwinm<0,3,31,31>(regs,&regs.R8,regs.R8);
		/* 821BD528h case    5:*/		return 0x821BD52C;
		  /* 821BD52Ch */ case    6:  		/* cmplw CR6, R9, R8 */
		/* 821BD52Ch case    6:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 821BD52Ch case    6:*/		return 0x821BD530;
		  /* 821BD530h */ case    7:  		/* bc 4, CR6_EQ, 36 */
		/* 821BD530h case    7:*/		if ( !regs.CR[6].eq ) { return 0x821BD554;  }
		/* 821BD530h case    7:*/		return 0x821BD534;
		  /* 821BD534h */ case    8:  		/* cmplwi CR6, R9, 0 */
		/* 821BD534h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 821BD534h case    8:*/		return 0x821BD538;
		  /* 821BD538h */ case    9:  		/* bc 4, CR6_EQ, 48 */
		/* 821BD538h case    9:*/		if ( !regs.CR[6].eq ) { return 0x821BD568;  }
		/* 821BD538h case    9:*/		return 0x821BD53C;
		  /* 821BD53Ch */ case   10:  		/* cmplw CR6, R11, R10 */
		/* 821BD53Ch case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821BD53Ch case   10:*/		return 0x821BD540;
		  /* 821BD540h */ case   11:  		/* bc 12, CR6_EQ, 52 */
		/* 821BD540h case   11:*/		if ( regs.CR[6].eq ) { return 0x821BD574;  }
		/* 821BD540h case   11:*/		return 0x821BD544;
		  /* 821BD544h */ case   12:  		/* mr R4, R5 */
		/* 821BD544h case   12:*/		regs.R4 = regs.R5;
		/* 821BD544h case   12:*/		return 0x821BD548;
		  /* 821BD548h */ case   13:  		/* bl 412568 */
		/* 821BD548h case   13:*/		regs.LR = 0x821BD54C; return 0x822220E0;
		/* 821BD548h case   13:*/		return 0x821BD54C;
		  /* 821BD54Ch */ case   14:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821BD54Ch case   14:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821BD54Ch case   14:*/		return 0x821BD550;
		  /* 821BD550h */ case   15:  		/* bc 4, CR0_EQ, 36 */
		/* 821BD550h case   15:*/		if ( !regs.CR[0].eq ) { return 0x821BD574;  }
		/* 821BD550h case   15:*/		return 0x821BD554;
	}
	return 0x821BD554;
} // Block from 821BD514h-821BD554h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821BD554h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD554( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD554) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD554);
		  /* 821BD554h */ case    0:  		/* li R3, 0 */
		/* 821BD554h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821BD554h case    0:*/		return 0x821BD558;
		  /* 821BD558h */ case    1:  		/* addi R1, R1, 96 */
		/* 821BD558h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 821BD558h case    1:*/		return 0x821BD55C;
		  /* 821BD55Ch */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 821BD55Ch case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821BD55Ch case    2:*/		return 0x821BD560;
		  /* 821BD560h */ case    3:  		/* mtspr LR, R12 */
		/* 821BD560h case    3:*/		regs.LR = regs.R12;
		/* 821BD560h case    3:*/		return 0x821BD564;
		  /* 821BD564h */ case    4:  		/* bclr 20, CR0_LT */
		/* 821BD564h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BD564h case    4:*/		return 0x821BD568;
	}
	return 0x821BD568;
} // Block from 821BD554h-821BD568h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BD568h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD568( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD568) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD568);
		  /* 821BD568h */ case    0:  		/* lwz R11, <#[R11 + 32]> */
		/* 821BD568h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000020) );
		/* 821BD568h case    0:*/		return 0x821BD56C;
		  /* 821BD56Ch */ case    1:  		/* cmplw CR6, R11, R10 */
		/* 821BD56Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821BD56Ch case    1:*/		return 0x821BD570;
		  /* 821BD570h */ case    2:  		/* bc 4, CR6_EQ, -28 */
		/* 821BD570h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821BD554;  }
		/* 821BD570h case    2:*/		return 0x821BD574;
	}
	return 0x821BD574;
} // Block from 821BD568h-821BD574h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BD574h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD574( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD574) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD574);
		  /* 821BD574h */ case    0:  		/* li R3, 1 */
		/* 821BD574h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821BD574h case    0:*/		return 0x821BD578;
		  /* 821BD578h */ case    1:  		/* b -32 */
		/* 821BD578h case    1:*/		return 0x821BD558;
		/* 821BD578h case    1:*/		return 0x821BD57C;
		  /* 821BD57Ch */ case    2:  		/* nop */
		/* 821BD57Ch case    2:*/		cpu::op::nop();
		/* 821BD57Ch case    2:*/		return 0x821BD580;
		  /* 821BD580h */ case    3:  		/* lwz R11, <#[R3]> */
		/* 821BD580h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821BD580h case    3:*/		return 0x821BD584;
		  /* 821BD584h */ case    4:  		/* lwz R10, <#[R4]> */
		/* 821BD584h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 821BD584h case    4:*/		return 0x821BD588;
		  /* 821BD588h */ case    5:  		/* lwz R9, <#[R11 + 8]> */
		/* 821BD588h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 821BD588h case    5:*/		return 0x821BD58C;
		  /* 821BD58Ch */ case    6:  		/* lwz R8, <#[R10 + 8]> */
		/* 821BD58Ch case    6:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000008) );
		/* 821BD58Ch case    6:*/		return 0x821BD590;
		  /* 821BD590h */ case    7:  		/* rlwinm R9, R9, 25, 25, 31 */
		/* 821BD590h case    7:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R9,regs.R9);
		/* 821BD590h case    7:*/		return 0x821BD594;
		  /* 821BD594h */ case    8:  		/* rlwinm R8, R8, 25, 25, 31 */
		/* 821BD594h case    8:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R8,regs.R8);
		/* 821BD594h case    8:*/		return 0x821BD598;
		  /* 821BD598h */ case    9:  		/* cmpw CR6, R9, R8 */
		/* 821BD598h case    9:*/		cpu::op::cmpw<6>(regs,regs.R9,regs.R8);
		/* 821BD598h case    9:*/		return 0x821BD59C;
		  /* 821BD59Ch */ case   10:  		/* bc 12, CR6_LT, 52 */
		/* 821BD59Ch case   10:*/		if ( regs.CR[6].lt ) { return 0x821BD5D0;  }
		/* 821BD59Ch case   10:*/		return 0x821BD5A0;
		  /* 821BD5A0h */ case   11:  		/* cmplw CR6, R9, R8 */
		/* 821BD5A0h case   11:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 821BD5A0h case   11:*/		return 0x821BD5A4;
		  /* 821BD5A4h */ case   12:  		/* bc 4, CR6_EQ, 12 */
		/* 821BD5A4h case   12:*/		if ( !regs.CR[6].eq ) { return 0x821BD5B0;  }
		/* 821BD5A4h case   12:*/		return 0x821BD5A8;
		  /* 821BD5A8h */ case   13:  		/* cmplw CR6, R11, R10 */
		/* 821BD5A8h case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821BD5A8h case   13:*/		return 0x821BD5AC;
		  /* 821BD5ACh */ case   14:  		/* bc 12, CR6_LT, 36 */
		/* 821BD5ACh case   14:*/		if ( regs.CR[6].lt ) { return 0x821BD5D0;  }
		/* 821BD5ACh case   14:*/		return 0x821BD5B0;
	}
	return 0x821BD5B0;
} // Block from 821BD574h-821BD5B0h (15 instructions)

//////////////////////////////////////////////////////
// Block at 821BD5B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD5B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD5B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD5B0);
		  /* 821BD5B0h */ case    0:  		/* cmplw CR6, R11, R10 */
		/* 821BD5B0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821BD5B0h case    0:*/		return 0x821BD5B4;
		  /* 821BD5B4h */ case    1:  		/* bc 4, CR6_EQ, 20 */
		/* 821BD5B4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BD5C8;  }
		/* 821BD5B4h case    1:*/		return 0x821BD5B8;
		  /* 821BD5B8h */ case    2:  		/* lwz R11, <#[R3 + 4]> */
		/* 821BD5B8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821BD5B8h case    2:*/		return 0x821BD5BC;
		  /* 821BD5BCh */ case    3:  		/* lwz R10, <#[R4 + 4]> */
		/* 821BD5BCh case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000004) );
		/* 821BD5BCh case    3:*/		return 0x821BD5C0;
		  /* 821BD5C0h */ case    4:  		/* cmpw CR6, R11, R10 */
		/* 821BD5C0h case    4:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 821BD5C0h case    4:*/		return 0x821BD5C4;
		  /* 821BD5C4h */ case    5:  		/* bc 12, CR6_LT, 12 */
		/* 821BD5C4h case    5:*/		if ( regs.CR[6].lt ) { return 0x821BD5D0;  }
		/* 821BD5C4h case    5:*/		return 0x821BD5C8;
	}
	return 0x821BD5C8;
} // Block from 821BD5B0h-821BD5C8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BD5C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD5C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD5C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD5C8);
		  /* 821BD5C8h */ case    0:  		/* li R11, 0 */
		/* 821BD5C8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BD5C8h case    0:*/		return 0x821BD5CC;
		  /* 821BD5CCh */ case    1:  		/* b 8 */
		/* 821BD5CCh case    1:*/		return 0x821BD5D4;
		/* 821BD5CCh case    1:*/		return 0x821BD5D0;
	}
	return 0x821BD5D0;
} // Block from 821BD5C8h-821BD5D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BD5D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD5D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD5D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD5D0);
		  /* 821BD5D0h */ case    0:  		/* li R11, 1 */
		/* 821BD5D0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821BD5D0h case    0:*/		return 0x821BD5D4;
	}
	return 0x821BD5D4;
} // Block from 821BD5D0h-821BD5D4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BD5D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD5D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD5D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD5D4);
		  /* 821BD5D4h */ case    0:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 821BD5D4h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 821BD5D4h case    0:*/		return 0x821BD5D8;
		  /* 821BD5D8h */ case    1:  		/* bclr 20, CR0_LT */
		/* 821BD5D8h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BD5D8h case    1:*/		return 0x821BD5DC;
	}
	return 0x821BD5DC;
} // Block from 821BD5D4h-821BD5DCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BD5DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD5DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD5DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD5DC);
		  /* 821BD5DCh */ case    0:  		/* nop */
		/* 821BD5DCh case    0:*/		cpu::op::nop();
		/* 821BD5DCh case    0:*/		return 0x821BD5E0;
		  /* 821BD5E0h */ case    1:  		/* lwz R11, <#[R3 + 8]> */
		/* 821BD5E0h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821BD5E0h case    1:*/		return 0x821BD5E4;
		  /* 821BD5E4h */ case    2:  		/* lwz R10, <#[R4 + 8]> */
		/* 821BD5E4h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000008) );
		/* 821BD5E4h case    2:*/		return 0x821BD5E8;
		  /* 821BD5E8h */ case    3:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821BD5E8h case    3:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821BD5E8h case    3:*/		return 0x821BD5EC;
		  /* 821BD5ECh */ case    4:  		/* rlwinm R10, R10, 25, 25, 31 */
		/* 821BD5ECh case    4:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R10,regs.R10);
		/* 821BD5ECh case    4:*/		return 0x821BD5F0;
		  /* 821BD5F0h */ case    5:  		/* cmpw CR6, R11, R10 */
		/* 821BD5F0h case    5:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 821BD5F0h case    5:*/		return 0x821BD5F4;
		  /* 821BD5F4h */ case    6:  		/* bc 4, CR6_GT, 48 */
		/* 821BD5F4h case    6:*/		if ( !regs.CR[6].gt ) { return 0x821BD624;  }
		/* 821BD5F4h case    6:*/		return 0x821BD5F8;
		  /* 821BD5F8h */ case    7:  		/* cmplwi CR6, R11, 125 */
		/* 821BD5F8h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 821BD5F8h case    7:*/		return 0x821BD5FC;
		  /* 821BD5FCh */ case    8:  		/* bc 4, CR6_EQ, 12 */
		/* 821BD5FCh case    8:*/		if ( !regs.CR[6].eq ) { return 0x821BD608;  }
		/* 821BD5FCh case    8:*/		return 0x821BD600;
		  /* 821BD600h */ case    9:  		/* li R3, 1 */
		/* 821BD600h case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821BD600h case    9:*/		return 0x821BD604;
		  /* 821BD604h */ case   10:  		/* bclr 20, CR0_LT */
		/* 821BD604h case   10:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BD604h case   10:*/		return 0x821BD608;
	}
	return 0x821BD608;
} // Block from 821BD5DCh-821BD608h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821BD608h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD608( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD608) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD608);
		  /* 821BD608h */ case    0:  		/* cmplwi CR6, R10, 125 */
		/* 821BD608h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000007D);
		/* 821BD608h case    0:*/		return 0x821BD60C;
		  /* 821BD60Ch */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 821BD60Ch case    1:*/		if ( regs.CR[6].eq ) { return 0x821BD624;  }
		/* 821BD60Ch case    1:*/		return 0x821BD610;
		  /* 821BD610h */ case    2:  		/* cmplwi CR6, R11, 110 */
		/* 821BD610h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000006E);
		/* 821BD610h case    2:*/		return 0x821BD614;
		  /* 821BD614h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 821BD614h case    3:*/		if ( regs.CR[6].eq ) { return 0x821BD624;  }
		/* 821BD614h case    3:*/		return 0x821BD618;
		  /* 821BD618h */ case    4:  		/* cmplwi CR6, R10, 110 */
		/* 821BD618h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x0000006E);
		/* 821BD618h case    4:*/		return 0x821BD61C;
		  /* 821BD61Ch */ case    5:  		/* li R3, 1 */
		/* 821BD61Ch case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821BD61Ch case    5:*/		return 0x821BD620;
		  /* 821BD620h */ case    6:  		/* bclr 4, CR6_EQ */
		/* 821BD620h case    6:*/		if ( !regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 821BD620h case    6:*/		return 0x821BD624;
	}
	return 0x821BD624;
} // Block from 821BD608h-821BD624h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BD624h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD624( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD624) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD624);
		  /* 821BD624h */ case    0:  		/* li R3, 0 */
		/* 821BD624h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821BD624h case    0:*/		return 0x821BD628;
		  /* 821BD628h */ case    1:  		/* bclr 20, CR0_LT */
		/* 821BD628h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BD628h case    1:*/		return 0x821BD62C;
	}
	return 0x821BD62C;
} // Block from 821BD624h-821BD62Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BD62Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD62C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD62C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD62C);
		  /* 821BD62Ch */ case    0:  		/* nop */
		/* 821BD62Ch case    0:*/		cpu::op::nop();
		/* 821BD62Ch case    0:*/		return 0x821BD630;
	}
	return 0x821BD630;
} // Block from 821BD62Ch-821BD630h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BD630h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD630( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD630) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD630);
		  /* 821BD630h */ case    0:  		/* mfspr R12, LR */
		/* 821BD630h case    0:*/		regs.R12 = regs.LR;
		/* 821BD630h case    0:*/		return 0x821BD634;
		  /* 821BD634h */ case    1:  		/* bl -1229788 */
		/* 821BD634h case    1:*/		regs.LR = 0x821BD638; return 0x82091258;
		/* 821BD634h case    1:*/		return 0x821BD638;
		  /* 821BD638h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821BD638h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821BD638h case    2:*/		return 0x821BD63C;
		  /* 821BD63Ch */ case    3:  		/* mr R31, R4 */
		/* 821BD63Ch case    3:*/		regs.R31 = regs.R4;
		/* 821BD63Ch case    3:*/		return 0x821BD640;
		  /* 821BD640h */ case    4:  		/* stw R5, <#[R1 + 164]> */
		/* 821BD640h case    4:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x000000A4) );
		/* 821BD640h case    4:*/		return 0x821BD644;
		  /* 821BD644h */ case    5:  		/* mr R4, R5 */
		/* 821BD644h case    5:*/		regs.R4 = regs.R5;
		/* 821BD644h case    5:*/		return 0x821BD648;
		  /* 821BD648h */ case    6:  		/* mr R30, R6 */
		/* 821BD648h case    6:*/		regs.R30 = regs.R6;
		/* 821BD648h case    6:*/		return 0x821BD64C;
		  /* 821BD64Ch */ case    7:  		/* mr R29, R7 */
		/* 821BD64Ch case    7:*/		regs.R29 = regs.R7;
		/* 821BD64Ch case    7:*/		return 0x821BD650;
		  /* 821BD650h */ case    8:  		/* mr R28, R8 */
		/* 821BD650h case    8:*/		regs.R28 = regs.R8;
		/* 821BD650h case    8:*/		return 0x821BD654;
		  /* 821BD654h */ case    9:  		/* lwz R11, <#[R31 + 8]> */
		/* 821BD654h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821BD654h case    9:*/		return 0x821BD658;
		  /* 821BD658h */ case   10:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821BD658h case   10:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821BD658h case   10:*/		return 0x821BD65C;
		  /* 821BD65Ch */ case   11:  		/* cmplwi CR6, R11, 128 */
		/* 821BD65Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000080);
		/* 821BD65Ch case   11:*/		return 0x821BD660;
		  /* 821BD660h */ case   12:  		/* bc 12, CR6_EQ, 20 */
		/* 821BD660h case   12:*/		if ( regs.CR[6].eq ) { return 0x821BD674;  }
		/* 821BD660h case   12:*/		return 0x821BD664;
		  /* 821BD664h */ case   13:  		/* li R3, 0 */
		/* 821BD664h case   13:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821BD664h case   13:*/		return 0x821BD668;
		  /* 821BD668h */ case   14:  		/* addi R1, R1, 128 */
		/* 821BD668h case   14:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821BD668h case   14:*/		return 0x821BD66C;
		  /* 821BD66Ch */ case   15:  		/* b -1229764 */
		/* 821BD66Ch case   15:*/		return 0x820912A8;
		/* 821BD66Ch case   15:*/		return 0x821BD670;
		  /* 821BD670h */ case   16:  		/* lwz R4, <#[R1 + 164]> */
		/* 821BD670h case   16:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x000000A4) );
		/* 821BD670h case   16:*/		return 0x821BD674;
	}
	return 0x821BD674;
} // Block from 821BD630h-821BD674h (17 instructions)

//////////////////////////////////////////////////////
// Block at 821BD674h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD674( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD674) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD674);
		  /* 821BD674h */ case    0:  		/* lwz R11, <#[R31 + 48]> */
		/* 821BD674h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 821BD674h case    0:*/		return 0x821BD678;
	}
	return 0x821BD678;
} // Block from 821BD674h-821BD678h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BD678h
// Function '?Reclean@Compiler@D3DXShader@@AAAXPAVInstruction@2@PAV?$Stack@PAVInstruction@D3DXShader@@$1?AllocInContext@CompilerHeap@2@SAPAXPAXK@Z$1?FreeInContext@42@SAX00K@Z@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD678( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD678) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD678);
		  /* 821BD678h */ case    0:  		/* lwz R10, <#[R11 + 12]> */
		/* 821BD678h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000000C) );
		/* 821BD678h case    0:*/		return 0x821BD67C;
		  /* 821BD67Ch */ case    1:  		/* lwz R9, <#[R10 + 8]> */
		/* 821BD67Ch case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000008) );
		/* 821BD67Ch case    1:*/		return 0x821BD680;
		  /* 821BD680h */ case    2:  		/* rlwinm R9, R9, 0, 18, 24 */
		/* 821BD680h case    2:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R9,regs.R9);
		/* 821BD680h case    2:*/		return 0x821BD684;
		  /* 821BD684h */ case    3:  		/* cmplwi CR6, R9, 16000 */
		/* 821BD684h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00003E80);
		/* 821BD684h case    3:*/		return 0x821BD688;
		  /* 821BD688h */ case    4:  		/* bc 12, CR6_EQ, 116 */
		/* 821BD688h case    4:*/		if ( regs.CR[6].eq ) { return 0x821BD6FC;  }
		/* 821BD688h case    4:*/		return 0x821BD68C;
		  /* 821BD68Ch */ case    5:  		/* li R10, 0 */
		/* 821BD68Ch case    5:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821BD68Ch case    5:*/		return 0x821BD690;
		  /* 821BD690h */ case    6:  		/* lwz R3, <#[R31 + 44]> */
		/* 821BD690h case    6:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821BD690h case    6:*/		return 0x821BD694;
		  /* 821BD694h */ case    7:  		/* mr R9, R31 */
		/* 821BD694h case    7:*/		regs.R9 = regs.R31;
		/* 821BD694h case    7:*/		return 0x821BD698;
		  /* 821BD698h */ case    8:  		/* li R8, 0 */
		/* 821BD698h case    8:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821BD698h case    8:*/		return 0x821BD69C;
		  /* 821BD69Ch */ case    9:  		/* addi R7, R1, 80 */
		/* 821BD69Ch case    9:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x50);
		/* 821BD69Ch case    9:*/		return 0x821BD6A0;
		  /* 821BD6A0h */ case   10:  		/* addi R6, R1, 164 */
		/* 821BD6A0h case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0xA4);
		/* 821BD6A0h case   10:*/		return 0x821BD6A4;
		  /* 821BD6A4h */ case   11:  		/* addi R5, R1, 84 */
		/* 821BD6A4h case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 821BD6A4h case   11:*/		return 0x821BD6A8;
		  /* 821BD6A8h */ case   12:  		/* bl 417320 */
		/* 821BD6A8h case   12:*/		regs.LR = 0x821BD6AC; return 0x822234D0;
		/* 821BD6A8h case   12:*/		return 0x821BD6AC;
		  /* 821BD6ACh */ case   13:  		/* lwz R11, <#[R1 + 80]> */
		/* 821BD6ACh case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 821BD6ACh case   13:*/		return 0x821BD6B0;
		  /* 821BD6B0h */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 821BD6B0h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BD6B0h case   14:*/		return 0x821BD6B4;
		  /* 821BD6B4h */ case   15:  		/* bc 4, CR6_EQ, -80 */
		/* 821BD6B4h case   15:*/		if ( !regs.CR[6].eq ) { return 0x821BD664;  }
		/* 821BD6B4h case   15:*/		return 0x821BD6B8;
	}
	return 0x821BD6B8;
} // Block from 821BD678h-821BD6B8h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821BD6B8h
// Function '?MultipliesFirstTwoOperands@Instruction@D3DXShader@@QAA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD6B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD6B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD6B8);
		  /* 821BD6B8h */ case    0:  		/* lwz R9, <#[R1 + 84]> */
		/* 821BD6B8h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000054) );
		/* 821BD6B8h case    0:*/		return 0x821BD6BC;
		  /* 821BD6BCh */ case    1:  		/* lwz R10, <#[R9 + 4]> */
		/* 821BD6BCh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000004) );
		/* 821BD6BCh case    1:*/		return 0x821BD6C0;
		  /* 821BD6C0h */ case    2:  		/* cmplwi CR6, R10, 0 */
		/* 821BD6C0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821BD6C0h case    2:*/		return 0x821BD6C4;
		  /* 821BD6C4h */ case    3:  		/* bc 12, CR6_EQ, 32 */
		/* 821BD6C4h case    3:*/		if ( regs.CR[6].eq ) { return 0x821BD6E4;  }
		/* 821BD6C4h case    3:*/		return 0x821BD6C8;
		  /* 821BD6C8h */ case    4:  		/* lwz R11, <#[R10 + 16]> */
		/* 821BD6C8h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000010) );
		/* 821BD6C8h case    4:*/		return 0x821BD6CC;
		  /* 821BD6CCh */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821BD6CCh case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BD6CCh case    5:*/		return 0x821BD6D0;
		  /* 821BD6D0h */ case    6:  		/* bc 12, CR6_EQ, 12 */
		/* 821BD6D0h case    6:*/		if ( regs.CR[6].eq ) { return 0x821BD6DC;  }
		/* 821BD6D0h case    6:*/		return 0x821BD6D4;
		  /* 821BD6D4h */ case    7:  		/* cmplw CR6, R11, R31 */
		/* 821BD6D4h case    7:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 821BD6D4h case    7:*/		return 0x821BD6D8;
		  /* 821BD6D8h */ case    8:  		/* bc 4, CR6_EQ, -116 */
		/* 821BD6D8h case    8:*/		if ( !regs.CR[6].eq ) { return 0x821BD664;  }
		/* 821BD6D8h case    8:*/		return 0x821BD6DC;
	}
	return 0x821BD6DC;
} // Block from 821BD6B8h-821BD6DCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 821BD6DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD6DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD6DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD6DC);
		  /* 821BD6DCh */ case    0:  		/* lwz R10, <#[R10 + 8]> */
		/* 821BD6DCh case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 821BD6DCh case    0:*/		return 0x821BD6E0;
		  /* 821BD6E0h */ case    1:  		/* b -32 */
		/* 821BD6E0h case    1:*/		return 0x821BD6C0;
		/* 821BD6E0h case    1:*/		return 0x821BD6E4;
	}
	return 0x821BD6E4;
} // Block from 821BD6DCh-821BD6E4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BD6E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD6E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD6E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD6E4);
		  /* 821BD6E4h */ case    0:  		/* lwz R11, <#[R9 + 8]> */
		/* 821BD6E4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000008) );
		/* 821BD6E4h case    0:*/		return 0x821BD6E8;
		  /* 821BD6E8h */ case    1:  		/* mr R31, R9 */
		/* 821BD6E8h case    1:*/		regs.R31 = regs.R9;
		/* 821BD6E8h case    1:*/		return 0x821BD6EC;
		  /* 821BD6ECh */ case    2:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821BD6ECh case    2:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821BD6ECh case    2:*/		return 0x821BD6F0;
		  /* 821BD6F0h */ case    3:  		/* cmplwi CR6, R11, 128 */
		/* 821BD6F0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000080);
		/* 821BD6F0h case    3:*/		return 0x821BD6F4;
		  /* 821BD6F4h */ case    4:  		/* bc 12, CR6_EQ, -132 */
		/* 821BD6F4h case    4:*/		if ( regs.CR[6].eq ) { return 0x821BD670;  }
		/* 821BD6F4h case    4:*/		return 0x821BD6F8;
		  /* 821BD6F8h */ case    5:  		/* b -148 */
		/* 821BD6F8h case    5:*/		return 0x821BD664;
		/* 821BD6F8h case    5:*/		return 0x821BD6FC;
	}
	return 0x821BD6FC;
} // Block from 821BD6E4h-821BD6FCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BD6FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD6FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD6FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD6FC);
		  /* 821BD6FCh */ case    0:  		/* stw R10, <#[R30]> */
		/* 821BD6FCh case    0:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R30 + 0x00000000) );
		/* 821BD6FCh case    0:*/		return 0x821BD700;
	}
	return 0x821BD700;
} // Block from 821BD6FCh-821BD700h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BD700h
// Function '?XenosNormalize@D3DXShader@@YANN@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD700( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD700) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD700);
		  /* 821BD700h */ case    0:  		/* rlwinm R10, R4, 1, 0, 30 */
		/* 821BD700h case    0:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R4);
		/* 821BD700h case    0:*/		return 0x821BD704;
		  /* 821BD704h */ case    1:  		/* lwz R9, <#[R11]> */
		/* 821BD704h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821BD704h case    1:*/		return 0x821BD708;
		  /* 821BD708h */ case    2:  		/* rlwinm R9, R9, 27, 24, 31 */
		/* 821BD708h case    2:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R9,regs.R9);
		/* 821BD708h case    2:*/		return 0x821BD70C;
		  /* 821BD70Ch */ case    3:  		/* srw R10, R9, R10 */
		/* 821BD70Ch case    3:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 821BD70Ch case    3:*/		return 0x821BD710;
		  /* 821BD710h */ case    4:  		/* rlwinm R10, R10, 0, 30, 31 */
		/* 821BD710h case    4:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R10,regs.R10);
		/* 821BD710h case    4:*/		return 0x821BD714;
		  /* 821BD714h */ case    5:  		/* li R3, 1 */
		/* 821BD714h case    5:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821BD714h case    5:*/		return 0x821BD718;
		  /* 821BD718h */ case    6:  		/* stw R10, <#[R29]> */
		/* 821BD718h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R29 + 0x00000000) );
		/* 821BD718h case    6:*/		return 0x821BD71C;
		  /* 821BD71Ch */ case    7:  		/* lwz R11, <#[R11]> */
		/* 821BD71Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821BD71Ch case    7:*/		return 0x821BD720;
		  /* 821BD720h */ case    8:  		/* rlwinm R11, R11, 0, 27, 31 */
		/* 821BD720h case    8:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R11,regs.R11);
		/* 821BD720h case    8:*/		return 0x821BD724;
		  /* 821BD724h */ case    9:  		/* stw R11, <#[R28]> */
		/* 821BD724h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 821BD724h case    9:*/		return 0x821BD728;
		  /* 821BD728h */ case   10:  		/* b -192 */
		/* 821BD728h case   10:*/		return 0x821BD668;
		/* 821BD728h case   10:*/		return 0x821BD72C;
		  /* 821BD72Ch */ case   11:  		/* nop */
		/* 821BD72Ch case   11:*/		cpu::op::nop();
		/* 821BD72Ch case   11:*/		return 0x821BD730;
		  /* 821BD730h */ case   12:  		/* lwz R10, <#[R3 + 8]> */
		/* 821BD730h case   12:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 821BD730h case   12:*/		return 0x821BD734;
		  /* 821BD734h */ case   13:  		/* mr R11, R3 */
		/* 821BD734h case   13:*/		regs.R11 = regs.R3;
		/* 821BD734h case   13:*/		return 0x821BD738;
		  /* 821BD738h */ case   14:  		/* rlwinm R9, R10, 0, 18, 24 */
		/* 821BD738h case   14:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R9,regs.R10);
		/* 821BD738h case   14:*/		return 0x821BD73C;
		  /* 821BD73Ch */ case   15:  		/* cmplwi CR6, R9, 16000 */
		/* 821BD73Ch case   15:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00003E80);
		/* 821BD73Ch case   15:*/		return 0x821BD740;
		  /* 821BD740h */ case   16:  		/* bc 4, CR6_EQ, 64 */
		/* 821BD740h case   16:*/		if ( !regs.CR[6].eq ) { return 0x821BD780;  }
		/* 821BD740h case   16:*/		return 0x821BD744;
		  /* 821BD744h */ case   17:  		/* rlwinm R10, R3, 0, 0, 19 */
		/* 821BD744h case   17:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R10,regs.R3);
		/* 821BD744h case   17:*/		return 0x821BD748;
		  /* 821BD748h */ case   18:  		/* lwz R10, <#[R10]> */
		/* 821BD748h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821BD748h case   18:*/		return 0x821BD74C;
		  /* 821BD74Ch */ case   19:  		/* lwz R10, <#[R10 + 148]> */
		/* 821BD74Ch case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000094) );
		/* 821BD74Ch case   19:*/		return 0x821BD750;
	}
	return 0x821BD750;
} // Block from 821BD700h-821BD750h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821BD750h
// Function '?XenosFloor@D3DXShader@@YANN@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD750( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD750) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD750);
		  /* 821BD750h */ case    0:  		/* lwz R10, <#[R10 + 40]> */
		/* 821BD750h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000028) );
		/* 821BD750h case    0:*/		return 0x821BD754;
		  /* 821BD754h */ case    1:  		/* nor R10, R10, R10 */
		/* 821BD754h case    1:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 821BD754h case    1:*/		return 0x821BD758;
		  /* 821BD758h */ case    2:  		/* rlwinm. R10, R10, 18, 31, 31 */
		/* 821BD758h case    2:*/		cpu::op::rlwinm<1,18,31,31>(regs,&regs.R10,regs.R10);
		/* 821BD758h case    2:*/		return 0x821BD75C;
		  /* 821BD75Ch */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 821BD75Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BD768;  }
		/* 821BD75Ch case    3:*/		return 0x821BD760;
		  /* 821BD760h */ case    4:  		/* li R3, 0 */
		/* 821BD760h case    4:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821BD760h case    4:*/		return 0x821BD764;
		  /* 821BD764h */ case    5:  		/* bclr 20, CR0_LT */
		/* 821BD764h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BD764h case    5:*/		return 0x821BD768;
	}
	return 0x821BD768;
} // Block from 821BD750h-821BD768h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BD768h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD768( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD768) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD768);
		  /* 821BD768h */ case    0:  		/* lwz R11, <#[R11 + 20]> */
		/* 821BD768h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 821BD768h case    0:*/		return 0x821BD76C;
		  /* 821BD76Ch */ case    1:  		/* rlwinm R10, R4, 1, 0, 30 */
		/* 821BD76Ch case    1:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R4);
		/* 821BD76Ch case    1:*/		return 0x821BD770;
		  /* 821BD770h */ case    2:  		/* rlwinm R11, R11, 30, 24, 31 */
		/* 821BD770h case    2:*/		cpu::op::rlwinm<0,30,24,31>(regs,&regs.R11,regs.R11);
		/* 821BD770h case    2:*/		return 0x821BD774;
		  /* 821BD774h */ case    3:  		/* srw R11, R11, R10 */
		/* 821BD774h case    3:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821BD774h case    3:*/		return 0x821BD778;
		  /* 821BD778h */ case    4:  		/* rlwinm R3, R11, 0, 30, 31 */
		/* 821BD778h case    4:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R3,regs.R11);
		/* 821BD778h case    4:*/		return 0x821BD77C;
		  /* 821BD77Ch */ case    5:  		/* bclr 20, CR0_LT */
		/* 821BD77Ch case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BD77Ch case    5:*/		return 0x821BD780;
	}
	return 0x821BD780;
} // Block from 821BD768h-821BD780h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BD780h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD780( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD780) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD780);
		  /* 821BD780h */ case    0:  		/* rlwinm. R10, R10, 0, 7, 7 */
		/* 821BD780h case    0:*/		cpu::op::rlwinm<1,0,7,7>(regs,&regs.R10,regs.R10);
		/* 821BD780h case    0:*/		return 0x821BD784;
		  /* 821BD784h */ case    1:  		/* li R3, 0 */
		/* 821BD784h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821BD784h case    1:*/		return 0x821BD788;
		  /* 821BD788h */ case    2:  		/* bclr 4, CR0_EQ */
		/* 821BD788h case    2:*/		if ( !regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 821BD788h case    2:*/		return 0x821BD78C;
	}
	return 0x821BD78C;
} // Block from 821BD780h-821BD78Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BD78Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD78C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD78C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD78C);
		  /* 821BD78Ch */ case    0:  		/* lhz R11, <#[R11 + 14]> */
		/* 821BD78Ch case    0:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000E) );
		/* 821BD78Ch case    0:*/		return 0x821BD790;
		  /* 821BD790h */ case    1:  		/* rlwinm R10, R4, 2, 16, 29 */
		/* 821BD790h case    1:*/		cpu::op::rlwinm<0,2,16,29>(regs,&regs.R10,regs.R4);
		/* 821BD790h case    1:*/		return 0x821BD794;
		  /* 821BD794h */ case    2:  		/* srw R11, R11, R10 */
		/* 821BD794h case    2:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821BD794h case    2:*/		return 0x821BD798;
		  /* 821BD798h */ case    3:  		/* rlwinm R11, R11, 0, 28, 31 */
		/* 821BD798h case    3:*/		cpu::op::rlwinm<0,0,28,31>(regs,&regs.R11,regs.R11);
		/* 821BD798h case    3:*/		return 0x821BD79C;
		  /* 821BD79Ch */ case    4:  		/* rlwinm. R10, R11, 0, 29, 29 */
		/* 821BD79Ch case    4:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R11);
		/* 821BD79Ch case    4:*/		return 0x821BD7A0;
		  /* 821BD7A0h */ case    5:  		/* bclr 12, CR0_EQ */
		/* 821BD7A0h case    5:*/		if ( regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 821BD7A0h case    5:*/		return 0x821BD7A4;
	}
	return 0x821BD7A4;
} // Block from 821BD78Ch-821BD7A4h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BD7A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD7A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD7A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD7A4);
		  /* 821BD7A4h */ case    0:  		/* rlwinm R11, R11, 0, 30, 30 */
		/* 821BD7A4h case    0:*/		cpu::op::rlwinm<0,0,30,30>(regs,&regs.R11,regs.R11);
		/* 821BD7A4h case    0:*/		return 0x821BD7A8;
		  /* 821BD7A8h */ case    1:  		/* cntlzw R11, R11 */
		/* 821BD7A8h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 821BD7A8h case    1:*/		return 0x821BD7AC;
		  /* 821BD7ACh */ case    2:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 821BD7ACh case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 821BD7ACh case    2:*/		return 0x821BD7B0;
		  /* 821BD7B0h */ case    3:  		/* xori R11, R11, 1 */
		/* 821BD7B0h case    3:*/		cpu::op::xori<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821BD7B0h case    3:*/		return 0x821BD7B4;
		  /* 821BD7B4h */ case    4:  		/* addi R3, R11, 1 */
		/* 821BD7B4h case    4:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x1);
		/* 821BD7B4h case    4:*/		return 0x821BD7B8;
		  /* 821BD7B8h */ case    5:  		/* bclr 20, CR0_LT */
		/* 821BD7B8h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BD7B8h case    5:*/		return 0x821BD7BC;
	}
	return 0x821BD7BC;
} // Block from 821BD7A4h-821BD7BCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BD7BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD7BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD7BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD7BC);
		  /* 821BD7BCh */ case    0:  		/* nop */
		/* 821BD7BCh case    0:*/		cpu::op::nop();
		/* 821BD7BCh case    0:*/		return 0x821BD7C0;
	}
	return 0x821BD7C0;
} // Block from 821BD7BCh-821BD7C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BD7C0h
// Function '?GetConstantValue_InAnyPhase@Instruction@D3DXShader@@QAANI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD7C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD7C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD7C0);
		  /* 821BD7C0h */ case    0:  		/* cmpwi CR6, R3, 0 */
		/* 821BD7C0h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000000);
		/* 821BD7C0h case    0:*/		return 0x821BD7C4;
		  /* 821BD7C4h */ case    1:  		/* bc 12, CR6_EQ, 12 */
		/* 821BD7C4h case    1:*/		if ( regs.CR[6].eq ) { return 0x821BD7D0;  }
		/* 821BD7C4h case    1:*/		return 0x821BD7C8;
		  /* 821BD7C8h */ case    2:  		/* cmpwi CR6, R4, 0 */
		/* 821BD7C8h case    2:*/		cpu::op::cmpwi<6>(regs,regs.R4,0x00000000);
		/* 821BD7C8h case    2:*/		return 0x821BD7CC;
		  /* 821BD7CCh */ case    3:  		/* bclr 4, CR6_EQ */
		/* 821BD7CCh case    3:*/		if ( !regs.CR[6].eq ) { return (uint32)regs.LR; }
		/* 821BD7CCh case    3:*/		return 0x821BD7D0;
	}
	return 0x821BD7D0;
} // Block from 821BD7C0h-821BD7D0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BD7D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD7D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD7D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD7D0);
		  /* 821BD7D0h */ case    0:  		/* li R3, 0 */
		/* 821BD7D0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821BD7D0h case    0:*/		return 0x821BD7D4;
		  /* 821BD7D4h */ case    1:  		/* bclr 20, CR0_LT */
		/* 821BD7D4h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BD7D4h case    1:*/		return 0x821BD7D8;
	}
	return 0x821BD7D8;
} // Block from 821BD7D0h-821BD7D8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BD7D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD7D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD7D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD7D8);
		  /* 821BD7D8h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 821BD7D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821BD7D8h case    0:*/		return 0x821BD7DC;
		  /* 821BD7DCh */ case    1:  		/* lwz R10, <#[R4]> */
		/* 821BD7DCh case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000000) );
		/* 821BD7DCh case    1:*/		return 0x821BD7E0;
		  /* 821BD7E0h */ case    2:  		/* lwz R9, <#[R11 + 4]> */
		/* 821BD7E0h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 821BD7E0h case    2:*/		return 0x821BD7E4;
		  /* 821BD7E4h */ case    3:  		/* lwz R8, <#[R10 + 4]> */
		/* 821BD7E4h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 821BD7E4h case    3:*/		return 0x821BD7E8;
		  /* 821BD7E8h */ case    4:  		/* lwz R10, <#[R10 + 48]> */
		/* 821BD7E8h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000030) );
		/* 821BD7E8h case    4:*/		return 0x821BD7EC;
		  /* 821BD7ECh */ case    5:  		/* lwz R11, <#[R11 + 48]> */
		/* 821BD7ECh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 821BD7ECh case    5:*/		return 0x821BD7F0;
		  /* 821BD7F0h */ case    6:  		/* lwz R9, <#[R9 + 68]> */
		/* 821BD7F0h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000044) );
		/* 821BD7F0h case    6:*/		return 0x821BD7F4;
		  /* 821BD7F4h */ case    7:  		/* lwz R8, <#[R8 + 68]> */
		/* 821BD7F4h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000044) );
		/* 821BD7F4h case    7:*/		return 0x821BD7F8;
		  /* 821BD7F8h */ case    8:  		/* rlwinm R9, R9, 0, 4, 31 */
		/* 821BD7F8h case    8:*/		cpu::op::rlwinm<0,0,4,31>(regs,&regs.R9,regs.R9);
		/* 821BD7F8h case    8:*/		return 0x821BD7FC;
		  /* 821BD7FCh */ case    9:  		/* rlwinm R8, R8, 0, 4, 31 */
		/* 821BD7FCh case    9:*/		cpu::op::rlwinm<0,0,4,31>(regs,&regs.R8,regs.R8);
		/* 821BD7FCh case    9:*/		return 0x821BD800;
		  /* 821BD800h */ case   10:  		/* mullw R11, R9, R11 */
		/* 821BD800h case   10:*/		cpu::op::mullw<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 821BD800h case   10:*/		return 0x821BD804;
		  /* 821BD804h */ case   11:  		/* mullw R10, R8, R10 */
		/* 821BD804h case   11:*/		cpu::op::mullw<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 821BD804h case   11:*/		return 0x821BD808;
		  /* 821BD808h */ case   12:  		/* subf R3, R11, R10 */
		/* 821BD808h case   12:*/		cpu::op::subf<0>(regs,&regs.R3,regs.R11,regs.R10);
		/* 821BD808h case   12:*/		return 0x821BD80C;
		  /* 821BD80Ch */ case   13:  		/* bclr 20, CR0_LT */
		/* 821BD80Ch case   13:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BD80Ch case   13:*/		return 0x821BD810;
	}
	return 0x821BD810;
} // Block from 821BD7D8h-821BD810h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821BD810h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD810( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD810) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD810);
		  /* 821BD810h */ case    0:  		/* lwz R11, <#[R3]> */
		/* 821BD810h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821BD810h case    0:*/		return 0x821BD814;
		  /* 821BD814h */ case    1:  		/* rlwinm. R10, R11, 0, 30, 30 */
		/* 821BD814h case    1:*/		cpu::op::rlwinm<1,0,30,30>(regs,&regs.R10,regs.R11);
		/* 821BD814h case    1:*/		return 0x821BD818;
		  /* 821BD818h */ case    2:  		/* bc 12, CR0_EQ, 12 */
		/* 821BD818h case    2:*/		if ( regs.CR[0].eq ) { return 0x821BD824;  }
		/* 821BD818h case    2:*/		return 0x821BD81C;
		  /* 821BD81Ch */ case    3:  		/* li R3, 0 */
		/* 821BD81Ch case    3:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821BD81Ch case    3:*/		return 0x821BD820;
		  /* 821BD820h */ case    4:  		/* bclr 20, CR0_LT */
		/* 821BD820h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BD820h case    4:*/		return 0x821BD824;
	}
	return 0x821BD824;
} // Block from 821BD810h-821BD824h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BD824h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD824( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD824) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD824);
		  /* 821BD824h */ case    0:  		/* rlwinm. R10, R11, 0, 29, 29 */
		/* 821BD824h case    0:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R10,regs.R11);
		/* 821BD824h case    0:*/		return 0x821BD828;
		  /* 821BD828h */ case    1:  		/* bc 12, CR0_EQ, 56 */
		/* 821BD828h case    1:*/		if ( regs.CR[0].eq ) { return 0x821BD860;  }
		/* 821BD828h case    1:*/		return 0x821BD82C;
		  /* 821BD82Ch */ case    2:  		/* rlwinm. R10, R4, 0, 24, 31 */
		/* 821BD82Ch case    2:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R4);
		/* 821BD82Ch case    2:*/		return 0x821BD830;
		  /* 821BD830h */ case    3:  		/* bc 12, CR0_EQ, -20 */
		/* 821BD830h case    3:*/		if ( regs.CR[0].eq ) { return 0x821BD81C;  }
		/* 821BD830h case    3:*/		return 0x821BD834;
		  /* 821BD834h */ case    4:  		/* lis R10, -32256 */
		/* 821BD834h case    4:*/		cpu::op::lis<0>(regs,&regs.R10,0xFFFF8200);
		/* 821BD834h case    4:*/		return 0x821BD838;
		  /* 821BD838h */ case    5:  		/* lfd FR0, <#[R10 + 1808]> */
		/* 821BD838h case    5:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R10 + 0x00000710) );
		/* 821BD838h case    5:*/		return 0x821BD83C;
		  /* 821BD83Ch */ case    6:  		/* fcmpu CR6, FR1, FR0 */
		/* 821BD83Ch case    6:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 821BD83Ch case    6:*/		return 0x821BD840;
		  /* 821BD840h */ case    7:  		/* bc 4, CR6_GT, 12 */
		/* 821BD840h case    7:*/		if ( !regs.CR[6].gt ) { return 0x821BD84C;  }
		/* 821BD840h case    7:*/		return 0x821BD844;
		  /* 821BD844h */ case    8:  		/* rlwinm. R10, R11, 0, 27, 27 */
		/* 821BD844h case    8:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R11);
		/* 821BD844h case    8:*/		return 0x821BD848;
		  /* 821BD848h */ case    9:  		/* bc 12, CR0_EQ, -44 */
		/* 821BD848h case    9:*/		if ( regs.CR[0].eq ) { return 0x821BD81C;  }
		/* 821BD848h case    9:*/		return 0x821BD84C;
	}
	return 0x821BD84C;
} // Block from 821BD824h-821BD84Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 821BD84Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD84C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD84C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD84C);
		  /* 821BD84Ch */ case    0:  		/* fcmpu CR6, FR1, FR0 */
		/* 821BD84Ch case    0:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 821BD84Ch case    0:*/		return 0x821BD850;
		  /* 821BD850h */ case    1:  		/* bc 4, CR6_LT, 32 */
		/* 821BD850h case    1:*/		if ( !regs.CR[6].lt ) { return 0x821BD870;  }
		/* 821BD850h case    1:*/		return 0x821BD854;
		  /* 821BD854h */ case    2:  		/* rlwinm. R11, R11, 0, 28, 28 */
		/* 821BD854h case    2:*/		cpu::op::rlwinm<1,0,28,28>(regs,&regs.R11,regs.R11);
		/* 821BD854h case    2:*/		return 0x821BD858;
		  /* 821BD858h */ case    3:  		/* bc 4, CR0_EQ, 24 */
		/* 821BD858h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BD870;  }
		/* 821BD858h case    3:*/		return 0x821BD85C;
		  /* 821BD85Ch */ case    4:  		/* b -64 */
		/* 821BD85Ch case    4:*/		return 0x821BD81C;
		/* 821BD85Ch case    4:*/		return 0x821BD860;
	}
	return 0x821BD860;
} // Block from 821BD84Ch-821BD860h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BD860h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD860( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD860) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD860);
		  /* 821BD860h */ case    0:  		/* lfd FR0, <#[R3 + 8]> */
		/* 821BD860h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R3 + 0x00000008) );
		/* 821BD860h case    0:*/		return 0x821BD864;
		  /* 821BD864h */ case    1:  		/* lfd FR13, <#[R3 + 16]> */
		/* 821BD864h case    1:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R3 + 0x00000010) );
		/* 821BD864h case    1:*/		return 0x821BD868;
		  /* 821BD868h */ case    2:  		/* fcmpu CR6, FR0, FR13 */
		/* 821BD868h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR13);
		/* 821BD868h case    2:*/		return 0x821BD86C;
		  /* 821BD86Ch */ case    3:  		/* bc 4, CR6_EQ, -80 */
		/* 821BD86Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x821BD81C;  }
		/* 821BD86Ch case    3:*/		return 0x821BD870;
	}
	return 0x821BD870;
} // Block from 821BD860h-821BD870h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BD870h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD870( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD870) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD870);
		  /* 821BD870h */ case    0:  		/* stfd FR0, <#[R6]> */
		/* 821BD870h case    0:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R6 + 0x00000000) );
		/* 821BD870h case    0:*/		return 0x821BD874;
		  /* 821BD874h */ case    1:  		/* li R3, 1 */
		/* 821BD874h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821BD874h case    1:*/		return 0x821BD878;
	}
	return 0x821BD878;
} // Block from 821BD870h-821BD878h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BD878h
// Function '?InvalidateResultBounds@Instruction@D3DXShader@@QAAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD878( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD878) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD878);
		  /* 821BD878h */ case    0:  		/* bclr 20, CR0_LT */
		/* 821BD878h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BD878h case    0:*/		return 0x821BD87C;
	}
	return 0x821BD87C;
} // Block from 821BD878h-821BD87Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BD87Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD87C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD87C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD87C);
		  /* 821BD87Ch */ case    0:  		/* nop */
		/* 821BD87Ch case    0:*/		cpu::op::nop();
		/* 821BD87Ch case    0:*/		return 0x821BD880;
		  /* 821BD880h */ case    1:  		/* lwz R10, <#[R4 + 64]> */
		/* 821BD880h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000040) );
		/* 821BD880h case    1:*/		return 0x821BD884;
		  /* 821BD884h */ case    2:  		/* b 52 */
		/* 821BD884h case    2:*/		return 0x821BD8B8;
		/* 821BD884h case    2:*/		return 0x821BD888;
		  /* 821BD888h */ case    3:  		/* lwz R11, <#[R10 + 12]> */
		/* 821BD888h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000000C) );
		/* 821BD888h case    3:*/		return 0x821BD88C;
		  /* 821BD88Ch */ case    4:  		/* rlwinm. R11, R11, 0, 5, 5 */
		/* 821BD88Ch case    4:*/		cpu::op::rlwinm<1,0,5,5>(regs,&regs.R11,regs.R11);
		/* 821BD88Ch case    4:*/		return 0x821BD890;
		  /* 821BD890h */ case    5:  		/* bc 12, CR0_EQ, 36 */
		/* 821BD890h case    5:*/		if ( regs.CR[0].eq ) { return 0x821BD8B4;  }
		/* 821BD890h case    5:*/		return 0x821BD894;
		  /* 821BD894h */ case    6:  		/* lwz R11, <#[R10]> */
		/* 821BD894h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 821BD894h case    6:*/		return 0x821BD898;
		  /* 821BD898h */ case    7:  		/* b 20 */
		/* 821BD898h case    7:*/		return 0x821BD8AC;
		/* 821BD898h case    7:*/		return 0x821BD89C;
		  /* 821BD89Ch */ case    8:  		/* lwz R9, <#[R11 + 4]> */
		/* 821BD89Ch case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 821BD89Ch case    8:*/		return 0x821BD8A0;
		  /* 821BD8A0h */ case    9:  		/* cmplw CR6, R9, R5 */
		/* 821BD8A0h case    9:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R5);
		/* 821BD8A0h case    9:*/		return 0x821BD8A4;
		  /* 821BD8A4h */ case   10:  		/* bc 12, CR6_EQ, 36 */
		/* 821BD8A4h case   10:*/		if ( regs.CR[6].eq ) { return 0x821BD8C8;  }
		/* 821BD8A4h case   10:*/		return 0x821BD8A8;
		  /* 821BD8A8h */ case   11:  		/* lwz R11, <#[R11 + 8]> */
		/* 821BD8A8h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821BD8A8h case   11:*/		return 0x821BD8AC;
	}
	return 0x821BD8AC;
} // Block from 821BD87Ch-821BD8ACh (12 instructions)

//////////////////////////////////////////////////////
// Block at 821BD8ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD8AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD8AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD8AC);
		  /* 821BD8ACh */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 821BD8ACh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BD8ACh case    0:*/		return 0x821BD8B0;
		  /* 821BD8B0h */ case    1:  		/* bc 4, CR6_EQ, -20 */
		/* 821BD8B0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BD89C;  }
		/* 821BD8B0h case    1:*/		return 0x821BD8B4;
	}
	return 0x821BD8B4;
} // Block from 821BD8ACh-821BD8B4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BD8B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD8B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD8B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD8B4);
		  /* 821BD8B4h */ case    0:  		/* lwz R10, <#[R10 + 20]> */
		/* 821BD8B4h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000014) );
		/* 821BD8B4h case    0:*/		return 0x821BD8B8;
	}
	return 0x821BD8B8;
} // Block from 821BD8B4h-821BD8B8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BD8B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD8B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD8B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD8B8);
		  /* 821BD8B8h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 821BD8B8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821BD8B8h case    0:*/		return 0x821BD8BC;
		  /* 821BD8BCh */ case    1:  		/* bc 4, CR6_EQ, -52 */
		/* 821BD8BCh case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BD888;  }
		/* 821BD8BCh case    1:*/		return 0x821BD8C0;
		  /* 821BD8C0h */ case    2:  		/* li R3, 0 */
		/* 821BD8C0h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821BD8C0h case    2:*/		return 0x821BD8C4;
		  /* 821BD8C4h */ case    3:  		/* bclr 20, CR0_LT */
		/* 821BD8C4h case    3:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BD8C4h case    3:*/		return 0x821BD8C8;
	}
	return 0x821BD8C8;
} // Block from 821BD8B8h-821BD8C8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BD8C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD8C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD8C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD8C8);
		  /* 821BD8C8h */ case    0:  		/* li R3, 1 */
		/* 821BD8C8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821BD8C8h case    0:*/		return 0x821BD8CC;
		  /* 821BD8CCh */ case    1:  		/* bclr 20, CR0_LT */
		/* 821BD8CCh case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BD8CCh case    1:*/		return 0x821BD8D0;
	}
	return 0x821BD8D0;
} // Block from 821BD8C8h-821BD8D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BD8D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD8D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD8D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD8D0);
		  /* 821BD8D0h */ case    0:  		/* mr R10, R3 */
		/* 821BD8D0h case    0:*/		regs.R10 = regs.R3;
		/* 821BD8D0h case    0:*/		return 0x821BD8D4;
		  /* 821BD8D4h */ case    1:  		/* li R3, -1 */
		/* 821BD8D4h case    1:*/		cpu::op::li<0>(regs,&regs.R3,0xFFFFFFFF);
		/* 821BD8D4h case    1:*/		return 0x821BD8D8;
	}
	return 0x821BD8D8;
} // Block from 821BD8D0h-821BD8D8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BD8D8h
// Function '?GetConstraintFlags@Instruction@D3DXShader@@QAAII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD8D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD8D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD8D8);
		  /* 821BD8D8h */ case    0:  		/* rlwinm R9, R4, 0, 27, 31 */
		/* 821BD8D8h case    0:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R4);
		/* 821BD8D8h case    0:*/		return 0x821BD8DC;
		  /* 821BD8DCh */ case    1:  		/* rlwinm R11, R4, 27, 5, 31 */
		/* 821BD8DCh case    1:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R4);
		/* 821BD8DCh case    1:*/		return 0x821BD8E0;
		  /* 821BD8E0h */ case    2:  		/* slw R8, R3, R9 */
		/* 821BD8E0h case    2:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R3,regs.R9);
		/* 821BD8E0h case    2:*/		return 0x821BD8E4;
		  /* 821BD8E4h */ case    3:  		/* cmplwi CR6, R11, 1 */
		/* 821BD8E4h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 821BD8E4h case    3:*/		return 0x821BD8E8;
		  /* 821BD8E8h */ case    4:  		/* bclr 4, CR6_LT */
		/* 821BD8E8h case    4:*/		if ( !regs.CR[6].lt ) { return (uint32)regs.LR; }
		/* 821BD8E8h case    4:*/		return 0x821BD8EC;
	}
	return 0x821BD8EC;
} // Block from 821BD8D8h-821BD8ECh (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BD8ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD8EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD8EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD8EC);
		  /* 821BD8ECh */ case    0:  		/* rlwinm R9, R11, 2, 0, 29 */
		/* 821BD8ECh case    0:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R9,regs.R11);
		/* 821BD8ECh case    0:*/		return 0x821BD8F0;
	}
	return 0x821BD8F0;
} // Block from 821BD8ECh-821BD8F0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BD8F0h
// Function '?ReplaceConstraintFlags@Instruction@D3DXShader@@QAA_NIII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD8F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD8F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD8F0);
		  /* 821BD8F0h */ case    0:  		/* add R10, R9, R10 */
		/* 821BD8F0h case    0:*/		cpu::op::add<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 821BD8F0h case    0:*/		return 0x821BD8F4;
		  /* 821BD8F4h */ case    1:  		/* lwz R9, <#[R10]> */
		/* 821BD8F4h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821BD8F4h case    1:*/		return 0x821BD8F8;
		  /* 821BD8F8h */ case    2:  		/* and. R9, R9, R8 */
		/* 821BD8F8h case    2:*/		cpu::op::and<1>(regs,&regs.R9,regs.R9,regs.R8);
		/* 821BD8F8h case    2:*/		return 0x821BD8FC;
		  /* 821BD8FCh */ case    3:  		/* bc 4, CR0_EQ, 28 */
		/* 821BD8FCh case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BD918;  }
		/* 821BD8FCh case    3:*/		return 0x821BD900;
		  /* 821BD900h */ case    4:  		/* addi R11, R11, 1 */
		/* 821BD900h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821BD900h case    4:*/		return 0x821BD904;
		  /* 821BD904h */ case    5:  		/* mr R8, R3 */
		/* 821BD904h case    5:*/		regs.R8 = regs.R3;
		/* 821BD904h case    5:*/		return 0x821BD908;
		  /* 821BD908h */ case    6:  		/* addi R10, R10, 4 */
		/* 821BD908h case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821BD908h case    6:*/		return 0x821BD90C;
		  /* 821BD90Ch */ case    7:  		/* cmplwi CR6, R11, 1 */
		/* 821BD90Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 821BD90Ch case    7:*/		return 0x821BD910;
		  /* 821BD910h */ case    8:  		/* bc 12, CR6_LT, -28 */
		/* 821BD910h case    8:*/		if ( regs.CR[6].lt ) { return 0x821BD8F4;  }
		/* 821BD910h case    8:*/		return 0x821BD914;
		  /* 821BD914h */ case    9:  		/* bclr 20, CR0_LT */
		/* 821BD914h case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BD914h case    9:*/		return 0x821BD918;
	}
	return 0x821BD918;
} // Block from 821BD8F0h-821BD918h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821BD918h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD918( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD918) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD918);
		  /* 821BD918h */ case    0:  		/* addi R10, R9, -1 */
		/* 821BD918h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R9,0xFFFFFFFF);
		/* 821BD918h case    0:*/		return 0x821BD91C;
		  /* 821BD91Ch */ case    1:  		/* rlwinm R11, R11, 5, 0, 26 */
		/* 821BD91Ch case    1:*/		cpu::op::rlwinm<0,5,0,26>(regs,&regs.R11,regs.R11);
		/* 821BD91Ch case    1:*/		return 0x821BD920;
		  /* 821BD920h */ case    2:  		/* andc R10, R9, R10 */
		/* 821BD920h case    2:*/		cpu::op::andc<0>(regs,&regs.R10,regs.R9,regs.R10);
		/* 821BD920h case    2:*/		return 0x821BD924;
		  /* 821BD924h */ case    3:  		/* cntlzw R10, R10 */
		/* 821BD924h case    3:*/		cpu::op::cntlzw<0>(regs,&regs.R10,regs.R10);
		/* 821BD924h case    3:*/		return 0x821BD928;
		  /* 821BD928h */ case    4:  		/* subf R11, R10, R11 */
		/* 821BD928h case    4:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821BD928h case    4:*/		return 0x821BD92C;
		  /* 821BD92Ch */ case    5:  		/* addi R3, R11, 31 */
		/* 821BD92Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0x1F);
		/* 821BD92Ch case    5:*/		return 0x821BD930;
	}
	return 0x821BD930;
} // Block from 821BD918h-821BD930h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BD930h
// Function '?ReplaceConstraintFlags@Instruction@D3DXShader@@QAA_NII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD930( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD930) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD930);
		  /* 821BD930h */ case    0:  		/* bclr 20, CR0_LT */
		/* 821BD930h case    0:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BD930h case    0:*/		return 0x821BD934;
	}
	return 0x821BD934;
} // Block from 821BD930h-821BD934h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BD934h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD934( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD934) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD934);
		  /* 821BD934h */ case    0:  		/* nop */
		/* 821BD934h case    0:*/		cpu::op::nop();
		/* 821BD934h case    0:*/		return 0x821BD938;
		  /* 821BD938h */ case    1:  		/* lwz R10, <#[R3 + 8]> */
		/* 821BD938h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 821BD938h case    1:*/		return 0x821BD93C;
		  /* 821BD93Ch */ case    2:  		/* rlwinm R11, R10, 25, 25, 31 */
		/* 821BD93Ch case    2:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R10);
		/* 821BD93Ch case    2:*/		return 0x821BD940;
		  /* 821BD940h */ case    3:  		/* cmplwi CR6, R11, 97 */
		/* 821BD940h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000061);
		/* 821BD940h case    3:*/		return 0x821BD944;
		  /* 821BD944h */ case    4:  		/* bc 12, CR6_EQ, 64 */
		/* 821BD944h case    4:*/		if ( regs.CR[6].eq ) { return 0x821BD984;  }
		/* 821BD944h case    4:*/		return 0x821BD948;
		  /* 821BD948h */ case    5:  		/* cmplwi CR6, R11, 99 */
		/* 821BD948h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000063);
		/* 821BD948h case    5:*/		return 0x821BD94C;
		  /* 821BD94Ch */ case    6:  		/* bc 12, CR6_EQ, 56 */
		/* 821BD94Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x821BD984;  }
		/* 821BD94Ch case    6:*/		return 0x821BD950;
		  /* 821BD950h */ case    7:  		/* cmplwi CR6, R11, 100 */
		/* 821BD950h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000064);
		/* 821BD950h case    7:*/		return 0x821BD954;
		  /* 821BD954h */ case    8:  		/* bc 12, CR6_EQ, 48 */
		/* 821BD954h case    8:*/		if ( regs.CR[6].eq ) { return 0x821BD984;  }
		/* 821BD954h case    8:*/		return 0x821BD958;
		  /* 821BD958h */ case    9:  		/* cmplwi CR6, R11, 96 */
		/* 821BD958h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000060);
		/* 821BD958h case    9:*/		return 0x821BD95C;
		  /* 821BD95Ch */ case   10:  		/* bc 4, CR6_EQ, 24 */
		/* 821BD95Ch case   10:*/		if ( !regs.CR[6].eq ) { return 0x821BD974;  }
		/* 821BD95Ch case   10:*/		return 0x821BD960;
		  /* 821BD960h */ case   11:  		/* rlwinm R11, R10, 0, 10, 12 */
		/* 821BD960h case   11:*/		cpu::op::rlwinm<0,0,10,12>(regs,&regs.R11,regs.R10);
		/* 821BD960h case   11:*/		return 0x821BD964;
		  /* 821BD964h */ case   12:  		/* lis R10, 8 */
		/* 821BD964h case   12:*/		cpu::op::lis<0>(regs,&regs.R10,0x8);
		/* 821BD964h case   12:*/		return 0x821BD968;
		  /* 821BD968h */ case   13:  		/* cmplw CR6, R11, R10 */
		/* 821BD968h case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821BD968h case   13:*/		return 0x821BD96C;
		  /* 821BD96Ch */ case   14:  		/* li R11, 1 */
		/* 821BD96Ch case   14:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821BD96Ch case   14:*/		return 0x821BD970;
		  /* 821BD970h */ case   15:  		/* bc 12, CR6_GT, 8 */
		/* 821BD970h case   15:*/		if ( regs.CR[6].gt ) { return 0x821BD978;  }
		/* 821BD970h case   15:*/		return 0x821BD974;
	}
	return 0x821BD974;
} // Block from 821BD934h-821BD974h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821BD974h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD974( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD974) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD974);
		  /* 821BD974h */ case    0:  		/* li R11, 0 */
		/* 821BD974h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BD974h case    0:*/		return 0x821BD978;
	}
	return 0x821BD978;
} // Block from 821BD974h-821BD978h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BD978h
// Function '?SetConstraintFlags@Instruction@D3DXShader@@QAA_NII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD978( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD978) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD978);
		  /* 821BD978h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821BD978h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821BD978h case    0:*/		return 0x821BD97C;
		  /* 821BD97Ch */ case    1:  		/* li R11, 0 */
		/* 821BD97Ch case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BD97Ch case    1:*/		return 0x821BD980;
		  /* 821BD980h */ case    2:  		/* bc 12, CR0_EQ, 8 */
		/* 821BD980h case    2:*/		if ( regs.CR[0].eq ) { return 0x821BD988;  }
		/* 821BD980h case    2:*/		return 0x821BD984;
	}
	return 0x821BD984;
} // Block from 821BD978h-821BD984h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BD984h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD984( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD984) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD984);
		  /* 821BD984h */ case    0:  		/* li R11, 1 */
		/* 821BD984h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821BD984h case    0:*/		return 0x821BD988;
	}
	return 0x821BD988;
} // Block from 821BD984h-821BD988h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BD988h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD988( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD988) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD988);
		  /* 821BD988h */ case    0:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 821BD988h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 821BD988h case    0:*/		return 0x821BD98C;
		  /* 821BD98Ch */ case    1:  		/* bclr 20, CR0_LT */
		/* 821BD98Ch case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BD98Ch case    1:*/		return 0x821BD990;
	}
	return 0x821BD990;
} // Block from 821BD988h-821BD990h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BD990h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD990( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD990) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD990);
		  /* 821BD990h */ case    0:  		/* mfspr R12, LR */
		/* 821BD990h case    0:*/		regs.R12 = regs.LR;
		/* 821BD990h case    0:*/		return 0x821BD994;
		  /* 821BD994h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821BD994h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821BD994h case    1:*/		return 0x821BD998;
		  /* 821BD998h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 821BD998h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821BD998h case    2:*/		return 0x821BD99C;
		  /* 821BD99Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 821BD99Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 821BD99Ch case    3:*/		return 0x821BD9A0;
		  /* 821BD9A0h */ case    4:  		/* mr R31, R3 */
		/* 821BD9A0h case    4:*/		regs.R31 = regs.R3;
		/* 821BD9A0h case    4:*/		return 0x821BD9A4;
		  /* 821BD9A4h */ case    5:  		/* mr R3, R4 */
		/* 821BD9A4h case    5:*/		regs.R3 = regs.R4;
		/* 821BD9A4h case    5:*/		return 0x821BD9A8;
		  /* 821BD9A8h */ case    6:  		/* lwz R11, <#[R31 + 8]> */
		/* 821BD9A8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821BD9A8h case    6:*/		return 0x821BD9AC;
		  /* 821BD9ACh */ case    7:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821BD9ACh case    7:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821BD9ACh case    7:*/		return 0x821BD9B0;
	}
	return 0x821BD9B0;
} // Block from 821BD990h-821BD9B0h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821BD9B0h
// Function '?SetAlwaysGEZero@Instruction@D3DXShader@@QAA_NI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD9B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD9B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD9B0);
		  /* 821BD9B0h */ case    0:  		/* cmplwi CR6, R11, 96 */
		/* 821BD9B0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000060);
		/* 821BD9B0h case    0:*/		return 0x821BD9B4;
		  /* 821BD9B4h */ case    1:  		/* bc 4, CR6_EQ, 36 */
		/* 821BD9B4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BD9D8;  }
		/* 821BD9B4h case    1:*/		return 0x821BD9B8;
		  /* 821BD9B8h */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 821BD9B8h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821BD9B8h case    2:*/		return 0x821BD9BC;
		  /* 821BD9BCh */ case    3:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 821BD9BCh case    3:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 821BD9BCh case    3:*/		return 0x821BD9C0;
		  /* 821BD9C0h */ case    4:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 821BD9C0h case    4:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 821BD9C0h case    4:*/		return 0x821BD9C4;
		  /* 821BD9C4h */ case    5:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 821BD9C4h case    5:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 821BD9C4h case    5:*/		return 0x821BD9C8;
		  /* 821BD9C8h */ case    6:  		/* bl -365976 */
		/* 821BD9C8h case    6:*/		regs.LR = 0x821BD9CC; return 0x82164430;
		/* 821BD9C8h case    6:*/		return 0x821BD9CC;
		  /* 821BD9CCh */ case    7:  		/* addi R11, R31, -4 */
		/* 821BD9CCh case    7:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFFC);
		/* 821BD9CCh case    7:*/		return 0x821BD9D0;
		  /* 821BD9D0h */ case    8:  		/* lwzx R3, <#[R3 + R11]> */
		/* 821BD9D0h case    8:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 821BD9D0h case    8:*/		return 0x821BD9D4;
		  /* 821BD9D4h */ case    9:  		/* b 48 */
		/* 821BD9D4h case    9:*/		return 0x821BDA04;
		/* 821BD9D4h case    9:*/		return 0x821BD9D8;
	}
	return 0x821BD9D8;
} // Block from 821BD9B0h-821BD9D8h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821BD9D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD9D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD9D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD9D8);
		  /* 821BD9D8h */ case    0:  		/* cmplwi CR6, R11, 97 */
		/* 821BD9D8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000061);
		/* 821BD9D8h case    0:*/		return 0x821BD9DC;
		  /* 821BD9DCh */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 821BD9DCh case    1:*/		if ( regs.CR[6].eq ) { return 0x821BD9F4;  }
		/* 821BD9DCh case    1:*/		return 0x821BD9E0;
		  /* 821BD9E0h */ case    2:  		/* cmplwi CR6, R11, 99 */
		/* 821BD9E0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000063);
		/* 821BD9E0h case    2:*/		return 0x821BD9E4;
		  /* 821BD9E4h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 821BD9E4h case    3:*/		if ( regs.CR[6].eq ) { return 0x821BD9F4;  }
		/* 821BD9E4h case    3:*/		return 0x821BD9E8;
		  /* 821BD9E8h */ case    4:  		/* cmplwi CR6, R11, 100 */
		/* 821BD9E8h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000064);
		/* 821BD9E8h case    4:*/		return 0x821BD9EC;
		  /* 821BD9ECh */ case    5:  		/* li R11, 0 */
		/* 821BD9ECh case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BD9ECh case    5:*/		return 0x821BD9F0;
		  /* 821BD9F0h */ case    6:  		/* bc 4, CR6_EQ, 8 */
		/* 821BD9F0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821BD9F8;  }
		/* 821BD9F0h case    6:*/		return 0x821BD9F4;
	}
	return 0x821BD9F4;
} // Block from 821BD9D8h-821BD9F4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BD9F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD9F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD9F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD9F4);
		  /* 821BD9F4h */ case    0:  		/* li R11, 1 */
		/* 821BD9F4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821BD9F4h case    0:*/		return 0x821BD9F8;
	}
	return 0x821BD9F8;
} // Block from 821BD9F4h-821BD9F8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BD9F8h
// Function '?GetConstantValue@Dependency@D3DXShader@@QAANI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BD9F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BD9F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BD9F8);
		  /* 821BD9F8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821BD9F8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821BD9F8h case    0:*/		return 0x821BD9FC;
		  /* 821BD9FCh */ case    1:  		/* bc 4, CR0_EQ, -68 */
		/* 821BD9FCh case    1:*/		if ( !regs.CR[0].eq ) { return 0x821BD9B8;  }
		/* 821BD9FCh case    1:*/		return 0x821BDA00;
		  /* 821BDA00h */ case    2:  		/* li R3, 0 */
		/* 821BDA00h case    2:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821BDA00h case    2:*/		return 0x821BDA04;
	}
	return 0x821BDA04;
} // Block from 821BD9F8h-821BDA04h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BDA04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDA04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDA04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDA04);
		  /* 821BDA04h */ case    0:  		/* addi R1, R1, 96 */
		/* 821BDA04h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 821BDA04h case    0:*/		return 0x821BDA08;
		  /* 821BDA08h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 821BDA08h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821BDA08h case    1:*/		return 0x821BDA0C;
		  /* 821BDA0Ch */ case    2:  		/* mtspr LR, R12 */
		/* 821BDA0Ch case    2:*/		regs.LR = regs.R12;
		/* 821BDA0Ch case    2:*/		return 0x821BDA10;
		  /* 821BDA10h */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 821BDA10h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821BDA10h case    3:*/		return 0x821BDA14;
		  /* 821BDA14h */ case    4:  		/* bclr 20, CR0_LT */
		/* 821BDA14h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BDA14h case    4:*/		return 0x821BDA18;
	}
	return 0x821BDA18;
} // Block from 821BDA04h-821BDA18h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BDA18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDA18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDA18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDA18);
		  /* 821BDA18h */ case    0:  		/* mfspr R12, LR */
		/* 821BDA18h case    0:*/		regs.R12 = regs.LR;
		/* 821BDA18h case    0:*/		return 0x821BDA1C;
		  /* 821BDA1Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821BDA1Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821BDA1Ch case    1:*/		return 0x821BDA20;
		  /* 821BDA20h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 821BDA20h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821BDA20h case    2:*/		return 0x821BDA24;
		  /* 821BDA24h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 821BDA24h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 821BDA24h case    3:*/		return 0x821BDA28;
		  /* 821BDA28h */ case    4:  		/* mr R31, R3 */
		/* 821BDA28h case    4:*/		regs.R31 = regs.R3;
		/* 821BDA28h case    4:*/		return 0x821BDA2C;
		  /* 821BDA2Ch */ case    5:  		/* mr R3, R4 */
		/* 821BDA2Ch case    5:*/		regs.R3 = regs.R4;
		/* 821BDA2Ch case    5:*/		return 0x821BDA30;
		  /* 821BDA30h */ case    6:  		/* li R6, 0 */
		/* 821BDA30h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821BDA30h case    6:*/		return 0x821BDA34;
		  /* 821BDA34h */ case    7:  		/* li R4, 103 */
		/* 821BDA34h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x67);
		/* 821BDA34h case    7:*/		return 0x821BDA38;
		  /* 821BDA38h */ case    8:  		/* lwz R11, <#[R31 + 8]> */
		/* 821BDA38h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821BDA38h case    8:*/		return 0x821BDA3C;
		  /* 821BDA3Ch */ case    9:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 821BDA3Ch case    9:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 821BDA3Ch case    9:*/		return 0x821BDA40;
		  /* 821BDA40h */ case   10:  		/* bl -366096 */
		/* 821BDA40h case   10:*/		regs.LR = 0x821BDA44; return 0x82164430;
		/* 821BDA40h case   10:*/		return 0x821BDA44;
		  /* 821BDA44h */ case   11:  		/* addi R11, R31, -4 */
		/* 821BDA44h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFFC);
		/* 821BDA44h case   11:*/		return 0x821BDA48;
		  /* 821BDA48h */ case   12:  		/* add R3, R3, R11 */
		/* 821BDA48h case   12:*/		cpu::op::add<0>(regs,&regs.R3,regs.R3,regs.R11);
		/* 821BDA48h case   12:*/		return 0x821BDA4C;
		  /* 821BDA4Ch */ case   13:  		/* addi R1, R1, 96 */
		/* 821BDA4Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 821BDA4Ch case   13:*/		return 0x821BDA50;
		  /* 821BDA50h */ case   14:  		/* lwz R12, <#[R1 - 8]> */
		/* 821BDA50h case   14:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821BDA50h case   14:*/		return 0x821BDA54;
		  /* 821BDA54h */ case   15:  		/* mtspr LR, R12 */
		/* 821BDA54h case   15:*/		regs.LR = regs.R12;
		/* 821BDA54h case   15:*/		return 0x821BDA58;
		  /* 821BDA58h */ case   16:  		/* ld R31, <#[R1 - 16]> */
		/* 821BDA58h case   16:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821BDA58h case   16:*/		return 0x821BDA5C;
		  /* 821BDA5Ch */ case   17:  		/* bclr 20, CR0_LT */
		/* 821BDA5Ch case   17:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BDA5Ch case   17:*/		return 0x821BDA60;
	}
	return 0x821BDA60;
} // Block from 821BDA18h-821BDA60h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821BDA60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDA60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDA60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDA60);
		  /* 821BDA60h */ case    0:  		/* mfspr R12, LR */
		/* 821BDA60h case    0:*/		regs.R12 = regs.LR;
		/* 821BDA60h case    0:*/		return 0x821BDA64;
		  /* 821BDA64h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821BDA64h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821BDA64h case    1:*/		return 0x821BDA68;
		  /* 821BDA68h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 821BDA68h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821BDA68h case    2:*/		return 0x821BDA6C;
		  /* 821BDA6Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 821BDA6Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 821BDA6Ch case    3:*/		return 0x821BDA70;
		  /* 821BDA70h */ case    4:  		/* mr R31, R3 */
		/* 821BDA70h case    4:*/		regs.R31 = regs.R3;
		/* 821BDA70h case    4:*/		return 0x821BDA74;
		  /* 821BDA74h */ case    5:  		/* mr R3, R4 */
		/* 821BDA74h case    5:*/		regs.R3 = regs.R4;
		/* 821BDA74h case    5:*/		return 0x821BDA78;
		  /* 821BDA78h */ case    6:  		/* li R6, 0 */
		/* 821BDA78h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821BDA78h case    6:*/		return 0x821BDA7C;
		  /* 821BDA7Ch */ case    7:  		/* li R4, 103 */
		/* 821BDA7Ch case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x67);
		/* 821BDA7Ch case    7:*/		return 0x821BDA80;
		  /* 821BDA80h */ case    8:  		/* lwz R11, <#[R31 + 8]> */
		/* 821BDA80h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821BDA80h case    8:*/		return 0x821BDA84;
		  /* 821BDA84h */ case    9:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 821BDA84h case    9:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 821BDA84h case    9:*/		return 0x821BDA88;
		  /* 821BDA88h */ case   10:  		/* bl -366168 */
		/* 821BDA88h case   10:*/		regs.LR = 0x821BDA8C; return 0x82164430;
		/* 821BDA88h case   10:*/		return 0x821BDA8C;
		  /* 821BDA8Ch */ case   11:  		/* addi R11, R31, -4 */
		/* 821BDA8Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFFC);
		/* 821BDA8Ch case   11:*/		return 0x821BDA90;
	}
	return 0x821BDA90;
} // Block from 821BDA60h-821BDA90h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821BDA90h
// Function '?IsAlwaysGEZero@Dependency@D3DXShader@@QAA_NI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDA90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDA90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDA90);
		  /* 821BDA90h */ case    0:  		/* lwzx R3, <#[R3 + R11]> */
		/* 821BDA90h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 821BDA90h case    0:*/		return 0x821BDA94;
		  /* 821BDA94h */ case    1:  		/* addi R1, R1, 96 */
		/* 821BDA94h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 821BDA94h case    1:*/		return 0x821BDA98;
		  /* 821BDA98h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 821BDA98h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821BDA98h case    2:*/		return 0x821BDA9C;
		  /* 821BDA9Ch */ case    3:  		/* mtspr LR, R12 */
		/* 821BDA9Ch case    3:*/		regs.LR = regs.R12;
		/* 821BDA9Ch case    3:*/		return 0x821BDAA0;
		  /* 821BDAA0h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 821BDAA0h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821BDAA0h case    4:*/		return 0x821BDAA4;
		  /* 821BDAA4h */ case    5:  		/* bclr 20, CR0_LT */
		/* 821BDAA4h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BDAA4h case    5:*/		return 0x821BDAA8;
	}
	return 0x821BDAA8;
} // Block from 821BDA90h-821BDAA8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BDAA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDAA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDAA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDAA8);
		  /* 821BDAA8h */ case    0:  		/* mfspr R12, LR */
		/* 821BDAA8h case    0:*/		regs.R12 = regs.LR;
		/* 821BDAA8h case    0:*/		return 0x821BDAAC;
		  /* 821BDAACh */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821BDAACh case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821BDAACh case    1:*/		return 0x821BDAB0;
		  /* 821BDAB0h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 821BDAB0h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821BDAB0h case    2:*/		return 0x821BDAB4;
		  /* 821BDAB4h */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 821BDAB4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 821BDAB4h case    3:*/		return 0x821BDAB8;
		  /* 821BDAB8h */ case    4:  		/* mr R31, R3 */
		/* 821BDAB8h case    4:*/		regs.R31 = regs.R3;
		/* 821BDAB8h case    4:*/		return 0x821BDABC;
		  /* 821BDABCh */ case    5:  		/* mr R3, R4 */
		/* 821BDABCh case    5:*/		regs.R3 = regs.R4;
		/* 821BDABCh case    5:*/		return 0x821BDAC0;
		  /* 821BDAC0h */ case    6:  		/* li R6, 0 */
		/* 821BDAC0h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821BDAC0h case    6:*/		return 0x821BDAC4;
		  /* 821BDAC4h */ case    7:  		/* li R4, 103 */
		/* 821BDAC4h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0x67);
		/* 821BDAC4h case    7:*/		return 0x821BDAC8;
		  /* 821BDAC8h */ case    8:  		/* lwz R11, <#[R31 + 8]> */
		/* 821BDAC8h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821BDAC8h case    8:*/		return 0x821BDACC;
		  /* 821BDACCh */ case    9:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 821BDACCh case    9:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 821BDACCh case    9:*/		return 0x821BDAD0;
		  /* 821BDAD0h */ case   10:  		/* bl -366240 */
		/* 821BDAD0h case   10:*/		regs.LR = 0x821BDAD4; return 0x82164430;
		/* 821BDAD0h case   10:*/		return 0x821BDAD4;
		  /* 821BDAD4h */ case   11:  		/* addi R11, R31, -4 */
		/* 821BDAD4h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFFC);
		/* 821BDAD4h case   11:*/		return 0x821BDAD8;
		  /* 821BDAD8h */ case   12:  		/* lwzx R11, <#[R3 + R11]> */
		/* 821BDAD8h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 821BDAD8h case   12:*/		return 0x821BDADC;
		  /* 821BDADCh */ case   13:  		/* cmpwi CR6, R11, 0 */
		/* 821BDADCh case   13:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 821BDADCh case   13:*/		return 0x821BDAE0;
	}
	return 0x821BDAE0;
} // Block from 821BDAA8h-821BDAE0h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821BDAE0h
// Function '?IsAlwaysLEZero@Dependency@D3DXShader@@QAA_NI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDAE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDAE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDAE0);
		  /* 821BDAE0h */ case    0:  		/* bc 12, CR6_LT, 16 */
		/* 821BDAE0h case    0:*/		if ( regs.CR[6].lt ) { return 0x821BDAF0;  }
		/* 821BDAE0h case    0:*/		return 0x821BDAE4;
		  /* 821BDAE4h */ case    1:  		/* cmpwi CR6, R11, 5 */
		/* 821BDAE4h case    1:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000005);
		/* 821BDAE4h case    1:*/		return 0x821BDAE8;
		  /* 821BDAE8h */ case    2:  		/* li R11, 1 */
		/* 821BDAE8h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821BDAE8h case    2:*/		return 0x821BDAEC;
		  /* 821BDAECh */ case    3:  		/* bc 4, CR6_GT, 8 */
		/* 821BDAECh case    3:*/		if ( !regs.CR[6].gt ) { return 0x821BDAF4;  }
		/* 821BDAECh case    3:*/		return 0x821BDAF0;
	}
	return 0x821BDAF0;
} // Block from 821BDAE0h-821BDAF0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BDAF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDAF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDAF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDAF0);
		  /* 821BDAF0h */ case    0:  		/* li R11, 0 */
		/* 821BDAF0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BDAF0h case    0:*/		return 0x821BDAF4;
	}
	return 0x821BDAF4;
} // Block from 821BDAF0h-821BDAF4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BDAF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDAF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDAF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDAF4);
		  /* 821BDAF4h */ case    0:  		/* rlwinm R3, R11, 0, 24, 31 */
		/* 821BDAF4h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R3,regs.R11);
		/* 821BDAF4h case    0:*/		return 0x821BDAF8;
		  /* 821BDAF8h */ case    1:  		/* addi R1, R1, 96 */
		/* 821BDAF8h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 821BDAF8h case    1:*/		return 0x821BDAFC;
		  /* 821BDAFCh */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 821BDAFCh case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821BDAFCh case    2:*/		return 0x821BDB00;
		  /* 821BDB00h */ case    3:  		/* mtspr LR, R12 */
		/* 821BDB00h case    3:*/		regs.LR = regs.R12;
		/* 821BDB00h case    3:*/		return 0x821BDB04;
		  /* 821BDB04h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 821BDB04h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821BDB04h case    4:*/		return 0x821BDB08;
		  /* 821BDB08h */ case    5:  		/* bclr 20, CR0_LT */
		/* 821BDB08h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BDB08h case    5:*/		return 0x821BDB0C;
	}
	return 0x821BDB0C;
} // Block from 821BDAF4h-821BDB0Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BDB0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDB0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDB0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDB0C);
		  /* 821BDB0Ch */ case    0:  		/* nop */
		/* 821BDB0Ch case    0:*/		cpu::op::nop();
		/* 821BDB0Ch case    0:*/		return 0x821BDB10;
		  /* 821BDB10h */ case    1:  		/* lbz R10, <#[R3 + 8]> */
		/* 821BDB10h case    1:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 821BDB10h case    1:*/		return 0x821BDB14;
		  /* 821BDB14h */ case    2:  		/* li R11, 0 */
		/* 821BDB14h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BDB14h case    2:*/		return 0x821BDB18;
		  /* 821BDB18h */ case    3:  		/* cmplwi CR0, R10, 0 */
		/* 821BDB18h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 821BDB18h case    3:*/		return 0x821BDB1C;
		  /* 821BDB1Ch */ case    4:  		/* bc 12, CR0_EQ, 32 */
		/* 821BDB1Ch case    4:*/		if ( regs.CR[0].eq ) { return 0x821BDB3C;  }
		/* 821BDB1Ch case    4:*/		return 0x821BDB20;
		  /* 821BDB20h */ case    5:  		/* lwz R11, <#[R4 + 60]> */
		/* 821BDB20h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000003C) );
		/* 821BDB20h case    5:*/		return 0x821BDB24;
		  /* 821BDB24h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 821BDB24h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BDB24h case    6:*/		return 0x821BDB28;
		  /* 821BDB28h */ case    7:  		/* bc 4, CR6_EQ, 20 */
		/* 821BDB28h case    7:*/		if ( !regs.CR[6].eq ) { return 0x821BDB3C;  }
		/* 821BDB28h case    7:*/		return 0x821BDB2C;
		  /* 821BDB2Ch */ case    8:  		/* li R10, 0 */
		/* 821BDB2Ch case    8:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821BDB2Ch case    8:*/		return 0x821BDB30;
	}
	return 0x821BDB30;
} // Block from 821BDB0Ch-821BDB30h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821BDB30h
// Function '?IsAlwaysInteger@Dependency@D3DXShader@@QAA_NI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDB30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDB30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDB30);
		  /* 821BDB30h */ case    0:  		/* stb R10, <#[R3 + 8]> */
		/* 821BDB30h case    0:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 821BDB30h case    0:*/		return 0x821BDB34;
		  /* 821BDB34h */ case    1:  		/* lwz R10, <#[R4 + 52]> */
		/* 821BDB34h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R4 + 0x00000034) );
		/* 821BDB34h case    1:*/		return 0x821BDB38;
		  /* 821BDB38h */ case    2:  		/* lwz R4, <#[R10 + 56]> */
		/* 821BDB38h case    2:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R10 + 0x00000038) );
		/* 821BDB38h case    2:*/		return 0x821BDB3C;
	}
	return 0x821BDB3C;
} // Block from 821BDB30h-821BDB3Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BDB3Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDB3C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDB3C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDB3C);
		  /* 821BDB3Ch */ case    0:  		/* lbz R10, <#[R3 + 8]> */
		/* 821BDB3Ch case    0:*/		cpu::mem::load8z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 821BDB3Ch case    0:*/		return 0x821BDB40;
		  /* 821BDB40h */ case    1:  		/* cmplwi CR0, R10, 0 */
		/* 821BDB40h case    1:*/		cpu::op::cmplwi<0>(regs,regs.R10,0x00000000);
		/* 821BDB40h case    1:*/		return 0x821BDB44;
		  /* 821BDB44h */ case    2:  		/* bc 4, CR0_EQ, 72 */
		/* 821BDB44h case    2:*/		if ( !regs.CR[0].eq ) { return 0x821BDB8C;  }
		/* 821BDB44h case    2:*/		return 0x821BDB48;
		  /* 821BDB48h */ case    3:  		/* lwz R11, <#[R4 + 56]> */
		/* 821BDB48h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000038) );
		/* 821BDB48h case    3:*/		return 0x821BDB4C;
		  /* 821BDB4Ch */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 821BDB4Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BDB4Ch case    4:*/		return 0x821BDB50;
		  /* 821BDB50h */ case    5:  		/* bc 4, CR6_EQ, 52 */
		/* 821BDB50h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821BDB84;  }
		/* 821BDB50h case    5:*/		return 0x821BDB54;
		  /* 821BDB54h */ case    6:  		/* lwz R10, <#[R3]> */
		/* 821BDB54h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 821BDB54h case    6:*/		return 0x821BDB58;
		  /* 821BDB58h */ case    7:  		/* cmplw CR6, R4, R10 */
		/* 821BDB58h case    7:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R10);
		/* 821BDB58h case    7:*/		return 0x821BDB5C;
		  /* 821BDB5Ch */ case    8:  		/* bc 12, CR6_EQ, 56 */
		/* 821BDB5Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x821BDB94;  }
		/* 821BDB5Ch case    8:*/		return 0x821BDB60;
		  /* 821BDB60h */ case    9:  		/* lwz R11, <#[R4 + 60]> */
		/* 821BDB60h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000003C) );
		/* 821BDB60h case    9:*/		return 0x821BDB64;
		  /* 821BDB64h */ case   10:  		/* cmplwi CR6, R11, 0 */
		/* 821BDB64h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BDB64h case   10:*/		return 0x821BDB68;
		  /* 821BDB68h */ case   11:  		/* bc 4, CR6_EQ, 12 */
		/* 821BDB68h case   11:*/		if ( !regs.CR[6].eq ) { return 0x821BDB74;  }
		/* 821BDB68h case   11:*/		return 0x821BDB6C;
		  /* 821BDB6Ch */ case   12:  		/* lwz R4, <#[R4 + 52]> */
		/* 821BDB6Ch case   12:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R4 + 0x00000034) );
		/* 821BDB6Ch case   12:*/		return 0x821BDB70;
		  /* 821BDB70h */ case   13:  		/* b -24 */
		/* 821BDB70h case   13:*/		return 0x821BDB58;
		/* 821BDB70h case   13:*/		return 0x821BDB74;
	}
	return 0x821BDB74;
} // Block from 821BDB3Ch-821BDB74h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821BDB74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDB74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDB74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDB74);
		  /* 821BDB74h */ case    0:  		/* mr R4, R11 */
		/* 821BDB74h case    0:*/		regs.R4 = regs.R11;
		/* 821BDB74h case    0:*/		return 0x821BDB78;
		  /* 821BDB78h */ case    1:  		/* lwz R11, <#[R11 + 56]> */
		/* 821BDB78h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000038) );
		/* 821BDB78h case    1:*/		return 0x821BDB7C;
		  /* 821BDB7Ch */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 821BDB7Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BDB7Ch case    2:*/		return 0x821BDB80;
	}
	return 0x821BDB80;
} // Block from 821BDB74h-821BDB80h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BDB80h
// Function '?CompareUnresolvedUAsmOptions@Compiler@D3DXShader@@AAA_NPAUUnresolvedUAsmOptions@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDB80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDB80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDB80);
		  /* 821BDB80h */ case    0:  		/* bc 12, CR6_EQ, -40 */
		/* 821BDB80h case    0:*/		if ( regs.CR[6].eq ) { return 0x821BDB58;  }
		/* 821BDB80h case    0:*/		return 0x821BDB84;
	}
	return 0x821BDB84;
} // Block from 821BDB80h-821BDB84h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BDB84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDB84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDB84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDB84);
		  /* 821BDB84h */ case    0:  		/* li R10, 1 */
		/* 821BDB84h case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 821BDB84h case    0:*/		return 0x821BDB88;
		  /* 821BDB88h */ case    1:  		/* stb R10, <#[R3 + 8]> */
		/* 821BDB88h case    1:*/		cpu::mem::store8( regs, regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 821BDB88h case    1:*/		return 0x821BDB8C;
	}
	return 0x821BDB8C;
} // Block from 821BDB84h-821BDB8Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BDB8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDB8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDB8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDB8C);
		  /* 821BDB8Ch */ case    0:  		/* mr R3, R11 */
		/* 821BDB8Ch case    0:*/		regs.R3 = regs.R11;
		/* 821BDB8Ch case    0:*/		return 0x821BDB90;
		  /* 821BDB90h */ case    1:  		/* bclr 20, CR0_LT */
		/* 821BDB90h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BDB90h case    1:*/		return 0x821BDB94;
	}
	return 0x821BDB94;
} // Block from 821BDB8Ch-821BDB94h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BDB94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDB94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDB94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDB94);
		  /* 821BDB94h */ case    0:  		/* li R3, 0 */
		/* 821BDB94h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821BDB94h case    0:*/		return 0x821BDB98;
		  /* 821BDB98h */ case    1:  		/* bclr 20, CR0_LT */
		/* 821BDB98h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BDB98h case    1:*/		return 0x821BDB9C;
	}
	return 0x821BDB9C;
} // Block from 821BDB94h-821BDB9Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BDB9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDB9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDB9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDB9C);
		  /* 821BDB9Ch */ case    0:  		/* nop */
		/* 821BDB9Ch case    0:*/		cpu::op::nop();
		/* 821BDB9Ch case    0:*/		return 0x821BDBA0;
	}
	return 0x821BDBA0;
} // Block from 821BDB9Ch-821BDBA0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BDBA0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDBA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDBA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDBA0);
		  /* 821BDBA0h */ case    0:  		/* mfspr R12, LR */
		/* 821BDBA0h case    0:*/		regs.R12 = regs.LR;
		/* 821BDBA0h case    0:*/		return 0x821BDBA4;
		  /* 821BDBA4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821BDBA4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821BDBA4h case    1:*/		return 0x821BDBA8;
		  /* 821BDBA8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 821BDBA8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821BDBA8h case    2:*/		return 0x821BDBAC;
		  /* 821BDBACh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 821BDBACh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821BDBACh case    3:*/		return 0x821BDBB0;
		  /* 821BDBB0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 821BDBB0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821BDBB0h case    4:*/		return 0x821BDBB4;
		  /* 821BDBB4h */ case    5:  		/* lwz R30, <#[R3 + 4]> */
		/* 821BDBB4h case    5:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R3 + 0x00000004) );
		/* 821BDBB4h case    5:*/		return 0x821BDBB8;
		  /* 821BDBB8h */ case    6:  		/* mr R31, R3 */
		/* 821BDBB8h case    6:*/		regs.R31 = regs.R3;
		/* 821BDBB8h case    6:*/		return 0x821BDBBC;
		  /* 821BDBBCh */ case    7:  		/* cmplwi CR6, R30, 0 */
		/* 821BDBBCh case    7:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821BDBBCh case    7:*/		return 0x821BDBC0;
		  /* 821BDBC0h */ case    8:  		/* bc 12, CR6_EQ, 16 */
		/* 821BDBC0h case    8:*/		if ( regs.CR[6].eq ) { return 0x821BDBD0;  }
		/* 821BDBC0h case    8:*/		return 0x821BDBC4;
		  /* 821BDBC4h */ case    9:  		/* mr R4, R30 */
		/* 821BDBC4h case    9:*/		regs.R4 = regs.R30;
		/* 821BDBC4h case    9:*/		return 0x821BDBC8;
		  /* 821BDBC8h */ case   10:  		/* bl -184 */
		/* 821BDBC8h case   10:*/		regs.LR = 0x821BDBCC; return 0x821BDB10;
		/* 821BDBC8h case   10:*/		return 0x821BDBCC;
		  /* 821BDBCCh */ case   11:  		/* stw R3, <#[R31 + 4]> */
		/* 821BDBCCh case   11:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000004) );
		/* 821BDBCCh case   11:*/		return 0x821BDBD0;
	}
	return 0x821BDBD0;
} // Block from 821BDBA0h-821BDBD0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821BDBD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDBD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDBD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDBD0);
		  /* 821BDBD0h */ case    0:  		/* mr R3, R30 */
		/* 821BDBD0h case    0:*/		regs.R3 = regs.R30;
		/* 821BDBD0h case    0:*/		return 0x821BDBD4;
		  /* 821BDBD4h */ case    1:  		/* addi R1, R1, 112 */
		/* 821BDBD4h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821BDBD4h case    1:*/		return 0x821BDBD8;
		  /* 821BDBD8h */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 821BDBD8h case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821BDBD8h case    2:*/		return 0x821BDBDC;
		  /* 821BDBDCh */ case    3:  		/* mtspr LR, R12 */
		/* 821BDBDCh case    3:*/		regs.LR = regs.R12;
		/* 821BDBDCh case    3:*/		return 0x821BDBE0;
		  /* 821BDBE0h */ case    4:  		/* ld R30, <#[R1 - 24]> */
		/* 821BDBE0h case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821BDBE0h case    4:*/		return 0x821BDBE4;
		  /* 821BDBE4h */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 821BDBE4h case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821BDBE4h case    5:*/		return 0x821BDBE8;
		  /* 821BDBE8h */ case    6:  		/* bclr 20, CR0_LT */
		/* 821BDBE8h case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BDBE8h case    6:*/		return 0x821BDBEC;
	}
	return 0x821BDBEC;
} // Block from 821BDBD0h-821BDBECh (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BDBECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDBEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDBEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDBEC);
		  /* 821BDBECh */ case    0:  		/* nop */
		/* 821BDBECh case    0:*/		cpu::op::nop();
		/* 821BDBECh case    0:*/		return 0x821BDBF0;
		  /* 821BDBF0h */ case    1:  		/* lwz R3, <#[R3 + 4]> */
		/* 821BDBF0h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000004) );
		/* 821BDBF0h case    1:*/		return 0x821BDBF4;
		  /* 821BDBF4h */ case    2:  		/* cmplwi CR6, R3, 0 */
		/* 821BDBF4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 821BDBF4h case    2:*/		return 0x821BDBF8;
		  /* 821BDBF8h */ case    3:  		/* bc 12, CR6_EQ, 92 */
		/* 821BDBF8h case    3:*/		if ( regs.CR[6].eq ) { return 0x821BDC54;  }
		/* 821BDBF8h case    3:*/		return 0x821BDBFC;
		  /* 821BDBFCh */ case    4:  		/* lwz R11, <#[R3 + 16]> */
		/* 821BDBFCh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000010) );
		/* 821BDBFCh case    4:*/		return 0x821BDC00;
		  /* 821BDC00h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821BDC00h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BDC00h case    5:*/		return 0x821BDC04;
		  /* 821BDC04h */ case    6:  		/* bc 12, CR6_EQ, 72 */
		/* 821BDC04h case    6:*/		if ( regs.CR[6].eq ) { return 0x821BDC4C;  }
		/* 821BDC04h case    6:*/		return 0x821BDC08;
		  /* 821BDC08h */ case    7:  		/* lwz R10, <#[R3]> */
		/* 821BDC08h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000000) );
		/* 821BDC08h case    7:*/		return 0x821BDC0C;
		  /* 821BDC0Ch */ case    8:  		/* rlwinm. R11, R10, 0, 1, 1 */
		/* 821BDC0Ch case    8:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R11,regs.R10);
		/* 821BDC0Ch case    8:*/		return 0x821BDC10;
		  /* 821BDC10h */ case    9:  		/* bc 4, CR0_EQ, 16 */
		/* 821BDC10h case    9:*/		if ( !regs.CR[0].eq ) { return 0x821BDC20;  }
		/* 821BDC10h case    9:*/		return 0x821BDC14;
		  /* 821BDC14h */ case   10:  		/* rlwinm. R11, R10, 0, 4, 6 */
		/* 821BDC14h case   10:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R10);
		/* 821BDC14h case   10:*/		return 0x821BDC18;
		  /* 821BDC18h */ case   11:  		/* li R11, 1 */
		/* 821BDC18h case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821BDC18h case   11:*/		return 0x821BDC1C;
		  /* 821BDC1Ch */ case   12:  		/* bc 12, CR0_EQ, 8 */
		/* 821BDC1Ch case   12:*/		if ( regs.CR[0].eq ) { return 0x821BDC24;  }
		/* 821BDC1Ch case   12:*/		return 0x821BDC20;
	}
	return 0x821BDC20;
} // Block from 821BDBECh-821BDC20h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821BDC20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDC20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDC20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDC20);
		  /* 821BDC20h */ case    0:  		/* li R11, 0 */
		/* 821BDC20h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BDC20h case    0:*/		return 0x821BDC24;
	}
	return 0x821BDC24;
} // Block from 821BDC20h-821BDC24h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BDC24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDC24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDC24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDC24);
		  /* 821BDC24h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821BDC24h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821BDC24h case    0:*/		return 0x821BDC28;
		  /* 821BDC28h */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 821BDC28h case    1:*/		if ( regs.CR[0].eq ) { return 0x821BDC40;  }
		/* 821BDC28h case    1:*/		return 0x821BDC2C;
		  /* 821BDC2Ch */ case    2:  		/* rlwinm R11, R10, 19, 20, 31 */
		/* 821BDC2Ch case    2:*/		cpu::op::rlwinm<0,19,20,31>(regs,&regs.R11,regs.R10);
		/* 821BDC2Ch case    2:*/		return 0x821BDC30;
		  /* 821BDC30h */ case    3:  		/* addi R10, R4, 1 */
		/* 821BDC30h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R4,0x1);
		/* 821BDC30h case    3:*/		return 0x821BDC34;
		  /* 821BDC34h */ case    4:  		/* cmplw CR6, R11, R10 */
		/* 821BDC34h case    4:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821BDC34h case    4:*/		return 0x821BDC38;
		  /* 821BDC38h */ case    5:  		/* li R11, 1 */
		/* 821BDC38h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821BDC38h case    5:*/		return 0x821BDC3C;
		  /* 821BDC3Ch */ case    6:  		/* bc 12, CR6_EQ, 8 */
		/* 821BDC3Ch case    6:*/		if ( regs.CR[6].eq ) { return 0x821BDC44;  }
		/* 821BDC3Ch case    6:*/		return 0x821BDC40;
	}
	return 0x821BDC40;
} // Block from 821BDC24h-821BDC40h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BDC40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDC40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDC40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDC40);
		  /* 821BDC40h */ case    0:  		/* li R11, 0 */
		/* 821BDC40h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BDC40h case    0:*/		return 0x821BDC44;
	}
	return 0x821BDC44;
} // Block from 821BDC40h-821BDC44h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BDC44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDC44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDC44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDC44);
		  /* 821BDC44h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821BDC44h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821BDC44h case    0:*/		return 0x821BDC48;
		  /* 821BDC48h */ case    1:  		/* bclr 4, CR0_EQ */
		/* 821BDC48h case    1:*/		if ( !regs.CR[0].eq ) { return (uint32)regs.LR; }
		/* 821BDC48h case    1:*/		return 0x821BDC4C;
	}
	return 0x821BDC4C;
} // Block from 821BDC44h-821BDC4Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BDC4Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDC4C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDC4C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDC4C);
		  /* 821BDC4Ch */ case    0:  		/* lwz R3, <#[R3 + 8]> */
		/* 821BDC4Ch case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R3 + 0x00000008) );
		/* 821BDC4Ch case    0:*/		return 0x821BDC50;
		  /* 821BDC50h */ case    1:  		/* b -92 */
		/* 821BDC50h case    1:*/		return 0x821BDBF4;
		/* 821BDC50h case    1:*/		return 0x821BDC54;
	}
	return 0x821BDC54;
} // Block from 821BDC4Ch-821BDC54h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BDC54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDC54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDC54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDC54);
		  /* 821BDC54h */ case    0:  		/* li R3, 0 */
		/* 821BDC54h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821BDC54h case    0:*/		return 0x821BDC58;
		  /* 821BDC58h */ case    1:  		/* bclr 20, CR0_LT */
		/* 821BDC58h case    1:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BDC58h case    1:*/		return 0x821BDC5C;
	}
	return 0x821BDC5C;
} // Block from 821BDC54h-821BDC5Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BDC5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDC5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDC5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDC5C);
		  /* 821BDC5Ch */ case    0:  		/* nop */
		/* 821BDC5Ch case    0:*/		cpu::op::nop();
		/* 821BDC5Ch case    0:*/		return 0x821BDC60;
	}
	return 0x821BDC60;
} // Block from 821BDC5Ch-821BDC60h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BDC60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDC60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDC60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDC60);
		  /* 821BDC60h */ case    0:  		/* mfspr R12, LR */
		/* 821BDC60h case    0:*/		regs.R12 = regs.LR;
		/* 821BDC60h case    0:*/		return 0x821BDC64;
		  /* 821BDC64h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821BDC64h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821BDC64h case    1:*/		return 0x821BDC68;
		  /* 821BDC68h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 821BDC68h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821BDC68h case    2:*/		return 0x821BDC6C;
		  /* 821BDC6Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 821BDC6Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821BDC6Ch case    3:*/		return 0x821BDC70;
		  /* 821BDC70h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 821BDC70h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821BDC70h case    4:*/		return 0x821BDC74;
		  /* 821BDC74h */ case    5:  		/* lwz R11, <#[R4 + 8]> */
		/* 821BDC74h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821BDC74h case    5:*/		return 0x821BDC78;
		  /* 821BDC78h */ case    6:  		/* mr R31, R3 */
		/* 821BDC78h case    6:*/		regs.R31 = regs.R3;
		/* 821BDC78h case    6:*/		return 0x821BDC7C;
		  /* 821BDC7Ch */ case    7:  		/* mr R30, R5 */
		/* 821BDC7Ch case    7:*/		regs.R30 = regs.R5;
		/* 821BDC7Ch case    7:*/		return 0x821BDC80;
		  /* 821BDC80h */ case    8:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821BDC80h case    8:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821BDC80h case    8:*/		return 0x821BDC84;
		  /* 821BDC84h */ case    9:  		/* cmplwi CR6, R11, 125 */
		/* 821BDC84h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 821BDC84h case    9:*/		return 0x821BDC88;
		  /* 821BDC88h */ case   10:  		/* bc 12, CR6_EQ, 16 */
		/* 821BDC88h case   10:*/		if ( regs.CR[6].eq ) { return 0x821BDC98;  }
		/* 821BDC88h case   10:*/		return 0x821BDC8C;
		  /* 821BDC8Ch */ case   11:  		/* cmplwi CR6, R11, 124 */
		/* 821BDC8Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 821BDC8Ch case   11:*/		return 0x821BDC90;
		  /* 821BDC90h */ case   12:  		/* li R11, 0 */
		/* 821BDC90h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BDC90h case   12:*/		return 0x821BDC94;
		  /* 821BDC94h */ case   13:  		/* bc 4, CR6_EQ, 8 */
		/* 821BDC94h case   13:*/		if ( !regs.CR[6].eq ) { return 0x821BDC9C;  }
		/* 821BDC94h case   13:*/		return 0x821BDC98;
	}
	return 0x821BDC98;
} // Block from 821BDC60h-821BDC98h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821BDC98h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDC98( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDC98) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDC98);
		  /* 821BDC98h */ case    0:  		/* li R11, 1 */
		/* 821BDC98h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821BDC98h case    0:*/		return 0x821BDC9C;
	}
	return 0x821BDC9C;
} // Block from 821BDC98h-821BDC9Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BDC9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDC9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDC9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDC9C);
		  /* 821BDC9Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821BDC9Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821BDC9Ch case    0:*/		return 0x821BDCA0;
		  /* 821BDCA0h */ case    1:  		/* bc 12, CR0_EQ, 104 */
		/* 821BDCA0h case    1:*/		if ( regs.CR[0].eq ) { return 0x821BDD08;  }
		/* 821BDCA0h case    1:*/		return 0x821BDCA4;
		  /* 821BDCA4h */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 821BDCA4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821BDCA4h case    2:*/		return 0x821BDCA8;
		  /* 821BDCA8h */ case    3:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821BDCA8h case    3:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821BDCA8h case    3:*/		return 0x821BDCAC;
		  /* 821BDCACh */ case    4:  		/* cmplwi CR6, R11, 14976 */
		/* 821BDCACh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003A80);
		/* 821BDCACh case    4:*/		return 0x821BDCB0;
		  /* 821BDCB0h */ case    5:  		/* bc 4, CR6_EQ, 88 */
		/* 821BDCB0h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821BDD08;  }
		/* 821BDCB0h case    5:*/		return 0x821BDCB4;
		  /* 821BDCB4h */ case    6:  		/* li R6, 0 */
		/* 821BDCB4h case    6:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821BDCB4h case    6:*/		return 0x821BDCB8;
		  /* 821BDCB8h */ case    7:  		/* li R5, 0 */
		/* 821BDCB8h case    7:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821BDCB8h case    7:*/		return 0x821BDCBC;
		  /* 821BDCBCh */ case    8:  		/* li R4, 117 */
		/* 821BDCBCh case    8:*/		cpu::op::li<0>(regs,&regs.R4,0x75);
		/* 821BDCBCh case    8:*/		return 0x821BDCC0;
		  /* 821BDCC0h */ case    9:  		/* mr R3, R30 */
		/* 821BDCC0h case    9:*/		regs.R3 = regs.R30;
		/* 821BDCC0h case    9:*/		return 0x821BDCC4;
		  /* 821BDCC4h */ case   10:  		/* bl -366740 */
		/* 821BDCC4h case   10:*/		regs.LR = 0x821BDCC8; return 0x82164430;
		/* 821BDCC4h case   10:*/		return 0x821BDCC8;
		  /* 821BDCC8h */ case   11:  		/* addi R11, R31, -16 */
		/* 821BDCC8h case   11:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFF0);
		/* 821BDCC8h case   11:*/		return 0x821BDCCC;
		  /* 821BDCCCh */ case   12:  		/* lwzx R11, <#[R3 + R11]> */
		/* 821BDCCCh case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 821BDCCCh case   12:*/		return 0x821BDCD0;
		  /* 821BDCD0h */ case   13:  		/* rlwinm R11, R11, 0, 29, 31 */
		/* 821BDCD0h case   13:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R11,regs.R11);
		/* 821BDCD0h case   13:*/		return 0x821BDCD4;
		  /* 821BDCD4h */ case   14:  		/* cmplwi CR6, R11, 4 */
		/* 821BDCD4h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000004);
		/* 821BDCD4h case   14:*/		return 0x821BDCD8;
		  /* 821BDCD8h */ case   15:  		/* bc 12, CR6_LT, 16 */
		/* 821BDCD8h case   15:*/		if ( regs.CR[6].lt ) { return 0x821BDCE8;  }
		/* 821BDCD8h case   15:*/		return 0x821BDCDC;
		  /* 821BDCDCh */ case   16:  		/* cmplwi CR6, R11, 6 */
		/* 821BDCDCh case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000006);
		/* 821BDCDCh case   16:*/		return 0x821BDCE0;
		  /* 821BDCE0h */ case   17:  		/* li R11, 1 */
		/* 821BDCE0h case   17:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821BDCE0h case   17:*/		return 0x821BDCE4;
		  /* 821BDCE4h */ case   18:  		/* bc 4, CR6_GT, 8 */
		/* 821BDCE4h case   18:*/		if ( !regs.CR[6].gt ) { return 0x821BDCEC;  }
		/* 821BDCE4h case   18:*/		return 0x821BDCE8;
	}
	return 0x821BDCE8;
} // Block from 821BDC9Ch-821BDCE8h (19 instructions)

//////////////////////////////////////////////////////
// Block at 821BDCE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDCE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDCE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDCE8);
		  /* 821BDCE8h */ case    0:  		/* li R11, 0 */
		/* 821BDCE8h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BDCE8h case    0:*/		return 0x821BDCEC;
	}
	return 0x821BDCEC;
} // Block from 821BDCE8h-821BDCECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BDCECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDCEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDCEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDCEC);
		  /* 821BDCECh */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821BDCECh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821BDCECh case    0:*/		return 0x821BDCF0;
		  /* 821BDCF0h */ case    1:  		/* bc 12, CR0_EQ, 24 */
		/* 821BDCF0h case    1:*/		if ( regs.CR[0].eq ) { return 0x821BDD08;  }
		/* 821BDCF0h case    1:*/		return 0x821BDCF4;
		  /* 821BDCF4h */ case    2:  		/* lwz R11, <#[R30 + 52]> */
		/* 821BDCF4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000034) );
		/* 821BDCF4h case    2:*/		return 0x821BDCF8;
	}
	return 0x821BDCF8;
} // Block from 821BDCECh-821BDCF8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BDCF8h
// Function '?IsEquivalentLinkedDependency@Compiler@D3DXShader@@AAA_NPAVDependency@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDCF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDCF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDCF8);
		  /* 821BDCF8h */ case    0:  		/* li R3, 0 */
		/* 821BDCF8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821BDCF8h case    0:*/		return 0x821BDCFC;
		  /* 821BDCFCh */ case    1:  		/* nor R11, R11, R11 */
		/* 821BDCFCh case    1:*/		cpu::op::nor<0>(regs,&regs.R11,regs.R11,regs.R11);
		/* 821BDCFCh case    1:*/		return 0x821BDD00;
		  /* 821BDD00h */ case    2:  		/* rlwinm. R11, R11, 25, 31, 31 */
		/* 821BDD00h case    2:*/		cpu::op::rlwinm<1,25,31,31>(regs,&regs.R11,regs.R11);
		/* 821BDD00h case    2:*/		return 0x821BDD04;
		  /* 821BDD04h */ case    3:  		/* bc 4, CR0_EQ, 8 */
		/* 821BDD04h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BDD0C;  }
		/* 821BDD04h case    3:*/		return 0x821BDD08;
	}
	return 0x821BDD08;
} // Block from 821BDCF8h-821BDD08h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BDD08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDD08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDD08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDD08);
		  /* 821BDD08h */ case    0:  		/* li R3, 1 */
		/* 821BDD08h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821BDD08h case    0:*/		return 0x821BDD0C;
	}
	return 0x821BDD0C;
} // Block from 821BDD08h-821BDD0Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BDD0Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDD0C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDD0C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDD0C);
		  /* 821BDD0Ch */ case    0:  		/* addi R1, R1, 112 */
		/* 821BDD0Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821BDD0Ch case    0:*/		return 0x821BDD10;
		  /* 821BDD10h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 821BDD10h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821BDD10h case    1:*/		return 0x821BDD14;
		  /* 821BDD14h */ case    2:  		/* mtspr LR, R12 */
		/* 821BDD14h case    2:*/		regs.LR = regs.R12;
		/* 821BDD14h case    2:*/		return 0x821BDD18;
		  /* 821BDD18h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 821BDD18h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821BDD18h case    3:*/		return 0x821BDD1C;
		  /* 821BDD1Ch */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 821BDD1Ch case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821BDD1Ch case    4:*/		return 0x821BDD20;
		  /* 821BDD20h */ case    5:  		/* bclr 20, CR0_LT */
		/* 821BDD20h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BDD20h case    5:*/		return 0x821BDD24;
	}
	return 0x821BDD24;
} // Block from 821BDD0Ch-821BDD24h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BDD24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDD24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDD24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDD24);
		  /* 821BDD24h */ case    0:  		/* nop */
		/* 821BDD24h case    0:*/		cpu::op::nop();
		/* 821BDD24h case    0:*/		return 0x821BDD28;
	}
	return 0x821BDD28;
} // Block from 821BDD24h-821BDD28h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BDD28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDD28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDD28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDD28);
		  /* 821BDD28h */ case    0:  		/* mfspr R12, LR */
		/* 821BDD28h case    0:*/		regs.R12 = regs.LR;
		/* 821BDD28h case    0:*/		return 0x821BDD2C;
		  /* 821BDD2Ch */ case    1:  		/* bl -1231568 */
		/* 821BDD2Ch case    1:*/		regs.LR = 0x821BDD30; return 0x8209125C;
		/* 821BDD2Ch case    1:*/		return 0x821BDD30;
		  /* 821BDD30h */ case    2:  		/* stwu R1, <#[R1 - 112]> */
		/* 821BDD30h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821BDD30h case    2:*/		return 0x821BDD34;
		  /* 821BDD34h */ case    3:  		/* mr R31, R3 */
		/* 821BDD34h case    3:*/		regs.R31 = regs.R3;
		/* 821BDD34h case    3:*/		return 0x821BDD38;
		  /* 821BDD38h */ case    4:  		/* mr R30, R4 */
		/* 821BDD38h case    4:*/		regs.R30 = regs.R4;
		/* 821BDD38h case    4:*/		return 0x821BDD3C;
		  /* 821BDD3Ch */ case    5:  		/* mr R29, R5 */
		/* 821BDD3Ch case    5:*/		regs.R29 = regs.R5;
		/* 821BDD3Ch case    5:*/		return 0x821BDD40;
		  /* 821BDD40h */ case    6:  		/* li R5, 22 */
		/* 821BDD40h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x16);
		/* 821BDD40h case    6:*/		return 0x821BDD44;
		  /* 821BDD44h */ case    7:  		/* li R4, 12 */
		/* 821BDD44h case    7:*/		cpu::op::li<0>(regs,&regs.R4,0xC);
		/* 821BDD44h case    7:*/		return 0x821BDD48;
		  /* 821BDD48h */ case    8:  		/* mr R3, R6 */
		/* 821BDD48h case    8:*/		regs.R3 = regs.R6;
		/* 821BDD48h case    8:*/		return 0x821BDD4C;
		  /* 821BDD4Ch */ case    9:  		/* bl -332196 */
		/* 821BDD4Ch case    9:*/		regs.LR = 0x821BDD50; return 0x8216CBA8;
		/* 821BDD4Ch case    9:*/		return 0x821BDD50;
		  /* 821BDD50h */ case   10:  		/* lwz R10, <#[R3 + 8]> */
		/* 821BDD50h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 821BDD50h case   10:*/		return 0x821BDD54;
		  /* 821BDD54h */ case   11:  		/* rlwimi R30, R29, 14, 4, 17 */
		/* 821BDD54h case   11:*/		cpu::op::rlwimi<0,14,4,17>(regs,&regs.R30,regs.R29);
		/* 821BDD54h case   11:*/		return 0x821BDD58;
		  /* 821BDD58h */ case   12:  		/* li R11, 0 */
		/* 821BDD58h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BDD58h case   12:*/		return 0x821BDD5C;
		  /* 821BDD5Ch */ case   13:  		/* rlwimi R30, R10, 0, 0, 3 */
		/* 821BDD5Ch case   13:*/		cpu::op::rlwimi<0,0,0,3>(regs,&regs.R30,regs.R10);
		/* 821BDD5Ch case   13:*/		return 0x821BDD60;
		  /* 821BDD60h */ case   14:  		/* stw R11, <#[R3]> */
		/* 821BDD60h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821BDD60h case   14:*/		return 0x821BDD64;
		  /* 821BDD64h */ case   15:  		/* stw R30, <#[R3 + 8]> */
		/* 821BDD64h case   15:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000008) );
		/* 821BDD64h case   15:*/		return 0x821BDD68;
		  /* 821BDD68h */ case   16:  		/* lwz R11, <#[R31 + 16]> */
		/* 821BDD68h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 821BDD68h case   16:*/		return 0x821BDD6C;
		  /* 821BDD6Ch */ case   17:  		/* stw R11, <#[R3 + 4]> */
		/* 821BDD6Ch case   17:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821BDD6Ch case   17:*/		return 0x821BDD70;
		  /* 821BDD70h */ case   18:  		/* stw R3, <#[R31 + 16]> */
		/* 821BDD70h case   18:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 821BDD70h case   18:*/		return 0x821BDD74;
		  /* 821BDD74h */ case   19:  		/* addi R1, R1, 112 */
		/* 821BDD74h case   19:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821BDD74h case   19:*/		return 0x821BDD78;
		  /* 821BDD78h */ case   20:  		/* b -1231564 */
		/* 821BDD78h case   20:*/		return 0x820912AC;
		/* 821BDD78h case   20:*/		return 0x821BDD7C;
		  /* 821BDD7Ch */ case   21:  		/* nop */
		/* 821BDD7Ch case   21:*/		cpu::op::nop();
		/* 821BDD7Ch case   21:*/		return 0x821BDD80;
	}
	return 0x821BDD80;
} // Block from 821BDD28h-821BDD80h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821BDD80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDD80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDD80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDD80);
		  /* 821BDD80h */ case    0:  		/* mfspr R12, LR */
		/* 821BDD80h case    0:*/		regs.R12 = regs.LR;
		/* 821BDD80h case    0:*/		return 0x821BDD84;
		  /* 821BDD84h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821BDD84h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821BDD84h case    1:*/		return 0x821BDD88;
		  /* 821BDD88h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 821BDD88h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821BDD88h case    2:*/		return 0x821BDD8C;
		  /* 821BDD8Ch */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 821BDD8Ch case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821BDD8Ch case    3:*/		return 0x821BDD90;
		  /* 821BDD90h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 821BDD90h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821BDD90h case    4:*/		return 0x821BDD94;
		  /* 821BDD94h */ case    5:  		/* lwz R11, <#[R4 + 8]> */
		/* 821BDD94h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821BDD94h case    5:*/		return 0x821BDD98;
		  /* 821BDD98h */ case    6:  		/* mr R31, R4 */
		/* 821BDD98h case    6:*/		regs.R31 = regs.R4;
		/* 821BDD98h case    6:*/		return 0x821BDD9C;
		  /* 821BDD9Ch */ case    7:  		/* mr R30, R3 */
		/* 821BDD9Ch case    7:*/		regs.R30 = regs.R3;
		/* 821BDD9Ch case    7:*/		return 0x821BDDA0;
		  /* 821BDDA0h */ case    8:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 821BDDA0h case    8:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 821BDDA0h case    8:*/		return 0x821BDDA4;
		  /* 821BDDA4h */ case    9:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 821BDDA4h case    9:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 821BDDA4h case    9:*/		return 0x821BDDA8;
		  /* 821BDDA8h */ case   10:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 821BDDA8h case   10:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 821BDDA8h case   10:*/		return 0x821BDDAC;
		  /* 821BDDACh */ case   11:  		/* bl -366972 */
		/* 821BDDACh case   11:*/		regs.LR = 0x821BDDB0; return 0x82164430;
		/* 821BDDACh case   11:*/		return 0x821BDDB0;
		  /* 821BDDB0h */ case   12:  		/* addi R11, R31, -16 */
		/* 821BDDB0h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFF0);
		/* 821BDDB0h case   12:*/		return 0x821BDDB4;
		  /* 821BDDB4h */ case   13:  		/* add R31, R3, R11 */
		/* 821BDDB4h case   13:*/		cpu::op::add<0>(regs,&regs.R31,regs.R3,regs.R11);
		/* 821BDDB4h case   13:*/		return 0x821BDDB8;
		  /* 821BDDB8h */ case   14:  		/* lwz R11, <#[R31 + 8]> */
		/* 821BDDB8h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821BDDB8h case   14:*/		return 0x821BDDBC;
		  /* 821BDDBCh */ case   15:  		/* rlwinm. R10, R11, 0, 30, 31 */
		/* 821BDDBCh case   15:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R10,regs.R11);
		/* 821BDDBCh case   15:*/		return 0x821BDDC0;
		  /* 821BDDC0h */ case   16:  		/* bc 12, CR0_EQ, 12 */
		/* 821BDDC0h case   16:*/		if ( regs.CR[0].eq ) { return 0x821BDDCC;  }
		/* 821BDDC0h case   16:*/		return 0x821BDDC4;
		  /* 821BDDC4h */ case   17:  		/* li R9, 1 */
		/* 821BDDC4h case   17:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 821BDDC4h case   17:*/		return 0x821BDDC8;
		  /* 821BDDC8h */ case   18:  		/* b 12 */
		/* 821BDDC8h case   18:*/		return 0x821BDDD4;
		/* 821BDDC8h case   18:*/		return 0x821BDDCC;
	}
	return 0x821BDDCC;
} // Block from 821BDD80h-821BDDCCh (19 instructions)

//////////////////////////////////////////////////////
// Block at 821BDDCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDDCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDDCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDDCC);
		  /* 821BDDCCh */ case    0:  		/* nor R9, R11, R11 */
		/* 821BDDCCh case    0:*/		cpu::op::nor<0>(regs,&regs.R9,regs.R11,regs.R11);
		/* 821BDDCCh case    0:*/		return 0x821BDDD0;
		  /* 821BDDD0h */ case    1:  		/* rlwinm R9, R9, 25, 31, 31 */
		/* 821BDDD0h case    1:*/		cpu::op::rlwinm<0,25,31,31>(regs,&regs.R9,regs.R9);
		/* 821BDDD0h case    1:*/		return 0x821BDDD4;
	}
	return 0x821BDDD4;
} // Block from 821BDDCCh-821BDDD4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BDDD4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDDD4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDDD4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDDD4);
		  /* 821BDDD4h */ case    0:  		/* rlwinm. R9, R9, 0, 24, 31 */
		/* 821BDDD4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R9,regs.R9);
		/* 821BDDD4h case    0:*/		return 0x821BDDD8;
		  /* 821BDDD8h */ case    1:  		/* bc 12, CR0_EQ, 36 */
		/* 821BDDD8h case    1:*/		if ( regs.CR[0].eq ) { return 0x821BDDFC;  }
		/* 821BDDD8h case    1:*/		return 0x821BDDDC;
		  /* 821BDDDCh */ case    2:  		/* cmplwi CR6, R10, 0 */
		/* 821BDDDCh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821BDDDCh case    2:*/		return 0x821BDDE0;
		  /* 821BDDE0h */ case    3:  		/* bc 4, CR6_EQ, 28 */
		/* 821BDDE0h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821BDDFC;  }
		/* 821BDDE0h case    3:*/		return 0x821BDDE4;
		  /* 821BDDE4h */ case    4:  		/* rlwinm R11, R11, 30, 28, 31 */
		/* 821BDDE4h case    4:*/		cpu::op::rlwinm<0,30,28,31>(regs,&regs.R11,regs.R11);
		/* 821BDDE4h case    4:*/		return 0x821BDDE8;
		  /* 821BDDE8h */ case    5:  		/* cmpwi CR6, R11, 5 */
		/* 821BDDE8h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000005);
		/* 821BDDE8h case    5:*/		return 0x821BDDEC;
		  /* 821BDDECh */ case    6:  		/* bc 4, CR6_EQ, 16 */
		/* 821BDDECh case    6:*/		if ( !regs.CR[6].eq ) { return 0x821BDDFC;  }
		/* 821BDDECh case    6:*/		return 0x821BDDF0;
	}
	return 0x821BDDF0;
} // Block from 821BDDD4h-821BDDF0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BDDF0h
// Function '?ShouldOrderTermBefore@D3DXShader@@YA_NPAUProductTerm@1@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDDF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDDF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDDF0);
		  /* 821BDDF0h */ case    0:  		/* li R4, 3585 */
		/* 821BDDF0h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0xE01);
		/* 821BDDF0h case    0:*/		return 0x821BDDF4;
		  /* 821BDDF4h */ case    1:  		/* mr R3, R30 */
		/* 821BDDF4h case    1:*/		regs.R3 = regs.R30;
		/* 821BDDF4h case    1:*/		return 0x821BDDF8;
		  /* 821BDDF8h */ case    2:  		/* bl -442496 */
		/* 821BDDF8h case    2:*/		regs.LR = 0x821BDDFC; return 0x82151D78;
		/* 821BDDF8h case    2:*/		return 0x821BDDFC;
	}
	return 0x821BDDFC;
} // Block from 821BDDF0h-821BDDFCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BDDFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDDFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDDFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDDFC);
		  /* 821BDDFCh */ case    0:  		/* lwz R11, <#[R31 + 8]> */
		/* 821BDDFCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821BDDFCh case    0:*/		return 0x821BDE00;
		  /* 821BDE00h */ case    1:  		/* li R10, 27 */
		/* 821BDE00h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x1B);
		/* 821BDE00h case    1:*/		return 0x821BDE04;
		  /* 821BDE04h */ case    2:  		/* rlwimi R11, R10, 3, 23, 31 */
		/* 821BDE04h case    2:*/		cpu::op::rlwimi<0,3,23,31>(regs,&regs.R11,regs.R10);
		/* 821BDE04h case    2:*/		return 0x821BDE08;
		  /* 821BDE08h */ case    3:  		/* stw R11, <#[R31 + 8]> */
		/* 821BDE08h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821BDE08h case    3:*/		return 0x821BDE0C;
		  /* 821BDE0Ch */ case    4:  		/* addi R1, R1, 112 */
		/* 821BDE0Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821BDE0Ch case    4:*/		return 0x821BDE10;
		  /* 821BDE10h */ case    5:  		/* lwz R12, <#[R1 - 8]> */
		/* 821BDE10h case    5:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821BDE10h case    5:*/		return 0x821BDE14;
		  /* 821BDE14h */ case    6:  		/* mtspr LR, R12 */
		/* 821BDE14h case    6:*/		regs.LR = regs.R12;
		/* 821BDE14h case    6:*/		return 0x821BDE18;
		  /* 821BDE18h */ case    7:  		/* ld R30, <#[R1 - 24]> */
		/* 821BDE18h case    7:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821BDE18h case    7:*/		return 0x821BDE1C;
		  /* 821BDE1Ch */ case    8:  		/* ld R31, <#[R1 - 16]> */
		/* 821BDE1Ch case    8:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821BDE1Ch case    8:*/		return 0x821BDE20;
		  /* 821BDE20h */ case    9:  		/* bclr 20, CR0_LT */
		/* 821BDE20h case    9:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BDE20h case    9:*/		return 0x821BDE24;
	}
	return 0x821BDE24;
} // Block from 821BDDFCh-821BDE24h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821BDE24h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDE24( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDE24) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDE24);
		  /* 821BDE24h */ case    0:  		/* nop */
		/* 821BDE24h case    0:*/		cpu::op::nop();
		/* 821BDE24h case    0:*/		return 0x821BDE28;
	}
	return 0x821BDE28;
} // Block from 821BDE24h-821BDE28h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BDE28h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDE28( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDE28) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDE28);
		  /* 821BDE28h */ case    0:  		/* mfspr R12, LR */
		/* 821BDE28h case    0:*/		regs.R12 = regs.LR;
		/* 821BDE28h case    0:*/		return 0x821BDE2C;
		  /* 821BDE2Ch */ case    1:  		/* bl -1231828 */
		/* 821BDE2Ch case    1:*/		regs.LR = 0x821BDE30; return 0x82091258;
		/* 821BDE2Ch case    1:*/		return 0x821BDE30;
		  /* 821BDE30h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821BDE30h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821BDE30h case    2:*/		return 0x821BDE34;
		  /* 821BDE34h */ case    3:  		/* lwz R11, <#[R5 + 8]> */
		/* 821BDE34h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000008) );
		/* 821BDE34h case    3:*/		return 0x821BDE38;
		  /* 821BDE38h */ case    4:  		/* mr R30, R3 */
		/* 821BDE38h case    4:*/		regs.R30 = regs.R3;
		/* 821BDE38h case    4:*/		return 0x821BDE3C;
		  /* 821BDE3Ch */ case    5:  		/* mr R31, R5 */
		/* 821BDE3Ch case    5:*/		regs.R31 = regs.R5;
		/* 821BDE3Ch case    5:*/		return 0x821BDE40;
		  /* 821BDE40h */ case    6:  		/* rlwinm R29, R11, 25, 25, 31 */
		/* 821BDE40h case    6:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R29,regs.R11);
		/* 821BDE40h case    6:*/		return 0x821BDE44;
		  /* 821BDE44h */ case    7:  		/* mr R28, R6 */
		/* 821BDE44h case    7:*/		regs.R28 = regs.R6;
		/* 821BDE44h case    7:*/		return 0x821BDE48;
		  /* 821BDE48h */ case    8:  		/* cmplwi CR6, R29, 120 */
		/* 821BDE48h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000078);
		/* 821BDE48h case    8:*/		return 0x821BDE4C;
		  /* 821BDE4Ch */ case    9:  		/* bc 4, CR6_EQ, 88 */
		/* 821BDE4Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x821BDEA4;  }
		/* 821BDE4Ch case    9:*/		return 0x821BDE50;
	}
	return 0x821BDE50;
} // Block from 821BDE28h-821BDE50h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821BDE50h
// Function '?ShouldSwapOperands@D3DXShader@@YA_NPAVInstruction@1@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDE50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDE50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDE50);
		  /* 821BDE50h */ case    0:  		/* lwz R11, <#[R4 + 8]> */
		/* 821BDE50h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821BDE50h case    0:*/		return 0x821BDE54;
		  /* 821BDE54h */ case    1:  		/* rlwinm R10, R11, 0, 18, 24 */
		/* 821BDE54h case    1:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R11);
		/* 821BDE54h case    1:*/		return 0x821BDE58;
		  /* 821BDE58h */ case    2:  		/* cmplwi CR6, R10, 12288 */
		/* 821BDE58h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00003000);
		/* 821BDE58h case    2:*/		return 0x821BDE5C;
		  /* 821BDE5Ch */ case    3:  		/* bc 4, CR6_EQ, 24 */
		/* 821BDE5Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x821BDE74;  }
		/* 821BDE5Ch case    3:*/		return 0x821BDE60;
		  /* 821BDE60h */ case    4:  		/* rlwinm R11, R11, 0, 10, 12 */
		/* 821BDE60h case    4:*/		cpu::op::rlwinm<0,0,10,12>(regs,&regs.R11,regs.R11);
		/* 821BDE60h case    4:*/		return 0x821BDE64;
		  /* 821BDE64h */ case    5:  		/* lis R10, 8 */
		/* 821BDE64h case    5:*/		cpu::op::lis<0>(regs,&regs.R10,0x8);
		/* 821BDE64h case    5:*/		return 0x821BDE68;
		  /* 821BDE68h */ case    6:  		/* cmplw CR6, R11, R10 */
		/* 821BDE68h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R10);
		/* 821BDE68h case    6:*/		return 0x821BDE6C;
		  /* 821BDE6Ch */ case    7:  		/* li R11, 1 */
		/* 821BDE6Ch case    7:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821BDE6Ch case    7:*/		return 0x821BDE70;
		  /* 821BDE70h */ case    8:  		/* bc 12, CR6_GT, 8 */
		/* 821BDE70h case    8:*/		if ( regs.CR[6].gt ) { return 0x821BDE78;  }
		/* 821BDE70h case    8:*/		return 0x821BDE74;
	}
	return 0x821BDE74;
} // Block from 821BDE50h-821BDE74h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821BDE74h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDE74( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDE74) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDE74);
		  /* 821BDE74h */ case    0:  		/* li R11, 0 */
		/* 821BDE74h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BDE74h case    0:*/		return 0x821BDE78;
	}
	return 0x821BDE78;
} // Block from 821BDE74h-821BDE78h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BDE78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDE78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDE78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDE78);
		  /* 821BDE78h */ case    0:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 821BDE78h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821BDE78h case    0:*/		return 0x821BDE7C;
		  /* 821BDE7Ch */ case    1:  		/* addic R10, R11, -1 */
		/* 821BDE7Ch case    1:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R11,0xFFFFFFFF);
		/* 821BDE7Ch case    1:*/		return 0x821BDE80;
		  /* 821BDE80h */ case    2:  		/* subfe R11, R10, R11 */
		/* 821BDE80h case    2:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821BDE80h case    2:*/		return 0x821BDE84;
		  /* 821BDE84h */ case    3:  		/* addi R11, R11, 11 */
		/* 821BDE84h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0xB);
		/* 821BDE84h case    3:*/		return 0x821BDE88;
		  /* 821BDE88h */ case    4:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821BDE88h case    4:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821BDE88h case    4:*/		return 0x821BDE8C;
		  /* 821BDE8Ch */ case    5:  		/* lwzx R11, <#[R11 + R4]> */
		/* 821BDE8Ch case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R4 + 0x00000000) );
		/* 821BDE8Ch case    5:*/		return 0x821BDE90;
		  /* 821BDE90h */ case    6:  		/* lwz R11, <#[R11]> */
		/* 821BDE90h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821BDE90h case    6:*/		return 0x821BDE94;
		  /* 821BDE94h */ case    7:  		/* rlwinm. R11, R11, 2, 31, 31 */
		/* 821BDE94h case    7:*/		cpu::op::rlwinm<1,2,31,31>(regs,&regs.R11,regs.R11);
		/* 821BDE94h case    7:*/		return 0x821BDE98;
		  /* 821BDE98h */ case    8:  		/* bc 12, CR0_EQ, 12 */
		/* 821BDE98h case    8:*/		if ( regs.CR[0].eq ) { return 0x821BDEA4;  }
		/* 821BDE98h case    8:*/		return 0x821BDE9C;
		  /* 821BDE9Ch */ case    9:  		/* li R3, 1 */
		/* 821BDE9Ch case    9:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821BDE9Ch case    9:*/		return 0x821BDEA0;
	}
	return 0x821BDEA0;
} // Block from 821BDE78h-821BDEA0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821BDEA0h
// Function '?FindAddChainConstant@Compiler@D3DXShader@@AAA_NPAVInstruction@2@W4Component@2@PAPAV32@PAW442@PAI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDEA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDEA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDEA0);
		  /* 821BDEA0h */ case    0:  		/* b 120 */
		/* 821BDEA0h case    0:*/		return 0x821BDF18;
		/* 821BDEA0h case    0:*/		return 0x821BDEA4;
	}
	return 0x821BDEA4;
} // Block from 821BDEA0h-821BDEA4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BDEA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDEA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDEA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDEA4);
		  /* 821BDEA4h */ case    0:  		/* cmplwi CR6, R29, 124 */
		/* 821BDEA4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x0000007C);
		/* 821BDEA4h case    0:*/		return 0x821BDEA8;
		  /* 821BDEA8h */ case    1:  		/* bc 4, CR6_EQ, 68 */
		/* 821BDEA8h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BDEEC;  }
		/* 821BDEA8h case    1:*/		return 0x821BDEAC;
		  /* 821BDEACh */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 821BDEACh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821BDEACh case    2:*/		return 0x821BDEB0;
		  /* 821BDEB0h */ case    3:  		/* mr R3, R30 */
		/* 821BDEB0h case    3:*/		regs.R3 = regs.R30;
		/* 821BDEB0h case    3:*/		return 0x821BDEB4;
		  /* 821BDEB4h */ case    4:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 821BDEB4h case    4:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 821BDEB4h case    4:*/		return 0x821BDEB8;
		  /* 821BDEB8h */ case    5:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 821BDEB8h case    5:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 821BDEB8h case    5:*/		return 0x821BDEBC;
		  /* 821BDEBCh */ case    6:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 821BDEBCh case    6:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 821BDEBCh case    6:*/		return 0x821BDEC0;
		  /* 821BDEC0h */ case    7:  		/* bl -367248 */
		/* 821BDEC0h case    7:*/		regs.LR = 0x821BDEC4; return 0x82164430;
		/* 821BDEC0h case    7:*/		return 0x821BDEC4;
		  /* 821BDEC4h */ case    8:  		/* addi R10, R31, -8 */
		/* 821BDEC4h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0xFFFFFFF8);
		/* 821BDEC4h case    8:*/		return 0x821BDEC8;
		  /* 821BDEC8h */ case    9:  		/* lwz R11, <#[R30 + 12]> */
		/* 821BDEC8h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000000C) );
		/* 821BDEC8h case    9:*/		return 0x821BDECC;
		  /* 821BDECCh */ case   10:  		/* lwzx R10, <#[R3 + R10]> */
		/* 821BDECCh case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + regs.R10 + 0x00000000) );
		/* 821BDECCh case   10:*/		return 0x821BDED0;
		  /* 821BDED0h */ case   11:  		/* rlwinm R10, R10, 0, 17, 31 */
		/* 821BDED0h case   11:*/		cpu::op::rlwinm<0,0,17,31>(regs,&regs.R10,regs.R10);
		/* 821BDED0h case   11:*/		return 0x821BDED4;
		  /* 821BDED4h */ case   12:  		/* mulli R10, R10, 40 */
		/* 821BDED4h case   12:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x28);
		/* 821BDED4h case   12:*/		return 0x821BDED8;
		  /* 821BDED8h */ case   13:  		/* add R11, R10, R11 */
		/* 821BDED8h case   13:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821BDED8h case   13:*/		return 0x821BDEDC;
		  /* 821BDEDCh */ case   14:  		/* lwz R11, <#[R11 + 4]> */
		/* 821BDEDCh case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821BDEDCh case   14:*/		return 0x821BDEE0;
		  /* 821BDEE0h */ case   15:  		/* rlwinm R11, R11, 0, 25, 27 */
		/* 821BDEE0h case   15:*/		cpu::op::rlwinm<0,0,25,27>(regs,&regs.R11,regs.R11);
		/* 821BDEE0h case   15:*/		return 0x821BDEE4;
		  /* 821BDEE4h */ case   16:  		/* cmplwi CR6, R11, 48 */
		/* 821BDEE4h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000030);
		/* 821BDEE4h case   16:*/		return 0x821BDEE8;
		  /* 821BDEE8h */ case   17:  		/* bc 12, CR6_EQ, -76 */
		/* 821BDEE8h case   17:*/		if ( regs.CR[6].eq ) { return 0x821BDE9C;  }
		/* 821BDEE8h case   17:*/		return 0x821BDEEC;
	}
	return 0x821BDEEC;
} // Block from 821BDEA4h-821BDEECh (18 instructions)

//////////////////////////////////////////////////////
// Block at 821BDEECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDEEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDEEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDEEC);
		  /* 821BDEECh */ case    0:  		/* cmplwi CR6, R28, 1 */
		/* 821BDEECh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000001);
		/* 821BDEECh case    0:*/		return 0x821BDEF0;
		  /* 821BDEF0h */ case    1:  		/* bc 12, CR6_LT, 36 */
		/* 821BDEF0h case    1:*/		if ( regs.CR[6].lt ) { return 0x821BDF14;  }
		/* 821BDEF0h case    1:*/		return 0x821BDEF4;
		  /* 821BDEF4h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 821BDEF4h case    2:*/		if ( regs.CR[6].eq ) { return 0x821BDF04;  }
		/* 821BDEF4h case    2:*/		return 0x821BDEF8;
		  /* 821BDEF8h */ case    3:  		/* li R4, 4800 */
		/* 821BDEF8h case    3:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 821BDEF8h case    3:*/		return 0x821BDEFC;
		  /* 821BDEFCh */ case    4:  		/* mr R3, R30 */
		/* 821BDEFCh case    4:*/		regs.R3 = regs.R30;
		/* 821BDEFCh case    4:*/		return 0x821BDF00;
		  /* 821BDF00h */ case    5:  		/* bl -442520 */
		/* 821BDF00h case    5:*/		regs.LR = 0x821BDF04; return 0x82151E68;
		/* 821BDF00h case    5:*/		return 0x821BDF04;
	}
	return 0x821BDF04;
} // Block from 821BDEECh-821BDF04h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BDF04h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDF04( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDF04) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDF04);
		  /* 821BDF04h */ case    0:  		/* addi R11, R29, -118 */
		/* 821BDF04h case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R29,0xFFFFFF8A);
		/* 821BDF04h case    0:*/		return 0x821BDF08;
		  /* 821BDF08h */ case    1:  		/* cntlzw R11, R11 */
		/* 821BDF08h case    1:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 821BDF08h case    1:*/		return 0x821BDF0C;
		  /* 821BDF0Ch */ case    2:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 821BDF0Ch case    2:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 821BDF0Ch case    2:*/		return 0x821BDF10;
		  /* 821BDF10h */ case    3:  		/* b 8 */
		/* 821BDF10h case    3:*/		return 0x821BDF18;
		/* 821BDF10h case    3:*/		return 0x821BDF14;
	}
	return 0x821BDF14;
} // Block from 821BDF04h-821BDF14h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BDF14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDF14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDF14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDF14);
		  /* 821BDF14h */ case    0:  		/* li R3, 0 */
		/* 821BDF14h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821BDF14h case    0:*/		return 0x821BDF18;
	}
	return 0x821BDF18;
} // Block from 821BDF14h-821BDF18h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BDF18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDF18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDF18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDF18);
		  /* 821BDF18h */ case    0:  		/* addi R1, R1, 128 */
		/* 821BDF18h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821BDF18h case    0:*/		return 0x821BDF1C;
		  /* 821BDF1Ch */ case    1:  		/* b -1231988 */
		/* 821BDF1Ch case    1:*/		return 0x820912A8;
		/* 821BDF1Ch case    1:*/		return 0x821BDF20;
	}
	return 0x821BDF20;
} // Block from 821BDF18h-821BDF20h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BDF20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDF20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDF20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDF20);
		  /* 821BDF20h */ case    0:  		/* mfspr R12, LR */
		/* 821BDF20h case    0:*/		regs.R12 = regs.LR;
		/* 821BDF20h case    0:*/		return 0x821BDF24;
		  /* 821BDF24h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821BDF24h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821BDF24h case    1:*/		return 0x821BDF28;
		  /* 821BDF28h */ case    2:  		/* std R31, <#[R1 - 16]> */
		/* 821BDF28h case    2:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821BDF28h case    2:*/		return 0x821BDF2C;
		  /* 821BDF2Ch */ case    3:  		/* stwu R1, <#[R1 - 96]> */
		/* 821BDF2Ch case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFFA0) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFFA0);
		/* 821BDF2Ch case    3:*/		return 0x821BDF30;
		  /* 821BDF30h */ case    4:  		/* lwz R11, <#[R4 + 8]> */
		/* 821BDF30h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821BDF30h case    4:*/		return 0x821BDF34;
		  /* 821BDF34h */ case    5:  		/* mr R31, R4 */
		/* 821BDF34h case    5:*/		regs.R31 = regs.R4;
		/* 821BDF34h case    5:*/		return 0x821BDF38;
		  /* 821BDF38h */ case    6:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821BDF38h case    6:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821BDF38h case    6:*/		return 0x821BDF3C;
		  /* 821BDF3Ch */ case    7:  		/* cmpwi CR6, R11, 5 */
		/* 821BDF3Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000005);
		/* 821BDF3Ch case    7:*/		return 0x821BDF40;
		  /* 821BDF40h */ case    8:  		/* bc 12, CR6_LT, 92 */
		/* 821BDF40h case    8:*/		if ( regs.CR[6].lt ) { return 0x821BDF9C;  }
		/* 821BDF40h case    8:*/		return 0x821BDF44;
		  /* 821BDF44h */ case    9:  		/* cmpwi CR6, R11, 8 */
		/* 821BDF44h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000008);
		/* 821BDF44h case    9:*/		return 0x821BDF48;
		  /* 821BDF48h */ case   10:  		/* bc 4, CR6_GT, 76 */
		/* 821BDF48h case   10:*/		if ( !regs.CR[6].gt ) { return 0x821BDF94;  }
		/* 821BDF48h case   10:*/		return 0x821BDF4C;
		  /* 821BDF4Ch */ case   11:  		/* cmpwi CR6, R11, 24 */
		/* 821BDF4Ch case   11:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000018);
		/* 821BDF4Ch case   11:*/		return 0x821BDF50;
		  /* 821BDF50h */ case   12:  		/* bc 4, CR6_GT, 76 */
		/* 821BDF50h case   12:*/		if ( !regs.CR[6].gt ) { return 0x821BDF9C;  }
		/* 821BDF50h case   12:*/		return 0x821BDF54;
		  /* 821BDF54h */ case   13:  		/* cmpwi CR6, R11, 28 */
		/* 821BDF54h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000001C);
		/* 821BDF54h case   13:*/		return 0x821BDF58;
		  /* 821BDF58h */ case   14:  		/* bc 4, CR6_GT, 60 */
		/* 821BDF58h case   14:*/		if ( !regs.CR[6].gt ) { return 0x821BDF94;  }
		/* 821BDF58h case   14:*/		return 0x821BDF5C;
		  /* 821BDF5Ch */ case   15:  		/* cmpwi CR6, R11, 124 */
		/* 821BDF5Ch case   15:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x0000007C);
		/* 821BDF5Ch case   15:*/		return 0x821BDF60;
		  /* 821BDF60h */ case   16:  		/* bc 4, CR6_EQ, 60 */
		/* 821BDF60h case   16:*/		if ( !regs.CR[6].eq ) { return 0x821BDF9C;  }
		/* 821BDF60h case   16:*/		return 0x821BDF64;
		  /* 821BDF64h */ case   17:  		/* lwz R11, <#[R4 + 8]> */
		/* 821BDF64h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821BDF64h case   17:*/		return 0x821BDF68;
		  /* 821BDF68h */ case   18:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 821BDF68h case   18:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 821BDF68h case   18:*/		return 0x821BDF6C;
		  /* 821BDF6Ch */ case   19:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 821BDF6Ch case   19:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 821BDF6Ch case   19:*/		return 0x821BDF70;
		  /* 821BDF70h */ case   20:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 821BDF70h case   20:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 821BDF70h case   20:*/		return 0x821BDF74;
		  /* 821BDF74h */ case   21:  		/* bl -367428 */
		/* 821BDF74h case   21:*/		regs.LR = 0x821BDF78; return 0x82164430;
		/* 821BDF74h case   21:*/		return 0x821BDF78;
		  /* 821BDF78h */ case   22:  		/* addi R11, R31, -8 */
		/* 821BDF78h case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFF8);
		/* 821BDF78h case   22:*/		return 0x821BDF7C;
		  /* 821BDF7Ch */ case   23:  		/* lwzx R11, <#[R3 + R11]> */
		/* 821BDF7Ch case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 821BDF7Ch case   23:*/		return 0x821BDF80;
		  /* 821BDF80h */ case   24:  		/* rlwinm R11, R11, 0, 1, 2 */
		/* 821BDF80h case   24:*/		cpu::op::rlwinm<0,0,1,2>(regs,&regs.R11,regs.R11);
		/* 821BDF80h case   24:*/		return 0x821BDF84;
		  /* 821BDF84h */ case   25:  		/* addis R11, R11, -8192 */
		/* 821BDF84h case   25:*/		cpu::op::addis<0>(regs,&regs.R11,regs.R11,0xFFFFE000);
		/* 821BDF84h case   25:*/		return 0x821BDF88;
		  /* 821BDF88h */ case   26:  		/* cntlzw R11, R11 */
		/* 821BDF88h case   26:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 821BDF88h case   26:*/		return 0x821BDF8C;
		  /* 821BDF8Ch */ case   27:  		/* rlwinm R3, R11, 27, 31, 31 */
		/* 821BDF8Ch case   27:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R3,regs.R11);
		/* 821BDF8Ch case   27:*/		return 0x821BDF90;
		  /* 821BDF90h */ case   28:  		/* b 16 */
		/* 821BDF90h case   28:*/		return 0x821BDFA0;
		/* 821BDF90h case   28:*/		return 0x821BDF94;
	}
	return 0x821BDF94;
} // Block from 821BDF20h-821BDF94h (29 instructions)

//////////////////////////////////////////////////////
// Block at 821BDF94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDF94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDF94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDF94);
		  /* 821BDF94h */ case    0:  		/* li R3, 1 */
		/* 821BDF94h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821BDF94h case    0:*/		return 0x821BDF98;
		  /* 821BDF98h */ case    1:  		/* b 8 */
		/* 821BDF98h case    1:*/		return 0x821BDFA0;
		/* 821BDF98h case    1:*/		return 0x821BDF9C;
	}
	return 0x821BDF9C;
} // Block from 821BDF94h-821BDF9Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BDF9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDF9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDF9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDF9C);
		  /* 821BDF9Ch */ case    0:  		/* li R3, 0 */
		/* 821BDF9Ch case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821BDF9Ch case    0:*/		return 0x821BDFA0;
	}
	return 0x821BDFA0;
} // Block from 821BDF9Ch-821BDFA0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BDFA0h
// Function '?ComputeResultPrecision@Compiler@D3DXShader@@SA?AW4ConstantValueType@2@PAVInstruction@2@W4Component@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDFA0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDFA0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDFA0);
		  /* 821BDFA0h */ case    0:  		/* addi R1, R1, 96 */
		/* 821BDFA0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x60);
		/* 821BDFA0h case    0:*/		return 0x821BDFA4;
		  /* 821BDFA4h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 821BDFA4h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821BDFA4h case    1:*/		return 0x821BDFA8;
		  /* 821BDFA8h */ case    2:  		/* mtspr LR, R12 */
		/* 821BDFA8h case    2:*/		regs.LR = regs.R12;
		/* 821BDFA8h case    2:*/		return 0x821BDFAC;
		  /* 821BDFACh */ case    3:  		/* ld R31, <#[R1 - 16]> */
		/* 821BDFACh case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821BDFACh case    3:*/		return 0x821BDFB0;
		  /* 821BDFB0h */ case    4:  		/* bclr 20, CR0_LT */
		/* 821BDFB0h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BDFB0h case    4:*/		return 0x821BDFB4;
	}
	return 0x821BDFB4;
} // Block from 821BDFA0h-821BDFB4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BDFB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDFB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDFB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDFB4);
		  /* 821BDFB4h */ case    0:  		/* nop */
		/* 821BDFB4h case    0:*/		cpu::op::nop();
		/* 821BDFB4h case    0:*/		return 0x821BDFB8;
	}
	return 0x821BDFB8;
} // Block from 821BDFB4h-821BDFB8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BDFB8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BDFB8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BDFB8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BDFB8);
		  /* 821BDFB8h */ case    0:  		/* mfspr R12, LR */
		/* 821BDFB8h case    0:*/		regs.R12 = regs.LR;
		/* 821BDFB8h case    0:*/		return 0x821BDFBC;
		  /* 821BDFBCh */ case    1:  		/* bl -1232252 */
		/* 821BDFBCh case    1:*/		regs.LR = 0x821BDFC0; return 0x82091240;
		/* 821BDFBCh case    1:*/		return 0x821BDFC0;
		  /* 821BDFC0h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 821BDFC0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 821BDFC0h case    2:*/		return 0x821BDFC4;
		  /* 821BDFC4h */ case    3:  		/* mr R29, R3 */
		/* 821BDFC4h case    3:*/		regs.R29 = regs.R3;
		/* 821BDFC4h case    3:*/		return 0x821BDFC8;
		  /* 821BDFC8h */ case    4:  		/* mr R31, R4 */
		/* 821BDFC8h case    4:*/		regs.R31 = regs.R4;
		/* 821BDFC8h case    4:*/		return 0x821BDFCC;
		  /* 821BDFCCh */ case    5:  		/* mr R26, R5 */
		/* 821BDFCCh case    5:*/		regs.R26 = regs.R5;
		/* 821BDFCCh case    5:*/		return 0x821BDFD0;
		  /* 821BDFD0h */ case    6:  		/* mr R25, R6 */
		/* 821BDFD0h case    6:*/		regs.R25 = regs.R6;
		/* 821BDFD0h case    6:*/		return 0x821BDFD4;
		  /* 821BDFD4h */ case    7:  		/* mr R24, R7 */
		/* 821BDFD4h case    7:*/		regs.R24 = regs.R7;
		/* 821BDFD4h case    7:*/		return 0x821BDFD8;
		  /* 821BDFD8h */ case    8:  		/* addi R23, R4, 4 */
		/* 821BDFD8h case    8:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R4,0x4);
		/* 821BDFD8h case    8:*/		return 0x821BDFDC;
		  /* 821BDFDCh */ case    9:  		/* lwz R30, <#[R23]> */
		/* 821BDFDCh case    9:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R23 + 0x00000000) );
		/* 821BDFDCh case    9:*/		return 0x821BDFE0;
		  /* 821BDFE0h */ case   10:  		/* cmplwi CR6, R30, 0 */
		/* 821BDFE0h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821BDFE0h case   10:*/		return 0x821BDFE4;
		  /* 821BDFE4h */ case   11:  		/* bc 12, CR6_EQ, 188 */
		/* 821BDFE4h case   11:*/		if ( regs.CR[6].eq ) { return 0x821BE0A0;  }
		/* 821BDFE4h case   11:*/		return 0x821BDFE8;
		  /* 821BDFE8h */ case   12:  		/* lwz R27, <#[R30 + 16]> */
		/* 821BDFE8h case   12:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R30 + 0x00000010) );
		/* 821BDFE8h case   12:*/		return 0x821BDFEC;
		  /* 821BDFECh */ case   13:  		/* cmplwi CR6, R27, 0 */
		/* 821BDFECh case   13:*/		cpu::op::cmplwi<6>(regs,regs.R27,0x00000000);
		/* 821BDFECh case   13:*/		return 0x821BDFF0;
		  /* 821BDFF0h */ case   14:  		/* bc 12, CR6_EQ, 156 */
		/* 821BDFF0h case   14:*/		if ( regs.CR[6].eq ) { return 0x821BE08C;  }
		/* 821BDFF0h case   14:*/		return 0x821BDFF4;
		  /* 821BDFF4h */ case   15:  		/* lwz R11, <#[R30]> */
		/* 821BDFF4h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821BDFF4h case   15:*/		return 0x821BDFF8;
		  /* 821BDFF8h */ case   16:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 821BDFF8h case   16:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 821BDFF8h case   16:*/		return 0x821BDFFC;
		  /* 821BDFFCh */ case   17:  		/* bc 12, CR0_EQ, 144 */
		/* 821BDFFCh case   17:*/		if ( regs.CR[0].eq ) { return 0x821BE08C;  }
		/* 821BDFFCh case   17:*/		return 0x821BE000;
		  /* 821BE000h */ case   18:  		/* lwz R28, <#[R27 + 8]> */
		/* 821BE000h case   18:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R27 + 0x00000008) );
		/* 821BE000h case   18:*/		return 0x821BE004;
		  /* 821BE004h */ case   19:  		/* rlwinm R11, R28, 25, 25, 31 */
		/* 821BE004h case   19:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R28);
		/* 821BE004h case   19:*/		return 0x821BE008;
		  /* 821BE008h */ case   20:  		/* cmpwi CR6, R11, 5 */
		/* 821BE008h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000005);
		/* 821BE008h case   20:*/		return 0x821BE00C;
		  /* 821BE00Ch */ case   21:  		/* bc 12, CR6_LT, 128 */
		/* 821BE00Ch case   21:*/		if ( regs.CR[6].lt ) { return 0x821BE08C;  }
		/* 821BE00Ch case   21:*/		return 0x821BE010;
		  /* 821BE010h */ case   22:  		/* cmpwi CR6, R11, 8 */
		/* 821BE010h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000008);
		/* 821BE010h case   22:*/		return 0x821BE014;
		  /* 821BE014h */ case   23:  		/* bc 4, CR6_GT, 92 */
		/* 821BE014h case   23:*/		if ( !regs.CR[6].gt ) { return 0x821BE070;  }
		/* 821BE014h case   23:*/		return 0x821BE018;
		  /* 821BE018h */ case   24:  		/* cmpwi CR6, R11, 55 */
		/* 821BE018h case   24:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000037);
		/* 821BE018h case   24:*/		return 0x821BE01C;
		  /* 821BE01Ch */ case   25:  		/* bc 12, CR6_EQ, 84 */
		/* 821BE01Ch case   25:*/		if ( regs.CR[6].eq ) { return 0x821BE070;  }
		/* 821BE01Ch case   25:*/		return 0x821BE020;
		  /* 821BE020h */ case   26:  		/* cmpwi CR6, R11, 103 */
		/* 821BE020h case   26:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000067);
		/* 821BE020h case   26:*/		return 0x821BE024;
		  /* 821BE024h */ case   27:  		/* bc 4, CR6_EQ, 104 */
		/* 821BE024h case   27:*/		if ( !regs.CR[6].eq ) { return 0x821BE08C;  }
		/* 821BE024h case   27:*/		return 0x821BE028;
		  /* 821BE028h */ case   28:  		/* lwz R11, <#[R31 + 8]> */
		/* 821BE028h case   28:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821BE028h case   28:*/		return 0x821BE02C;
		  /* 821BE02Ch */ case   29:  		/* li R6, 0 */
		/* 821BE02Ch case   29:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821BE02Ch case   29:*/		return 0x821BE030;
	}
	return 0x821BE030;
} // Block from 821BDFB8h-821BE030h (30 instructions)

//////////////////////////////////////////////////////
// Block at 821BE030h
// Function '?ComputeBinaryOperatorPrecision@Compiler@D3DXShader@@SA?AW4ConstantValueType@2@W432@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE030( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE030) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE030);
		  /* 821BE030h */ case    0:  		/* li R4, 103 */
		/* 821BE030h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x67);
		/* 821BE030h case    0:*/		return 0x821BE034;
		  /* 821BE034h */ case    1:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 821BE034h case    1:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 821BE034h case    1:*/		return 0x821BE038;
		  /* 821BE038h */ case    2:  		/* mr R3, R29 */
		/* 821BE038h case    2:*/		regs.R3 = regs.R29;
		/* 821BE038h case    2:*/		return 0x821BE03C;
		  /* 821BE03Ch */ case    3:  		/* bl -367628 */
		/* 821BE03Ch case    3:*/		regs.LR = 0x821BE040; return 0x82164430;
		/* 821BE03Ch case    3:*/		return 0x821BE040;
		  /* 821BE040h */ case    4:  		/* mr R22, R3 */
		/* 821BE040h case    4:*/		regs.R22 = regs.R3;
		/* 821BE040h case    4:*/		return 0x821BE044;
		  /* 821BE044h */ case    5:  		/* li R6, 0 */
		/* 821BE044h case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821BE044h case    5:*/		return 0x821BE048;
	}
	return 0x821BE048;
} // Block from 821BE030h-821BE048h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BE048h
// Function '?SortLoopsByBenefit@D3DXShader@@YAHPBX0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE048( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE048) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE048);
		  /* 821BE048h */ case    0:  		/* rlwinm R5, R28, 13, 29, 31 */
		/* 821BE048h case    0:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R28);
		/* 821BE048h case    0:*/		return 0x821BE04C;
		  /* 821BE04Ch */ case    1:  		/* li R4, 103 */
		/* 821BE04Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x67);
		/* 821BE04Ch case    1:*/		return 0x821BE050;
		  /* 821BE050h */ case    2:  		/* mr R3, R29 */
		/* 821BE050h case    2:*/		regs.R3 = regs.R29;
		/* 821BE050h case    2:*/		return 0x821BE054;
		  /* 821BE054h */ case    3:  		/* bl -367652 */
		/* 821BE054h case    3:*/		regs.LR = 0x821BE058; return 0x82164430;
		/* 821BE054h case    3:*/		return 0x821BE058;
		  /* 821BE058h */ case    4:  		/* addi R11, R27, -4 */
		/* 821BE058h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R27,0xFFFFFFFC);
		/* 821BE058h case    4:*/		return 0x821BE05C;
		  /* 821BE05Ch */ case    5:  		/* addi R10, R31, -4 */
		/* 821BE05Ch case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0xFFFFFFFC);
		/* 821BE05Ch case    5:*/		return 0x821BE060;
		  /* 821BE060h */ case    6:  		/* lwzx R11, <#[R3 + R11]> */
		/* 821BE060h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 821BE060h case    6:*/		return 0x821BE064;
		  /* 821BE064h */ case    7:  		/* lwzx R10, <#[R22 + R10]> */
		/* 821BE064h case    7:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R22 + regs.R10 + 0x00000000) );
		/* 821BE064h case    7:*/		return 0x821BE068;
		  /* 821BE068h */ case    8:  		/* cmpw CR6, R11, R10 */
		/* 821BE068h case    8:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 821BE068h case    8:*/		return 0x821BE06C;
		  /* 821BE06Ch */ case    9:  		/* bc 4, CR6_EQ, 32 */
		/* 821BE06Ch case    9:*/		if ( !regs.CR[6].eq ) { return 0x821BE08C;  }
		/* 821BE06Ch case    9:*/		return 0x821BE070;
	}
	return 0x821BE070;
} // Block from 821BE048h-821BE070h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821BE070h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE070( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE070) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE070);
		  /* 821BE070h */ case    0:  		/* mr R8, R24 */
		/* 821BE070h case    0:*/		regs.R8 = regs.R24;
		/* 821BE070h case    0:*/		return 0x821BE074;
		  /* 821BE074h */ case    1:  		/* mr R7, R25 */
		/* 821BE074h case    1:*/		regs.R7 = regs.R25;
		/* 821BE074h case    1:*/		return 0x821BE078;
		  /* 821BE078h */ case    2:  		/* mr R6, R26 */
		/* 821BE078h case    2:*/		regs.R6 = regs.R26;
		/* 821BE078h case    2:*/		return 0x821BE07C;
		  /* 821BE07Ch */ case    3:  		/* mr R5, R30 */
		/* 821BE07Ch case    3:*/		regs.R5 = regs.R30;
		/* 821BE07Ch case    3:*/		return 0x821BE080;
	}
	return 0x821BE080;
} // Block from 821BE070h-821BE080h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BE080h
// Function '?ComputeInductionVariableStartValue@D3DXShader@@YA_NPAUInductionVariable@1@_NNPAN@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE080( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE080) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE080);
		  /* 821BE080h */ case    0:  		/* mr R4, R31 */
		/* 821BE080h case    0:*/		regs.R4 = regs.R31;
		/* 821BE080h case    0:*/		return 0x821BE084;
		  /* 821BE084h */ case    1:  		/* mr R3, R29 */
		/* 821BE084h case    1:*/		regs.R3 = regs.R29;
		/* 821BE084h case    1:*/		return 0x821BE088;
		  /* 821BE088h */ case    2:  		/* bl 417568 */
		/* 821BE088h case    2:*/		regs.LR = 0x821BE08C; return 0x82223FA8;
		/* 821BE088h case    2:*/		return 0x821BE08C;
	}
	return 0x821BE08C;
} // Block from 821BE080h-821BE08Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BE08Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE08C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE08C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE08C);
		  /* 821BE08Ch */ case    0:  		/* lwz R11, <#[R23]> */
		/* 821BE08Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000000) );
		/* 821BE08Ch case    0:*/		return 0x821BE090;
		  /* 821BE090h */ case    1:  		/* cmplw CR6, R11, R30 */
		/* 821BE090h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 821BE090h case    1:*/		return 0x821BE094;
		  /* 821BE094h */ case    2:  		/* bc 4, CR6_EQ, -184 */
		/* 821BE094h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821BDFDC;  }
		/* 821BE094h case    2:*/		return 0x821BE098;
		  /* 821BE098h */ case    3:  		/* addi R23, R30, 8 */
		/* 821BE098h case    3:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R30,0x8);
		/* 821BE098h case    3:*/		return 0x821BE09C;
		  /* 821BE09Ch */ case    4:  		/* b -192 */
		/* 821BE09Ch case    4:*/		return 0x821BDFDC;
		/* 821BE09Ch case    4:*/		return 0x821BE0A0;
	}
	return 0x821BE0A0;
} // Block from 821BE08Ch-821BE0A0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BE0A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE0A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE0A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE0A0);
		  /* 821BE0A0h */ case    0:  		/* addi R1, R1, 176 */
		/* 821BE0A0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 821BE0A0h case    0:*/		return 0x821BE0A4;
		  /* 821BE0A4h */ case    1:  		/* b -1232404 */
		/* 821BE0A4h case    1:*/		return 0x82091290;
		/* 821BE0A4h case    1:*/		return 0x821BE0A8;
	}
	return 0x821BE0A8;
} // Block from 821BE0A0h-821BE0A8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BE0A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE0A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE0A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE0A8);
		  /* 821BE0A8h */ case    0:  		/* mfspr R12, LR */
		/* 821BE0A8h case    0:*/		regs.R12 = regs.LR;
		/* 821BE0A8h case    0:*/		return 0x821BE0AC;
		  /* 821BE0ACh */ case    1:  		/* bl -1232464 */
		/* 821BE0ACh case    1:*/		regs.LR = 0x821BE0B0; return 0x8209125C;
		/* 821BE0ACh case    1:*/		return 0x821BE0B0;
		  /* 821BE0B0h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821BE0B0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821BE0B0h case    2:*/		return 0x821BE0B4;
		  /* 821BE0B4h */ case    3:  		/* lwz R11, <#[R4 + 8]> */
		/* 821BE0B4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821BE0B4h case    3:*/		return 0x821BE0B8;
		  /* 821BE0B8h */ case    4:  		/* mr R30, R3 */
		/* 821BE0B8h case    4:*/		regs.R30 = regs.R3;
		/* 821BE0B8h case    4:*/		return 0x821BE0BC;
		  /* 821BE0BCh */ case    5:  		/* mr R29, R6 */
		/* 821BE0BCh case    5:*/		regs.R29 = regs.R6;
		/* 821BE0BCh case    5:*/		return 0x821BE0C0;
		  /* 821BE0C0h */ case    6:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821BE0C0h case    6:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821BE0C0h case    6:*/		return 0x821BE0C4;
		  /* 821BE0C4h */ case    7:  		/* cmplwi CR6, R11, 15104 */
		/* 821BE0C4h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003B00);
		/* 821BE0C4h case    7:*/		return 0x821BE0C8;
		  /* 821BE0C8h */ case    8:  		/* bc 4, CR6_EQ, 12 */
		/* 821BE0C8h case    8:*/		if ( !regs.CR[6].eq ) { return 0x821BE0D4;  }
		/* 821BE0C8h case    8:*/		return 0x821BE0CC;
		  /* 821BE0CCh */ case    9:  		/* lwz R11, <#[R4 + 48]> */
		/* 821BE0CCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000030) );
		/* 821BE0CCh case    9:*/		return 0x821BE0D0;
		  /* 821BE0D0h */ case   10:  		/* lwz R4, <#[R11 + 12]> */
		/* 821BE0D0h case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x0000000C) );
		/* 821BE0D0h case   10:*/		return 0x821BE0D4;
	}
	return 0x821BE0D4;
} // Block from 821BE0A8h-821BE0D4h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821BE0D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE0D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE0D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE0D4);
		  /* 821BE0D4h */ case    0:  		/* lwz R9, <#[R4 + 44]> */
		/* 821BE0D4h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x0000002C) );
		/* 821BE0D4h case    0:*/		return 0x821BE0D8;
		  /* 821BE0D8h */ case    1:  		/* li R10, 0 */
		/* 821BE0D8h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821BE0D8h case    1:*/		return 0x821BE0DC;
		  /* 821BE0DCh */ case    2:  		/* li R11, 0 */
		/* 821BE0DCh case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BE0DCh case    2:*/		return 0x821BE0E0;
		  /* 821BE0E0h */ case    3:  		/* lwz R8, <#[R9]> */
		/* 821BE0E0h case    3:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 821BE0E0h case    3:*/		return 0x821BE0E4;
		  /* 821BE0E4h */ case    4:  		/* rlwinm. R7, R8, 7, 29, 31 */
		/* 821BE0E4h case    4:*/		cpu::op::rlwinm<1,7,29,31>(regs,&regs.R7,regs.R8);
		/* 821BE0E4h case    4:*/		return 0x821BE0E8;
		  /* 821BE0E8h */ case    5:  		/* bc 12, CR0_EQ, 76 */
		/* 821BE0E8h case    5:*/		if ( regs.CR[0].eq ) { return 0x821BE134;  }
		/* 821BE0E8h case    5:*/		return 0x821BE0EC;
		  /* 821BE0ECh */ case    6:  		/* li R9, 0 */
		/* 821BE0ECh case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821BE0ECh case    6:*/		return 0x821BE0F0;
	}
	return 0x821BE0F0;
} // Block from 821BE0D4h-821BE0F0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BE0F0h
// Function '?IsArrayLoadAndCanUseIndexRegister@Compiler@D3DXShader@@AAA_NPAUInductionVariable@2@PAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE0F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE0F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE0F0);
		  /* 821BE0F0h */ case    0:  		/* rlwinm R6, R8, 27, 24, 31 */
		/* 821BE0F0h case    0:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R6,regs.R8);
		/* 821BE0F0h case    0:*/		return 0x821BE0F4;
		  /* 821BE0F4h */ case    1:  		/* li R5, 1 */
		/* 821BE0F4h case    1:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 821BE0F4h case    1:*/		return 0x821BE0F8;
		  /* 821BE0F8h */ case    2:  		/* srw R6, R6, R9 */
		/* 821BE0F8h case    2:*/		cpu::op::srw<0>(regs,&regs.R6,regs.R6,regs.R9);
		/* 821BE0F8h case    2:*/		return 0x821BE0FC;
		  /* 821BE0FCh */ case    3:  		/* rlwinm R6, R6, 0, 30, 31 */
		/* 821BE0FCh case    3:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R6,regs.R6);
		/* 821BE0FCh case    3:*/		return 0x821BE100;
		  /* 821BE100h */ case    4:  		/* addi R11, R11, 1 */
		/* 821BE100h case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821BE100h case    4:*/		return 0x821BE104;
		  /* 821BE104h */ case    5:  		/* slw R6, R5, R6 */
		/* 821BE104h case    5:*/		cpu::op::slw<0>(regs,&regs.R6,regs.R5,regs.R6);
		/* 821BE104h case    5:*/		return 0x821BE108;
		  /* 821BE108h */ case    6:  		/* or R10, R6, R10 */
		/* 821BE108h case    6:*/		cpu::op::or<0>(regs,&regs.R10,regs.R6,regs.R10);
		/* 821BE108h case    6:*/		return 0x821BE10C;
		  /* 821BE10Ch */ case    7:  		/* addi R9, R9, 2 */
		/* 821BE10Ch case    7:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x2);
		/* 821BE10Ch case    7:*/		return 0x821BE110;
		  /* 821BE110h */ case    8:  		/* cmplw CR6, R11, R7 */
		/* 821BE110h case    8:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R7);
		/* 821BE110h case    8:*/		return 0x821BE114;
		  /* 821BE114h */ case    9:  		/* bc 12, CR6_LT, -36 */
		/* 821BE114h case    9:*/		if ( regs.CR[6].lt ) { return 0x821BE0F0;  }
		/* 821BE114h case    9:*/		return 0x821BE118;
		  /* 821BE118h */ case   10:  		/* cmplwi CR6, R10, 0 */
		/* 821BE118h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821BE118h case   10:*/		return 0x821BE11C;
		  /* 821BE11Ch */ case   11:  		/* bc 12, CR6_EQ, 24 */
		/* 821BE11Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x821BE134;  }
		/* 821BE11Ch case   11:*/		return 0x821BE120;
		  /* 821BE120h */ case   12:  		/* addi R11, R10, -1 */
		/* 821BE120h case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0xFFFFFFFF);
		/* 821BE120h case   12:*/		return 0x821BE124;
		  /* 821BE124h */ case   13:  		/* andc R11, R10, R11 */
		/* 821BE124h case   13:*/		cpu::op::andc<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821BE124h case   13:*/		return 0x821BE128;
		  /* 821BE128h */ case   14:  		/* subf. R11, R11, R10 */
		/* 821BE128h case   14:*/		cpu::op::subf<1>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821BE128h case   14:*/		return 0x821BE12C;
		  /* 821BE12Ch */ case   15:  		/* li R11, 1 */
		/* 821BE12Ch case   15:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821BE12Ch case   15:*/		return 0x821BE130;
		  /* 821BE130h */ case   16:  		/* bc 12, CR0_EQ, 8 */
		/* 821BE130h case   16:*/		if ( regs.CR[0].eq ) { return 0x821BE138;  }
		/* 821BE130h case   16:*/		return 0x821BE134;
	}
	return 0x821BE134;
} // Block from 821BE0F0h-821BE134h (17 instructions)

//////////////////////////////////////////////////////
// Block at 821BE134h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE134( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE134) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE134);
		  /* 821BE134h */ case    0:  		/* li R11, 0 */
		/* 821BE134h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BE134h case    0:*/		return 0x821BE138;
	}
	return 0x821BE138;
} // Block from 821BE134h-821BE138h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BE138h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE138( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE138) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE138);
		  /* 821BE138h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821BE138h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821BE138h case    0:*/		return 0x821BE13C;
		  /* 821BE13Ch */ case    1:  		/* bc 12, CR0_EQ, 124 */
		/* 821BE13Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x821BE1B8;  }
		/* 821BE13Ch case    1:*/		return 0x821BE140;
	}
	return 0x821BE140;
} // Block from 821BE138h-821BE140h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BE140h
// Function '?FindSetBit@?$FixedSizeBitSet@I$00@D3DXShader@@QAAII@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE140( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE140) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE140);
		  /* 821BE140h */ case    0:  		/* li R11, 0 */
		/* 821BE140h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BE140h case    0:*/		return 0x821BE144;
		  /* 821BE144h */ case    1:  		/* stw R4, <#[R1 + 84]> */
		/* 821BE144h case    1:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x00000054) );
		/* 821BE144h case    1:*/		return 0x821BE148;
		  /* 821BE148h */ case    2:  		/* mr R31, R4 */
		/* 821BE148h case    2:*/		regs.R31 = regs.R4;
		/* 821BE148h case    2:*/		return 0x821BE14C;
		  /* 821BE14Ch */ case    3:  		/* stw R11, <#[R1 + 80]> */
		/* 821BE14Ch case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 821BE14Ch case    3:*/		return 0x821BE150;
		  /* 821BE150h */ case    4:  		/* li R10, 0 */
		/* 821BE150h case    4:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821BE150h case    4:*/		return 0x821BE154;
		  /* 821BE154h */ case    5:  		/* lwz R3, <#[R31 + 44]> */
		/* 821BE154h case    5:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821BE154h case    5:*/		return 0x821BE158;
		  /* 821BE158h */ case    6:  		/* li R9, 0 */
		/* 821BE158h case    6:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821BE158h case    6:*/		return 0x821BE15C;
		  /* 821BE15Ch */ case    7:  		/* lwz R4, <#[R1 + 80]> */
		/* 821BE15Ch case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000050) );
		/* 821BE15Ch case    7:*/		return 0x821BE160;
		  /* 821BE160h */ case    8:  		/* li R8, 0 */
		/* 821BE160h case    8:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821BE160h case    8:*/		return 0x821BE164;
		  /* 821BE164h */ case    9:  		/* addi R7, R1, 88 */
		/* 821BE164h case    9:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x58);
		/* 821BE164h case    9:*/		return 0x821BE168;
		  /* 821BE168h */ case   10:  		/* addi R6, R1, 80 */
		/* 821BE168h case   10:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x50);
		/* 821BE168h case   10:*/		return 0x821BE16C;
		  /* 821BE16Ch */ case   11:  		/* addi R5, R1, 84 */
		/* 821BE16Ch case   11:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x54);
		/* 821BE16Ch case   11:*/		return 0x821BE170;
		  /* 821BE170h */ case   12:  		/* bl 414560 */
		/* 821BE170h case   12:*/		regs.LR = 0x821BE174; return 0x822234D0;
		/* 821BE170h case   12:*/		return 0x821BE174;
		  /* 821BE174h */ case   13:  		/* lwz R31, <#[R1 + 84]> */
		/* 821BE174h case   13:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000054) );
		/* 821BE174h case   13:*/		return 0x821BE178;
		  /* 821BE178h */ case   14:  		/* lwz R11, <#[R31 + 8]> */
		/* 821BE178h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821BE178h case   14:*/		return 0x821BE17C;
		  /* 821BE17Ch */ case   15:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821BE17Ch case   15:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821BE17Ch case   15:*/		return 0x821BE180;
		  /* 821BE180h */ case   16:  		/* cmplwi CR6, R11, 13184 */
		/* 821BE180h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003380);
		/* 821BE180h case   16:*/		return 0x821BE184;
		  /* 821BE184h */ case   17:  		/* bc 4, CR6_EQ, 24 */
		/* 821BE184h case   17:*/		if ( !regs.CR[6].eq ) { return 0x821BE19C;  }
		/* 821BE184h case   17:*/		return 0x821BE188;
		  /* 821BE188h */ case   18:  		/* mr R4, R30 */
		/* 821BE188h case   18:*/		regs.R4 = regs.R30;
		/* 821BE188h case   18:*/		return 0x821BE18C;
		  /* 821BE18Ch */ case   19:  		/* mr R3, R31 */
		/* 821BE18Ch case   19:*/		regs.R3 = regs.R31;
		/* 821BE18Ch case   19:*/		return 0x821BE190;
		  /* 821BE190h */ case   20:  		/* bl -1768 */
		/* 821BE190h case   20:*/		regs.LR = 0x821BE194; return 0x821BDAA8;
		/* 821BE190h case   20:*/		return 0x821BE194;
		  /* 821BE194h */ case   21:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821BE194h case   21:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821BE194h case   21:*/		return 0x821BE198;
		  /* 821BE198h */ case   22:  		/* bc 4, CR0_EQ, -72 */
		/* 821BE198h case   22:*/		if ( !regs.CR[0].eq ) { return 0x821BE150;  }
		/* 821BE198h case   22:*/		return 0x821BE19C;
	}
	return 0x821BE19C;
} // Block from 821BE140h-821BE19Ch (23 instructions)

//////////////////////////////////////////////////////
// Block at 821BE19Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE19C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE19C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE19C);
		  /* 821BE19Ch */ case    0:  		/* lwz R11, <#[R29 + 48]> */
		/* 821BE19Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000030) );
		/* 821BE19Ch case    0:*/		return 0x821BE1A0;
		  /* 821BE1A0h */ case    1:  		/* cmplw CR6, R31, R11 */
		/* 821BE1A0h case    1:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R11);
		/* 821BE1A0h case    1:*/		return 0x821BE1A4;
		  /* 821BE1A4h */ case    2:  		/* bc 4, CR6_EQ, 20 */
		/* 821BE1A4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821BE1B8;  }
		/* 821BE1A4h case    2:*/		return 0x821BE1A8;
	}
	return 0x821BE1A8;
} // Block from 821BE19Ch-821BE1A8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BE1A8h
// Function '?HasSamplerOperand@Instruction@D3DXShader@@QAA_NXZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE1A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE1A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE1A8);
		  /* 821BE1A8h */ case    0:  		/* lwz R11, <#[R1 + 88]> */
		/* 821BE1A8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 821BE1A8h case    0:*/		return 0x821BE1AC;
		  /* 821BE1ACh */ case    1:  		/* li R3, 1 */
		/* 821BE1ACh case    1:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821BE1ACh case    1:*/		return 0x821BE1B0;
		  /* 821BE1B0h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 821BE1B0h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BE1B0h case    2:*/		return 0x821BE1B4;
		  /* 821BE1B4h */ case    3:  		/* bc 12, CR6_EQ, 8 */
		/* 821BE1B4h case    3:*/		if ( regs.CR[6].eq ) { return 0x821BE1BC;  }
		/* 821BE1B4h case    3:*/		return 0x821BE1B8;
	}
	return 0x821BE1B8;
} // Block from 821BE1A8h-821BE1B8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BE1B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE1B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE1B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE1B8);
		  /* 821BE1B8h */ case    0:  		/* li R3, 0 */
		/* 821BE1B8h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821BE1B8h case    0:*/		return 0x821BE1BC;
	}
	return 0x821BE1BC;
} // Block from 821BE1B8h-821BE1BCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BE1BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE1BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE1BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE1BC);
		  /* 821BE1BCh */ case    0:  		/* addi R1, R1, 128 */
		/* 821BE1BCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821BE1BCh case    0:*/		return 0x821BE1C0;
		  /* 821BE1C0h */ case    1:  		/* b -1232660 */
		/* 821BE1C0h case    1:*/		return 0x820912AC;
		/* 821BE1C0h case    1:*/		return 0x821BE1C4;
		  /* 821BE1C4h */ case    2:  		/* nop */
		/* 821BE1C4h case    2:*/		cpu::op::nop();
		/* 821BE1C4h case    2:*/		return 0x821BE1C8;
	}
	return 0x821BE1C8;
} // Block from 821BE1BCh-821BE1C8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BE1C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE1C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE1C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE1C8);
		  /* 821BE1C8h */ case    0:  		/* mfspr R12, LR */
		/* 821BE1C8h case    0:*/		regs.R12 = regs.LR;
		/* 821BE1C8h case    0:*/		return 0x821BE1CC;
		  /* 821BE1CCh */ case    1:  		/* bl -1232772 */
		/* 821BE1CCh case    1:*/		regs.LR = 0x821BE1D0; return 0x82091248;
		/* 821BE1CCh case    1:*/		return 0x821BE1D0;
		  /* 821BE1D0h */ case    2:  		/* stfd FR31, <#[R1 - 80]> */
		/* 821BE1D0h case    2:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R1 + 0xFFFFFFB0) );
		/* 821BE1D0h case    2:*/		return 0x821BE1D4;
		  /* 821BE1D4h */ case    3:  		/* stwu R1, <#[R1 - 160]> */
		/* 821BE1D4h case    3:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 821BE1D4h case    3:*/		return 0x821BE1D8;
		  /* 821BE1D8h */ case    4:  		/* lis R11, -32256 */
		/* 821BE1D8h case    4:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 821BE1D8h case    4:*/		return 0x821BE1DC;
		  /* 821BE1DCh */ case    5:  		/* lwz R28, <#[R1 + 244]> */
		/* 821BE1DCh case    5:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x000000F4) );
		/* 821BE1DCh case    5:*/		return 0x821BE1E0;
		  /* 821BE1E0h */ case    6:  		/* mr R27, R4 */
		/* 821BE1E0h case    6:*/		regs.R27 = regs.R4;
		/* 821BE1E0h case    6:*/		return 0x821BE1E4;
		  /* 821BE1E4h */ case    7:  		/* stw R7, <#[R1 + 212]> */
		/* 821BE1E4h case    7:*/		cpu::mem::store32( regs, regs.R7, (uint32)(regs.R1 + 0x000000D4) );
		/* 821BE1E4h case    7:*/		return 0x821BE1E8;
		  /* 821BE1E8h */ case    8:  		/* mr R25, R3 */
		/* 821BE1E8h case    8:*/		regs.R25 = regs.R3;
		/* 821BE1E8h case    8:*/		return 0x821BE1EC;
		  /* 821BE1ECh */ case    9:  		/* stw R8, <#[R1 + 220]> */
		/* 821BE1ECh case    9:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R1 + 0x000000DC) );
		/* 821BE1ECh case    9:*/		return 0x821BE1F0;
		  /* 821BE1F0h */ case   10:  		/* mr R26, R5 */
		/* 821BE1F0h case   10:*/		regs.R26 = regs.R5;
		/* 821BE1F0h case   10:*/		return 0x821BE1F4;
		  /* 821BE1F4h */ case   11:  		/* stw R9, <#[R1 + 228]> */
		/* 821BE1F4h case   11:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x000000E4) );
		/* 821BE1F4h case   11:*/		return 0x821BE1F8;
		  /* 821BE1F8h */ case   12:  		/* mr R24, R6 */
		/* 821BE1F8h case   12:*/		regs.R24 = regs.R6;
		/* 821BE1F8h case   12:*/		return 0x821BE1FC;
		  /* 821BE1FCh */ case   13:  		/* lfd FR31, <#[R11 + 1808]> */
		/* 821BE1FCh case   13:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R11 + 0x00000710) );
		/* 821BE1FCh case   13:*/		return 0x821BE200;
	}
	return 0x821BE200;
} // Block from 821BE1C8h-821BE200h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821BE200h
// Function '?GetUnresolvedUAsmOptions@Instruction@D3DXShader@@QAAPAUUnresolvedUAsmOptions@2@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE200( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE200) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE200);
		  /* 821BE200h */ case    0:  		/* mr R4, R8 */
		/* 821BE200h case    0:*/		regs.R4 = regs.R8;
		/* 821BE200h case    0:*/		return 0x821BE204;
		  /* 821BE204h */ case    1:  		/* mr R30, R10 */
		/* 821BE204h case    1:*/		regs.R30 = regs.R10;
		/* 821BE204h case    1:*/		return 0x821BE208;
		  /* 821BE208h */ case    2:  		/* mr R31, R6 */
		/* 821BE208h case    2:*/		regs.R31 = regs.R6;
		/* 821BE208h case    2:*/		return 0x821BE20C;
		  /* 821BE20Ch */ case    3:  		/* lwz R11, <#[R27 + 48]> */
		/* 821BE20Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000030) );
		/* 821BE20Ch case    3:*/		return 0x821BE210;
		  /* 821BE210h */ case    4:  		/* lwz R29, <#[R1 + 252]> */
		/* 821BE210h case    4:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x000000FC) );
		/* 821BE210h case    4:*/		return 0x821BE214;
		  /* 821BE214h */ case    5:  		/* cmplw CR6, R29, R11 */
		/* 821BE214h case    5:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 821BE214h case    5:*/		return 0x821BE218;
		  /* 821BE218h */ case    6:  		/* bc 12, CR6_EQ, 16 */
		/* 821BE218h case    6:*/		if ( regs.CR[6].eq ) { return 0x821BE228;  }
		/* 821BE218h case    6:*/		return 0x821BE21C;
		  /* 821BE21Ch */ case    7:  		/* lwz R11, <#[R27 + 52]> */
		/* 821BE21Ch case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000034) );
		/* 821BE21Ch case    7:*/		return 0x821BE220;
		  /* 821BE220h */ case    8:  		/* cmplw CR6, R29, R11 */
		/* 821BE220h case    8:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 821BE220h case    8:*/		return 0x821BE224;
		  /* 821BE224h */ case    9:  		/* bc 4, CR6_EQ, 128 */
		/* 821BE224h case    9:*/		if ( !regs.CR[6].eq ) { return 0x821BE2A4;  }
		/* 821BE224h case    9:*/		return 0x821BE228;
	}
	return 0x821BE228;
} // Block from 821BE200h-821BE228h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821BE228h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE228( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE228) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE228);
		  /* 821BE228h */ case    0:  		/* lwz R5, <#[R1 + 260]> */
		/* 821BE228h case    0:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000104) );
		/* 821BE228h case    0:*/		return 0x821BE22C;
		  /* 821BE22Ch */ case    1:  		/* mr R10, R7 */
		/* 821BE22Ch case    1:*/		regs.R10 = regs.R7;
		/* 821BE22Ch case    1:*/		return 0x821BE230;
		  /* 821BE230h */ case    2:  		/* mr R6, R9 */
		/* 821BE230h case    2:*/		regs.R6 = regs.R9;
		/* 821BE230h case    2:*/		return 0x821BE234;
		  /* 821BE234h */ case    3:  		/* lwz R9, <#[R1 + 268]> */
		/* 821BE234h case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x0000010C) );
		/* 821BE234h case    3:*/		return 0x821BE238;
		  /* 821BE238h */ case    4:  		/* mr R11, R31 */
		/* 821BE238h case    4:*/		regs.R11 = regs.R31;
		/* 821BE238h case    4:*/		return 0x821BE23C;
		  /* 821BE23Ch */ case    5:  		/* stw R29, <#[R1 + 212]> */
		/* 821BE23Ch case    5:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R1 + 0x000000D4) );
		/* 821BE23Ch case    5:*/		return 0x821BE240;
		  /* 821BE240h */ case    6:  		/* mr R7, R29 */
		/* 821BE240h case    6:*/		regs.R7 = regs.R29;
		/* 821BE240h case    6:*/		return 0x821BE244;
		  /* 821BE244h */ case    7:  		/* stw R6, <#[R1 + 268]> */
		/* 821BE244h case    7:*/		cpu::mem::store32( regs, regs.R6, (uint32)(regs.R1 + 0x0000010C) );
		/* 821BE244h case    7:*/		return 0x821BE248;
		  /* 821BE248h */ case    8:  		/* mr R31, R28 */
		/* 821BE248h case    8:*/		regs.R31 = regs.R28;
		/* 821BE248h case    8:*/		return 0x821BE24C;
		  /* 821BE24Ch */ case    9:  		/* stw R10, <#[R1 + 252]> */
		/* 821BE24Ch case    9:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R1 + 0x000000FC) );
		/* 821BE24Ch case    9:*/		return 0x821BE250;
		  /* 821BE250h */ case   10:  		/* mr R8, R4 */
		/* 821BE250h case   10:*/		regs.R8 = regs.R4;
		/* 821BE250h case   10:*/		return 0x821BE254;
		  /* 821BE254h */ case   11:  		/* stw R5, <#[R1 + 220]> */
		/* 821BE254h case   11:*/		cpu::mem::store32( regs, regs.R5, (uint32)(regs.R1 + 0x000000DC) );
		/* 821BE254h case   11:*/		return 0x821BE258;
		  /* 821BE258h */ case   12:  		/* mr R29, R10 */
		/* 821BE258h case   12:*/		regs.R29 = regs.R10;
		/* 821BE258h case   12:*/		return 0x821BE25C;
		  /* 821BE25Ch */ case   13:  		/* stw R4, <#[R1 + 260]> */
		/* 821BE25Ch case   13:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R1 + 0x00000104) );
		/* 821BE25Ch case   13:*/		return 0x821BE260;
		  /* 821BE260h */ case   14:  		/* mr R28, R11 */
		/* 821BE260h case   14:*/		regs.R28 = regs.R11;
		/* 821BE260h case   14:*/		return 0x821BE264;
		  /* 821BE264h */ case   15:  		/* stw R9, <#[R1 + 228]> */
		/* 821BE264h case   15:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x000000E4) );
		/* 821BE264h case   15:*/		return 0x821BE268;
		  /* 821BE268h */ case   16:  		/* cmpwi CR6, R30, 15 */
		/* 821BE268h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x0000000F);
		/* 821BE268h case   16:*/		return 0x821BE26C;
		  /* 821BE26Ch */ case   17:  		/* bc 12, CR6_EQ, 52 */
		/* 821BE26Ch case   17:*/		if ( regs.CR[6].eq ) { return 0x821BE2A0;  }
		/* 821BE26Ch case   17:*/		return 0x821BE270;
		  /* 821BE270h */ case   18:  		/* cmpwi CR6, R30, 16 */
		/* 821BE270h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000010);
		/* 821BE270h case   18:*/		return 0x821BE274;
		  /* 821BE274h */ case   19:  		/* bc 12, CR6_EQ, 36 */
		/* 821BE274h case   19:*/		if ( regs.CR[6].eq ) { return 0x821BE298;  }
		/* 821BE274h case   19:*/		return 0x821BE278;
		  /* 821BE278h */ case   20:  		/* cmpwi CR6, R30, 17 */
		/* 821BE278h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000011);
		/* 821BE278h case   20:*/		return 0x821BE27C;
		  /* 821BE27Ch */ case   21:  		/* bc 12, CR6_EQ, 20 */
		/* 821BE27Ch case   21:*/		if ( regs.CR[6].eq ) { return 0x821BE290;  }
		/* 821BE27Ch case   21:*/		return 0x821BE280;
		  /* 821BE280h */ case   22:  		/* cmpwi CR6, R30, 18 */
		/* 821BE280h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000012);
		/* 821BE280h case   22:*/		return 0x821BE284;
		  /* 821BE284h */ case   23:  		/* bc 4, CR6_EQ, 32 */
		/* 821BE284h case   23:*/		if ( !regs.CR[6].eq ) { return 0x821BE2A4;  }
		/* 821BE284h case   23:*/		return 0x821BE288;
	}
	return 0x821BE288;
} // Block from 821BE228h-821BE288h (24 instructions)

//////////////////////////////////////////////////////
// Block at 821BE288h
// Function '?GetIntegerMathInfo@Instruction@D3DXShader@@QAAPAUInstruction_INTEGER_MATH@2@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE288( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE288) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE288);
		  /* 821BE288h */ case    0:  		/* li R30, 17 */
		/* 821BE288h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x11);
		/* 821BE288h case    0:*/		return 0x821BE28C;
		  /* 821BE28Ch */ case    1:  		/* b 24 */
		/* 821BE28Ch case    1:*/		return 0x821BE2A4;
		/* 821BE28Ch case    1:*/		return 0x821BE290;
	}
	return 0x821BE290;
} // Block from 821BE288h-821BE290h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BE290h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE290( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE290) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE290);
		  /* 821BE290h */ case    0:  		/* li R30, 18 */
		/* 821BE290h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x12);
		/* 821BE290h case    0:*/		return 0x821BE294;
		  /* 821BE294h */ case    1:  		/* b 16 */
		/* 821BE294h case    1:*/		return 0x821BE2A4;
		/* 821BE294h case    1:*/		return 0x821BE298;
	}
	return 0x821BE298;
} // Block from 821BE290h-821BE298h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BE298h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE298( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE298) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE298);
		  /* 821BE298h */ case    0:  		/* li R30, 15 */
		/* 821BE298h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0xF);
		/* 821BE298h case    0:*/		return 0x821BE29C;
		  /* 821BE29Ch */ case    1:  		/* b 8 */
		/* 821BE29Ch case    1:*/		return 0x821BE2A4;
		/* 821BE29Ch case    1:*/		return 0x821BE2A0;
	}
	return 0x821BE2A0;
} // Block from 821BE298h-821BE2A0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BE2A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE2A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE2A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE2A0);
		  /* 821BE2A0h */ case    0:  		/* li R30, 16 */
		/* 821BE2A0h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x10);
		/* 821BE2A0h case    0:*/		return 0x821BE2A4;
	}
	return 0x821BE2A4;
} // Block from 821BE2A0h-821BE2A4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BE2A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE2A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE2A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE2A4);
		  /* 821BE2A4h */ case    0:  		/* lwz R11, <#[R29 + 8]> */
		/* 821BE2A4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 821BE2A4h case    0:*/		return 0x821BE2A8;
		  /* 821BE2A8h */ case    1:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821BE2A8h case    1:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821BE2A8h case    1:*/		return 0x821BE2AC;
		  /* 821BE2ACh */ case    2:  		/* cmplwi CR6, R11, 16000 */
		/* 821BE2ACh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E80);
		/* 821BE2ACh case    2:*/		return 0x821BE2B0;
		  /* 821BE2B0h */ case    3:  		/* bc 4, CR6_EQ, 316 */
		/* 821BE2B0h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821BE3EC;  }
		/* 821BE2B0h case    3:*/		return 0x821BE2B4;
		  /* 821BE2B4h */ case    4:  		/* mr R3, R29 */
		/* 821BE2B4h case    4:*/		regs.R3 = regs.R29;
		/* 821BE2B4h case    4:*/		return 0x821BE2B8;
		  /* 821BE2B8h */ case    5:  		/* lwz R5, <#[R1 + 268]> */
		/* 821BE2B8h case    5:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x0000010C) );
		/* 821BE2B8h case    5:*/		return 0x821BE2BC;
		  /* 821BE2BCh */ case    6:  		/* lwz R4, <#[R1 + 260]> */
		/* 821BE2BCh case    6:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000104) );
		/* 821BE2BCh case    6:*/		return 0x821BE2C0;
		  /* 821BE2C0h */ case    7:  		/* bl 406496 */
		/* 821BE2C0h case    7:*/		regs.LR = 0x821BE2C4; return 0x822216A0;
		/* 821BE2C0h case    7:*/		return 0x821BE2C4;
		  /* 821BE2C4h */ case    8:  		/* lwz R9, <#[R1 + 228]> */
		/* 821BE2C4h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x000000E4) );
		/* 821BE2C4h case    8:*/		return 0x821BE2C8;
		  /* 821BE2C8h */ case    9:  		/* lwz R7, <#[R1 + 212]> */
		/* 821BE2C8h case    9:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x000000D4) );
		/* 821BE2C8h case    9:*/		return 0x821BE2CC;
		  /* 821BE2CCh */ case   10:  		/* fcmpu CR6, FR1, FR31 */
		/* 821BE2CCh case   10:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR31);
		/* 821BE2CCh case   10:*/		return 0x821BE2D0;
	}
	return 0x821BE2D0;
} // Block from 821BE2A4h-821BE2D0h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821BE2D0h
// Function '?GetIntegerOp@Instruction@D3DXShader@@QAA?AW4IntegerMathOp@2@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE2D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE2D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE2D0);
		  /* 821BE2D0h */ case    0:  		/* bc 4, CR6_EQ, 280 */
		/* 821BE2D0h case    0:*/		if ( !regs.CR[6].eq ) { return 0x821BE3E8;  }
		/* 821BE2D0h case    0:*/		return 0x821BE2D4;
		  /* 821BE2D4h */ case    1:  		/* cmplwi CR6, R9, 4 */
		/* 821BE2D4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000004);
		/* 821BE2D4h case    1:*/		return 0x821BE2D8;
		  /* 821BE2D8h */ case    2:  		/* bc 4, CR6_EQ, 16 */
		/* 821BE2D8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821BE2E8;  }
		/* 821BE2D8h case    2:*/		return 0x821BE2DC;
		  /* 821BE2DCh */ case    3:  		/* lwz R29, <#[R1 + 252]> */
		/* 821BE2DCh case    3:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x000000FC) );
		/* 821BE2DCh case    3:*/		return 0x821BE2E0;
		  /* 821BE2E0h */ case    4:  		/* li R9, 0 */
		/* 821BE2E0h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821BE2E0h case    4:*/		return 0x821BE2E4;
		  /* 821BE2E4h */ case    5:  		/* b -128 */
		/* 821BE2E4h case    5:*/		return 0x821BE264;
		/* 821BE2E4h case    5:*/		return 0x821BE2E8;
	}
	return 0x821BE2E8;
} // Block from 821BE2D0h-821BE2E8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BE2E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE2E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE2E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE2E8);
		  /* 821BE2E8h */ case    0:  		/* lwz R4, <#[R1 + 220]> */
		/* 821BE2E8h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x000000DC) );
		/* 821BE2E8h case    0:*/		return 0x821BE2EC;
		  /* 821BE2ECh */ case    1:  		/* cmplwi CR6, R9, 2 */
		/* 821BE2ECh case    1:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000002);
		/* 821BE2ECh case    1:*/		return 0x821BE2F0;
		  /* 821BE2F0h */ case    2:  		/* bc 4, CR6_EQ, 36 */
		/* 821BE2F0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821BE314;  }
		/* 821BE2F0h case    2:*/		return 0x821BE2F4;
		  /* 821BE2F4h */ case    3:  		/* lhz R11, <#[R7 + 14]> */
		/* 821BE2F4h case    3:*/		cpu::mem::load16z( regs, &regs.R11, (uint32)(regs.R7 + 0x0000000E) );
		/* 821BE2F4h case    3:*/		return 0x821BE2F8;
		  /* 821BE2F8h */ case    4:  		/* rlwinm R10, R4, 2, 16, 29 */
		/* 821BE2F8h case    4:*/		cpu::op::rlwinm<0,2,16,29>(regs,&regs.R10,regs.R4);
		/* 821BE2F8h case    4:*/		return 0x821BE2FC;
		  /* 821BE2FCh */ case    5:  		/* srw R11, R11, R10 */
		/* 821BE2FCh case    5:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821BE2FCh case    5:*/		return 0x821BE300;
		  /* 821BE300h */ case    6:  		/* rlwinm R11, R11, 31, 17, 31 */
		/* 821BE300h case    6:*/		cpu::op::rlwinm<0,31,17,31>(regs,&regs.R11,regs.R11);
		/* 821BE300h case    6:*/		return 0x821BE304;
		  /* 821BE304h */ case    7:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821BE304h case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821BE304h case    7:*/		return 0x821BE308;
		  /* 821BE308h */ case    8:  		/* bc 12, CR0_EQ, 224 */
		/* 821BE308h case    8:*/		if ( regs.CR[0].eq ) { return 0x821BE3E8;  }
		/* 821BE308h case    8:*/		return 0x821BE30C;
		  /* 821BE30Ch */ case    9:  		/* li R9, 0 */
		/* 821BE30Ch case    9:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821BE30Ch case    9:*/		return 0x821BE310;
		  /* 821BE310h */ case   10:  		/* stw R9, <#[R1 + 228]> */
		/* 821BE310h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x000000E4) );
		/* 821BE310h case   10:*/		return 0x821BE314;
	}
	return 0x821BE314;
} // Block from 821BE2E8h-821BE314h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821BE314h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE314( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE314) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE314);
		  /* 821BE314h */ case    0:  		/* cmplwi CR6, R9, 0 */
		/* 821BE314h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 821BE314h case    0:*/		return 0x821BE318;
	}
	return 0x821BE318;
} // Block from 821BE314h-821BE318h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BE318h
// Function '?IsIntegerCast@Instruction@D3DXShader@@QAA_NPAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE318( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE318) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE318);
		  /* 821BE318h */ case    0:  		/* bc 4, CR6_EQ, 208 */
		/* 821BE318h case    0:*/		if ( !regs.CR[6].eq ) { return 0x821BE3E8;  }
		/* 821BE318h case    0:*/		return 0x821BE31C;
		  /* 821BE31Ch */ case    1:  		/* cmpwi CR6, R30, 16 */
		/* 821BE31Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000010);
		/* 821BE31Ch case    1:*/		return 0x821BE320;
		  /* 821BE320h */ case    2:  		/* bc 12, CR6_EQ, 20 */
		/* 821BE320h case    2:*/		if ( regs.CR[6].eq ) { return 0x821BE334;  }
		/* 821BE320h case    2:*/		return 0x821BE324;
		  /* 821BE324h */ case    3:  		/* cmpwi CR6, R30, 19 */
		/* 821BE324h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000013);
		/* 821BE324h case    3:*/		return 0x821BE328;
		  /* 821BE328h */ case    4:  		/* bc 12, CR6_EQ, 60 */
		/* 821BE328h case    4:*/		if ( regs.CR[6].eq ) { return 0x821BE364;  }
		/* 821BE328h case    4:*/		return 0x821BE32C;
		  /* 821BE32Ch */ case    5:  		/* cmpwi CR6, R30, 20 */
		/* 821BE32Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000014);
		/* 821BE32Ch case    5:*/		return 0x821BE330;
		  /* 821BE330h */ case    6:  		/* bc 4, CR6_EQ, 184 */
		/* 821BE330h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821BE3E8;  }
		/* 821BE330h case    6:*/		return 0x821BE334;
	}
	return 0x821BE334;
} // Block from 821BE318h-821BE334h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BE334h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE334( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE334) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE334);
		  /* 821BE334h */ case    0:  		/* lwz R11, <#[R7 + 8]> */
		/* 821BE334h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000008) );
		/* 821BE334h case    0:*/		return 0x821BE338;
		  /* 821BE338h */ case    1:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821BE338h case    1:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821BE338h case    1:*/		return 0x821BE33C;
		  /* 821BE33Ch */ case    2:  		/* cmpwi CR6, R11, 5 */
		/* 821BE33Ch case    2:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000005);
		/* 821BE33Ch case    2:*/		return 0x821BE340;
		  /* 821BE340h */ case    3:  		/* bc 12, CR6_EQ, 72 */
		/* 821BE340h case    3:*/		if ( regs.CR[6].eq ) { return 0x821BE388;  }
		/* 821BE340h case    3:*/		return 0x821BE344;
		  /* 821BE344h */ case    4:  		/* cmpwi CR6, R11, 6 */
		/* 821BE344h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000006);
		/* 821BE344h case    4:*/		return 0x821BE348;
		  /* 821BE348h */ case    5:  		/* bc 12, CR6_EQ, 56 */
		/* 821BE348h case    5:*/		if ( regs.CR[6].eq ) { return 0x821BE380;  }
		/* 821BE348h case    5:*/		return 0x821BE34C;
		  /* 821BE34Ch */ case    6:  		/* cmpwi CR6, R11, 7 */
		/* 821BE34Ch case    6:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000007);
		/* 821BE34Ch case    6:*/		return 0x821BE350;
		  /* 821BE350h */ case    7:  		/* bc 12, CR6_EQ, 40 */
		/* 821BE350h case    7:*/		if ( regs.CR[6].eq ) { return 0x821BE378;  }
		/* 821BE350h case    7:*/		return 0x821BE354;
		  /* 821BE354h */ case    8:  		/* cmpwi CR6, R11, 8 */
		/* 821BE354h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000008);
		/* 821BE354h case    8:*/		return 0x821BE358;
		  /* 821BE358h */ case    9:  		/* bc 4, CR6_EQ, 144 */
		/* 821BE358h case    9:*/		if ( !regs.CR[6].eq ) { return 0x821BE3E8;  }
		/* 821BE358h case    9:*/		return 0x821BE35C;
		  /* 821BE35Ch */ case   10:  		/* li R30, 20 */
		/* 821BE35Ch case   10:*/		cpu::op::li<0>(regs,&regs.R30,0x14);
		/* 821BE35Ch case   10:*/		return 0x821BE360;
		  /* 821BE360h */ case   11:  		/* b 44 */
		/* 821BE360h case   11:*/		return 0x821BE38C;
		/* 821BE360h case   11:*/		return 0x821BE364;
	}
	return 0x821BE364;
} // Block from 821BE334h-821BE364h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821BE364h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE364( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE364) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE364);
		  /* 821BE364h */ case    0:  		/* rlwinm R11, R26, 0, 24, 31 */
		/* 821BE364h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R26);
		/* 821BE364h case    0:*/		return 0x821BE368;
		  /* 821BE368h */ case    1:  		/* li R30, 20 */
		/* 821BE368h case    1:*/		cpu::op::li<0>(regs,&regs.R30,0x14);
		/* 821BE368h case    1:*/		return 0x821BE36C;
		  /* 821BE36Ch */ case    2:  		/* cntlzw R11, R11 */
		/* 821BE36Ch case    2:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R11);
		/* 821BE36Ch case    2:*/		return 0x821BE370;
		  /* 821BE370h */ case    3:  		/* rlwinm R26, R11, 27, 31, 31 */
		/* 821BE370h case    3:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R26,regs.R11);
		/* 821BE370h case    3:*/		return 0x821BE374;
		  /* 821BE374h */ case    4:  		/* b -360 */
		/* 821BE374h case    4:*/		return 0x821BE20C;
		/* 821BE374h case    4:*/		return 0x821BE378;
	}
	return 0x821BE378;
} // Block from 821BE364h-821BE378h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BE378h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE378( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE378) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE378);
		  /* 821BE378h */ case    0:  		/* li R30, 18 */
		/* 821BE378h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x12);
		/* 821BE378h case    0:*/		return 0x821BE37C;
		  /* 821BE37Ch */ case    1:  		/* b 16 */
		/* 821BE37Ch case    1:*/		return 0x821BE38C;
		/* 821BE37Ch case    1:*/		return 0x821BE380;
	}
	return 0x821BE380;
} // Block from 821BE378h-821BE380h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BE380h
// Function '?FindNextBlock@DomGraphBreadthFirstEnumerator@D3DXShader@@AAAPAVBlock@2@PAV32@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE380( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE380) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE380);
		  /* 821BE380h */ case    0:  		/* li R30, 16 */
		/* 821BE380h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x10);
		/* 821BE380h case    0:*/		return 0x821BE384;
		  /* 821BE384h */ case    1:  		/* b 8 */
		/* 821BE384h case    1:*/		return 0x821BE38C;
		/* 821BE384h case    1:*/		return 0x821BE388;
	}
	return 0x821BE388;
} // Block from 821BE380h-821BE388h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BE388h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE388( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE388) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE388);
		  /* 821BE388h */ case    0:  		/* li R30, 19 */
		/* 821BE388h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x13);
		/* 821BE388h case    0:*/		return 0x821BE38C;
	}
	return 0x821BE38C;
} // Block from 821BE388h-821BE38Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BE38Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE38C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE38C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE38C);
		  /* 821BE38Ch */ case    0:  		/* lwz R28, <#[R7 + 48]> */
		/* 821BE38Ch case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R7 + 0x00000030) );
		/* 821BE38Ch case    0:*/		return 0x821BE390;
		  /* 821BE390h */ case    1:  		/* li R10, 0 */
		/* 821BE390h case    1:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821BE390h case    1:*/		return 0x821BE394;
		  /* 821BE394h */ case    2:  		/* lwz R31, <#[R7 + 44]> */
		/* 821BE394h case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R7 + 0x0000002C) );
		/* 821BE394h case    2:*/		return 0x821BE398;
		  /* 821BE398h */ case    3:  		/* li R9, 0 */
		/* 821BE398h case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821BE398h case    3:*/		return 0x821BE39C;
		  /* 821BE39Ch */ case    4:  		/* li R8, 0 */
		/* 821BE39Ch case    4:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821BE39Ch case    4:*/		return 0x821BE3A0;
		  /* 821BE3A0h */ case    5:  		/* addi R7, R1, 268 */
		/* 821BE3A0h case    5:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x10C);
		/* 821BE3A0h case    5:*/		return 0x821BE3A4;
		  /* 821BE3A4h */ case    6:  		/* addi R6, R1, 260 */
		/* 821BE3A4h case    6:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x104);
		/* 821BE3A4h case    6:*/		return 0x821BE3A8;
		  /* 821BE3A8h */ case    7:  		/* addi R5, R1, 252 */
		/* 821BE3A8h case    7:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0xFC);
		/* 821BE3A8h case    7:*/		return 0x821BE3AC;
		  /* 821BE3ACh */ case    8:  		/* mr R3, R28 */
		/* 821BE3ACh case    8:*/		regs.R3 = regs.R28;
		/* 821BE3ACh case    8:*/		return 0x821BE3B0;
		  /* 821BE3B0h */ case    9:  		/* bl 413984 */
		/* 821BE3B0h case    9:*/		regs.LR = 0x821BE3B4; return 0x822234D0;
		/* 821BE3B0h case    9:*/		return 0x821BE3B4;
		  /* 821BE3B4h */ case   10:  		/* li R10, 0 */
		/* 821BE3B4h case   10:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821BE3B4h case   10:*/		return 0x821BE3B8;
		  /* 821BE3B8h */ case   11:  		/* li R9, 0 */
		/* 821BE3B8h case   11:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821BE3B8h case   11:*/		return 0x821BE3BC;
		  /* 821BE3BCh */ case   12:  		/* lwz R4, <#[R1 + 220]> */
		/* 821BE3BCh case   12:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x000000DC) );
		/* 821BE3BCh case   12:*/		return 0x821BE3C0;
		  /* 821BE3C0h */ case   13:  		/* li R8, 0 */
		/* 821BE3C0h case   13:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821BE3C0h case   13:*/		return 0x821BE3C4;
		  /* 821BE3C4h */ case   14:  		/* addi R7, R1, 228 */
		/* 821BE3C4h case   14:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0xE4);
		/* 821BE3C4h case   14:*/		return 0x821BE3C8;
		  /* 821BE3C8h */ case   15:  		/* addi R6, R1, 220 */
		/* 821BE3C8h case   15:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0xDC);
		/* 821BE3C8h case   15:*/		return 0x821BE3CC;
		  /* 821BE3CCh */ case   16:  		/* addi R5, R1, 212 */
		/* 821BE3CCh case   16:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0xD4);
		/* 821BE3CCh case   16:*/		return 0x821BE3D0;
		  /* 821BE3D0h */ case   17:  		/* mr R3, R31 */
		/* 821BE3D0h case   17:*/		regs.R3 = regs.R31;
		/* 821BE3D0h case   17:*/		return 0x821BE3D4;
		  /* 821BE3D4h */ case   18:  		/* bl 413948 */
		/* 821BE3D4h case   18:*/		regs.LR = 0x821BE3D8; return 0x822234D0;
		/* 821BE3D4h case   18:*/		return 0x821BE3D8;
		  /* 821BE3D8h */ case   19:  		/* lwz R9, <#[R1 + 228]> */
		/* 821BE3D8h case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x000000E4) );
		/* 821BE3D8h case   19:*/		return 0x821BE3DC;
		  /* 821BE3DCh */ case   20:  		/* lwz R4, <#[R1 + 220]> */
		/* 821BE3DCh case   20:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x000000DC) );
		/* 821BE3DCh case   20:*/		return 0x821BE3E0;
		  /* 821BE3E0h */ case   21:  		/* lwz R7, <#[R1 + 212]> */
		/* 821BE3E0h case   21:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x000000D4) );
		/* 821BE3E0h case   21:*/		return 0x821BE3E4;
		  /* 821BE3E4h */ case   22:  		/* b -472 */
		/* 821BE3E4h case   22:*/		return 0x821BE20C;
		/* 821BE3E4h case   22:*/		return 0x821BE3E8;
	}
	return 0x821BE3E8;
} // Block from 821BE38Ch-821BE3E8h (23 instructions)

//////////////////////////////////////////////////////
// Block at 821BE3E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE3E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE3E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE3E8);
		  /* 821BE3E8h */ case    0:  		/* lwz R29, <#[R1 + 252]> */
		/* 821BE3E8h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R1 + 0x000000FC) );
		/* 821BE3E8h case    0:*/		return 0x821BE3EC;
	}
	return 0x821BE3EC;
} // Block from 821BE3E8h-821BE3ECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BE3ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE3EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE3EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE3EC);
		  /* 821BE3ECh */ case    0:  		/* lwz R11, <#[R27 + 48]> */
		/* 821BE3ECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000030) );
		/* 821BE3ECh case    0:*/		return 0x821BE3F0;
		  /* 821BE3F0h */ case    1:  		/* cmplw CR6, R7, R11 */
		/* 821BE3F0h case    1:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 821BE3F0h case    1:*/		return 0x821BE3F4;
		  /* 821BE3F4h */ case    2:  		/* bc 12, CR6_EQ, 24 */
		/* 821BE3F4h case    2:*/		if ( regs.CR[6].eq ) { return 0x821BE40C;  }
		/* 821BE3F4h case    2:*/		return 0x821BE3F8;
		  /* 821BE3F8h */ case    3:  		/* lwz R11, <#[R27 + 52]> */
		/* 821BE3F8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000034) );
		/* 821BE3F8h case    3:*/		return 0x821BE3FC;
		  /* 821BE3FCh */ case    4:  		/* cmplw CR6, R7, R11 */
		/* 821BE3FCh case    4:*/		cpu::op::cmplw<6>(regs,regs.R7,regs.R11);
		/* 821BE3FCh case    4:*/		return 0x821BE400;
		  /* 821BE400h */ case    5:  		/* bc 12, CR6_EQ, 12 */
		/* 821BE400h case    5:*/		if ( regs.CR[6].eq ) { return 0x821BE40C;  }
		/* 821BE400h case    5:*/		return 0x821BE404;
		  /* 821BE404h */ case    6:  		/* li R3, 1 */
		/* 821BE404h case    6:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821BE404h case    6:*/		return 0x821BE408;
		  /* 821BE408h */ case    7:  		/* b 696 */
		/* 821BE408h case    7:*/		return 0x821BE6C0;
		/* 821BE408h case    7:*/		return 0x821BE40C;
	}
	return 0x821BE40C;
} // Block from 821BE3ECh-821BE40Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 821BE40Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE40C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE40C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE40C);
		  /* 821BE40Ch */ case    0:  		/* cmplwi CR6, R9, 0 */
		/* 821BE40Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 821BE40Ch case    0:*/		return 0x821BE410;
	}
	return 0x821BE410;
} // Block from 821BE40Ch-821BE410h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BE410h
// Function '?GetNext@DomGraphBreadthFirstEnumerator@D3DXShader@@QAAPAVBlock@2@XZ'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE410( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE410) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE410);
		  /* 821BE410h */ case    0:  		/* bc 4, CR6_EQ, 684 */
		/* 821BE410h case    0:*/		if ( !regs.CR[6].eq ) { return 0x821BE6BC;  }
		/* 821BE410h case    0:*/		return 0x821BE414;
		  /* 821BE414h */ case    1:  		/* rlwinm. R10, R26, 0, 24, 31 */
		/* 821BE414h case    1:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R26);
		/* 821BE414h case    1:*/		return 0x821BE418;
		  /* 821BE418h */ case    2:  		/* bc 4, CR0_EQ, 96 */
		/* 821BE418h case    2:*/		if ( !regs.CR[0].eq ) { return 0x821BE478;  }
		/* 821BE418h case    2:*/		return 0x821BE41C;
		  /* 821BE41Ch */ case    3:  		/* cmpwi CR6, R30, 15 */
		/* 821BE41Ch case    3:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x0000000F);
		/* 821BE41Ch case    3:*/		return 0x821BE420;
		  /* 821BE420h */ case    4:  		/* bc 12, CR6_EQ, 84 */
		/* 821BE420h case    4:*/		if ( regs.CR[6].eq ) { return 0x821BE474;  }
		/* 821BE420h case    4:*/		return 0x821BE424;
		  /* 821BE424h */ case    5:  		/* cmpwi CR6, R30, 16 */
		/* 821BE424h case    5:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000010);
		/* 821BE424h case    5:*/		return 0x821BE428;
		  /* 821BE428h */ case    6:  		/* bc 12, CR6_EQ, 68 */
		/* 821BE428h case    6:*/		if ( regs.CR[6].eq ) { return 0x821BE46C;  }
		/* 821BE428h case    6:*/		return 0x821BE42C;
		  /* 821BE42Ch */ case    7:  		/* cmpwi CR6, R30, 17 */
		/* 821BE42Ch case    7:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000011);
		/* 821BE42Ch case    7:*/		return 0x821BE430;
		  /* 821BE430h */ case    8:  		/* bc 12, CR6_EQ, 52 */
		/* 821BE430h case    8:*/		if ( regs.CR[6].eq ) { return 0x821BE464;  }
		/* 821BE430h case    8:*/		return 0x821BE434;
		  /* 821BE434h */ case    9:  		/* cmpwi CR6, R30, 18 */
		/* 821BE434h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000012);
		/* 821BE434h case    9:*/		return 0x821BE438;
		  /* 821BE438h */ case   10:  		/* bc 12, CR6_EQ, 36 */
		/* 821BE438h case   10:*/		if ( regs.CR[6].eq ) { return 0x821BE45C;  }
		/* 821BE438h case   10:*/		return 0x821BE43C;
		  /* 821BE43Ch */ case   11:  		/* cmpwi CR6, R30, 19 */
		/* 821BE43Ch case   11:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000013);
		/* 821BE43Ch case   11:*/		return 0x821BE440;
		  /* 821BE440h */ case   12:  		/* bc 12, CR6_EQ, 20 */
		/* 821BE440h case   12:*/		if ( regs.CR[6].eq ) { return 0x821BE454;  }
		/* 821BE440h case   12:*/		return 0x821BE444;
		  /* 821BE444h */ case   13:  		/* cmpwi CR6, R30, 20 */
		/* 821BE444h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000014);
		/* 821BE444h case   13:*/		return 0x821BE448;
		  /* 821BE448h */ case   14:  		/* bc 4, CR6_EQ, 48 */
		/* 821BE448h case   14:*/		if ( !regs.CR[6].eq ) { return 0x821BE478;  }
		/* 821BE448h case   14:*/		return 0x821BE44C;
		  /* 821BE44Ch */ case   15:  		/* li R30, 19 */
		/* 821BE44Ch case   15:*/		cpu::op::li<0>(regs,&regs.R30,0x13);
		/* 821BE44Ch case   15:*/		return 0x821BE450;
		  /* 821BE450h */ case   16:  		/* b 40 */
		/* 821BE450h case   16:*/		return 0x821BE478;
		/* 821BE450h case   16:*/		return 0x821BE454;
	}
	return 0x821BE454;
} // Block from 821BE410h-821BE454h (17 instructions)

//////////////////////////////////////////////////////
// Block at 821BE454h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE454( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE454) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE454);
		  /* 821BE454h */ case    0:  		/* li R30, 20 */
		/* 821BE454h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x14);
		/* 821BE454h case    0:*/		return 0x821BE458;
		  /* 821BE458h */ case    1:  		/* b 32 */
		/* 821BE458h case    1:*/		return 0x821BE478;
		/* 821BE458h case    1:*/		return 0x821BE45C;
	}
	return 0x821BE45C;
} // Block from 821BE454h-821BE45Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BE45Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE45C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE45C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE45C);
		  /* 821BE45Ch */ case    0:  		/* li R30, 15 */
		/* 821BE45Ch case    0:*/		cpu::op::li<0>(regs,&regs.R30,0xF);
		/* 821BE45Ch case    0:*/		return 0x821BE460;
	}
	return 0x821BE460;
} // Block from 821BE45Ch-821BE460h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BE460h
// Function '?FindNextSideEffectDependent@Instruction@D3DXShader@@QAAPAVDependency@2@W4SideEffect@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE460( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE460) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE460);
		  /* 821BE460h */ case    0:  		/* b 24 */
		/* 821BE460h case    0:*/		return 0x821BE478;
		/* 821BE460h case    0:*/		return 0x821BE464;
	}
	return 0x821BE464;
} // Block from 821BE460h-821BE464h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BE464h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE464( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE464) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE464);
		  /* 821BE464h */ case    0:  		/* li R30, 16 */
		/* 821BE464h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x10);
		/* 821BE464h case    0:*/		return 0x821BE468;
		  /* 821BE468h */ case    1:  		/* b 16 */
		/* 821BE468h case    1:*/		return 0x821BE478;
		/* 821BE468h case    1:*/		return 0x821BE46C;
	}
	return 0x821BE46C;
} // Block from 821BE464h-821BE46Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BE46Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE46C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE46C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE46C);
		  /* 821BE46Ch */ case    0:  		/* li R30, 17 */
		/* 821BE46Ch case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x11);
		/* 821BE46Ch case    0:*/		return 0x821BE470;
		  /* 821BE470h */ case    1:  		/* b 8 */
		/* 821BE470h case    1:*/		return 0x821BE478;
		/* 821BE470h case    1:*/		return 0x821BE474;
	}
	return 0x821BE474;
} // Block from 821BE46Ch-821BE474h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BE474h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE474( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE474) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE474);
		  /* 821BE474h */ case    0:  		/* li R30, 18 */
		/* 821BE474h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x12);
		/* 821BE474h case    0:*/		return 0x821BE478;
	}
	return 0x821BE478;
} // Block from 821BE474h-821BE478h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BE478h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE478( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE478) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE478);
		  /* 821BE478h */ case    0:  		/* li R11, 1 */
		/* 821BE478h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821BE478h case    0:*/		return 0x821BE47C;
		  /* 821BE47Ch */ case    1:  		/* cmpwi CR6, R30, 15 */
		/* 821BE47Ch case    1:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x0000000F);
		/* 821BE47Ch case    1:*/		return 0x821BE480;
		  /* 821BE480h */ case    2:  		/* bc 12, CR6_EQ, 84 */
		/* 821BE480h case    2:*/		if ( regs.CR[6].eq ) { return 0x821BE4D4;  }
		/* 821BE480h case    2:*/		return 0x821BE484;
		  /* 821BE484h */ case    3:  		/* cmpwi CR6, R30, 16 */
		/* 821BE484h case    3:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000010);
		/* 821BE484h case    3:*/		return 0x821BE488;
		  /* 821BE488h */ case    4:  		/* bc 12, CR6_EQ, 56 */
		/* 821BE488h case    4:*/		if ( regs.CR[6].eq ) { return 0x821BE4C0;  }
		/* 821BE488h case    4:*/		return 0x821BE48C;
		  /* 821BE48Ch */ case    5:  		/* cmpwi CR6, R30, 17 */
		/* 821BE48Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000011);
		/* 821BE48Ch case    5:*/		return 0x821BE490;
		  /* 821BE490h */ case    6:  		/* bc 12, CR6_EQ, 68 */
		/* 821BE490h case    6:*/		if ( regs.CR[6].eq ) { return 0x821BE4D4;  }
		/* 821BE490h case    6:*/		return 0x821BE494;
		  /* 821BE494h */ case    7:  		/* cmpwi CR6, R30, 18 */
		/* 821BE494h case    7:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000012);
		/* 821BE494h case    7:*/		return 0x821BE498;
		  /* 821BE498h */ case    8:  		/* bc 12, CR6_EQ, 40 */
		/* 821BE498h case    8:*/		if ( regs.CR[6].eq ) { return 0x821BE4C0;  }
		/* 821BE498h case    8:*/		return 0x821BE49C;
		  /* 821BE49Ch */ case    9:  		/* cmpwi CR6, R30, 19 */
		/* 821BE49Ch case    9:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000013);
		/* 821BE49Ch case    9:*/		return 0x821BE4A0;
		  /* 821BE4A0h */ case   10:  		/* bc 12, CR6_EQ, 20 */
		/* 821BE4A0h case   10:*/		if ( regs.CR[6].eq ) { return 0x821BE4B4;  }
		/* 821BE4A0h case   10:*/		return 0x821BE4A4;
		  /* 821BE4A4h */ case   11:  		/* cmpwi CR6, R30, 20 */
		/* 821BE4A4h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000014);
		/* 821BE4A4h case   11:*/		return 0x821BE4A8;
		  /* 821BE4A8h */ case   12:  		/* bc 4, CR6_EQ, 68 */
		/* 821BE4A8h case   12:*/		if ( !regs.CR[6].eq ) { return 0x821BE4EC;  }
		/* 821BE4A8h case   12:*/		return 0x821BE4AC;
		  /* 821BE4ACh */ case   13:  		/* mr R11, R26 */
		/* 821BE4ACh case   13:*/		regs.R11 = regs.R26;
		/* 821BE4ACh case   13:*/		return 0x821BE4B0;
		  /* 821BE4B0h */ case   14:  		/* b 60 */
		/* 821BE4B0h case   14:*/		return 0x821BE4EC;
		/* 821BE4B0h case   14:*/		return 0x821BE4B4;
	}
	return 0x821BE4B4;
} // Block from 821BE478h-821BE4B4h (15 instructions)

//////////////////////////////////////////////////////
// Block at 821BE4B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE4B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE4B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE4B4);
		  /* 821BE4B4h */ case    0:  		/* cntlzw R11, R10 */
		/* 821BE4B4h case    0:*/		cpu::op::cntlzw<0>(regs,&regs.R11,regs.R10);
		/* 821BE4B4h case    0:*/		return 0x821BE4B8;
		  /* 821BE4B8h */ case    1:  		/* rlwinm R11, R11, 27, 31, 31 */
		/* 821BE4B8h case    1:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R11,regs.R11);
		/* 821BE4B8h case    1:*/		return 0x821BE4BC;
		  /* 821BE4BCh */ case    2:  		/* b 48 */
		/* 821BE4BCh case    2:*/		return 0x821BE4EC;
		/* 821BE4BCh case    2:*/		return 0x821BE4C0;
	}
	return 0x821BE4C0;
} // Block from 821BE4B4h-821BE4C0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BE4C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE4C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE4C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE4C0);
		  /* 821BE4C0h */ case    0:  		/* lfd FR0, <#[R27 + 40]> */
		/* 821BE4C0h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R27 + 0x00000028) );
		/* 821BE4C0h case    0:*/		return 0x821BE4C4;
		  /* 821BE4C4h */ case    1:  		/* li R11, 1 */
		/* 821BE4C4h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821BE4C4h case    1:*/		return 0x821BE4C8;
		  /* 821BE4C8h */ case    2:  		/* fcmpu CR6, FR0, FR31 */
		/* 821BE4C8h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 821BE4C8h case    2:*/		return 0x821BE4CC;
		  /* 821BE4CCh */ case    3:  		/* bc 12, CR6_LT, 28 */
		/* 821BE4CCh case    3:*/		if ( regs.CR[6].lt ) { return 0x821BE4E8;  }
		/* 821BE4CCh case    3:*/		return 0x821BE4D0;
	}
	return 0x821BE4D0;
} // Block from 821BE4C0h-821BE4D0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BE4D0h
// Function '?SupportsInputDef_BeforeCleanPhase@Instruction@D3DXShader@@QAA_NPAV12@PAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE4D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE4D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE4D0);
		  /* 821BE4D0h */ case    0:  		/* b 20 */
		/* 821BE4D0h case    0:*/		return 0x821BE4E4;
		/* 821BE4D0h case    0:*/		return 0x821BE4D4;
	}
	return 0x821BE4D4;
} // Block from 821BE4D0h-821BE4D4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BE4D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE4D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE4D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE4D4);
		  /* 821BE4D4h */ case    0:  		/* lfd FR0, <#[R27 + 40]> */
		/* 821BE4D4h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R27 + 0x00000028) );
		/* 821BE4D4h case    0:*/		return 0x821BE4D8;
		  /* 821BE4D8h */ case    1:  		/* li R11, 1 */
		/* 821BE4D8h case    1:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821BE4D8h case    1:*/		return 0x821BE4DC;
		  /* 821BE4DCh */ case    2:  		/* fcmpu CR6, FR0, FR31 */
		/* 821BE4DCh case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR0,regs.FR31);
		/* 821BE4DCh case    2:*/		return 0x821BE4E0;
		  /* 821BE4E0h */ case    3:  		/* bc 12, CR6_GT, 8 */
		/* 821BE4E0h case    3:*/		if ( regs.CR[6].gt ) { return 0x821BE4E8;  }
		/* 821BE4E0h case    3:*/		return 0x821BE4E4;
	}
	return 0x821BE4E4;
} // Block from 821BE4D4h-821BE4E4h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BE4E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE4E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE4E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE4E4);
		  /* 821BE4E4h */ case    0:  		/* li R11, 0 */
		/* 821BE4E4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BE4E4h case    0:*/		return 0x821BE4E8;
	}
	return 0x821BE4E8;
} // Block from 821BE4E4h-821BE4E8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BE4E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE4E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE4E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE4E8);
		  /* 821BE4E8h */ case    0:  		/* rlwinm R11, R11, 0, 24, 31 */
		/* 821BE4E8h case    0:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821BE4E8h case    0:*/		return 0x821BE4EC;
	}
	return 0x821BE4EC;
} // Block from 821BE4E8h-821BE4ECh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BE4ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE4EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE4EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE4EC);
		  /* 821BE4ECh */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821BE4ECh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821BE4ECh case    0:*/		return 0x821BE4F0;
		  /* 821BE4F0h */ case    1:  		/* bc 12, CR0_EQ, 460 */
		/* 821BE4F0h case    1:*/		if ( regs.CR[0].eq ) { return 0x821BE6BC;  }
		/* 821BE4F0h case    1:*/		return 0x821BE4F4;
		  /* 821BE4F4h */ case    2:  		/* lwz R11, <#[R29 + 8]> */
		/* 821BE4F4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 821BE4F4h case    2:*/		return 0x821BE4F8;
		  /* 821BE4F8h */ case    3:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821BE4F8h case    3:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821BE4F8h case    3:*/		return 0x821BE4FC;
		  /* 821BE4FCh */ case    4:  		/* cmplwi CR6, R11, 125 */
		/* 821BE4FCh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 821BE4FCh case    4:*/		return 0x821BE500;
		  /* 821BE500h */ case    5:  		/* bc 4, CR6_EQ, 168 */
		/* 821BE500h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821BE5A8;  }
		/* 821BE500h case    5:*/		return 0x821BE504;
		  /* 821BE504h */ case    6:  		/* mr R3, R29 */
		/* 821BE504h case    6:*/		regs.R3 = regs.R29;
		/* 821BE504h case    6:*/		return 0x821BE508;
		  /* 821BE508h */ case    7:  		/* lwz R5, <#[R1 + 268]> */
		/* 821BE508h case    7:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x0000010C) );
		/* 821BE508h case    7:*/		return 0x821BE50C;
		  /* 821BE50Ch */ case    8:  		/* lwz R4, <#[R1 + 260]> */
		/* 821BE50Ch case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R1 + 0x00000104) );
		/* 821BE50Ch case    8:*/		return 0x821BE510;
		  /* 821BE510h */ case    9:  		/* bl 405904 */
		/* 821BE510h case    9:*/		regs.LR = 0x821BE514; return 0x822216A0;
		/* 821BE510h case    9:*/		return 0x821BE514;
		  /* 821BE514h */ case   10:  		/* fmr FR31, FR1 */
		/* 821BE514h case   10:*/		cpu::op::fmr<0>(regs,&regs.FR31,regs.FR1);
		/* 821BE514h case   10:*/		return 0x821BE518;
		  /* 821BE518h */ case   11:  		/* cmpwi CR6, R30, 15 */
		/* 821BE518h case   11:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x0000000F);
		/* 821BE518h case   11:*/		return 0x821BE51C;
		  /* 821BE51Ch */ case   12:  		/* bc 12, CR6_LT, 32 */
		/* 821BE51Ch case   12:*/		if ( regs.CR[6].lt ) { return 0x821BE53C;  }
		/* 821BE51Ch case   12:*/		return 0x821BE520;
		  /* 821BE520h */ case   13:  		/* cmpwi CR6, R30, 16 */
		/* 821BE520h case   13:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000010);
		/* 821BE520h case   13:*/		return 0x821BE524;
		  /* 821BE524h */ case   14:  		/* bc 4, CR6_GT, 12 */
		/* 821BE524h case   14:*/		if ( !regs.CR[6].gt ) { return 0x821BE530;  }
		/* 821BE524h case   14:*/		return 0x821BE528;
		  /* 821BE528h */ case   15:  		/* cmpwi CR6, R30, 20 */
		/* 821BE528h case   15:*/		cpu::op::cmpwi<6>(regs,regs.R30,0x00000014);
		/* 821BE528h case   15:*/		return 0x821BE52C;
		  /* 821BE52Ch */ case   16:  		/* bc 4, CR6_EQ, 16 */
		/* 821BE52Ch case   16:*/		if ( !regs.CR[6].eq ) { return 0x821BE53C;  }
		/* 821BE52Ch case   16:*/		return 0x821BE530;
	}
	return 0x821BE530;
} // Block from 821BE4ECh-821BE530h (17 instructions)

//////////////////////////////////////////////////////
// Block at 821BE530h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE530( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE530) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE530);
		  /* 821BE530h */ case    0:  		/* lwz R11, <#[R27]> */
		/* 821BE530h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 821BE530h case    0:*/		return 0x821BE534;
		  /* 821BE534h */ case    1:  		/* rlwinm R11, R11, 0, 2, 0 */
		/* 821BE534h case    1:*/		cpu::op::rlwinm<0,0,2,0>(regs,&regs.R11,regs.R11);
		/* 821BE534h case    1:*/		return 0x821BE538;
		  /* 821BE538h */ case    2:  		/* stw R11, <#[R27]> */
		/* 821BE538h case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 821BE538h case    2:*/		return 0x821BE53C;
	}
	return 0x821BE53C;
} // Block from 821BE530h-821BE53Ch (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BE53Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE53C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE53C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE53C);
		  /* 821BE53Ch */ case    0:  		/* lwz R11, <#[R27]> */
		/* 821BE53Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 821BE53Ch case    0:*/		return 0x821BE540;
		  /* 821BE540h */ case    1:  		/* lfd FR0, <#[R27 + 24]> */
		/* 821BE540h case    1:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R27 + 0x00000018) );
		/* 821BE540h case    1:*/		return 0x821BE544;
		  /* 821BE544h */ case    2:  		/* fcmpu CR6, FR31, FR0 */
		/* 821BE544h case    2:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR0);
		/* 821BE544h case    2:*/		return 0x821BE548;
		  /* 821BE548h */ case    3:  		/* ori R11, R11, 64 */
		/* 821BE548h case    3:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x40);
		/* 821BE548h case    3:*/		return 0x821BE54C;
		  /* 821BE54Ch */ case    4:  		/* stw R11, <#[R27]> */
		/* 821BE54Ch case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 821BE54Ch case    4:*/		return 0x821BE550;
		  /* 821BE550h */ case    5:  		/* bc 4, CR6_LT, 8 */
		/* 821BE550h case    5:*/		if ( !regs.CR[6].lt ) { return 0x821BE558;  }
		/* 821BE550h case    5:*/		return 0x821BE554;
		  /* 821BE554h */ case    6:  		/* stfd FR31, <#[R27 + 24]> */
		/* 821BE554h case    6:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R27 + 0x00000018) );
		/* 821BE554h case    6:*/		return 0x821BE558;
	}
	return 0x821BE558;
} // Block from 821BE53Ch-821BE558h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BE558h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE558( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE558) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE558);
		  /* 821BE558h */ case    0:  		/* lfd FR0, <#[R27 + 32]> */
		/* 821BE558h case    0:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R27 + 0x00000020) );
		/* 821BE558h case    0:*/		return 0x821BE55C;
		  /* 821BE55Ch */ case    1:  		/* fcmpu CR6, FR31, FR0 */
		/* 821BE55Ch case    1:*/		cpu::op::fcmpu<6>(regs,regs.FR31,regs.FR0);
		/* 821BE55Ch case    1:*/		return 0x821BE560;
		  /* 821BE560h */ case    2:  		/* bc 4, CR6_GT, 8 */
		/* 821BE560h case    2:*/		if ( !regs.CR[6].gt ) { return 0x821BE568;  }
		/* 821BE560h case    2:*/		return 0x821BE564;
		  /* 821BE564h */ case    3:  		/* stfd FR31, <#[R27 + 32]> */
		/* 821BE564h case    3:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R27 + 0x00000020) );
		/* 821BE564h case    3:*/		return 0x821BE568;
	}
	return 0x821BE568;
} // Block from 821BE558h-821BE568h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BE568h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE568( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE568) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE568);
		  /* 821BE568h */ case    0:  		/* li R5, 39 */
		/* 821BE568h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x27);
		/* 821BE568h case    0:*/		return 0x821BE56C;
		  /* 821BE56Ch */ case    1:  		/* li R4, 32 */
		/* 821BE56Ch case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x20);
		/* 821BE56Ch case    1:*/		return 0x821BE570;
		  /* 821BE570h */ case    2:  		/* mr R3, R25 */
		/* 821BE570h case    2:*/		regs.R3 = regs.R25;
		/* 821BE570h case    2:*/		return 0x821BE574;
		  /* 821BE574h */ case    3:  		/* bl -367748 */
		/* 821BE574h case    3:*/		regs.LR = 0x821BE578; return 0x821648F0;
		/* 821BE574h case    3:*/		return 0x821BE578;
		  /* 821BE578h */ case    4:  		/* li R9, 1 */
		/* 821BE578h case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 821BE578h case    4:*/		return 0x821BE57C;
		  /* 821BE57Ch */ case    5:  		/* stfd FR31, <#[R3 + 16]> */
		/* 821BE57Ch case    5:*/		cpu::mem::store64f( regs, regs.FR31, (uint32)(regs.R3 + 0x00000010) );
		/* 821BE57Ch case    5:*/		return 0x821BE580;
		  /* 821BE580h */ case    6:  		/* mr R10, R3 */
		/* 821BE580h case    6:*/		regs.R10 = regs.R3;
		/* 821BE580h case    6:*/		return 0x821BE584;
		  /* 821BE584h */ case    7:  		/* stw R9, <#[R3]> */
		/* 821BE584h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 821BE584h case    7:*/		return 0x821BE588;
		  /* 821BE588h */ case    8:  		/* stw R24, <#[R3 + 4]> */
		/* 821BE588h case    8:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R3 + 0x00000004) );
		/* 821BE588h case    8:*/		return 0x821BE58C;
		  /* 821BE58Ch */ case    9:  		/* stw R28, <#[R3 + 8]> */
		/* 821BE58Ch case    9:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R3 + 0x00000008) );
		/* 821BE58Ch case    9:*/		return 0x821BE590;
		  /* 821BE590h */ case   10:  		/* lwz R11, <#[R1 + 276]> */
		/* 821BE590h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000114) );
		/* 821BE590h case   10:*/		return 0x821BE594;
		  /* 821BE594h */ case   11:  		/* li R3, 3 */
		/* 821BE594h case   11:*/		cpu::op::li<0>(regs,&regs.R3,0x3);
		/* 821BE594h case   11:*/		return 0x821BE598;
	}
	return 0x821BE598;
} // Block from 821BE568h-821BE598h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821BE598h
// Function '?AddArrayLengthConstraint@Instruction@D3DXShader@@QAAXIIPAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE598( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE598) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE598);
		  /* 821BE598h */ case    0:  		/* lwz R9, <#[R11]> */
		/* 821BE598h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821BE598h case    0:*/		return 0x821BE59C;
		  /* 821BE59Ch */ case    1:  		/* stw R9, <#[R10 + 24]> */
		/* 821BE59Ch case    1:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000018) );
		/* 821BE59Ch case    1:*/		return 0x821BE5A0;
		  /* 821BE5A0h */ case    2:  		/* stw R10, <#[R11]> */
		/* 821BE5A0h case    2:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821BE5A0h case    2:*/		return 0x821BE5A4;
		  /* 821BE5A4h */ case    3:  		/* b 284 */
		/* 821BE5A4h case    3:*/		return 0x821BE6C0;
		/* 821BE5A4h case    3:*/		return 0x821BE5A8;
	}
	return 0x821BE5A8;
} // Block from 821BE598h-821BE5A8h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BE5A8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE5A8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE5A8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE5A8);
		  /* 821BE5A8h */ case    0:  		/* cmplwi CR6, R11, 124 */
		/* 821BE5A8h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 821BE5A8h case    0:*/		return 0x821BE5AC;
		  /* 821BE5ACh */ case    1:  		/* bc 4, CR6_EQ, 272 */
		/* 821BE5ACh case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BE6BC;  }
		/* 821BE5ACh case    1:*/		return 0x821BE5B0;
		  /* 821BE5B0h */ case    2:  		/* lwz R11, <#[R29 + 8]> */
		/* 821BE5B0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 821BE5B0h case    2:*/		return 0x821BE5B4;
		  /* 821BE5B4h */ case    3:  		/* mr R3, R25 */
		/* 821BE5B4h case    3:*/		regs.R3 = regs.R25;
		/* 821BE5B4h case    3:*/		return 0x821BE5B8;
		  /* 821BE5B8h */ case    4:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 821BE5B8h case    4:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 821BE5B8h case    4:*/		return 0x821BE5BC;
		  /* 821BE5BCh */ case    5:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 821BE5BCh case    5:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 821BE5BCh case    5:*/		return 0x821BE5C0;
		  /* 821BE5C0h */ case    6:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 821BE5C0h case    6:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 821BE5C0h case    6:*/		return 0x821BE5C4;
		  /* 821BE5C4h */ case    7:  		/* bl -369044 */
		/* 821BE5C4h case    7:*/		regs.LR = 0x821BE5C8; return 0x82164430;
		/* 821BE5C4h case    7:*/		return 0x821BE5C8;
		  /* 821BE5C8h */ case    8:  		/* addi R10, R29, -8 */
		/* 821BE5C8h case    8:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R29,0xFFFFFFF8);
		/* 821BE5C8h case    8:*/		return 0x821BE5CC;
		  /* 821BE5CCh */ case    9:  		/* lwz R11, <#[R25 + 12]> */
		/* 821BE5CCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x0000000C) );
		/* 821BE5CCh case    9:*/		return 0x821BE5D0;
		  /* 821BE5D0h */ case   10:  		/* lwzx R10, <#[R3 + R10]> */
		/* 821BE5D0h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + regs.R10 + 0x00000000) );
		/* 821BE5D0h case   10:*/		return 0x821BE5D4;
		  /* 821BE5D4h */ case   11:  		/* rlwinm R10, R10, 0, 17, 31 */
		/* 821BE5D4h case   11:*/		cpu::op::rlwinm<0,0,17,31>(regs,&regs.R10,regs.R10);
		/* 821BE5D4h case   11:*/		return 0x821BE5D8;
		  /* 821BE5D8h */ case   12:  		/* mulli R10, R10, 40 */
		/* 821BE5D8h case   12:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R10,0x28);
		/* 821BE5D8h case   12:*/		return 0x821BE5DC;
		  /* 821BE5DCh */ case   13:  		/* add R11, R10, R11 */
		/* 821BE5DCh case   13:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821BE5DCh case   13:*/		return 0x821BE5E0;
		  /* 821BE5E0h */ case   14:  		/* lwz R10, <#[R11]> */
		/* 821BE5E0h case   14:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821BE5E0h case   14:*/		return 0x821BE5E4;
		  /* 821BE5E4h */ case   15:  		/* rlwinm. R9, R10, 0, 12, 12 */
		/* 821BE5E4h case   15:*/		cpu::op::rlwinm<1,0,12,12>(regs,&regs.R9,regs.R10);
		/* 821BE5E4h case   15:*/		return 0x821BE5E8;
		  /* 821BE5E8h */ case   16:  		/* bc 12, CR0_EQ, 116 */
		/* 821BE5E8h case   16:*/		if ( regs.CR[0].eq ) { return 0x821BE65C;  }
		/* 821BE5E8h case   16:*/		return 0x821BE5EC;
		  /* 821BE5ECh */ case   17:  		/* lwz R11, <#[R11 + 4]> */
		/* 821BE5ECh case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821BE5ECh case   17:*/		return 0x821BE5F0;
	}
	return 0x821BE5F0;
} // Block from 821BE5A8h-821BE5F0h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821BE5F0h
// Function '?MarkMustInlineCall@Compiler@D3DXShader@@AAAXPAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE5F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE5F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE5F0);
		  /* 821BE5F0h */ case    0:  		/* rlwinm R11, R11, 0, 25, 27 */
		/* 821BE5F0h case    0:*/		cpu::op::rlwinm<0,0,25,27>(regs,&regs.R11,regs.R11);
		/* 821BE5F0h case    0:*/		return 0x821BE5F4;
		  /* 821BE5F4h */ case    1:  		/* cmplwi CR6, R11, 16 */
		/* 821BE5F4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000010);
		/* 821BE5F4h case    1:*/		return 0x821BE5F8;
		  /* 821BE5F8h */ case    2:  		/* bc 4, CR6_EQ, 196 */
		/* 821BE5F8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821BE6BC;  }
		/* 821BE5F8h case    2:*/		return 0x821BE5FC;
		  /* 821BE5FCh */ case    3:  		/* lwz R11, <#[R27]> */
		/* 821BE5FCh case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 821BE5FCh case    3:*/		return 0x821BE600;
		  /* 821BE600h */ case    4:  		/* rlwinm. R10, R11, 0, 21, 21 */
		/* 821BE600h case    4:*/		cpu::op::rlwinm<1,0,21,21>(regs,&regs.R10,regs.R11);
		/* 821BE600h case    4:*/		return 0x821BE604;
		  /* 821BE604h */ case    5:  		/* bc 4, CR0_EQ, 184 */
		/* 821BE604h case    5:*/		if ( !regs.CR[0].eq ) { return 0x821BE6BC;  }
		/* 821BE604h case    5:*/		return 0x821BE608;
		  /* 821BE608h */ case    6:  		/* lwz R10, <#[R1 + 260]> */
		/* 821BE608h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R1 + 0x00000104) );
		/* 821BE608h case    6:*/		return 0x821BE60C;
		  /* 821BE60Ch */ case    7:  		/* ori R11, R11, 1024 */
		/* 821BE60Ch case    7:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x400);
		/* 821BE60Ch case    7:*/		return 0x821BE610;
		  /* 821BE610h */ case    8:  		/* stw R29, <#[R27 + 56]> */
		/* 821BE610h case    8:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R27 + 0x00000038) );
		/* 821BE610h case    8:*/		return 0x821BE614;
		  /* 821BE614h */ case    9:  		/* cmpwi CR6, R10, 0 */
		/* 821BE614h case    9:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 821BE614h case    9:*/		return 0x821BE618;
		  /* 821BE618h */ case   10:  		/* stw R11, <#[R27]> */
		/* 821BE618h case   10:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 821BE618h case   10:*/		return 0x821BE61C;
		  /* 821BE61Ch */ case   11:  		/* bc 4, CR6_EQ, 16 */
		/* 821BE61Ch case   11:*/		if ( !regs.CR[6].eq ) { return 0x821BE62C;  }
		/* 821BE61Ch case   11:*/		return 0x821BE620;
		  /* 821BE620h */ case   12:  		/* lwz R11, <#[R27 + 4]> */
		/* 821BE620h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 821BE620h case   12:*/		return 0x821BE624;
		  /* 821BE624h */ case   13:  		/* oris R11, R11, 1 */
		/* 821BE624h case   13:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821BE624h case   13:*/		return 0x821BE628;
		  /* 821BE628h */ case   14:  		/* stw R11, <#[R27 + 4]> */
		/* 821BE628h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 821BE628h case   14:*/		return 0x821BE62C;
	}
	return 0x821BE62C;
} // Block from 821BE5F0h-821BE62Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 821BE62Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE62C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE62C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE62C);
		  /* 821BE62Ch */ case    0:  		/* li R5, 39 */
		/* 821BE62Ch case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x27);
		/* 821BE62Ch case    0:*/		return 0x821BE630;
		  /* 821BE630h */ case    1:  		/* li R4, 32 */
		/* 821BE630h case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x20);
		/* 821BE630h case    1:*/		return 0x821BE634;
		  /* 821BE634h */ case    2:  		/* mr R3, R25 */
		/* 821BE634h case    2:*/		regs.R3 = regs.R25;
		/* 821BE634h case    2:*/		return 0x821BE638;
		  /* 821BE638h */ case    3:  		/* bl -367944 */
		/* 821BE638h case    3:*/		regs.LR = 0x821BE63C; return 0x821648F0;
		/* 821BE638h case    3:*/		return 0x821BE63C;
		  /* 821BE63Ch */ case    4:  		/* li R9, 2 */
		/* 821BE63Ch case    4:*/		cpu::op::li<0>(regs,&regs.R9,0x2);
		/* 821BE63Ch case    4:*/		return 0x821BE640;
		  /* 821BE640h */ case    5:  		/* stw R24, <#[R3 + 4]> */
		/* 821BE640h case    5:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R3 + 0x00000004) );
		/* 821BE640h case    5:*/		return 0x821BE644;
		  /* 821BE644h */ case    6:  		/* mr R10, R3 */
		/* 821BE644h case    6:*/		regs.R10 = regs.R3;
		/* 821BE644h case    6:*/		return 0x821BE648;
		  /* 821BE648h */ case    7:  		/* stw R9, <#[R3]> */
		/* 821BE648h case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000000) );
		/* 821BE648h case    7:*/		return 0x821BE64C;
		  /* 821BE64Ch */ case    8:  		/* stw R28, <#[R3 + 8]> */
		/* 821BE64Ch case    8:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R3 + 0x00000008) );
		/* 821BE64Ch case    8:*/		return 0x821BE650;
		  /* 821BE650h */ case    9:  		/* lwz R9, <#[R1 + 252]> */
		/* 821BE650h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x000000FC) );
		/* 821BE650h case    9:*/		return 0x821BE654;
		  /* 821BE654h */ case   10:  		/* stw R9, <#[R3 + 16]> */
		/* 821BE654h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R3 + 0x00000010) );
		/* 821BE654h case   10:*/		return 0x821BE658;
		  /* 821BE658h */ case   11:  		/* b -200 */
		/* 821BE658h case   11:*/		return 0x821BE590;
		/* 821BE658h case   11:*/		return 0x821BE65C;
	}
	return 0x821BE65C;
} // Block from 821BE62Ch-821BE65Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 821BE65Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE65C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE65C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE65C);
		  /* 821BE65Ch */ case    0:  		/* lwz R9, <#[R1 + 260]> */
		/* 821BE65Ch case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000104) );
		/* 821BE65Ch case    0:*/		return 0x821BE660;
		  /* 821BE660h */ case    1:  		/* lhz R8, <#[R29 + 14]> */
		/* 821BE660h case    1:*/		cpu::mem::load16z( regs, &regs.R8, (uint32)(regs.R29 + 0x0000000E) );
		/* 821BE660h case    1:*/		return 0x821BE664;
		  /* 821BE664h */ case    2:  		/* rlwinm R9, R9, 2, 16, 29 */
		/* 821BE664h case    2:*/		cpu::op::rlwinm<0,2,16,29>(regs,&regs.R9,regs.R9);
		/* 821BE664h case    2:*/		return 0x821BE668;
		  /* 821BE668h */ case    3:  		/* srw R9, R8, R9 */
		/* 821BE668h case    3:*/		cpu::op::srw<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 821BE668h case    3:*/		return 0x821BE66C;
		  /* 821BE66Ch */ case    4:  		/* rlwinm. R9, R9, 0, 29, 29 */
		/* 821BE66Ch case    4:*/		cpu::op::rlwinm<1,0,29,29>(regs,&regs.R9,regs.R9);
		/* 821BE66Ch case    4:*/		return 0x821BE670;
		  /* 821BE670h */ case    5:  		/* bc 12, CR0_EQ, 76 */
		/* 821BE670h case    5:*/		if ( regs.CR[0].eq ) { return 0x821BE6BC;  }
		/* 821BE670h case    5:*/		return 0x821BE674;
		  /* 821BE674h */ case    6:  		/* rlwinm R10, R10, 0, 15, 28 */
		/* 821BE674h case    6:*/		cpu::op::rlwinm<0,0,15,28>(regs,&regs.R10,regs.R10);
		/* 821BE674h case    6:*/		return 0x821BE678;
		  /* 821BE678h */ case    7:  		/* cmplwi CR6, R10, 8 */
		/* 821BE678h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000008);
		/* 821BE678h case    7:*/		return 0x821BE67C;
		  /* 821BE67Ch */ case    8:  		/* bc 4, CR6_EQ, 64 */
		/* 821BE67Ch case    8:*/		if ( !regs.CR[6].eq ) { return 0x821BE6BC;  }
		/* 821BE67Ch case    8:*/		return 0x821BE680;
		  /* 821BE680h */ case    9:  		/* lwz R11, <#[R11 + 36]> */
		/* 821BE680h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 821BE680h case    9:*/		return 0x821BE684;
		  /* 821BE684h */ case   10:  		/* cmplwi CR6, R11, 0 */
		/* 821BE684h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BE684h case   10:*/		return 0x821BE688;
		  /* 821BE688h */ case   11:  		/* bc 4, CR6_EQ, 52 */
		/* 821BE688h case   11:*/		if ( !regs.CR[6].eq ) { return 0x821BE6BC;  }
		/* 821BE688h case   11:*/		return 0x821BE68C;
		  /* 821BE68Ch */ case   12:  		/* lwz R11, <#[R27]> */
		/* 821BE68Ch case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 821BE68Ch case   12:*/		return 0x821BE690;
		  /* 821BE690h */ case   13:  		/* rlwinm. R10, R11, 0, 20, 20 */
		/* 821BE690h case   13:*/		cpu::op::rlwinm<1,0,20,20>(regs,&regs.R10,regs.R11);
		/* 821BE690h case   13:*/		return 0x821BE694;
		  /* 821BE694h */ case   14:  		/* bc 4, CR0_EQ, 40 */
		/* 821BE694h case   14:*/		if ( !regs.CR[0].eq ) { return 0x821BE6BC;  }
		/* 821BE694h case   14:*/		return 0x821BE698;
	}
	return 0x821BE698;
} // Block from 821BE65Ch-821BE698h (15 instructions)

//////////////////////////////////////////////////////
// Block at 821BE698h
// Function '?IsValidSamplerOperandDef@Compiler@D3DXShader@@AAA_NPAVInstruction@2@0W4ResolveArrayReferencesStage@12@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE698( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE698) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE698);
		  /* 821BE698h */ case    0:  		/* ori R11, R11, 2048 */
		/* 821BE698h case    0:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x800);
		/* 821BE698h case    0:*/		return 0x821BE69C;
		  /* 821BE69Ch */ case    1:  		/* stw R29, <#[R27 + 56]> */
		/* 821BE69Ch case    1:*/		cpu::mem::store32( regs, regs.R29, (uint32)(regs.R27 + 0x00000038) );
		/* 821BE69Ch case    1:*/		return 0x821BE6A0;
		  /* 821BE6A0h */ case    2:  		/* li R5, 39 */
		/* 821BE6A0h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x27);
		/* 821BE6A0h case    2:*/		return 0x821BE6A4;
		  /* 821BE6A4h */ case    3:  		/* stw R11, <#[R27]> */
		/* 821BE6A4h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000000) );
		/* 821BE6A4h case    3:*/		return 0x821BE6A8;
		  /* 821BE6A8h */ case    4:  		/* li R4, 32 */
		/* 821BE6A8h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0x20);
		/* 821BE6A8h case    4:*/		return 0x821BE6AC;
		  /* 821BE6ACh */ case    5:  		/* mr R3, R25 */
		/* 821BE6ACh case    5:*/		regs.R3 = regs.R25;
		/* 821BE6ACh case    5:*/		return 0x821BE6B0;
		  /* 821BE6B0h */ case    6:  		/* bl -368064 */
		/* 821BE6B0h case    6:*/		regs.LR = 0x821BE6B4; return 0x821648F0;
		/* 821BE6B0h case    6:*/		return 0x821BE6B4;
		  /* 821BE6B4h */ case    7:  		/* li R9, 3 */
		/* 821BE6B4h case    7:*/		cpu::op::li<0>(regs,&regs.R9,0x3);
		/* 821BE6B4h case    7:*/		return 0x821BE6B8;
		  /* 821BE6B8h */ case    8:  		/* b -120 */
		/* 821BE6B8h case    8:*/		return 0x821BE640;
		/* 821BE6B8h case    8:*/		return 0x821BE6BC;
	}
	return 0x821BE6BC;
} // Block from 821BE698h-821BE6BCh (9 instructions)

//////////////////////////////////////////////////////
// Block at 821BE6BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE6BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE6BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE6BC);
		  /* 821BE6BCh */ case    0:  		/* li R3, 2 */
		/* 821BE6BCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x2);
		/* 821BE6BCh case    0:*/		return 0x821BE6C0;
	}
	return 0x821BE6C0;
} // Block from 821BE6BCh-821BE6C0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BE6C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE6C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE6C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE6C0);
		  /* 821BE6C0h */ case    0:  		/* addi R1, R1, 160 */
		/* 821BE6C0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 821BE6C0h case    0:*/		return 0x821BE6C4;
		  /* 821BE6C4h */ case    1:  		/* lfd FR31, <#[R1 - 80]> */
		/* 821BE6C4h case    1:*/		cpu::mem::load64f( regs, &regs.FR31, (uint32)(regs.R1 + 0xFFFFFFB0) );
		/* 821BE6C4h case    1:*/		return 0x821BE6C8;
		  /* 821BE6C8h */ case    2:  		/* b -1233968 */
		/* 821BE6C8h case    2:*/		return 0x82091298;
		/* 821BE6C8h case    2:*/		return 0x821BE6CC;
		  /* 821BE6CCh */ case    3:  		/* nop */
		/* 821BE6CCh case    3:*/		cpu::op::nop();
		/* 821BE6CCh case    3:*/		return 0x821BE6D0;
	}
	return 0x821BE6D0;
} // Block from 821BE6C0h-821BE6D0h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BE6D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE6D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE6D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE6D0);
		  /* 821BE6D0h */ case    0:  		/* mfspr R12, LR */
		/* 821BE6D0h case    0:*/		regs.R12 = regs.LR;
		/* 821BE6D0h case    0:*/		return 0x821BE6D4;
		  /* 821BE6D4h */ case    1:  		/* bl -1234060 */
		/* 821BE6D4h case    1:*/		regs.LR = 0x821BE6D8; return 0x82091248;
		/* 821BE6D4h case    1:*/		return 0x821BE6D8;
		  /* 821BE6D8h */ case    2:  		/* stwu R1, <#[R1 - 224]> */
		/* 821BE6D8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF20) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF20);
		/* 821BE6D8h case    2:*/		return 0x821BE6DC;
		  /* 821BE6DCh */ case    3:  		/* mr R27, R3 */
		/* 821BE6DCh case    3:*/		regs.R27 = regs.R3;
		/* 821BE6DCh case    3:*/		return 0x821BE6E0;
		  /* 821BE6E0h */ case    4:  		/* mr R26, R4 */
		/* 821BE6E0h case    4:*/		regs.R26 = regs.R4;
		/* 821BE6E0h case    4:*/		return 0x821BE6E4;
		  /* 821BE6E4h */ case    5:  		/* mr R25, R5 */
		/* 821BE6E4h case    5:*/		regs.R25 = regs.R5;
		/* 821BE6E4h case    5:*/		return 0x821BE6E8;
		  /* 821BE6E8h */ case    6:  		/* mr R30, R6 */
		/* 821BE6E8h case    6:*/		regs.R30 = regs.R6;
		/* 821BE6E8h case    6:*/		return 0x821BE6EC;
		  /* 821BE6ECh */ case    7:  		/* mr R31, R7 */
		/* 821BE6ECh case    7:*/		regs.R31 = regs.R7;
		/* 821BE6ECh case    7:*/		return 0x821BE6F0;
		  /* 821BE6F0h */ case    8:  		/* mr R29, R8 */
		/* 821BE6F0h case    8:*/		regs.R29 = regs.R8;
		/* 821BE6F0h case    8:*/		return 0x821BE6F4;
		  /* 821BE6F4h */ case    9:  		/* mr R24, R10 */
		/* 821BE6F4h case    9:*/		regs.R24 = regs.R10;
		/* 821BE6F4h case    9:*/		return 0x821BE6F8;
		  /* 821BE6F8h */ case   10:  		/* cmplwi CR6, R9, 0 */
		/* 821BE6F8h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 821BE6F8h case   10:*/		return 0x821BE6FC;
		  /* 821BE6FCh */ case   11:  		/* bc 4, CR6_EQ, 224 */
		/* 821BE6FCh case   11:*/		if ( !regs.CR[6].eq ) { return 0x821BE7DC;  }
		/* 821BE6FCh case   11:*/		return 0x821BE700;
		  /* 821BE700h */ case   12:  		/* lwz R11, <#[R7 + 8]> */
		/* 821BE700h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0x00000008) );
		/* 821BE700h case   12:*/		return 0x821BE704;
		  /* 821BE704h */ case   13:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821BE704h case   13:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821BE704h case   13:*/		return 0x821BE708;
		  /* 821BE708h */ case   14:  		/* cmpwi CR6, R11, 1 */
		/* 821BE708h case   14:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000001);
		/* 821BE708h case   14:*/		return 0x821BE70C;
		  /* 821BE70Ch */ case   15:  		/* bc 12, CR6_EQ, 208 */
		/* 821BE70Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x821BE7DC;  }
		/* 821BE70Ch case   15:*/		return 0x821BE710;
		  /* 821BE710h */ case   16:  		/* cmpwi CR6, R11, 5 */
		/* 821BE710h case   16:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000005);
		/* 821BE710h case   16:*/		return 0x821BE714;
		  /* 821BE714h */ case   17:  		/* bc 12, CR6_EQ, 52 */
		/* 821BE714h case   17:*/		if ( regs.CR[6].eq ) { return 0x821BE748;  }
		/* 821BE714h case   17:*/		return 0x821BE718;
		  /* 821BE718h */ case   18:  		/* cmpwi CR6, R11, 6 */
		/* 821BE718h case   18:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000006);
		/* 821BE718h case   18:*/		return 0x821BE71C;
		  /* 821BE71Ch */ case   19:  		/* bc 12, CR6_EQ, 36 */
		/* 821BE71Ch case   19:*/		if ( regs.CR[6].eq ) { return 0x821BE740;  }
		/* 821BE71Ch case   19:*/		return 0x821BE720;
		  /* 821BE720h */ case   20:  		/* cmpwi CR6, R11, 7 */
		/* 821BE720h case   20:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000007);
		/* 821BE720h case   20:*/		return 0x821BE724;
		  /* 821BE724h */ case   21:  		/* bc 12, CR6_EQ, 20 */
		/* 821BE724h case   21:*/		if ( regs.CR[6].eq ) { return 0x821BE738;  }
		/* 821BE724h case   21:*/		return 0x821BE728;
		  /* 821BE728h */ case   22:  		/* cmpwi CR6, R11, 8 */
		/* 821BE728h case   22:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000008);
		/* 821BE728h case   22:*/		return 0x821BE72C;
		  /* 821BE72Ch */ case   23:  		/* bc 4, CR6_EQ, 176 */
		/* 821BE72Ch case   23:*/		if ( !regs.CR[6].eq ) { return 0x821BE7DC;  }
		/* 821BE72Ch case   23:*/		return 0x821BE730;
		  /* 821BE730h */ case   24:  		/* li R28, 20 */
		/* 821BE730h case   24:*/		cpu::op::li<0>(regs,&regs.R28,0x14);
		/* 821BE730h case   24:*/		return 0x821BE734;
		  /* 821BE734h */ case   25:  		/* b 24 */
		/* 821BE734h case   25:*/		return 0x821BE74C;
		/* 821BE734h case   25:*/		return 0x821BE738;
	}
	return 0x821BE738;
} // Block from 821BE6D0h-821BE738h (26 instructions)

//////////////////////////////////////////////////////
// Block at 821BE738h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE738( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE738) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE738);
		  /* 821BE738h */ case    0:  		/* li R28, 18 */
		/* 821BE738h case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x12);
		/* 821BE738h case    0:*/		return 0x821BE73C;
		  /* 821BE73Ch */ case    1:  		/* b 16 */
		/* 821BE73Ch case    1:*/		return 0x821BE74C;
		/* 821BE73Ch case    1:*/		return 0x821BE740;
	}
	return 0x821BE740;
} // Block from 821BE738h-821BE740h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BE740h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE740( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE740) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE740);
		  /* 821BE740h */ case    0:  		/* li R28, 16 */
		/* 821BE740h case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x10);
		/* 821BE740h case    0:*/		return 0x821BE744;
		  /* 821BE744h */ case    1:  		/* b 8 */
		/* 821BE744h case    1:*/		return 0x821BE74C;
		/* 821BE744h case    1:*/		return 0x821BE748;
	}
	return 0x821BE748;
} // Block from 821BE740h-821BE748h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BE748h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE748( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE748) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE748);
		  /* 821BE748h */ case    0:  		/* li R28, 19 */
		/* 821BE748h case    0:*/		cpu::op::li<0>(regs,&regs.R28,0x13);
		/* 821BE748h case    0:*/		return 0x821BE74C;
	}
	return 0x821BE74C;
} // Block from 821BE748h-821BE74Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BE74Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE74C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE74C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE74C);
		  /* 821BE74Ch */ case    0:  		/* li R10, 0 */
		/* 821BE74Ch case    0:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821BE74Ch case    0:*/		return 0x821BE750;
		  /* 821BE750h */ case    1:  		/* lwz R3, <#[R31 + 44]> */
		/* 821BE750h case    1:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x0000002C) );
		/* 821BE750h case    1:*/		return 0x821BE754;
		  /* 821BE754h */ case    2:  		/* li R9, 0 */
		/* 821BE754h case    2:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821BE754h case    2:*/		return 0x821BE758;
		  /* 821BE758h */ case    3:  		/* li R8, 0 */
		/* 821BE758h case    3:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821BE758h case    3:*/		return 0x821BE75C;
		  /* 821BE75Ch */ case    4:  		/* addi R7, R1, 128 */
		/* 821BE75Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x80);
		/* 821BE75Ch case    4:*/		return 0x821BE760;
		  /* 821BE760h */ case    5:  		/* addi R6, R1, 132 */
		/* 821BE760h case    5:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x84);
		/* 821BE760h case    5:*/		return 0x821BE764;
		  /* 821BE764h */ case    6:  		/* addi R5, R1, 136 */
		/* 821BE764h case    6:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x88);
		/* 821BE764h case    6:*/		return 0x821BE768;
		  /* 821BE768h */ case    7:  		/* mr R4, R29 */
		/* 821BE768h case    7:*/		regs.R4 = regs.R29;
		/* 821BE768h case    7:*/		return 0x821BE76C;
		  /* 821BE76Ch */ case    8:  		/* bl 413028 */
		/* 821BE76Ch case    8:*/		regs.LR = 0x821BE770; return 0x822234D0;
		/* 821BE76Ch case    8:*/		return 0x821BE770;
		  /* 821BE770h */ case    9:  		/* li R10, 0 */
		/* 821BE770h case    9:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821BE770h case    9:*/		return 0x821BE774;
		  /* 821BE774h */ case   10:  		/* li R9, 0 */
		/* 821BE774h case   10:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821BE774h case   10:*/		return 0x821BE778;
		  /* 821BE778h */ case   11:  		/* lwz R3, <#[R31 + 48]> */
		/* 821BE778h case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000030) );
		/* 821BE778h case   11:*/		return 0x821BE77C;
		  /* 821BE77Ch */ case   12:  		/* li R8, 0 */
		/* 821BE77Ch case   12:*/		cpu::op::li<0>(regs,&regs.R8,0x0);
		/* 821BE77Ch case   12:*/		return 0x821BE780;
		  /* 821BE780h */ case   13:  		/* addi R7, R1, 140 */
		/* 821BE780h case   13:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x8C);
		/* 821BE780h case   13:*/		return 0x821BE784;
		  /* 821BE784h */ case   14:  		/* addi R6, R1, 144 */
		/* 821BE784h case   14:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x90);
		/* 821BE784h case   14:*/		return 0x821BE788;
		  /* 821BE788h */ case   15:  		/* addi R5, R1, 148 */
		/* 821BE788h case   15:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x94);
		/* 821BE788h case   15:*/		return 0x821BE78C;
		  /* 821BE78Ch */ case   16:  		/* mr R4, R29 */
		/* 821BE78Ch case   16:*/		regs.R4 = regs.R29;
		/* 821BE78Ch case   16:*/		return 0x821BE790;
	}
	return 0x821BE790;
} // Block from 821BE74Ch-821BE790h (17 instructions)

//////////////////////////////////////////////////////
// Block at 821BE790h
// Function '?ComputesBooleanValue@Compiler@D3DXShader@@AAA_NPAVInstruction@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE790( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE790) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE790);
		  /* 821BE790h */ case    0:  		/* bl 412992 */
		/* 821BE790h case    0:*/		regs.LR = 0x821BE794; return 0x822234D0;
		/* 821BE790h case    0:*/		return 0x821BE794;
		  /* 821BE794h */ case    1:  		/* mr R6, R30 */
		/* 821BE794h case    1:*/		regs.R6 = regs.R30;
		/* 821BE794h case    1:*/		return 0x821BE798;
		  /* 821BE798h */ case    2:  		/* stw R30, <#[R1 + 84]> */
		/* 821BE798h case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x00000054) );
		/* 821BE798h case    2:*/		return 0x821BE79C;
		  /* 821BE79Ch */ case    3:  		/* mr R10, R28 */
		/* 821BE79Ch case    3:*/		regs.R10 = regs.R28;
		/* 821BE79Ch case    3:*/		return 0x821BE7A0;
		  /* 821BE7A0h */ case    4:  		/* lwz R11, <#[R1 + 140]> */
		/* 821BE7A0h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x0000008C) );
		/* 821BE7A0h case    4:*/		return 0x821BE7A4;
		  /* 821BE7A4h */ case    5:  		/* mr R5, R25 */
		/* 821BE7A4h case    5:*/		regs.R5 = regs.R25;
		/* 821BE7A4h case    5:*/		return 0x821BE7A8;
		  /* 821BE7A8h */ case    6:  		/* mr R4, R26 */
		/* 821BE7A8h case    6:*/		regs.R4 = regs.R26;
		/* 821BE7A8h case    6:*/		return 0x821BE7AC;
		  /* 821BE7ACh */ case    7:  		/* lwz R9, <#[R1 + 128]> */
		/* 821BE7ACh case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R1 + 0x00000080) );
		/* 821BE7ACh case    7:*/		return 0x821BE7B0;
		  /* 821BE7B0h */ case    8:  		/* mr R3, R27 */
		/* 821BE7B0h case    8:*/		regs.R3 = regs.R27;
		/* 821BE7B0h case    8:*/		return 0x821BE7B4;
		  /* 821BE7B4h */ case    9:  		/* lwz R8, <#[R1 + 132]> */
		/* 821BE7B4h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R1 + 0x00000084) );
		/* 821BE7B4h case    9:*/		return 0x821BE7B8;
		  /* 821BE7B8h */ case   10:  		/* lwz R7, <#[R1 + 136]> */
		/* 821BE7B8h case   10:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R1 + 0x00000088) );
		/* 821BE7B8h case   10:*/		return 0x821BE7BC;
		  /* 821BE7BCh */ case   11:  		/* stw R24, <#[R1 + 116]> */
		/* 821BE7BCh case   11:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R1 + 0x00000074) );
		/* 821BE7BCh case   11:*/		return 0x821BE7C0;
		  /* 821BE7C0h */ case   12:  		/* stw R11, <#[R1 + 108]> */
		/* 821BE7C0h case   12:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x0000006C) );
		/* 821BE7C0h case   12:*/		return 0x821BE7C4;
		  /* 821BE7C4h */ case   13:  		/* lwz R31, <#[R1 + 144]> */
		/* 821BE7C4h case   13:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R1 + 0x00000090) );
		/* 821BE7C4h case   13:*/		return 0x821BE7C8;
		  /* 821BE7C8h */ case   14:  		/* lwz R30, <#[R1 + 148]> */
		/* 821BE7C8h case   14:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R1 + 0x00000094) );
		/* 821BE7C8h case   14:*/		return 0x821BE7CC;
		  /* 821BE7CCh */ case   15:  		/* stw R31, <#[R1 + 100]> */
		/* 821BE7CCh case   15:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000064) );
		/* 821BE7CCh case   15:*/		return 0x821BE7D0;
		  /* 821BE7D0h */ case   16:  		/* stw R30, <#[R1 + 92]> */
		/* 821BE7D0h case   16:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R1 + 0x0000005C) );
		/* 821BE7D0h case   16:*/		return 0x821BE7D4;
		  /* 821BE7D4h */ case   17:  		/* bl -1548 */
		/* 821BE7D4h case   17:*/		regs.LR = 0x821BE7D8; return 0x821BE1C8;
		/* 821BE7D4h case   17:*/		return 0x821BE7D8;
		  /* 821BE7D8h */ case   18:  		/* b 8 */
		/* 821BE7D8h case   18:*/		return 0x821BE7E0;
		/* 821BE7D8h case   18:*/		return 0x821BE7DC;
	}
	return 0x821BE7DC;
} // Block from 821BE790h-821BE7DCh (19 instructions)

//////////////////////////////////////////////////////
// Block at 821BE7DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE7DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE7DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE7DC);
		  /* 821BE7DCh */ case    0:  		/* li R3, 0 */
		/* 821BE7DCh case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821BE7DCh case    0:*/		return 0x821BE7E0;
	}
	return 0x821BE7E0;
} // Block from 821BE7DCh-821BE7E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BE7E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE7E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE7E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE7E0);
		  /* 821BE7E0h */ case    0:  		/* addi R1, R1, 224 */
		/* 821BE7E0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xE0);
		/* 821BE7E0h case    0:*/		return 0x821BE7E4;
		  /* 821BE7E4h */ case    1:  		/* b -1234252 */
		/* 821BE7E4h case    1:*/		return 0x82091298;
		/* 821BE7E4h case    1:*/		return 0x821BE7E8;
	}
	return 0x821BE7E8;
} // Block from 821BE7E0h-821BE7E8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BE7E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE7E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE7E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE7E8);
		  /* 821BE7E8h */ case    0:  		/* mfspr R12, LR */
		/* 821BE7E8h case    0:*/		regs.R12 = regs.LR;
		/* 821BE7E8h case    0:*/		return 0x821BE7EC;
		  /* 821BE7ECh */ case    1:  		/* bl -1234340 */
		/* 821BE7ECh case    1:*/		regs.LR = 0x821BE7F0; return 0x82091248;
		/* 821BE7ECh case    1:*/		return 0x821BE7F0;
		  /* 821BE7F0h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 821BE7F0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 821BE7F0h case    2:*/		return 0x821BE7F4;
		  /* 821BE7F4h */ case    3:  		/* lwz R11, <#[R4 + 8]> */
		/* 821BE7F4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821BE7F4h case    3:*/		return 0x821BE7F8;
		  /* 821BE7F8h */ case    4:  		/* mr R25, R3 */
		/* 821BE7F8h case    4:*/		regs.R25 = regs.R3;
		/* 821BE7F8h case    4:*/		return 0x821BE7FC;
		  /* 821BE7FCh */ case    5:  		/* mr R30, R4 */
		/* 821BE7FCh case    5:*/		regs.R30 = regs.R4;
		/* 821BE7FCh case    5:*/		return 0x821BE800;
		  /* 821BE800h */ case    6:  		/* rlwinm R10, R11, 0, 18, 24 */
		/* 821BE800h case    6:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R11);
		/* 821BE800h case    6:*/		return 0x821BE804;
		  /* 821BE804h */ case    7:  		/* mr R26, R5 */
		/* 821BE804h case    7:*/		regs.R26 = regs.R5;
		/* 821BE804h case    7:*/		return 0x821BE808;
		  /* 821BE808h */ case    8:  		/* mr R29, R6 */
		/* 821BE808h case    8:*/		regs.R29 = regs.R6;
		/* 821BE808h case    8:*/		return 0x821BE80C;
		  /* 821BE80Ch */ case    9:  		/* cmplwi CR6, R10, 1664 */
		/* 821BE80Ch case    9:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000680);
		/* 821BE80Ch case    9:*/		return 0x821BE810;
		  /* 821BE810h */ case   10:  		/* bc 12, CR6_EQ, 12 */
		/* 821BE810h case   10:*/		if ( regs.CR[6].eq ) { return 0x821BE81C;  }
		/* 821BE810h case   10:*/		return 0x821BE814;
		  /* 821BE814h */ case   11:  		/* li R3, 0 */
		/* 821BE814h case   11:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821BE814h case   11:*/		return 0x821BE818;
		  /* 821BE818h */ case   12:  		/* b 384 */
		/* 821BE818h case   12:*/		return 0x821BE998;
		/* 821BE818h case   12:*/		return 0x821BE81C;
	}
	return 0x821BE81C;
} // Block from 821BE7E8h-821BE81Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 821BE81Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE81C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE81C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE81C);
		  /* 821BE81Ch */ case    0:  		/* rlwinm. R11, R11, 6, 31, 31 */
		/* 821BE81Ch case    0:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R11,regs.R11);
		/* 821BE81Ch case    0:*/		return 0x821BE820;
		  /* 821BE820h */ case    1:  		/* bc 4, CR0_EQ, -12 */
		/* 821BE820h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821BE814;  }
		/* 821BE820h case    1:*/		return 0x821BE824;
		  /* 821BE824h */ case    2:  		/* lwz R11, <#[R30 + 44]> */
		/* 821BE824h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000002C) );
		/* 821BE824h case    2:*/		return 0x821BE828;
	}
	return 0x821BE828;
} // Block from 821BE81Ch-821BE828h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BE828h
// Function '?SimplifyCastDependents@Compiler@D3DXShader@@AAAXPAVInstruction@2@0IIPAV?$Stack@PAVInstruction@D3DXShader@@$1?AllocInContext@CompilerHeap@2@SAPAXPAXK@Z$1?FreeInContext@42@SAX00K@Z@2@PA_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE828( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE828) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE828);
		  /* 821BE828h */ case    0:  		/* lwz R10, <#[R11]> */
		/* 821BE828h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821BE828h case    0:*/		return 0x821BE82C;
		  /* 821BE82Ch */ case    1:  		/* rlwinm. R9, R10, 0, 27, 31 */
		/* 821BE82Ch case    1:*/		cpu::op::rlwinm<1,0,27,31>(regs,&regs.R9,regs.R10);
		/* 821BE82Ch case    1:*/		return 0x821BE830;
		  /* 821BE830h */ case    2:  		/* bc 4, CR0_EQ, -28 */
		/* 821BE830h case    2:*/		if ( !regs.CR[0].eq ) { return 0x821BE814;  }
		/* 821BE830h case    2:*/		return 0x821BE834;
		  /* 821BE834h */ case    3:  		/* rlwinm R9, R10, 0, 4, 6 */
		/* 821BE834h case    3:*/		cpu::op::rlwinm<0,0,4,6>(regs,&regs.R9,regs.R10);
		/* 821BE834h case    3:*/		return 0x821BE838;
		  /* 821BE838h */ case    4:  		/* lis R8, 512 */
		/* 821BE838h case    4:*/		cpu::op::lis<0>(regs,&regs.R8,0x200);
		/* 821BE838h case    4:*/		return 0x821BE83C;
		  /* 821BE83Ch */ case    5:  		/* cmplw CR6, R9, R8 */
		/* 821BE83Ch case    5:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 821BE83Ch case    5:*/		return 0x821BE840;
		  /* 821BE840h */ case    6:  		/* bc 4, CR6_EQ, -44 */
		/* 821BE840h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821BE814;  }
		/* 821BE840h case    6:*/		return 0x821BE844;
		  /* 821BE844h */ case    7:  		/* lwz R24, <#[R30 + 48]> */
		/* 821BE844h case    7:*/		cpu::mem::load32z( regs, &regs.R24, (uint32)(regs.R30 + 0x00000030) );
		/* 821BE844h case    7:*/		return 0x821BE848;
		  /* 821BE848h */ case    8:  		/* lwz R9, <#[R24]> */
		/* 821BE848h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R24 + 0x00000000) );
		/* 821BE848h case    8:*/		return 0x821BE84C;
		  /* 821BE84Ch */ case    9:  		/* rlwinm. R9, R9, 0, 27, 31 */
		/* 821BE84Ch case    9:*/		cpu::op::rlwinm<1,0,27,31>(regs,&regs.R9,regs.R9);
		/* 821BE84Ch case    9:*/		return 0x821BE850;
		  /* 821BE850h */ case   10:  		/* bc 4, CR0_EQ, -60 */
		/* 821BE850h case   10:*/		if ( !regs.CR[0].eq ) { return 0x821BE814;  }
		/* 821BE850h case   10:*/		return 0x821BE854;
		  /* 821BE854h */ case   11:  		/* lwz R27, <#[R11 + 12]> */
		/* 821BE854h case   11:*/		cpu::mem::load32z( regs, &regs.R27, (uint32)(regs.R11 + 0x0000000C) );
		/* 821BE854h case   11:*/		return 0x821BE858;
		  /* 821BE858h */ case   12:  		/* li R28, 0 */
		/* 821BE858h case   12:*/		cpu::op::li<0>(regs,&regs.R28,0x0);
		/* 821BE858h case   12:*/		return 0x821BE85C;
		  /* 821BE85Ch */ case   13:  		/* cmplw CR6, R27, R26 */
		/* 821BE85Ch case   13:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R26);
		/* 821BE85Ch case   13:*/		return 0x821BE860;
		  /* 821BE860h */ case   14:  		/* bc 12, CR6_EQ, 124 */
		/* 821BE860h case   14:*/		if ( regs.CR[6].eq ) { return 0x821BE8DC;  }
		/* 821BE860h case   14:*/		return 0x821BE864;
		  /* 821BE864h */ case   15:  		/* lwz R11, <#[R27 + 8]> */
		/* 821BE864h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 821BE864h case   15:*/		return 0x821BE868;
		  /* 821BE868h */ case   16:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821BE868h case   16:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821BE868h case   16:*/		return 0x821BE86C;
		  /* 821BE86Ch */ case   17:  		/* cmplwi CR6, R11, 128 */
		/* 821BE86Ch case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000080);
		/* 821BE86Ch case   17:*/		return 0x821BE870;
		  /* 821BE870h */ case   18:  		/* bc 4, CR6_EQ, -92 */
		/* 821BE870h case   18:*/		if ( !regs.CR[6].eq ) { return 0x821BE814;  }
		/* 821BE870h case   18:*/		return 0x821BE874;
		  /* 821BE874h */ case   19:  		/* lwz R11, <#[R27 + 44]> */
		/* 821BE874h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000002C) );
		/* 821BE874h case   19:*/		return 0x821BE878;
		  /* 821BE878h */ case   20:  		/* lwz R11, <#[R11 + 12]> */
		/* 821BE878h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 821BE878h case   20:*/		return 0x821BE87C;
		  /* 821BE87Ch */ case   21:  		/* cmplw CR6, R11, R26 */
		/* 821BE87Ch case   21:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 821BE87Ch case   21:*/		return 0x821BE880;
		  /* 821BE880h */ case   22:  		/* bc 4, CR6_EQ, -108 */
		/* 821BE880h case   22:*/		if ( !regs.CR[6].eq ) { return 0x821BE814;  }
		/* 821BE880h case   22:*/		return 0x821BE884;
		  /* 821BE884h */ case   23:  		/* lwz R11, <#[R27 + 48]> */
		/* 821BE884h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000030) );
		/* 821BE884h case   23:*/		return 0x821BE888;
		  /* 821BE888h */ case   24:  		/* lwz R3, <#[R11 + 12]> */
		/* 821BE888h case   24:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R11 + 0x0000000C) );
		/* 821BE888h case   24:*/		return 0x821BE88C;
		  /* 821BE88Ch */ case   25:  		/* lwz R11, <#[R3 + 8]> */
		/* 821BE88Ch case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821BE88Ch case   25:*/		return 0x821BE890;
		  /* 821BE890h */ case   26:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821BE890h case   26:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821BE890h case   26:*/		return 0x821BE894;
		  /* 821BE894h */ case   27:  		/* cmplwi CR6, R11, 16000 */
		/* 821BE894h case   27:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E80);
		/* 821BE894h case   27:*/		return 0x821BE898;
		  /* 821BE898h */ case   28:  		/* bc 4, CR6_EQ, -132 */
		/* 821BE898h case   28:*/		if ( !regs.CR[6].eq ) { return 0x821BE814;  }
		/* 821BE898h case   28:*/		return 0x821BE89C;
		  /* 821BE89Ch */ case   29:  		/* rlwinm R4, R10, 27, 30, 31 */
		/* 821BE89Ch case   29:*/		cpu::op::rlwinm<0,27,30,31>(regs,&regs.R4,regs.R10);
		/* 821BE89Ch case   29:*/		return 0x821BE8A0;
		  /* 821BE8A0h */ case   30:  		/* bl -6480 */
		/* 821BE8A0h case   30:*/		regs.LR = 0x821BE8A4; return 0x821BCF50;
		/* 821BE8A0h case   30:*/		return 0x821BE8A4;
		  /* 821BE8A4h */ case   31:  		/* lis R11, -32256 */
		/* 821BE8A4h case   31:*/		cpu::op::lis<0>(regs,&regs.R11,0xFFFF8200);
		/* 821BE8A4h case   31:*/		return 0x821BE8A8;
		  /* 821BE8A8h */ case   32:  		/* lfd FR0, <#[R11 + 1808]> */
		/* 821BE8A8h case   32:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R11 + 0x00000710) );
		/* 821BE8A8h case   32:*/		return 0x821BE8AC;
		  /* 821BE8ACh */ case   33:  		/* fcmpu CR6, FR1, FR0 */
		/* 821BE8ACh case   33:*/		cpu::op::fcmpu<6>(regs,regs.FR1,regs.FR0);
		/* 821BE8ACh case   33:*/		return 0x821BE8B0;
		  /* 821BE8B0h */ case   34:  		/* bc 12, CR6_GT, -156 */
		/* 821BE8B0h case   34:*/		if ( regs.CR[6].gt ) { return 0x821BE814;  }
		/* 821BE8B0h case   34:*/		return 0x821BE8B4;
		  /* 821BE8B4h */ case   35:  		/* fneg FR0, FR1 */
		/* 821BE8B4h case   35:*/		cpu::op::fneg<0>(regs,&regs.FR0,regs.FR1);
		/* 821BE8B4h case   35:*/		return 0x821BE8B8;
		  /* 821BE8B8h */ case   36:  		/* fctidz FR13, FR0 */
		/* 821BE8B8h case   36:*/		cpu::op::fctidz<0>(regs,&regs.FR13,regs.FR0);
		/* 821BE8B8h case   36:*/		return 0x821BE8BC;
		  /* 821BE8BCh */ case   37:  		/* stfd FR13, <#[R1 + 80]> */
		/* 821BE8BCh case   37:*/		cpu::mem::store64f( regs, regs.FR13, (uint32)(regs.R1 + 0x00000050) );
		/* 821BE8BCh case   37:*/		return 0x821BE8C0;
		  /* 821BE8C0h */ case   38:  		/* lwz R28, <#[R1 + 84]> */
		/* 821BE8C0h case   38:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R1 + 0x00000054) );
		/* 821BE8C0h case   38:*/		return 0x821BE8C4;
		  /* 821BE8C4h */ case   39:  		/* mr R11, R28 */
		/* 821BE8C4h case   39:*/		regs.R11 = regs.R28;
		/* 821BE8C4h case   39:*/		return 0x821BE8C8;
		  /* 821BE8C8h */ case   40:  		/* std R28, <#[R1 + 80]> */
		/* 821BE8C8h case   40:*/		cpu::mem::store64( regs, regs.R28, (uint32)(regs.R1 + 0x00000050) );
		/* 821BE8C8h case   40:*/		return 0x821BE8CC;
		  /* 821BE8CCh */ case   41:  		/* lfd FR13, <#[R1 + 80]> */
		/* 821BE8CCh case   41:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000050) );
		/* 821BE8CCh case   41:*/		return 0x821BE8D0;
		  /* 821BE8D0h */ case   42:  		/* fcfid FR13, FR13 */
		/* 821BE8D0h case   42:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 821BE8D0h case   42:*/		return 0x821BE8D4;
		  /* 821BE8D4h */ case   43:  		/* fcmpu CR6, FR13, FR0 */
		/* 821BE8D4h case   43:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 821BE8D4h case   43:*/		return 0x821BE8D8;
		  /* 821BE8D8h */ case   44:  		/* bc 4, CR6_EQ, -196 */
		/* 821BE8D8h case   44:*/		if ( !regs.CR[6].eq ) { return 0x821BE814;  }
		/* 821BE8D8h case   44:*/		return 0x821BE8DC;
	}
	return 0x821BE8DC;
} // Block from 821BE828h-821BE8DCh (45 instructions)

//////////////////////////////////////////////////////
// Block at 821BE8DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE8DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE8DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE8DC);
		  /* 821BE8DCh */ case    0:  		/* lwz R11, <#[R29]> */
		/* 821BE8DCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 821BE8DCh case    0:*/		return 0x821BE8E0;
		  /* 821BE8E0h */ case    1:  		/* mr R31, R29 */
		/* 821BE8E0h case    1:*/		regs.R31 = regs.R29;
		/* 821BE8E0h case    1:*/		return 0x821BE8E4;
		  /* 821BE8E4h */ case    2:  		/* b 28 */
		/* 821BE8E4h case    2:*/		return 0x821BE900;
		/* 821BE8E4h case    2:*/		return 0x821BE8E8;
		  /* 821BE8E8h */ case    3:  		/* lwz R10, <#[R11]> */
		/* 821BE8E8h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821BE8E8h case    3:*/		return 0x821BE8EC;
		  /* 821BE8ECh */ case    4:  		/* cmplw CR6, R28, R10 */
		/* 821BE8ECh case    4:*/		cpu::op::cmplw<6>(regs,regs.R28,regs.R10);
		/* 821BE8ECh case    4:*/		return 0x821BE8F0;
		  /* 821BE8F0h */ case    5:  		/* bc 12, CR6_EQ, -220 */
		/* 821BE8F0h case    5:*/		if ( regs.CR[6].eq ) { return 0x821BE814;  }
		/* 821BE8F0h case    5:*/		return 0x821BE8F4;
		  /* 821BE8F4h */ case    6:  		/* bc 4, CR6_GT, 8 */
		/* 821BE8F4h case    6:*/		if ( !regs.CR[6].gt ) { return 0x821BE8FC;  }
		/* 821BE8F4h case    6:*/		return 0x821BE8F8;
		  /* 821BE8F8h */ case    7:  		/* addi R31, R11, 8 */
		/* 821BE8F8h case    7:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0x8);
		/* 821BE8F8h case    7:*/		return 0x821BE8FC;
	}
	return 0x821BE8FC;
} // Block from 821BE8DCh-821BE8FCh (8 instructions)

//////////////////////////////////////////////////////
// Block at 821BE8FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE8FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE8FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE8FC);
		  /* 821BE8FCh */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 821BE8FCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821BE8FCh case    0:*/		return 0x821BE900;
	}
	return 0x821BE900;
} // Block from 821BE8FCh-821BE900h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BE900h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE900( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE900) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE900);
		  /* 821BE900h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 821BE900h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BE900h case    0:*/		return 0x821BE904;
		  /* 821BE904h */ case    1:  		/* bc 4, CR6_EQ, -28 */
		/* 821BE904h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BE8E8;  }
		/* 821BE904h case    1:*/		return 0x821BE908;
		  /* 821BE908h */ case    2:  		/* lwz R11, <#[R30 + 8]> */
		/* 821BE908h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821BE908h case    2:*/		return 0x821BE90C;
		  /* 821BE90Ch */ case    3:  		/* li R5, 1 */
		/* 821BE90Ch case    3:*/		cpu::op::li<0>(regs,&regs.R5,0x1);
		/* 821BE90Ch case    3:*/		return 0x821BE910;
		  /* 821BE910h */ case    4:  		/* li R4, 12 */
		/* 821BE910h case    4:*/		cpu::op::li<0>(regs,&regs.R4,0xC);
		/* 821BE910h case    4:*/		return 0x821BE914;
		  /* 821BE914h */ case    5:  		/* oris R11, R11, 1024 */
		/* 821BE914h case    5:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x400);
		/* 821BE914h case    5:*/		return 0x821BE918;
	}
	return 0x821BE918;
} // Block from 821BE900h-821BE918h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BE918h
// Function '?CheckArrayLimitInLoop@Compiler@D3DXShader@@AAA_NPAVInstruction@2@PAUConstraint_ArrayLength@2@PAUInductionVariable@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE918( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE918) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE918);
		  /* 821BE918h */ case    0:  		/* mr R3, R25 */
		/* 821BE918h case    0:*/		regs.R3 = regs.R25;
		/* 821BE918h case    0:*/		return 0x821BE91C;
		  /* 821BE91Ch */ case    1:  		/* stw R11, <#[R30 + 8]> */
		/* 821BE91Ch case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821BE91Ch case    1:*/		return 0x821BE920;
		  /* 821BE920h */ case    2:  		/* bl -368688 */
		/* 821BE920h case    2:*/		regs.LR = 0x821BE924; return 0x821648F0;
		/* 821BE920h case    2:*/		return 0x821BE924;
		  /* 821BE924h */ case    3:  		/* stw R28, <#[R3]> */
		/* 821BE924h case    3:*/		cpu::mem::store32( regs, regs.R28, (uint32)(regs.R3 + 0x00000000) );
		/* 821BE924h case    3:*/		return 0x821BE928;
		  /* 821BE928h */ case    4:  		/* stw R30, <#[R3 + 4]> */
		/* 821BE928h case    4:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R3 + 0x00000004) );
		/* 821BE928h case    4:*/		return 0x821BE92C;
		  /* 821BE92Ch */ case    5:  		/* cmplw CR6, R27, R26 */
		/* 821BE92Ch case    5:*/		cpu::op::cmplw<6>(regs,regs.R27,regs.R26);
		/* 821BE92Ch case    5:*/		return 0x821BE930;
		  /* 821BE930h */ case    6:  		/* lwz R11, <#[R31]> */
		/* 821BE930h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821BE930h case    6:*/		return 0x821BE934;
		  /* 821BE934h */ case    7:  		/* stw R11, <#[R3 + 8]> */
		/* 821BE934h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821BE934h case    7:*/		return 0x821BE938;
		  /* 821BE938h */ case    8:  		/* stw R3, <#[R31]> */
		/* 821BE938h case    8:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x00000000) );
		/* 821BE938h case    8:*/		return 0x821BE93C;
		  /* 821BE93Ch */ case    9:  		/* lwz R11, <#[R29 + 4]> */
		/* 821BE93Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 821BE93Ch case    9:*/		return 0x821BE940;
		  /* 821BE940h */ case   10:  		/* addi R11, R11, 1 */
		/* 821BE940h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821BE940h case   10:*/		return 0x821BE944;
		  /* 821BE944h */ case   11:  		/* stw R11, <#[R29 + 4]> */
		/* 821BE944h case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 821BE944h case   11:*/		return 0x821BE948;
		  /* 821BE948h */ case   12:  		/* bc 4, CR6_EQ, 12 */
		/* 821BE948h case   12:*/		if ( !regs.CR[6].eq ) { return 0x821BE954;  }
		/* 821BE948h case   12:*/		return 0x821BE94C;
		  /* 821BE94Ch */ case   13:  		/* lwz R11, <#[R30 + 52]> */
		/* 821BE94Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000034) );
		/* 821BE94Ch case   13:*/		return 0x821BE950;
		  /* 821BE950h */ case   14:  		/* stw R11, <#[R29 + 8]> */
		/* 821BE950h case   14:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 821BE950h case   14:*/		return 0x821BE954;
	}
	return 0x821BE954;
} // Block from 821BE918h-821BE954h (15 instructions)

//////////////////////////////////////////////////////
// Block at 821BE954h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE954( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE954) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE954);
		  /* 821BE954h */ case    0:  		/* lwz R11, <#[R24 + 12]> */
		/* 821BE954h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R24 + 0x0000000C) );
		/* 821BE954h case    0:*/		return 0x821BE958;
		  /* 821BE958h */ case    1:  		/* lwz R11, <#[R11 + 8]> */
		/* 821BE958h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821BE958h case    1:*/		return 0x821BE95C;
		  /* 821BE95Ch */ case    2:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821BE95Ch case    2:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821BE95Ch case    2:*/		return 0x821BE960;
		  /* 821BE960h */ case    3:  		/* cmplwi CR6, R11, 125 */
		/* 821BE960h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007D);
		/* 821BE960h case    3:*/		return 0x821BE964;
		  /* 821BE964h */ case    4:  		/* bc 4, CR6_EQ, 24 */
		/* 821BE964h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821BE97C;  }
		/* 821BE964h case    4:*/		return 0x821BE968;
		  /* 821BE968h */ case    5:  		/* lwz R11, <#[R29 + 12]> */
		/* 821BE968h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 821BE968h case    5:*/		return 0x821BE96C;
		  /* 821BE96Ch */ case    6:  		/* addi R10, R11, 1 */
		/* 821BE96Ch case    6:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x1);
		/* 821BE96Ch case    6:*/		return 0x821BE970;
		  /* 821BE970h */ case    7:  		/* rlwimi R10, R11, 0, 0, 18 */
		/* 821BE970h case    7:*/		cpu::op::rlwimi<0,0,0,18>(regs,&regs.R10,regs.R11);
		/* 821BE970h case    7:*/		return 0x821BE974;
		  /* 821BE974h */ case    8:  		/* stw R10, <#[R29 + 12]> */
		/* 821BE974h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R29 + 0x0000000C) );
		/* 821BE974h case    8:*/		return 0x821BE978;
		  /* 821BE978h */ case    9:  		/* b 32 */
		/* 821BE978h case    9:*/		return 0x821BE998;
		/* 821BE978h case    9:*/		return 0x821BE97C;
	}
	return 0x821BE97C;
} // Block from 821BE954h-821BE97Ch (10 instructions)

//////////////////////////////////////////////////////
// Block at 821BE97Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE97C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE97C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE97C);
		  /* 821BE97Ch */ case    0:  		/* cmplwi CR6, R11, 124 */
		/* 821BE97Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000007C);
		/* 821BE97Ch case    0:*/		return 0x821BE980;
		  /* 821BE980h */ case    1:  		/* bc 4, CR6_EQ, 24 */
		/* 821BE980h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BE998;  }
		/* 821BE980h case    1:*/		return 0x821BE984;
		  /* 821BE984h */ case    2:  		/* lwz R10, <#[R29 + 12]> */
		/* 821BE984h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x0000000C) );
		/* 821BE984h case    2:*/		return 0x821BE988;
		  /* 821BE988h */ case    3:  		/* rlwinm R11, R10, 0, 0, 18 */
		/* 821BE988h case    3:*/		cpu::op::rlwinm<0,0,0,18>(regs,&regs.R11,regs.R10);
		/* 821BE988h case    3:*/		return 0x821BE98C;
		  /* 821BE98Ch */ case    4:  		/* addi R11, R11, 8192 */
		/* 821BE98Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2000);
		/* 821BE98Ch case    4:*/		return 0x821BE990;
		  /* 821BE990h */ case    5:  		/* rlwimi R11, R10, 0, 19, 5 */
		/* 821BE990h case    5:*/		cpu::op::rlwimi<0,0,19,5>(regs,&regs.R11,regs.R10);
		/* 821BE990h case    5:*/		return 0x821BE994;
		  /* 821BE994h */ case    6:  		/* stw R11, <#[R29 + 12]> */
		/* 821BE994h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R29 + 0x0000000C) );
		/* 821BE994h case    6:*/		return 0x821BE998;
	}
	return 0x821BE998;
} // Block from 821BE97Ch-821BE998h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BE998h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE998( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE998) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE998);
		  /* 821BE998h */ case    0:  		/* addi R1, R1, 160 */
		/* 821BE998h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 821BE998h case    0:*/		return 0x821BE99C;
		  /* 821BE99Ch */ case    1:  		/* b -1234692 */
		/* 821BE99Ch case    1:*/		return 0x82091298;
		/* 821BE99Ch case    1:*/		return 0x821BE9A0;
	}
	return 0x821BE9A0;
} // Block from 821BE998h-821BE9A0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BE9A0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BE9A0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BE9A0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BE9A0);
		  /* 821BE9A0h */ case    0:  		/* mfspr R12, LR */
		/* 821BE9A0h case    0:*/		regs.R12 = regs.LR;
		/* 821BE9A0h case    0:*/		return 0x821BE9A4;
		  /* 821BE9A4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821BE9A4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821BE9A4h case    1:*/		return 0x821BE9A8;
		  /* 821BE9A8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 821BE9A8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821BE9A8h case    2:*/		return 0x821BE9AC;
		  /* 821BE9ACh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 821BE9ACh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821BE9ACh case    3:*/		return 0x821BE9B0;
		  /* 821BE9B0h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 821BE9B0h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821BE9B0h case    4:*/		return 0x821BE9B4;
		  /* 821BE9B4h */ case    5:  		/* mr R30, R5 */
		/* 821BE9B4h case    5:*/		regs.R30 = regs.R5;
		/* 821BE9B4h case    5:*/		return 0x821BE9B8;
		  /* 821BE9B8h */ case    6:  		/* lwz R5, <#[R4 + 12]> */
		/* 821BE9B8h case    6:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R4 + 0x0000000C) );
		/* 821BE9B8h case    6:*/		return 0x821BE9BC;
		  /* 821BE9BCh */ case    7:  		/* mr R31, R4 */
		/* 821BE9BCh case    7:*/		regs.R31 = regs.R4;
		/* 821BE9BCh case    7:*/		return 0x821BE9C0;
		  /* 821BE9C0h */ case    8:  		/* bl -317648 */
		/* 821BE9C0h case    8:*/		regs.LR = 0x821BE9C4; return 0x821710F0;
		/* 821BE9C0h case    8:*/		return 0x821BE9C4;
		  /* 821BE9C4h */ case    9:  		/* lwz R8, <#[R3]> */
		/* 821BE9C4h case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R3 + 0x00000000) );
		/* 821BE9C4h case    9:*/		return 0x821BE9C8;
		  /* 821BE9C8h */ case   10:  		/* li R11, 1 */
		/* 821BE9C8h case   10:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821BE9C8h case   10:*/		return 0x821BE9CC;
		  /* 821BE9CCh */ case   11:  		/* rlwinm R10, R30, 1, 0, 30 */
		/* 821BE9CCh case   11:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R30);
		/* 821BE9CCh case   11:*/		return 0x821BE9D0;
		  /* 821BE9D0h */ case   12:  		/* rlwimi R8, R11, 25, 4, 6 */
		/* 821BE9D0h case   12:*/		cpu::op::rlwimi<0,25,4,6>(regs,&regs.R8,regs.R11);
		/* 821BE9D0h case   12:*/		return 0x821BE9D4;
		  /* 821BE9D4h */ case   13:  		/* li R9, 7296 */
		/* 821BE9D4h case   13:*/		cpu::op::li<0>(regs,&regs.R9,0x1C80);
		/* 821BE9D4h case   13:*/		return 0x821BE9D8;
		  /* 821BE9D8h */ case   14:  		/* stw R8, <#[R3]> */
		/* 821BE9D8h case   14:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R3 + 0x00000000) );
		/* 821BE9D8h case   14:*/		return 0x821BE9DC;
		  /* 821BE9DCh */ case   15:  		/* rlwinm R11, R8, 0, 27, 24 */
		/* 821BE9DCh case   15:*/		cpu::op::rlwinm<0,0,27,24>(regs,&regs.R11,regs.R8);
		/* 821BE9DCh case   15:*/		return 0x821BE9E0;
		  /* 821BE9E0h */ case   16:  		/* lwz R8, <#[R31]> */
		/* 821BE9E0h case   16:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R31 + 0x00000000) );
		/* 821BE9E0h case   16:*/		return 0x821BE9E4;
		  /* 821BE9E4h */ case   17:  		/* rlwinm R8, R8, 27, 24, 31 */
		/* 821BE9E4h case   17:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R8,regs.R8);
		/* 821BE9E4h case   17:*/		return 0x821BE9E8;
		  /* 821BE9E8h */ case   18:  		/* srw R10, R8, R10 */
		/* 821BE9E8h case   18:*/		cpu::op::srw<0>(regs,&regs.R10,regs.R8,regs.R10);
		/* 821BE9E8h case   18:*/		return 0x821BE9EC;
		  /* 821BE9ECh */ case   19:  		/* rlwinm R11, R11, 0, 24, 21 */
		/* 821BE9ECh case   19:*/		cpu::op::rlwinm<0,0,24,21>(regs,&regs.R11,regs.R11);
		/* 821BE9ECh case   19:*/		return 0x821BE9F0;
		  /* 821BE9F0h */ case   20:  		/* rlwimi R9, R10, 5, 25, 26 */
		/* 821BE9F0h case   20:*/		cpu::op::rlwimi<0,5,25,26>(regs,&regs.R9,regs.R10);
		/* 821BE9F0h case   20:*/		return 0x821BE9F4;
		  /* 821BE9F4h */ case   21:  		/* or R11, R9, R11 */
		/* 821BE9F4h case   21:*/		cpu::op::or<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 821BE9F4h case   21:*/		return 0x821BE9F8;
		  /* 821BE9F8h */ case   22:  		/* stw R11, <#[R3]> */
		/* 821BE9F8h case   22:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821BE9F8h case   22:*/		return 0x821BE9FC;
		  /* 821BE9FCh */ case   23:  		/* addi R1, R1, 112 */
		/* 821BE9FCh case   23:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821BE9FCh case   23:*/		return 0x821BEA00;
		  /* 821BEA00h */ case   24:  		/* lwz R12, <#[R1 - 8]> */
		/* 821BEA00h case   24:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821BEA00h case   24:*/		return 0x821BEA04;
		  /* 821BEA04h */ case   25:  		/* mtspr LR, R12 */
		/* 821BEA04h case   25:*/		regs.LR = regs.R12;
		/* 821BEA04h case   25:*/		return 0x821BEA08;
		  /* 821BEA08h */ case   26:  		/* ld R30, <#[R1 - 24]> */
		/* 821BEA08h case   26:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821BEA08h case   26:*/		return 0x821BEA0C;
		  /* 821BEA0Ch */ case   27:  		/* ld R31, <#[R1 - 16]> */
		/* 821BEA0Ch case   27:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821BEA0Ch case   27:*/		return 0x821BEA10;
		  /* 821BEA10h */ case   28:  		/* bclr 20, CR0_LT */
		/* 821BEA10h case   28:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BEA10h case   28:*/		return 0x821BEA14;
	}
	return 0x821BEA14;
} // Block from 821BE9A0h-821BEA14h (29 instructions)

//////////////////////////////////////////////////////
// Block at 821BEA14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BEA14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BEA14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BEA14);
		  /* 821BEA14h */ case    0:  		/* nop */
		/* 821BEA14h case    0:*/		cpu::op::nop();
		/* 821BEA14h case    0:*/		return 0x821BEA18;
	}
	return 0x821BEA18;
} // Block from 821BEA14h-821BEA18h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BEA18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BEA18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BEA18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BEA18);
		  /* 821BEA18h */ case    0:  		/* mfspr R12, LR */
		/* 821BEA18h case    0:*/		regs.R12 = regs.LR;
		/* 821BEA18h case    0:*/		return 0x821BEA1C;
		  /* 821BEA1Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821BEA1Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821BEA1Ch case    1:*/		return 0x821BEA20;
		  /* 821BEA20h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 821BEA20h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821BEA20h case    2:*/		return 0x821BEA24;
		  /* 821BEA24h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 821BEA24h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821BEA24h case    3:*/		return 0x821BEA28;
		  /* 821BEA28h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 821BEA28h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821BEA28h case    4:*/		return 0x821BEA2C;
		  /* 821BEA2Ch */ case    5:  		/* mr R31, R3 */
		/* 821BEA2Ch case    5:*/		regs.R31 = regs.R3;
		/* 821BEA2Ch case    5:*/		return 0x821BEA30;
		  /* 821BEA30h */ case    6:  		/* mr R30, R4 */
		/* 821BEA30h case    6:*/		regs.R30 = regs.R4;
		/* 821BEA30h case    6:*/		return 0x821BEA34;
		  /* 821BEA34h */ case    7:  		/* b 52 */
		/* 821BEA34h case    7:*/		return 0x821BEA68;
		/* 821BEA34h case    7:*/		return 0x821BEA38;
	}
	return 0x821BEA38;
} // Block from 821BEA18h-821BEA38h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821BEA38h
// Function '?ExamineLoopInvariantTest@Compiler@D3DXShader@@AAA?AW4ExamineLoopInvariantTestDisposition@12@PAUInductionVariable@2@_NPAVDependency@2@PAVInstruction@2@W4Component@2@IW4_D3DEXPR_OP@2@234IPAPAUInvariantCondition@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BEA38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BEA38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BEA38);
		  /* 821BEA38h */ case    0:  		/* lwz R3, <#[R4 + 16]> */
		/* 821BEA38h case    0:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R4 + 0x00000010) );
		/* 821BEA38h case    0:*/		return 0x821BEA3C;
		  /* 821BEA3Ch */ case    1:  		/* cmplwi CR6, R3, 0 */
		/* 821BEA3Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 821BEA3Ch case    1:*/		return 0x821BEA40;
		  /* 821BEA40h */ case    2:  		/* bc 12, CR6_EQ, 16 */
		/* 821BEA40h case    2:*/		if ( regs.CR[6].eq ) { return 0x821BEA50;  }
		/* 821BEA40h case    2:*/		return 0x821BEA44;
		  /* 821BEA44h */ case    3:  		/* mr R5, R30 */
		/* 821BEA44h case    3:*/		regs.R5 = regs.R30;
		/* 821BEA44h case    3:*/		return 0x821BEA48;
		  /* 821BEA48h */ case    4:  		/* bl -287032 */
		/* 821BEA48h case    4:*/		regs.LR = 0x821BEA4C; return 0x82178910;
		/* 821BEA48h case    4:*/		return 0x821BEA4C;
		  /* 821BEA4Ch */ case    5:  		/* b 28 */
		/* 821BEA4Ch case    5:*/		return 0x821BEA68;
		/* 821BEA4Ch case    5:*/		return 0x821BEA50;
	}
	return 0x821BEA50;
} // Block from 821BEA38h-821BEA50h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BEA50h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BEA50( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BEA50) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BEA50);
		  /* 821BEA50h */ case    0:  		/* lwz R11, <#[R4 + 8]> */
		/* 821BEA50h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821BEA50h case    0:*/		return 0x821BEA54;
		  /* 821BEA54h */ case    1:  		/* li R6, 26 */
		/* 821BEA54h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x1A);
		/* 821BEA54h case    1:*/		return 0x821BEA58;
		  /* 821BEA58h */ case    2:  		/* li R5, 20 */
		/* 821BEA58h case    2:*/		cpu::op::li<0>(regs,&regs.R5,0x14);
		/* 821BEA58h case    2:*/		return 0x821BEA5C;
		  /* 821BEA5Ch */ case    3:  		/* mr R3, R30 */
		/* 821BEA5Ch case    3:*/		regs.R3 = regs.R30;
		/* 821BEA5Ch case    3:*/		return 0x821BEA60;
		  /* 821BEA60h */ case    4:  		/* stw R11, <#[R31 + 4]> */
		/* 821BEA60h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 821BEA60h case    4:*/		return 0x821BEA64;
		  /* 821BEA64h */ case    5:  		/* bl -368076 */
		/* 821BEA64h case    5:*/		regs.LR = 0x821BEA68; return 0x82164C98;
		/* 821BEA64h case    5:*/		return 0x821BEA68;
	}
	return 0x821BEA68;
} // Block from 821BEA50h-821BEA68h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BEA68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BEA68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BEA68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BEA68);
		  /* 821BEA68h */ case    0:  		/* lwz R4, <#[R31 + 4]> */
		/* 821BEA68h case    0:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000004) );
		/* 821BEA68h case    0:*/		return 0x821BEA6C;
		  /* 821BEA6Ch */ case    1:  		/* cmplwi CR6, R4, 0 */
		/* 821BEA6Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R4,0x00000000);
		/* 821BEA6Ch case    1:*/		return 0x821BEA70;
		  /* 821BEA70h */ case    2:  		/* bc 4, CR6_EQ, -56 */
		/* 821BEA70h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821BEA38;  }
		/* 821BEA70h case    2:*/		return 0x821BEA74;
		  /* 821BEA74h */ case    3:  		/* addi R1, R1, 112 */
		/* 821BEA74h case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821BEA74h case    3:*/		return 0x821BEA78;
		  /* 821BEA78h */ case    4:  		/* lwz R12, <#[R1 - 8]> */
		/* 821BEA78h case    4:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821BEA78h case    4:*/		return 0x821BEA7C;
		  /* 821BEA7Ch */ case    5:  		/* mtspr LR, R12 */
		/* 821BEA7Ch case    5:*/		regs.LR = regs.R12;
		/* 821BEA7Ch case    5:*/		return 0x821BEA80;
		  /* 821BEA80h */ case    6:  		/* ld R30, <#[R1 - 24]> */
		/* 821BEA80h case    6:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821BEA80h case    6:*/		return 0x821BEA84;
		  /* 821BEA84h */ case    7:  		/* ld R31, <#[R1 - 16]> */
		/* 821BEA84h case    7:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821BEA84h case    7:*/		return 0x821BEA88;
		  /* 821BEA88h */ case    8:  		/* bclr 20, CR0_LT */
		/* 821BEA88h case    8:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BEA88h case    8:*/		return 0x821BEA8C;
	}
	return 0x821BEA8C;
} // Block from 821BEA68h-821BEA8Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 821BEA8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BEA8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BEA8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BEA8C);
		  /* 821BEA8Ch */ case    0:  		/* nop */
		/* 821BEA8Ch case    0:*/		cpu::op::nop();
		/* 821BEA8Ch case    0:*/		return 0x821BEA90;
	}
	return 0x821BEA90;
} // Block from 821BEA8Ch-821BEA90h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BEA90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BEA90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BEA90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BEA90);
		  /* 821BEA90h */ case    0:  		/* mfspr R12, LR */
		/* 821BEA90h case    0:*/		regs.R12 = regs.LR;
		/* 821BEA90h case    0:*/		return 0x821BEA94;
		  /* 821BEA94h */ case    1:  		/* bl -1235020 */
		/* 821BEA94h case    1:*/		regs.LR = 0x821BEA98; return 0x82091248;
		/* 821BEA94h case    1:*/		return 0x821BEA98;
		  /* 821BEA98h */ case    2:  		/* stwu R1, <#[R1 - 192]> */
		/* 821BEA98h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF40) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF40);
		/* 821BEA98h case    2:*/		return 0x821BEA9C;
		  /* 821BEA9Ch */ case    3:  		/* lwz R11, <#[R4 + 20]> */
		/* 821BEA9Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000014) );
		/* 821BEA9Ch case    3:*/		return 0x821BEAA0;
		  /* 821BEAA0h */ case    4:  		/* mr R26, R3 */
		/* 821BEAA0h case    4:*/		regs.R26 = regs.R3;
		/* 821BEAA0h case    4:*/		return 0x821BEAA4;
		  /* 821BEAA4h */ case    5:  		/* mr R25, R4 */
		/* 821BEAA4h case    5:*/		regs.R25 = regs.R4;
		/* 821BEAA4h case    5:*/		return 0x821BEAA8;
		  /* 821BEAA8h */ case    6:  		/* mr R24, R5 */
		/* 821BEAA8h case    6:*/		regs.R24 = regs.R5;
		/* 821BEAA8h case    6:*/		return 0x821BEAAC;
		  /* 821BEAACh */ case    7:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BEAACh case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BEAACh case    7:*/		return 0x821BEAB0;
		  /* 821BEAB0h */ case    8:  		/* bc 4, CR0_EQ, 284 */
		/* 821BEAB0h case    8:*/		if ( !regs.CR[0].eq ) { return 0x821BEBCC;  }
		/* 821BEAB0h case    8:*/		return 0x821BEAB4;
		  /* 821BEAB4h */ case    9:  		/* mr R29, R11 */
		/* 821BEAB4h case    9:*/		regs.R29 = regs.R11;
		/* 821BEAB4h case    9:*/		return 0x821BEAB8;
		  /* 821BEAB8h */ case   10:  		/* cmplwi CR0, R11, 0 */
		/* 821BEAB8h case   10:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821BEAB8h case   10:*/		return 0x821BEABC;
		  /* 821BEABCh */ case   11:  		/* bc 12, CR0_EQ, 272 */
		/* 821BEABCh case   11:*/		if ( regs.CR[0].eq ) { return 0x821BEBCC;  }
		/* 821BEABCh case   11:*/		return 0x821BEAC0;
		  /* 821BEAC0h */ case   12:  		/* li R27, 0 */
		/* 821BEAC0h case   12:*/		cpu::op::li<0>(regs,&regs.R27,0x0);
		/* 821BEAC0h case   12:*/		return 0x821BEAC4;
		  /* 821BEAC4h */ case   13:  		/* lwz R11, <#[R29 + 8]> */
		/* 821BEAC4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000008) );
		/* 821BEAC4h case   13:*/		return 0x821BEAC8;
		  /* 821BEAC8h */ case   14:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821BEAC8h case   14:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821BEAC8h case   14:*/		return 0x821BEACC;
		  /* 821BEACCh */ case   15:  		/* cmplwi CR6, R11, 14336 */
		/* 821BEACCh case   15:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003800);
		/* 821BEACCh case   15:*/		return 0x821BEAD0;
		  /* 821BEAD0h */ case   16:  		/* bc 4, CR6_EQ, 224 */
		/* 821BEAD0h case   16:*/		if ( !regs.CR[6].eq ) { return 0x821BEBB0;  }
		/* 821BEAD0h case   16:*/		return 0x821BEAD4;
		  /* 821BEAD4h */ case   17:  		/* lwz R11, <#[R29]> */
		/* 821BEAD4h case   17:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 821BEAD4h case   17:*/		return 0x821BEAD8;
		  /* 821BEAD8h */ case   18:  		/* cmplwi CR6, R11, 0 */
		/* 821BEAD8h case   18:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BEAD8h case   18:*/		return 0x821BEADC;
		  /* 821BEADCh */ case   19:  		/* bc 12, CR6_EQ, 20 */
		/* 821BEADCh case   19:*/		if ( regs.CR[6].eq ) { return 0x821BEAF0;  }
		/* 821BEADCh case   19:*/		return 0x821BEAE0;
		  /* 821BEAE0h */ case   20:  		/* lwz R11, <#[R11 + 4]> */
		/* 821BEAE0h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821BEAE0h case   20:*/		return 0x821BEAE4;
		  /* 821BEAE4h */ case   21:  		/* cmplwi CR6, R11, 0 */
		/* 821BEAE4h case   21:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BEAE4h case   21:*/		return 0x821BEAE8;
		  /* 821BEAE8h */ case   22:  		/* li R11, 1 */
		/* 821BEAE8h case   22:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821BEAE8h case   22:*/		return 0x821BEAEC;
		  /* 821BEAECh */ case   23:  		/* bc 4, CR6_EQ, 8 */
		/* 821BEAECh case   23:*/		if ( !regs.CR[6].eq ) { return 0x821BEAF4;  }
		/* 821BEAECh case   23:*/		return 0x821BEAF0;
	}
	return 0x821BEAF0;
} // Block from 821BEA90h-821BEAF0h (24 instructions)

//////////////////////////////////////////////////////
// Block at 821BEAF0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BEAF0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BEAF0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BEAF0);
		  /* 821BEAF0h */ case    0:  		/* mr R11, R27 */
		/* 821BEAF0h case    0:*/		regs.R11 = regs.R27;
		/* 821BEAF0h case    0:*/		return 0x821BEAF4;
	}
	return 0x821BEAF4;
} // Block from 821BEAF0h-821BEAF4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BEAF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BEAF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BEAF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BEAF4);
		  /* 821BEAF4h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821BEAF4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821BEAF4h case    0:*/		return 0x821BEAF8;
		  /* 821BEAF8h */ case    1:  		/* bc 12, CR0_EQ, 184 */
		/* 821BEAF8h case    1:*/		if ( regs.CR[0].eq ) { return 0x821BEBB0;  }
		/* 821BEAF8h case    1:*/		return 0x821BEAFC;
		  /* 821BEAFCh */ case    2:  		/* lbz R11, <#[R24]> */
		/* 821BEAFCh case    2:*/		cpu::mem::load8z( regs, &regs.R11, (uint32)(regs.R24 + 0x00000000) );
		/* 821BEAFCh case    2:*/		return 0x821BEB00;
		  /* 821BEB00h */ case    3:  		/* cmplwi CR0, R11, 0 */
		/* 821BEB00h case    3:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821BEB00h case    3:*/		return 0x821BEB04;
		  /* 821BEB04h */ case    4:  		/* bc 12, CR0_EQ, 16 */
		/* 821BEB04h case    4:*/		if ( regs.CR[0].eq ) { return 0x821BEB14;  }
		/* 821BEB04h case    4:*/		return 0x821BEB08;
		  /* 821BEB08h */ case    5:  		/* mr R3, R26 */
		/* 821BEB08h case    5:*/		regs.R3 = regs.R26;
		/* 821BEB08h case    5:*/		return 0x821BEB0C;
		  /* 821BEB0Ch */ case    6:  		/* bl 182292 */
		/* 821BEB0Ch case    6:*/		regs.LR = 0x821BEB10; return 0x821EB320;
		/* 821BEB0Ch case    6:*/		return 0x821BEB10;
		  /* 821BEB10h */ case    7:  		/* stb R27, <#[R24]> */
		/* 821BEB10h case    7:*/		cpu::mem::store8( regs, regs.R27, (uint32)(regs.R24 + 0x00000000) );
		/* 821BEB10h case    7:*/		return 0x821BEB14;
	}
	return 0x821BEB14;
} // Block from 821BEAF4h-821BEB14h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821BEB14h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BEB14( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BEB14) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BEB14);
		  /* 821BEB14h */ case    0:  		/* mr R28, R29 */
		/* 821BEB14h case    0:*/		regs.R28 = regs.R29;
		/* 821BEB14h case    0:*/		return 0x821BEB18;
		  /* 821BEB18h */ case    1:  		/* lwz R30, <#[R28]> */
		/* 821BEB18h case    1:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R28 + 0x00000000) );
		/* 821BEB18h case    1:*/		return 0x821BEB1C;
		  /* 821BEB1Ch */ case    2:  		/* cmplwi CR6, R30, 0 */
		/* 821BEB1Ch case    2:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821BEB1Ch case    2:*/		return 0x821BEB20;
		  /* 821BEB20h */ case    3:  		/* bc 12, CR6_EQ, 144 */
		/* 821BEB20h case    3:*/		if ( regs.CR[6].eq ) { return 0x821BEBB0;  }
		/* 821BEB20h case    3:*/		return 0x821BEB24;
		  /* 821BEB24h */ case    4:  		/* stw R25, <#[R1 + 80]> */
		/* 821BEB24h case    4:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R1 + 0x00000050) );
		/* 821BEB24h case    4:*/		return 0x821BEB28;
		  /* 821BEB28h */ case    5:  		/* addi R3, R1, 80 */
		/* 821BEB28h case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 821BEB28h case    5:*/		return 0x821BEB2C;
		  /* 821BEB2Ch */ case    6:  		/* stw R27, <#[R1 + 88]> */
		/* 821BEB2Ch case    6:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000058) );
		/* 821BEB2Ch case    6:*/		return 0x821BEB30;
		  /* 821BEB30h */ case    7:  		/* stw R27, <#[R1 + 96]> */
		/* 821BEB30h case    7:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000060) );
		/* 821BEB30h case    7:*/		return 0x821BEB34;
		  /* 821BEB34h */ case    8:  		/* stw R27, <#[R1 + 100]> */
		/* 821BEB34h case    8:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R1 + 0x00000064) );
		/* 821BEB34h case    8:*/		return 0x821BEB38;
		  /* 821BEB38h */ case    9:  		/* stb R27, <#[R1 + 104]> */
		/* 821BEB38h case    9:*/		cpu::mem::store8( regs, regs.R27, (uint32)(regs.R1 + 0x00000068) );
		/* 821BEB38h case    9:*/		return 0x821BEB3C;
		  /* 821BEB3Ch */ case   10:  		/* lwz R4, <#[R25 + 8]> */
		/* 821BEB3Ch case   10:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R25 + 0x00000008) );
		/* 821BEB3Ch case   10:*/		return 0x821BEB40;
		  /* 821BEB40h */ case   11:  		/* bl 462464 */
		/* 821BEB40h case   11:*/		regs.LR = 0x821BEB44; return 0x8222F9C0;
		/* 821BEB40h case   11:*/		return 0x821BEB44;
		  /* 821BEB44h */ case   12:  		/* addi R3, R1, 80 */
		/* 821BEB44h case   12:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 821BEB44h case   12:*/		return 0x821BEB48;
		  /* 821BEB48h */ case   13:  		/* bl -335944 */
		/* 821BEB48h case   13:*/		regs.LR = 0x821BEB4C; return 0x8216CB00;
		/* 821BEB48h case   13:*/		return 0x821BEB4C;
		  /* 821BEB4Ch */ case   14:  		/* or. R31, R3, R3 */
		/* 821BEB4Ch case   14:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 821BEB4Ch case   14:*/		return 0x821BEB50;
		  /* 821BEB50h */ case   15:  		/* bc 12, CR0_EQ, 60 */
		/* 821BEB50h case   15:*/		if ( regs.CR[0].eq ) { return 0x821BEB8C;  }
		/* 821BEB50h case   15:*/		return 0x821BEB54;
		  /* 821BEB54h */ case   16:  		/* li R7, 1 */
		/* 821BEB54h case   16:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821BEB54h case   16:*/		return 0x821BEB58;
		  /* 821BEB58h */ case   17:  		/* li R6, 0 */
		/* 821BEB58h case   17:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821BEB58h case   17:*/		return 0x821BEB5C;
		  /* 821BEB5Ch */ case   18:  		/* mr R5, R31 */
		/* 821BEB5Ch case   18:*/		regs.R5 = regs.R31;
		/* 821BEB5Ch case   18:*/		return 0x821BEB60;
		  /* 821BEB60h */ case   19:  		/* mr R4, R29 */
		/* 821BEB60h case   19:*/		regs.R4 = regs.R29;
		/* 821BEB60h case   19:*/		return 0x821BEB64;
		  /* 821BEB64h */ case   20:  		/* mr R3, R26 */
		/* 821BEB64h case   20:*/		regs.R3 = regs.R26;
		/* 821BEB64h case   20:*/		return 0x821BEB68;
		  /* 821BEB68h */ case   21:  		/* bl 170392 */
		/* 821BEB68h case   21:*/		regs.LR = 0x821BEB6C; return 0x821E8500;
		/* 821BEB68h case   21:*/		return 0x821BEB6C;
		  /* 821BEB6Ch */ case   22:  		/* cmplw CR6, R3, R30 */
		/* 821BEB6Ch case   22:*/		cpu::op::cmplw<6>(regs,regs.R3,regs.R30);
		/* 821BEB6Ch case   22:*/		return 0x821BEB70;
		  /* 821BEB70h */ case   23:  		/* bc 12, CR6_EQ, 20 */
		/* 821BEB70h case   23:*/		if ( regs.CR[6].eq ) { return 0x821BEB84;  }
		/* 821BEB70h case   23:*/		return 0x821BEB74;
		  /* 821BEB74h */ case   24:  		/* addi R3, R1, 80 */
		/* 821BEB74h case   24:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 821BEB74h case   24:*/		return 0x821BEB78;
		  /* 821BEB78h */ case   25:  		/* bl -335992 */
		/* 821BEB78h case   25:*/		regs.LR = 0x821BEB7C; return 0x8216CB00;
		/* 821BEB78h case   25:*/		return 0x821BEB7C;
		  /* 821BEB7Ch */ case   26:  		/* or. R31, R3, R3 */
		/* 821BEB7Ch case   26:*/		cpu::op::or<1>(regs,&regs.R31,regs.R3,regs.R3);
		/* 821BEB7Ch case   26:*/		return 0x821BEB80;
		  /* 821BEB80h */ case   27:  		/* bc 4, CR0_EQ, -44 */
		/* 821BEB80h case   27:*/		if ( !regs.CR[0].eq ) { return 0x821BEB54;  }
		/* 821BEB80h case   27:*/		return 0x821BEB84;
	}
	return 0x821BEB84;
} // Block from 821BEB14h-821BEB84h (28 instructions)

//////////////////////////////////////////////////////
// Block at 821BEB84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BEB84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BEB84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BEB84);
		  /* 821BEB84h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 821BEB84h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821BEB84h case    0:*/		return 0x821BEB88;
		  /* 821BEB88h */ case    1:  		/* bc 4, CR6_EQ, 20 */
		/* 821BEB88h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BEB9C;  }
		/* 821BEB88h case    1:*/		return 0x821BEB8C;
	}
	return 0x821BEB8C;
} // Block from 821BEB84h-821BEB8Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BEB8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BEB8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BEB8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BEB8C);
		  /* 821BEB8Ch */ case    0:  		/* mr R5, R26 */
		/* 821BEB8Ch case    0:*/		regs.R5 = regs.R26;
		/* 821BEB8Ch case    0:*/		return 0x821BEB90;
		  /* 821BEB90h */ case    1:  		/* mr R4, R30 */
		/* 821BEB90h case    1:*/		regs.R4 = regs.R30;
		/* 821BEB90h case    1:*/		return 0x821BEB94;
		  /* 821BEB94h */ case    2:  		/* mr R3, R29 */
		/* 821BEB94h case    2:*/		regs.R3 = regs.R29;
		/* 821BEB94h case    2:*/		return 0x821BEB98;
		  /* 821BEB98h */ case    3:  		/* bl -287368 */
		/* 821BEB98h case    3:*/		regs.LR = 0x821BEB9C; return 0x82178910;
		/* 821BEB98h case    3:*/		return 0x821BEB9C;
	}
	return 0x821BEB9C;
} // Block from 821BEB8Ch-821BEB9Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BEB9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BEB9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BEB9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BEB9C);
		  /* 821BEB9Ch */ case    0:  		/* lwz R11, <#[R28]> */
		/* 821BEB9Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 821BEB9Ch case    0:*/		return 0x821BEBA0;
		  /* 821BEBA0h */ case    1:  		/* cmplw CR6, R11, R30 */
		/* 821BEBA0h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 821BEBA0h case    1:*/		return 0x821BEBA4;
		  /* 821BEBA4h */ case    2:  		/* bc 4, CR6_EQ, -140 */
		/* 821BEBA4h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821BEB18;  }
		/* 821BEBA4h case    2:*/		return 0x821BEBA8;
		  /* 821BEBA8h */ case    3:  		/* addi R28, R30, 4 */
		/* 821BEBA8h case    3:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R30,0x4);
		/* 821BEBA8h case    3:*/		return 0x821BEBAC;
		  /* 821BEBACh */ case    4:  		/* b -148 */
		/* 821BEBACh case    4:*/		return 0x821BEB18;
		/* 821BEBACh case    4:*/		return 0x821BEBB0;
	}
	return 0x821BEBB0;
} // Block from 821BEB9Ch-821BEBB0h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BEBB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BEBB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BEBB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BEBB0);
		  /* 821BEBB0h */ case    0:  		/* rlwinm R11, R29, 0, 0, 30 */
		/* 821BEBB0h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R29);
		/* 821BEBB0h case    0:*/		return 0x821BEBB4;
		  /* 821BEBB4h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 821BEBB4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 821BEBB4h case    1:*/		return 0x821BEBB8;
		  /* 821BEBB8h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BEBB8h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BEBB8h case    2:*/		return 0x821BEBBC;
		  /* 821BEBBCh */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 821BEBBCh case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BEBCC;  }
		/* 821BEBBCh case    3:*/		return 0x821BEBC0;
		  /* 821BEBC0h */ case    4:  		/* mr R29, R11 */
		/* 821BEBC0h case    4:*/		regs.R29 = regs.R11;
		/* 821BEBC0h case    4:*/		return 0x821BEBC4;
		  /* 821BEBC4h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821BEBC4h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BEBC4h case    5:*/		return 0x821BEBC8;
		  /* 821BEBC8h */ case    6:  		/* bc 4, CR6_EQ, -260 */
		/* 821BEBC8h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821BEAC4;  }
		/* 821BEBC8h case    6:*/		return 0x821BEBCC;
	}
	return 0x821BEBCC;
} // Block from 821BEBB0h-821BEBCCh (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BEBCCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BEBCC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BEBCC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BEBCC);
		  /* 821BEBCCh */ case    0:  		/* addi R1, R1, 192 */
		/* 821BEBCCh case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xC0);
		/* 821BEBCCh case    0:*/		return 0x821BEBD0;
		  /* 821BEBD0h */ case    1:  		/* b -1235256 */
		/* 821BEBD0h case    1:*/		return 0x82091298;
		/* 821BEBD0h case    1:*/		return 0x821BEBD4;
		  /* 821BEBD4h */ case    2:  		/* nop */
		/* 821BEBD4h case    2:*/		cpu::op::nop();
		/* 821BEBD4h case    2:*/		return 0x821BEBD8;
	}
	return 0x821BEBD8;
} // Block from 821BEBCCh-821BEBD8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BEBD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BEBD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BEBD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BEBD8);
		  /* 821BEBD8h */ case    0:  		/* mfspr R12, LR */
		/* 821BEBD8h case    0:*/		regs.R12 = regs.LR;
		/* 821BEBD8h case    0:*/		return 0x821BEBDC;
		  /* 821BEBDCh */ case    1:  		/* bl -1235344 */
		/* 821BEBDCh case    1:*/		regs.LR = 0x821BEBE0; return 0x8209124C;
		/* 821BEBDCh case    1:*/		return 0x821BEBE0;
		  /* 821BEBE0h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 821BEBE0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 821BEBE0h case    2:*/		return 0x821BEBE4;
		  /* 821BEBE4h */ case    3:  		/* lwz R11, <#[R4 + 20]> */
		/* 821BEBE4h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000014) );
		/* 821BEBE4h case    3:*/		return 0x821BEBE8;
		  /* 821BEBE8h */ case    4:  		/* mr R27, R3 */
		/* 821BEBE8h case    4:*/		regs.R27 = regs.R3;
		/* 821BEBE8h case    4:*/		return 0x821BEBEC;
		  /* 821BEBECh */ case    5:  		/* mr R25, R4 */
		/* 821BEBECh case    5:*/		regs.R25 = regs.R4;
		/* 821BEBECh case    5:*/		return 0x821BEBF0;
		  /* 821BEBF0h */ case    6:  		/* mr R26, R5 */
		/* 821BEBF0h case    6:*/		regs.R26 = regs.R5;
		/* 821BEBF0h case    6:*/		return 0x821BEBF4;
		  /* 821BEBF4h */ case    7:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BEBF4h case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BEBF4h case    7:*/		return 0x821BEBF8;
		  /* 821BEBF8h */ case    8:  		/* bc 4, CR0_EQ, 176 */
		/* 821BEBF8h case    8:*/		if ( !regs.CR[0].eq ) { return 0x821BECA8;  }
		/* 821BEBF8h case    8:*/		return 0x821BEBFC;
		  /* 821BEBFCh */ case    9:  		/* mr R30, R11 */
		/* 821BEBFCh case    9:*/		regs.R30 = regs.R11;
		/* 821BEBFCh case    9:*/		return 0x821BEC00;
		  /* 821BEC00h */ case   10:  		/* cmplwi CR0, R11, 0 */
		/* 821BEC00h case   10:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821BEC00h case   10:*/		return 0x821BEC04;
		  /* 821BEC04h */ case   11:  		/* bc 12, CR0_EQ, 164 */
		/* 821BEC04h case   11:*/		if ( regs.CR[0].eq ) { return 0x821BECA8;  }
		/* 821BEC04h case   11:*/		return 0x821BEC08;
		  /* 821BEC08h */ case   12:  		/* lwz R11, <#[R30 + 8]> */
		/* 821BEC08h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821BEC08h case   12:*/		return 0x821BEC0C;
		  /* 821BEC0Ch */ case   13:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821BEC0Ch case   13:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821BEC0Ch case   13:*/		return 0x821BEC10;
		  /* 821BEC10h */ case   14:  		/* cmplwi CR6, R11, 14336 */
		/* 821BEC10h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003800);
		/* 821BEC10h case   14:*/		return 0x821BEC14;
		  /* 821BEC14h */ case   15:  		/* bc 4, CR6_EQ, 124 */
		/* 821BEC14h case   15:*/		if ( !regs.CR[6].eq ) { return 0x821BEC90;  }
		/* 821BEC14h case   15:*/		return 0x821BEC18;
		  /* 821BEC18h */ case   16:  		/* li R7, 1 */
		/* 821BEC18h case   16:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821BEC18h case   16:*/		return 0x821BEC1C;
		  /* 821BEC1Ch */ case   17:  		/* li R6, 0 */
		/* 821BEC1Ch case   17:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821BEC1Ch case   17:*/		return 0x821BEC20;
		  /* 821BEC20h */ case   18:  		/* mr R5, R26 */
		/* 821BEC20h case   18:*/		regs.R5 = regs.R26;
		/* 821BEC20h case   18:*/		return 0x821BEC24;
		  /* 821BEC24h */ case   19:  		/* mr R4, R30 */
		/* 821BEC24h case   19:*/		regs.R4 = regs.R30;
		/* 821BEC24h case   19:*/		return 0x821BEC28;
		  /* 821BEC28h */ case   20:  		/* mr R3, R27 */
		/* 821BEC28h case   20:*/		regs.R3 = regs.R27;
		/* 821BEC28h case   20:*/		return 0x821BEC2C;
		  /* 821BEC2Ch */ case   21:  		/* bl 170196 */
		/* 821BEC2Ch case   21:*/		regs.LR = 0x821BEC30; return 0x821E8500;
		/* 821BEC2Ch case   21:*/		return 0x821BEC30;
		  /* 821BEC30h */ case   22:  		/* or. R29, R3, R3 */
		/* 821BEC30h case   22:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 821BEC30h case   22:*/		return 0x821BEC34;
		  /* 821BEC34h */ case   23:  		/* bc 12, CR0_EQ, 92 */
		/* 821BEC34h case   23:*/		if ( regs.CR[0].eq ) { return 0x821BEC90;  }
		/* 821BEC34h case   23:*/		return 0x821BEC38;
		  /* 821BEC38h */ case   24:  		/* lwz R28, <#[R25 + 8]> */
		/* 821BEC38h case   24:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R25 + 0x00000008) );
		/* 821BEC38h case   24:*/		return 0x821BEC3C;
		  /* 821BEC3Ch */ case   25:  		/* cmplwi CR6, R28, 0 */
		/* 821BEC3Ch case   25:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 821BEC3Ch case   25:*/		return 0x821BEC40;
		  /* 821BEC40h */ case   26:  		/* bc 12, CR6_EQ, 64 */
		/* 821BEC40h case   26:*/		if ( regs.CR[6].eq ) { return 0x821BEC80;  }
		/* 821BEC40h case   26:*/		return 0x821BEC44;
		  /* 821BEC44h */ case   27:  		/* lwz R31, <#[R28 + 4]> */
		/* 821BEC44h case   27:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R28 + 0x00000004) );
		/* 821BEC44h case   27:*/		return 0x821BEC48;
		  /* 821BEC48h */ case   28:  		/* cmplw CR6, R31, R26 */
		/* 821BEC48h case   28:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R26);
		/* 821BEC48h case   28:*/		return 0x821BEC4C;
		  /* 821BEC4Ch */ case   29:  		/* bc 12, CR6_EQ, 36 */
		/* 821BEC4Ch case   29:*/		if ( regs.CR[6].eq ) { return 0x821BEC70;  }
		/* 821BEC4Ch case   29:*/		return 0x821BEC50;
		  /* 821BEC50h */ case   30:  		/* li R7, 1 */
		/* 821BEC50h case   30:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821BEC50h case   30:*/		return 0x821BEC54;
		  /* 821BEC54h */ case   31:  		/* li R6, 0 */
		/* 821BEC54h case   31:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821BEC54h case   31:*/		return 0x821BEC58;
		  /* 821BEC58h */ case   32:  		/* mr R5, R31 */
		/* 821BEC58h case   32:*/		regs.R5 = regs.R31;
		/* 821BEC58h case   32:*/		return 0x821BEC5C;
		  /* 821BEC5Ch */ case   33:  		/* mr R4, R30 */
		/* 821BEC5Ch case   33:*/		regs.R4 = regs.R30;
		/* 821BEC5Ch case   33:*/		return 0x821BEC60;
		  /* 821BEC60h */ case   34:  		/* mr R3, R27 */
		/* 821BEC60h case   34:*/		regs.R3 = regs.R27;
		/* 821BEC60h case   34:*/		return 0x821BEC64;
		  /* 821BEC64h */ case   35:  		/* bl 170140 */
		/* 821BEC64h case   35:*/		regs.LR = 0x821BEC68; return 0x821E8500;
		/* 821BEC64h case   35:*/		return 0x821BEC68;
		  /* 821BEC68h */ case   36:  		/* cmplw CR6, R29, R3 */
		/* 821BEC68h case   36:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R3);
		/* 821BEC68h case   36:*/		return 0x821BEC6C;
		  /* 821BEC6Ch */ case   37:  		/* bc 12, CR6_EQ, 12 */
		/* 821BEC6Ch case   37:*/		if ( regs.CR[6].eq ) { return 0x821BEC78;  }
		/* 821BEC6Ch case   37:*/		return 0x821BEC70;
	}
	return 0x821BEC70;
} // Block from 821BEBD8h-821BEC70h (38 instructions)

//////////////////////////////////////////////////////
// Block at 821BEC70h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BEC70( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BEC70) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BEC70);
		  /* 821BEC70h */ case    0:  		/* lwz R28, <#[R28 + 12]> */
		/* 821BEC70h case    0:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R28 + 0x0000000C) );
		/* 821BEC70h case    0:*/		return 0x821BEC74;
		  /* 821BEC74h */ case    1:  		/* b -56 */
		/* 821BEC74h case    1:*/		return 0x821BEC3C;
		/* 821BEC74h case    1:*/		return 0x821BEC78;
	}
	return 0x821BEC78;
} // Block from 821BEC70h-821BEC78h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BEC78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BEC78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BEC78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BEC78);
		  /* 821BEC78h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 821BEC78h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821BEC78h case    0:*/		return 0x821BEC7C;
		  /* 821BEC7Ch */ case    1:  		/* bc 4, CR6_EQ, 20 */
		/* 821BEC7Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BEC90;  }
		/* 821BEC7Ch case    1:*/		return 0x821BEC80;
	}
	return 0x821BEC80;
} // Block from 821BEC78h-821BEC80h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BEC80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BEC80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BEC80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BEC80);
		  /* 821BEC80h */ case    0:  		/* mr R5, R27 */
		/* 821BEC80h case    0:*/		regs.R5 = regs.R27;
		/* 821BEC80h case    0:*/		return 0x821BEC84;
		  /* 821BEC84h */ case    1:  		/* mr R4, R29 */
		/* 821BEC84h case    1:*/		regs.R4 = regs.R29;
		/* 821BEC84h case    1:*/		return 0x821BEC88;
		  /* 821BEC88h */ case    2:  		/* mr R3, R30 */
		/* 821BEC88h case    2:*/		regs.R3 = regs.R30;
		/* 821BEC88h case    2:*/		return 0x821BEC8C;
		  /* 821BEC8Ch */ case    3:  		/* bl -287612 */
		/* 821BEC8Ch case    3:*/		regs.LR = 0x821BEC90; return 0x82178910;
		/* 821BEC8Ch case    3:*/		return 0x821BEC90;
	}
	return 0x821BEC90;
} // Block from 821BEC80h-821BEC90h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BEC90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BEC90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BEC90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BEC90);
		  /* 821BEC90h */ case    0:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 821BEC90h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 821BEC90h case    0:*/		return 0x821BEC94;
		  /* 821BEC94h */ case    1:  		/* lwz R30, <#[R11 + 40]> */
		/* 821BEC94h case    1:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000028) );
		/* 821BEC94h case    1:*/		return 0x821BEC98;
		  /* 821BEC98h */ case    2:  		/* rlwinm. R11, R30, 0, 31, 31 */
		/* 821BEC98h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R30);
		/* 821BEC98h case    2:*/		return 0x821BEC9C;
		  /* 821BEC9Ch */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 821BEC9Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BECA8;  }
		/* 821BEC9Ch case    3:*/		return 0x821BECA0;
		  /* 821BECA0h */ case    4:  		/* cmplwi CR6, R30, 0 */
		/* 821BECA0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821BECA0h case    4:*/		return 0x821BECA4;
		  /* 821BECA4h */ case    5:  		/* bc 4, CR6_EQ, -156 */
		/* 821BECA4h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821BEC08;  }
		/* 821BECA4h case    5:*/		return 0x821BECA8;
	}
	return 0x821BECA8;
} // Block from 821BEC90h-821BECA8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BECA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BECA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BECA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BECA8);
		  /* 821BECA8h */ case    0:  		/* addi R1, R1, 144 */
		/* 821BECA8h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 821BECA8h case    0:*/		return 0x821BECAC;
		  /* 821BECACh */ case    1:  		/* b -1235472 */
		/* 821BECACh case    1:*/		return 0x8209129C;
		/* 821BECACh case    1:*/		return 0x821BECB0;
	}
	return 0x821BECB0;
} // Block from 821BECA8h-821BECB0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BECB0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BECB0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BECB0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BECB0);
		  /* 821BECB0h */ case    0:  		/* mfspr R12, LR */
		/* 821BECB0h case    0:*/		regs.R12 = regs.LR;
		/* 821BECB0h case    0:*/		return 0x821BECB4;
		  /* 821BECB4h */ case    1:  		/* bl -1235556 */
		/* 821BECB4h case    1:*/		regs.LR = 0x821BECB8; return 0x82091250;
		/* 821BECB4h case    1:*/		return 0x821BECB8;
		  /* 821BECB8h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 821BECB8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 821BECB8h case    2:*/		return 0x821BECBC;
		  /* 821BECBCh */ case    3:  		/* mr R31, R5 */
		/* 821BECBCh case    3:*/		regs.R31 = regs.R5;
		/* 821BECBCh case    3:*/		return 0x821BECC0;
		  /* 821BECC0h */ case    4:  		/* mr R28, R4 */
		/* 821BECC0h case    4:*/		regs.R28 = regs.R4;
		/* 821BECC0h case    4:*/		return 0x821BECC4;
		  /* 821BECC4h */ case    5:  		/* mr R5, R4 */
		/* 821BECC4h case    5:*/		regs.R5 = regs.R4;
		/* 821BECC4h case    5:*/		return 0x821BECC8;
		  /* 821BECC8h */ case    6:  		/* mr R4, R31 */
		/* 821BECC8h case    6:*/		regs.R4 = regs.R31;
		/* 821BECC8h case    6:*/		return 0x821BECCC;
		  /* 821BECCCh */ case    7:  		/* mr R26, R3 */
		/* 821BECCCh case    7:*/		regs.R26 = regs.R3;
		/* 821BECCCh case    7:*/		return 0x821BECD0;
		  /* 821BECD0h */ case    8:  		/* bl -248 */
		/* 821BECD0h case    8:*/		regs.LR = 0x821BECD4; return 0x821BEBD8;
		/* 821BECD0h case    8:*/		return 0x821BECD4;
		  /* 821BECD4h */ case    9:  		/* lwz R11, <#[R31 + 8]> */
		/* 821BECD4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821BECD4h case    9:*/		return 0x821BECD8;
		  /* 821BECD8h */ case   10:  		/* li R27, 1 */
		/* 821BECD8h case   10:*/		cpu::op::li<0>(regs,&regs.R27,0x1);
		/* 821BECD8h case   10:*/		return 0x821BECDC;
		  /* 821BECDCh */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 821BECDCh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BECDCh case   11:*/		return 0x821BECE0;
		  /* 821BECE0h */ case   12:  		/* bc 12, CR6_EQ, 20 */
		/* 821BECE0h case   12:*/		if ( regs.CR[6].eq ) { return 0x821BECF4;  }
		/* 821BECE0h case   12:*/		return 0x821BECE4;
		  /* 821BECE4h */ case   13:  		/* lwz R11, <#[R11 + 12]> */
		/* 821BECE4h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 821BECE4h case   13:*/		return 0x821BECE8;
		  /* 821BECE8h */ case   14:  		/* cmplwi CR6, R11, 0 */
		/* 821BECE8h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BECE8h case   14:*/		return 0x821BECEC;
		  /* 821BECECh */ case   15:  		/* mr R11, R27 */
		/* 821BECECh case   15:*/		regs.R11 = regs.R27;
		/* 821BECECh case   15:*/		return 0x821BECF0;
		  /* 821BECF0h */ case   16:  		/* bc 4, CR6_EQ, 8 */
		/* 821BECF0h case   16:*/		if ( !regs.CR[6].eq ) { return 0x821BECF8;  }
		/* 821BECF0h case   16:*/		return 0x821BECF4;
	}
	return 0x821BECF4;
} // Block from 821BECB0h-821BECF4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 821BECF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BECF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BECF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BECF4);
		  /* 821BECF4h */ case    0:  		/* li R11, 0 */
		/* 821BECF4h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BECF4h case    0:*/		return 0x821BECF8;
	}
	return 0x821BECF8;
} // Block from 821BECF4h-821BECF8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BECF8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BECF8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BECF8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BECF8);
		  /* 821BECF8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821BECF8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821BECF8h case    0:*/		return 0x821BECFC;
		  /* 821BECFCh */ case    1:  		/* bc 4, CR0_EQ, 108 */
		/* 821BECFCh case    1:*/		if ( !regs.CR[0].eq ) { return 0x821BED68;  }
		/* 821BECFCh case    1:*/		return 0x821BED00;
		  /* 821BED00h */ case    2:  		/* lwz R11, <#[R28 + 40]> */
		/* 821BED00h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000028) );
		/* 821BED00h case    2:*/		return 0x821BED04;
		  /* 821BED04h */ case    3:  		/* lwz R11, <#[R11]> */
		/* 821BED04h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821BED04h case    3:*/		return 0x821BED08;
		  /* 821BED08h */ case    4:  		/* rlwinm. R11, R11, 13, 31, 31 */
		/* 821BED08h case    4:*/		cpu::op::rlwinm<1,13,31,31>(regs,&regs.R11,regs.R11);
		/* 821BED08h case    4:*/		return 0x821BED0C;
		  /* 821BED0Ch */ case    5:  		/* bc 12, CR0_EQ, 92 */
		/* 821BED0Ch case    5:*/		if ( regs.CR[0].eq ) { return 0x821BED68;  }
		/* 821BED0Ch case    5:*/		return 0x821BED10;
		  /* 821BED10h */ case    6:  		/* lwz R9, <#[R31 + 40]> */
		/* 821BED10h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000028) );
		/* 821BED10h case    6:*/		return 0x821BED14;
		  /* 821BED14h */ case    7:  		/* lwz R11, <#[R28 + 48]> */
		/* 821BED14h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000030) );
		/* 821BED14h case    7:*/		return 0x821BED18;
		  /* 821BED18h */ case    8:  		/* rlwinm R10, R11, 0, 13, 31 */
		/* 821BED18h case    8:*/		cpu::op::rlwinm<0,0,13,31>(regs,&regs.R10,regs.R11);
		/* 821BED18h case    8:*/		return 0x821BED1C;
		  /* 821BED1Ch */ case    9:  		/* lwz R8, <#[R9]> */
		/* 821BED1Ch case    9:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x00000000) );
		/* 821BED1Ch case    9:*/		return 0x821BED20;
		  /* 821BED20h */ case   10:  		/* rlwinm R11, R10, 27, 5, 31 */
		/* 821BED20h case   10:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R10);
		/* 821BED20h case   10:*/		return 0x821BED24;
		  /* 821BED24h */ case   11:  		/* rlwinm R7, R10, 0, 27, 31 */
		/* 821BED24h case   11:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R7,regs.R10);
		/* 821BED24h case   11:*/		return 0x821BED28;
		  /* 821BED28h */ case   12:  		/* rlwinm R10, R8, 0, 13, 31 */
		/* 821BED28h case   12:*/		cpu::op::rlwinm<0,0,13,31>(regs,&regs.R10,regs.R8);
		/* 821BED28h case   12:*/		return 0x821BED2C;
		  /* 821BED2Ch */ case   13:  		/* addi R11, R11, 1 */
		/* 821BED2Ch case   13:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821BED2Ch case   13:*/		return 0x821BED30;
		  /* 821BED30h */ case   14:  		/* addi R8, R10, 31 */
		/* 821BED30h case   14:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R10,0x1F);
		/* 821BED30h case   14:*/		return 0x821BED34;
		  /* 821BED34h */ case   15:  		/* rlwinm R10, R11, 2, 0, 29 */
		/* 821BED34h case   15:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R11);
		/* 821BED34h case   15:*/		return 0x821BED38;
		  /* 821BED38h */ case   16:  		/* rlwinm R11, R8, 29, 3, 29 */
		/* 821BED38h case   16:*/		cpu::op::rlwinm<0,29,3,29>(regs,&regs.R11,regs.R8);
		/* 821BED38h case   16:*/		return 0x821BED3C;
		  /* 821BED3Ch */ case   17:  		/* slw R8, R27, R7 */
		/* 821BED3Ch case   17:*/		cpu::op::slw<0>(regs,&regs.R8,regs.R27,regs.R7);
		/* 821BED3Ch case   17:*/		return 0x821BED40;
		  /* 821BED40h */ case   18:  		/* add R11, R11, R10 */
		/* 821BED40h case   18:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821BED40h case   18:*/		return 0x821BED44;
		  /* 821BED44h */ case   19:  		/* lwzx R11, <#[R11 + R9]> */
		/* 821BED44h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 821BED44h case   19:*/		return 0x821BED48;
		  /* 821BED48h */ case   20:  		/* and. R11, R11, R8 */
		/* 821BED48h case   20:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R8);
		/* 821BED48h case   20:*/		return 0x821BED4C;
		  /* 821BED4Ch */ case   21:  		/* bc 12, CR0_EQ, 28 */
		/* 821BED4Ch case   21:*/		if ( regs.CR[0].eq ) { return 0x821BED68;  }
		/* 821BED4Ch case   21:*/		return 0x821BED50;
		  /* 821BED50h */ case   22:  		/* stw R31, <#[R1 + 80]> */
		/* 821BED50h case   22:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000050) );
		/* 821BED50h case   22:*/		return 0x821BED54;
		  /* 821BED54h */ case   23:  		/* stw R31, <#[R1 + 84]> */
		/* 821BED54h case   23:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R1 + 0x00000054) );
		/* 821BED54h case   23:*/		return 0x821BED58;
		  /* 821BED58h */ case   24:  		/* addi R3, R1, 80 */
		/* 821BED58h case   24:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x50);
		/* 821BED58h case   24:*/		return 0x821BED5C;
		  /* 821BED5Ch */ case   25:  		/* bl -290236 */
		/* 821BED5Ch case   25:*/		regs.LR = 0x821BED60; return 0x82177FA0;
		/* 821BED5Ch case   25:*/		return 0x821BED60;
		  /* 821BED60h */ case   26:  		/* or. R29, R3, R3 */
		/* 821BED60h case   26:*/		cpu::op::or<1>(regs,&regs.R29,regs.R3,regs.R3);
		/* 821BED60h case   26:*/		return 0x821BED64;
		  /* 821BED64h */ case   27:  		/* bc 4, CR0_EQ, 28 */
		/* 821BED64h case   27:*/		if ( !regs.CR[0].eq ) { return 0x821BED80;  }
		/* 821BED64h case   27:*/		return 0x821BED68;
	}
	return 0x821BED68;
} // Block from 821BECF8h-821BED68h (28 instructions)

//////////////////////////////////////////////////////
// Block at 821BED68h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BED68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BED68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BED68);
		  /* 821BED68h */ case    0:  		/* mr R5, R26 */
		/* 821BED68h case    0:*/		regs.R5 = regs.R26;
		/* 821BED68h case    0:*/		return 0x821BED6C;
		  /* 821BED6Ch */ case    1:  		/* mr R4, R31 */
		/* 821BED6Ch case    1:*/		regs.R4 = regs.R31;
		/* 821BED6Ch case    1:*/		return 0x821BED70;
		  /* 821BED70h */ case    2:  		/* mr R3, R28 */
		/* 821BED70h case    2:*/		regs.R3 = regs.R28;
		/* 821BED70h case    2:*/		return 0x821BED74;
		  /* 821BED74h */ case    3:  		/* bl 461812 */
		/* 821BED74h case    3:*/		regs.LR = 0x821BED78; return 0x8222F968;
		/* 821BED74h case    3:*/		return 0x821BED78;
		  /* 821BED78h */ case    4:  		/* addi R1, R1, 144 */
		/* 821BED78h case    4:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 821BED78h case    4:*/		return 0x821BED7C;
		  /* 821BED7Ch */ case    5:  		/* b -1235676 */
		/* 821BED7Ch case    5:*/		return 0x820912A0;
		/* 821BED7Ch case    5:*/		return 0x821BED80;
	}
	return 0x821BED80;
} // Block from 821BED68h-821BED80h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BED80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BED80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BED80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BED80);
		  /* 821BED80h */ case    0:  		/* lwz R30, <#[R29 + 12]> */
		/* 821BED80h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R29 + 0x0000000C) );
		/* 821BED80h case    0:*/		return 0x821BED84;
		  /* 821BED84h */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 821BED84h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821BED84h case    1:*/		return 0x821BED88;
		  /* 821BED88h */ case    2:  		/* bc 12, CR6_EQ, -48 */
		/* 821BED88h case    2:*/		if ( regs.CR[6].eq ) { return 0x821BED58;  }
		/* 821BED88h case    2:*/		return 0x821BED8C;
		  /* 821BED8Ch */ case    3:  		/* lwz R11, <#[R31 + 48]> */
		/* 821BED8Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 821BED8Ch case    3:*/		return 0x821BED90;
		  /* 821BED90h */ case    4:  		/* lwz R4, <#[R30]> */
		/* 821BED90h case    4:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R30 + 0x00000000) );
		/* 821BED90h case    4:*/		return 0x821BED94;
		  /* 821BED94h */ case    5:  		/* rlwinm R10, R11, 0, 13, 31 */
		/* 821BED94h case    5:*/		cpu::op::rlwinm<0,0,13,31>(regs,&regs.R10,regs.R11);
		/* 821BED94h case    5:*/		return 0x821BED98;
		  /* 821BED98h */ case    6:  		/* rlwinm R11, R10, 27, 5, 31 */
		/* 821BED98h case    6:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R10);
		/* 821BED98h case    6:*/		return 0x821BED9C;
		  /* 821BED9Ch */ case    7:  		/* rlwinm R10, R10, 0, 27, 31 */
		/* 821BED9Ch case    7:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R10,regs.R10);
		/* 821BED9Ch case    7:*/		return 0x821BEDA0;
		  /* 821BEDA0h */ case    8:  		/* addi R11, R11, 1 */
		/* 821BEDA0h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821BEDA0h case    8:*/		return 0x821BEDA4;
		  /* 821BEDA4h */ case    9:  		/* lwz R9, <#[R4 + 40]> */
		/* 821BEDA4h case    9:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R4 + 0x00000028) );
		/* 821BEDA4h case    9:*/		return 0x821BEDA8;
		  /* 821BEDA8h */ case   10:  		/* slw R10, R27, R10 */
		/* 821BEDA8h case   10:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R27,regs.R10);
		/* 821BEDA8h case   10:*/		return 0x821BEDAC;
		  /* 821BEDACh */ case   11:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821BEDACh case   11:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821BEDACh case   11:*/		return 0x821BEDB0;
		  /* 821BEDB0h */ case   12:  		/* lwzx R11, <#[R11 + R9]> */
		/* 821BEDB0h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 821BEDB0h case   12:*/		return 0x821BEDB4;
		  /* 821BEDB4h */ case   13:  		/* and. R11, R11, R10 */
		/* 821BEDB4h case   13:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821BEDB4h case   13:*/		return 0x821BEDB8;
		  /* 821BEDB8h */ case   14:  		/* bc 4, CR0_EQ, 16 */
		/* 821BEDB8h case   14:*/		if ( !regs.CR[0].eq ) { return 0x821BEDC8;  }
		/* 821BEDB8h case   14:*/		return 0x821BEDBC;
		  /* 821BEDBCh */ case   15:  		/* mr R5, R29 */
		/* 821BEDBCh case   15:*/		regs.R5 = regs.R29;
		/* 821BEDBCh case   15:*/		return 0x821BEDC0;
		  /* 821BEDC0h */ case   16:  		/* mr R3, R26 */
		/* 821BEDC0h case   16:*/		regs.R3 = regs.R26;
		/* 821BEDC0h case   16:*/		return 0x821BEDC4;
		  /* 821BEDC4h */ case   17:  		/* bl -492 */
		/* 821BEDC4h case   17:*/		regs.LR = 0x821BEDC8; return 0x821BEBD8;
		/* 821BEDC4h case   17:*/		return 0x821BEDC8;
	}
	return 0x821BEDC8;
} // Block from 821BED80h-821BEDC8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821BEDC8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BEDC8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BEDC8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BEDC8);
		  /* 821BEDC8h */ case    0:  		/* lwz R30, <#[R30 + 8]> */
		/* 821BEDC8h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000008) );
		/* 821BEDC8h case    0:*/		return 0x821BEDCC;
		  /* 821BEDCCh */ case    1:  		/* b -72 */
		/* 821BEDCCh case    1:*/		return 0x821BED84;
		/* 821BEDCCh case    1:*/		return 0x821BEDD0;
	}
	return 0x821BEDD0;
} // Block from 821BEDC8h-821BEDD0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BEDD0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BEDD0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BEDD0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BEDD0);
		  /* 821BEDD0h */ case    0:  		/* mfspr R12, LR */
		/* 821BEDD0h case    0:*/		regs.R12 = regs.LR;
		/* 821BEDD0h case    0:*/		return 0x821BEDD4;
		  /* 821BEDD4h */ case    1:  		/* bl -1235852 */
		/* 821BEDD4h case    1:*/		regs.LR = 0x821BEDD8; return 0x82091248;
		/* 821BEDD4h case    1:*/		return 0x821BEDD8;
		  /* 821BEDD8h */ case    2:  		/* stwu R1, <#[R1 - 160]> */
		/* 821BEDD8h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF60) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF60);
		/* 821BEDD8h case    2:*/		return 0x821BEDDC;
		  /* 821BEDDCh */ case    3:  		/* mr R26, R3 */
		/* 821BEDDCh case    3:*/		regs.R26 = regs.R3;
		/* 821BEDDCh case    3:*/		return 0x821BEDE0;
		  /* 821BEDE0h */ case    4:  		/* mr R24, R4 */
		/* 821BEDE0h case    4:*/		regs.R24 = regs.R4;
		/* 821BEDE0h case    4:*/		return 0x821BEDE4;
		  /* 821BEDE4h */ case    5:  		/* li R25, 0 */
		/* 821BEDE4h case    5:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 821BEDE4h case    5:*/		return 0x821BEDE8;
		  /* 821BEDE8h */ case    6:  		/* lwz R11, <#[R26 + 4]> */
		/* 821BEDE8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000004) );
		/* 821BEDE8h case    6:*/		return 0x821BEDEC;
		  /* 821BEDECh */ case    7:  		/* mr R9, R25 */
		/* 821BEDECh case    7:*/		regs.R9 = regs.R25;
		/* 821BEDECh case    7:*/		return 0x821BEDF0;
		  /* 821BEDF0h */ case    8:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 821BEDF0h case    8:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BEDF0h case    8:*/		return 0x821BEDF4;
		  /* 821BEDF4h */ case    9:  		/* addic R10, R10, -1 */
		/* 821BEDF4h case    9:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 821BEDF4h case    9:*/		return 0x821BEDF8;
		  /* 821BEDF8h */ case   10:  		/* subfe R10, R10, R10 */
		/* 821BEDF8h case   10:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 821BEDF8h case   10:*/		return 0x821BEDFC;
		  /* 821BEDFCh */ case   11:  		/* and R11, R10, R11 */
		/* 821BEDFCh case   11:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821BEDFCh case   11:*/		return 0x821BEE00;
		  /* 821BEE00h */ case   12:  		/* b 72 */
		/* 821BEE00h case   12:*/		return 0x821BEE48;
		/* 821BEE00h case   12:*/		return 0x821BEE04;
		  /* 821BEE04h */ case   13:  		/* lwz R10, <#[R11 + 44]> */
		/* 821BEE04h case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000002C) );
		/* 821BEE04h case   13:*/		return 0x821BEE08;
		  /* 821BEE08h */ case   14:  		/* cmplw CR6, R10, R24 */
		/* 821BEE08h case   14:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R24);
		/* 821BEE08h case   14:*/		return 0x821BEE0C;
		  /* 821BEE0Ch */ case   15:  		/* bc 12, CR6_EQ, 60 */
		/* 821BEE0Ch case   15:*/		if ( regs.CR[6].eq ) { return 0x821BEE48;  }
		/* 821BEE0Ch case   15:*/		return 0x821BEE10;
		  /* 821BEE10h */ case   16:  		/* lwz R10, <#[R11 + 48]> */
		/* 821BEE10h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 821BEE10h case   16:*/		return 0x821BEE14;
		  /* 821BEE14h */ case   17:  		/* rlwinm. R10, R10, 13, 31, 31 */
		/* 821BEE14h case   17:*/		cpu::op::rlwinm<1,13,31,31>(regs,&regs.R10,regs.R10);
		/* 821BEE14h case   17:*/		return 0x821BEE18;
		  /* 821BEE18h */ case   18:  		/* bc 4, CR0_EQ, 48 */
		/* 821BEE18h case   18:*/		if ( !regs.CR[0].eq ) { return 0x821BEE48;  }
		/* 821BEE18h case   18:*/		return 0x821BEE1C;
		  /* 821BEE1Ch */ case   19:  		/* lwz R10, <#[R11 + 8]> */
		/* 821BEE1Ch case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821BEE1Ch case   19:*/		return 0x821BEE20;
		  /* 821BEE20h */ case   20:  		/* cmplwi CR6, R10, 0 */
		/* 821BEE20h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821BEE20h case   20:*/		return 0x821BEE24;
		  /* 821BEE24h */ case   21:  		/* bc 12, CR6_EQ, 28 */
		/* 821BEE24h case   21:*/		if ( regs.CR[6].eq ) { return 0x821BEE40;  }
		/* 821BEE24h case   21:*/		return 0x821BEE28;
		  /* 821BEE28h */ case   22:  		/* lwz R8, <#[R10 + 4]> */
		/* 821BEE28h case   22:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000004) );
		/* 821BEE28h case   22:*/		return 0x821BEE2C;
		  /* 821BEE2Ch */ case   23:  		/* lwz R8, <#[R8 + 44]> */
		/* 821BEE2Ch case   23:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x0000002C) );
		/* 821BEE2Ch case   23:*/		return 0x821BEE30;
		  /* 821BEE30h */ case   24:  		/* cmplw CR6, R8, R24 */
		/* 821BEE30h case   24:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R24);
		/* 821BEE30h case   24:*/		return 0x821BEE34;
		  /* 821BEE34h */ case   25:  		/* bc 4, CR6_EQ, 20 */
		/* 821BEE34h case   25:*/		if ( !regs.CR[6].eq ) { return 0x821BEE48;  }
		/* 821BEE34h case   25:*/		return 0x821BEE38;
		  /* 821BEE38h */ case   26:  		/* lwz R10, <#[R10 + 12]> */
		/* 821BEE38h case   26:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000000C) );
		/* 821BEE38h case   26:*/		return 0x821BEE3C;
		  /* 821BEE3Ch */ case   27:  		/* b -28 */
		/* 821BEE3Ch case   27:*/		return 0x821BEE20;
		/* 821BEE3Ch case   27:*/		return 0x821BEE40;
	}
	return 0x821BEE40;
} // Block from 821BEDD0h-821BEE40h (28 instructions)

//////////////////////////////////////////////////////
// Block at 821BEE40h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BEE40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BEE40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BEE40);
		  /* 821BEE40h */ case    0:  		/* stw R24, <#[R11 + 44]> */
		/* 821BEE40h case    0:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R11 + 0x0000002C) );
		/* 821BEE40h case    0:*/		return 0x821BEE44;
		  /* 821BEE44h */ case    1:  		/* li R9, 1 */
		/* 821BEE44h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x1);
		/* 821BEE44h case    1:*/		return 0x821BEE48;
	}
	return 0x821BEE48;
} // Block from 821BEE40h-821BEE48h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BEE48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BEE48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BEE48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BEE48);
		  /* 821BEE48h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821BEE48h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821BEE48h case    0:*/		return 0x821BEE4C;
		  /* 821BEE4Ch */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 821BEE4Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821BEE4Ch case    1:*/		return 0x821BEE50;
		  /* 821BEE50h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BEE50h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BEE50h case    2:*/		return 0x821BEE54;
		  /* 821BEE54h */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 821BEE54h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BEE60;  }
		/* 821BEE54h case    3:*/		return 0x821BEE58;
		  /* 821BEE58h */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 821BEE58h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BEE58h case    4:*/		return 0x821BEE5C;
		  /* 821BEE5Ch */ case    5:  		/* bc 4, CR6_EQ, -88 */
		/* 821BEE5Ch case    5:*/		if ( !regs.CR[6].eq ) { return 0x821BEE04;  }
		/* 821BEE5Ch case    5:*/		return 0x821BEE60;
	}
	return 0x821BEE60;
} // Block from 821BEE48h-821BEE60h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BEE60h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BEE60( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BEE60) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BEE60);
		  /* 821BEE60h */ case    0:  		/* rlwinm. R11, R9, 0, 24, 31 */
		/* 821BEE60h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R9);
		/* 821BEE60h case    0:*/		return 0x821BEE64;
		  /* 821BEE64h */ case    1:  		/* bc 4, CR0_EQ, -124 */
		/* 821BEE64h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821BEDE8;  }
		/* 821BEE64h case    1:*/		return 0x821BEE68;
		  /* 821BEE68h */ case    2:  		/* lwz R11, <#[R26 + 4]> */
		/* 821BEE68h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000004) );
		/* 821BEE68h case    2:*/		return 0x821BEE6C;
		  /* 821BEE6Ch */ case    3:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BEE6Ch case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BEE6Ch case    3:*/		return 0x821BEE70;
		  /* 821BEE70h */ case    4:  		/* bc 4, CR0_EQ, 496 */
		/* 821BEE70h case    4:*/		if ( !regs.CR[0].eq ) { return 0x821BF060;  }
		/* 821BEE70h case    4:*/		return 0x821BEE74;
		  /* 821BEE74h */ case    5:  		/* mr R27, R11 */
		/* 821BEE74h case    5:*/		regs.R27 = regs.R11;
		/* 821BEE74h case    5:*/		return 0x821BEE78;
		  /* 821BEE78h */ case    6:  		/* cmplwi CR0, R11, 0 */
		/* 821BEE78h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821BEE78h case    6:*/		return 0x821BEE7C;
		  /* 821BEE7Ch */ case    7:  		/* bc 12, CR0_EQ, 484 */
		/* 821BEE7Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x821BF060;  }
		/* 821BEE7Ch case    7:*/		return 0x821BEE80;
		  /* 821BEE80h */ case    8:  		/* lwz R11, <#[R27 + 44]> */
		/* 821BEE80h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000002C) );
		/* 821BEE80h case    8:*/		return 0x821BEE84;
		  /* 821BEE84h */ case    9:  		/* cmplw CR6, R11, R24 */
		/* 821BEE84h case    9:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R24);
		/* 821BEE84h case    9:*/		return 0x821BEE88;
		  /* 821BEE88h */ case   10:  		/* bc 4, CR6_EQ, 444 */
		/* 821BEE88h case   10:*/		if ( !regs.CR[6].eq ) { return 0x821BF044;  }
		/* 821BEE88h case   10:*/		return 0x821BEE8C;
		  /* 821BEE8Ch */ case   11:  		/* lwz R11, <#[R27 + 48]> */
		/* 821BEE8Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000030) );
		/* 821BEE8Ch case   11:*/		return 0x821BEE90;
		  /* 821BEE90h */ case   12:  		/* rlwinm. R10, R11, 12, 31, 31 */
		/* 821BEE90h case   12:*/		cpu::op::rlwinm<1,12,31,31>(regs,&regs.R10,regs.R11);
		/* 821BEE90h case   12:*/		return 0x821BEE94;
		  /* 821BEE94h */ case   13:  		/* bc 12, CR0_EQ, 16 */
		/* 821BEE94h case   13:*/		if ( regs.CR[0].eq ) { return 0x821BEEA4;  }
		/* 821BEE94h case   13:*/		return 0x821BEE98;
		  /* 821BEE98h */ case   14:  		/* rlwinm R11, R11, 0, 12, 10 */
		/* 821BEE98h case   14:*/		cpu::op::rlwinm<0,0,12,10>(regs,&regs.R11,regs.R11);
		/* 821BEE98h case   14:*/		return 0x821BEE9C;
		  /* 821BEE9Ch */ case   15:  		/* stw R11, <#[R27 + 48]> */
		/* 821BEE9Ch case   15:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000030) );
		/* 821BEE9Ch case   15:*/		return 0x821BEEA0;
		  /* 821BEEA0h */ case   16:  		/* b 28 */
		/* 821BEEA0h case   16:*/		return 0x821BEEBC;
		/* 821BEEA0h case   16:*/		return 0x821BEEA4;
	}
	return 0x821BEEA4;
} // Block from 821BEE60h-821BEEA4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 821BEEA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BEEA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BEEA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BEEA4);
		  /* 821BEEA4h */ case    0:  		/* rlwinm. R11, R11, 13, 31, 31 */
		/* 821BEEA4h case    0:*/		cpu::op::rlwinm<1,13,31,31>(regs,&regs.R11,regs.R11);
		/* 821BEEA4h case    0:*/		return 0x821BEEA8;
		  /* 821BEEA8h */ case    1:  		/* bc 12, CR0_EQ, 20 */
		/* 821BEEA8h case    1:*/		if ( regs.CR[0].eq ) { return 0x821BEEBC;  }
		/* 821BEEA8h case    1:*/		return 0x821BEEAC;
		  /* 821BEEACh */ case    2:  		/* lwz R11, <#[R27 + 116]> */
		/* 821BEEACh case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000074) );
		/* 821BEEACh case    2:*/		return 0x821BEEB0;
		  /* 821BEEB0h */ case    3:  		/* stw R25, <#[R11 + 12]> */
		/* 821BEEB0h case    3:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R11 + 0x0000000C) );
		/* 821BEEB0h case    3:*/		return 0x821BEEB4;
		  /* 821BEEB4h */ case    4:  		/* stw R25, <#[R11 + 16]> */
		/* 821BEEB4h case    4:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R11 + 0x00000010) );
		/* 821BEEB4h case    4:*/		return 0x821BEEB8;
		  /* 821BEEB8h */ case    5:  		/* stw R25, <#[R11 + 20]> */
		/* 821BEEB8h case    5:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R11 + 0x00000014) );
		/* 821BEEB8h case    5:*/		return 0x821BEEBC;
	}
	return 0x821BEEBC;
} // Block from 821BEEA4h-821BEEBCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BEEBCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BEEBC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BEEBC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BEEBC);
		  /* 821BEEBCh */ case    0:  		/* lwz R11, <#[R27 + 20]> */
		/* 821BEEBCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000014) );
		/* 821BEEBCh case    0:*/		return 0x821BEEC0;
		  /* 821BEEC0h */ case    1:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821BEEC0h case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821BEEC0h case    1:*/		return 0x821BEEC4;
		  /* 821BEEC4h */ case    2:  		/* bc 12, CR0_EQ, 40 */
		/* 821BEEC4h case    2:*/		if ( regs.CR[0].eq ) { return 0x821BEEEC;  }
		/* 821BEEC4h case    2:*/		return 0x821BEEC8;
		  /* 821BEEC8h */ case    3:  		/* lwz R11, <#[R27 + 28]> */
		/* 821BEEC8h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000001C) );
		/* 821BEEC8h case    3:*/		return 0x821BEECC;
		  /* 821BEECCh */ case    4:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821BEECCh case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821BEECCh case    4:*/		return 0x821BEED0;
		  /* 821BEED0h */ case    5:  		/* bc 12, CR0_EQ, 16 */
		/* 821BEED0h case    5:*/		if ( regs.CR[0].eq ) { return 0x821BEEE0;  }
		/* 821BEED0h case    5:*/		return 0x821BEED4;
		  /* 821BEED4h */ case    6:  		/* lwz R11, <#[R27 + 36]> */
		/* 821BEED4h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000024) );
		/* 821BEED4h case    6:*/		return 0x821BEED8;
		  /* 821BEED8h */ case    7:  		/* addi R29, R27, 32 */
		/* 821BEED8h case    7:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R27,0x20);
		/* 821BEED8h case    7:*/		return 0x821BEEDC;
		  /* 821BEEDCh */ case    8:  		/* b 24 */
		/* 821BEEDCh case    8:*/		return 0x821BEEF4;
		/* 821BEEDCh case    8:*/		return 0x821BEEE0;
	}
	return 0x821BEEE0;
} // Block from 821BEEBCh-821BEEE0h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821BEEE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BEEE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BEEE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BEEE0);
		  /* 821BEEE0h */ case    0:  		/* lwz R11, <#[R27 + 28]> */
		/* 821BEEE0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000001C) );
		/* 821BEEE0h case    0:*/		return 0x821BEEE4;
		  /* 821BEEE4h */ case    1:  		/* addi R29, R27, 24 */
		/* 821BEEE4h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R27,0x18);
		/* 821BEEE4h case    1:*/		return 0x821BEEE8;
		  /* 821BEEE8h */ case    2:  		/* b 12 */
		/* 821BEEE8h case    2:*/		return 0x821BEEF4;
		/* 821BEEE8h case    2:*/		return 0x821BEEEC;
	}
	return 0x821BEEEC;
} // Block from 821BEEE0h-821BEEECh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BEEECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BEEEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BEEEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BEEEC);
		  /* 821BEEECh */ case    0:  		/* lwz R11, <#[R27 + 20]> */
		/* 821BEEECh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000014) );
		/* 821BEEECh case    0:*/		return 0x821BEEF0;
		  /* 821BEEF0h */ case    1:  		/* addi R29, R27, 16 */
		/* 821BEEF0h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R27,0x10);
		/* 821BEEF0h case    1:*/		return 0x821BEEF4;
	}
	return 0x821BEEF4;
} // Block from 821BEEECh-821BEEF4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BEEF4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BEEF4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BEEF4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BEEF4);
		  /* 821BEEF4h */ case    0:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 821BEEF4h case    0:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BEEF4h case    0:*/		return 0x821BEEF8;
		  /* 821BEEF8h */ case    1:  		/* addic R10, R10, -1 */
		/* 821BEEF8h case    1:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 821BEEF8h case    1:*/		return 0x821BEEFC;
		  /* 821BEEFCh */ case    2:  		/* subfe R10, R10, R10 */
		/* 821BEEFCh case    2:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 821BEEFCh case    2:*/		return 0x821BEF00;
		  /* 821BEF00h */ case    3:  		/* and R30, R10, R11 */
		/* 821BEF00h case    3:*/		cpu::op::and<0>(regs,&regs.R30,regs.R10,regs.R11);
		/* 821BEF00h case    3:*/		return 0x821BEF04;
		  /* 821BEF04h */ case    4:  		/* b 152 */
		/* 821BEF04h case    4:*/		return 0x821BEF9C;
		/* 821BEF04h case    4:*/		return 0x821BEF08;
		  /* 821BEF08h */ case    5:  		/* addi R28, R30, 4 */
		/* 821BEF08h case    5:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R30,0x4);
		/* 821BEF08h case    5:*/		return 0x821BEF0C;
		  /* 821BEF0Ch */ case    6:  		/* lwz R31, <#[R28]> */
		/* 821BEF0Ch case    6:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R28 + 0x00000000) );
		/* 821BEF0Ch case    6:*/		return 0x821BEF10;
		  /* 821BEF10h */ case    7:  		/* cmplwi CR6, R31, 0 */
		/* 821BEF10h case    7:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821BEF10h case    7:*/		return 0x821BEF14;
		  /* 821BEF14h */ case    8:  		/* bc 12, CR6_EQ, 48 */
		/* 821BEF14h case    8:*/		if ( regs.CR[6].eq ) { return 0x821BEF44;  }
		/* 821BEF14h case    8:*/		return 0x821BEF18;
		  /* 821BEF18h */ case    9:  		/* lwz R3, <#[R31 + 16]> */
		/* 821BEF18h case    9:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R31 + 0x00000010) );
		/* 821BEF18h case    9:*/		return 0x821BEF1C;
		  /* 821BEF1Ch */ case   10:  		/* cmplwi CR6, R3, 0 */
		/* 821BEF1Ch case   10:*/		cpu::op::cmplwi<6>(regs,regs.R3,0x00000000);
		/* 821BEF1Ch case   10:*/		return 0x821BEF20;
		  /* 821BEF20h */ case   11:  		/* bc 12, CR6_EQ, 16 */
		/* 821BEF20h case   11:*/		if ( regs.CR[6].eq ) { return 0x821BEF30;  }
		/* 821BEF20h case   11:*/		return 0x821BEF24;
		  /* 821BEF24h */ case   12:  		/* mr R5, R26 */
		/* 821BEF24h case   12:*/		regs.R5 = regs.R26;
		/* 821BEF24h case   12:*/		return 0x821BEF28;
		  /* 821BEF28h */ case   13:  		/* mr R4, R31 */
		/* 821BEF28h case   13:*/		regs.R4 = regs.R31;
		/* 821BEF28h case   13:*/		return 0x821BEF2C;
		  /* 821BEF2Ch */ case   14:  		/* bl -288284 */
		/* 821BEF2Ch case   14:*/		regs.LR = 0x821BEF30; return 0x82178910;
		/* 821BEF2Ch case   14:*/		return 0x821BEF30;
	}
	return 0x821BEF30;
} // Block from 821BEEF4h-821BEF30h (15 instructions)

//////////////////////////////////////////////////////
// Block at 821BEF30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BEF30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BEF30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BEF30);
		  /* 821BEF30h */ case    0:  		/* lwz R11, <#[R28]> */
		/* 821BEF30h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000000) );
		/* 821BEF30h case    0:*/		return 0x821BEF34;
		  /* 821BEF34h */ case    1:  		/* cmplw CR6, R11, R31 */
		/* 821BEF34h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 821BEF34h case    1:*/		return 0x821BEF38;
		  /* 821BEF38h */ case    2:  		/* bc 4, CR6_EQ, -44 */
		/* 821BEF38h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821BEF0C;  }
		/* 821BEF38h case    2:*/		return 0x821BEF3C;
		  /* 821BEF3Ch */ case    3:  		/* addi R28, R31, 8 */
		/* 821BEF3Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R31,0x8);
		/* 821BEF3Ch case    3:*/		return 0x821BEF40;
	}
	return 0x821BEF40;
} // Block from 821BEF30h-821BEF40h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BEF40h
// Function '?ExamineAndExpressionTerm@Compiler@D3DXShader@@AAA?AW4ExamineLoopInvariantTestDisposition@12@PAUInductionVariable@2@_NPAVDependency@2@PAVInstruction@2@W4Component@2@IPAPAUInvariantCondition@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BEF40( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BEF40) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BEF40);
		  /* 821BEF40h */ case    0:  		/* b -52 */
		/* 821BEF40h case    0:*/		return 0x821BEF0C;
		/* 821BEF40h case    0:*/		return 0x821BEF44;
	}
	return 0x821BEF44;
} // Block from 821BEF40h-821BEF44h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BEF44h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BEF44( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BEF44) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BEF44);
		  /* 821BEF44h */ case    0:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 821BEF44h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 821BEF44h case    0:*/		return 0x821BEF48;
		  /* 821BEF48h */ case    1:  		/* lwz R30, <#[R11 + 40]> */
		/* 821BEF48h case    1:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000028) );
		/* 821BEF48h case    1:*/		return 0x821BEF4C;
		  /* 821BEF4Ch */ case    2:  		/* rlwinm. R11, R30, 0, 31, 31 */
		/* 821BEF4Ch case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R30);
		/* 821BEF4Ch case    2:*/		return 0x821BEF50;
		  /* 821BEF50h */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 821BEF50h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BEF5C;  }
		/* 821BEF50h case    3:*/		return 0x821BEF54;
		  /* 821BEF54h */ case    4:  		/* cmplwi CR6, R30, 0 */
		/* 821BEF54h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821BEF54h case    4:*/		return 0x821BEF58;
		  /* 821BEF58h */ case    5:  		/* bc 4, CR6_EQ, -80 */
		/* 821BEF58h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821BEF08;  }
		/* 821BEF58h case    5:*/		return 0x821BEF5C;
	}
	return 0x821BEF5C;
} // Block from 821BEF44h-821BEF5Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BEF5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BEF5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BEF5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BEF5C);
		  /* 821BEF5Ch */ case    0:  		/* addi R10, R27, 32 */
		/* 821BEF5Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R27,0x20);
		/* 821BEF5Ch case    0:*/		return 0x821BEF60;
		  /* 821BEF60h */ case    1:  		/* cmplw CR6, R29, R10 */
		/* 821BEF60h case    1:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R10);
		/* 821BEF60h case    1:*/		return 0x821BEF64;
		  /* 821BEF64h */ case    2:  		/* bc 12, CR6_EQ, 64 */
		/* 821BEF64h case    2:*/		if ( regs.CR[6].eq ) { return 0x821BEFA4;  }
		/* 821BEF64h case    2:*/		return 0x821BEF68;
		  /* 821BEF68h */ case    3:  		/* addi R11, R27, 24 */
		/* 821BEF68h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R27,0x18);
		/* 821BEF68h case    3:*/		return 0x821BEF6C;
		  /* 821BEF6Ch */ case    4:  		/* cmplw CR6, R29, R11 */
		/* 821BEF6Ch case    4:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 821BEF6Ch case    4:*/		return 0x821BEF70;
		  /* 821BEF70h */ case    5:  		/* bc 12, CR6_EQ, 28 */
		/* 821BEF70h case    5:*/		if ( regs.CR[6].eq ) { return 0x821BEF8C;  }
		/* 821BEF70h case    5:*/		return 0x821BEF74;
		  /* 821BEF74h */ case    6:  		/* lwz R9, <#[R27 + 28]> */
		/* 821BEF74h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x0000001C) );
		/* 821BEF74h case    6:*/		return 0x821BEF78;
		  /* 821BEF78h */ case    7:  		/* rlwinm. R9, R9, 0, 31, 31 */
		/* 821BEF78h case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R9);
		/* 821BEF78h case    7:*/		return 0x821BEF7C;
		  /* 821BEF7Ch */ case    8:  		/* bc 4, CR0_EQ, 16 */
		/* 821BEF7Ch case    8:*/		if ( !regs.CR[0].eq ) { return 0x821BEF8C;  }
		/* 821BEF7Ch case    8:*/		return 0x821BEF80;
		  /* 821BEF80h */ case    9:  		/* lwz R30, <#[R11 + 4]> */
		/* 821BEF80h case    9:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000004) );
		/* 821BEF80h case    9:*/		return 0x821BEF84;
		  /* 821BEF84h */ case   10:  		/* mr R29, R11 */
		/* 821BEF84h case   10:*/		regs.R29 = regs.R11;
		/* 821BEF84h case   10:*/		return 0x821BEF88;
		  /* 821BEF88h */ case   11:  		/* b 12 */
		/* 821BEF88h case   11:*/		return 0x821BEF94;
		/* 821BEF88h case   11:*/		return 0x821BEF8C;
	}
	return 0x821BEF8C;
} // Block from 821BEF5Ch-821BEF8Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 821BEF8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BEF8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BEF8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BEF8C);
		  /* 821BEF8Ch */ case    0:  		/* lwz R30, <#[R10 + 4]> */
		/* 821BEF8Ch case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R10 + 0x00000004) );
		/* 821BEF8Ch case    0:*/		return 0x821BEF90;
		  /* 821BEF90h */ case    1:  		/* mr R29, R10 */
		/* 821BEF90h case    1:*/		regs.R29 = regs.R10;
		/* 821BEF90h case    1:*/		return 0x821BEF94;
	}
	return 0x821BEF94;
} // Block from 821BEF8Ch-821BEF94h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BEF94h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BEF94( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BEF94) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BEF94);
		  /* 821BEF94h */ case    0:  		/* rlwinm. R11, R30, 0, 31, 31 */
		/* 821BEF94h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R30);
		/* 821BEF94h case    0:*/		return 0x821BEF98;
		  /* 821BEF98h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 821BEF98h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821BEFA4;  }
		/* 821BEF98h case    1:*/		return 0x821BEF9C;
	}
	return 0x821BEF9C;
} // Block from 821BEF94h-821BEF9Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BEF9Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BEF9C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BEF9C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BEF9C);
		  /* 821BEF9Ch */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 821BEF9Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821BEF9Ch case    0:*/		return 0x821BEFA0;
		  /* 821BEFA0h */ case    1:  		/* bc 4, CR6_EQ, -152 */
		/* 821BEFA0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BEF08;  }
		/* 821BEFA0h case    1:*/		return 0x821BEFA4;
	}
	return 0x821BEFA4;
} // Block from 821BEF9Ch-821BEFA4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BEFA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BEFA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BEFA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BEFA4);
		  /* 821BEFA4h */ case    0:  		/* lwz R30, <#[R27 + 12]> */
		/* 821BEFA4h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R27 + 0x0000000C) );
		/* 821BEFA4h case    0:*/		return 0x821BEFA8;
		  /* 821BEFA8h */ case    1:  		/* addi R29, R27, 12 */
		/* 821BEFA8h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R27,0xC);
		/* 821BEFA8h case    1:*/		return 0x821BEFAC;
		  /* 821BEFACh */ case    2:  		/* cmplwi CR6, R30, 0 */
		/* 821BEFACh case    2:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821BEFACh case    2:*/		return 0x821BEFB0;
		  /* 821BEFB0h */ case    3:  		/* bc 12, CR6_EQ, 148 */
		/* 821BEFB0h case    3:*/		if ( regs.CR[6].eq ) { return 0x821BF044;  }
		/* 821BEFB0h case    3:*/		return 0x821BEFB4;
		  /* 821BEFB4h */ case    4:  		/* lwz R31, <#[R30]> */
		/* 821BEFB4h case    4:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000000) );
		/* 821BEFB4h case    4:*/		return 0x821BEFB8;
		  /* 821BEFB8h */ case    5:  		/* mr R5, R26 */
		/* 821BEFB8h case    5:*/		regs.R5 = regs.R26;
		/* 821BEFB8h case    5:*/		return 0x821BEFBC;
		  /* 821BEFBCh */ case    6:  		/* mr R3, R27 */
		/* 821BEFBCh case    6:*/		regs.R3 = regs.R27;
		/* 821BEFBCh case    6:*/		return 0x821BEFC0;
		  /* 821BEFC0h */ case    7:  		/* mr R4, R31 */
		/* 821BEFC0h case    7:*/		regs.R4 = regs.R31;
		/* 821BEFC0h case    7:*/		return 0x821BEFC4;
		  /* 821BEFC4h */ case    8:  		/* bl 461220 */
		/* 821BEFC4h case    8:*/		regs.LR = 0x821BEFC8; return 0x8222F968;
		/* 821BEFC4h case    8:*/		return 0x821BEFC8;
		  /* 821BEFC8h */ case    9:  		/* lwz R10, <#[R31 + 48]> */
		/* 821BEFC8h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000030) );
		/* 821BEFC8h case    9:*/		return 0x821BEFCC;
		  /* 821BEFCCh */ case   10:  		/* rlwinm. R11, R10, 11, 31, 31 */
		/* 821BEFCCh case   10:*/		cpu::op::rlwinm<1,11,31,31>(regs,&regs.R11,regs.R10);
		/* 821BEFCCh case   10:*/		return 0x821BEFD0;
		  /* 821BEFD0h */ case   11:  		/* bc 12, CR0_EQ, 92 */
		/* 821BEFD0h case   11:*/		if ( regs.CR[0].eq ) { return 0x821BF02C;  }
		/* 821BEFD0h case   11:*/		return 0x821BEFD4;
		  /* 821BEFD4h */ case   12:  		/* lwz R11, <#[R31 + 44]> */
		/* 821BEFD4h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 821BEFD4h case   12:*/		return 0x821BEFD8;
		  /* 821BEFD8h */ case   13:  		/* cmplw CR6, R11, R24 */
		/* 821BEFD8h case   13:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R24);
		/* 821BEFD8h case   13:*/		return 0x821BEFDC;
		  /* 821BEFDCh */ case   14:  		/* bc 12, CR6_EQ, 80 */
		/* 821BEFDCh case   14:*/		if ( regs.CR[6].eq ) { return 0x821BF02C;  }
		/* 821BEFDCh case   14:*/		return 0x821BEFE0;
		  /* 821BEFE0h */ case   15:  		/* lwz R11, <#[R27 + 36]> */
		/* 821BEFE0h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000024) );
		/* 821BEFE0h case   15:*/		return 0x821BEFE4;
		  /* 821BEFE4h */ case   16:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821BEFE4h case   16:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821BEFE4h case   16:*/		return 0x821BEFE8;
		  /* 821BEFE8h */ case   17:  		/* bc 4, CR0_EQ, 68 */
		/* 821BEFE8h case   17:*/		if ( !regs.CR[0].eq ) { return 0x821BF02C;  }
		/* 821BEFE8h case   17:*/		return 0x821BEFEC;
		  /* 821BEFECh */ case   18:  		/* lwz R11, <#[R27 + 32]> */
		/* 821BEFECh case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000020) );
		/* 821BEFECh case   18:*/		return 0x821BEFF0;
		  /* 821BEFF0h */ case   19:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821BEFF0h case   19:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821BEFF0h case   19:*/		return 0x821BEFF4;
		  /* 821BEFF4h */ case   20:  		/* addic. R11, R11, -40 */
		/* 821BEFF4h case   20:*/		cpu::op::addic<1>(regs,&regs.R11,regs.R11,0xFFFFFFD8);
		/* 821BEFF4h case   20:*/		return 0x821BEFF8;
		  /* 821BEFF8h */ case   21:  		/* bc 12, CR0_EQ, 52 */
		/* 821BEFF8h case   21:*/		if ( regs.CR[0].eq ) { return 0x821BF02C;  }
		/* 821BEFF8h case   21:*/		return 0x821BEFFC;
		  /* 821BEFFCh */ case   22:  		/* lwz R11, <#[R11 + 8]> */
		/* 821BEFFCh case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821BEFFCh case   22:*/		return 0x821BF000;
		  /* 821BF000h */ case   23:  		/* rlwinm R11, R11, 25, 25, 31 */
		/* 821BF000h case   23:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R11);
		/* 821BF000h case   23:*/		return 0x821BF004;
		  /* 821BF004h */ case   24:  		/* cmplwi CR6, R11, 86 */
		/* 821BF004h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000056);
		/* 821BF004h case   24:*/		return 0x821BF008;
		  /* 821BF008h */ case   25:  		/* bc 12, CR6_EQ, 16 */
		/* 821BF008h case   25:*/		if ( regs.CR[6].eq ) { return 0x821BF018;  }
		/* 821BF008h case   25:*/		return 0x821BF00C;
		  /* 821BF00Ch */ case   26:  		/* cmplwi CR6, R11, 87 */
		/* 821BF00Ch case   26:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000057);
		/* 821BF00Ch case   26:*/		return 0x821BF010;
		  /* 821BF010h */ case   27:  		/* mr R11, R25 */
		/* 821BF010h case   27:*/		regs.R11 = regs.R25;
		/* 821BF010h case   27:*/		return 0x821BF014;
		  /* 821BF014h */ case   28:  		/* bc 4, CR6_EQ, 8 */
		/* 821BF014h case   28:*/		if ( !regs.CR[6].eq ) { return 0x821BF01C;  }
		/* 821BF014h case   28:*/		return 0x821BF018;
	}
	return 0x821BF018;
} // Block from 821BEFA4h-821BF018h (29 instructions)

//////////////////////////////////////////////////////
// Block at 821BF018h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF018( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF018) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF018);
		  /* 821BF018h */ case    0:  		/* li R11, 1 */
		/* 821BF018h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821BF018h case    0:*/		return 0x821BF01C;
	}
	return 0x821BF01C;
} // Block from 821BF018h-821BF01Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BF01Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF01C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF01C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF01C);
		  /* 821BF01Ch */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821BF01Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821BF01Ch case    0:*/		return 0x821BF020;
		  /* 821BF020h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 821BF020h case    1:*/		if ( regs.CR[0].eq ) { return 0x821BF02C;  }
		/* 821BF020h case    1:*/		return 0x821BF024;
		  /* 821BF024h */ case    2:  		/* rlwinm R11, R10, 0, 11, 9 */
		/* 821BF024h case    2:*/		cpu::op::rlwinm<0,0,11,9>(regs,&regs.R11,regs.R10);
		/* 821BF024h case    2:*/		return 0x821BF028;
		  /* 821BF028h */ case    3:  		/* stw R11, <#[R31 + 48]> */
		/* 821BF028h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000030) );
		/* 821BF028h case    3:*/		return 0x821BF02C;
	}
	return 0x821BF02C;
} // Block from 821BF01Ch-821BF02Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BF02Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF02C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF02C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF02C);
		  /* 821BF02Ch */ case    0:  		/* lwz R11, <#[R29]> */
		/* 821BF02Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 821BF02Ch case    0:*/		return 0x821BF030;
		  /* 821BF030h */ case    1:  		/* cmplw CR6, R11, R30 */
		/* 821BF030h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 821BF030h case    1:*/		return 0x821BF034;
		  /* 821BF034h */ case    2:  		/* bc 4, CR6_EQ, 8 */
		/* 821BF034h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821BF03C;  }
		/* 821BF034h case    2:*/		return 0x821BF038;
		  /* 821BF038h */ case    3:  		/* addi R29, R30, 8 */
		/* 821BF038h case    3:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R30,0x8);
		/* 821BF038h case    3:*/		return 0x821BF03C;
	}
	return 0x821BF03C;
} // Block from 821BF02Ch-821BF03Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BF03Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF03C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF03C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF03C);
		  /* 821BF03Ch */ case    0:  		/* lwz R30, <#[R29]> */
		/* 821BF03Ch case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R29 + 0x00000000) );
		/* 821BF03Ch case    0:*/		return 0x821BF040;
		  /* 821BF040h */ case    1:  		/* b -148 */
		/* 821BF040h case    1:*/		return 0x821BEFAC;
		/* 821BF040h case    1:*/		return 0x821BF044;
	}
	return 0x821BF044;
} // Block from 821BF03Ch-821BF044h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BF044h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF044( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF044) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF044);
		  /* 821BF044h */ case    0:  		/* rlwinm R11, R27, 0, 0, 30 */
		/* 821BF044h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R27);
		/* 821BF044h case    0:*/		return 0x821BF048;
		  /* 821BF048h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 821BF048h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821BF048h case    1:*/		return 0x821BF04C;
		  /* 821BF04Ch */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BF04Ch case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BF04Ch case    2:*/		return 0x821BF050;
		  /* 821BF050h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 821BF050h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BF060;  }
		/* 821BF050h case    3:*/		return 0x821BF054;
		  /* 821BF054h */ case    4:  		/* mr R27, R11 */
		/* 821BF054h case    4:*/		regs.R27 = regs.R11;
		/* 821BF054h case    4:*/		return 0x821BF058;
	}
	return 0x821BF058;
} // Block from 821BF044h-821BF058h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BF058h
// Function '?DecodeArrayLoad@Compiler@D3DXShader@@AAAPAUArrayElementLoad@2@PAVInstruction@2@0PAUArrayLoad@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF058( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF058) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF058);
		  /* 821BF058h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 821BF058h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BF058h case    0:*/		return 0x821BF05C;
		  /* 821BF05Ch */ case    1:  		/* bc 4, CR6_EQ, -476 */
		/* 821BF05Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BEE80;  }
		/* 821BF05Ch case    1:*/		return 0x821BF060;
	}
	return 0x821BF060;
} // Block from 821BF058h-821BF060h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BF060h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF060( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF060) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF060);
		  /* 821BF060h */ case    0:  		/* lwz R11, <#[R26 + 40]> */
		/* 821BF060h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000028) );
		/* 821BF060h case    0:*/		return 0x821BF064;
		  /* 821BF064h */ case    1:  		/* mr R28, R25 */
		/* 821BF064h case    1:*/		regs.R28 = regs.R25;
		/* 821BF064h case    1:*/		return 0x821BF068;
		  /* 821BF068h */ case    2:  		/* lwz R30, <#[R26 + 4]> */
		/* 821BF068h case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R26 + 0x00000004) );
		/* 821BF068h case    2:*/		return 0x821BF06C;
		  /* 821BF06Ch */ case    3:  		/* ori R10, R11, 4096 */
		/* 821BF06Ch case    3:*/		cpu::op::ori<0>(regs,&regs.R10,regs.R11,0x1000);
		/* 821BF06Ch case    3:*/		return 0x821BF070;
		  /* 821BF070h */ case    4:  		/* rlwinm. R9, R30, 0, 31, 31 */
		/* 821BF070h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R30);
		/* 821BF070h case    4:*/		return 0x821BF074;
		  /* 821BF074h */ case    5:  		/* rlwinm R27, R11, 20, 31, 31 */
		/* 821BF074h case    5:*/		cpu::op::rlwinm<0,20,31,31>(regs,&regs.R27,regs.R11);
		/* 821BF074h case    5:*/		return 0x821BF078;
		  /* 821BF078h */ case    6:  		/* stw R10, <#[R26 + 40]> */
		/* 821BF078h case    6:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R26 + 0x00000028) );
		/* 821BF078h case    6:*/		return 0x821BF07C;
		  /* 821BF07Ch */ case    7:  		/* bc 4, CR0_EQ, 420 */
		/* 821BF07Ch case    7:*/		if ( !regs.CR[0].eq ) { return 0x821BF220;  }
		/* 821BF07Ch case    7:*/		return 0x821BF080;
		  /* 821BF080h */ case    8:  		/* cmplwi CR0, R30, 0 */
		/* 821BF080h case    8:*/		cpu::op::cmplwi<0>(regs,regs.R30,0x00000000);
		/* 821BF080h case    8:*/		return 0x821BF084;
		  /* 821BF084h */ case    9:  		/* bc 12, CR0_EQ, 412 */
		/* 821BF084h case    9:*/		if ( regs.CR[0].eq ) { return 0x821BF220;  }
		/* 821BF084h case    9:*/		return 0x821BF088;
		  /* 821BF088h */ case   10:  		/* lwz R11, <#[R30 + 44]> */
		/* 821BF088h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000002C) );
		/* 821BF088h case   10:*/		return 0x821BF08C;
		  /* 821BF08Ch */ case   11:  		/* cmplw CR6, R11, R24 */
		/* 821BF08Ch case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R24);
		/* 821BF08Ch case   11:*/		return 0x821BF090;
		  /* 821BF090h */ case   12:  		/* bc 4, CR6_EQ, 276 */
		/* 821BF090h case   12:*/		if ( !regs.CR[6].eq ) { return 0x821BF1A4;  }
		/* 821BF090h case   12:*/		return 0x821BF094;
		  /* 821BF094h */ case   13:  		/* lwz R11, <#[R30 + 36]> */
		/* 821BF094h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000024) );
		/* 821BF094h case   13:*/		return 0x821BF098;
		  /* 821BF098h */ case   14:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821BF098h case   14:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821BF098h case   14:*/		return 0x821BF09C;
		  /* 821BF09Ch */ case   15:  		/* bc 12, CR0_EQ, 40 */
		/* 821BF09Ch case   15:*/		if ( regs.CR[0].eq ) { return 0x821BF0C4;  }
		/* 821BF09Ch case   15:*/		return 0x821BF0A0;
		  /* 821BF0A0h */ case   16:  		/* lwz R11, <#[R30 + 28]> */
		/* 821BF0A0h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 821BF0A0h case   16:*/		return 0x821BF0A4;
		  /* 821BF0A4h */ case   17:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821BF0A4h case   17:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821BF0A4h case   17:*/		return 0x821BF0A8;
		  /* 821BF0A8h */ case   18:  		/* bc 12, CR0_EQ, 16 */
		/* 821BF0A8h case   18:*/		if ( regs.CR[0].eq ) { return 0x821BF0B8;  }
		/* 821BF0A8h case   18:*/		return 0x821BF0AC;
		  /* 821BF0ACh */ case   19:  		/* lwz R11, <#[R30 + 20]> */
		/* 821BF0ACh case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000014) );
		/* 821BF0ACh case   19:*/		return 0x821BF0B0;
		  /* 821BF0B0h */ case   20:  		/* addi R29, R30, 16 */
		/* 821BF0B0h case   20:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R30,0x10);
		/* 821BF0B0h case   20:*/		return 0x821BF0B4;
		  /* 821BF0B4h */ case   21:  		/* b 24 */
		/* 821BF0B4h case   21:*/		return 0x821BF0CC;
		/* 821BF0B4h case   21:*/		return 0x821BF0B8;
	}
	return 0x821BF0B8;
} // Block from 821BF060h-821BF0B8h (22 instructions)

//////////////////////////////////////////////////////
// Block at 821BF0B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF0B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF0B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF0B8);
		  /* 821BF0B8h */ case    0:  		/* lwz R11, <#[R30 + 28]> */
		/* 821BF0B8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x0000001C) );
		/* 821BF0B8h case    0:*/		return 0x821BF0BC;
		  /* 821BF0BCh */ case    1:  		/* addi R29, R30, 24 */
		/* 821BF0BCh case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R30,0x18);
		/* 821BF0BCh case    1:*/		return 0x821BF0C0;
		  /* 821BF0C0h */ case    2:  		/* b 12 */
		/* 821BF0C0h case    2:*/		return 0x821BF0CC;
		/* 821BF0C0h case    2:*/		return 0x821BF0C4;
	}
	return 0x821BF0C4;
} // Block from 821BF0B8h-821BF0C4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BF0C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF0C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF0C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF0C4);
		  /* 821BF0C4h */ case    0:  		/* lwz R11, <#[R30 + 36]> */
		/* 821BF0C4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000024) );
		/* 821BF0C4h case    0:*/		return 0x821BF0C8;
		  /* 821BF0C8h */ case    1:  		/* addi R29, R30, 32 */
		/* 821BF0C8h case    1:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R30,0x20);
		/* 821BF0C8h case    1:*/		return 0x821BF0CC;
	}
	return 0x821BF0CC;
} // Block from 821BF0C4h-821BF0CCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BF0CCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF0CC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF0CC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF0CC);
		  /* 821BF0CCh */ case    0:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821BF0CCh case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821BF0CCh case    0:*/		return 0x821BF0D0;
		  /* 821BF0D0h */ case    1:  		/* bc 12, CR0_EQ, 140 */
		/* 821BF0D0h case    1:*/		if ( regs.CR[0].eq ) { return 0x821BF15C;  }
		/* 821BF0D0h case    1:*/		return 0x821BF0D4;
		  /* 821BF0D4h */ case    2:  		/* mr R31, R25 */
		/* 821BF0D4h case    2:*/		regs.R31 = regs.R25;
		/* 821BF0D4h case    2:*/		return 0x821BF0D8;
		  /* 821BF0D8h */ case    3:  		/* b 144 */
		/* 821BF0D8h case    3:*/		return 0x821BF168;
		/* 821BF0D8h case    3:*/		return 0x821BF0DC;
		  /* 821BF0DCh */ case    4:  		/* lwz R11, <#[R31 + 8]> */
		/* 821BF0DCh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821BF0DCh case    4:*/		return 0x821BF0E0;
		  /* 821BF0E0h */ case    5:  		/* li R6, 1 */
		/* 821BF0E0h case    5:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821BF0E0h case    5:*/		return 0x821BF0E4;
		  /* 821BF0E4h */ case    6:  		/* li R5, 0 */
		/* 821BF0E4h case    6:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821BF0E4h case    6:*/		return 0x821BF0E8;
		  /* 821BF0E8h */ case    7:  		/* rlwinm R11, R11, 0, 7, 5 */
		/* 821BF0E8h case    7:*/		cpu::op::rlwinm<0,0,7,5>(regs,&regs.R11,regs.R11);
		/* 821BF0E8h case    7:*/		return 0x821BF0EC;
		  /* 821BF0ECh */ case    8:  		/* mr R4, R31 */
		/* 821BF0ECh case    8:*/		regs.R4 = regs.R31;
		/* 821BF0ECh case    8:*/		return 0x821BF0F0;
		  /* 821BF0F0h */ case    9:  		/* stw R11, <#[R31 + 8]> */
		/* 821BF0F0h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821BF0F0h case    9:*/		return 0x821BF0F4;
		  /* 821BF0F4h */ case   10:  		/* mr R3, R26 */
		/* 821BF0F4h case   10:*/		regs.R3 = regs.R26;
		/* 821BF0F4h case   10:*/		return 0x821BF0F8;
		  /* 821BF0F8h */ case   11:  		/* bl 443088 */
		/* 821BF0F8h case   11:*/		regs.LR = 0x821BF0FC; return 0x8222B3C8;
		/* 821BF0F8h case   11:*/		return 0x821BF0FC;
		  /* 821BF0FCh */ case   12:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821BF0FCh case   12:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821BF0FCh case   12:*/		return 0x821BF100;
		  /* 821BF100h */ case   13:  		/* lwz R11, <#[R11 + 36]> */
		/* 821BF100h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 821BF100h case   13:*/		return 0x821BF104;
		  /* 821BF104h */ case   14:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BF104h case   14:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BF104h case   14:*/		return 0x821BF108;
		  /* 821BF108h */ case   15:  		/* bc 4, CR0_EQ, 16 */
		/* 821BF108h case   15:*/		if ( !regs.CR[0].eq ) { return 0x821BF118;  }
		/* 821BF108h case   15:*/		return 0x821BF10C;
		  /* 821BF10Ch */ case   16:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821BF10Ch case   16:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821BF10Ch case   16:*/		return 0x821BF110;
		  /* 821BF110h */ case   17:  		/* addic. R31, R11, -40 */
		/* 821BF110h case   17:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R11,0xFFFFFFD8);
		/* 821BF110h case   17:*/		return 0x821BF114;
		  /* 821BF114h */ case   18:  		/* bc 4, CR0_EQ, -56 */
		/* 821BF114h case   18:*/		if ( !regs.CR[0].eq ) { return 0x821BF0DC;  }
		/* 821BF114h case   18:*/		return 0x821BF118;
	}
	return 0x821BF118;
} // Block from 821BF0CCh-821BF118h (19 instructions)

//////////////////////////////////////////////////////
// Block at 821BF118h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF118( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF118) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF118);
		  /* 821BF118h */ case    0:  		/* addi R10, R30, 16 */
		/* 821BF118h case    0:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R30,0x10);
		/* 821BF118h case    0:*/		return 0x821BF11C;
		  /* 821BF11Ch */ case    1:  		/* cmplw CR6, R29, R10 */
		/* 821BF11Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R10);
		/* 821BF11Ch case    1:*/		return 0x821BF120;
		  /* 821BF120h */ case    2:  		/* bc 12, CR6_EQ, 80 */
		/* 821BF120h case    2:*/		if ( regs.CR[6].eq ) { return 0x821BF170;  }
		/* 821BF120h case    2:*/		return 0x821BF124;
		  /* 821BF124h */ case    3:  		/* addi R11, R30, 24 */
		/* 821BF124h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0x18);
		/* 821BF124h case    3:*/		return 0x821BF128;
		  /* 821BF128h */ case    4:  		/* cmplw CR6, R29, R11 */
		/* 821BF128h case    4:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 821BF128h case    4:*/		return 0x821BF12C;
		  /* 821BF12Ch */ case    5:  		/* bc 12, CR6_EQ, 32 */
		/* 821BF12Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x821BF14C;  }
		/* 821BF12Ch case    5:*/		return 0x821BF130;
		  /* 821BF130h */ case    6:  		/* lwz R9, <#[R30 + 28]> */
		/* 821BF130h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R30 + 0x0000001C) );
		/* 821BF130h case    6:*/		return 0x821BF134;
		  /* 821BF134h */ case    7:  		/* rlwinm. R9, R9, 0, 31, 31 */
		/* 821BF134h case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R9);
		/* 821BF134h case    7:*/		return 0x821BF138;
		  /* 821BF138h */ case    8:  		/* bc 4, CR0_EQ, 20 */
		/* 821BF138h case    8:*/		if ( !regs.CR[0].eq ) { return 0x821BF14C;  }
		/* 821BF138h case    8:*/		return 0x821BF13C;
		  /* 821BF13Ch */ case    9:  		/* lwz R10, <#[R11 + 4]> */
		/* 821BF13Ch case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821BF13Ch case    9:*/		return 0x821BF140;
		  /* 821BF140h */ case   10:  		/* mr R29, R11 */
		/* 821BF140h case   10:*/		regs.R29 = regs.R11;
		/* 821BF140h case   10:*/		return 0x821BF144;
		  /* 821BF144h */ case   11:  		/* rlwinm. R11, R10, 0, 31, 31 */
		/* 821BF144h case   11:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R10);
		/* 821BF144h case   11:*/		return 0x821BF148;
		  /* 821BF148h */ case   12:  		/* b 16 */
		/* 821BF148h case   12:*/		return 0x821BF158;
		/* 821BF148h case   12:*/		return 0x821BF14C;
	}
	return 0x821BF14C;
} // Block from 821BF118h-821BF14Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 821BF14Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF14C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF14C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF14C);
		  /* 821BF14Ch */ case    0:  		/* lwz R11, <#[R10 + 4]> */
		/* 821BF14Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000004) );
		/* 821BF14Ch case    0:*/		return 0x821BF150;
		  /* 821BF150h */ case    1:  		/* mr R29, R10 */
		/* 821BF150h case    1:*/		regs.R29 = regs.R10;
		/* 821BF150h case    1:*/		return 0x821BF154;
		  /* 821BF154h */ case    2:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821BF154h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821BF154h case    2:*/		return 0x821BF158;
	}
	return 0x821BF158;
} // Block from 821BF14Ch-821BF158h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BF158h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF158( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF158) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF158);
		  /* 821BF158h */ case    0:  		/* bc 4, CR0_EQ, 24 */
		/* 821BF158h case    0:*/		if ( !regs.CR[0].eq ) { return 0x821BF170;  }
		/* 821BF158h case    0:*/		return 0x821BF15C;
	}
	return 0x821BF15C;
} // Block from 821BF158h-821BF15Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BF15Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF15C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF15C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF15C);
		  /* 821BF15Ch */ case    0:  		/* lwz R11, <#[R29]> */
		/* 821BF15Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 821BF15Ch case    0:*/		return 0x821BF160;
		  /* 821BF160h */ case    1:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821BF160h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821BF160h case    1:*/		return 0x821BF164;
		  /* 821BF164h */ case    2:  		/* addi R31, R11, -40 */
		/* 821BF164h case    2:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R11,0xFFFFFFD8);
		/* 821BF164h case    2:*/		return 0x821BF168;
	}
	return 0x821BF168;
} // Block from 821BF15Ch-821BF168h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BF168h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF168( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF168) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF168);
		  /* 821BF168h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 821BF168h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821BF168h case    0:*/		return 0x821BF16C;
		  /* 821BF16Ch */ case    1:  		/* bc 4, CR6_EQ, -144 */
		/* 821BF16Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BF0DC;  }
		/* 821BF16Ch case    1:*/		return 0x821BF170;
	}
	return 0x821BF170;
} // Block from 821BF168h-821BF170h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BF170h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF170( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF170) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF170);
		  /* 821BF170h */ case    0:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 821BF170h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 821BF170h case    0:*/		return 0x821BF174;
		  /* 821BF174h */ case    1:  		/* lwz R10, <#[R11 + 4]> */
		/* 821BF174h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821BF174h case    1:*/		return 0x821BF178;
		  /* 821BF178h */ case    2:  		/* lwz R9, <#[R11]> */
		/* 821BF178h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821BF178h case    2:*/		return 0x821BF17C;
		  /* 821BF17Ch */ case    3:  		/* rlwinm R10, R10, 0, 0, 30 */
		/* 821BF17Ch case    3:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R10,regs.R10);
		/* 821BF17Ch case    3:*/		return 0x821BF180;
		  /* 821BF180h */ case    4:  		/* stw R9, <#[R10]> */
		/* 821BF180h case    4:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821BF180h case    4:*/		return 0x821BF184;
		  /* 821BF184h */ case    5:  		/* lwz R10, <#[R11 + 4]> */
		/* 821BF184h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000004) );
		/* 821BF184h case    5:*/		return 0x821BF188;
		  /* 821BF188h */ case    6:  		/* lwz R11, <#[R11]> */
		/* 821BF188h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821BF188h case    6:*/		return 0x821BF18C;
		  /* 821BF18Ch */ case    7:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821BF18Ch case    7:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821BF18Ch case    7:*/		return 0x821BF190;
		  /* 821BF190h */ case    8:  		/* stw R10, <#[R11]> */
		/* 821BF190h case    8:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821BF190h case    8:*/		return 0x821BF194;
		  /* 821BF194h */ case    9:  		/* lwz R11, <#[R30 + 48]> */
		/* 821BF194h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000030) );
		/* 821BF194h case    9:*/		return 0x821BF198;
		  /* 821BF198h */ case   10:  		/* oris R11, R11, 64 */
		/* 821BF198h case   10:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x40);
		/* 821BF198h case   10:*/		return 0x821BF19C;
		  /* 821BF19Ch */ case   11:  		/* stw R11, <#[R30 + 48]> */
		/* 821BF19Ch case   11:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000030) );
		/* 821BF19Ch case   11:*/		return 0x821BF1A0;
		  /* 821BF1A0h */ case   12:  		/* stw R25, <#[R30 + 80]> */
		/* 821BF1A0h case   12:*/		cpu::mem::store32( regs, regs.R25, (uint32)(regs.R30 + 0x00000050) );
		/* 821BF1A0h case   12:*/		return 0x821BF1A4;
	}
	return 0x821BF1A4;
} // Block from 821BF170h-821BF1A4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821BF1A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF1A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF1A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF1A4);
		  /* 821BF1A4h */ case    0:  		/* cmplwi CR6, R28, 0 */
		/* 821BF1A4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R28,0x00000000);
		/* 821BF1A4h case    0:*/		return 0x821BF1A8;
		  /* 821BF1A8h */ case    1:  		/* bc 12, CR6_EQ, 48 */
		/* 821BF1A8h case    1:*/		if ( regs.CR[6].eq ) { return 0x821BF1D8;  }
		/* 821BF1A8h case    1:*/		return 0x821BF1AC;
		  /* 821BF1ACh */ case    2:  		/* rlwinm R11, R28, 0, 0, 30 */
		/* 821BF1ACh case    2:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R28);
		/* 821BF1ACh case    2:*/		return 0x821BF1B0;
		  /* 821BF1B0h */ case    3:  		/* lwz R11, <#[R11 + 4]> */
		/* 821BF1B0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821BF1B0h case    3:*/		return 0x821BF1B4;
		  /* 821BF1B4h */ case    4:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 821BF1B4h case    4:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BF1B4h case    4:*/		return 0x821BF1B8;
		  /* 821BF1B8h */ case    5:  		/* addic R10, R10, -1 */
		/* 821BF1B8h case    5:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 821BF1B8h case    5:*/		return 0x821BF1BC;
		  /* 821BF1BCh */ case    6:  		/* subfe R10, R10, R10 */
		/* 821BF1BCh case    6:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 821BF1BCh case    6:*/		return 0x821BF1C0;
		  /* 821BF1C0h */ case    7:  		/* and R10, R10, R11 */
		/* 821BF1C0h case    7:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 821BF1C0h case    7:*/		return 0x821BF1C4;
		  /* 821BF1C4h */ case    8:  		/* cmplw CR6, R30, R10 */
		/* 821BF1C4h case    8:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R10);
		/* 821BF1C4h case    8:*/		return 0x821BF1C8;
		  /* 821BF1C8h */ case    9:  		/* bc 12, CR6_EQ, 44 */
		/* 821BF1C8h case    9:*/		if ( regs.CR[6].eq ) { return 0x821BF1F4;  }
		/* 821BF1C8h case    9:*/		return 0x821BF1CC;
		  /* 821BF1CCh */ case   10:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BF1CCh case   10:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BF1CCh case   10:*/		return 0x821BF1D0;
		  /* 821BF1D0h */ case   11:  		/* bc 4, CR0_EQ, 80 */
		/* 821BF1D0h case   11:*/		if ( !regs.CR[0].eq ) { return 0x821BF220;  }
		/* 821BF1D0h case   11:*/		return 0x821BF1D4;
		  /* 821BF1D4h */ case   12:  		/* b 64 */
		/* 821BF1D4h case   12:*/		return 0x821BF214;
		/* 821BF1D4h case   12:*/		return 0x821BF1D8;
	}
	return 0x821BF1D8;
} // Block from 821BF1A4h-821BF1D8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821BF1D8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF1D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF1D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF1D8);
		  /* 821BF1D8h */ case    0:  		/* lwz R11, <#[R26 + 4]> */
		/* 821BF1D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000004) );
		/* 821BF1D8h case    0:*/		return 0x821BF1DC;
		  /* 821BF1DCh */ case    1:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 821BF1DCh case    1:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BF1DCh case    1:*/		return 0x821BF1E0;
		  /* 821BF1E0h */ case    2:  		/* addic R9, R10, -1 */
		/* 821BF1E0h case    2:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R10,0xFFFFFFFF);
		/* 821BF1E0h case    2:*/		return 0x821BF1E4;
		  /* 821BF1E4h */ case    3:  		/* subfe R9, R9, R9 */
		/* 821BF1E4h case    3:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 821BF1E4h case    3:*/		return 0x821BF1E8;
		  /* 821BF1E8h */ case    4:  		/* and R9, R9, R11 */
		/* 821BF1E8h case    4:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 821BF1E8h case    4:*/		return 0x821BF1EC;
		  /* 821BF1ECh */ case    5:  		/* cmplw CR6, R30, R9 */
		/* 821BF1ECh case    5:*/		cpu::op::cmplw<6>(regs,regs.R30,regs.R9);
		/* 821BF1ECh case    5:*/		return 0x821BF1F0;
		  /* 821BF1F0h */ case    6:  		/* bc 4, CR6_EQ, 28 */
		/* 821BF1F0h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821BF20C;  }
		/* 821BF1F0h case    6:*/		return 0x821BF1F4;
	}
	return 0x821BF1F4;
} // Block from 821BF1D8h-821BF1F4h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BF1F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF1F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF1F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF1F4);
		  /* 821BF1F4h */ case    0:  		/* rlwinm R11, R30, 0, 0, 30 */
		/* 821BF1F4h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R30);
		/* 821BF1F4h case    0:*/		return 0x821BF1F8;
		  /* 821BF1F8h */ case    1:  		/* mr R28, R30 */
		/* 821BF1F8h case    1:*/		regs.R28 = regs.R30;
		/* 821BF1F8h case    1:*/		return 0x821BF1FC;
		  /* 821BF1FCh */ case    2:  		/* lwz R30, <#[R11 + 4]> */
		/* 821BF1FCh case    2:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R11 + 0x00000004) );
		/* 821BF1FCh case    2:*/		return 0x821BF200;
		  /* 821BF200h */ case    3:  		/* rlwinm. R11, R30, 0, 31, 31 */
		/* 821BF200h case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R30);
		/* 821BF200h case    3:*/		return 0x821BF204;
		  /* 821BF204h */ case    4:  		/* bc 4, CR0_EQ, 28 */
		/* 821BF204h case    4:*/		if ( !regs.CR[0].eq ) { return 0x821BF220;  }
		/* 821BF204h case    4:*/		return 0x821BF208;
		  /* 821BF208h */ case    5:  		/* b 16 */
		/* 821BF208h case    5:*/		return 0x821BF218;
		/* 821BF208h case    5:*/		return 0x821BF20C;
	}
	return 0x821BF20C;
} // Block from 821BF1F4h-821BF20Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BF20Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF20C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF20C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF20C);
		  /* 821BF20Ch */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 821BF20Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821BF20Ch case    0:*/		return 0x821BF210;
	}
	return 0x821BF210;
} // Block from 821BF20Ch-821BF210h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BF210h
// Function '?GetComponentDependency@Compiler@D3DXShader@@QAAPAVDependency@2@PAV32@W4Component@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF210( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF210) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF210);
		  /* 821BF210h */ case    0:  		/* bc 4, CR6_EQ, 16 */
		/* 821BF210h case    0:*/		if ( !regs.CR[6].eq ) { return 0x821BF220;  }
		/* 821BF210h case    0:*/		return 0x821BF214;
	}
	return 0x821BF214;
} // Block from 821BF210h-821BF214h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BF214h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF214( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF214) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF214);
		  /* 821BF214h */ case    0:  		/* mr R30, R11 */
		/* 821BF214h case    0:*/		regs.R30 = regs.R11;
		/* 821BF214h case    0:*/		return 0x821BF218;
	}
	return 0x821BF218;
} // Block from 821BF214h-821BF218h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BF218h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF218( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF218) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF218);
		  /* 821BF218h */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 821BF218h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821BF218h case    0:*/		return 0x821BF21C;
		  /* 821BF21Ch */ case    1:  		/* bc 4, CR6_EQ, -404 */
		/* 821BF21Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BF088;  }
		/* 821BF21Ch case    1:*/		return 0x821BF220;
	}
	return 0x821BF220;
} // Block from 821BF218h-821BF220h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BF220h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF220( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF220) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF220);
		  /* 821BF220h */ case    0:  		/* mr R4, R27 */
		/* 821BF220h case    0:*/		regs.R4 = regs.R27;
		/* 821BF220h case    0:*/		return 0x821BF224;
		  /* 821BF224h */ case    1:  		/* mr R3, R26 */
		/* 821BF224h case    1:*/		regs.R3 = regs.R26;
		/* 821BF224h case    1:*/		return 0x821BF228;
		  /* 821BF228h */ case    2:  		/* bl -369976 */
		/* 821BF228h case    2:*/		regs.LR = 0x821BF22C; return 0x82164CF0;
		/* 821BF228h case    2:*/		return 0x821BF22C;
		  /* 821BF22Ch */ case    3:  		/* addi R1, R1, 160 */
		/* 821BF22Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xA0);
		/* 821BF22Ch case    3:*/		return 0x821BF230;
		  /* 821BF230h */ case    4:  		/* b -1236888 */
		/* 821BF230h case    4:*/		return 0x82091298;
		/* 821BF230h case    4:*/		return 0x821BF234;
		  /* 821BF234h */ case    5:  		/* nop */
		/* 821BF234h case    5:*/		cpu::op::nop();
		/* 821BF234h case    5:*/		return 0x821BF238;
	}
	return 0x821BF238;
} // Block from 821BF220h-821BF238h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BF238h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF238( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF238) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF238);
		  /* 821BF238h */ case    0:  		/* mfspr R12, LR */
		/* 821BF238h case    0:*/		regs.R12 = regs.LR;
		/* 821BF238h case    0:*/		return 0x821BF23C;
		  /* 821BF23Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821BF23Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821BF23Ch case    1:*/		return 0x821BF240;
		  /* 821BF240h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 821BF240h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821BF240h case    2:*/		return 0x821BF244;
		  /* 821BF244h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 821BF244h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821BF244h case    3:*/		return 0x821BF248;
		  /* 821BF248h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 821BF248h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821BF248h case    4:*/		return 0x821BF24C;
		  /* 821BF24Ch */ case    5:  		/* lwz R31, <#[R4 + 64]> */
		/* 821BF24Ch case    5:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R4 + 0x00000040) );
		/* 821BF24Ch case    5:*/		return 0x821BF250;
		  /* 821BF250h */ case    6:  		/* mr R30, R3 */
		/* 821BF250h case    6:*/		regs.R30 = regs.R3;
		/* 821BF250h case    6:*/		return 0x821BF254;
		  /* 821BF254h */ case    7:  		/* b 104 */
		/* 821BF254h case    7:*/		return 0x821BF2BC;
		/* 821BF254h case    7:*/		return 0x821BF258;
		  /* 821BF258h */ case    8:  		/* lwz R11, <#[R31 + 36]> */
		/* 821BF258h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 821BF258h case    8:*/		return 0x821BF25C;
		  /* 821BF25Ch */ case    9:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821BF25Ch case    9:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821BF25Ch case    9:*/		return 0x821BF260;
		  /* 821BF260h */ case   10:  		/* bc 12, CR0_EQ, 12 */
		/* 821BF260h case   10:*/		if ( regs.CR[0].eq ) { return 0x821BF26C;  }
		/* 821BF260h case   10:*/		return 0x821BF264;
		  /* 821BF264h */ case   11:  		/* li R3, 0 */
		/* 821BF264h case   11:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821BF264h case   11:*/		return 0x821BF268;
		  /* 821BF268h */ case   12:  		/* b 16 */
		/* 821BF268h case   12:*/		return 0x821BF278;
		/* 821BF268h case   12:*/		return 0x821BF26C;
	}
	return 0x821BF26C;
} // Block from 821BF238h-821BF26Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 821BF26Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF26C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF26C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF26C);
		  /* 821BF26Ch */ case    0:  		/* lwz R11, <#[R31 + 32]> */
		/* 821BF26Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000020) );
		/* 821BF26Ch case    0:*/		return 0x821BF270;
		  /* 821BF270h */ case    1:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821BF270h case    1:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821BF270h case    1:*/		return 0x821BF274;
		  /* 821BF274h */ case    2:  		/* addi R3, R11, -40 */
		/* 821BF274h case    2:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R11,0xFFFFFFD8);
		/* 821BF274h case    2:*/		return 0x821BF278;
	}
	return 0x821BF278;
} // Block from 821BF26Ch-821BF278h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BF278h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF278( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF278) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF278);
		  /* 821BF278h */ case    0:  		/* lwz R11, <#[R3 + 8]> */
		/* 821BF278h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000008) );
		/* 821BF278h case    0:*/		return 0x821BF27C;
		  /* 821BF27Ch */ case    1:  		/* rlwinm R10, R11, 0, 18, 24 */
		/* 821BF27Ch case    1:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R11);
		/* 821BF27Ch case    1:*/		return 0x821BF280;
		  /* 821BF280h */ case    2:  		/* cmplwi CR6, R10, 11520 */
		/* 821BF280h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00002D00);
		/* 821BF280h case    2:*/		return 0x821BF284;
		  /* 821BF284h */ case    3:  		/* bc 4, CR6_EQ, 52 */
		/* 821BF284h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821BF2B8;  }
		/* 821BF284h case    3:*/		return 0x821BF288;
	}
	return 0x821BF288;
} // Block from 821BF278h-821BF288h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BF288h
// Function '?RemoveAllDependents@Instruction@D3DXShader@@QAAXPAVCompiler@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF288( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF288) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF288);
		  /* 821BF288h */ case    0:  		/* rlwinm. R11, R11, 5, 31, 31 */
		/* 821BF288h case    0:*/		cpu::op::rlwinm<1,5,31,31>(regs,&regs.R11,regs.R11);
		/* 821BF288h case    0:*/		return 0x821BF28C;
		  /* 821BF28Ch */ case    1:  		/* bc 4, CR0_EQ, 84 */
		/* 821BF28Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x821BF2E0;  }
		/* 821BF28Ch case    1:*/		return 0x821BF290;
		  /* 821BF290h */ case    2:  		/* mr R4, R30 */
		/* 821BF290h case    2:*/		regs.R4 = regs.R30;
		/* 821BF290h case    2:*/		return 0x821BF294;
		  /* 821BF294h */ case    3:  		/* bl -371468 */
		/* 821BF294h case    3:*/		regs.LR = 0x821BF298; return 0x82164788;
		/* 821BF294h case    3:*/		return 0x821BF298;
		  /* 821BF298h */ case    4:  		/* cmpwi CR6, R3, 3 */
		/* 821BF298h case    4:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000003);
		/* 821BF298h case    4:*/		return 0x821BF29C;
		  /* 821BF29Ch */ case    5:  		/* bc 12, CR6_EQ, 68 */
		/* 821BF29Ch case    5:*/		if ( regs.CR[6].eq ) { return 0x821BF2E0;  }
		/* 821BF29Ch case    5:*/		return 0x821BF2A0;
		  /* 821BF2A0h */ case    6:  		/* cmpwi CR6, R3, 4 */
		/* 821BF2A0h case    6:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000004);
		/* 821BF2A0h case    6:*/		return 0x821BF2A4;
		  /* 821BF2A4h */ case    7:  		/* bc 12, CR6_EQ, 60 */
		/* 821BF2A4h case    7:*/		if ( regs.CR[6].eq ) { return 0x821BF2E0;  }
		/* 821BF2A4h case    7:*/		return 0x821BF2A8;
		  /* 821BF2A8h */ case    8:  		/* cmpwi CR6, R3, 8 */
		/* 821BF2A8h case    8:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000008);
		/* 821BF2A8h case    8:*/		return 0x821BF2AC;
		  /* 821BF2ACh */ case    9:  		/* bc 12, CR6_EQ, 24 */
		/* 821BF2ACh case    9:*/		if ( regs.CR[6].eq ) { return 0x821BF2C4;  }
		/* 821BF2ACh case    9:*/		return 0x821BF2B0;
		  /* 821BF2B0h */ case   10:  		/* cmpwi CR6, R3, 9 */
		/* 821BF2B0h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R3,0x00000009);
		/* 821BF2B0h case   10:*/		return 0x821BF2B4;
		  /* 821BF2B4h */ case   11:  		/* bc 12, CR6_EQ, 16 */
		/* 821BF2B4h case   11:*/		if ( regs.CR[6].eq ) { return 0x821BF2C4;  }
		/* 821BF2B4h case   11:*/		return 0x821BF2B8;
	}
	return 0x821BF2B8;
} // Block from 821BF288h-821BF2B8h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821BF2B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF2B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF2B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF2B8);
		  /* 821BF2B8h */ case    0:  		/* lwz R31, <#[R31 + 64]> */
		/* 821BF2B8h case    0:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000040) );
		/* 821BF2B8h case    0:*/		return 0x821BF2BC;
	}
	return 0x821BF2BC;
} // Block from 821BF2B8h-821BF2BCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BF2BCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF2BC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF2BC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF2BC);
		  /* 821BF2BCh */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 821BF2BCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821BF2BCh case    0:*/		return 0x821BF2C0;
		  /* 821BF2C0h */ case    1:  		/* bc 4, CR6_EQ, -104 */
		/* 821BF2C0h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BF258;  }
		/* 821BF2C0h case    1:*/		return 0x821BF2C4;
	}
	return 0x821BF2C4;
} // Block from 821BF2BCh-821BF2C4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BF2C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF2C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF2C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF2C4);
		  /* 821BF2C4h */ case    0:  		/* li R3, 0 */
		/* 821BF2C4h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821BF2C4h case    0:*/		return 0x821BF2C8;
		  /* 821BF2C8h */ case    1:  		/* addi R1, R1, 112 */
		/* 821BF2C8h case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821BF2C8h case    1:*/		return 0x821BF2CC;
		  /* 821BF2CCh */ case    2:  		/* lwz R12, <#[R1 - 8]> */
		/* 821BF2CCh case    2:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821BF2CCh case    2:*/		return 0x821BF2D0;
		  /* 821BF2D0h */ case    3:  		/* mtspr LR, R12 */
		/* 821BF2D0h case    3:*/		regs.LR = regs.R12;
		/* 821BF2D0h case    3:*/		return 0x821BF2D4;
		  /* 821BF2D4h */ case    4:  		/* ld R30, <#[R1 - 24]> */
		/* 821BF2D4h case    4:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821BF2D4h case    4:*/		return 0x821BF2D8;
		  /* 821BF2D8h */ case    5:  		/* ld R31, <#[R1 - 16]> */
		/* 821BF2D8h case    5:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821BF2D8h case    5:*/		return 0x821BF2DC;
		  /* 821BF2DCh */ case    6:  		/* bclr 20, CR0_LT */
		/* 821BF2DCh case    6:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BF2DCh case    6:*/		return 0x821BF2E0;
	}
	return 0x821BF2E0;
} // Block from 821BF2C4h-821BF2E0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BF2E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF2E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF2E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF2E0);
		  /* 821BF2E0h */ case    0:  		/* li R3, 1 */
		/* 821BF2E0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821BF2E0h case    0:*/		return 0x821BF2E4;
		  /* 821BF2E4h */ case    1:  		/* b -28 */
		/* 821BF2E4h case    1:*/		return 0x821BF2C8;
		/* 821BF2E4h case    1:*/		return 0x821BF2E8;
	}
	return 0x821BF2E8;
} // Block from 821BF2E0h-821BF2E8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BF2E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF2E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF2E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF2E8);
		  /* 821BF2E8h */ case    0:  		/* mfspr R12, LR */
		/* 821BF2E8h case    0:*/		regs.R12 = regs.LR;
		/* 821BF2E8h case    0:*/		return 0x821BF2EC;
		  /* 821BF2ECh */ case    1:  		/* bl -1237148 */
		/* 821BF2ECh case    1:*/		regs.LR = 0x821BF2F0; return 0x82091250;
		/* 821BF2ECh case    1:*/		return 0x821BF2F0;
		  /* 821BF2F0h */ case    2:  		/* stwu R1, <#[R1 - 144]> */
		/* 821BF2F0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF70) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF70);
		/* 821BF2F0h case    2:*/		return 0x821BF2F4;
		  /* 821BF2F4h */ case    3:  		/* mr R27, R3 */
		/* 821BF2F4h case    3:*/		regs.R27 = regs.R3;
		/* 821BF2F4h case    3:*/		return 0x821BF2F8;
		  /* 821BF2F8h */ case    4:  		/* mr R26, R4 */
		/* 821BF2F8h case    4:*/		regs.R26 = regs.R4;
		/* 821BF2F8h case    4:*/		return 0x821BF2FC;
		  /* 821BF2FCh */ case    5:  		/* lwz R11, <#[R27 + 4]> */
		/* 821BF2FCh case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 821BF2FCh case    5:*/		return 0x821BF300;
	}
	return 0x821BF300;
} // Block from 821BF2E8h-821BF300h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BF300h
// Function '?CleanClonedDependencies@Compiler@D3DXShader@@AAAXPAVBlock@2@PA_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF300( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF300) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF300);
		  /* 821BF300h */ case    0:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BF300h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BF300h case    0:*/		return 0x821BF304;
		  /* 821BF304h */ case    1:  		/* bc 4, CR0_EQ, 460 */
		/* 821BF304h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821BF4D0;  }
		/* 821BF304h case    1:*/		return 0x821BF308;
		  /* 821BF308h */ case    2:  		/* mr R29, R11 */
		/* 821BF308h case    2:*/		regs.R29 = regs.R11;
		/* 821BF308h case    2:*/		return 0x821BF30C;
		  /* 821BF30Ch */ case    3:  		/* cmplwi CR0, R11, 0 */
		/* 821BF30Ch case    3:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821BF30Ch case    3:*/		return 0x821BF310;
		  /* 821BF310h */ case    4:  		/* bc 12, CR0_EQ, 448 */
		/* 821BF310h case    4:*/		if ( regs.CR[0].eq ) { return 0x821BF4D0;  }
		/* 821BF310h case    4:*/		return 0x821BF314;
		  /* 821BF314h */ case    5:  		/* lwz R11, <#[R29 + 44]> */
		/* 821BF314h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000002C) );
		/* 821BF314h case    5:*/		return 0x821BF318;
		  /* 821BF318h */ case    6:  		/* cmplw CR6, R11, R26 */
		/* 821BF318h case    6:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 821BF318h case    6:*/		return 0x821BF31C;
		  /* 821BF31Ch */ case    7:  		/* bc 12, CR6_EQ, 196 */
		/* 821BF31Ch case    7:*/		if ( regs.CR[6].eq ) { return 0x821BF3E0;  }
		/* 821BF31Ch case    7:*/		return 0x821BF320;
		  /* 821BF320h */ case    8:  		/* lwz R11, <#[R29 + 20]> */
		/* 821BF320h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000014) );
		/* 821BF320h case    8:*/		return 0x821BF324;
		  /* 821BF324h */ case    9:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821BF324h case    9:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821BF324h case    9:*/		return 0x821BF328;
		  /* 821BF328h */ case   10:  		/* bc 12, CR0_EQ, 40 */
		/* 821BF328h case   10:*/		if ( regs.CR[0].eq ) { return 0x821BF350;  }
		/* 821BF328h case   10:*/		return 0x821BF32C;
		  /* 821BF32Ch */ case   11:  		/* lwz R11, <#[R29 + 28]> */
		/* 821BF32Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000001C) );
		/* 821BF32Ch case   11:*/		return 0x821BF330;
		  /* 821BF330h */ case   12:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821BF330h case   12:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821BF330h case   12:*/		return 0x821BF334;
		  /* 821BF334h */ case   13:  		/* bc 12, CR0_EQ, 16 */
		/* 821BF334h case   13:*/		if ( regs.CR[0].eq ) { return 0x821BF344;  }
		/* 821BF334h case   13:*/		return 0x821BF338;
		  /* 821BF338h */ case   14:  		/* lwz R11, <#[R29 + 36]> */
		/* 821BF338h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000024) );
		/* 821BF338h case   14:*/		return 0x821BF33C;
		  /* 821BF33Ch */ case   15:  		/* addi R10, R29, 32 */
		/* 821BF33Ch case   15:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R29,0x20);
		/* 821BF33Ch case   15:*/		return 0x821BF340;
		  /* 821BF340h */ case   16:  		/* b 24 */
		/* 821BF340h case   16:*/		return 0x821BF358;
		/* 821BF340h case   16:*/		return 0x821BF344;
	}
	return 0x821BF344;
} // Block from 821BF300h-821BF344h (17 instructions)

//////////////////////////////////////////////////////
// Block at 821BF344h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF344( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF344) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF344);
		  /* 821BF344h */ case    0:  		/* lwz R11, <#[R29 + 28]> */
		/* 821BF344h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000001C) );
		/* 821BF344h case    0:*/		return 0x821BF348;
		  /* 821BF348h */ case    1:  		/* addi R10, R29, 24 */
		/* 821BF348h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R29,0x18);
		/* 821BF348h case    1:*/		return 0x821BF34C;
		  /* 821BF34Ch */ case    2:  		/* b 12 */
		/* 821BF34Ch case    2:*/		return 0x821BF358;
		/* 821BF34Ch case    2:*/		return 0x821BF350;
	}
	return 0x821BF350;
} // Block from 821BF344h-821BF350h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BF350h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF350( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF350) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF350);
		  /* 821BF350h */ case    0:  		/* lwz R11, <#[R29 + 20]> */
		/* 821BF350h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000014) );
		/* 821BF350h case    0:*/		return 0x821BF354;
		  /* 821BF354h */ case    1:  		/* addi R10, R29, 16 */
		/* 821BF354h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R29,0x10);
		/* 821BF354h case    1:*/		return 0x821BF358;
	}
	return 0x821BF358;
} // Block from 821BF350h-821BF358h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BF358h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF358( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF358) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF358);
		  /* 821BF358h */ case    0:  		/* rlwinm R9, R11, 0, 31, 31 */
		/* 821BF358h case    0:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R9,regs.R11);
		/* 821BF358h case    0:*/		return 0x821BF35C;
		  /* 821BF35Ch */ case    1:  		/* addic R9, R9, -1 */
		/* 821BF35Ch case    1:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 821BF35Ch case    1:*/		return 0x821BF360;
		  /* 821BF360h */ case    2:  		/* subfe R9, R9, R9 */
		/* 821BF360h case    2:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 821BF360h case    2:*/		return 0x821BF364;
		  /* 821BF364h */ case    3:  		/* and R11, R9, R11 */
		/* 821BF364h case    3:*/		cpu::op::and<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 821BF364h case    3:*/		return 0x821BF368;
		  /* 821BF368h */ case    4:  		/* b 104 */
		/* 821BF368h case    4:*/		return 0x821BF3D0;
		/* 821BF368h case    4:*/		return 0x821BF36C;
		  /* 821BF36Ch */ case    5:  		/* lwz R9, <#[R11 + 8]> */
		/* 821BF36Ch case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 821BF36Ch case    5:*/		return 0x821BF370;
		  /* 821BF370h */ case    6:  		/* rlwinm. R9, R9, 6, 31, 31 */
		/* 821BF370h case    6:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R9,regs.R9);
		/* 821BF370h case    6:*/		return 0x821BF374;
		  /* 821BF374h */ case    7:  		/* bc 4, CR0_EQ, 104 */
		/* 821BF374h case    7:*/		if ( !regs.CR[0].eq ) { return 0x821BF3DC;  }
		/* 821BF374h case    7:*/		return 0x821BF378;
		  /* 821BF378h */ case    8:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821BF378h case    8:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821BF378h case    8:*/		return 0x821BF37C;
		  /* 821BF37Ch */ case    9:  		/* lwz R11, <#[R11 + 40]> */
		/* 821BF37Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 821BF37Ch case    9:*/		return 0x821BF380;
		  /* 821BF380h */ case   10:  		/* rlwinm. R9, R11, 0, 31, 31 */
		/* 821BF380h case   10:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R11);
		/* 821BF380h case   10:*/		return 0x821BF384;
		  /* 821BF384h */ case   11:  		/* bc 4, CR0_EQ, 12 */
		/* 821BF384h case   11:*/		if ( !regs.CR[0].eq ) { return 0x821BF390;  }
		/* 821BF384h case   11:*/		return 0x821BF388;
		  /* 821BF388h */ case   12:  		/* cmplwi CR6, R11, 0 */
		/* 821BF388h case   12:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BF388h case   12:*/		return 0x821BF38C;
		  /* 821BF38Ch */ case   13:  		/* bc 4, CR6_EQ, -32 */
		/* 821BF38Ch case   13:*/		if ( !regs.CR[6].eq ) { return 0x821BF36C;  }
		/* 821BF38Ch case   13:*/		return 0x821BF390;
	}
	return 0x821BF390;
} // Block from 821BF358h-821BF390h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821BF390h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF390( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF390) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF390);
		  /* 821BF390h */ case    0:  		/* addi R8, R29, 32 */
		/* 821BF390h case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R29,0x20);
		/* 821BF390h case    0:*/		return 0x821BF394;
		  /* 821BF394h */ case    1:  		/* cmplw CR6, R10, R8 */
		/* 821BF394h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 821BF394h case    1:*/		return 0x821BF398;
		  /* 821BF398h */ case    2:  		/* bc 12, CR6_EQ, 72 */
		/* 821BF398h case    2:*/		if ( regs.CR[6].eq ) { return 0x821BF3E0;  }
		/* 821BF398h case    2:*/		return 0x821BF39C;
		  /* 821BF39Ch */ case    3:  		/* addi R9, R29, 24 */
		/* 821BF39Ch case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R29,0x18);
		/* 821BF39Ch case    3:*/		return 0x821BF3A0;
		  /* 821BF3A0h */ case    4:  		/* cmplw CR6, R10, R9 */
		/* 821BF3A0h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 821BF3A0h case    4:*/		return 0x821BF3A4;
		  /* 821BF3A4h */ case    5:  		/* bc 12, CR6_EQ, 28 */
		/* 821BF3A4h case    5:*/		if ( regs.CR[6].eq ) { return 0x821BF3C0;  }
		/* 821BF3A4h case    5:*/		return 0x821BF3A8;
		  /* 821BF3A8h */ case    6:  		/* lwz R11, <#[R29 + 28]> */
		/* 821BF3A8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000001C) );
		/* 821BF3A8h case    6:*/		return 0x821BF3AC;
		  /* 821BF3ACh */ case    7:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821BF3ACh case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821BF3ACh case    7:*/		return 0x821BF3B0;
		  /* 821BF3B0h */ case    8:  		/* bc 4, CR0_EQ, 16 */
		/* 821BF3B0h case    8:*/		if ( !regs.CR[0].eq ) { return 0x821BF3C0;  }
		/* 821BF3B0h case    8:*/		return 0x821BF3B4;
		  /* 821BF3B4h */ case    9:  		/* lwz R11, <#[R9 + 4]> */
		/* 821BF3B4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 821BF3B4h case    9:*/		return 0x821BF3B8;
		  /* 821BF3B8h */ case   10:  		/* mr R10, R9 */
		/* 821BF3B8h case   10:*/		regs.R10 = regs.R9;
		/* 821BF3B8h case   10:*/		return 0x821BF3BC;
		  /* 821BF3BCh */ case   11:  		/* b 12 */
		/* 821BF3BCh case   11:*/		return 0x821BF3C8;
		/* 821BF3BCh case   11:*/		return 0x821BF3C0;
	}
	return 0x821BF3C0;
} // Block from 821BF390h-821BF3C0h (12 instructions)

//////////////////////////////////////////////////////
// Block at 821BF3C0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF3C0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF3C0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF3C0);
		  /* 821BF3C0h */ case    0:  		/* lwz R11, <#[R8 + 4]> */
		/* 821BF3C0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000004) );
		/* 821BF3C0h case    0:*/		return 0x821BF3C4;
		  /* 821BF3C4h */ case    1:  		/* mr R10, R8 */
		/* 821BF3C4h case    1:*/		regs.R10 = regs.R8;
		/* 821BF3C4h case    1:*/		return 0x821BF3C8;
	}
	return 0x821BF3C8;
} // Block from 821BF3C0h-821BF3C8h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BF3C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF3C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF3C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF3C8);
		  /* 821BF3C8h */ case    0:  		/* rlwinm. R9, R11, 0, 31, 31 */
		/* 821BF3C8h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R11);
		/* 821BF3C8h case    0:*/		return 0x821BF3CC;
		  /* 821BF3CCh */ case    1:  		/* bc 4, CR0_EQ, 20 */
		/* 821BF3CCh case    1:*/		if ( !regs.CR[0].eq ) { return 0x821BF3E0;  }
		/* 821BF3CCh case    1:*/		return 0x821BF3D0;
	}
	return 0x821BF3D0;
} // Block from 821BF3C8h-821BF3D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BF3D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF3D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF3D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF3D0);
		  /* 821BF3D0h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 821BF3D0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BF3D0h case    0:*/		return 0x821BF3D4;
		  /* 821BF3D4h */ case    1:  		/* bc 4, CR6_EQ, -104 */
		/* 821BF3D4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BF36C;  }
		/* 821BF3D4h case    1:*/		return 0x821BF3D8;
		  /* 821BF3D8h */ case    2:  		/* b 8 */
		/* 821BF3D8h case    2:*/		return 0x821BF3E0;
		/* 821BF3D8h case    2:*/		return 0x821BF3DC;
	}
	return 0x821BF3DC;
} // Block from 821BF3D0h-821BF3DCh (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BF3DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF3DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF3DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF3DC);
		  /* 821BF3DCh */ case    0:  		/* stw R26, <#[R29 + 44]> */
		/* 821BF3DCh case    0:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R29 + 0x0000002C) );
		/* 821BF3DCh case    0:*/		return 0x821BF3E0;
	}
	return 0x821BF3E0;
} // Block from 821BF3DCh-821BF3E0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BF3E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF3E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF3E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF3E0);
		  /* 821BF3E0h */ case    0:  		/* lwz R11, <#[R29 + 44]> */
		/* 821BF3E0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x0000002C) );
		/* 821BF3E0h case    0:*/		return 0x821BF3E4;
		  /* 821BF3E4h */ case    1:  		/* cmplw CR6, R11, R26 */
		/* 821BF3E4h case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 821BF3E4h case    1:*/		return 0x821BF3E8;
		  /* 821BF3E8h */ case    2:  		/* bc 4, CR6_EQ, 204 */
		/* 821BF3E8h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821BF4B4;  }
		/* 821BF3E8h case    2:*/		return 0x821BF3EC;
		  /* 821BF3ECh */ case    3:  		/* mr R4, R29 */
		/* 821BF3ECh case    3:*/		regs.R4 = regs.R29;
		/* 821BF3ECh case    3:*/		return 0x821BF3F0;
		  /* 821BF3F0h */ case    4:  		/* mr R3, R27 */
		/* 821BF3F0h case    4:*/		regs.R3 = regs.R27;
		/* 821BF3F0h case    4:*/		return 0x821BF3F4;
		  /* 821BF3F4h */ case    5:  		/* li R31, 0 */
		/* 821BF3F4h case    5:*/		cpu::op::li<0>(regs,&regs.R31,0x0);
		/* 821BF3F4h case    5:*/		return 0x821BF3F8;
		  /* 821BF3F8h */ case    6:  		/* bl -289672 */
		/* 821BF3F8h case    6:*/		regs.LR = 0x821BF3FC; return 0x82178870;
		/* 821BF3F8h case    6:*/		return 0x821BF3FC;
		  /* 821BF3FCh */ case    7:  		/* or. R30, R3, R3 */
		/* 821BF3FCh case    7:*/		cpu::op::or<1>(regs,&regs.R30,regs.R3,regs.R3);
		/* 821BF3FCh case    7:*/		return 0x821BF400;
		  /* 821BF400h */ case    8:  		/* bc 12, CR0_EQ, 32 */
		/* 821BF400h case    8:*/		if ( regs.CR[0].eq ) { return 0x821BF420;  }
		/* 821BF400h case    8:*/		return 0x821BF404;
		  /* 821BF404h */ case    9:  		/* lwz R11, <#[R30 + 8]> */
		/* 821BF404h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821BF404h case    9:*/		return 0x821BF408;
		  /* 821BF408h */ case   10:  		/* rlwinm R10, R11, 0, 18, 24 */
		/* 821BF408h case   10:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R10,regs.R11);
		/* 821BF408h case   10:*/		return 0x821BF40C;
		  /* 821BF40Ch */ case   11:  		/* cmplwi CR6, R10, 10752 */
		/* 821BF40Ch case   11:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00002A00);
		/* 821BF40Ch case   11:*/		return 0x821BF410;
		  /* 821BF410h */ case   12:  		/* bc 4, CR6_EQ, 16 */
		/* 821BF410h case   12:*/		if ( !regs.CR[6].eq ) { return 0x821BF420;  }
		/* 821BF410h case   12:*/		return 0x821BF414;
		  /* 821BF414h */ case   13:  		/* rlwinm. R11, R11, 6, 31, 31 */
		/* 821BF414h case   13:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R11,regs.R11);
		/* 821BF414h case   13:*/		return 0x821BF418;
		  /* 821BF418h */ case   14:  		/* bc 12, CR0_EQ, 8 */
		/* 821BF418h case   14:*/		if ( regs.CR[0].eq ) { return 0x821BF420;  }
		/* 821BF418h case   14:*/		return 0x821BF41C;
		  /* 821BF41Ch */ case   15:  		/* li R31, 1 */
		/* 821BF41Ch case   15:*/		cpu::op::li<0>(regs,&regs.R31,0x1);
		/* 821BF41Ch case   15:*/		return 0x821BF420;
	}
	return 0x821BF420;
} // Block from 821BF3E0h-821BF420h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821BF420h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF420( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF420) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF420);
		  /* 821BF420h */ case    0:  		/* lwz R11, <#[R29 + 48]> */
		/* 821BF420h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000030) );
		/* 821BF420h case    0:*/		return 0x821BF424;
		  /* 821BF424h */ case    1:  		/* rlwinm. R10, R11, 6, 31, 31 */
		/* 821BF424h case    1:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R10,regs.R11);
		/* 821BF424h case    1:*/		return 0x821BF428;
		  /* 821BF428h */ case    2:  		/* bc 12, CR0_EQ, 24 */
		/* 821BF428h case    2:*/		if ( regs.CR[0].eq ) { return 0x821BF440;  }
		/* 821BF428h case    2:*/		return 0x821BF42C;
		  /* 821BF42Ch */ case    3:  		/* cmplwi CR6, R30, 0 */
		/* 821BF42Ch case    3:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821BF42Ch case    3:*/		return 0x821BF430;
		  /* 821BF430h */ case    4:  		/* bc 12, CR6_EQ, 28 */
		/* 821BF430h case    4:*/		if ( regs.CR[6].eq ) { return 0x821BF44C;  }
		/* 821BF430h case    4:*/		return 0x821BF434;
		  /* 821BF434h */ case    5:  		/* lwz R11, <#[R30 + 8]> */
		/* 821BF434h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821BF434h case    5:*/		return 0x821BF438;
		  /* 821BF438h */ case    6:  		/* rlwinm. R11, R11, 6, 31, 31 */
		/* 821BF438h case    6:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R11,regs.R11);
		/* 821BF438h case    6:*/		return 0x821BF43C;
		  /* 821BF43Ch */ case    7:  		/* b 8 */
		/* 821BF43Ch case    7:*/		return 0x821BF444;
		/* 821BF43Ch case    7:*/		return 0x821BF440;
	}
	return 0x821BF440;
} // Block from 821BF420h-821BF440h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821BF440h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF440( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF440) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF440);
		  /* 821BF440h */ case    0:  		/* rlwinm. R11, R11, 5, 31, 31 */
		/* 821BF440h case    0:*/		cpu::op::rlwinm<1,5,31,31>(regs,&regs.R11,regs.R11);
		/* 821BF440h case    0:*/		return 0x821BF444;
	}
	return 0x821BF444;
} // Block from 821BF440h-821BF444h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BF444h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF444( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF444) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF444);
		  /* 821BF444h */ case    0:  		/* bc 12, CR0_EQ, 8 */
		/* 821BF444h case    0:*/		if ( regs.CR[0].eq ) { return 0x821BF44C;  }
		/* 821BF444h case    0:*/		return 0x821BF448;
	}
	return 0x821BF448;
} // Block from 821BF444h-821BF448h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BF448h
// Function '?DisconnectPHIDependenciesThroughPath@Compiler@D3DXShader@@AAAXPAVBlock@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF448( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF448) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF448);
		  /* 821BF448h */ case    0:  		/* li R31, 1 */
		/* 821BF448h case    0:*/		cpu::op::li<0>(regs,&regs.R31,0x1);
		/* 821BF448h case    0:*/		return 0x821BF44C;
	}
	return 0x821BF44C;
} // Block from 821BF448h-821BF44Ch (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BF44Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF44C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF44C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF44C);
		  /* 821BF44Ch */ case    0:  		/* rlwinm. R11, R31, 0, 24, 31 */
		/* 821BF44Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R31);
		/* 821BF44Ch case    0:*/		return 0x821BF450;
		  /* 821BF450h */ case    1:  		/* bc 12, CR0_EQ, 100 */
		/* 821BF450h case    1:*/		if ( regs.CR[0].eq ) { return 0x821BF4B4;  }
		/* 821BF450h case    1:*/		return 0x821BF454;
		  /* 821BF454h */ case    2:  		/* lwz R10, <#[R29 + 12]> */
		/* 821BF454h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x0000000C) );
		/* 821BF454h case    2:*/		return 0x821BF458;
		  /* 821BF458h */ case    3:  		/* cmplwi CR6, R10, 0 */
		/* 821BF458h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821BF458h case    3:*/		return 0x821BF45C;
		  /* 821BF45Ch */ case    4:  		/* bc 12, CR6_EQ, 32 */
		/* 821BF45Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x821BF47C;  }
		/* 821BF45Ch case    4:*/		return 0x821BF460;
		  /* 821BF460h */ case    5:  		/* lwz R11, <#[R10]> */
		/* 821BF460h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 821BF460h case    5:*/		return 0x821BF464;
		  /* 821BF464h */ case    6:  		/* lwz R9, <#[R11 + 44]> */
		/* 821BF464h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000002C) );
		/* 821BF464h case    6:*/		return 0x821BF468;
		  /* 821BF468h */ case    7:  		/* cmplw CR6, R9, R26 */
		/* 821BF468h case    7:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R26);
		/* 821BF468h case    7:*/		return 0x821BF46C;
		  /* 821BF46Ch */ case    8:  		/* bc 12, CR6_EQ, 8 */
		/* 821BF46Ch case    8:*/		if ( regs.CR[6].eq ) { return 0x821BF474;  }
		/* 821BF46Ch case    8:*/		return 0x821BF470;
		  /* 821BF470h */ case    9:  		/* stw R26, <#[R11 + 44]> */
		/* 821BF470h case    9:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + 0x0000002C) );
		/* 821BF470h case    9:*/		return 0x821BF474;
	}
	return 0x821BF474;
} // Block from 821BF44Ch-821BF474h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821BF474h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF474( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF474) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF474);
		  /* 821BF474h */ case    0:  		/* lwz R10, <#[R10 + 8]> */
		/* 821BF474h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 821BF474h case    0:*/		return 0x821BF478;
		  /* 821BF478h */ case    1:  		/* b -32 */
		/* 821BF478h case    1:*/		return 0x821BF458;
		/* 821BF478h case    1:*/		return 0x821BF47C;
	}
	return 0x821BF47C;
} // Block from 821BF474h-821BF47Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BF47Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF47C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF47C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF47C);
		  /* 821BF47Ch */ case    0:  		/* cmplwi CR6, R30, 0 */
		/* 821BF47Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821BF47Ch case    0:*/		return 0x821BF480;
		  /* 821BF480h */ case    1:  		/* bc 12, CR6_EQ, 52 */
		/* 821BF480h case    1:*/		if ( regs.CR[6].eq ) { return 0x821BF4B4;  }
		/* 821BF480h case    1:*/		return 0x821BF484;
		  /* 821BF484h */ case    2:  		/* lwz R11, <#[R30 + 8]> */
		/* 821BF484h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821BF484h case    2:*/		return 0x821BF488;
		  /* 821BF488h */ case    3:  		/* mr R3, R27 */
		/* 821BF488h case    3:*/		regs.R3 = regs.R27;
		/* 821BF488h case    3:*/		return 0x821BF48C;
		  /* 821BF48Ch */ case    4:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 821BF48Ch case    4:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 821BF48Ch case    4:*/		return 0x821BF490;
		  /* 821BF490h */ case    5:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 821BF490h case    5:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 821BF490h case    5:*/		return 0x821BF494;
		  /* 821BF494h */ case    6:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 821BF494h case    6:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 821BF494h case    6:*/		return 0x821BF498;
		  /* 821BF498h */ case    7:  		/* bl -372840 */
		/* 821BF498h case    7:*/		regs.LR = 0x821BF49C; return 0x82164430;
		/* 821BF498h case    7:*/		return 0x821BF49C;
		  /* 821BF49Ch */ case    8:  		/* addi R11, R30, -16 */
		/* 821BF49Ch case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R30,0xFFFFFFF0);
		/* 821BF49Ch case    8:*/		return 0x821BF4A0;
		  /* 821BF4A0h */ case    9:  		/* lwzx R11, <#[R3 + R11]> */
		/* 821BF4A0h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + regs.R11 + 0x00000000) );
		/* 821BF4A0h case    9:*/		return 0x821BF4A4;
		  /* 821BF4A4h */ case   10:  		/* lwz R10, <#[R11 + 44]> */
		/* 821BF4A4h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000002C) );
		/* 821BF4A4h case   10:*/		return 0x821BF4A8;
		  /* 821BF4A8h */ case   11:  		/* cmplw CR6, R10, R26 */
		/* 821BF4A8h case   11:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R26);
		/* 821BF4A8h case   11:*/		return 0x821BF4AC;
		  /* 821BF4ACh */ case   12:  		/* bc 12, CR6_EQ, 8 */
		/* 821BF4ACh case   12:*/		if ( regs.CR[6].eq ) { return 0x821BF4B4;  }
		/* 821BF4ACh case   12:*/		return 0x821BF4B0;
		  /* 821BF4B0h */ case   13:  		/* stw R26, <#[R11 + 44]> */
		/* 821BF4B0h case   13:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + 0x0000002C) );
		/* 821BF4B0h case   13:*/		return 0x821BF4B4;
	}
	return 0x821BF4B4;
} // Block from 821BF47Ch-821BF4B4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821BF4B4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF4B4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF4B4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF4B4);
		  /* 821BF4B4h */ case    0:  		/* rlwinm R11, R29, 0, 0, 30 */
		/* 821BF4B4h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R29);
		/* 821BF4B4h case    0:*/		return 0x821BF4B8;
		  /* 821BF4B8h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 821BF4B8h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821BF4B8h case    1:*/		return 0x821BF4BC;
		  /* 821BF4BCh */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BF4BCh case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BF4BCh case    2:*/		return 0x821BF4C0;
		  /* 821BF4C0h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 821BF4C0h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BF4D0;  }
		/* 821BF4C0h case    3:*/		return 0x821BF4C4;
		  /* 821BF4C4h */ case    4:  		/* mr R29, R11 */
		/* 821BF4C4h case    4:*/		regs.R29 = regs.R11;
		/* 821BF4C4h case    4:*/		return 0x821BF4C8;
		  /* 821BF4C8h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821BF4C8h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BF4C8h case    5:*/		return 0x821BF4CC;
		  /* 821BF4CCh */ case    6:  		/* bc 4, CR6_EQ, -440 */
		/* 821BF4CCh case    6:*/		if ( !regs.CR[6].eq ) { return 0x821BF314;  }
		/* 821BF4CCh case    6:*/		return 0x821BF4D0;
	}
	return 0x821BF4D0;
} // Block from 821BF4B4h-821BF4D0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BF4D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF4D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF4D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF4D0);
		  /* 821BF4D0h */ case    0:  		/* lwz R11, <#[R27 + 4]> */
		/* 821BF4D0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 821BF4D0h case    0:*/		return 0x821BF4D4;
		  /* 821BF4D4h */ case    1:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 821BF4D4h case    1:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BF4D4h case    1:*/		return 0x821BF4D8;
		  /* 821BF4D8h */ case    2:  		/* addic R10, R10, -1 */
		/* 821BF4D8h case    2:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 821BF4D8h case    2:*/		return 0x821BF4DC;
		  /* 821BF4DCh */ case    3:  		/* subfe R10, R10, R10 */
		/* 821BF4DCh case    3:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 821BF4DCh case    3:*/		return 0x821BF4E0;
		  /* 821BF4E0h */ case    4:  		/* and R11, R10, R11 */
		/* 821BF4E0h case    4:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821BF4E0h case    4:*/		return 0x821BF4E4;
		  /* 821BF4E4h */ case    5:  		/* lwz R11, <#[R11 + 20]> */
		/* 821BF4E4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 821BF4E4h case    5:*/		return 0x821BF4E8;
		  /* 821BF4E8h */ case    6:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BF4E8h case    6:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BF4E8h case    6:*/		return 0x821BF4EC;
		  /* 821BF4ECh */ case    7:  		/* bc 4, CR0_EQ, 56 */
		/* 821BF4ECh case    7:*/		if ( !regs.CR[0].eq ) { return 0x821BF524;  }
		/* 821BF4ECh case    7:*/		return 0x821BF4F0;
		  /* 821BF4F0h */ case    8:  		/* cmplwi CR0, R11, 0 */
		/* 821BF4F0h case    8:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821BF4F0h case    8:*/		return 0x821BF4F4;
		  /* 821BF4F4h */ case    9:  		/* bc 12, CR0_EQ, 48 */
		/* 821BF4F4h case    9:*/		if ( regs.CR[0].eq ) { return 0x821BF524;  }
		/* 821BF4F4h case    9:*/		return 0x821BF4F8;
		  /* 821BF4F8h */ case   10:  		/* lwz R10, <#[R11 + 8]> */
		/* 821BF4F8h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821BF4F8h case   10:*/		return 0x821BF4FC;
		  /* 821BF4FCh */ case   11:  		/* rlwinm. R9, R10, 6, 31, 31 */
		/* 821BF4FCh case   11:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R9,regs.R10);
		/* 821BF4FCh case   11:*/		return 0x821BF500;
		  /* 821BF500h */ case   12:  		/* bc 12, CR0_EQ, 12 */
		/* 821BF500h case   12:*/		if ( regs.CR[0].eq ) { return 0x821BF50C;  }
		/* 821BF500h case   12:*/		return 0x821BF504;
		  /* 821BF504h */ case   13:  		/* rlwinm R10, R10, 0, 6, 4 */
		/* 821BF504h case   13:*/		cpu::op::rlwinm<0,0,6,4>(regs,&regs.R10,regs.R10);
		/* 821BF504h case   13:*/		return 0x821BF508;
		  /* 821BF508h */ case   14:  		/* stw R10, <#[R11 + 8]> */
		/* 821BF508h case   14:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821BF508h case   14:*/		return 0x821BF50C;
	}
	return 0x821BF50C;
} // Block from 821BF4D0h-821BF50Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 821BF50Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF50C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF50C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF50C);
		  /* 821BF50Ch */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821BF50Ch case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821BF50Ch case    0:*/		return 0x821BF510;
		  /* 821BF510h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 821BF510h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 821BF510h case    1:*/		return 0x821BF514;
		  /* 821BF514h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BF514h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BF514h case    2:*/		return 0x821BF518;
		  /* 821BF518h */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 821BF518h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BF524;  }
		/* 821BF518h case    3:*/		return 0x821BF51C;
		  /* 821BF51Ch */ case    4:  		/* cmplwi CR6, R11, 0 */
		/* 821BF51Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BF51Ch case    4:*/		return 0x821BF520;
	}
	return 0x821BF520;
} // Block from 821BF50Ch-821BF520h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BF520h
// Function '?DisconnectSuccessor@Compiler@D3DXShader@@AAAXPAVBlock@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF520( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF520) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF520);
		  /* 821BF520h */ case    0:  		/* bc 4, CR6_EQ, -40 */
		/* 821BF520h case    0:*/		if ( !regs.CR[6].eq ) { return 0x821BF4F8;  }
		/* 821BF520h case    0:*/		return 0x821BF524;
	}
	return 0x821BF524;
} // Block from 821BF520h-821BF524h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BF524h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF524( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF524) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF524);
		  /* 821BF524h */ case    0:  		/* lwz R11, <#[R27 + 4]> */
		/* 821BF524h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 821BF524h case    0:*/		return 0x821BF528;
		  /* 821BF528h */ case    1:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 821BF528h case    1:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BF528h case    1:*/		return 0x821BF52C;
		  /* 821BF52Ch */ case    2:  		/* addic R9, R10, -1 */
		/* 821BF52Ch case    2:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R10,0xFFFFFFFF);
		/* 821BF52Ch case    2:*/		return 0x821BF530;
		  /* 821BF530h */ case    3:  		/* subfe R9, R9, R9 */
		/* 821BF530h case    3:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 821BF530h case    3:*/		return 0x821BF534;
		  /* 821BF534h */ case    4:  		/* and R9, R9, R11 */
		/* 821BF534h case    4:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 821BF534h case    4:*/		return 0x821BF538;
		  /* 821BF538h */ case    5:  		/* lwz R9, <#[R9 + 28]> */
		/* 821BF538h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x0000001C) );
		/* 821BF538h case    5:*/		return 0x821BF53C;
		  /* 821BF53Ch */ case    6:  		/* rlwinm. R9, R9, 0, 31, 31 */
		/* 821BF53Ch case    6:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R9);
		/* 821BF53Ch case    6:*/		return 0x821BF540;
		  /* 821BF540h */ case    7:  		/* addic R9, R10, -1 */
		/* 821BF540h case    7:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R10,0xFFFFFFFF);
		/* 821BF540h case    7:*/		return 0x821BF544;
		  /* 821BF544h */ case    8:  		/* subfe R9, R9, R9 */
		/* 821BF544h case    8:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 821BF544h case    8:*/		return 0x821BF548;
		  /* 821BF548h */ case    9:  		/* and R9, R9, R11 */
		/* 821BF548h case    9:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 821BF548h case    9:*/		return 0x821BF54C;
		  /* 821BF54Ch */ case   10:  		/* bc 12, CR0_EQ, 44 */
		/* 821BF54Ch case   10:*/		if ( regs.CR[0].eq ) { return 0x821BF578;  }
		/* 821BF54Ch case   10:*/		return 0x821BF550;
		  /* 821BF550h */ case   11:  		/* lwz R9, <#[R9 + 36]> */
		/* 821BF550h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000024) );
		/* 821BF550h case   11:*/		return 0x821BF554;
		  /* 821BF554h */ case   12:  		/* rlwinm R8, R9, 0, 31, 31 */
		/* 821BF554h case   12:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R8,regs.R9);
		/* 821BF554h case   12:*/		return 0x821BF558;
		  /* 821BF558h */ case   13:  		/* addic R8, R8, -1 */
		/* 821BF558h case   13:*/		cpu::op::addic<0>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 821BF558h case   13:*/		return 0x821BF55C;
		  /* 821BF55Ch */ case   14:  		/* subfe R8, R8, R8 */
		/* 821BF55Ch case   14:*/		cpu::op::subfe<0>(regs,&regs.R8,regs.R8,regs.R8);
		/* 821BF55Ch case   14:*/		return 0x821BF560;
		  /* 821BF560h */ case   15:  		/* addic R7, R10, -1 */
		/* 821BF560h case   15:*/		cpu::op::addic<0>(regs,&regs.R7,regs.R10,0xFFFFFFFF);
		/* 821BF560h case   15:*/		return 0x821BF564;
		  /* 821BF564h */ case   16:  		/* and R9, R8, R9 */
		/* 821BF564h case   16:*/		cpu::op::and<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 821BF564h case   16:*/		return 0x821BF568;
		  /* 821BF568h */ case   17:  		/* subfe R8, R7, R7 */
		/* 821BF568h case   17:*/		cpu::op::subfe<0>(regs,&regs.R8,regs.R7,regs.R7);
		/* 821BF568h case   17:*/		return 0x821BF56C;
		  /* 821BF56Ch */ case   18:  		/* and R8, R8, R11 */
		/* 821BF56Ch case   18:*/		cpu::op::and<0>(regs,&regs.R8,regs.R8,regs.R11);
		/* 821BF56Ch case   18:*/		return 0x821BF570;
		  /* 821BF570h */ case   19:  		/* addi R8, R8, 32 */
		/* 821BF570h case   19:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x20);
		/* 821BF570h case   19:*/		return 0x821BF574;
		  /* 821BF574h */ case   20:  		/* b 40 */
		/* 821BF574h case   20:*/		return 0x821BF59C;
		/* 821BF574h case   20:*/		return 0x821BF578;
	}
	return 0x821BF578;
} // Block from 821BF524h-821BF578h (21 instructions)

//////////////////////////////////////////////////////
// Block at 821BF578h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF578( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF578) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF578);
		  /* 821BF578h */ case    0:  		/* lwz R9, <#[R9 + 28]> */
		/* 821BF578h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x0000001C) );
		/* 821BF578h case    0:*/		return 0x821BF57C;
		  /* 821BF57Ch */ case    1:  		/* rlwinm R8, R9, 0, 31, 31 */
		/* 821BF57Ch case    1:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R8,regs.R9);
		/* 821BF57Ch case    1:*/		return 0x821BF580;
		  /* 821BF580h */ case    2:  		/* addic R8, R8, -1 */
		/* 821BF580h case    2:*/		cpu::op::addic<0>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 821BF580h case    2:*/		return 0x821BF584;
		  /* 821BF584h */ case    3:  		/* subfe R8, R8, R8 */
		/* 821BF584h case    3:*/		cpu::op::subfe<0>(regs,&regs.R8,regs.R8,regs.R8);
		/* 821BF584h case    3:*/		return 0x821BF588;
		  /* 821BF588h */ case    4:  		/* addic R7, R10, -1 */
		/* 821BF588h case    4:*/		cpu::op::addic<0>(regs,&regs.R7,regs.R10,0xFFFFFFFF);
		/* 821BF588h case    4:*/		return 0x821BF58C;
		  /* 821BF58Ch */ case    5:  		/* and R9, R8, R9 */
		/* 821BF58Ch case    5:*/		cpu::op::and<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 821BF58Ch case    5:*/		return 0x821BF590;
		  /* 821BF590h */ case    6:  		/* subfe R8, R7, R7 */
		/* 821BF590h case    6:*/		cpu::op::subfe<0>(regs,&regs.R8,regs.R7,regs.R7);
		/* 821BF590h case    6:*/		return 0x821BF594;
		  /* 821BF594h */ case    7:  		/* and R8, R8, R11 */
		/* 821BF594h case    7:*/		cpu::op::and<0>(regs,&regs.R8,regs.R8,regs.R11);
		/* 821BF594h case    7:*/		return 0x821BF598;
		  /* 821BF598h */ case    8:  		/* addi R8, R8, 24 */
		/* 821BF598h case    8:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x18);
		/* 821BF598h case    8:*/		return 0x821BF59C;
	}
	return 0x821BF59C;
} // Block from 821BF578h-821BF59Ch (9 instructions)

//////////////////////////////////////////////////////
// Block at 821BF59Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF59C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF59C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF59C);
		  /* 821BF59Ch */ case    0:  		/* cmplwi CR6, R9, 0 */
		/* 821BF59Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 821BF59Ch case    0:*/		return 0x821BF5A0;
		  /* 821BF5A0h */ case    1:  		/* bc 12, CR6_EQ, 160 */
		/* 821BF5A0h case    1:*/		if ( regs.CR[6].eq ) { return 0x821BF640;  }
		/* 821BF5A0h case    1:*/		return 0x821BF5A4;
		  /* 821BF5A4h */ case    2:  		/* lwz R10, <#[R9 + 8]> */
		/* 821BF5A4h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x00000008) );
		/* 821BF5A4h case    2:*/		return 0x821BF5A8;
		  /* 821BF5A8h */ case    3:  		/* rlwinm. R11, R10, 6, 31, 31 */
		/* 821BF5A8h case    3:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R11,regs.R10);
		/* 821BF5A8h case    3:*/		return 0x821BF5AC;
		  /* 821BF5ACh */ case    4:  		/* bc 12, CR0_EQ, 56 */
		/* 821BF5ACh case    4:*/		if ( regs.CR[0].eq ) { return 0x821BF5E4;  }
		/* 821BF5ACh case    4:*/		return 0x821BF5B0;
		  /* 821BF5B0h */ case    5:  		/* rlwinm. R11, R10, 26, 31, 31 */
		/* 821BF5B0h case    5:*/		cpu::op::rlwinm<1,26,31,31>(regs,&regs.R11,regs.R10);
		/* 821BF5B0h case    5:*/		return 0x821BF5B4;
		  /* 821BF5B4h */ case    6:  		/* bc 4, CR0_EQ, 40 */
		/* 821BF5B4h case    6:*/		if ( !regs.CR[0].eq ) { return 0x821BF5DC;  }
		/* 821BF5B4h case    6:*/		return 0x821BF5B8;
		  /* 821BF5B8h */ case    7:  		/* rlwinm R11, R10, 25, 25, 31 */
		/* 821BF5B8h case    7:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R10);
		/* 821BF5B8h case    7:*/		return 0x821BF5BC;
		  /* 821BF5BCh */ case    8:  		/* cmplwi CR6, R11, 83 */
		/* 821BF5BCh case    8:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000053);
		/* 821BF5BCh case    8:*/		return 0x821BF5C0;
		  /* 821BF5C0h */ case    9:  		/* bc 12, CR6_LT, 16 */
		/* 821BF5C0h case    9:*/		if ( regs.CR[6].lt ) { return 0x821BF5D0;  }
		/* 821BF5C0h case    9:*/		return 0x821BF5C4;
		  /* 821BF5C4h */ case   10:  		/* cmplwi CR6, R11, 95 */
		/* 821BF5C4h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x0000005F);
		/* 821BF5C4h case   10:*/		return 0x821BF5C8;
		  /* 821BF5C8h */ case   11:  		/* li R11, 1 */
		/* 821BF5C8h case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x1);
		/* 821BF5C8h case   11:*/		return 0x821BF5CC;
		  /* 821BF5CCh */ case   12:  		/* bc 4, CR6_GT, 8 */
		/* 821BF5CCh case   12:*/		if ( !regs.CR[6].gt ) { return 0x821BF5D4;  }
		/* 821BF5CCh case   12:*/		return 0x821BF5D0;
	}
	return 0x821BF5D0;
} // Block from 821BF59Ch-821BF5D0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821BF5D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF5D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF5D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF5D0);
		  /* 821BF5D0h */ case    0:  		/* li R11, 0 */
		/* 821BF5D0h case    0:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BF5D0h case    0:*/		return 0x821BF5D4;
	}
	return 0x821BF5D4;
} // Block from 821BF5D0h-821BF5D4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BF5D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF5D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF5D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF5D4);
		  /* 821BF5D4h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821BF5D4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821BF5D4h case    0:*/		return 0x821BF5D8;
		  /* 821BF5D8h */ case    1:  		/* bc 12, CR0_EQ, 12 */
		/* 821BF5D8h case    1:*/		if ( regs.CR[0].eq ) { return 0x821BF5E4;  }
		/* 821BF5D8h case    1:*/		return 0x821BF5DC;
	}
	return 0x821BF5DC;
} // Block from 821BF5D4h-821BF5DCh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BF5DCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF5DC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF5DC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF5DC);
		  /* 821BF5DCh */ case    0:  		/* rlwinm R11, R10, 0, 6, 4 */
		/* 821BF5DCh case    0:*/		cpu::op::rlwinm<0,0,6,4>(regs,&regs.R11,regs.R10);
		/* 821BF5DCh case    0:*/		return 0x821BF5E0;
		  /* 821BF5E0h */ case    1:  		/* stw R11, <#[R9 + 8]> */
		/* 821BF5E0h case    1:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000008) );
		/* 821BF5E0h case    1:*/		return 0x821BF5E4;
	}
	return 0x821BF5E4;
} // Block from 821BF5DCh-821BF5E4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BF5E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF5E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF5E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF5E4);
		  /* 821BF5E4h */ case    0:  		/* rlwinm R11, R9, 0, 0, 30 */
		/* 821BF5E4h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R9);
		/* 821BF5E4h case    0:*/		return 0x821BF5E8;
		  /* 821BF5E8h */ case    1:  		/* lwz R9, <#[R11 + 40]> */
		/* 821BF5E8h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000028) );
		/* 821BF5E8h case    1:*/		return 0x821BF5EC;
		  /* 821BF5ECh */ case    2:  		/* rlwinm. R11, R9, 0, 31, 31 */
		/* 821BF5ECh case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R9);
		/* 821BF5ECh case    2:*/		return 0x821BF5F0;
		  /* 821BF5F0h */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 821BF5F0h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BF5FC;  }
		/* 821BF5F0h case    3:*/		return 0x821BF5F4;
		  /* 821BF5F4h */ case    4:  		/* cmplwi CR6, R9, 0 */
		/* 821BF5F4h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 821BF5F4h case    4:*/		return 0x821BF5F8;
		  /* 821BF5F8h */ case    5:  		/* bc 4, CR6_EQ, -84 */
		/* 821BF5F8h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821BF5A4;  }
		/* 821BF5F8h case    5:*/		return 0x821BF5FC;
	}
	return 0x821BF5FC;
} // Block from 821BF5E4h-821BF5FCh (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BF5FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF5FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF5FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF5FC);
		  /* 821BF5FCh */ case    0:  		/* lwz R11, <#[R27 + 4]> */
		/* 821BF5FCh case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 821BF5FCh case    0:*/		return 0x821BF600;
		  /* 821BF600h */ case    1:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 821BF600h case    1:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BF600h case    1:*/		return 0x821BF604;
		  /* 821BF604h */ case    2:  		/* addic R9, R10, -1 */
		/* 821BF604h case    2:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R10,0xFFFFFFFF);
		/* 821BF604h case    2:*/		return 0x821BF608;
		  /* 821BF608h */ case    3:  		/* subfe R9, R9, R9 */
		/* 821BF608h case    3:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 821BF608h case    3:*/		return 0x821BF60C;
		  /* 821BF60Ch */ case    4:  		/* and R9, R9, R11 */
		/* 821BF60Ch case    4:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 821BF60Ch case    4:*/		return 0x821BF610;
		  /* 821BF610h */ case    5:  		/* addi R9, R9, 32 */
		/* 821BF610h case    5:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x20);
		/* 821BF610h case    5:*/		return 0x821BF614;
		  /* 821BF614h */ case    6:  		/* cmplw CR6, R8, R9 */
		/* 821BF614h case    6:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R9);
		/* 821BF614h case    6:*/		return 0x821BF618;
		  /* 821BF618h */ case    7:  		/* bc 12, CR6_EQ, 40 */
		/* 821BF618h case    7:*/		if ( regs.CR[6].eq ) { return 0x821BF640;  }
		/* 821BF618h case    7:*/		return 0x821BF61C;
		  /* 821BF61Ch */ case    8:  		/* addic R9, R10, -1 */
		/* 821BF61Ch case    8:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R10,0xFFFFFFFF);
		/* 821BF61Ch case    8:*/		return 0x821BF620;
		  /* 821BF620h */ case    9:  		/* subfe R9, R9, R9 */
		/* 821BF620h case    9:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 821BF620h case    9:*/		return 0x821BF624;
		  /* 821BF624h */ case   10:  		/* and R9, R9, R11 */
		/* 821BF624h case   10:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 821BF624h case   10:*/		return 0x821BF628;
		  /* 821BF628h */ case   11:  		/* addi R8, R9, 32 */
		/* 821BF628h case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R9,0x20);
		/* 821BF628h case   11:*/		return 0x821BF62C;
		  /* 821BF62Ch */ case   12:  		/* lwz R9, <#[R9 + 36]> */
		/* 821BF62Ch case   12:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000024) );
		/* 821BF62Ch case   12:*/		return 0x821BF630;
		  /* 821BF630h */ case   13:  		/* rlwinm. R7, R9, 0, 31, 31 */
		/* 821BF630h case   13:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R7,regs.R9);
		/* 821BF630h case   13:*/		return 0x821BF634;
		  /* 821BF634h */ case   14:  		/* bc 4, CR0_EQ, 12 */
		/* 821BF634h case   14:*/		if ( !regs.CR[0].eq ) { return 0x821BF640;  }
		/* 821BF634h case   14:*/		return 0x821BF638;
		  /* 821BF638h */ case   15:  		/* cmplwi CR0, R9, 0 */
		/* 821BF638h case   15:*/		cpu::op::cmplwi<0>(regs,regs.R9,0x00000000);
		/* 821BF638h case   15:*/		return 0x821BF63C;
		  /* 821BF63Ch */ case   16:  		/* bc 4, CR0_EQ, -152 */
		/* 821BF63Ch case   16:*/		if ( !regs.CR[0].eq ) { return 0x821BF5A4;  }
		/* 821BF63Ch case   16:*/		return 0x821BF640;
	}
	return 0x821BF640;
} // Block from 821BF5FCh-821BF640h (17 instructions)

//////////////////////////////////////////////////////
// Block at 821BF640h
// Function '?RemoveVisitedBlocks@Compiler@D3DXShader@@AAAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF640( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF640) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF640);
		  /* 821BF640h */ case    0:  		/* lwz R9, <#[R27 + 44]> */
		/* 821BF640h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R27 + 0x0000002C) );
		/* 821BF640h case    0:*/		return 0x821BF644;
		  /* 821BF644h */ case    1:  		/* rlwinm. R9, R9, 0, 8, 8 */
		/* 821BF644h case    1:*/		cpu::op::rlwinm<1,0,8,8>(regs,&regs.R9,regs.R9);
		/* 821BF644h case    1:*/		return 0x821BF648;
		  /* 821BF648h */ case    2:  		/* bc 12, CR0_EQ, 348 */
		/* 821BF648h case    2:*/		if ( regs.CR[0].eq ) { return 0x821BF7A4;  }
		/* 821BF648h case    2:*/		return 0x821BF64C;
		  /* 821BF64Ch */ case    3:  		/* li R30, 0 */
		/* 821BF64Ch case    3:*/		cpu::op::li<0>(regs,&regs.R30,0x0);
		/* 821BF64Ch case    3:*/		return 0x821BF650;
		  /* 821BF650h */ case    4:  		/* cmplwi CR6, R10, 0 */
		/* 821BF650h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821BF650h case    4:*/		return 0x821BF654;
		  /* 821BF654h */ case    5:  		/* bc 4, CR6_EQ, 328 */
		/* 821BF654h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821BF79C;  }
		/* 821BF654h case    5:*/		return 0x821BF658;
		  /* 821BF658h */ case    6:  		/* mr R28, R11 */
		/* 821BF658h case    6:*/		regs.R28 = regs.R11;
		/* 821BF658h case    6:*/		return 0x821BF65C;
		  /* 821BF65Ch */ case    7:  		/* cmplwi CR0, R11, 0 */
		/* 821BF65Ch case    7:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821BF65Ch case    7:*/		return 0x821BF660;
		  /* 821BF660h */ case    8:  		/* bc 12, CR0_EQ, 316 */
		/* 821BF660h case    8:*/		if ( regs.CR[0].eq ) { return 0x821BF79C;  }
		/* 821BF660h case    8:*/		return 0x821BF664;
		  /* 821BF664h */ case    9:  		/* lwz R11, <#[R28 + 44]> */
		/* 821BF664h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x0000002C) );
		/* 821BF664h case    9:*/		return 0x821BF668;
		  /* 821BF668h */ case   10:  		/* cmplw CR6, R11, R26 */
		/* 821BF668h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R26);
		/* 821BF668h case   10:*/		return 0x821BF66C;
		  /* 821BF66Ch */ case   11:  		/* bc 4, CR6_EQ, 276 */
		/* 821BF66Ch case   11:*/		if ( !regs.CR[6].eq ) { return 0x821BF780;  }
		/* 821BF66Ch case   11:*/		return 0x821BF670;
		  /* 821BF670h */ case   12:  		/* lwz R11, <#[R28 + 8]> */
		/* 821BF670h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x00000008) );
		/* 821BF670h case   12:*/		return 0x821BF674;
		  /* 821BF674h */ case   13:  		/* cmplwi CR6, R11, 0 */
		/* 821BF674h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BF674h case   13:*/		return 0x821BF678;
		  /* 821BF678h */ case   14:  		/* bc 12, CR6_EQ, 264 */
		/* 821BF678h case   14:*/		if ( regs.CR[6].eq ) { return 0x821BF780;  }
		/* 821BF678h case   14:*/		return 0x821BF67C;
		  /* 821BF67Ch */ case   15:  		/* lwz R11, <#[R11 + 4]> */
		/* 821BF67Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821BF67Ch case   15:*/		return 0x821BF680;
		  /* 821BF680h */ case   16:  		/* cmplwi CR6, R11, 0 */
		/* 821BF680h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BF680h case   16:*/		return 0x821BF684;
		  /* 821BF684h */ case   17:  		/* bc 12, CR6_EQ, 252 */
		/* 821BF684h case   17:*/		if ( regs.CR[6].eq ) { return 0x821BF780;  }
		/* 821BF684h case   17:*/		return 0x821BF688;
		  /* 821BF688h */ case   18:  		/* lwz R10, <#[R11 + 68]> */
		/* 821BF688h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000044) );
		/* 821BF688h case   18:*/		return 0x821BF68C;
		  /* 821BF68Ch */ case   19:  		/* rlwinm. R10, R10, 0, 1, 1 */
		/* 821BF68Ch case   19:*/		cpu::op::rlwinm<1,0,1,1>(regs,&regs.R10,regs.R10);
		/* 821BF68Ch case   19:*/		return 0x821BF690;
		  /* 821BF690h */ case   20:  		/* bc 12, CR0_EQ, 240 */
		/* 821BF690h case   20:*/		if ( regs.CR[0].eq ) { return 0x821BF780;  }
		/* 821BF690h case   20:*/		return 0x821BF694;
		  /* 821BF694h */ case   21:  		/* lwz R10, <#[R11 + 44]> */
		/* 821BF694h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000002C) );
		/* 821BF694h case   21:*/		return 0x821BF698;
		  /* 821BF698h */ case   22:  		/* cmplw CR6, R10, R26 */
		/* 821BF698h case   22:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R26);
		/* 821BF698h case   22:*/		return 0x821BF69C;
		  /* 821BF69Ch */ case   23:  		/* bc 12, CR6_EQ, 8 */
		/* 821BF69Ch case   23:*/		if ( regs.CR[6].eq ) { return 0x821BF6A4;  }
		/* 821BF69Ch case   23:*/		return 0x821BF6A0;
		  /* 821BF6A0h */ case   24:  		/* stw R26, <#[R11 + 44]> */
		/* 821BF6A0h case   24:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R11 + 0x0000002C) );
		/* 821BF6A0h case   24:*/		return 0x821BF6A4;
	}
	return 0x821BF6A4;
} // Block from 821BF640h-821BF6A4h (25 instructions)

//////////////////////////////////////////////////////
// Block at 821BF6A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF6A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF6A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF6A4);
		  /* 821BF6A4h */ case    0:  		/* lwz R29, <#[R11 + 8]> */
		/* 821BF6A4h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x00000008) );
		/* 821BF6A4h case    0:*/		return 0x821BF6A8;
		  /* 821BF6A8h */ case    1:  		/* cmplwi CR6, R29, 0 */
		/* 821BF6A8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 821BF6A8h case    1:*/		return 0x821BF6AC;
		  /* 821BF6ACh */ case    2:  		/* bc 12, CR6_EQ, 212 */
		/* 821BF6ACh case    2:*/		if ( regs.CR[6].eq ) { return 0x821BF780;  }
		/* 821BF6ACh case    2:*/		return 0x821BF6B0;
		  /* 821BF6B0h */ case    3:  		/* lwz R11, <#[R29 + 4]> */
		/* 821BF6B0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 821BF6B0h case    3:*/		return 0x821BF6B4;
		  /* 821BF6B4h */ case    4:  		/* lwz R10, <#[R11 + 28]> */
		/* 821BF6B4h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000001C) );
		/* 821BF6B4h case    4:*/		return 0x821BF6B8;
		  /* 821BF6B8h */ case    5:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 821BF6B8h case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 821BF6B8h case    5:*/		return 0x821BF6BC;
		  /* 821BF6BCh */ case    6:  		/* bc 4, CR0_EQ, 240 */
		/* 821BF6BCh case    6:*/		if ( !regs.CR[0].eq ) { return 0x821BF7AC;  }
		/* 821BF6BCh case    6:*/		return 0x821BF6C0;
		  /* 821BF6C0h */ case    7:  		/* lwz R11, <#[R11 + 24]> */
		/* 821BF6C0h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000018) );
		/* 821BF6C0h case    7:*/		return 0x821BF6C4;
		  /* 821BF6C4h */ case    8:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821BF6C4h case    8:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821BF6C4h case    8:*/		return 0x821BF6C8;
		  /* 821BF6C8h */ case    9:  		/* addic. R31, R11, -40 */
		/* 821BF6C8h case    9:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R11,0xFFFFFFD8);
		/* 821BF6C8h case    9:*/		return 0x821BF6CC;
		  /* 821BF6CCh */ case   10:  		/* bc 12, CR0_EQ, 224 */
		/* 821BF6CCh case   10:*/		if ( regs.CR[0].eq ) { return 0x821BF7AC;  }
		/* 821BF6CCh case   10:*/		return 0x821BF6D0;
		  /* 821BF6D0h */ case   11:  		/* lwz R11, <#[R31 + 8]> */
		/* 821BF6D0h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821BF6D0h case   11:*/		return 0x821BF6D4;
		  /* 821BF6D4h */ case   12:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821BF6D4h case   12:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821BF6D4h case   12:*/		return 0x821BF6D8;
		  /* 821BF6D8h */ case   13:  		/* cmplwi CR6, R11, 14976 */
		/* 821BF6D8h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003A80);
		/* 821BF6D8h case   13:*/		return 0x821BF6DC;
		  /* 821BF6DCh */ case   14:  		/* bc 4, CR6_EQ, 60 */
		/* 821BF6DCh case   14:*/		if ( !regs.CR[6].eq ) { return 0x821BF718;  }
		/* 821BF6DCh case   14:*/		return 0x821BF6E0;
		  /* 821BF6E0h */ case   15:  		/* li R6, 0 */
		/* 821BF6E0h case   15:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821BF6E0h case   15:*/		return 0x821BF6E4;
		  /* 821BF6E4h */ case   16:  		/* li R5, 0 */
		/* 821BF6E4h case   16:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821BF6E4h case   16:*/		return 0x821BF6E8;
		  /* 821BF6E8h */ case   17:  		/* li R4, 117 */
		/* 821BF6E8h case   17:*/		cpu::op::li<0>(regs,&regs.R4,0x75);
		/* 821BF6E8h case   17:*/		return 0x821BF6EC;
		  /* 821BF6ECh */ case   18:  		/* mr R3, R27 */
		/* 821BF6ECh case   18:*/		regs.R3 = regs.R27;
		/* 821BF6ECh case   18:*/		return 0x821BF6F0;
		  /* 821BF6F0h */ case   19:  		/* bl -373440 */
		/* 821BF6F0h case   19:*/		regs.LR = 0x821BF6F4; return 0x82164430;
		/* 821BF6F0h case   19:*/		return 0x821BF6F4;
		  /* 821BF6F4h */ case   20:  		/* addi R11, R31, -16 */
		/* 821BF6F4h case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R31,0xFFFFFFF0);
		/* 821BF6F4h case   20:*/		return 0x821BF6F8;
		  /* 821BF6F8h */ case   21:  		/* add R11, R3, R11 */
		/* 821BF6F8h case   21:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 821BF6F8h case   21:*/		return 0x821BF6FC;
		  /* 821BF6FCh */ case   22:  		/* lwz R10, <#[R11]> */
		/* 821BF6FCh case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821BF6FCh case   22:*/		return 0x821BF700;
		  /* 821BF700h */ case   23:  		/* rlwinm R10, R10, 0, 29, 31 */
		/* 821BF700h case   23:*/		cpu::op::rlwinm<0,0,29,31>(regs,&regs.R10,regs.R10);
		/* 821BF700h case   23:*/		return 0x821BF704;
		  /* 821BF704h */ case   24:  		/* cmplwi CR6, R10, 7 */
		/* 821BF704h case   24:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000007);
		/* 821BF704h case   24:*/		return 0x821BF708;
		  /* 821BF708h */ case   25:  		/* bc 4, CR6_EQ, 16 */
		/* 821BF708h case   25:*/		if ( !regs.CR[6].eq ) { return 0x821BF718;  }
		/* 821BF708h case   25:*/		return 0x821BF70C;
		  /* 821BF70Ch */ case   26:  		/* lwz R11, <#[R11 + 4]> */
		/* 821BF70Ch case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821BF70Ch case   26:*/		return 0x821BF710;
		  /* 821BF710h */ case   27:  		/* cmpwi CR6, R11, 2 */
		/* 821BF710h case   27:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000002);
		/* 821BF710h case   27:*/		return 0x821BF714;
		  /* 821BF714h */ case   28:  		/* bc 12, CR6_EQ, 32 */
		/* 821BF714h case   28:*/		if ( regs.CR[6].eq ) { return 0x821BF734;  }
		/* 821BF714h case   28:*/		return 0x821BF718;
	}
	return 0x821BF718;
} // Block from 821BF6A4h-821BF718h (29 instructions)

//////////////////////////////////////////////////////
// Block at 821BF718h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF718( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF718) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF718);
		  /* 821BF718h */ case    0:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821BF718h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821BF718h case    0:*/		return 0x821BF71C;
		  /* 821BF71Ch */ case    1:  		/* lwz R11, <#[R11 + 36]> */
		/* 821BF71Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000024) );
		/* 821BF71Ch case    1:*/		return 0x821BF720;
		  /* 821BF720h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BF720h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BF720h case    2:*/		return 0x821BF724;
		  /* 821BF724h */ case    3:  		/* bc 4, CR0_EQ, 136 */
		/* 821BF724h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BF7AC;  }
		/* 821BF724h case    3:*/		return 0x821BF728;
		  /* 821BF728h */ case    4:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821BF728h case    4:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821BF728h case    4:*/		return 0x821BF72C;
		  /* 821BF72Ch */ case    5:  		/* addic. R31, R11, -40 */
		/* 821BF72Ch case    5:*/		cpu::op::addic<1>(regs,&regs.R31,regs.R11,0xFFFFFFD8);
		/* 821BF72Ch case    5:*/		return 0x821BF730;
		  /* 821BF730h */ case    6:  		/* bc 4, CR0_EQ, -96 */
		/* 821BF730h case    6:*/		if ( !regs.CR[0].eq ) { return 0x821BF6D0;  }
		/* 821BF730h case    6:*/		return 0x821BF734;
	}
	return 0x821BF734;
} // Block from 821BF718h-821BF734h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BF734h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF734( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF734) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF734);
		  /* 821BF734h */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 821BF734h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821BF734h case    0:*/		return 0x821BF738;
		  /* 821BF738h */ case    1:  		/* bc 12, CR6_EQ, 116 */
		/* 821BF738h case    1:*/		if ( regs.CR[6].eq ) { return 0x821BF7AC;  }
		/* 821BF738h case    1:*/		return 0x821BF73C;
		  /* 821BF73Ch */ case    2:  		/* lwz R11, <#[R31 + 8]> */
		/* 821BF73Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821BF73Ch case    2:*/		return 0x821BF740;
		  /* 821BF740h */ case    3:  		/* rlwinm. R10, R11, 6, 31, 31 */
		/* 821BF740h case    3:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R10,regs.R11);
		/* 821BF740h case    3:*/		return 0x821BF744;
		  /* 821BF744h */ case    4:  		/* bc 4, CR0_EQ, 52 */
		/* 821BF744h case    4:*/		if ( !regs.CR[0].eq ) { return 0x821BF778;  }
		/* 821BF744h case    4:*/		return 0x821BF748;
		  /* 821BF748h */ case    5:  		/* oris R11, R11, 1024 */
		/* 821BF748h case    5:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x400);
		/* 821BF748h case    5:*/		return 0x821BF74C;
		  /* 821BF74Ch */ case    6:  		/* lwz R30, <#[R31]> */
		/* 821BF74Ch case    6:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x00000000) );
		/* 821BF74Ch case    6:*/		return 0x821BF750;
		  /* 821BF750h */ case    7:  		/* stw R11, <#[R31 + 8]> */
		/* 821BF750h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821BF750h case    7:*/		return 0x821BF754;
		  /* 821BF754h */ case    8:  		/* cmplwi CR6, R30, 0 */
		/* 821BF754h case    8:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821BF754h case    8:*/		return 0x821BF758;
		  /* 821BF758h */ case    9:  		/* bc 12, CR6_EQ, 28 */
		/* 821BF758h case    9:*/		if ( regs.CR[6].eq ) { return 0x821BF774;  }
		/* 821BF758h case    9:*/		return 0x821BF75C;
		  /* 821BF75Ch */ case   10:  		/* li R5, 0 */
		/* 821BF75Ch case   10:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821BF75Ch case   10:*/		return 0x821BF760;
		  /* 821BF760h */ case   11:  		/* mr R4, R30 */
		/* 821BF760h case   11:*/		regs.R4 = regs.R30;
		/* 821BF760h case   11:*/		return 0x821BF764;
		  /* 821BF764h */ case   12:  		/* mr R3, R27 */
		/* 821BF764h case   12:*/		regs.R3 = regs.R27;
		/* 821BF764h case   12:*/		return 0x821BF768;
		  /* 821BF768h */ case   13:  		/* bl 452096 */
		/* 821BF768h case   13:*/		regs.LR = 0x821BF76C; return 0x8222DD68;
		/* 821BF768h case   13:*/		return 0x821BF76C;
		  /* 821BF76Ch */ case   14:  		/* lwz R30, <#[R30 + 4]> */
		/* 821BF76Ch case   14:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000004) );
		/* 821BF76Ch case   14:*/		return 0x821BF770;
		  /* 821BF770h */ case   15:  		/* b -28 */
		/* 821BF770h case   15:*/		return 0x821BF754;
		/* 821BF770h case   15:*/		return 0x821BF774;
	}
	return 0x821BF774;
} // Block from 821BF734h-821BF774h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821BF774h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF774( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF774) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF774);
		  /* 821BF774h */ case    0:  		/* li R30, 1 */
		/* 821BF774h case    0:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 821BF774h case    0:*/		return 0x821BF778;
	}
	return 0x821BF778;
} // Block from 821BF774h-821BF778h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BF778h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF778( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF778) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF778);
		  /* 821BF778h */ case    0:  		/* lwz R29, <#[R29 + 12]> */
		/* 821BF778h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R29 + 0x0000000C) );
		/* 821BF778h case    0:*/		return 0x821BF77C;
		  /* 821BF77Ch */ case    1:  		/* b -212 */
		/* 821BF77Ch case    1:*/		return 0x821BF6A8;
		/* 821BF77Ch case    1:*/		return 0x821BF780;
	}
	return 0x821BF780;
} // Block from 821BF778h-821BF780h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BF780h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF780( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF780) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF780);
		  /* 821BF780h */ case    0:  		/* rlwinm R11, R28, 0, 0, 30 */
		/* 821BF780h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R28);
		/* 821BF780h case    0:*/		return 0x821BF784;
		  /* 821BF784h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 821BF784h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821BF784h case    1:*/		return 0x821BF788;
		  /* 821BF788h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BF788h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BF788h case    2:*/		return 0x821BF78C;
		  /* 821BF78Ch */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 821BF78Ch case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BF79C;  }
		/* 821BF78Ch case    3:*/		return 0x821BF790;
		  /* 821BF790h */ case    4:  		/* mr R28, R11 */
		/* 821BF790h case    4:*/		regs.R28 = regs.R11;
		/* 821BF790h case    4:*/		return 0x821BF794;
		  /* 821BF794h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821BF794h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BF794h case    5:*/		return 0x821BF798;
		  /* 821BF798h */ case    6:  		/* bc 4, CR6_EQ, -308 */
		/* 821BF798h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821BF664;  }
		/* 821BF798h case    6:*/		return 0x821BF79C;
	}
	return 0x821BF79C;
} // Block from 821BF780h-821BF79Ch (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BF79Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF79C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF79C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF79C);
		  /* 821BF79Ch */ case    0:  		/* rlwinm. R11, R30, 0, 24, 31 */
		/* 821BF79Ch case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R30);
		/* 821BF79Ch case    0:*/		return 0x821BF7A0;
		  /* 821BF7A0h */ case    1:  		/* bc 4, CR0_EQ, -1188 */
		/* 821BF7A0h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821BF2FC;  }
		/* 821BF7A0h case    1:*/		return 0x821BF7A4;
	}
	return 0x821BF7A4;
} // Block from 821BF79Ch-821BF7A4h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BF7A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF7A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF7A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF7A4);
		  /* 821BF7A4h */ case    0:  		/* addi R1, R1, 144 */
		/* 821BF7A4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x90);
		/* 821BF7A4h case    0:*/		return 0x821BF7A8;
		  /* 821BF7A8h */ case    1:  		/* b -1238280 */
		/* 821BF7A8h case    1:*/		return 0x820912A0;
		/* 821BF7A8h case    1:*/		return 0x821BF7AC;
	}
	return 0x821BF7AC;
} // Block from 821BF7A4h-821BF7ACh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BF7ACh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF7AC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF7AC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF7AC);
		  /* 821BF7ACh */ case    0:  		/* li R4, 4800 */
		/* 821BF7ACh case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 821BF7ACh case    0:*/		return 0x821BF7B0;
		  /* 821BF7B0h */ case    1:  		/* mr R3, R27 */
		/* 821BF7B0h case    1:*/		regs.R3 = regs.R27;
		/* 821BF7B0h case    1:*/		return 0x821BF7B4;
		  /* 821BF7B4h */ case    2:  		/* bl -448844 */
		/* 821BF7B4h case    2:*/		regs.LR = 0x821BF7B8; return 0x82151E68;
		/* 821BF7B4h case    2:*/		return 0x821BF7B8;
	}
	return 0x821BF7B8;
} // Block from 821BF7ACh-821BF7B8h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BF7B8h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF7B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF7B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF7B8);
		  /* 821BF7B8h */ case    0:  		/* std R30, <#[R1 - 16]> */
		/* 821BF7B8h case    0:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821BF7B8h case    0:*/		return 0x821BF7BC;
		  /* 821BF7BCh */ case    1:  		/* std R31, <#[R1 - 8]> */
		/* 821BF7BCh case    1:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821BF7BCh case    1:*/		return 0x821BF7C0;
		  /* 821BF7C0h */ case    2:  		/* lwz R11, <#[R3 + 4]> */
		/* 821BF7C0h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821BF7C0h case    2:*/		return 0x821BF7C4;
		  /* 821BF7C4h */ case    3:  		/* li R6, 0 */
		/* 821BF7C4h case    3:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821BF7C4h case    3:*/		return 0x821BF7C8;
		  /* 821BF7C8h */ case    4:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BF7C8h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BF7C8h case    4:*/		return 0x821BF7CC;
		  /* 821BF7CCh */ case    5:  		/* bc 4, CR0_EQ, 152 */
		/* 821BF7CCh case    5:*/		if ( !regs.CR[0].eq ) { return 0x821BF864;  }
		/* 821BF7CCh case    5:*/		return 0x821BF7D0;
		  /* 821BF7D0h */ case    6:  		/* mr R8, R11 */
		/* 821BF7D0h case    6:*/		regs.R8 = regs.R11;
		/* 821BF7D0h case    6:*/		return 0x821BF7D4;
		  /* 821BF7D4h */ case    7:  		/* cmplwi CR0, R11, 0 */
		/* 821BF7D4h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821BF7D4h case    7:*/		return 0x821BF7D8;
		  /* 821BF7D8h */ case    8:  		/* bc 12, CR0_EQ, 140 */
		/* 821BF7D8h case    8:*/		if ( regs.CR[0].eq ) { return 0x821BF864;  }
		/* 821BF7D8h case    8:*/		return 0x821BF7DC;
		  /* 821BF7DCh */ case    9:  		/* lwz R11, <#[R8 + 48]> */
		/* 821BF7DCh case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000030) );
		/* 821BF7DCh case    9:*/		return 0x821BF7E0;
		  /* 821BF7E0h */ case   10:  		/* rlwinm. R11, R11, 2, 31, 31 */
		/* 821BF7E0h case   10:*/		cpu::op::rlwinm<1,2,31,31>(regs,&regs.R11,regs.R11);
		/* 821BF7E0h case   10:*/		return 0x821BF7E4;
		  /* 821BF7E4h */ case   11:  		/* bc 12, CR0_EQ, 100 */
		/* 821BF7E4h case   11:*/		if ( regs.CR[0].eq ) { return 0x821BF848;  }
		/* 821BF7E4h case   11:*/		return 0x821BF7E8;
		  /* 821BF7E8h */ case   12:  		/* lwz R7, <#[R8 + 12]> */
		/* 821BF7E8h case   12:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R8 + 0x0000000C) );
		/* 821BF7E8h case   12:*/		return 0x821BF7EC;
		  /* 821BF7ECh */ case   13:  		/* cmplwi CR6, R7, 0 */
		/* 821BF7ECh case   13:*/		cpu::op::cmplwi<6>(regs,regs.R7,0x00000000);
		/* 821BF7ECh case   13:*/		return 0x821BF7F0;
		  /* 821BF7F0h */ case   14:  		/* bc 12, CR6_EQ, 88 */
		/* 821BF7F0h case   14:*/		if ( regs.CR[6].eq ) { return 0x821BF848;  }
		/* 821BF7F0h case   14:*/		return 0x821BF7F4;
		  /* 821BF7F4h */ case   15:  		/* lwz R9, <#[R7]> */
		/* 821BF7F4h case   15:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R7 + 0x00000000) );
		/* 821BF7F4h case   15:*/		return 0x821BF7F8;
		  /* 821BF7F8h */ case   16:  		/* lwz R11, <#[R9 + 48]> */
		/* 821BF7F8h case   16:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000030) );
		/* 821BF7F8h case   16:*/		return 0x821BF7FC;
		  /* 821BF7FCh */ case   17:  		/* rlwinm. R10, R11, 2, 31, 31 */
		/* 821BF7FCh case   17:*/		cpu::op::rlwinm<1,2,31,31>(regs,&regs.R10,regs.R11);
		/* 821BF7FCh case   17:*/		return 0x821BF800;
		  /* 821BF800h */ case   18:  		/* bc 4, CR0_EQ, 64 */
		/* 821BF800h case   18:*/		if ( !regs.CR[0].eq ) { return 0x821BF840;  }
		/* 821BF800h case   18:*/		return 0x821BF804;
		  /* 821BF804h */ case   19:  		/* rlwinm. R10, R4, 0, 24, 31 */
		/* 821BF804h case   19:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R4);
		/* 821BF804h case   19:*/		return 0x821BF808;
		  /* 821BF808h */ case   20:  		/* bc 12, CR0_EQ, 44 */
		/* 821BF808h case   20:*/		if ( regs.CR[0].eq ) { return 0x821BF834;  }
		/* 821BF808h case   20:*/		return 0x821BF80C;
		  /* 821BF80Ch */ case   21:  		/* rlwinm R10, R11, 27, 18, 31 */
		/* 821BF80Ch case   21:*/		cpu::op::rlwinm<0,27,18,31>(regs,&regs.R10,regs.R11);
		/* 821BF80Ch case   21:*/		return 0x821BF810;
		  /* 821BF810h */ case   22:  		/* lwz R5, <#[R8 + 40]> */
		/* 821BF810h case   22:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R8 + 0x00000028) );
		/* 821BF810h case   22:*/		return 0x821BF814;
		  /* 821BF814h */ case   23:  		/* rlwinm R31, R11, 0, 27, 31 */
		/* 821BF814h case   23:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R31,regs.R11);
		/* 821BF814h case   23:*/		return 0x821BF818;
		  /* 821BF818h */ case   24:  		/* addi R10, R10, 1 */
		/* 821BF818h case   24:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821BF818h case   24:*/		return 0x821BF81C;
		  /* 821BF81Ch */ case   25:  		/* li R30, 1 */
		/* 821BF81Ch case   25:*/		cpu::op::li<0>(regs,&regs.R30,0x1);
		/* 821BF81Ch case   25:*/		return 0x821BF820;
		  /* 821BF820h */ case   26:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821BF820h case   26:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821BF820h case   26:*/		return 0x821BF824;
		  /* 821BF824h */ case   27:  		/* slw R31, R30, R31 */
		/* 821BF824h case   27:*/		cpu::op::slw<0>(regs,&regs.R31,regs.R30,regs.R31);
		/* 821BF824h case   27:*/		return 0x821BF828;
		  /* 821BF828h */ case   28:  		/* lwzx R10, <#[R10 + R5]> */
		/* 821BF828h case   28:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R5 + 0x00000000) );
		/* 821BF828h case   28:*/		return 0x821BF82C;
		  /* 821BF82Ch */ case   29:  		/* and. R10, R10, R31 */
		/* 821BF82Ch case   29:*/		cpu::op::and<1>(regs,&regs.R10,regs.R10,regs.R31);
		/* 821BF82Ch case   29:*/		return 0x821BF830;
		  /* 821BF830h */ case   30:  		/* bc 4, CR0_EQ, 16 */
		/* 821BF830h case   30:*/		if ( !regs.CR[0].eq ) { return 0x821BF840;  }
		/* 821BF830h case   30:*/		return 0x821BF834;
	}
	return 0x821BF834;
} // Block from 821BF7B8h-821BF834h (31 instructions)

//////////////////////////////////////////////////////
// Block at 821BF834h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF834( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF834) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF834);
		  /* 821BF834h */ case    0:  		/* oris R11, R11, 16384 */
		/* 821BF834h case    0:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x4000);
		/* 821BF834h case    0:*/		return 0x821BF838;
		  /* 821BF838h */ case    1:  		/* li R6, 1 */
		/* 821BF838h case    1:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821BF838h case    1:*/		return 0x821BF83C;
		  /* 821BF83Ch */ case    2:  		/* stw R11, <#[R9 + 48]> */
		/* 821BF83Ch case    2:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000030) );
		/* 821BF83Ch case    2:*/		return 0x821BF840;
	}
	return 0x821BF840;
} // Block from 821BF834h-821BF840h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BF840h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF840( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF840) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF840);
		  /* 821BF840h */ case    0:  		/* lwz R7, <#[R7 + 8]> */
		/* 821BF840h case    0:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R7 + 0x00000008) );
		/* 821BF840h case    0:*/		return 0x821BF844;
		  /* 821BF844h */ case    1:  		/* b -88 */
		/* 821BF844h case    1:*/		return 0x821BF7EC;
		/* 821BF844h case    1:*/		return 0x821BF848;
	}
	return 0x821BF848;
} // Block from 821BF840h-821BF848h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BF848h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF848( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF848) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF848);
		  /* 821BF848h */ case    0:  		/* rlwinm R11, R8, 0, 0, 30 */
		/* 821BF848h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R8);
		/* 821BF848h case    0:*/		return 0x821BF84C;
		  /* 821BF84Ch */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 821BF84Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821BF84Ch case    1:*/		return 0x821BF850;
		  /* 821BF850h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BF850h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BF850h case    2:*/		return 0x821BF854;
		  /* 821BF854h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 821BF854h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BF864;  }
		/* 821BF854h case    3:*/		return 0x821BF858;
		  /* 821BF858h */ case    4:  		/* mr R8, R11 */
		/* 821BF858h case    4:*/		regs.R8 = regs.R11;
		/* 821BF858h case    4:*/		return 0x821BF85C;
		  /* 821BF85Ch */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821BF85Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BF85Ch case    5:*/		return 0x821BF860;
		  /* 821BF860h */ case    6:  		/* bc 4, CR6_EQ, -132 */
		/* 821BF860h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821BF7DC;  }
		/* 821BF860h case    6:*/		return 0x821BF864;
	}
	return 0x821BF864;
} // Block from 821BF848h-821BF864h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BF864h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF864( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF864) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF864);
		  /* 821BF864h */ case    0:  		/* rlwinm. R11, R6, 0, 24, 31 */
		/* 821BF864h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R6);
		/* 821BF864h case    0:*/		return 0x821BF868;
		  /* 821BF868h */ case    1:  		/* bc 4, CR0_EQ, -168 */
		/* 821BF868h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821BF7C0;  }
		/* 821BF868h case    1:*/		return 0x821BF86C;
		  /* 821BF86Ch */ case    2:  		/* ld R30, <#[R1 - 16]> */
		/* 821BF86Ch case    2:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821BF86Ch case    2:*/		return 0x821BF870;
		  /* 821BF870h */ case    3:  		/* ld R31, <#[R1 - 8]> */
		/* 821BF870h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821BF870h case    3:*/		return 0x821BF874;
		  /* 821BF874h */ case    4:  		/* bclr 20, CR0_LT */
		/* 821BF874h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BF874h case    4:*/		return 0x821BF878;
	}
	return 0x821BF878;
} // Block from 821BF864h-821BF878h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BF878h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF878( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF878) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF878);
		  /* 821BF878h */ case    0:  		/* std R30, <#[R1 - 16]> */
		/* 821BF878h case    0:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821BF878h case    0:*/		return 0x821BF87C;
		  /* 821BF87Ch */ case    1:  		/* std R31, <#[R1 - 8]> */
		/* 821BF87Ch case    1:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821BF87Ch case    1:*/		return 0x821BF880;
		  /* 821BF880h */ case    2:  		/* lwz R11, <#[R3 + 4]> */
		/* 821BF880h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821BF880h case    2:*/		return 0x821BF884;
		  /* 821BF884h */ case    3:  		/* li R7, 0 */
		/* 821BF884h case    3:*/		cpu::op::li<0>(regs,&regs.R7,0x0);
		/* 821BF884h case    3:*/		return 0x821BF888;
		  /* 821BF888h */ case    4:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BF888h case    4:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BF888h case    4:*/		return 0x821BF88C;
		  /* 821BF88Ch */ case    5:  		/* bc 4, CR0_EQ, 156 */
		/* 821BF88Ch case    5:*/		if ( !regs.CR[0].eq ) { return 0x821BF928;  }
		/* 821BF88Ch case    5:*/		return 0x821BF890;
		  /* 821BF890h */ case    6:  		/* mr R9, R11 */
		/* 821BF890h case    6:*/		regs.R9 = regs.R11;
		/* 821BF890h case    6:*/		return 0x821BF894;
		  /* 821BF894h */ case    7:  		/* cmplwi CR0, R11, 0 */
		/* 821BF894h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821BF894h case    7:*/		return 0x821BF898;
		  /* 821BF898h */ case    8:  		/* bc 12, CR0_EQ, 144 */
		/* 821BF898h case    8:*/		if ( regs.CR[0].eq ) { return 0x821BF928;  }
		/* 821BF898h case    8:*/		return 0x821BF89C;
		  /* 821BF89Ch */ case    9:  		/* lwz R11, <#[R9 + 44]> */
		/* 821BF89Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x0000002C) );
		/* 821BF89Ch case    9:*/		return 0x821BF8A0;
		  /* 821BF8A0h */ case   10:  		/* cmplw CR6, R11, R4 */
		/* 821BF8A0h case   10:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R4);
		/* 821BF8A0h case   10:*/		return 0x821BF8A4;
		  /* 821BF8A4h */ case   11:  		/* bc 4, CR6_EQ, 104 */
		/* 821BF8A4h case   11:*/		if ( !regs.CR[6].eq ) { return 0x821BF90C;  }
		/* 821BF8A4h case   11:*/		return 0x821BF8A8;
		  /* 821BF8A8h */ case   12:  		/* lwz R8, <#[R9 + 12]> */
		/* 821BF8A8h case   12:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R9 + 0x0000000C) );
		/* 821BF8A8h case   12:*/		return 0x821BF8AC;
		  /* 821BF8ACh */ case   13:  		/* cmplwi CR6, R8, 0 */
		/* 821BF8ACh case   13:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 821BF8ACh case   13:*/		return 0x821BF8B0;
		  /* 821BF8B0h */ case   14:  		/* bc 12, CR6_EQ, 92 */
		/* 821BF8B0h case   14:*/		if ( regs.CR[6].eq ) { return 0x821BF90C;  }
		/* 821BF8B0h case   14:*/		return 0x821BF8B4;
		  /* 821BF8B4h */ case   15:  		/* lwz R11, <#[R8]> */
		/* 821BF8B4h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000000) );
		/* 821BF8B4h case   15:*/		return 0x821BF8B8;
		  /* 821BF8B8h */ case   16:  		/* lwz R10, <#[R11 + 44]> */
		/* 821BF8B8h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000002C) );
		/* 821BF8B8h case   16:*/		return 0x821BF8BC;
		  /* 821BF8BCh */ case   17:  		/* cmplw CR6, R10, R4 */
		/* 821BF8BCh case   17:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R4);
		/* 821BF8BCh case   17:*/		return 0x821BF8C0;
		  /* 821BF8C0h */ case   18:  		/* bc 12, CR6_EQ, 68 */
		/* 821BF8C0h case   18:*/		if ( regs.CR[6].eq ) { return 0x821BF904;  }
		/* 821BF8C0h case   18:*/		return 0x821BF8C4;
		  /* 821BF8C4h */ case   19:  		/* rlwinm. R10, R5, 0, 24, 31 */
		/* 821BF8C4h case   19:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R10,regs.R5);
		/* 821BF8C4h case   19:*/		return 0x821BF8C8;
		  /* 821BF8C8h */ case   20:  		/* bc 12, CR0_EQ, 52 */
		/* 821BF8C8h case   20:*/		if ( regs.CR[0].eq ) { return 0x821BF8FC;  }
		/* 821BF8C8h case   20:*/		return 0x821BF8CC;
		  /* 821BF8CCh */ case   21:  		/* lwz R10, <#[R11 + 48]> */
		/* 821BF8CCh case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000030) );
		/* 821BF8CCh case   21:*/		return 0x821BF8D0;
		  /* 821BF8D0h */ case   22:  		/* li R6, 1 */
		/* 821BF8D0h case   22:*/		cpu::op::li<0>(regs,&regs.R6,0x1);
		/* 821BF8D0h case   22:*/		return 0x821BF8D4;
		  /* 821BF8D4h */ case   23:  		/* lwz R31, <#[R9 + 40]> */
		/* 821BF8D4h case   23:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R9 + 0x00000028) );
		/* 821BF8D4h case   23:*/		return 0x821BF8D8;
		  /* 821BF8D8h */ case   24:  		/* rlwinm R30, R10, 0, 13, 31 */
		/* 821BF8D8h case   24:*/		cpu::op::rlwinm<0,0,13,31>(regs,&regs.R30,regs.R10);
		/* 821BF8D8h case   24:*/		return 0x821BF8DC;
		  /* 821BF8DCh */ case   25:  		/* rlwinm R10, R30, 27, 5, 31 */
		/* 821BF8DCh case   25:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R30);
		/* 821BF8DCh case   25:*/		return 0x821BF8E0;
		  /* 821BF8E0h */ case   26:  		/* rlwinm R30, R30, 0, 27, 31 */
		/* 821BF8E0h case   26:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R30,regs.R30);
		/* 821BF8E0h case   26:*/		return 0x821BF8E4;
		  /* 821BF8E4h */ case   27:  		/* addi R10, R10, 1 */
		/* 821BF8E4h case   27:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821BF8E4h case   27:*/		return 0x821BF8E8;
		  /* 821BF8E8h */ case   28:  		/* slw R6, R6, R30 */
		/* 821BF8E8h case   28:*/		cpu::op::slw<0>(regs,&regs.R6,regs.R6,regs.R30);
		/* 821BF8E8h case   28:*/		return 0x821BF8EC;
		  /* 821BF8ECh */ case   29:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821BF8ECh case   29:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821BF8ECh case   29:*/		return 0x821BF8F0;
		  /* 821BF8F0h */ case   30:  		/* lwzx R10, <#[R10 + R31]> */
		/* 821BF8F0h case   30:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R31 + 0x00000000) );
		/* 821BF8F0h case   30:*/		return 0x821BF8F4;
		  /* 821BF8F4h */ case   31:  		/* and. R10, R10, R6 */
		/* 821BF8F4h case   31:*/		cpu::op::and<1>(regs,&regs.R10,regs.R10,regs.R6);
		/* 821BF8F4h case   31:*/		return 0x821BF8F8;
		  /* 821BF8F8h */ case   32:  		/* bc 4, CR0_EQ, 12 */
		/* 821BF8F8h case   32:*/		if ( !regs.CR[0].eq ) { return 0x821BF904;  }
		/* 821BF8F8h case   32:*/		return 0x821BF8FC;
	}
	return 0x821BF8FC;
} // Block from 821BF878h-821BF8FCh (33 instructions)

//////////////////////////////////////////////////////
// Block at 821BF8FCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF8FC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF8FC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF8FC);
		  /* 821BF8FCh */ case    0:  		/* stw R4, <#[R11 + 44]> */
		/* 821BF8FCh case    0:*/		cpu::mem::store32( regs, regs.R4, (uint32)(regs.R11 + 0x0000002C) );
		/* 821BF8FCh case    0:*/		return 0x821BF900;
		  /* 821BF900h */ case    1:  		/* li R7, 1 */
		/* 821BF900h case    1:*/		cpu::op::li<0>(regs,&regs.R7,0x1);
		/* 821BF900h case    1:*/		return 0x821BF904;
	}
	return 0x821BF904;
} // Block from 821BF8FCh-821BF904h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BF904h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF904( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF904) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF904);
		  /* 821BF904h */ case    0:  		/* lwz R8, <#[R8 + 8]> */
		/* 821BF904h case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R8 + 0x00000008) );
		/* 821BF904h case    0:*/		return 0x821BF908;
		  /* 821BF908h */ case    1:  		/* b -92 */
		/* 821BF908h case    1:*/		return 0x821BF8AC;
		/* 821BF908h case    1:*/		return 0x821BF90C;
	}
	return 0x821BF90C;
} // Block from 821BF904h-821BF90Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BF90Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF90C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF90C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF90C);
		  /* 821BF90Ch */ case    0:  		/* rlwinm R11, R9, 0, 0, 30 */
		/* 821BF90Ch case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R9);
		/* 821BF90Ch case    0:*/		return 0x821BF910;
		  /* 821BF910h */ case    1:  		/* lwz R11, <#[R11 + 4]> */
		/* 821BF910h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821BF910h case    1:*/		return 0x821BF914;
		  /* 821BF914h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BF914h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BF914h case    2:*/		return 0x821BF918;
		  /* 821BF918h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 821BF918h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BF928;  }
		/* 821BF918h case    3:*/		return 0x821BF91C;
		  /* 821BF91Ch */ case    4:  		/* mr R9, R11 */
		/* 821BF91Ch case    4:*/		regs.R9 = regs.R11;
		/* 821BF91Ch case    4:*/		return 0x821BF920;
		  /* 821BF920h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821BF920h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BF920h case    5:*/		return 0x821BF924;
		  /* 821BF924h */ case    6:  		/* bc 4, CR6_EQ, -136 */
		/* 821BF924h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821BF89C;  }
		/* 821BF924h case    6:*/		return 0x821BF928;
	}
	return 0x821BF928;
} // Block from 821BF90Ch-821BF928h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BF928h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF928( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF928) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF928);
		  /* 821BF928h */ case    0:  		/* rlwinm. R11, R7, 0, 24, 31 */
		/* 821BF928h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R7);
		/* 821BF928h case    0:*/		return 0x821BF92C;
		  /* 821BF92Ch */ case    1:  		/* bc 4, CR0_EQ, -172 */
		/* 821BF92Ch case    1:*/		if ( !regs.CR[0].eq ) { return 0x821BF880;  }
		/* 821BF92Ch case    1:*/		return 0x821BF930;
		  /* 821BF930h */ case    2:  		/* ld R30, <#[R1 - 16]> */
		/* 821BF930h case    2:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821BF930h case    2:*/		return 0x821BF934;
		  /* 821BF934h */ case    3:  		/* ld R31, <#[R1 - 8]> */
		/* 821BF934h case    3:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821BF934h case    3:*/		return 0x821BF938;
		  /* 821BF938h */ case    4:  		/* bclr 20, CR0_LT */
		/* 821BF938h case    4:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821BF938h case    4:*/		return 0x821BF93C;
	}
	return 0x821BF93C;
} // Block from 821BF928h-821BF93Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BF93Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF93C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF93C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF93C);
		  /* 821BF93Ch */ case    0:  		/* nop */
		/* 821BF93Ch case    0:*/		cpu::op::nop();
		/* 821BF93Ch case    0:*/		return 0x821BF940;
	}
	return 0x821BF940;
} // Block from 821BF93Ch-821BF940h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BF940h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF940( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF940) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF940);
		  /* 821BF940h */ case    0:  		/* mfspr R12, LR */
		/* 821BF940h case    0:*/		regs.R12 = regs.LR;
		/* 821BF940h case    0:*/		return 0x821BF944;
		  /* 821BF944h */ case    1:  		/* bl -1238788 */
		/* 821BF944h case    1:*/		regs.LR = 0x821BF948; return 0x82091240;
		/* 821BF944h case    1:*/		return 0x821BF948;
		  /* 821BF948h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 821BF948h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 821BF948h case    2:*/		return 0x821BF94C;
		  /* 821BF94Ch */ case    3:  		/* lwz R11, <#[R4 + 4]> */
		/* 821BF94Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 821BF94Ch case    3:*/		return 0x821BF950;
		  /* 821BF950h */ case    4:  		/* mr R26, R3 */
		/* 821BF950h case    4:*/		regs.R26 = regs.R3;
		/* 821BF950h case    4:*/		return 0x821BF954;
		  /* 821BF954h */ case    5:  		/* mr R24, R5 */
		/* 821BF954h case    5:*/		regs.R24 = regs.R5;
		/* 821BF954h case    5:*/		return 0x821BF958;
		  /* 821BF958h */ case    6:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BF958h case    6:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BF958h case    6:*/		return 0x821BF95C;
		  /* 821BF95Ch */ case    7:  		/* bc 4, CR0_EQ, 1528 */
		/* 821BF95Ch case    7:*/		if ( !regs.CR[0].eq ) { return 0x821BFF54;  }
		/* 821BF95Ch case    7:*/		return 0x821BF960;
		  /* 821BF960h */ case    8:  		/* mr R27, R11 */
		/* 821BF960h case    8:*/		regs.R27 = regs.R11;
		/* 821BF960h case    8:*/		return 0x821BF964;
		  /* 821BF964h */ case    9:  		/* cmplwi CR0, R11, 0 */
		/* 821BF964h case    9:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821BF964h case    9:*/		return 0x821BF968;
		  /* 821BF968h */ case   10:  		/* bc 12, CR0_EQ, 1516 */
		/* 821BF968h case   10:*/		if ( regs.CR[0].eq ) { return 0x821BFF54;  }
		/* 821BF968h case   10:*/		return 0x821BF96C;
		  /* 821BF96Ch */ case   11:  		/* rlwinm R22, R6, 0, 24, 31 */
		/* 821BF96Ch case   11:*/		cpu::op::rlwinm<0,0,24,31>(regs,&regs.R22,regs.R6);
		/* 821BF96Ch case   11:*/		return 0x821BF970;
		  /* 821BF970h */ case   12:  		/* li R23, 1 */
		/* 821BF970h case   12:*/		cpu::op::li<0>(regs,&regs.R23,0x1);
		/* 821BF970h case   12:*/		return 0x821BF974;
		  /* 821BF974h */ case   13:  		/* cmplwi CR6, R22, 0 */
		/* 821BF974h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 821BF974h case   13:*/		return 0x821BF978;
		  /* 821BF978h */ case   14:  		/* bc 12, CR6_EQ, 16 */
		/* 821BF978h case   14:*/		if ( regs.CR[6].eq ) { return 0x821BF988;  }
		/* 821BF978h case   14:*/		return 0x821BF97C;
		  /* 821BF97Ch */ case   15:  		/* lwz R11, <#[R27 + 8]> */
		/* 821BF97Ch case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 821BF97Ch case   15:*/		return 0x821BF980;
		  /* 821BF980h */ case   16:  		/* rlwinm. R11, R11, 6, 31, 31 */
		/* 821BF980h case   16:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R11,regs.R11);
		/* 821BF980h case   16:*/		return 0x821BF984;
		  /* 821BF984h */ case   17:  		/* bc 12, CR0_EQ, 1460 */
		/* 821BF984h case   17:*/		if ( regs.CR[0].eq ) { return 0x821BFF38;  }
		/* 821BF984h case   17:*/		return 0x821BF988;
	}
	return 0x821BF988;
} // Block from 821BF940h-821BF988h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821BF988h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF988( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF988) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF988);
		  /* 821BF988h */ case    0:  		/* lwz R25, <#[R27 + 32]> */
		/* 821BF988h case    0:*/		cpu::mem::load32z( regs, &regs.R25, (uint32)(regs.R27 + 0x00000020) );
		/* 821BF988h case    0:*/		return 0x821BF98C;
		  /* 821BF98Ch */ case    1:  		/* lwz R29, <#[R27]> */
		/* 821BF98Ch case    1:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R27 + 0x00000000) );
		/* 821BF98Ch case    1:*/		return 0x821BF990;
		  /* 821BF990h */ case    2:  		/* cmplwi CR6, R29, 0 */
		/* 821BF990h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 821BF990h case    2:*/		return 0x821BF994;
		  /* 821BF994h */ case    3:  		/* bc 12, CR6_EQ, 760 */
		/* 821BF994h case    3:*/		if ( regs.CR[6].eq ) { return 0x821BFC8C;  }
		/* 821BF994h case    3:*/		return 0x821BF998;
		  /* 821BF998h */ case    4:  		/* lwz R5, <#[R29 + 12]> */
		/* 821BF998h case    4:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R29 + 0x0000000C) );
		/* 821BF998h case    4:*/		return 0x821BF99C;
		  /* 821BF99Ch */ case    5:  		/* cmplwi CR6, R22, 0 */
		/* 821BF99Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 821BF99Ch case    5:*/		return 0x821BF9A0;
		  /* 821BF9A0h */ case    6:  		/* bc 12, CR6_EQ, 16 */
		/* 821BF9A0h case    6:*/		if ( regs.CR[6].eq ) { return 0x821BF9B0;  }
		/* 821BF9A0h case    6:*/		return 0x821BF9A4;
		  /* 821BF9A4h */ case    7:  		/* lwz R11, <#[R5 + 8]> */
		/* 821BF9A4h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000008) );
		/* 821BF9A4h case    7:*/		return 0x821BF9A8;
		  /* 821BF9A8h */ case    8:  		/* rlwinm. R11, R11, 6, 31, 31 */
		/* 821BF9A8h case    8:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R11,regs.R11);
		/* 821BF9A8h case    8:*/		return 0x821BF9AC;
		  /* 821BF9ACh */ case    9:  		/* bc 12, CR0_EQ, 24 */
		/* 821BF9ACh case    9:*/		if ( regs.CR[0].eq ) { return 0x821BF9C4;  }
		/* 821BF9ACh case    9:*/		return 0x821BF9B0;
	}
	return 0x821BF9B0;
} // Block from 821BF988h-821BF9B0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821BF9B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF9B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF9B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF9B0);
		  /* 821BF9B0h */ case    0:  		/* lwz R11, <#[R5 + 28]> */
		/* 821BF9B0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x0000001C) );
		/* 821BF9B0h case    0:*/		return 0x821BF9B4;
		  /* 821BF9B4h */ case    1:  		/* lwz R11, <#[R11 + 44]> */
		/* 821BF9B4h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000002C) );
		/* 821BF9B4h case    1:*/		return 0x821BF9B8;
		  /* 821BF9B8h */ case    2:  		/* cmplw CR6, R11, R24 */
		/* 821BF9B8h case    2:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R24);
		/* 821BF9B8h case    2:*/		return 0x821BF9BC;
		  /* 821BF9BCh */ case    3:  		/* bc 4, CR6_EQ, 8 */
		/* 821BF9BCh case    3:*/		if ( !regs.CR[6].eq ) { return 0x821BF9C4;  }
		/* 821BF9BCh case    3:*/		return 0x821BF9C0;
		  /* 821BF9C0h */ case    4:  		/* lwz R5, <#[R5 + 32]> */
		/* 821BF9C0h case    4:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R5 + 0x00000020) );
		/* 821BF9C0h case    4:*/		return 0x821BF9C4;
	}
	return 0x821BF9C4;
} // Block from 821BF9B0h-821BF9C4h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BF9C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF9C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF9C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF9C4);
		  /* 821BF9C4h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 821BF9C4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 821BF9C4h case    0:*/		return 0x821BF9C8;
		  /* 821BF9C8h */ case    1:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 821BF9C8h case    1:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 821BF9C8h case    1:*/		return 0x821BF9CC;
		  /* 821BF9CCh */ case    2:  		/* bc 4, CR0_EQ, 20 */
		/* 821BF9CCh case    2:*/		if ( !regs.CR[0].eq ) { return 0x821BF9E0;  }
		/* 821BF9CCh case    2:*/		return 0x821BF9D0;
		  /* 821BF9D0h */ case    3:  		/* lwz R11, <#[R5 + 28]> */
		/* 821BF9D0h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x0000001C) );
		/* 821BF9D0h case    3:*/		return 0x821BF9D4;
		  /* 821BF9D4h */ case    4:  		/* lwz R10, <#[R25 + 28]> */
		/* 821BF9D4h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R25 + 0x0000001C) );
		/* 821BF9D4h case    4:*/		return 0x821BF9D8;
		  /* 821BF9D8h */ case    5:  		/* cmpw CR6, R11, R10 */
		/* 821BF9D8h case    5:*/		cpu::op::cmpw<6>(regs,regs.R11,regs.R10);
		/* 821BF9D8h case    5:*/		return 0x821BF9DC;
		  /* 821BF9DCh */ case    6:  		/* bc 4, CR6_EQ, 680 */
		/* 821BF9DCh case    6:*/		if ( !regs.CR[6].eq ) { return 0x821BFC84;  }
		/* 821BF9DCh case    6:*/		return 0x821BF9E0;
	}
	return 0x821BF9E0;
} // Block from 821BF9C4h-821BF9E0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BF9E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BF9E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BF9E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BF9E0);
		  /* 821BF9E0h */ case    0:  		/* mr R4, R29 */
		/* 821BF9E0h case    0:*/		regs.R4 = regs.R29;
		/* 821BF9E0h case    0:*/		return 0x821BF9E4;
		  /* 821BF9E4h */ case    1:  		/* mr R3, R26 */
		/* 821BF9E4h case    1:*/		regs.R3 = regs.R26;
		/* 821BF9E4h case    1:*/		return 0x821BF9E8;
		  /* 821BF9E8h */ case    2:  		/* bl -321784 */
		/* 821BF9E8h case    2:*/		regs.LR = 0x821BF9EC; return 0x821710F0;
		/* 821BF9E8h case    2:*/		return 0x821BF9EC;
		  /* 821BF9ECh */ case    3:  		/* mr R4, R3 */
		/* 821BF9ECh case    3:*/		regs.R4 = regs.R3;
		/* 821BF9ECh case    3:*/		return 0x821BF9F0;
		  /* 821BF9F0h */ case    4:  		/* mr R3, R25 */
		/* 821BF9F0h case    4:*/		regs.R3 = regs.R25;
		/* 821BF9F0h case    4:*/		return 0x821BF9F4;
		  /* 821BF9F4h */ case    5:  		/* bl -292908 */
		/* 821BF9F4h case    5:*/		regs.LR = 0x821BF9F8; return 0x821781C8;
		/* 821BF9F4h case    5:*/		return 0x821BF9F8;
		  /* 821BF9F8h */ case    6:  		/* lwz R11, <#[R25 + 8]> */
		/* 821BF9F8h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 821BF9F8h case    6:*/		return 0x821BF9FC;
		  /* 821BF9FCh */ case    7:  		/* mr R30, R3 */
		/* 821BF9FCh case    7:*/		regs.R30 = regs.R3;
		/* 821BF9FCh case    7:*/		return 0x821BFA00;
		  /* 821BFA00h */ case    8:  		/* rlwinm R6, R11, 25, 25, 31 */
		/* 821BFA00h case    8:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R6,regs.R11);
		/* 821BFA00h case    8:*/		return 0x821BFA04;
		  /* 821BFA04h */ case    9:  		/* cmplwi CR6, R6, 119 */
		/* 821BFA04h case    9:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000077);
		/* 821BFA04h case    9:*/		return 0x821BFA08;
		  /* 821BFA08h */ case   10:  		/* bc 4, CR6_EQ, 100 */
		/* 821BFA08h case   10:*/		if ( !regs.CR[6].eq ) { return 0x821BFA6C;  }
		/* 821BFA08h case   10:*/		return 0x821BFA0C;
		  /* 821BFA0Ch */ case   11:  		/* li R6, 0 */
		/* 821BFA0Ch case   11:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821BFA0Ch case   11:*/		return 0x821BFA10;
		  /* 821BFA10h */ case   12:  		/* li R5, 0 */
		/* 821BFA10h case   12:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821BFA10h case   12:*/		return 0x821BFA14;
		  /* 821BFA14h */ case   13:  		/* li R4, 119 */
		/* 821BFA14h case   13:*/		cpu::op::li<0>(regs,&regs.R4,0x77);
		/* 821BFA14h case   13:*/		return 0x821BFA18;
		  /* 821BFA18h */ case   14:  		/* mr R3, R26 */
		/* 821BFA18h case   14:*/		regs.R3 = regs.R26;
		/* 821BFA18h case   14:*/		return 0x821BFA1C;
		  /* 821BFA1Ch */ case   15:  		/* bl -374252 */
		/* 821BFA1Ch case   15:*/		regs.LR = 0x821BFA20; return 0x82164430;
		/* 821BFA1Ch case   15:*/		return 0x821BFA20;
		  /* 821BFA20h */ case   16:  		/* add R11, R3, R27 */
		/* 821BFA20h case   16:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R27);
		/* 821BFA20h case   16:*/		return 0x821BFA24;
		  /* 821BFA24h */ case   17:  		/* li R10, 0 */
		/* 821BFA24h case   17:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821BFA24h case   17:*/		return 0x821BFA28;
		  /* 821BFA28h */ case   18:  		/* add R7, R3, R25 */
		/* 821BFA28h case   18:*/		cpu::op::add<0>(regs,&regs.R7,regs.R3,regs.R25);
		/* 821BFA28h case   18:*/		return 0x821BFA2C;
		  /* 821BFA2Ch */ case   19:  		/* lwz R9, <#[R11 - 8]> */
		/* 821BFA2Ch case   19:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0xFFFFFFF8) );
		/* 821BFA2Ch case   19:*/		return 0x821BFA30;
		  /* 821BFA30h */ case   20:  		/* cmplwi CR6, R9, 0 */
		/* 821BFA30h case   20:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 821BFA30h case   20:*/		return 0x821BFA34;
		  /* 821BFA34h */ case   21:  		/* bc 12, CR6_EQ, 40 */
		/* 821BFA34h case   21:*/		if ( regs.CR[6].eq ) { return 0x821BFA5C;  }
		/* 821BFA34h case   21:*/		return 0x821BFA38;
		  /* 821BFA38h */ case   22:  		/* lwz R8, <#[R11 - 4]> */
		/* 821BFA38h case   22:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0xFFFFFFFC) );
		/* 821BFA38h case   22:*/		return 0x821BFA3C;
		  /* 821BFA3Ch */ case   23:  		/* li R11, 0 */
		/* 821BFA3Ch case   23:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BFA3Ch case   23:*/		return 0x821BFA40;
		  /* 821BFA40h */ case   24:  		/* lwzx R6, <#[R11 + R8]> */
		/* 821BFA40h case   24:*/		cpu::mem::load32z( regs, &regs.R6, (uint32)(regs.R11 + regs.R8 + 0x00000000) );
		/* 821BFA40h case   24:*/		return 0x821BFA44;
		  /* 821BFA44h */ case   25:  		/* cmplw CR6, R6, R29 */
		/* 821BFA44h case   25:*/		cpu::op::cmplw<6>(regs,regs.R6,regs.R29);
		/* 821BFA44h case   25:*/		return 0x821BFA48;
		  /* 821BFA48h */ case   26:  		/* bc 12, CR6_EQ, 20 */
		/* 821BFA48h case   26:*/		if ( regs.CR[6].eq ) { return 0x821BFA5C;  }
		/* 821BFA48h case   26:*/		return 0x821BFA4C;
		  /* 821BFA4Ch */ case   27:  		/* addi R10, R10, 1 */
		/* 821BFA4Ch case   27:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821BFA4Ch case   27:*/		return 0x821BFA50;
		  /* 821BFA50h */ case   28:  		/* addi R11, R11, 4 */
		/* 821BFA50h case   28:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821BFA50h case   28:*/		return 0x821BFA54;
		  /* 821BFA54h */ case   29:  		/* cmplw CR6, R10, R9 */
		/* 821BFA54h case   29:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 821BFA54h case   29:*/		return 0x821BFA58;
		  /* 821BFA58h */ case   30:  		/* bc 12, CR6_LT, -24 */
		/* 821BFA58h case   30:*/		if ( regs.CR[6].lt ) { return 0x821BFA40;  }
		/* 821BFA58h case   30:*/		return 0x821BFA5C;
	}
	return 0x821BFA5C;
} // Block from 821BF9E0h-821BFA5Ch (31 instructions)

//////////////////////////////////////////////////////
// Block at 821BFA5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BFA5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BFA5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BFA5C);
		  /* 821BFA5Ch */ case    0:  		/* lwz R11, <#[R7 - 4]> */
		/* 821BFA5Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R7 + 0xFFFFFFFC) );
		/* 821BFA5Ch case    0:*/		return 0x821BFA60;
		  /* 821BFA60h */ case    1:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821BFA60h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821BFA60h case    1:*/		return 0x821BFA64;
		  /* 821BFA64h */ case    2:  		/* stwx R30, <#[R10 + R11]> */
		/* 821BFA64h case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R10 + regs.R11 + 0x00000000) );
		/* 821BFA64h case    2:*/		return 0x821BFA68;
		  /* 821BFA68h */ case    3:  		/* b 540 */
		/* 821BFA68h case    3:*/		return 0x821BFC84;
		/* 821BFA68h case    3:*/		return 0x821BFA6C;
	}
	return 0x821BFA6C;
} // Block from 821BFA5Ch-821BFA6Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BFA6Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BFA6C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BFA6C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BFA6C);
		  /* 821BFA6Ch */ case    0:  		/* lwz R8, <#[R27 + 8]> */
		/* 821BFA6Ch case    0:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R27 + 0x00000008) );
		/* 821BFA6Ch case    0:*/		return 0x821BFA70;
		  /* 821BFA70h */ case    1:  		/* li R9, 0 */
		/* 821BFA70h case    1:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821BFA70h case    1:*/		return 0x821BFA74;
		  /* 821BFA74h */ case    2:  		/* li R10, 0 */
		/* 821BFA74h case    2:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821BFA74h case    2:*/		return 0x821BFA78;
		  /* 821BFA78h */ case    3:  		/* addi R11, R27, 44 */
		/* 821BFA78h case    3:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R27,0x2C);
		/* 821BFA78h case    3:*/		return 0x821BFA7C;
		  /* 821BFA7Ch */ case    4:  		/* rlwinm R7, R8, 13, 29, 31 */
		/* 821BFA7Ch case    4:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R7,regs.R8);
		/* 821BFA7Ch case    4:*/		return 0x821BFA80;
		  /* 821BFA80h */ case    5:  		/* cmplw CR6, R10, R7 */
		/* 821BFA80h case    5:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R7);
		/* 821BFA80h case    5:*/		return 0x821BFA84;
		  /* 821BFA84h */ case    6:  		/* bc 4, CR6_LT, 56 */
		/* 821BFA84h case    6:*/		if ( !regs.CR[6].lt ) { return 0x821BFABC;  }
		/* 821BFA84h case    6:*/		return 0x821BFA88;
		  /* 821BFA88h */ case    7:  		/* lwz R8, <#[R11]> */
		/* 821BFA88h case    7:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000000) );
		/* 821BFA88h case    7:*/		return 0x821BFA8C;
		  /* 821BFA8Ch */ case    8:  		/* cmplw CR6, R8, R29 */
		/* 821BFA8Ch case    8:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R29);
		/* 821BFA8Ch case    8:*/		return 0x821BFA90;
		  /* 821BFA90h */ case    9:  		/* bc 12, CR6_EQ, 20 */
		/* 821BFA90h case    9:*/		if ( regs.CR[6].eq ) { return 0x821BFAA4;  }
		/* 821BFA90h case    9:*/		return 0x821BFA94;
		  /* 821BFA94h */ case   10:  		/* addi R9, R9, 1 */
		/* 821BFA94h case   10:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R9,0x1);
		/* 821BFA94h case   10:*/		return 0x821BFA98;
		  /* 821BFA98h */ case   11:  		/* addi R10, R10, 1 */
		/* 821BFA98h case   11:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821BFA98h case   11:*/		return 0x821BFA9C;
		  /* 821BFA9Ch */ case   12:  		/* addi R11, R11, 4 */
		/* 821BFA9Ch case   12:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821BFA9Ch case   12:*/		return 0x821BFAA0;
		  /* 821BFAA0h */ case   13:  		/* b -32 */
		/* 821BFAA0h case   13:*/		return 0x821BFA80;
		/* 821BFAA0h case   13:*/		return 0x821BFAA4;
	}
	return 0x821BFAA4;
} // Block from 821BFA6Ch-821BFAA4h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821BFAA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BFAA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BFAA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BFAA4);
		  /* 821BFAA4h */ case    0:  		/* cmplwi CR6, R8, 0 */
		/* 821BFAA4h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R8,0x00000000);
		/* 821BFAA4h case    0:*/		return 0x821BFAA8;
	}
	return 0x821BFAA8;
} // Block from 821BFAA4h-821BFAA8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BFAA8h
// Function '?IsControlledByDynamicBranch@Compiler@D3DXShader@@AAA_NPAVBlock@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BFAA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BFAA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BFAA8);
		  /* 821BFAA8h */ case    0:  		/* bc 12, CR6_EQ, 20 */
		/* 821BFAA8h case    0:*/		if ( regs.CR[6].eq ) { return 0x821BFABC;  }
		/* 821BFAA8h case    0:*/		return 0x821BFAAC;
		  /* 821BFAACh */ case    1:  		/* addi R11, R9, 11 */
		/* 821BFAACh case    1:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R9,0xB);
		/* 821BFAACh case    1:*/		return 0x821BFAB0;
		  /* 821BFAB0h */ case    2:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821BFAB0h case    2:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821BFAB0h case    2:*/		return 0x821BFAB4;
		  /* 821BFAB4h */ case    3:  		/* stwx R30, <#[R11 + R25]> */
		/* 821BFAB4h case    3:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + regs.R25 + 0x00000000) );
		/* 821BFAB4h case    3:*/		return 0x821BFAB8;
		  /* 821BFAB8h */ case    4:  		/* b 460 */
		/* 821BFAB8h case    4:*/		return 0x821BFC84;
		/* 821BFAB8h case    4:*/		return 0x821BFABC;
	}
	return 0x821BFABC;
} // Block from 821BFAA8h-821BFABCh (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BFABCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BFABC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BFABC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BFABC);
		  /* 821BFABCh */ case    0:  		/* cmplwi CR6, R6, 97 */
		/* 821BFABCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000061);
		/* 821BFABCh case    0:*/		return 0x821BFAC0;
		  /* 821BFAC0h */ case    1:  		/* bc 12, CR6_EQ, 24 */
		/* 821BFAC0h case    1:*/		if ( regs.CR[6].eq ) { return 0x821BFAD8;  }
		/* 821BFAC0h case    1:*/		return 0x821BFAC4;
		  /* 821BFAC4h */ case    2:  		/* cmplwi CR6, R6, 99 */
		/* 821BFAC4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000063);
		/* 821BFAC4h case    2:*/		return 0x821BFAC8;
		  /* 821BFAC8h */ case    3:  		/* bc 12, CR6_EQ, 16 */
		/* 821BFAC8h case    3:*/		if ( regs.CR[6].eq ) { return 0x821BFAD8;  }
		/* 821BFAC8h case    3:*/		return 0x821BFACC;
		  /* 821BFACCh */ case    4:  		/* cmplwi CR6, R6, 100 */
		/* 821BFACCh case    4:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000064);
		/* 821BFACCh case    4:*/		return 0x821BFAD0;
		  /* 821BFAD0h */ case    5:  		/* li R11, 0 */
		/* 821BFAD0h case    5:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BFAD0h case    5:*/		return 0x821BFAD4;
		  /* 821BFAD4h */ case    6:  		/* bc 4, CR6_EQ, 8 */
		/* 821BFAD4h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821BFADC;  }
		/* 821BFAD4h case    6:*/		return 0x821BFAD8;
	}
	return 0x821BFAD8;
} // Block from 821BFABCh-821BFAD8h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BFAD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BFAD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BFAD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BFAD8);
		  /* 821BFAD8h */ case    0:  		/* mr R11, R23 */
		/* 821BFAD8h case    0:*/		regs.R11 = regs.R23;
		/* 821BFAD8h case    0:*/		return 0x821BFADC;
	}
	return 0x821BFADC;
} // Block from 821BFAD8h-821BFADCh (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BFADCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BFADC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BFADC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BFADC);
		  /* 821BFADCh */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821BFADCh case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821BFADCh case    0:*/		return 0x821BFAE0;
		  /* 821BFAE0h */ case    1:  		/* bc 12, CR0_EQ, 132 */
		/* 821BFAE0h case    1:*/		if ( regs.CR[0].eq ) { return 0x821BFB64;  }
		/* 821BFAE0h case    1:*/		return 0x821BFAE4;
		  /* 821BFAE4h */ case    2:  		/* lwz R11, <#[R25 + 8]> */
		/* 821BFAE4h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 821BFAE4h case    2:*/		return 0x821BFAE8;
		  /* 821BFAE8h */ case    3:  		/* mr R3, R26 */
		/* 821BFAE8h case    3:*/		regs.R3 = regs.R26;
		/* 821BFAE8h case    3:*/		return 0x821BFAEC;
		  /* 821BFAECh */ case    4:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 821BFAECh case    4:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 821BFAECh case    4:*/		return 0x821BFAF0;
		  /* 821BFAF0h */ case    5:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 821BFAF0h case    5:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 821BFAF0h case    5:*/		return 0x821BFAF4;
		  /* 821BFAF4h */ case    6:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 821BFAF4h case    6:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 821BFAF4h case    6:*/		return 0x821BFAF8;
		  /* 821BFAF8h */ case    7:  		/* bl -374472 */
		/* 821BFAF8h case    7:*/		regs.LR = 0x821BFAFC; return 0x82164430;
		/* 821BFAF8h case    7:*/		return 0x821BFAFC;
		  /* 821BFAFCh */ case    8:  		/* addi R11, R25, -24 */
		/* 821BFAFCh case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R25,0xFFFFFFE8);
		/* 821BFAFCh case    8:*/		return 0x821BFB00;
		  /* 821BFB00h */ case    9:  		/* add R11, R3, R11 */
		/* 821BFB00h case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 821BFB00h case    9:*/		return 0x821BFB04;
		  /* 821BFB04h */ case   10:  		/* lwz R31, <#[R11 + 20]> */
		/* 821BFB04h case   10:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000014) );
		/* 821BFB04h case   10:*/		return 0x821BFB08;
		  /* 821BFB08h */ case   11:  		/* cmplwi CR6, R31, 0 */
		/* 821BFB08h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821BFB08h case   11:*/		return 0x821BFB0C;
		  /* 821BFB0Ch */ case   12:  		/* bc 12, CR6_EQ, 376 */
		/* 821BFB0Ch case   12:*/		if ( regs.CR[6].eq ) { return 0x821BFC84;  }
		/* 821BFB0Ch case   12:*/		return 0x821BFB10;
		  /* 821BFB10h */ case   13:  		/* lwz R11, <#[R27 + 8]> */
		/* 821BFB10h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 821BFB10h case   13:*/		return 0x821BFB14;
		  /* 821BFB14h */ case   14:  		/* mr R3, R26 */
		/* 821BFB14h case   14:*/		regs.R3 = regs.R26;
		/* 821BFB14h case   14:*/		return 0x821BFB18;
		  /* 821BFB18h */ case   15:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 821BFB18h case   15:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 821BFB18h case   15:*/		return 0x821BFB1C;
		  /* 821BFB1Ch */ case   16:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 821BFB1Ch case   16:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 821BFB1Ch case   16:*/		return 0x821BFB20;
		  /* 821BFB20h */ case   17:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 821BFB20h case   17:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 821BFB20h case   17:*/		return 0x821BFB24;
		  /* 821BFB24h */ case   18:  		/* bl -374516 */
		/* 821BFB24h case   18:*/		regs.LR = 0x821BFB28; return 0x82164430;
		/* 821BFB24h case   18:*/		return 0x821BFB28;
		  /* 821BFB28h */ case   19:  		/* addi R10, R27, -4 */
		/* 821BFB28h case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R27,0xFFFFFFFC);
		/* 821BFB28h case   19:*/		return 0x821BFB2C;
		  /* 821BFB2Ch */ case   20:  		/* li R11, 0 */
		/* 821BFB2Ch case   20:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BFB2Ch case   20:*/		return 0x821BFB30;
		  /* 821BFB30h */ case   21:  		/* lwzx R10, <#[R3 + R10]> */
		/* 821BFB30h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + regs.R10 + 0x00000000) );
		/* 821BFB30h case   21:*/		return 0x821BFB34;
		  /* 821BFB34h */ case   22:  		/* lwz R9, <#[R10 + 4]> */
		/* 821BFB34h case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 821BFB34h case   22:*/		return 0x821BFB38;
		  /* 821BFB38h */ case   23:  		/* cmplwi CR6, R9, 0 */
		/* 821BFB38h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 821BFB38h case   23:*/		return 0x821BFB3C;
		  /* 821BFB3Ch */ case   24:  		/* bc 12, CR6_EQ, 328 */
		/* 821BFB3Ch case   24:*/		if ( regs.CR[6].eq ) { return 0x821BFC84;  }
		/* 821BFB3Ch case   24:*/		return 0x821BFB40;
		  /* 821BFB40h */ case   25:  		/* addi R10, R10, 8 */
		/* 821BFB40h case   25:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x8);
		/* 821BFB40h case   25:*/		return 0x821BFB44;
		  /* 821BFB44h */ case   26:  		/* lwz R8, <#[R10]> */
		/* 821BFB44h case   26:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 821BFB44h case   26:*/		return 0x821BFB48;
		  /* 821BFB48h */ case   27:  		/* cmplw CR6, R8, R29 */
		/* 821BFB48h case   27:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R29);
		/* 821BFB48h case   27:*/		return 0x821BFB4C;
		  /* 821BFB4Ch */ case   28:  		/* bc 12, CR6_EQ, 160 */
		/* 821BFB4Ch case   28:*/		if ( regs.CR[6].eq ) { return 0x821BFBEC;  }
		/* 821BFB4Ch case   28:*/		return 0x821BFB50;
		  /* 821BFB50h */ case   29:  		/* addi R11, R11, 1 */
		/* 821BFB50h case   29:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821BFB50h case   29:*/		return 0x821BFB54;
		  /* 821BFB54h */ case   30:  		/* addi R10, R10, 4 */
		/* 821BFB54h case   30:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821BFB54h case   30:*/		return 0x821BFB58;
	}
	return 0x821BFB58;
} // Block from 821BFADCh-821BFB58h (31 instructions)

//////////////////////////////////////////////////////
// Block at 821BFB58h
// Function '?VisitBlocksWithMarkedInstructions@Compiler@D3DXShader@@AAAXI@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BFB58( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BFB58) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BFB58);
		  /* 821BFB58h */ case    0:  		/* cmplw CR6, R11, R9 */
		/* 821BFB58h case    0:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 821BFB58h case    0:*/		return 0x821BFB5C;
		  /* 821BFB5Ch */ case    1:  		/* bc 12, CR6_LT, -24 */
		/* 821BFB5Ch case    1:*/		if ( regs.CR[6].lt ) { return 0x821BFB44;  }
		/* 821BFB5Ch case    1:*/		return 0x821BFB60;
		  /* 821BFB60h */ case    2:  		/* b 292 */
		/* 821BFB60h case    2:*/		return 0x821BFC84;
		/* 821BFB60h case    2:*/		return 0x821BFB64;
	}
	return 0x821BFB64;
} // Block from 821BFB58h-821BFB64h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BFB64h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BFB64( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BFB64) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BFB64);
		  /* 821BFB64h */ case    0:  		/* cmplwi CR6, R6, 96 */
		/* 821BFB64h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000060);
		/* 821BFB64h case    0:*/		return 0x821BFB68;
		  /* 821BFB68h */ case    1:  		/* bc 4, CR6_EQ, 148 */
		/* 821BFB68h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BFBFC;  }
		/* 821BFB68h case    1:*/		return 0x821BFB6C;
		  /* 821BFB6Ch */ case    2:  		/* lwz R11, <#[R25 + 8]> */
		/* 821BFB6Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 821BFB6Ch case    2:*/		return 0x821BFB70;
		  /* 821BFB70h */ case    3:  		/* mr R3, R26 */
		/* 821BFB70h case    3:*/		regs.R3 = regs.R26;
		/* 821BFB70h case    3:*/		return 0x821BFB74;
		  /* 821BFB74h */ case    4:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 821BFB74h case    4:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 821BFB74h case    4:*/		return 0x821BFB78;
		  /* 821BFB78h */ case    5:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 821BFB78h case    5:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 821BFB78h case    5:*/		return 0x821BFB7C;
		  /* 821BFB7Ch */ case    6:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 821BFB7Ch case    6:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 821BFB7Ch case    6:*/		return 0x821BFB80;
		  /* 821BFB80h */ case    7:  		/* bl -374608 */
		/* 821BFB80h case    7:*/		regs.LR = 0x821BFB84; return 0x82164430;
		/* 821BFB80h case    7:*/		return 0x821BFB84;
		  /* 821BFB84h */ case    8:  		/* addi R11, R25, -20 */
		/* 821BFB84h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R25,0xFFFFFFEC);
		/* 821BFB84h case    8:*/		return 0x821BFB88;
		  /* 821BFB88h */ case    9:  		/* add R11, R3, R11 */
		/* 821BFB88h case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 821BFB88h case    9:*/		return 0x821BFB8C;
		  /* 821BFB8Ch */ case   10:  		/* lwz R31, <#[R11 + 16]> */
		/* 821BFB8Ch case   10:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000010) );
		/* 821BFB8Ch case   10:*/		return 0x821BFB90;
		  /* 821BFB90h */ case   11:  		/* cmplwi CR6, R31, 0 */
		/* 821BFB90h case   11:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821BFB90h case   11:*/		return 0x821BFB94;
		  /* 821BFB94h */ case   12:  		/* bc 12, CR6_EQ, 240 */
		/* 821BFB94h case   12:*/		if ( regs.CR[6].eq ) { return 0x821BFC84;  }
		/* 821BFB94h case   12:*/		return 0x821BFB98;
		  /* 821BFB98h */ case   13:  		/* lwz R11, <#[R27 + 8]> */
		/* 821BFB98h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 821BFB98h case   13:*/		return 0x821BFB9C;
		  /* 821BFB9Ch */ case   14:  		/* mr R3, R26 */
		/* 821BFB9Ch case   14:*/		regs.R3 = regs.R26;
		/* 821BFB9Ch case   14:*/		return 0x821BFBA0;
		  /* 821BFBA0h */ case   15:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 821BFBA0h case   15:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 821BFBA0h case   15:*/		return 0x821BFBA4;
		  /* 821BFBA4h */ case   16:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 821BFBA4h case   16:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 821BFBA4h case   16:*/		return 0x821BFBA8;
		  /* 821BFBA8h */ case   17:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 821BFBA8h case   17:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 821BFBA8h case   17:*/		return 0x821BFBAC;
		  /* 821BFBACh */ case   18:  		/* bl -374652 */
		/* 821BFBACh case   18:*/		regs.LR = 0x821BFBB0; return 0x82164430;
		/* 821BFBACh case   18:*/		return 0x821BFBB0;
		  /* 821BFBB0h */ case   19:  		/* addi R10, R27, -4 */
		/* 821BFBB0h case   19:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R27,0xFFFFFFFC);
		/* 821BFBB0h case   19:*/		return 0x821BFBB4;
		  /* 821BFBB4h */ case   20:  		/* li R11, 0 */
		/* 821BFBB4h case   20:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BFBB4h case   20:*/		return 0x821BFBB8;
		  /* 821BFBB8h */ case   21:  		/* lwzx R10, <#[R3 + R10]> */
		/* 821BFBB8h case   21:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + regs.R10 + 0x00000000) );
		/* 821BFBB8h case   21:*/		return 0x821BFBBC;
		  /* 821BFBBCh */ case   22:  		/* lwz R9, <#[R10 + 4]> */
		/* 821BFBBCh case   22:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000004) );
		/* 821BFBBCh case   22:*/		return 0x821BFBC0;
		  /* 821BFBC0h */ case   23:  		/* cmplwi CR6, R9, 0 */
		/* 821BFBC0h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 821BFBC0h case   23:*/		return 0x821BFBC4;
		  /* 821BFBC4h */ case   24:  		/* bc 12, CR6_EQ, 192 */
		/* 821BFBC4h case   24:*/		if ( regs.CR[6].eq ) { return 0x821BFC84;  }
		/* 821BFBC4h case   24:*/		return 0x821BFBC8;
		  /* 821BFBC8h */ case   25:  		/* addi R10, R10, 8 */
		/* 821BFBC8h case   25:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x8);
		/* 821BFBC8h case   25:*/		return 0x821BFBCC;
		  /* 821BFBCCh */ case   26:  		/* lwz R8, <#[R10]> */
		/* 821BFBCCh case   26:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 821BFBCCh case   26:*/		return 0x821BFBD0;
		  /* 821BFBD0h */ case   27:  		/* cmplw CR6, R8, R29 */
		/* 821BFBD0h case   27:*/		cpu::op::cmplw<6>(regs,regs.R8,regs.R29);
		/* 821BFBD0h case   27:*/		return 0x821BFBD4;
		  /* 821BFBD4h */ case   28:  		/* bc 12, CR6_EQ, 24 */
		/* 821BFBD4h case   28:*/		if ( regs.CR[6].eq ) { return 0x821BFBEC;  }
		/* 821BFBD4h case   28:*/		return 0x821BFBD8;
		  /* 821BFBD8h */ case   29:  		/* addi R11, R11, 1 */
		/* 821BFBD8h case   29:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821BFBD8h case   29:*/		return 0x821BFBDC;
		  /* 821BFBDCh */ case   30:  		/* addi R10, R10, 4 */
		/* 821BFBDCh case   30:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x4);
		/* 821BFBDCh case   30:*/		return 0x821BFBE0;
		  /* 821BFBE0h */ case   31:  		/* cmplw CR6, R11, R9 */
		/* 821BFBE0h case   31:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R9);
		/* 821BFBE0h case   31:*/		return 0x821BFBE4;
		  /* 821BFBE4h */ case   32:  		/* bc 12, CR6_LT, -24 */
		/* 821BFBE4h case   32:*/		if ( regs.CR[6].lt ) { return 0x821BFBCC;  }
		/* 821BFBE4h case   32:*/		return 0x821BFBE8;
		  /* 821BFBE8h */ case   33:  		/* b 156 */
		/* 821BFBE8h case   33:*/		return 0x821BFC84;
		/* 821BFBE8h case   33:*/		return 0x821BFBEC;
	}
	return 0x821BFBEC;
} // Block from 821BFB64h-821BFBECh (34 instructions)

//////////////////////////////////////////////////////
// Block at 821BFBECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BFBEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BFBEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BFBEC);
		  /* 821BFBECh */ case    0:  		/* addi R11, R11, 2 */
		/* 821BFBECh case    0:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x2);
		/* 821BFBECh case    0:*/		return 0x821BFBF0;
		  /* 821BFBF0h */ case    1:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821BFBF0h case    1:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821BFBF0h case    1:*/		return 0x821BFBF4;
		  /* 821BFBF4h */ case    2:  		/* stwx R30, <#[R11 + R31]> */
		/* 821BFBF4h case    2:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + regs.R31 + 0x00000000) );
		/* 821BFBF4h case    2:*/		return 0x821BFBF8;
		  /* 821BFBF8h */ case    3:  		/* b 140 */
		/* 821BFBF8h case    3:*/		return 0x821BFC84;
		/* 821BFBF8h case    3:*/		return 0x821BFBFC;
	}
	return 0x821BFBFC;
} // Block from 821BFBECh-821BFBFCh (4 instructions)

//////////////////////////////////////////////////////
// Block at 821BFBFCh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BFBFC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BFBFC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BFBFC);
		  /* 821BFBFCh */ case    0:  		/* cmplwi CR6, R6, 86 */
		/* 821BFBFCh case    0:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000056);
		/* 821BFBFCh case    0:*/		return 0x821BFC00;
		  /* 821BFC00h */ case    1:  		/* bc 12, CR6_EQ, 48 */
		/* 821BFC00h case    1:*/		if ( regs.CR[6].eq ) { return 0x821BFC30;  }
		/* 821BFC00h case    1:*/		return 0x821BFC04;
		  /* 821BFC04h */ case    2:  		/* cmplwi CR6, R6, 87 */
		/* 821BFC04h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000057);
		/* 821BFC04h case    2:*/		return 0x821BFC08;
		  /* 821BFC08h */ case    3:  		/* bc 12, CR6_EQ, 40 */
		/* 821BFC08h case    3:*/		if ( regs.CR[6].eq ) { return 0x821BFC30;  }
		/* 821BFC08h case    3:*/		return 0x821BFC0C;
		  /* 821BFC0Ch */ case    4:  		/* cmplwi CR6, R6, 89 */
		/* 821BFC0Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000059);
		/* 821BFC0Ch case    4:*/		return 0x821BFC10;
		  /* 821BFC10h */ case    5:  		/* bc 12, CR6_EQ, 32 */
		/* 821BFC10h case    5:*/		if ( regs.CR[6].eq ) { return 0x821BFC30;  }
		/* 821BFC10h case    5:*/		return 0x821BFC14;
		  /* 821BFC14h */ case    6:  		/* cmplwi CR6, R6, 90 */
		/* 821BFC14h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x0000005A);
		/* 821BFC14h case    6:*/		return 0x821BFC18;
		  /* 821BFC18h */ case    7:  		/* bc 12, CR6_EQ, 24 */
		/* 821BFC18h case    7:*/		if ( regs.CR[6].eq ) { return 0x821BFC30;  }
		/* 821BFC18h case    7:*/		return 0x821BFC1C;
		  /* 821BFC1Ch */ case    8:  		/* cmplwi CR6, R6, 84 */
		/* 821BFC1Ch case    8:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000054);
		/* 821BFC1Ch case    8:*/		return 0x821BFC20;
		  /* 821BFC20h */ case    9:  		/* bc 12, CR6_EQ, 16 */
		/* 821BFC20h case    9:*/		if ( regs.CR[6].eq ) { return 0x821BFC30;  }
		/* 821BFC20h case    9:*/		return 0x821BFC24;
		  /* 821BFC24h */ case   10:  		/* cmplwi CR6, R6, 85 */
		/* 821BFC24h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R6,0x00000055);
		/* 821BFC24h case   10:*/		return 0x821BFC28;
		  /* 821BFC28h */ case   11:  		/* li R11, 0 */
		/* 821BFC28h case   11:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BFC28h case   11:*/		return 0x821BFC2C;
		  /* 821BFC2Ch */ case   12:  		/* bc 4, CR6_EQ, 8 */
		/* 821BFC2Ch case   12:*/		if ( !regs.CR[6].eq ) { return 0x821BFC34;  }
		/* 821BFC2Ch case   12:*/		return 0x821BFC30;
	}
	return 0x821BFC30;
} // Block from 821BFBFCh-821BFC30h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821BFC30h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BFC30( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BFC30) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BFC30);
		  /* 821BFC30h */ case    0:  		/* mr R11, R23 */
		/* 821BFC30h case    0:*/		regs.R11 = regs.R23;
		/* 821BFC30h case    0:*/		return 0x821BFC34;
	}
	return 0x821BFC34;
} // Block from 821BFC30h-821BFC34h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BFC34h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BFC34( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BFC34) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BFC34);
		  /* 821BFC34h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821BFC34h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821BFC34h case    0:*/		return 0x821BFC38;
		  /* 821BFC38h */ case    1:  		/* bc 12, CR0_EQ, 76 */
		/* 821BFC38h case    1:*/		if ( regs.CR[0].eq ) { return 0x821BFC84;  }
		/* 821BFC38h case    1:*/		return 0x821BFC3C;
		  /* 821BFC3Ch */ case    2:  		/* lwz R11, <#[R25 + 8]> */
		/* 821BFC3Ch case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 821BFC3Ch case    2:*/		return 0x821BFC40;
		  /* 821BFC40h */ case    3:  		/* mr R3, R26 */
		/* 821BFC40h case    3:*/		regs.R3 = regs.R26;
		/* 821BFC40h case    3:*/		return 0x821BFC44;
		  /* 821BFC44h */ case    4:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 821BFC44h case    4:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 821BFC44h case    4:*/		return 0x821BFC48;
		  /* 821BFC48h */ case    5:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 821BFC48h case    5:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 821BFC48h case    5:*/		return 0x821BFC4C;
		  /* 821BFC4Ch */ case    6:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 821BFC4Ch case    6:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 821BFC4Ch case    6:*/		return 0x821BFC50;
		  /* 821BFC50h */ case    7:  		/* bl -374816 */
		/* 821BFC50h case    7:*/		regs.LR = 0x821BFC54; return 0x82164430;
		/* 821BFC50h case    7:*/		return 0x821BFC54;
		  /* 821BFC54h */ case    8:  		/* addi R11, R25, -16 */
		/* 821BFC54h case    8:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R25,0xFFFFFFF0);
		/* 821BFC54h case    8:*/		return 0x821BFC58;
		  /* 821BFC58h */ case    9:  		/* add R11, R3, R11 */
		/* 821BFC58h case    9:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R11);
		/* 821BFC58h case    9:*/		return 0x821BFC5C;
		  /* 821BFC5Ch */ case   10:  		/* lwz R10, <#[R11 + 8]> */
		/* 821BFC5Ch case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821BFC5Ch case   10:*/		return 0x821BFC60;
		  /* 821BFC60h */ case   11:  		/* rlwinm. R9, R10, 0, 30, 31 */
		/* 821BFC60h case   11:*/		cpu::op::rlwinm<1,0,30,31>(regs,&regs.R9,regs.R10);
		/* 821BFC60h case   11:*/		return 0x821BFC64;
		  /* 821BFC64h */ case   12:  		/* bc 12, CR0_EQ, 32 */
		/* 821BFC64h case   12:*/		if ( regs.CR[0].eq ) { return 0x821BFC84;  }
		/* 821BFC64h case   12:*/		return 0x821BFC68;
		  /* 821BFC68h */ case   13:  		/* lwz R9, <#[R11 + 4]> */
		/* 821BFC68h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000004) );
		/* 821BFC68h case   13:*/		return 0x821BFC6C;
		  /* 821BFC6Ch */ case   14:  		/* rlwinm R9, R9, 0, 0, 29 */
		/* 821BFC6Ch case   14:*/		cpu::op::rlwinm<0,0,0,29>(regs,&regs.R9,regs.R9);
		/* 821BFC6Ch case   14:*/		return 0x821BFC70;
		  /* 821BFC70h */ case   15:  		/* cmplw CR6, R29, R9 */
		/* 821BFC70h case   15:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R9);
		/* 821BFC70h case   15:*/		return 0x821BFC74;
		  /* 821BFC74h */ case   16:  		/* bc 4, CR6_EQ, 16 */
		/* 821BFC74h case   16:*/		if ( !regs.CR[6].eq ) { return 0x821BFC84;  }
		/* 821BFC74h case   16:*/		return 0x821BFC78;
		  /* 821BFC78h */ case   17:  		/* rlwimi R10, R23, 0, 30, 31 */
		/* 821BFC78h case   17:*/		cpu::op::rlwimi<0,0,30,31>(regs,&regs.R10,regs.R23);
		/* 821BFC78h case   17:*/		return 0x821BFC7C;
		  /* 821BFC7Ch */ case   18:  		/* stw R30, <#[R11 + 4]> */
		/* 821BFC7Ch case   18:*/		cpu::mem::store32( regs, regs.R30, (uint32)(regs.R11 + 0x00000004) );
		/* 821BFC7Ch case   18:*/		return 0x821BFC80;
		  /* 821BFC80h */ case   19:  		/* stw R10, <#[R11 + 8]> */
		/* 821BFC80h case   19:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821BFC80h case   19:*/		return 0x821BFC84;
	}
	return 0x821BFC84;
} // Block from 821BFC34h-821BFC84h (20 instructions)

//////////////////////////////////////////////////////
// Block at 821BFC84h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BFC84( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BFC84) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BFC84);
		  /* 821BFC84h */ case    0:  		/* lwz R29, <#[R29 + 4]> */
		/* 821BFC84h case    0:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R29 + 0x00000004) );
		/* 821BFC84h case    0:*/		return 0x821BFC88;
		  /* 821BFC88h */ case    1:  		/* b -760 */
		/* 821BFC88h case    1:*/		return 0x821BF990;
		/* 821BFC88h case    1:*/		return 0x821BFC8C;
	}
	return 0x821BFC8C;
} // Block from 821BFC84h-821BFC8Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BFC8Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BFC8C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BFC8C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BFC8C);
		  /* 821BFC8Ch */ case    0:  		/* addi R28, R27, 4 */
		/* 821BFC8Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R27,0x4);
		/* 821BFC8Ch case    0:*/		return 0x821BFC90;
		  /* 821BFC90h */ case    1:  		/* mr R30, R28 */
		/* 821BFC90h case    1:*/		regs.R30 = regs.R28;
		/* 821BFC90h case    1:*/		return 0x821BFC94;
		  /* 821BFC94h */ case    2:  		/* lwz R31, <#[R30]> */
		/* 821BFC94h case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000000) );
		/* 821BFC94h case    2:*/		return 0x821BFC98;
		  /* 821BFC98h */ case    3:  		/* cmplwi CR6, R31, 0 */
		/* 821BFC98h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821BFC98h case    3:*/		return 0x821BFC9C;
		  /* 821BFC9Ch */ case    4:  		/* bc 12, CR6_EQ, 80 */
		/* 821BFC9Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x821BFCEC;  }
		/* 821BFC9Ch case    4:*/		return 0x821BFCA0;
		  /* 821BFCA0h */ case    5:  		/* lwz R11, <#[R31 + 16]> */
		/* 821BFCA0h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 821BFCA0h case    5:*/		return 0x821BFCA4;
		  /* 821BFCA4h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 821BFCA4h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BFCA4h case    6:*/		return 0x821BFCA8;
		  /* 821BFCA8h */ case    7:  		/* bc 12, CR6_EQ, 48 */
		/* 821BFCA8h case    7:*/		if ( regs.CR[6].eq ) { return 0x821BFCD8;  }
		/* 821BFCA8h case    7:*/		return 0x821BFCAC;
		  /* 821BFCACh */ case    8:  		/* lwz R10, <#[R11 + 28]> */
		/* 821BFCACh case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000001C) );
		/* 821BFCACh case    8:*/		return 0x821BFCB0;
		  /* 821BFCB0h */ case    9:  		/* lwz R10, <#[R10 + 44]> */
		/* 821BFCB0h case    9:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000002C) );
		/* 821BFCB0h case    9:*/		return 0x821BFCB4;
		  /* 821BFCB4h */ case   10:  		/* cmplw CR6, R10, R24 */
		/* 821BFCB4h case   10:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R24);
		/* 821BFCB4h case   10:*/		return 0x821BFCB8;
		  /* 821BFCB8h */ case   11:  		/* bc 12, CR6_EQ, 32 */
		/* 821BFCB8h case   11:*/		if ( regs.CR[6].eq ) { return 0x821BFCD8;  }
		/* 821BFCB8h case   11:*/		return 0x821BFCBC;
		  /* 821BFCBCh */ case   12:  		/* lwz R11, <#[R11 + 8]> */
		/* 821BFCBCh case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821BFCBCh case   12:*/		return 0x821BFCC0;
		  /* 821BFCC0h */ case   13:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821BFCC0h case   13:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821BFCC0h case   13:*/		return 0x821BFCC4;
		  /* 821BFCC4h */ case   14:  		/* cmplwi CR6, R11, 14336 */
		/* 821BFCC4h case   14:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003800);
		/* 821BFCC4h case   14:*/		return 0x821BFCC8;
		  /* 821BFCC8h */ case   15:  		/* bc 12, CR6_EQ, 16 */
		/* 821BFCC8h case   15:*/		if ( regs.CR[6].eq ) { return 0x821BFCD8;  }
		/* 821BFCC8h case   15:*/		return 0x821BFCCC;
		  /* 821BFCCCh */ case   16:  		/* mr R4, R31 */
		/* 821BFCCCh case   16:*/		regs.R4 = regs.R31;
		/* 821BFCCCh case   16:*/		return 0x821BFCD0;
		  /* 821BFCD0h */ case   17:  		/* mr R3, R26 */
		/* 821BFCD0h case   17:*/		regs.R3 = regs.R26;
		/* 821BFCD0h case   17:*/		return 0x821BFCD4;
		  /* 821BFCD4h */ case   18:  		/* bl -33652 */
		/* 821BFCD4h case   18:*/		regs.LR = 0x821BFCD8; return 0x821B7960;
		/* 821BFCD4h case   18:*/		return 0x821BFCD8;
	}
	return 0x821BFCD8;
} // Block from 821BFC8Ch-821BFCD8h (19 instructions)

//////////////////////////////////////////////////////
// Block at 821BFCD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BFCD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BFCD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BFCD8);
		  /* 821BFCD8h */ case    0:  		/* lwz R11, <#[R30]> */
		/* 821BFCD8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821BFCD8h case    0:*/		return 0x821BFCDC;
		  /* 821BFCDCh */ case    1:  		/* cmplw CR6, R11, R31 */
		/* 821BFCDCh case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 821BFCDCh case    1:*/		return 0x821BFCE0;
		  /* 821BFCE0h */ case    2:  		/* bc 4, CR6_EQ, -76 */
		/* 821BFCE0h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821BFC94;  }
		/* 821BFCE0h case    2:*/		return 0x821BFCE4;
		  /* 821BFCE4h */ case    3:  		/* addi R30, R31, 8 */
		/* 821BFCE4h case    3:*/		cpu::op::addi<0>(regs,&regs.R30,regs.R31,0x8);
		/* 821BFCE4h case    3:*/		return 0x821BFCE8;
		  /* 821BFCE8h */ case    4:  		/* b -84 */
		/* 821BFCE8h case    4:*/		return 0x821BFC94;
		/* 821BFCE8h case    4:*/		return 0x821BFCEC;
	}
	return 0x821BFCEC;
} // Block from 821BFCD8h-821BFCECh (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BFCECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BFCEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BFCEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BFCEC);
		  /* 821BFCECh */ case    0:  		/* mr R29, R28 */
		/* 821BFCECh case    0:*/		regs.R29 = regs.R28;
		/* 821BFCECh case    0:*/		return 0x821BFCF0;
		  /* 821BFCF0h */ case    1:  		/* lwz R31, <#[R29]> */
		/* 821BFCF0h case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R29 + 0x00000000) );
		/* 821BFCF0h case    1:*/		return 0x821BFCF4;
		  /* 821BFCF4h */ case    2:  		/* cmplwi CR6, R31, 0 */
		/* 821BFCF4h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821BFCF4h case    2:*/		return 0x821BFCF8;
		  /* 821BFCF8h */ case    3:  		/* bc 12, CR6_EQ, 308 */
		/* 821BFCF8h case    3:*/		if ( regs.CR[6].eq ) { return 0x821BFE2C;  }
		/* 821BFCF8h case    3:*/		return 0x821BFCFC;
		  /* 821BFCFCh */ case    4:  		/* lwz R11, <#[R31 + 16]> */
		/* 821BFCFCh case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000010) );
		/* 821BFCFCh case    4:*/		return 0x821BFD00;
		  /* 821BFD00h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821BFD00h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BFD00h case    5:*/		return 0x821BFD04;
		  /* 821BFD04h */ case    6:  		/* bc 12, CR6_EQ, 276 */
		/* 821BFD04h case    6:*/		if ( regs.CR[6].eq ) { return 0x821BFE18;  }
		/* 821BFD04h case    6:*/		return 0x821BFD08;
		  /* 821BFD08h */ case    7:  		/* lwz R9, <#[R11 + 28]> */
		/* 821BFD08h case    7:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000001C) );
		/* 821BFD08h case    7:*/		return 0x821BFD0C;
		  /* 821BFD0Ch */ case    8:  		/* lwz R10, <#[R9 + 44]> */
		/* 821BFD0Ch case    8:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R9 + 0x0000002C) );
		/* 821BFD0Ch case    8:*/		return 0x821BFD10;
		  /* 821BFD10h */ case    9:  		/* cmplw CR6, R10, R24 */
		/* 821BFD10h case    9:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R24);
		/* 821BFD10h case    9:*/		return 0x821BFD14;
		  /* 821BFD14h */ case   10:  		/* bc 12, CR6_EQ, 260 */
		/* 821BFD14h case   10:*/		if ( regs.CR[6].eq ) { return 0x821BFE18;  }
		/* 821BFD14h case   10:*/		return 0x821BFD18;
		  /* 821BFD18h */ case   11:  		/* lwz R11, <#[R11 + 8]> */
		/* 821BFD18h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821BFD18h case   11:*/		return 0x821BFD1C;
		  /* 821BFD1Ch */ case   12:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821BFD1Ch case   12:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821BFD1Ch case   12:*/		return 0x821BFD20;
		  /* 821BFD20h */ case   13:  		/* cmplwi CR6, R11, 14336 */
		/* 821BFD20h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003800);
		/* 821BFD20h case   13:*/		return 0x821BFD24;
		  /* 821BFD24h */ case   14:  		/* bc 4, CR6_EQ, 244 */
		/* 821BFD24h case   14:*/		if ( !regs.CR[6].eq ) { return 0x821BFE18;  }
		/* 821BFD24h case   14:*/		return 0x821BFD28;
		  /* 821BFD28h */ case   15:  		/* lwz R11, <#[R9 + 52]> */
		/* 821BFD28h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000034) );
		/* 821BFD28h case   15:*/		return 0x821BFD2C;
		  /* 821BFD2Ch */ case   16:  		/* mr R4, R9 */
		/* 821BFD2Ch case   16:*/		regs.R4 = regs.R9;
		/* 821BFD2Ch case   16:*/		return 0x821BFD30;
		  /* 821BFD30h */ case   17:  		/* lwz R8, <#[R27 + 28]> */
		/* 821BFD30h case   17:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R27 + 0x0000001C) );
		/* 821BFD30h case   17:*/		return 0x821BFD34;
		  /* 821BFD34h */ case   18:  		/* b 68 */
		/* 821BFD34h case   18:*/		return 0x821BFD78;
		/* 821BFD34h case   18:*/		return 0x821BFD38;
		  /* 821BFD38h */ case   19:  		/* lwz R10, <#[R11 + 44]> */
		/* 821BFD38h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x0000002C) );
		/* 821BFD38h case   19:*/		return 0x821BFD3C;
		  /* 821BFD3Ch */ case   20:  		/* cmplw CR6, R10, R24 */
		/* 821BFD3Ch case   20:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R24);
		/* 821BFD3Ch case   20:*/		return 0x821BFD40;
		  /* 821BFD40h */ case   21:  		/* bc 12, CR6_EQ, 64 */
		/* 821BFD40h case   21:*/		if ( regs.CR[6].eq ) { return 0x821BFD80;  }
		/* 821BFD40h case   21:*/		return 0x821BFD44;
		  /* 821BFD44h */ case   22:  		/* lwz R10, <#[R8 + 48]> */
		/* 821BFD44h case   22:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R8 + 0x00000030) );
		/* 821BFD44h case   22:*/		return 0x821BFD48;
		  /* 821BFD48h */ case   23:  		/* lwz R7, <#[R11 + 40]> */
		/* 821BFD48h case   23:*/		cpu::mem::load32z( regs, &regs.R7, (uint32)(regs.R11 + 0x00000028) );
		/* 821BFD48h case   23:*/		return 0x821BFD4C;
		  /* 821BFD4Ch */ case   24:  		/* rlwinm R6, R10, 0, 13, 31 */
		/* 821BFD4Ch case   24:*/		cpu::op::rlwinm<0,0,13,31>(regs,&regs.R6,regs.R10);
		/* 821BFD4Ch case   24:*/		return 0x821BFD50;
		  /* 821BFD50h */ case   25:  		/* rlwinm R10, R6, 27, 5, 31 */
		/* 821BFD50h case   25:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R10,regs.R6);
		/* 821BFD50h case   25:*/		return 0x821BFD54;
		  /* 821BFD54h */ case   26:  		/* rlwinm R6, R6, 0, 27, 31 */
		/* 821BFD54h case   26:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R6,regs.R6);
		/* 821BFD54h case   26:*/		return 0x821BFD58;
		  /* 821BFD58h */ case   27:  		/* addi R10, R10, 1 */
		/* 821BFD58h case   27:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821BFD58h case   27:*/		return 0x821BFD5C;
		  /* 821BFD5Ch */ case   28:  		/* slw R6, R23, R6 */
		/* 821BFD5Ch case   28:*/		cpu::op::slw<0>(regs,&regs.R6,regs.R23,regs.R6);
		/* 821BFD5Ch case   28:*/		return 0x821BFD60;
		  /* 821BFD60h */ case   29:  		/* rlwinm R10, R10, 2, 0, 29 */
		/* 821BFD60h case   29:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R10,regs.R10);
		/* 821BFD60h case   29:*/		return 0x821BFD64;
		  /* 821BFD64h */ case   30:  		/* lwzx R10, <#[R10 + R7]> */
		/* 821BFD64h case   30:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + regs.R7 + 0x00000000) );
		/* 821BFD64h case   30:*/		return 0x821BFD68;
		  /* 821BFD68h */ case   31:  		/* and. R10, R10, R6 */
		/* 821BFD68h case   31:*/		cpu::op::and<1>(regs,&regs.R10,regs.R10,regs.R6);
		/* 821BFD68h case   31:*/		return 0x821BFD6C;
		  /* 821BFD6Ch */ case   32:  		/* bc 12, CR0_EQ, 20 */
		/* 821BFD6Ch case   32:*/		if ( regs.CR[0].eq ) { return 0x821BFD80;  }
		/* 821BFD6Ch case   32:*/		return 0x821BFD70;
		  /* 821BFD70h */ case   33:  		/* mr R4, R11 */
		/* 821BFD70h case   33:*/		regs.R4 = regs.R11;
		/* 821BFD70h case   33:*/		return 0x821BFD74;
		  /* 821BFD74h */ case   34:  		/* lwz R11, <#[R11 + 52]> */
		/* 821BFD74h case   34:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000034) );
		/* 821BFD74h case   34:*/		return 0x821BFD78;
	}
	return 0x821BFD78;
} // Block from 821BFCECh-821BFD78h (35 instructions)

//////////////////////////////////////////////////////
// Block at 821BFD78h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BFD78( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BFD78) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BFD78);
		  /* 821BFD78h */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 821BFD78h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BFD78h case    0:*/		return 0x821BFD7C;
		  /* 821BFD7Ch */ case    1:  		/* bc 4, CR6_EQ, -68 */
		/* 821BFD7Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BFD38;  }
		/* 821BFD7Ch case    1:*/		return 0x821BFD80;
	}
	return 0x821BFD80;
} // Block from 821BFD78h-821BFD80h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BFD80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BFD80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BFD80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BFD80);
		  /* 821BFD80h */ case    0:  		/* lwz R11, <#[R26 + 4]> */
		/* 821BFD80h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000004) );
		/* 821BFD80h case    0:*/		return 0x821BFD84;
		  /* 821BFD84h */ case    1:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 821BFD84h case    1:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BFD84h case    1:*/		return 0x821BFD88;
		  /* 821BFD88h */ case    2:  		/* addic R10, R10, -1 */
		/* 821BFD88h case    2:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 821BFD88h case    2:*/		return 0x821BFD8C;
		  /* 821BFD8Ch */ case    3:  		/* subfe R10, R10, R10 */
		/* 821BFD8Ch case    3:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 821BFD8Ch case    3:*/		return 0x821BFD90;
		  /* 821BFD90h */ case    4:  		/* and R11, R10, R11 */
		/* 821BFD90h case    4:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821BFD90h case    4:*/		return 0x821BFD94;
		  /* 821BFD94h */ case    5:  		/* cmplw CR6, R4, R11 */
		/* 821BFD94h case    5:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R11);
		/* 821BFD94h case    5:*/		return 0x821BFD98;
		  /* 821BFD98h */ case    6:  		/* bc 12, CR6_EQ, 128 */
		/* 821BFD98h case    6:*/		if ( regs.CR[6].eq ) { return 0x821BFE18;  }
		/* 821BFD98h case    6:*/		return 0x821BFD9C;
		  /* 821BFD9Ch */ case    7:  		/* cmplw CR6, R4, R9 */
		/* 821BFD9Ch case    7:*/		cpu::op::cmplw<6>(regs,regs.R4,regs.R9);
		/* 821BFD9Ch case    7:*/		return 0x821BFDA0;
		  /* 821BFDA0h */ case    8:  		/* bc 12, CR6_EQ, 120 */
		/* 821BFDA0h case    8:*/		if ( regs.CR[6].eq ) { return 0x821BFE18;  }
		/* 821BFDA0h case    8:*/		return 0x821BFDA4;
		  /* 821BFDA4h */ case    9:  		/* lwz R11, <#[R31]> */
		/* 821BFDA4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821BFDA4h case    9:*/		return 0x821BFDA8;
		  /* 821BFDA8h */ case   10:  		/* mr R5, R27 */
		/* 821BFDA8h case   10:*/		regs.R5 = regs.R27;
		/* 821BFDA8h case   10:*/		return 0x821BFDAC;
		  /* 821BFDACh */ case   11:  		/* lwz R10, <#[R26 + 40]> */
		/* 821BFDACh case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000028) );
		/* 821BFDACh case   11:*/		return 0x821BFDB0;
		  /* 821BFDB0h */ case   12:  		/* mr R3, R26 */
		/* 821BFDB0h case   12:*/		regs.R3 = regs.R26;
		/* 821BFDB0h case   12:*/		return 0x821BFDB4;
		  /* 821BFDB4h */ case   13:  		/* andi. R30, R11, 25 */
		/* 821BFDB4h case   13:*/		cpu::op::andi<1>(regs,&regs.R30,regs.R11,0x19);
		/* 821BFDB4h case   13:*/		return 0x821BFDB8;
		  /* 821BFDB8h */ case   14:  		/* rlwinm R6, R11, 27, 30, 31 */
		/* 821BFDB8h case   14:*/		cpu::op::rlwinm<0,27,30,31>(regs,&regs.R6,regs.R11);
		/* 821BFDB8h case   14:*/		return 0x821BFDBC;
		  /* 821BFDBCh */ case   15:  		/* rlwinm R8, R10, 18, 31, 31 */
		/* 821BFDBCh case   15:*/		cpu::op::rlwinm<0,18,31,31>(regs,&regs.R8,regs.R10);
		/* 821BFDBCh case   15:*/		return 0x821BFDC0;
		  /* 821BFDC0h */ case   16:  		/* mr R7, R30 */
		/* 821BFDC0h case   16:*/		regs.R7 = regs.R30;
		/* 821BFDC0h case   16:*/		return 0x821BFDC4;
		  /* 821BFDC4h */ case   17:  		/* bl -38196 */
		/* 821BFDC4h case   17:*/		regs.LR = 0x821BFDC8; return 0x821B6890;
		/* 821BFDC4h case   17:*/		return 0x821BFDC8;
		  /* 821BFDC8h */ case   18:  		/* lwz R11, <#[R31 + 12]> */
		/* 821BFDC8h case   18:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000000C) );
		/* 821BFDC8h case   18:*/		return 0x821BFDCC;
		  /* 821BFDCCh */ case   19:  		/* addi R11, R11, 4 */
		/* 821BFDCCh case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x4);
		/* 821BFDCCh case   19:*/		return 0x821BFDD0;
		  /* 821BFDD0h */ case   20:  		/* lwz R10, <#[R11]> */
		/* 821BFDD0h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821BFDD0h case   20:*/		return 0x821BFDD4;
		  /* 821BFDD4h */ case   21:  		/* b 12 */
		/* 821BFDD4h case   21:*/		return 0x821BFDE0;
		/* 821BFDD4h case   21:*/		return 0x821BFDD8;
		  /* 821BFDD8h */ case   22:  		/* addi R11, R10, 8 */
		/* 821BFDD8h case   22:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R10,0x8);
		/* 821BFDD8h case   22:*/		return 0x821BFDDC;
		  /* 821BFDDCh */ case   23:  		/* lwz R10, <#[R10 + 8]> */
		/* 821BFDDCh case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 821BFDDCh case   23:*/		return 0x821BFDE0;
	}
	return 0x821BFDE0;
} // Block from 821BFD80h-821BFDE0h (24 instructions)

//////////////////////////////////////////////////////
// Block at 821BFDE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BFDE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BFDE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BFDE0);
		  /* 821BFDE0h */ case    0:  		/* cmplw CR6, R10, R31 */
		/* 821BFDE0h case    0:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R31);
		/* 821BFDE0h case    0:*/		return 0x821BFDE4;
		  /* 821BFDE4h */ case    1:  		/* bc 4, CR6_EQ, -12 */
		/* 821BFDE4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821BFDD8;  }
		/* 821BFDE4h case    1:*/		return 0x821BFDE8;
		  /* 821BFDE8h */ case    2:  		/* lwz R10, <#[R31 + 8]> */
		/* 821BFDE8h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 821BFDE8h case    2:*/		return 0x821BFDEC;
		  /* 821BFDECh */ case    3:  		/* li R9, 57 */
		/* 821BFDECh case    3:*/		cpu::op::li<0>(regs,&regs.R9,0x39);
		/* 821BFDECh case    3:*/		return 0x821BFDF0;
		  /* 821BFDF0h */ case    4:  		/* stw R10, <#[R11]> */
		/* 821BFDF0h case    4:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R11 + 0x00000000) );
		/* 821BFDF0h case    4:*/		return 0x821BFDF4;
		  /* 821BFDF4h */ case    5:  		/* lwz R11, <#[R3 + 4]> */
		/* 821BFDF4h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821BFDF4h case    5:*/		return 0x821BFDF8;
		  /* 821BFDF8h */ case    6:  		/* stw R11, <#[R31 + 8]> */
		/* 821BFDF8h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000008) );
		/* 821BFDF8h case    6:*/		return 0x821BFDFC;
		  /* 821BFDFCh */ case    7:  		/* stw R31, <#[R3 + 4]> */
		/* 821BFDFCh case    7:*/		cpu::mem::store32( regs, regs.R31, (uint32)(regs.R3 + 0x00000004) );
		/* 821BFDFCh case    7:*/		return 0x821BFE00;
		  /* 821BFE00h */ case    8:  		/* lwz R11, <#[R31]> */
		/* 821BFE00h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821BFE00h case    8:*/		return 0x821BFE04;
		  /* 821BFE04h */ case    9:  		/* rlwimi R11, R9, 7, 19, 26 */
		/* 821BFE04h case    9:*/		cpu::op::rlwimi<0,7,19,26>(regs,&regs.R11,regs.R9);
		/* 821BFE04h case    9:*/		return 0x821BFE08;
		  /* 821BFE08h */ case   10:  		/* subf R10, R30, R11 */
		/* 821BFE08h case   10:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R30,regs.R11);
		/* 821BFE08h case   10:*/		return 0x821BFE0C;
		  /* 821BFE0Ch */ case   11:  		/* stw R3, <#[R31 + 12]> */
		/* 821BFE0Ch case   11:*/		cpu::mem::store32( regs, regs.R3, (uint32)(regs.R31 + 0x0000000C) );
		/* 821BFE0Ch case   11:*/		return 0x821BFE10;
		  /* 821BFE10h */ case   12:  		/* rlwimi R10, R11, 0, 0, 26 */
		/* 821BFE10h case   12:*/		cpu::op::rlwimi<0,0,0,26>(regs,&regs.R10,regs.R11);
		/* 821BFE10h case   12:*/		return 0x821BFE14;
		  /* 821BFE14h */ case   13:  		/* stw R10, <#[R31]> */
		/* 821BFE14h case   13:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R31 + 0x00000000) );
		/* 821BFE14h case   13:*/		return 0x821BFE18;
	}
	return 0x821BFE18;
} // Block from 821BFDE0h-821BFE18h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821BFE18h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BFE18( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BFE18) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BFE18);
		  /* 821BFE18h */ case    0:  		/* lwz R11, <#[R29]> */
		/* 821BFE18h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 821BFE18h case    0:*/		return 0x821BFE1C;
		  /* 821BFE1Ch */ case    1:  		/* cmplw CR6, R11, R31 */
		/* 821BFE1Ch case    1:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 821BFE1Ch case    1:*/		return 0x821BFE20;
		  /* 821BFE20h */ case    2:  		/* bc 4, CR6_EQ, -304 */
		/* 821BFE20h case    2:*/		if ( !regs.CR[6].eq ) { return 0x821BFCF0;  }
		/* 821BFE20h case    2:*/		return 0x821BFE24;
		  /* 821BFE24h */ case    3:  		/* addi R29, R31, 8 */
		/* 821BFE24h case    3:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R31,0x8);
		/* 821BFE24h case    3:*/		return 0x821BFE28;
		  /* 821BFE28h */ case    4:  		/* b -312 */
		/* 821BFE28h case    4:*/		return 0x821BFCF0;
		/* 821BFE28h case    4:*/		return 0x821BFE2C;
	}
	return 0x821BFE2C;
} // Block from 821BFE18h-821BFE2Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 821BFE2Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BFE2C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BFE2C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BFE2C);
		  /* 821BFE2Ch */ case    0:  		/* lwz R30, <#[R28]> */
		/* 821BFE2Ch case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R28 + 0x00000000) );
		/* 821BFE2Ch case    0:*/		return 0x821BFE30;
		  /* 821BFE30h */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 821BFE30h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821BFE30h case    1:*/		return 0x821BFE34;
		  /* 821BFE34h */ case    2:  		/* bc 12, CR6_EQ, 172 */
		/* 821BFE34h case    2:*/		if ( regs.CR[6].eq ) { return 0x821BFEE0;  }
		/* 821BFE34h case    2:*/		return 0x821BFE38;
		  /* 821BFE38h */ case    3:  		/* lwz R31, <#[R30 + 16]> */
		/* 821BFE38h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R30 + 0x00000010) );
		/* 821BFE38h case    3:*/		return 0x821BFE3C;
		  /* 821BFE3Ch */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 821BFE3Ch case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821BFE3Ch case    4:*/		return 0x821BFE40;
		  /* 821BFE40h */ case    5:  		/* bc 12, CR6_EQ, 152 */
		/* 821BFE40h case    5:*/		if ( regs.CR[6].eq ) { return 0x821BFED8;  }
		/* 821BFE40h case    5:*/		return 0x821BFE44;
		  /* 821BFE44h */ case    6:  		/* lwz R10, <#[R31 + 28]> */
		/* 821BFE44h case    6:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x0000001C) );
		/* 821BFE44h case    6:*/		return 0x821BFE48;
		  /* 821BFE48h */ case    7:  		/* lwz R11, <#[R10 + 44]> */
		/* 821BFE48h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x0000002C) );
		/* 821BFE48h case    7:*/		return 0x821BFE4C;
		  /* 821BFE4Ch */ case    8:  		/* subf R11, R11, R24 */
		/* 821BFE4Ch case    8:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R11,regs.R24);
		/* 821BFE4Ch case    8:*/		return 0x821BFE50;
		  /* 821BFE50h */ case    9:  		/* addic R9, R11, -1 */
		/* 821BFE50h case    9:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R11,0xFFFFFFFF);
		/* 821BFE50h case    9:*/		return 0x821BFE54;
		  /* 821BFE54h */ case   10:  		/* subfe R11, R9, R11 */
		/* 821BFE54h case   10:*/		cpu::op::subfe<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 821BFE54h case   10:*/		return 0x821BFE58;
		  /* 821BFE58h */ case   11:  		/* rlwinm. R9, R11, 0, 24, 31 */
		/* 821BFE58h case   11:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R9,regs.R11);
		/* 821BFE58h case   11:*/		return 0x821BFE5C;
		  /* 821BFE5Ch */ case   12:  		/* bc 12, CR0_EQ, 88 */
		/* 821BFE5Ch case   12:*/		if ( regs.CR[0].eq ) { return 0x821BFEB4;  }
		/* 821BFE5Ch case   12:*/		return 0x821BFE60;
		  /* 821BFE60h */ case   13:  		/* cmplwi CR6, R22, 0 */
		/* 821BFE60h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 821BFE60h case   13:*/		return 0x821BFE64;
		  /* 821BFE64h */ case   14:  		/* bc 12, CR6_EQ, 80 */
		/* 821BFE64h case   14:*/		if ( regs.CR[6].eq ) { return 0x821BFEB4;  }
		/* 821BFE64h case   14:*/		return 0x821BFE68;
		  /* 821BFE68h */ case   15:  		/* lwz R11, <#[R10 + 48]> */
		/* 821BFE68h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000030) );
		/* 821BFE68h case   15:*/		return 0x821BFE6C;
		  /* 821BFE6Ch */ case   16:  		/* rlwinm. R11, R11, 13, 31, 31 */
		/* 821BFE6Ch case   16:*/		cpu::op::rlwinm<1,13,31,31>(regs,&regs.R11,regs.R11);
		/* 821BFE6Ch case   16:*/		return 0x821BFE70;
		  /* 821BFE70h */ case   17:  		/* bc 12, CR0_EQ, 68 */
		/* 821BFE70h case   17:*/		if ( regs.CR[0].eq ) { return 0x821BFEB4;  }
		/* 821BFE70h case   17:*/		return 0x821BFE74;
		  /* 821BFE74h */ case   18:  		/* mr R3, R26 */
		/* 821BFE74h case   18:*/		regs.R3 = regs.R26;
		/* 821BFE74h case   18:*/		return 0x821BFE78;
		  /* 821BFE78h */ case   19:  		/* lwz R4, <#[R27 + 28]> */
		/* 821BFE78h case   19:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R27 + 0x0000001C) );
		/* 821BFE78h case   19:*/		return 0x821BFE7C;
		  /* 821BFE7Ch */ case   20:  		/* bl -292364 */
		/* 821BFE7Ch case   20:*/		regs.LR = 0x821BFE80; return 0x82178870;
		/* 821BFE7Ch case   20:*/		return 0x821BFE80;
		  /* 821BFE80h */ case   21:  		/* cmplwi CR0, R3, 0 */
		/* 821BFE80h case   21:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 821BFE80h case   21:*/		return 0x821BFE84;
		  /* 821BFE84h */ case   22:  		/* bc 12, CR0_EQ, 216 */
		/* 821BFE84h case   22:*/		if ( regs.CR[0].eq ) { return 0x821BFF5C;  }
		/* 821BFE84h case   22:*/		return 0x821BFE88;
		  /* 821BFE88h */ case   23:  		/* lwz R10, <#[R3 + 8]> */
		/* 821BFE88h case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + 0x00000008) );
		/* 821BFE88h case   23:*/		return 0x821BFE8C;
		  /* 821BFE8Ch */ case   24:  		/* rlwinm R11, R10, 25, 25, 31 */
		/* 821BFE8Ch case   24:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R11,regs.R10);
		/* 821BFE8Ch case   24:*/		return 0x821BFE90;
		  /* 821BFE90h */ case   25:  		/* cmplwi CR6, R11, 86 */
		/* 821BFE90h case   25:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000056);
		/* 821BFE90h case   25:*/		return 0x821BFE94;
		  /* 821BFE94h */ case   26:  		/* bc 12, CR6_EQ, 16 */
		/* 821BFE94h case   26:*/		if ( regs.CR[6].eq ) { return 0x821BFEA4;  }
		/* 821BFE94h case   26:*/		return 0x821BFE98;
		  /* 821BFE98h */ case   27:  		/* cmplwi CR6, R11, 87 */
		/* 821BFE98h case   27:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000057);
		/* 821BFE98h case   27:*/		return 0x821BFE9C;
		  /* 821BFE9Ch */ case   28:  		/* li R11, 0 */
		/* 821BFE9Ch case   28:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BFE9Ch case   28:*/		return 0x821BFEA0;
		  /* 821BFEA0h */ case   29:  		/* bc 4, CR6_EQ, 8 */
		/* 821BFEA0h case   29:*/		if ( !regs.CR[6].eq ) { return 0x821BFEA8;  }
		/* 821BFEA0h case   29:*/		return 0x821BFEA4;
	}
	return 0x821BFEA4;
} // Block from 821BFE2Ch-821BFEA4h (30 instructions)

//////////////////////////////////////////////////////
// Block at 821BFEA4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BFEA4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BFEA4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BFEA4);
		  /* 821BFEA4h */ case    0:  		/* mr R11, R23 */
		/* 821BFEA4h case    0:*/		regs.R11 = regs.R23;
		/* 821BFEA4h case    0:*/		return 0x821BFEA8;
	}
	return 0x821BFEA8;
} // Block from 821BFEA4h-821BFEA8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821BFEA8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BFEA8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BFEA8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BFEA8);
		  /* 821BFEA8h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821BFEA8h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821BFEA8h case    0:*/		return 0x821BFEAC;
		  /* 821BFEACh */ case    1:  		/* bc 12, CR0_EQ, 176 */
		/* 821BFEACh case    1:*/		if ( regs.CR[0].eq ) { return 0x821BFF5C;  }
		/* 821BFEACh case    1:*/		return 0x821BFEB0;
		  /* 821BFEB0h */ case    2:  		/* rlwinm R11, R10, 6, 31, 31 */
		/* 821BFEB0h case    2:*/		cpu::op::rlwinm<0,6,31,31>(regs,&regs.R11,regs.R10);
		/* 821BFEB0h case    2:*/		return 0x821BFEB4;
	}
	return 0x821BFEB4;
} // Block from 821BFEA8h-821BFEB4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BFEB4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BFEB4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BFEB4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BFEB4);
		  /* 821BFEB4h */ case    0:  		/* rlwinm. R11, R11, 0, 24, 31 */
		/* 821BFEB4h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R11);
		/* 821BFEB4h case    0:*/		return 0x821BFEB8;
		  /* 821BFEB8h */ case    1:  		/* bc 12, CR0_EQ, 32 */
		/* 821BFEB8h case    1:*/		if ( regs.CR[0].eq ) { return 0x821BFED8;  }
		/* 821BFEB8h case    1:*/		return 0x821BFEBC;
		  /* 821BFEBCh */ case    2:  		/* mr R5, R25 */
		/* 821BFEBCh case    2:*/		regs.R5 = regs.R25;
		/* 821BFEBCh case    2:*/		return 0x821BFEC0;
		  /* 821BFEC0h */ case    3:  		/* mr R4, R30 */
		/* 821BFEC0h case    3:*/		regs.R4 = regs.R30;
		/* 821BFEC0h case    3:*/		return 0x821BFEC4;
		  /* 821BFEC4h */ case    4:  		/* mr R3, R26 */
		/* 821BFEC4h case    4:*/		regs.R3 = regs.R26;
		/* 821BFEC4h case    4:*/		return 0x821BFEC8;
		  /* 821BFEC8h */ case    5:  		/* bl -323032 */
		/* 821BFEC8h case    5:*/		regs.LR = 0x821BFECC; return 0x821710F0;
		/* 821BFEC8h case    5:*/		return 0x821BFECC;
		  /* 821BFECCh */ case    6:  		/* mr R4, R3 */
		/* 821BFECCh case    6:*/		regs.R4 = regs.R3;
		/* 821BFECCh case    6:*/		return 0x821BFED0;
		  /* 821BFED0h */ case    7:  		/* mr R3, R31 */
		/* 821BFED0h case    7:*/		regs.R3 = regs.R31;
		/* 821BFED0h case    7:*/		return 0x821BFED4;
		  /* 821BFED4h */ case    8:  		/* bl -294156 */
		/* 821BFED4h case    8:*/		regs.LR = 0x821BFED8; return 0x821781C8;
		/* 821BFED4h case    8:*/		return 0x821BFED8;
	}
	return 0x821BFED8;
} // Block from 821BFEB4h-821BFED8h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821BFED8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BFED8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BFED8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BFED8);
		  /* 821BFED8h */ case    0:  		/* lwz R30, <#[R30 + 8]> */
		/* 821BFED8h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000008) );
		/* 821BFED8h case    0:*/		return 0x821BFEDC;
		  /* 821BFEDCh */ case    1:  		/* b -172 */
		/* 821BFEDCh case    1:*/		return 0x821BFE30;
		/* 821BFEDCh case    1:*/		return 0x821BFEE0;
	}
	return 0x821BFEE0;
} // Block from 821BFED8h-821BFEE0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BFEE0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BFEE0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BFEE0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BFEE0);
		  /* 821BFEE0h */ case    0:  		/* lwz R11, <#[R25 + 8]> */
		/* 821BFEE0h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R25 + 0x00000008) );
		/* 821BFEE0h case    0:*/		return 0x821BFEE4;
		  /* 821BFEE4h */ case    1:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821BFEE4h case    1:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821BFEE4h case    1:*/		return 0x821BFEE8;
		  /* 821BFEE8h */ case    2:  		/* cmplwi CR6, R11, 10880 */
		/* 821BFEE8h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00002A80);
		/* 821BFEE8h case    2:*/		return 0x821BFEEC;
		  /* 821BFEECh */ case    3:  		/* bc 4, CR6_EQ, 76 */
		/* 821BFEECh case    3:*/		if ( !regs.CR[6].eq ) { return 0x821BFF38;  }
		/* 821BFEECh case    3:*/		return 0x821BFEF0;
		  /* 821BFEF0h */ case    4:  		/* li R6, 0 */
		/* 821BFEF0h case    4:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821BFEF0h case    4:*/		return 0x821BFEF4;
		  /* 821BFEF4h */ case    5:  		/* li R5, 0 */
		/* 821BFEF4h case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821BFEF4h case    5:*/		return 0x821BFEF8;
		  /* 821BFEF8h */ case    6:  		/* li R4, 85 */
		/* 821BFEF8h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x55);
		/* 821BFEF8h case    6:*/		return 0x821BFEFC;
		  /* 821BFEFCh */ case    7:  		/* mr R3, R26 */
		/* 821BFEFCh case    7:*/		regs.R3 = regs.R26;
		/* 821BFEFCh case    7:*/		return 0x821BFF00;
		  /* 821BFF00h */ case    8:  		/* bl -375504 */
		/* 821BFF00h case    8:*/		regs.LR = 0x821BFF04; return 0x82164430;
		/* 821BFF00h case    8:*/		return 0x821BFF04;
		  /* 821BFF04h */ case    9:  		/* addi R10, R3, -20 */
		/* 821BFF04h case    9:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R3,0xFFFFFFEC);
		/* 821BFF04h case    9:*/		return 0x821BFF08;
		  /* 821BFF08h */ case   10:  		/* cmplwi CR6, R22, 0 */
		/* 821BFF08h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R22,0x00000000);
		/* 821BFF08h case   10:*/		return 0x821BFF0C;
		  /* 821BFF0Ch */ case   11:  		/* lwzx R11, <#[R10 + R27]> */
		/* 821BFF0Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + regs.R27 + 0x00000000) );
		/* 821BFF0Ch case   11:*/		return 0x821BFF10;
		  /* 821BFF10h */ case   12:  		/* bc 12, CR6_EQ, 16 */
		/* 821BFF10h case   12:*/		if ( regs.CR[6].eq ) { return 0x821BFF20;  }
		/* 821BFF10h case   12:*/		return 0x821BFF14;
		  /* 821BFF14h */ case   13:  		/* lwz R9, <#[R11 + 8]> */
		/* 821BFF14h case   13:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 821BFF14h case   13:*/		return 0x821BFF18;
		  /* 821BFF18h */ case   14:  		/* rlwinm. R9, R9, 6, 31, 31 */
		/* 821BFF18h case   14:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R9,regs.R9);
		/* 821BFF18h case   14:*/		return 0x821BFF1C;
		  /* 821BFF1Ch */ case   15:  		/* bc 12, CR0_EQ, 28 */
		/* 821BFF1Ch case   15:*/		if ( regs.CR[0].eq ) { return 0x821BFF38;  }
		/* 821BFF1Ch case   15:*/		return 0x821BFF20;
	}
	return 0x821BFF20;
} // Block from 821BFEE0h-821BFF20h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821BFF20h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BFF20( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BFF20) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BFF20);
		  /* 821BFF20h */ case    0:  		/* lwz R9, <#[R11 + 28]> */
		/* 821BFF20h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000001C) );
		/* 821BFF20h case    0:*/		return 0x821BFF24;
		  /* 821BFF24h */ case    1:  		/* lwz R9, <#[R9 + 44]> */
		/* 821BFF24h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x0000002C) );
		/* 821BFF24h case    1:*/		return 0x821BFF28;
		  /* 821BFF28h */ case    2:  		/* cmplw CR6, R9, R24 */
		/* 821BFF28h case    2:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R24);
		/* 821BFF28h case    2:*/		return 0x821BFF2C;
		  /* 821BFF2Ch */ case    3:  		/* bc 4, CR6_EQ, 12 */
		/* 821BFF2Ch case    3:*/		if ( !regs.CR[6].eq ) { return 0x821BFF38;  }
		/* 821BFF2Ch case    3:*/		return 0x821BFF30;
		  /* 821BFF30h */ case    4:  		/* lwz R11, <#[R11 + 32]> */
		/* 821BFF30h case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000020) );
		/* 821BFF30h case    4:*/		return 0x821BFF34;
		  /* 821BFF34h */ case    5:  		/* stwx R11, <#[R10 + R25]> */
		/* 821BFF34h case    5:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R10 + regs.R25 + 0x00000000) );
		/* 821BFF34h case    5:*/		return 0x821BFF38;
	}
	return 0x821BFF38;
} // Block from 821BFF20h-821BFF38h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821BFF38h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BFF38( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BFF38) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BFF38);
		  /* 821BFF38h */ case    0:  		/* rlwinm R11, R27, 0, 0, 30 */
		/* 821BFF38h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R27);
		/* 821BFF38h case    0:*/		return 0x821BFF3C;
		  /* 821BFF3Ch */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 821BFF3Ch case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 821BFF3Ch case    1:*/		return 0x821BFF40;
		  /* 821BFF40h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821BFF40h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821BFF40h case    2:*/		return 0x821BFF44;
		  /* 821BFF44h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 821BFF44h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821BFF54;  }
		/* 821BFF44h case    3:*/		return 0x821BFF48;
		  /* 821BFF48h */ case    4:  		/* mr R27, R11 */
		/* 821BFF48h case    4:*/		regs.R27 = regs.R11;
		/* 821BFF48h case    4:*/		return 0x821BFF4C;
		  /* 821BFF4Ch */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821BFF4Ch case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821BFF4Ch case    5:*/		return 0x821BFF50;
		  /* 821BFF50h */ case    6:  		/* bc 4, CR6_EQ, -1500 */
		/* 821BFF50h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821BF974;  }
		/* 821BFF50h case    6:*/		return 0x821BFF54;
	}
	return 0x821BFF54;
} // Block from 821BFF38h-821BFF54h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821BFF54h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BFF54( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BFF54) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BFF54);
		  /* 821BFF54h */ case    0:  		/* addi R1, R1, 176 */
		/* 821BFF54h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 821BFF54h case    0:*/		return 0x821BFF58;
		  /* 821BFF58h */ case    1:  		/* b -1240264 */
		/* 821BFF58h case    1:*/		return 0x82091290;
		/* 821BFF58h case    1:*/		return 0x821BFF5C;
	}
	return 0x821BFF5C;
} // Block from 821BFF54h-821BFF5Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BFF5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BFF5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BFF5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BFF5C);
		  /* 821BFF5Ch */ case    0:  		/* li R4, 4800 */
		/* 821BFF5Ch case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 821BFF5Ch case    0:*/		return 0x821BFF60;
		  /* 821BFF60h */ case    1:  		/* mr R3, R26 */
		/* 821BFF60h case    1:*/		regs.R3 = regs.R26;
		/* 821BFF60h case    1:*/		return 0x821BFF64;
		  /* 821BFF64h */ case    2:  		/* bl -450812 */
		/* 821BFF64h case    2:*/		regs.LR = 0x821BFF68; return 0x82151E68;
		/* 821BFF64h case    2:*/		return 0x821BFF68;
	}
	return 0x821BFF68;
} // Block from 821BFF5Ch-821BFF68h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BFF68h
// Function ''
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BFF68( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BFF68) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BFF68);
		  /* 821BFF68h */ case    0:  		/* mfspr R12, LR */
		/* 821BFF68h case    0:*/		regs.R12 = regs.LR;
		/* 821BFF68h case    0:*/		return 0x821BFF6C;
		  /* 821BFF6Ch */ case    1:  		/* bl -1240336 */
		/* 821BFF6Ch case    1:*/		regs.LR = 0x821BFF70; return 0x8209125C;
		/* 821BFF6Ch case    1:*/		return 0x821BFF70;
		  /* 821BFF70h */ case    2:  		/* stwu R1, <#[R1 - 128]> */
		/* 821BFF70h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF80) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF80);
		/* 821BFF70h case    2:*/		return 0x821BFF74;
		  /* 821BFF74h */ case    3:  		/* lwz R31, <#[R3 + 4]> */
		/* 821BFF74h case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R3 + 0x00000004) );
		/* 821BFF74h case    3:*/		return 0x821BFF78;
		  /* 821BFF78h */ case    4:  		/* mr R29, R3 */
		/* 821BFF78h case    4:*/		regs.R29 = regs.R3;
		/* 821BFF78h case    4:*/		return 0x821BFF7C;
		  /* 821BFF7Ch */ case    5:  		/* mr R30, R4 */
		/* 821BFF7Ch case    5:*/		regs.R30 = regs.R4;
		/* 821BFF7Ch case    5:*/		return 0x821BFF80;
		  /* 821BFF80h */ case    6:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 821BFF80h case    6:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 821BFF80h case    6:*/		return 0x821BFF84;
		  /* 821BFF84h */ case    7:  		/* bc 4, CR0_EQ, 280 */
		/* 821BFF84h case    7:*/		if ( !regs.CR[0].eq ) { return 0x821C009C;  }
		/* 821BFF84h case    7:*/		return 0x821BFF88;
		  /* 821BFF88h */ case    8:  		/* cmplwi CR0, R31, 0 */
		/* 821BFF88h case    8:*/		cpu::op::cmplwi<0>(regs,regs.R31,0x00000000);
		/* 821BFF88h case    8:*/		return 0x821BFF8C;
		  /* 821BFF8Ch */ case    9:  		/* bc 12, CR0_EQ, 272 */
		/* 821BFF8Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x821C009C;  }
		/* 821BFF8Ch case    9:*/		return 0x821BFF90;
		  /* 821BFF90h */ case   10:  		/* lwz R11, <#[R31 + 44]> */
		/* 821BFF90h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000002C) );
		/* 821BFF90h case   10:*/		return 0x821BFF94;
		  /* 821BFF94h */ case   11:  		/* cmplw CR6, R11, R30 */
		/* 821BFF94h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 821BFF94h case   11:*/		return 0x821BFF98;
		  /* 821BFF98h */ case   12:  		/* bc 4, CR6_EQ, 236 */
		/* 821BFF98h case   12:*/		if ( !regs.CR[6].eq ) { return 0x821C0084;  }
		/* 821BFF98h case   12:*/		return 0x821BFF9C;
		  /* 821BFF9Ch */ case   13:  		/* li R11, 0 */
		/* 821BFF9Ch case   13:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821BFF9Ch case   13:*/		return 0x821BFFA0;
		  /* 821BFFA0h */ case   14:  		/* lwz R4, <#[R31 + 80]> */
		/* 821BFFA0h case   14:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R31 + 0x00000050) );
		/* 821BFFA0h case   14:*/		return 0x821BFFA4;
		  /* 821BFFA4h */ case   15:  		/* addi R5, R1, 80 */
		/* 821BFFA4h case   15:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 821BFFA4h case   15:*/		return 0x821BFFA8;
		  /* 821BFFA8h */ case   16:  		/* stb R11, <#[R1 + 80]> */
		/* 821BFFA8h case   16:*/		cpu::mem::store8( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 821BFFA8h case   16:*/		return 0x821BFFAC;
		  /* 821BFFACh */ case   17:  		/* mr R3, R29 */
		/* 821BFFACh case   17:*/		regs.R3 = regs.R29;
		/* 821BFFACh case   17:*/		return 0x821BFFB0;
		  /* 821BFFB0h */ case   18:  		/* bl -5408 */
		/* 821BFFB0h case   18:*/		regs.LR = 0x821BFFB4; return 0x821BEA90;
		/* 821BFFB0h case   18:*/		return 0x821BFFB4;
		  /* 821BFFB4h */ case   19:  		/* lwz R11, <#[R31 + 20]> */
		/* 821BFFB4h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 821BFFB4h case   19:*/		return 0x821BFFB8;
		  /* 821BFFB8h */ case   20:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821BFFB8h case   20:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821BFFB8h case   20:*/		return 0x821BFFBC;
		  /* 821BFFBCh */ case   21:  		/* bc 12, CR0_EQ, 40 */
		/* 821BFFBCh case   21:*/		if ( regs.CR[0].eq ) { return 0x821BFFE4;  }
		/* 821BFFBCh case   21:*/		return 0x821BFFC0;
		  /* 821BFFC0h */ case   22:  		/* lwz R11, <#[R31 + 28]> */
		/* 821BFFC0h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 821BFFC0h case   22:*/		return 0x821BFFC4;
		  /* 821BFFC4h */ case   23:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821BFFC4h case   23:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821BFFC4h case   23:*/		return 0x821BFFC8;
		  /* 821BFFC8h */ case   24:  		/* bc 12, CR0_EQ, 16 */
		/* 821BFFC8h case   24:*/		if ( regs.CR[0].eq ) { return 0x821BFFD8;  }
		/* 821BFFC8h case   24:*/		return 0x821BFFCC;
		  /* 821BFFCCh */ case   25:  		/* lwz R11, <#[R31 + 36]> */
		/* 821BFFCCh case   25:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000024) );
		/* 821BFFCCh case   25:*/		return 0x821BFFD0;
		  /* 821BFFD0h */ case   26:  		/* addi R10, R31, 32 */
		/* 821BFFD0h case   26:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x20);
		/* 821BFFD0h case   26:*/		return 0x821BFFD4;
		  /* 821BFFD4h */ case   27:  		/* b 24 */
		/* 821BFFD4h case   27:*/		return 0x821BFFEC;
		/* 821BFFD4h case   27:*/		return 0x821BFFD8;
	}
	return 0x821BFFD8;
} // Block from 821BFF68h-821BFFD8h (28 instructions)

//////////////////////////////////////////////////////
// Block at 821BFFD8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BFFD8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BFFD8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BFFD8);
		  /* 821BFFD8h */ case    0:  		/* lwz R11, <#[R31 + 28]> */
		/* 821BFFD8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 821BFFD8h case    0:*/		return 0x821BFFDC;
		  /* 821BFFDCh */ case    1:  		/* addi R10, R31, 24 */
		/* 821BFFDCh case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x18);
		/* 821BFFDCh case    1:*/		return 0x821BFFE0;
		  /* 821BFFE0h */ case    2:  		/* b 12 */
		/* 821BFFE0h case    2:*/		return 0x821BFFEC;
		/* 821BFFE0h case    2:*/		return 0x821BFFE4;
	}
	return 0x821BFFE4;
} // Block from 821BFFD8h-821BFFE4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821BFFE4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BFFE4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BFFE4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BFFE4);
		  /* 821BFFE4h */ case    0:  		/* lwz R11, <#[R31 + 20]> */
		/* 821BFFE4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000014) );
		/* 821BFFE4h case    0:*/		return 0x821BFFE8;
		  /* 821BFFE8h */ case    1:  		/* addi R10, R31, 16 */
		/* 821BFFE8h case    1:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R31,0x10);
		/* 821BFFE8h case    1:*/		return 0x821BFFEC;
	}
	return 0x821BFFEC;
} // Block from 821BFFE4h-821BFFECh (2 instructions)

//////////////////////////////////////////////////////
// Block at 821BFFECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821BFFEC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821BFFEC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821BFFEC);
		  /* 821BFFECh */ case    0:  		/* rlwinm R9, R11, 0, 31, 31 */
		/* 821BFFECh case    0:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R9,regs.R11);
		/* 821BFFECh case    0:*/		return 0x821BFFF0;
		  /* 821BFFF0h */ case    1:  		/* addic R9, R9, -1 */
		/* 821BFFF0h case    1:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 821BFFF0h case    1:*/		return 0x821BFFF4;
		  /* 821BFFF4h */ case    2:  		/* subfe R9, R9, R9 */
		/* 821BFFF4h case    2:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 821BFFF4h case    2:*/		return 0x821BFFF8;
		  /* 821BFFF8h */ case    3:  		/* and R11, R9, R11 */
		/* 821BFFF8h case    3:*/		cpu::op::and<0>(regs,&regs.R11,regs.R9,regs.R11);
		/* 821BFFF8h case    3:*/		return 0x821BFFFC;
		  /* 821BFFFCh */ case    4:  		/* b 128 */
		/* 821BFFFCh case    4:*/		return 0x821C007C;
		/* 821BFFFCh case    4:*/		return 0x821C0000;
		  /* 821C0000h */ case    5:  		/* lwz R9, <#[R11 + 8]> */
		/* 821C0000h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 821C0000h case    5:*/		return 0x821C0004;
		  /* 821C0004h */ case    6:  		/* rlwinm. R8, R9, 6, 31, 31 */
		/* 821C0004h case    6:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R8,regs.R9);
		/* 821C0004h case    6:*/		return 0x821C0008;
		  /* 821C0008h */ case    7:  		/* bc 12, CR0_EQ, 28 */
		/* 821C0008h case    7:*/		if ( regs.CR[0].eq ) { return 0x821C0024;  }
		/* 821C0008h case    7:*/		return 0x821C000C;
		  /* 821C000Ch */ case    8:  		/* lwz R8, <#[R11 + 32]> */
		/* 821C000Ch case    8:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R11 + 0x00000020) );
		/* 821C000Ch case    8:*/		return 0x821C0010;
		  /* 821C0010h */ case    9:  		/* rlwinm R9, R9, 0, 6, 4 */
		/* 821C0010h case    9:*/		cpu::op::rlwinm<0,0,6,4>(regs,&regs.R9,regs.R9);
		/* 821C0010h case    9:*/		return 0x821C0014;
		  /* 821C0014h */ case   10:  		/* stw R9, <#[R11 + 8]> */
		/* 821C0014h case   10:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R11 + 0x00000008) );
		/* 821C0014h case   10:*/		return 0x821C0018;
		  /* 821C0018h */ case   11:  		/* lwz R9, <#[R8 + 8]> */
		/* 821C0018h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R8 + 0x00000008) );
		/* 821C0018h case   11:*/		return 0x821C001C;
		  /* 821C001Ch */ case   12:  		/* rlwinm R9, R9, 0, 6, 4 */
		/* 821C001Ch case   12:*/		cpu::op::rlwinm<0,0,6,4>(regs,&regs.R9,regs.R9);
		/* 821C001Ch case   12:*/		return 0x821C0020;
		  /* 821C0020h */ case   13:  		/* stw R9, <#[R8 + 8]> */
		/* 821C0020h case   13:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R8 + 0x00000008) );
		/* 821C0020h case   13:*/		return 0x821C0024;
	}
	return 0x821C0024;
} // Block from 821BFFECh-821C0024h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821C0024h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C0024( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C0024) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C0024);
		  /* 821C0024h */ case    0:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821C0024h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821C0024h case    0:*/		return 0x821C0028;
	}
	return 0x821C0028;
} // Block from 821C0024h-821C0028h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821C0028h
// Function '?MarkReachableBlocks@Compiler@D3DXShader@@AAAX_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C0028( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C0028) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C0028);
		  /* 821C0028h */ case    0:  		/* lwz R11, <#[R11 + 40]> */
		/* 821C0028h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 821C0028h case    0:*/		return 0x821C002C;
		  /* 821C002Ch */ case    1:  		/* rlwinm. R9, R11, 0, 31, 31 */
		/* 821C002Ch case    1:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R11);
		/* 821C002Ch case    1:*/		return 0x821C0030;
		  /* 821C0030h */ case    2:  		/* bc 4, CR0_EQ, 12 */
		/* 821C0030h case    2:*/		if ( !regs.CR[0].eq ) { return 0x821C003C;  }
		/* 821C0030h case    2:*/		return 0x821C0034;
		  /* 821C0034h */ case    3:  		/* cmplwi CR6, R11, 0 */
		/* 821C0034h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821C0034h case    3:*/		return 0x821C0038;
		  /* 821C0038h */ case    4:  		/* bc 4, CR6_EQ, -56 */
		/* 821C0038h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821C0000;  }
		/* 821C0038h case    4:*/		return 0x821C003C;
	}
	return 0x821C003C;
} // Block from 821C0028h-821C003Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 821C003Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C003C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C003C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C003C);
		  /* 821C003Ch */ case    0:  		/* addi R8, R31, 32 */
		/* 821C003Ch case    0:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R31,0x20);
		/* 821C003Ch case    0:*/		return 0x821C0040;
		  /* 821C0040h */ case    1:  		/* cmplw CR6, R10, R8 */
		/* 821C0040h case    1:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 821C0040h case    1:*/		return 0x821C0044;
		  /* 821C0044h */ case    2:  		/* bc 12, CR6_EQ, 64 */
		/* 821C0044h case    2:*/		if ( regs.CR[6].eq ) { return 0x821C0084;  }
		/* 821C0044h case    2:*/		return 0x821C0048;
		  /* 821C0048h */ case    3:  		/* addi R9, R31, 24 */
		/* 821C0048h case    3:*/		cpu::op::addi<0>(regs,&regs.R9,regs.R31,0x18);
		/* 821C0048h case    3:*/		return 0x821C004C;
		  /* 821C004Ch */ case    4:  		/* cmplw CR6, R10, R9 */
		/* 821C004Ch case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 821C004Ch case    4:*/		return 0x821C0050;
		  /* 821C0050h */ case    5:  		/* bc 12, CR6_EQ, 28 */
		/* 821C0050h case    5:*/		if ( regs.CR[6].eq ) { return 0x821C006C;  }
		/* 821C0050h case    5:*/		return 0x821C0054;
		  /* 821C0054h */ case    6:  		/* lwz R11, <#[R31 + 28]> */
		/* 821C0054h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x0000001C) );
		/* 821C0054h case    6:*/		return 0x821C0058;
		  /* 821C0058h */ case    7:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821C0058h case    7:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821C0058h case    7:*/		return 0x821C005C;
		  /* 821C005Ch */ case    8:  		/* bc 4, CR0_EQ, 16 */
		/* 821C005Ch case    8:*/		if ( !regs.CR[0].eq ) { return 0x821C006C;  }
		/* 821C005Ch case    8:*/		return 0x821C0060;
		  /* 821C0060h */ case    9:  		/* lwz R11, <#[R9 + 4]> */
		/* 821C0060h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000004) );
		/* 821C0060h case    9:*/		return 0x821C0064;
		  /* 821C0064h */ case   10:  		/* mr R10, R9 */
		/* 821C0064h case   10:*/		regs.R10 = regs.R9;
		/* 821C0064h case   10:*/		return 0x821C0068;
		  /* 821C0068h */ case   11:  		/* b 12 */
		/* 821C0068h case   11:*/		return 0x821C0074;
		/* 821C0068h case   11:*/		return 0x821C006C;
	}
	return 0x821C006C;
} // Block from 821C003Ch-821C006Ch (12 instructions)

//////////////////////////////////////////////////////
// Block at 821C006Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C006C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C006C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C006C);
		  /* 821C006Ch */ case    0:  		/* lwz R11, <#[R8 + 4]> */
		/* 821C006Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R8 + 0x00000004) );
		/* 821C006Ch case    0:*/		return 0x821C0070;
		  /* 821C0070h */ case    1:  		/* mr R10, R8 */
		/* 821C0070h case    1:*/		regs.R10 = regs.R8;
		/* 821C0070h case    1:*/		return 0x821C0074;
	}
	return 0x821C0074;
} // Block from 821C006Ch-821C0074h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821C0074h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C0074( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C0074) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C0074);
		  /* 821C0074h */ case    0:  		/* rlwinm. R9, R11, 0, 31, 31 */
		/* 821C0074h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R11);
		/* 821C0074h case    0:*/		return 0x821C0078;
		  /* 821C0078h */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 821C0078h case    1:*/		if ( !regs.CR[0].eq ) { return 0x821C0084;  }
		/* 821C0078h case    1:*/		return 0x821C007C;
	}
	return 0x821C007C;
} // Block from 821C0074h-821C007Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 821C007Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C007C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C007C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C007C);
		  /* 821C007Ch */ case    0:  		/* cmplwi CR6, R11, 0 */
		/* 821C007Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821C007Ch case    0:*/		return 0x821C0080;
		  /* 821C0080h */ case    1:  		/* bc 4, CR6_EQ, -128 */
		/* 821C0080h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821C0000;  }
		/* 821C0080h case    1:*/		return 0x821C0084;
	}
	return 0x821C0084;
} // Block from 821C007Ch-821C0084h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821C0084h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C0084( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C0084) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C0084);
		  /* 821C0084h */ case    0:  		/* rlwinm R11, R31, 0, 0, 30 */
		/* 821C0084h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R31);
		/* 821C0084h case    0:*/		return 0x821C0088;
		  /* 821C0088h */ case    1:  		/* lwz R31, <#[R11 + 4]> */
		/* 821C0088h case    1:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000004) );
		/* 821C0088h case    1:*/		return 0x821C008C;
		  /* 821C008Ch */ case    2:  		/* rlwinm. R11, R31, 0, 31, 31 */
		/* 821C008Ch case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R31);
		/* 821C008Ch case    2:*/		return 0x821C0090;
		  /* 821C0090h */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 821C0090h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821C009C;  }
		/* 821C0090h case    3:*/		return 0x821C0094;
		  /* 821C0094h */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 821C0094h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821C0094h case    4:*/		return 0x821C0098;
		  /* 821C0098h */ case    5:  		/* bc 4, CR6_EQ, -264 */
		/* 821C0098h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821BFF90;  }
		/* 821C0098h case    5:*/		return 0x821C009C;
	}
	return 0x821C009C;
} // Block from 821C0084h-821C009Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 821C009Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C009C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C009C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C009C);
		  /* 821C009Ch */ case    0:  		/* lwz R11, <#[R29 + 4]> */
		/* 821C009Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 821C009Ch case    0:*/		return 0x821C00A0;
		  /* 821C00A0h */ case    1:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 821C00A0h case    1:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821C00A0h case    1:*/		return 0x821C00A4;
		  /* 821C00A4h */ case    2:  		/* addic R9, R10, -1 */
		/* 821C00A4h case    2:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R10,0xFFFFFFFF);
		/* 821C00A4h case    2:*/		return 0x821C00A8;
		  /* 821C00A8h */ case    3:  		/* subfe R9, R9, R9 */
		/* 821C00A8h case    3:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 821C00A8h case    3:*/		return 0x821C00AC;
		  /* 821C00ACh */ case    4:  		/* and R9, R9, R11 */
		/* 821C00ACh case    4:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 821C00ACh case    4:*/		return 0x821C00B0;
		  /* 821C00B0h */ case    5:  		/* lwz R9, <#[R9 + 20]> */
		/* 821C00B0h case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000014) );
		/* 821C00B0h case    5:*/		return 0x821C00B4;
		  /* 821C00B4h */ case    6:  		/* rlwinm. R9, R9, 0, 31, 31 */
		/* 821C00B4h case    6:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R9);
		/* 821C00B4h case    6:*/		return 0x821C00B8;
		  /* 821C00B8h */ case    7:  		/* addic R9, R10, -1 */
		/* 821C00B8h case    7:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R10,0xFFFFFFFF);
		/* 821C00B8h case    7:*/		return 0x821C00BC;
		  /* 821C00BCh */ case    8:  		/* subfe R9, R9, R9 */
		/* 821C00BCh case    8:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 821C00BCh case    8:*/		return 0x821C00C0;
		  /* 821C00C0h */ case    9:  		/* and R9, R9, R11 */
		/* 821C00C0h case    9:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 821C00C0h case    9:*/		return 0x821C00C4;
		  /* 821C00C4h */ case   10:  		/* bc 12, CR0_EQ, 100 */
		/* 821C00C4h case   10:*/		if ( regs.CR[0].eq ) { return 0x821C0128;  }
		/* 821C00C4h case   10:*/		return 0x821C00C8;
		  /* 821C00C8h */ case   11:  		/* lwz R9, <#[R9 + 28]> */
		/* 821C00C8h case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x0000001C) );
		/* 821C00C8h case   11:*/		return 0x821C00CC;
		  /* 821C00CCh */ case   12:  		/* rlwinm. R9, R9, 0, 31, 31 */
		/* 821C00CCh case   12:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R9,regs.R9);
		/* 821C00CCh case   12:*/		return 0x821C00D0;
		  /* 821C00D0h */ case   13:  		/* addic R9, R10, -1 */
		/* 821C00D0h case   13:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R10,0xFFFFFFFF);
		/* 821C00D0h case   13:*/		return 0x821C00D4;
		  /* 821C00D4h */ case   14:  		/* subfe R9, R9, R9 */
		/* 821C00D4h case   14:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 821C00D4h case   14:*/		return 0x821C00D8;
		  /* 821C00D8h */ case   15:  		/* and R9, R9, R11 */
		/* 821C00D8h case   15:*/		cpu::op::and<0>(regs,&regs.R9,regs.R9,regs.R11);
		/* 821C00D8h case   15:*/		return 0x821C00DC;
		  /* 821C00DCh */ case   16:  		/* bc 12, CR0_EQ, 40 */
		/* 821C00DCh case   16:*/		if ( regs.CR[0].eq ) { return 0x821C0104;  }
		/* 821C00DCh case   16:*/		return 0x821C00E0;
		  /* 821C00E0h */ case   17:  		/* lwz R9, <#[R9 + 36]> */
		/* 821C00E0h case   17:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000024) );
		/* 821C00E0h case   17:*/		return 0x821C00E4;
		  /* 821C00E4h */ case   18:  		/* rlwinm R8, R9, 0, 31, 31 */
		/* 821C00E4h case   18:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R8,regs.R9);
		/* 821C00E4h case   18:*/		return 0x821C00E8;
	}
	return 0x821C00E8;
} // Block from 821C009Ch-821C00E8h (19 instructions)

//////////////////////////////////////////////////////
// Block at 821C00E8h
// Function '?VisitReachableBlocks@Compiler@D3DXShader@@AAAXI_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C00E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C00E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C00E8);
		  /* 821C00E8h */ case    0:  		/* addic R8, R8, -1 */
		/* 821C00E8h case    0:*/		cpu::op::addic<0>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 821C00E8h case    0:*/		return 0x821C00EC;
		  /* 821C00ECh */ case    1:  		/* subfe R8, R8, R8 */
		/* 821C00ECh case    1:*/		cpu::op::subfe<0>(regs,&regs.R8,regs.R8,regs.R8);
		/* 821C00ECh case    1:*/		return 0x821C00F0;
		  /* 821C00F0h */ case    2:  		/* addic R10, R10, -1 */
		/* 821C00F0h case    2:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 821C00F0h case    2:*/		return 0x821C00F4;
		  /* 821C00F4h */ case    3:  		/* subfe R10, R10, R10 */
		/* 821C00F4h case    3:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 821C00F4h case    3:*/		return 0x821C00F8;
		  /* 821C00F8h */ case    4:  		/* and R11, R10, R11 */
		/* 821C00F8h case    4:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821C00F8h case    4:*/		return 0x821C00FC;
		  /* 821C00FCh */ case    5:  		/* addi R10, R11, 32 */
		/* 821C00FCh case    5:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x20);
		/* 821C00FCh case    5:*/		return 0x821C0100;
		  /* 821C0100h */ case    6:  		/* b 72 */
		/* 821C0100h case    6:*/		return 0x821C0148;
		/* 821C0100h case    6:*/		return 0x821C0104;
	}
	return 0x821C0104;
} // Block from 821C00E8h-821C0104h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821C0104h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C0104( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C0104) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C0104);
		  /* 821C0104h */ case    0:  		/* lwz R9, <#[R9 + 28]> */
		/* 821C0104h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x0000001C) );
		/* 821C0104h case    0:*/		return 0x821C0108;
		  /* 821C0108h */ case    1:  		/* rlwinm R8, R9, 0, 31, 31 */
		/* 821C0108h case    1:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R8,regs.R9);
		/* 821C0108h case    1:*/		return 0x821C010C;
		  /* 821C010Ch */ case    2:  		/* addic R8, R8, -1 */
		/* 821C010Ch case    2:*/		cpu::op::addic<0>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 821C010Ch case    2:*/		return 0x821C0110;
		  /* 821C0110h */ case    3:  		/* subfe R8, R8, R8 */
		/* 821C0110h case    3:*/		cpu::op::subfe<0>(regs,&regs.R8,regs.R8,regs.R8);
		/* 821C0110h case    3:*/		return 0x821C0114;
		  /* 821C0114h */ case    4:  		/* addic R10, R10, -1 */
		/* 821C0114h case    4:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 821C0114h case    4:*/		return 0x821C0118;
		  /* 821C0118h */ case    5:  		/* subfe R10, R10, R10 */
		/* 821C0118h case    5:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 821C0118h case    5:*/		return 0x821C011C;
		  /* 821C011Ch */ case    6:  		/* and R11, R10, R11 */
		/* 821C011Ch case    6:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821C011Ch case    6:*/		return 0x821C0120;
		  /* 821C0120h */ case    7:  		/* addi R10, R11, 24 */
		/* 821C0120h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x18);
		/* 821C0120h case    7:*/		return 0x821C0124;
		  /* 821C0124h */ case    8:  		/* b 36 */
		/* 821C0124h case    8:*/		return 0x821C0148;
		/* 821C0124h case    8:*/		return 0x821C0128;
	}
	return 0x821C0128;
} // Block from 821C0104h-821C0128h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821C0128h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C0128( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C0128) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C0128);
		  /* 821C0128h */ case    0:  		/* lwz R9, <#[R9 + 20]> */
		/* 821C0128h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000014) );
		/* 821C0128h case    0:*/		return 0x821C012C;
		  /* 821C012Ch */ case    1:  		/* rlwinm R8, R9, 0, 31, 31 */
		/* 821C012Ch case    1:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R8,regs.R9);
		/* 821C012Ch case    1:*/		return 0x821C0130;
		  /* 821C0130h */ case    2:  		/* addic R8, R8, -1 */
		/* 821C0130h case    2:*/		cpu::op::addic<0>(regs,&regs.R8,regs.R8,0xFFFFFFFF);
		/* 821C0130h case    2:*/		return 0x821C0134;
		  /* 821C0134h */ case    3:  		/* subfe R8, R8, R8 */
		/* 821C0134h case    3:*/		cpu::op::subfe<0>(regs,&regs.R8,regs.R8,regs.R8);
		/* 821C0134h case    3:*/		return 0x821C0138;
		  /* 821C0138h */ case    4:  		/* addic R10, R10, -1 */
		/* 821C0138h case    4:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R10,0xFFFFFFFF);
		/* 821C0138h case    4:*/		return 0x821C013C;
		  /* 821C013Ch */ case    5:  		/* subfe R10, R10, R10 */
		/* 821C013Ch case    5:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 821C013Ch case    5:*/		return 0x821C0140;
		  /* 821C0140h */ case    6:  		/* and R11, R10, R11 */
		/* 821C0140h case    6:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821C0140h case    6:*/		return 0x821C0144;
		  /* 821C0144h */ case    7:  		/* addi R10, R11, 16 */
		/* 821C0144h case    7:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x10);
		/* 821C0144h case    7:*/		return 0x821C0148;
	}
	return 0x821C0148;
} // Block from 821C0128h-821C0148h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821C0148h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C0148( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C0148) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C0148);
		  /* 821C0148h */ case    0:  		/* and R9, R8, R9 */
		/* 821C0148h case    0:*/		cpu::op::and<0>(regs,&regs.R9,regs.R8,regs.R9);
		/* 821C0148h case    0:*/		return 0x821C014C;
		  /* 821C014Ch */ case    1:  		/* b 180 */
		/* 821C014Ch case    1:*/		return 0x821C0200;
		/* 821C014Ch case    1:*/		return 0x821C0150;
		  /* 821C0150h */ case    2:  		/* lwz R11, <#[R9 + 8]> */
		/* 821C0150h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R9 + 0x00000008) );
		/* 821C0150h case    2:*/		return 0x821C0154;
		  /* 821C0154h */ case    3:  		/* rlwinm. R8, R11, 6, 31, 31 */
		/* 821C0154h case    3:*/		cpu::op::rlwinm<1,6,31,31>(regs,&regs.R8,regs.R11);
		/* 821C0154h case    3:*/		return 0x821C0158;
		  /* 821C0158h */ case    4:  		/* bc 12, CR0_EQ, 12 */
		/* 821C0158h case    4:*/		if ( regs.CR[0].eq ) { return 0x821C0164;  }
		/* 821C0158h case    4:*/		return 0x821C015C;
		  /* 821C015Ch */ case    5:  		/* rlwinm R11, R11, 0, 6, 4 */
		/* 821C015Ch case    5:*/		cpu::op::rlwinm<0,0,6,4>(regs,&regs.R11,regs.R11);
		/* 821C015Ch case    5:*/		return 0x821C0160;
		  /* 821C0160h */ case    6:  		/* stw R11, <#[R9 + 8]> */
		/* 821C0160h case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R9 + 0x00000008) );
		/* 821C0160h case    6:*/		return 0x821C0164;
	}
	return 0x821C0164;
} // Block from 821C0148h-821C0164h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821C0164h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C0164( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C0164) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C0164);
		  /* 821C0164h */ case    0:  		/* rlwinm R11, R9, 0, 0, 30 */
		/* 821C0164h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R9);
		/* 821C0164h case    0:*/		return 0x821C0168;
		  /* 821C0168h */ case    1:  		/* lwz R9, <#[R11 + 40]> */
		/* 821C0168h case    1:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000028) );
		/* 821C0168h case    1:*/		return 0x821C016C;
		  /* 821C016Ch */ case    2:  		/* rlwinm. R11, R9, 0, 31, 31 */
		/* 821C016Ch case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R9);
		/* 821C016Ch case    2:*/		return 0x821C0170;
		  /* 821C0170h */ case    3:  		/* bc 4, CR0_EQ, 12 */
		/* 821C0170h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821C017C;  }
		/* 821C0170h case    3:*/		return 0x821C0174;
		  /* 821C0174h */ case    4:  		/* cmplwi CR6, R9, 0 */
		/* 821C0174h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 821C0174h case    4:*/		return 0x821C0178;
		  /* 821C0178h */ case    5:  		/* bc 4, CR6_EQ, -40 */
		/* 821C0178h case    5:*/		if ( !regs.CR[6].eq ) { return 0x821C0150;  }
		/* 821C0178h case    5:*/		return 0x821C017C;
	}
	return 0x821C017C;
} // Block from 821C0164h-821C017Ch (6 instructions)

//////////////////////////////////////////////////////
// Block at 821C017Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C017C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C017C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C017C);
		  /* 821C017Ch */ case    0:  		/* lwz R11, <#[R29 + 4]> */
		/* 821C017Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000004) );
		/* 821C017Ch case    0:*/		return 0x821C0180;
		  /* 821C0180h */ case    1:  		/* rlwinm R9, R11, 0, 31, 31 */
		/* 821C0180h case    1:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R9,regs.R11);
		/* 821C0180h case    1:*/		return 0x821C0184;
		  /* 821C0184h */ case    2:  		/* addic R8, R9, -1 */
		/* 821C0184h case    2:*/		cpu::op::addic<0>(regs,&regs.R8,regs.R9,0xFFFFFFFF);
		/* 821C0184h case    2:*/		return 0x821C0188;
		  /* 821C0188h */ case    3:  		/* subfe R8, R8, R8 */
		/* 821C0188h case    3:*/		cpu::op::subfe<0>(regs,&regs.R8,regs.R8,regs.R8);
		/* 821C0188h case    3:*/		return 0x821C018C;
		  /* 821C018Ch */ case    4:  		/* and R8, R8, R11 */
		/* 821C018Ch case    4:*/		cpu::op::and<0>(regs,&regs.R8,regs.R8,regs.R11);
		/* 821C018Ch case    4:*/		return 0x821C0190;
		  /* 821C0190h */ case    5:  		/* addi R8, R8, 32 */
		/* 821C0190h case    5:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x20);
		/* 821C0190h case    5:*/		return 0x821C0194;
		  /* 821C0194h */ case    6:  		/* cmplw CR6, R10, R8 */
		/* 821C0194h case    6:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 821C0194h case    6:*/		return 0x821C0198;
		  /* 821C0198h */ case    7:  		/* bc 12, CR6_EQ, 112 */
		/* 821C0198h case    7:*/		if ( regs.CR[6].eq ) { return 0x821C0208;  }
		/* 821C0198h case    7:*/		return 0x821C019C;
		  /* 821C019Ch */ case    8:  		/* addic R8, R9, -1 */
		/* 821C019Ch case    8:*/		cpu::op::addic<0>(regs,&regs.R8,regs.R9,0xFFFFFFFF);
		/* 821C019Ch case    8:*/		return 0x821C01A0;
		  /* 821C01A0h */ case    9:  		/* subfe R8, R8, R8 */
		/* 821C01A0h case    9:*/		cpu::op::subfe<0>(regs,&regs.R8,regs.R8,regs.R8);
		/* 821C01A0h case    9:*/		return 0x821C01A4;
		  /* 821C01A4h */ case   10:  		/* and R8, R8, R11 */
		/* 821C01A4h case   10:*/		cpu::op::and<0>(regs,&regs.R8,regs.R8,regs.R11);
		/* 821C01A4h case   10:*/		return 0x821C01A8;
		  /* 821C01A8h */ case   11:  		/* addi R8, R8, 24 */
		/* 821C01A8h case   11:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R8,0x18);
		/* 821C01A8h case   11:*/		return 0x821C01AC;
		  /* 821C01ACh */ case   12:  		/* cmplw CR6, R10, R8 */
		/* 821C01ACh case   12:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R8);
		/* 821C01ACh case   12:*/		return 0x821C01B0;
	}
	return 0x821C01B0;
} // Block from 821C017Ch-821C01B0h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821C01B0h
// Function '?CloneDependenciesInList@Compiler@D3DXShader@@AAAXPAV?$DoubleLinkList@VInstruction@D3DXShader@@$0CE@@2@I_N@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C01B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C01B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C01B0);
		  /* 821C01B0h */ case    0:  		/* bc 12, CR6_EQ, 52 */
		/* 821C01B0h case    0:*/		if ( regs.CR[6].eq ) { return 0x821C01E4;  }
		/* 821C01B0h case    0:*/		return 0x821C01B4;
		  /* 821C01B4h */ case    1:  		/* addic R10, R9, -1 */
		/* 821C01B4h case    1:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R9,0xFFFFFFFF);
		/* 821C01B4h case    1:*/		return 0x821C01B8;
		  /* 821C01B8h */ case    2:  		/* subfe R10, R10, R10 */
		/* 821C01B8h case    2:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 821C01B8h case    2:*/		return 0x821C01BC;
		  /* 821C01BCh */ case    3:  		/* and R10, R10, R11 */
		/* 821C01BCh case    3:*/		cpu::op::and<0>(regs,&regs.R10,regs.R10,regs.R11);
		/* 821C01BCh case    3:*/		return 0x821C01C0;
		  /* 821C01C0h */ case    4:  		/* lwz R10, <#[R10 + 28]> */
		/* 821C01C0h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000001C) );
		/* 821C01C0h case    4:*/		return 0x821C01C4;
		  /* 821C01C4h */ case    5:  		/* rlwinm. R10, R10, 0, 31, 31 */
		/* 821C01C4h case    5:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R10);
		/* 821C01C4h case    5:*/		return 0x821C01C8;
		  /* 821C01C8h */ case    6:  		/* bc 4, CR0_EQ, 28 */
		/* 821C01C8h case    6:*/		if ( !regs.CR[0].eq ) { return 0x821C01E4;  }
		/* 821C01C8h case    6:*/		return 0x821C01CC;
		  /* 821C01CCh */ case    7:  		/* addic R10, R9, -1 */
		/* 821C01CCh case    7:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R9,0xFFFFFFFF);
		/* 821C01CCh case    7:*/		return 0x821C01D0;
		  /* 821C01D0h */ case    8:  		/* subfe R10, R10, R10 */
		/* 821C01D0h case    8:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 821C01D0h case    8:*/		return 0x821C01D4;
		  /* 821C01D4h */ case    9:  		/* and R11, R10, R11 */
		/* 821C01D4h case    9:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821C01D4h case    9:*/		return 0x821C01D8;
		  /* 821C01D8h */ case   10:  		/* addi R10, R11, 24 */
		/* 821C01D8h case   10:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x18);
		/* 821C01D8h case   10:*/		return 0x821C01DC;
		  /* 821C01DCh */ case   11:  		/* lwz R9, <#[R11 + 28]> */
		/* 821C01DCh case   11:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x0000001C) );
		/* 821C01DCh case   11:*/		return 0x821C01E0;
		  /* 821C01E0h */ case   12:  		/* b 24 */
		/* 821C01E0h case   12:*/		return 0x821C01F8;
		/* 821C01E0h case   12:*/		return 0x821C01E4;
	}
	return 0x821C01E4;
} // Block from 821C01B0h-821C01E4h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821C01E4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C01E4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C01E4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C01E4);
		  /* 821C01E4h */ case    0:  		/* addic R10, R9, -1 */
		/* 821C01E4h case    0:*/		cpu::op::addic<0>(regs,&regs.R10,regs.R9,0xFFFFFFFF);
		/* 821C01E4h case    0:*/		return 0x821C01E8;
		  /* 821C01E8h */ case    1:  		/* subfe R10, R10, R10 */
		/* 821C01E8h case    1:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 821C01E8h case    1:*/		return 0x821C01EC;
		  /* 821C01ECh */ case    2:  		/* and R11, R10, R11 */
		/* 821C01ECh case    2:*/		cpu::op::and<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821C01ECh case    2:*/		return 0x821C01F0;
		  /* 821C01F0h */ case    3:  		/* addi R10, R11, 32 */
		/* 821C01F0h case    3:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R11,0x20);
		/* 821C01F0h case    3:*/		return 0x821C01F4;
		  /* 821C01F4h */ case    4:  		/* lwz R9, <#[R11 + 36]> */
		/* 821C01F4h case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000024) );
		/* 821C01F4h case    4:*/		return 0x821C01F8;
	}
	return 0x821C01F8;
} // Block from 821C01E4h-821C01F8h (5 instructions)

//////////////////////////////////////////////////////
// Block at 821C01F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C01F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C01F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C01F8);
		  /* 821C01F8h */ case    0:  		/* rlwinm. R11, R9, 0, 31, 31 */
		/* 821C01F8h case    0:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R9);
		/* 821C01F8h case    0:*/		return 0x821C01FC;
		  /* 821C01FCh */ case    1:  		/* bc 4, CR0_EQ, 12 */
		/* 821C01FCh case    1:*/		if ( !regs.CR[0].eq ) { return 0x821C0208;  }
		/* 821C01FCh case    1:*/		return 0x821C0200;
	}
	return 0x821C0200;
} // Block from 821C01F8h-821C0200h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821C0200h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C0200( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C0200) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C0200);
		  /* 821C0200h */ case    0:  		/* cmplwi CR6, R9, 0 */
		/* 821C0200h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 821C0200h case    0:*/		return 0x821C0204;
		  /* 821C0204h */ case    1:  		/* bc 4, CR6_EQ, -180 */
		/* 821C0204h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821C0150;  }
		/* 821C0204h case    1:*/		return 0x821C0208;
	}
	return 0x821C0208;
} // Block from 821C0200h-821C0208h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821C0208h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C0208( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C0208) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C0208);
		  /* 821C0208h */ case    0:  		/* addi R1, R1, 128 */
		/* 821C0208h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x80);
		/* 821C0208h case    0:*/		return 0x821C020C;
		  /* 821C020Ch */ case    1:  		/* b -1240928 */
		/* 821C020Ch case    1:*/		return 0x820912AC;
		/* 821C020Ch case    1:*/		return 0x821C0210;
	}
	return 0x821C0210;
} // Block from 821C0208h-821C0210h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821C0210h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C0210( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C0210) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C0210);
		  /* 821C0210h */ case    0:  		/* mfspr R12, LR */
		/* 821C0210h case    0:*/		regs.R12 = regs.LR;
		/* 821C0210h case    0:*/		return 0x821C0214;
		  /* 821C0214h */ case    1:  		/* bl -1241044 */
		/* 821C0214h case    1:*/		regs.LR = 0x821C0218; return 0x82091240;
		/* 821C0214h case    1:*/		return 0x821C0218;
		  /* 821C0218h */ case    2:  		/* stwu R1, <#[R1 - 176]> */
		/* 821C0218h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF50) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF50);
		/* 821C0218h case    2:*/		return 0x821C021C;
		  /* 821C021Ch */ case    3:  		/* lwz R11, <#[R4 + 4]> */
		/* 821C021Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000004) );
		/* 821C021Ch case    3:*/		return 0x821C0220;
		  /* 821C0220h */ case    4:  		/* mr R25, R3 */
		/* 821C0220h case    4:*/		regs.R25 = regs.R3;
		/* 821C0220h case    4:*/		return 0x821C0224;
		  /* 821C0224h */ case    5:  		/* mr R22, R4 */
		/* 821C0224h case    5:*/		regs.R22 = regs.R4;
		/* 821C0224h case    5:*/		return 0x821C0228;
		  /* 821C0228h */ case    6:  		/* mr R23, R5 */
		/* 821C0228h case    6:*/		regs.R23 = regs.R5;
		/* 821C0228h case    6:*/		return 0x821C022C;
		  /* 821C022Ch */ case    7:  		/* li R24, 1 */
		/* 821C022Ch case    7:*/		cpu::op::li<0>(regs,&regs.R24,0x1);
		/* 821C022Ch case    7:*/		return 0x821C0230;
		  /* 821C0230h */ case    8:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821C0230h case    8:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821C0230h case    8:*/		return 0x821C0234;
		  /* 821C0234h */ case    9:  		/* bc 4, CR0_EQ, 596 */
		/* 821C0234h case    9:*/		if ( !regs.CR[0].eq ) { return 0x821C0488;  }
		/* 821C0234h case    9:*/		return 0x821C0238;
		  /* 821C0238h */ case   10:  		/* mr R26, R11 */
		/* 821C0238h case   10:*/		regs.R26 = regs.R11;
		/* 821C0238h case   10:*/		return 0x821C023C;
		  /* 821C023Ch */ case   11:  		/* cmplwi CR0, R11, 0 */
		/* 821C023Ch case   11:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821C023Ch case   11:*/		return 0x821C0240;
		  /* 821C0240h */ case   12:  		/* bc 12, CR0_EQ, 584 */
		/* 821C0240h case   12:*/		if ( regs.CR[0].eq ) { return 0x821C0488;  }
		/* 821C0240h case   12:*/		return 0x821C0244;
		  /* 821C0244h */ case   13:  		/* lwz R11, <#[R23 + 4]> */
		/* 821C0244h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 821C0244h case   13:*/		return 0x821C0248;
		  /* 821C0248h */ case   14:  		/* rlwinm R10, R11, 0, 31, 31 */
		/* 821C0248h case   14:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821C0248h case   14:*/		return 0x821C024C;
		  /* 821C024Ch */ case   15:  		/* addic R9, R10, -1 */
		/* 821C024Ch case   15:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R10,0xFFFFFFFF);
		/* 821C024Ch case   15:*/		return 0x821C0250;
		  /* 821C0250h */ case   16:  		/* cmplwi CR6, R10, 0 */
		/* 821C0250h case   16:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821C0250h case   16:*/		return 0x821C0254;
		  /* 821C0254h */ case   17:  		/* subfe R10, R9, R9 */
		/* 821C0254h case   17:*/		cpu::op::subfe<0>(regs,&regs.R10,regs.R9,regs.R9);
		/* 821C0254h case   17:*/		return 0x821C0258;
		  /* 821C0258h */ case   18:  		/* and R24, R10, R24 */
		/* 821C0258h case   18:*/		cpu::op::and<0>(regs,&regs.R24,regs.R10,regs.R24);
		/* 821C0258h case   18:*/		return 0x821C025C;
		  /* 821C025Ch */ case   19:  		/* bc 4, CR6_EQ, 528 */
		/* 821C025Ch case   19:*/		if ( !regs.CR[6].eq ) { return 0x821C046C;  }
		/* 821C025Ch case   19:*/		return 0x821C0260;
		  /* 821C0260h */ case   20:  		/* mr R27, R11 */
		/* 821C0260h case   20:*/		regs.R27 = regs.R11;
		/* 821C0260h case   20:*/		return 0x821C0264;
		  /* 821C0264h */ case   21:  		/* cmplwi CR0, R11, 0 */
		/* 821C0264h case   21:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821C0264h case   21:*/		return 0x821C0268;
		  /* 821C0268h */ case   22:  		/* bc 12, CR0_EQ, 516 */
		/* 821C0268h case   22:*/		if ( regs.CR[0].eq ) { return 0x821C046C;  }
		/* 821C0268h case   22:*/		return 0x821C026C;
		  /* 821C026Ch */ case   23:  		/* lwz R10, <#[R27 + 8]> */
		/* 821C026Ch case   23:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x00000008) );
		/* 821C026Ch case   23:*/		return 0x821C0270;
		  /* 821C0270h */ case   24:  		/* rlwinm. R11, R10, 0, 2, 2 */
		/* 821C0270h case   24:*/		cpu::op::rlwinm<1,0,2,2>(regs,&regs.R11,regs.R10);
		/* 821C0270h case   24:*/		return 0x821C0274;
		  /* 821C0274h */ case   25:  		/* bc 4, CR0_EQ, 432 */
		/* 821C0274h case   25:*/		if ( !regs.CR[0].eq ) { return 0x821C0424;  }
		/* 821C0274h case   25:*/		return 0x821C0278;
		  /* 821C0278h */ case   26:  		/* lwz R11, <#[R26 + 8]> */
		/* 821C0278h case   26:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 821C0278h case   26:*/		return 0x821C027C;
		  /* 821C027Ch */ case   27:  		/* rlwinm R8, R10, 25, 25, 31 */
		/* 821C027Ch case   27:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R8,regs.R10);
		/* 821C027Ch case   27:*/		return 0x821C0280;
		  /* 821C0280h */ case   28:  		/* rlwinm R9, R11, 25, 25, 31 */
		/* 821C0280h case   28:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R9,regs.R11);
		/* 821C0280h case   28:*/		return 0x821C0284;
		  /* 821C0284h */ case   29:  		/* cmplw CR6, R9, R8 */
		/* 821C0284h case   29:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 821C0284h case   29:*/		return 0x821C0288;
		  /* 821C0288h */ case   30:  		/* bc 4, CR6_EQ, 412 */
		/* 821C0288h case   30:*/		if ( !regs.CR[6].eq ) { return 0x821C0424;  }
		/* 821C0288h case   30:*/		return 0x821C028C;
		  /* 821C028Ch */ case   31:  		/* rlwinm R8, R11, 7, 25, 31 */
		/* 821C028Ch case   31:*/		cpu::op::rlwinm<0,7,25,31>(regs,&regs.R8,regs.R11);
		/* 821C028Ch case   31:*/		return 0x821C0290;
		  /* 821C0290h */ case   32:  		/* rlwinm R7, R10, 7, 25, 31 */
		/* 821C0290h case   32:*/		cpu::op::rlwinm<0,7,25,31>(regs,&regs.R7,regs.R10);
		/* 821C0290h case   32:*/		return 0x821C0294;
		  /* 821C0294h */ case   33:  		/* xor R8, R8, R7 */
		/* 821C0294h case   33:*/		cpu::op::xor<0>(regs,&regs.R8,regs.R8,regs.R7);
		/* 821C0294h case   33:*/		return 0x821C0298;
		  /* 821C0298h */ case   34:  		/* rlwinm. R8, R8, 0, 31, 31 */
		/* 821C0298h case   34:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R8,regs.R8);
		/* 821C0298h case   34:*/		return 0x821C029C;
		  /* 821C029Ch */ case   35:  		/* bc 4, CR0_EQ, 392 */
		/* 821C029Ch case   35:*/		if ( !regs.CR[0].eq ) { return 0x821C0424;  }
		/* 821C029Ch case   35:*/		return 0x821C02A0;
		  /* 821C02A0h */ case   36:  		/* rlwinm R31, R11, 27, 31, 31 */
		/* 821C02A0h case   36:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R31,regs.R11);
		/* 821C02A0h case   36:*/		return 0x821C02A4;
		  /* 821C02A4h */ case   37:  		/* rlwinm R8, R10, 27, 31, 31 */
		/* 821C02A4h case   37:*/		cpu::op::rlwinm<0,27,31,31>(regs,&regs.R8,regs.R10);
		/* 821C02A4h case   37:*/		return 0x821C02A8;
		  /* 821C02A8h */ case   38:  		/* cmplw CR6, R31, R8 */
		/* 821C02A8h case   38:*/		cpu::op::cmplw<6>(regs,regs.R31,regs.R8);
		/* 821C02A8h case   38:*/		return 0x821C02AC;
		  /* 821C02ACh */ case   39:  		/* bc 4, CR6_EQ, 376 */
		/* 821C02ACh case   39:*/		if ( !regs.CR[6].eq ) { return 0x821C0424;  }
		/* 821C02ACh case   39:*/		return 0x821C02B0;
		  /* 821C02B0h */ case   40:  		/* xor R11, R11, R10 */
		/* 821C02B0h case   40:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821C02B0h case   40:*/		return 0x821C02B4;
		  /* 821C02B4h */ case   41:  		/* rlwinm. R11, R11, 0, 10, 12 */
		/* 821C02B4h case   41:*/		cpu::op::rlwinm<1,0,10,12>(regs,&regs.R11,regs.R11);
		/* 821C02B4h case   41:*/		return 0x821C02B8;
		  /* 821C02B8h */ case   42:  		/* bc 4, CR0_EQ, 364 */
		/* 821C02B8h case   42:*/		if ( !regs.CR[0].eq ) { return 0x821C0424;  }
		/* 821C02B8h case   42:*/		return 0x821C02BC;
		  /* 821C02BCh */ case   43:  		/* lwz R11, <#[R27 + 20]> */
		/* 821C02BCh case   43:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000014) );
		/* 821C02BCh case   43:*/		return 0x821C02C0;
		  /* 821C02C0h */ case   44:  		/* lwz R10, <#[R26 + 20]> */
		/* 821C02C0h case   44:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000014) );
		/* 821C02C0h case   44:*/		return 0x821C02C4;
		  /* 821C02C4h */ case   45:  		/* xor R11, R11, R10 */
		/* 821C02C4h case   45:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821C02C4h case   45:*/		return 0x821C02C8;
		  /* 821C02C8h */ case   46:  		/* rlwinm. R11, R11, 0, 31, 31 */
		/* 821C02C8h case   46:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R11,regs.R11);
		/* 821C02C8h case   46:*/		return 0x821C02CC;
		  /* 821C02CCh */ case   47:  		/* bc 4, CR0_EQ, 344 */
		/* 821C02CCh case   47:*/		if ( !regs.CR[0].eq ) { return 0x821C0424;  }
		/* 821C02CCh case   47:*/		return 0x821C02D0;
		  /* 821C02D0h */ case   48:  		/* cmplwi CR6, R9, 117 */
		/* 821C02D0h case   48:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000075);
		/* 821C02D0h case   48:*/		return 0x821C02D4;
		  /* 821C02D4h */ case   49:  		/* bc 4, CR6_EQ, 56 */
		/* 821C02D4h case   49:*/		if ( !regs.CR[6].eq ) { return 0x821C030C;  }
		/* 821C02D4h case   49:*/		return 0x821C02D8;
		  /* 821C02D8h */ case   50:  		/* li R6, 0 */
		/* 821C02D8h case   50:*/		cpu::op::li<0>(regs,&regs.R6,0x0);
		/* 821C02D8h case   50:*/		return 0x821C02DC;
		  /* 821C02DCh */ case   51:  		/* li R5, 0 */
		/* 821C02DCh case   51:*/		cpu::op::li<0>(regs,&regs.R5,0x0);
		/* 821C02DCh case   51:*/		return 0x821C02E0;
		  /* 821C02E0h */ case   52:  		/* li R4, 117 */
		/* 821C02E0h case   52:*/		cpu::op::li<0>(regs,&regs.R4,0x75);
		/* 821C02E0h case   52:*/		return 0x821C02E4;
		  /* 821C02E4h */ case   53:  		/* mr R3, R25 */
		/* 821C02E4h case   53:*/		regs.R3 = regs.R25;
		/* 821C02E4h case   53:*/		return 0x821C02E8;
		  /* 821C02E8h */ case   54:  		/* bl -376504 */
		/* 821C02E8h case   54:*/		regs.LR = 0x821C02EC; return 0x82164430;
		/* 821C02E8h case   54:*/		return 0x821C02EC;
		  /* 821C02ECh */ case   55:  		/* add R11, R3, R26 */
		/* 821C02ECh case   55:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R26);
		/* 821C02ECh case   55:*/		return 0x821C02F0;
		  /* 821C02F0h */ case   56:  		/* lwz R11, <#[R11 - 16]> */
		/* 821C02F0h case   56:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFFFFF0) );
		/* 821C02F0h case   56:*/		return 0x821C02F4;
		  /* 821C02F4h */ case   57:  		/* rlwinm. R11, R11, 0, 29, 31 */
		/* 821C02F4h case   57:*/		cpu::op::rlwinm<1,0,29,31>(regs,&regs.R11,regs.R11);
		/* 821C02F4h case   57:*/		return 0x821C02F8;
		  /* 821C02F8h */ case   58:  		/* bc 4, CR0_EQ, 332 */
		/* 821C02F8h case   58:*/		if ( !regs.CR[0].eq ) { return 0x821C0444;  }
		/* 821C02F8h case   58:*/		return 0x821C02FC;
		  /* 821C02FCh */ case   59:  		/* add R11, R3, R27 */
		/* 821C02FCh case   59:*/		cpu::op::add<0>(regs,&regs.R11,regs.R3,regs.R27);
		/* 821C02FCh case   59:*/		return 0x821C0300;
		  /* 821C0300h */ case   60:  		/* lwz R11, <#[R11 - 16]> */
		/* 821C0300h case   60:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0xFFFFFFF0) );
		/* 821C0300h case   60:*/		return 0x821C0304;
		  /* 821C0304h */ case   61:  		/* rlwinm. R11, R11, 0, 29, 31 */
		/* 821C0304h case   61:*/		cpu::op::rlwinm<1,0,29,31>(regs,&regs.R11,regs.R11);
		/* 821C0304h case   61:*/		return 0x821C0308;
		  /* 821C0308h */ case   62:  		/* bc 4, CR0_EQ, 316 */
		/* 821C0308h case   62:*/		if ( !regs.CR[0].eq ) { return 0x821C0444;  }
		/* 821C0308h case   62:*/		return 0x821C030C;
	}
	return 0x821C030C;
} // Block from 821C0210h-821C030Ch (63 instructions)

//////////////////////////////////////////////////////
// Block at 821C030Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C030C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C030C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C030C);
		  /* 821C030Ch */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 821C030Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821C030Ch case    0:*/		return 0x821C0310;
		  /* 821C0310h */ case    1:  		/* bc 12, CR6_EQ, 128 */
		/* 821C0310h case    1:*/		if ( regs.CR[6].eq ) { return 0x821C0390;  }
		/* 821C0310h case    1:*/		return 0x821C0314;
		  /* 821C0314h */ case    2:  		/* lwz R10, <#[R26 + 4]> */
		/* 821C0314h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000004) );
		/* 821C0314h case    2:*/		return 0x821C0318;
		  /* 821C0318h */ case    3:  		/* cmplwi CR6, R10, 0 */
		/* 821C0318h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821C0318h case    3:*/		return 0x821C031C;
		  /* 821C031Ch */ case    4:  		/* bc 12, CR6_EQ, 36 */
		/* 821C031Ch case    4:*/		if ( regs.CR[6].eq ) { return 0x821C0340;  }
		/* 821C031Ch case    4:*/		return 0x821C0320;
		  /* 821C0320h */ case    5:  		/* lwz R11, <#[R10 + 16]> */
		/* 821C0320h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000010) );
		/* 821C0320h case    5:*/		return 0x821C0324;
		  /* 821C0324h */ case    6:  		/* cmplwi CR6, R11, 0 */
		/* 821C0324h case    6:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821C0324h case    6:*/		return 0x821C0328;
		  /* 821C0328h */ case    7:  		/* bc 12, CR6_EQ, 16 */
		/* 821C0328h case    7:*/		if ( regs.CR[6].eq ) { return 0x821C0338;  }
		/* 821C0328h case    7:*/		return 0x821C032C;
		  /* 821C032Ch */ case    8:  		/* lwz R11, <#[R10]> */
		/* 821C032Ch case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000000) );
		/* 821C032Ch case    8:*/		return 0x821C0330;
		  /* 821C0330h */ case    9:  		/* rlwinm. R11, R11, 0, 4, 6 */
		/* 821C0330h case    9:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R11,regs.R11);
		/* 821C0330h case    9:*/		return 0x821C0334;
		  /* 821C0334h */ case   10:  		/* bc 4, CR0_EQ, 12 */
		/* 821C0334h case   10:*/		if ( !regs.CR[0].eq ) { return 0x821C0340;  }
		/* 821C0334h case   10:*/		return 0x821C0338;
	}
	return 0x821C0338;
} // Block from 821C030Ch-821C0338h (11 instructions)

//////////////////////////////////////////////////////
// Block at 821C0338h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C0338( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C0338) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C0338);
		  /* 821C0338h */ case    0:  		/* lwz R10, <#[R10 + 8]> */
		/* 821C0338h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 821C0338h case    0:*/		return 0x821C033C;
		  /* 821C033Ch */ case    1:  		/* b -36 */
		/* 821C033Ch case    1:*/		return 0x821C0318;
		/* 821C033Ch case    1:*/		return 0x821C0340;
	}
	return 0x821C0340;
} // Block from 821C0338h-821C0340h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821C0340h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C0340( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C0340) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C0340);
		  /* 821C0340h */ case    0:  		/* lwz R11, <#[R27 + 4]> */
		/* 821C0340h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000004) );
		/* 821C0340h case    0:*/		return 0x821C0344;
		  /* 821C0344h */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 821C0344h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821C0344h case    1:*/		return 0x821C0348;
		  /* 821C0348h */ case    2:  		/* bc 12, CR6_EQ, 36 */
		/* 821C0348h case    2:*/		if ( regs.CR[6].eq ) { return 0x821C036C;  }
		/* 821C0348h case    2:*/		return 0x821C034C;
		  /* 821C034Ch */ case    3:  		/* lwz R9, <#[R11 + 16]> */
		/* 821C034Ch case    3:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000010) );
		/* 821C034Ch case    3:*/		return 0x821C0350;
		  /* 821C0350h */ case    4:  		/* cmplwi CR6, R9, 0 */
		/* 821C0350h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R9,0x00000000);
		/* 821C0350h case    4:*/		return 0x821C0354;
		  /* 821C0354h */ case    5:  		/* bc 12, CR6_EQ, 16 */
		/* 821C0354h case    5:*/		if ( regs.CR[6].eq ) { return 0x821C0364;  }
		/* 821C0354h case    5:*/		return 0x821C0358;
		  /* 821C0358h */ case    6:  		/* lwz R9, <#[R11]> */
		/* 821C0358h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R11 + 0x00000000) );
		/* 821C0358h case    6:*/		return 0x821C035C;
		  /* 821C035Ch */ case    7:  		/* rlwinm. R9, R9, 0, 4, 6 */
		/* 821C035Ch case    7:*/		cpu::op::rlwinm<1,0,4,6>(regs,&regs.R9,regs.R9);
		/* 821C035Ch case    7:*/		return 0x821C0360;
		  /* 821C0360h */ case    8:  		/* bc 4, CR0_EQ, 12 */
		/* 821C0360h case    8:*/		if ( !regs.CR[0].eq ) { return 0x821C036C;  }
		/* 821C0360h case    8:*/		return 0x821C0364;
	}
	return 0x821C0364;
} // Block from 821C0340h-821C0364h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821C0364h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C0364( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C0364) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C0364);
		  /* 821C0364h */ case    0:  		/* lwz R11, <#[R11 + 8]> */
		/* 821C0364h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821C0364h case    0:*/		return 0x821C0368;
		  /* 821C0368h */ case    1:  		/* b -36 */
		/* 821C0368h case    1:*/		return 0x821C0344;
		/* 821C0368h case    1:*/		return 0x821C036C;
	}
	return 0x821C036C;
} // Block from 821C0364h-821C036Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 821C036Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C036C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C036C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C036C);
		  /* 821C036Ch */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 821C036Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821C036Ch case    0:*/		return 0x821C0370;
		  /* 821C0370h */ case    1:  		/* bc 12, CR6_EQ, 376 */
		/* 821C0370h case    1:*/		if ( regs.CR[6].eq ) { return 0x821C04E8;  }
		/* 821C0370h case    1:*/		return 0x821C0374;
		  /* 821C0374h */ case    2:  		/* cmplwi CR6, R11, 0 */
		/* 821C0374h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821C0374h case    2:*/		return 0x821C0378;
		  /* 821C0378h */ case    3:  		/* bc 12, CR6_EQ, 368 */
		/* 821C0378h case    3:*/		if ( regs.CR[6].eq ) { return 0x821C04E8;  }
		/* 821C0378h case    3:*/		return 0x821C037C;
		  /* 821C037Ch */ case    4:  		/* lwz R11, <#[R11]> */
		/* 821C037Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000000) );
		/* 821C037Ch case    4:*/		return 0x821C0380;
		  /* 821C0380h */ case    5:  		/* lwz R10, <#[R10]> */
		/* 821C0380h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821C0380h case    5:*/		return 0x821C0384;
		  /* 821C0384h */ case    6:  		/* xor R11, R11, R10 */
		/* 821C0384h case    6:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821C0384h case    6:*/		return 0x821C0388;
		  /* 821C0388h */ case    7:  		/* rlwinm. R11, R11, 0, 7, 18 */
		/* 821C0388h case    7:*/		cpu::op::rlwinm<1,0,7,18>(regs,&regs.R11,regs.R11);
		/* 821C0388h case    7:*/		return 0x821C038C;
		  /* 821C038Ch */ case    8:  		/* bc 4, CR0_EQ, 152 */
		/* 821C038Ch case    8:*/		if ( !regs.CR[0].eq ) { return 0x821C0424;  }
		/* 821C038Ch case    8:*/		return 0x821C0390;
	}
	return 0x821C0390;
} // Block from 821C036Ch-821C0390h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821C0390h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C0390( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C0390) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C0390);
		  /* 821C0390h */ case    0:  		/* li R29, 0 */
		/* 821C0390h case    0:*/		cpu::op::li<0>(regs,&regs.R29,0x0);
		/* 821C0390h case    0:*/		return 0x821C0394;
		  /* 821C0394h */ case    1:  		/* addi R31, R27, 44 */
		/* 821C0394h case    1:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R27,0x2C);
		/* 821C0394h case    1:*/		return 0x821C0398;
		  /* 821C0398h */ case    2:  		/* subf R28, R27, R26 */
		/* 821C0398h case    2:*/		cpu::op::subf<0>(regs,&regs.R28,regs.R27,regs.R26);
		/* 821C0398h case    2:*/		return 0x821C039C;
		  /* 821C039Ch */ case    3:  		/* lwz R11, <#[R26 + 8]> */
		/* 821C039Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 821C039Ch case    3:*/		return 0x821C03A0;
		  /* 821C03A0h */ case    4:  		/* rlwinm R11, R11, 13, 29, 31 */
		/* 821C03A0h case    4:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R11,regs.R11);
		/* 821C03A0h case    4:*/		return 0x821C03A4;
		  /* 821C03A4h */ case    5:  		/* cmplw CR6, R29, R11 */
		/* 821C03A4h case    5:*/		cpu::op::cmplw<6>(regs,regs.R29,regs.R11);
		/* 821C03A4h case    5:*/		return 0x821C03A8;
		  /* 821C03A8h */ case    6:  		/* bc 4, CR6_LT, 56 */
		/* 821C03A8h case    6:*/		if ( !regs.CR[6].lt ) { return 0x821C03E0;  }
		/* 821C03A8h case    6:*/		return 0x821C03AC;
		  /* 821C03ACh */ case    7:  		/* lwzx R30, <#[R28 + R31]> */
		/* 821C03ACh case    7:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R28 + regs.R31 + 0x00000000) );
		/* 821C03ACh case    7:*/		return 0x821C03B0;
		  /* 821C03B0h */ case    8:  		/* mr R3, R25 */
		/* 821C03B0h case    8:*/		regs.R3 = regs.R25;
		/* 821C03B0h case    8:*/		return 0x821C03B4;
		  /* 821C03B4h */ case    9:  		/* lwz R5, <#[R31]> */
		/* 821C03B4h case    9:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R31 + 0x00000000) );
		/* 821C03B4h case    9:*/		return 0x821C03B8;
		  /* 821C03B8h */ case   10:  		/* mr R4, R30 */
		/* 821C03B8h case   10:*/		regs.R4 = regs.R30;
		/* 821C03B8h case   10:*/		return 0x821C03BC;
		  /* 821C03BCh */ case   11:  		/* bl -12084 */
		/* 821C03BCh case   11:*/		regs.LR = 0x821C03C0; return 0x821BD488;
		/* 821C03BCh case   11:*/		return 0x821C03C0;
		  /* 821C03C0h */ case   12:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821C03C0h case   12:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821C03C0h case   12:*/		return 0x821C03C4;
		  /* 821C03C4h */ case   13:  		/* bc 12, CR0_EQ, 16 */
		/* 821C03C4h case   13:*/		if ( regs.CR[0].eq ) { return 0x821C03D4;  }
		/* 821C03C4h case   13:*/		return 0x821C03C8;
		  /* 821C03C8h */ case   14:  		/* addi R29, R29, 1 */
		/* 821C03C8h case   14:*/		cpu::op::addi<0>(regs,&regs.R29,regs.R29,0x1);
		/* 821C03C8h case   14:*/		return 0x821C03CC;
		  /* 821C03CCh */ case   15:  		/* addi R31, R31, 4 */
		/* 821C03CCh case   15:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R31,0x4);
		/* 821C03CCh case   15:*/		return 0x821C03D0;
		  /* 821C03D0h */ case   16:  		/* b -52 */
		/* 821C03D0h case   16:*/		return 0x821C039C;
		/* 821C03D0h case   16:*/		return 0x821C03D4;
	}
	return 0x821C03D4;
} // Block from 821C0390h-821C03D4h (17 instructions)

//////////////////////////////////////////////////////
// Block at 821C03D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C03D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C03D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C03D4);
		  /* 821C03D4h */ case    0:  		/* li R24, 0 */
		/* 821C03D4h case    0:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 821C03D4h case    0:*/		return 0x821C03D8;
		  /* 821C03D8h */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 821C03D8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821C03D8h case    1:*/		return 0x821C03DC;
		  /* 821C03DCh */ case    2:  		/* bc 4, CR6_EQ, 72 */
		/* 821C03DCh case    2:*/		if ( !regs.CR[6].eq ) { return 0x821C0424;  }
		/* 821C03DCh case    2:*/		return 0x821C03E0;
	}
	return 0x821C03E0;
} // Block from 821C03D4h-821C03E0h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821C03E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C03E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C03E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C03E0);
		  /* 821C03E0h */ case    0:  		/* lwz R30, <#[R26]> */
		/* 821C03E0h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R26 + 0x00000000) );
		/* 821C03E0h case    0:*/		return 0x821C03E4;
		  /* 821C03E4h */ case    1:  		/* cmplwi CR6, R30, 0 */
		/* 821C03E4h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R30,0x00000000);
		/* 821C03E4h case    1:*/		return 0x821C03E8;
		  /* 821C03E8h */ case    2:  		/* bc 12, CR6_EQ, 100 */
		/* 821C03E8h case    2:*/		if ( regs.CR[6].eq ) { return 0x821C044C;  }
		/* 821C03E8h case    2:*/		return 0x821C03EC;
		  /* 821C03ECh */ case    3:  		/* lwz R31, <#[R27]> */
		/* 821C03ECh case    3:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R27 + 0x00000000) );
		/* 821C03ECh case    3:*/		return 0x821C03F0;
		  /* 821C03F0h */ case    4:  		/* cmplwi CR6, R31, 0 */
		/* 821C03F0h case    4:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821C03F0h case    4:*/		return 0x821C03F4;
		  /* 821C03F4h */ case    5:  		/* bc 12, CR6_EQ, 44 */
		/* 821C03F4h case    5:*/		if ( regs.CR[6].eq ) { return 0x821C0420;  }
		/* 821C03F4h case    5:*/		return 0x821C03F8;
		  /* 821C03F8h */ case    6:  		/* mr R5, R31 */
		/* 821C03F8h case    6:*/		regs.R5 = regs.R31;
		/* 821C03F8h case    6:*/		return 0x821C03FC;
		  /* 821C03FCh */ case    7:  		/* mr R4, R30 */
		/* 821C03FCh case    7:*/		regs.R4 = regs.R30;
		/* 821C03FCh case    7:*/		return 0x821C0400;
		  /* 821C0400h */ case    8:  		/* mr R3, R25 */
		/* 821C0400h case    8:*/		regs.R3 = regs.R25;
		/* 821C0400h case    8:*/		return 0x821C0404;
		  /* 821C0404h */ case    9:  		/* bl -12156 */
		/* 821C0404h case    9:*/		regs.LR = 0x821C0408; return 0x821BD488;
		/* 821C0404h case    9:*/		return 0x821C0408;
		  /* 821C0408h */ case   10:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821C0408h case   10:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821C0408h case   10:*/		return 0x821C040C;
		  /* 821C040Ch */ case   11:  		/* bc 4, CR0_EQ, 12 */
		/* 821C040Ch case   11:*/		if ( !regs.CR[0].eq ) { return 0x821C0418;  }
		/* 821C040Ch case   11:*/		return 0x821C0410;
		  /* 821C0410h */ case   12:  		/* lwz R31, <#[R31 + 4]> */
		/* 821C0410h case   12:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000004) );
		/* 821C0410h case   12:*/		return 0x821C0414;
		  /* 821C0414h */ case   13:  		/* b -36 */
		/* 821C0414h case   13:*/		return 0x821C03F0;
		/* 821C0414h case   13:*/		return 0x821C0418;
	}
	return 0x821C0418;
} // Block from 821C03E0h-821C0418h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821C0418h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C0418( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C0418) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C0418);
		  /* 821C0418h */ case    0:  		/* lwz R30, <#[R30 + 4]> */
		/* 821C0418h case    0:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R30 + 0x00000004) );
		/* 821C0418h case    0:*/		return 0x821C041C;
		  /* 821C041Ch */ case    1:  		/* b -56 */
		/* 821C041Ch case    1:*/		return 0x821C03E4;
		/* 821C041Ch case    1:*/		return 0x821C0420;
	}
	return 0x821C0420;
} // Block from 821C0418h-821C0420h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821C0420h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C0420( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C0420) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C0420);
		  /* 821C0420h */ case    0:  		/* li R24, 0 */
		/* 821C0420h case    0:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 821C0420h case    0:*/		return 0x821C0424;
	}
	return 0x821C0424;
} // Block from 821C0420h-821C0424h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821C0424h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C0424( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C0424) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C0424);
		  /* 821C0424h */ case    0:  		/* rlwinm R11, R27, 0, 0, 30 */
		/* 821C0424h case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R27);
		/* 821C0424h case    0:*/		return 0x821C0428;
		  /* 821C0428h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 821C0428h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 821C0428h case    1:*/		return 0x821C042C;
		  /* 821C042Ch */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821C042Ch case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821C042Ch case    2:*/		return 0x821C0430;
		  /* 821C0430h */ case    3:  		/* bc 4, CR0_EQ, 60 */
		/* 821C0430h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821C046C;  }
		/* 821C0430h case    3:*/		return 0x821C0434;
		  /* 821C0434h */ case    4:  		/* mr R27, R11 */
		/* 821C0434h case    4:*/		regs.R27 = regs.R11;
		/* 821C0434h case    4:*/		return 0x821C0438;
		  /* 821C0438h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821C0438h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821C0438h case    5:*/		return 0x821C043C;
		  /* 821C043Ch */ case    6:  		/* bc 4, CR6_EQ, -464 */
		/* 821C043Ch case    6:*/		if ( !regs.CR[6].eq ) { return 0x821C026C;  }
		/* 821C043Ch case    6:*/		return 0x821C0440;
		  /* 821C0440h */ case    7:  		/* b 44 */
		/* 821C0440h case    7:*/		return 0x821C046C;
		/* 821C0440h case    7:*/		return 0x821C0444;
	}
	return 0x821C0444;
} // Block from 821C0424h-821C0444h (8 instructions)

//////////////////////////////////////////////////////
// Block at 821C0444h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C0444( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C0444) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C0444);
		  /* 821C0444h */ case    0:  		/* li R24, 0 */
		/* 821C0444h case    0:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 821C0444h case    0:*/		return 0x821C0448;
		  /* 821C0448h */ case    1:  		/* b 36 */
		/* 821C0448h case    1:*/		return 0x821C046C;
		/* 821C0448h case    1:*/		return 0x821C044C;
	}
	return 0x821C044C;
} // Block from 821C0444h-821C044Ch (2 instructions)

//////////////////////////////////////////////////////
// Block at 821C044Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C044C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C044C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C044C);
		  /* 821C044Ch */ case    0:  		/* lwz R11, <#[R26 + 8]> */
		/* 821C044Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 821C044Ch case    0:*/		return 0x821C0450;
		  /* 821C0450h */ case    1:  		/* stw R27, <#[R26 + 32]> */
		/* 821C0450h case    1:*/		cpu::mem::store32( regs, regs.R27, (uint32)(regs.R26 + 0x00000020) );
		/* 821C0450h case    1:*/		return 0x821C0454;
		  /* 821C0454h */ case    2:  		/* oris R11, R11, 8192 */
		/* 821C0454h case    2:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x2000);
		/* 821C0454h case    2:*/		return 0x821C0458;
		  /* 821C0458h */ case    3:  		/* stw R11, <#[R26 + 8]> */
		/* 821C0458h case    3:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 821C0458h case    3:*/		return 0x821C045C;
		  /* 821C045Ch */ case    4:  		/* lwz R11, <#[R27 + 8]> */
		/* 821C045Ch case    4:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 821C045Ch case    4:*/		return 0x821C0460;
		  /* 821C0460h */ case    5:  		/* oris R11, R11, 8192 */
		/* 821C0460h case    5:*/		cpu::op::oris<0>(regs,&regs.R11,regs.R11,0x2000);
		/* 821C0460h case    5:*/		return 0x821C0464;
		  /* 821C0464h */ case    6:  		/* stw R26, <#[R27 + 32]> */
		/* 821C0464h case    6:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R27 + 0x00000020) );
		/* 821C0464h case    6:*/		return 0x821C0468;
		  /* 821C0468h */ case    7:  		/* stw R11, <#[R27 + 8]> */
		/* 821C0468h case    7:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R27 + 0x00000008) );
		/* 821C0468h case    7:*/		return 0x821C046C;
	}
	return 0x821C046C;
} // Block from 821C044Ch-821C046Ch (8 instructions)

//////////////////////////////////////////////////////
// Block at 821C046Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C046C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C046C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C046C);
		  /* 821C046Ch */ case    0:  		/* rlwinm R11, R26, 0, 0, 30 */
		/* 821C046Ch case    0:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R26);
		/* 821C046Ch case    0:*/		return 0x821C0470;
		  /* 821C0470h */ case    1:  		/* lwz R11, <#[R11 + 40]> */
		/* 821C0470h case    1:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 821C0470h case    1:*/		return 0x821C0474;
		  /* 821C0474h */ case    2:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821C0474h case    2:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821C0474h case    2:*/		return 0x821C0478;
		  /* 821C0478h */ case    3:  		/* bc 4, CR0_EQ, 16 */
		/* 821C0478h case    3:*/		if ( !regs.CR[0].eq ) { return 0x821C0488;  }
		/* 821C0478h case    3:*/		return 0x821C047C;
		  /* 821C047Ch */ case    4:  		/* mr R26, R11 */
		/* 821C047Ch case    4:*/		regs.R26 = regs.R11;
		/* 821C047Ch case    4:*/		return 0x821C0480;
		  /* 821C0480h */ case    5:  		/* cmplwi CR6, R11, 0 */
		/* 821C0480h case    5:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821C0480h case    5:*/		return 0x821C0484;
		  /* 821C0484h */ case    6:  		/* bc 4, CR6_EQ, -576 */
		/* 821C0484h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821C0244;  }
		/* 821C0484h case    6:*/		return 0x821C0488;
	}
	return 0x821C0488;
} // Block from 821C046Ch-821C0488h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821C0488h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C0488( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C0488) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C0488);
		  /* 821C0488h */ case    0:  		/* rlwinm. R11, R24, 0, 24, 31 */
		/* 821C0488h case    0:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R24);
		/* 821C0488h case    0:*/		return 0x821C048C;
		  /* 821C048Ch */ case    1:  		/* bc 12, CR0_EQ, 108 */
		/* 821C048Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x821C04F8;  }
		/* 821C048Ch case    1:*/		return 0x821C0490;
		  /* 821C0490h */ case    2:  		/* lwz R11, <#[R23 + 4]> */
		/* 821C0490h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R23 + 0x00000004) );
		/* 821C0490h case    2:*/		return 0x821C0494;
		  /* 821C0494h */ case    3:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821C0494h case    3:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821C0494h case    3:*/		return 0x821C0498;
		  /* 821C0498h */ case    4:  		/* bc 4, CR0_EQ, 24 */
		/* 821C0498h case    4:*/		if ( !regs.CR[0].eq ) { return 0x821C04B0;  }
		/* 821C0498h case    4:*/		return 0x821C049C;
		  /* 821C049Ch */ case    5:  		/* lwz R9, <#[R22 + 4]> */
		/* 821C049Ch case    5:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R22 + 0x00000004) );
		/* 821C049Ch case    5:*/		return 0x821C04A0;
		  /* 821C04A0h */ case    6:  		/* rlwinm R9, R9, 0, 31, 31 */
		/* 821C04A0h case    6:*/		cpu::op::rlwinm<0,0,31,31>(regs,&regs.R9,regs.R9);
		/* 821C04A0h case    6:*/		return 0x821C04A4;
		  /* 821C04A4h */ case    7:  		/* addic R9, R9, -1 */
		/* 821C04A4h case    7:*/		cpu::op::addic<0>(regs,&regs.R9,regs.R9,0xFFFFFFFF);
		/* 821C04A4h case    7:*/		return 0x821C04A8;
		  /* 821C04A8h */ case    8:  		/* subfe R9, R9, R9 */
		/* 821C04A8h case    8:*/		cpu::op::subfe<0>(regs,&regs.R9,regs.R9,regs.R9);
		/* 821C04A8h case    8:*/		return 0x821C04AC;
		  /* 821C04ACh */ case    9:  		/* and R24, R9, R24 */
		/* 821C04ACh case    9:*/		cpu::op::and<0>(regs,&regs.R24,regs.R9,regs.R24);
		/* 821C04ACh case    9:*/		return 0x821C04B0;
	}
	return 0x821C04B0;
} // Block from 821C0488h-821C04B0h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821C04B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C04B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C04B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C04B0);
		  /* 821C04B0h */ case    0:  		/* cmplwi CR6, R10, 0 */
		/* 821C04B0h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821C04B0h case    0:*/		return 0x821C04B4;
		  /* 821C04B4h */ case    1:  		/* bc 4, CR6_EQ, 68 */
		/* 821C04B4h case    1:*/		if ( !regs.CR[6].eq ) { return 0x821C04F8;  }
		/* 821C04B4h case    1:*/		return 0x821C04B8;
		  /* 821C04B8h */ case    2:  		/* cmplwi CR0, R11, 0 */
		/* 821C04B8h case    2:*/		cpu::op::cmplwi<0>(regs,regs.R11,0x00000000);
		/* 821C04B8h case    2:*/		return 0x821C04BC;
		  /* 821C04BCh */ case    3:  		/* bc 12, CR0_EQ, 60 */
		/* 821C04BCh case    3:*/		if ( regs.CR[0].eq ) { return 0x821C04F8;  }
		/* 821C04BCh case    3:*/		return 0x821C04C0;
		  /* 821C04C0h */ case    4:  		/* lwz R10, <#[R11 + 8]> */
		/* 821C04C0h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821C04C0h case    4:*/		return 0x821C04C4;
		  /* 821C04C4h */ case    5:  		/* rlwinm. R10, R10, 0, 2, 2 */
		/* 821C04C4h case    5:*/		cpu::op::rlwinm<1,0,2,2>(regs,&regs.R10,regs.R10);
		/* 821C04C4h case    5:*/		return 0x821C04C8;
		  /* 821C04C8h */ case    6:  		/* bc 12, CR0_EQ, 44 */
		/* 821C04C8h case    6:*/		if ( regs.CR[0].eq ) { return 0x821C04F4;  }
		/* 821C04C8h case    6:*/		return 0x821C04CC;
		  /* 821C04CCh */ case    7:  		/* rlwinm R11, R11, 0, 0, 30 */
		/* 821C04CCh case    7:*/		cpu::op::rlwinm<0,0,0,30>(regs,&regs.R11,regs.R11);
		/* 821C04CCh case    7:*/		return 0x821C04D0;
		  /* 821C04D0h */ case    8:  		/* lwz R11, <#[R11 + 40]> */
		/* 821C04D0h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000028) );
		/* 821C04D0h case    8:*/		return 0x821C04D4;
		  /* 821C04D4h */ case    9:  		/* rlwinm. R10, R11, 0, 31, 31 */
		/* 821C04D4h case    9:*/		cpu::op::rlwinm<1,0,31,31>(regs,&regs.R10,regs.R11);
		/* 821C04D4h case    9:*/		return 0x821C04D8;
		  /* 821C04D8h */ case   10:  		/* bc 4, CR0_EQ, 32 */
		/* 821C04D8h case   10:*/		if ( !regs.CR[0].eq ) { return 0x821C04F8;  }
		/* 821C04D8h case   10:*/		return 0x821C04DC;
		  /* 821C04DCh */ case   11:  		/* cmplwi CR6, R11, 0 */
		/* 821C04DCh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821C04DCh case   11:*/		return 0x821C04E0;
		  /* 821C04E0h */ case   12:  		/* bc 4, CR6_EQ, -32 */
		/* 821C04E0h case   12:*/		if ( !regs.CR[6].eq ) { return 0x821C04C0;  }
		/* 821C04E0h case   12:*/		return 0x821C04E4;
		  /* 821C04E4h */ case   13:  		/* b 20 */
		/* 821C04E4h case   13:*/		return 0x821C04F8;
		/* 821C04E4h case   13:*/		return 0x821C04E8;
	}
	return 0x821C04E8;
} // Block from 821C04B0h-821C04E8h (14 instructions)

//////////////////////////////////////////////////////
// Block at 821C04E8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C04E8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C04E8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C04E8);
		  /* 821C04E8h */ case    0:  		/* li R4, 4800 */
		/* 821C04E8h case    0:*/		cpu::op::li<0>(regs,&regs.R4,0x12C0);
		/* 821C04E8h case    0:*/		return 0x821C04EC;
		  /* 821C04ECh */ case    1:  		/* mr R3, R25 */
		/* 821C04ECh case    1:*/		regs.R3 = regs.R25;
		/* 821C04ECh case    1:*/		return 0x821C04F0;
		  /* 821C04F0h */ case    2:  		/* bl -452232 */
		/* 821C04F0h case    2:*/		regs.LR = 0x821C04F4; return 0x82151E68;
		/* 821C04F0h case    2:*/		return 0x821C04F4;
	}
	return 0x821C04F4;
} // Block from 821C04E8h-821C04F4h (3 instructions)

//////////////////////////////////////////////////////
// Block at 821C04F4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C04F4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C04F4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C04F4);
		  /* 821C04F4h */ case    0:  		/* li R24, 0 */
		/* 821C04F4h case    0:*/		cpu::op::li<0>(regs,&regs.R24,0x0);
		/* 821C04F4h case    0:*/		return 0x821C04F8;
	}
	return 0x821C04F8;
} // Block from 821C04F4h-821C04F8h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821C04F8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C04F8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C04F8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C04F8);
		  /* 821C04F8h */ case    0:  		/* mr R3, R24 */
		/* 821C04F8h case    0:*/		regs.R3 = regs.R24;
		/* 821C04F8h case    0:*/		return 0x821C04FC;
		  /* 821C04FCh */ case    1:  		/* addi R1, R1, 176 */
		/* 821C04FCh case    1:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xB0);
		/* 821C04FCh case    1:*/		return 0x821C0500;
		  /* 821C0500h */ case    2:  		/* b -1241712 */
		/* 821C0500h case    2:*/		return 0x82091290;
		/* 821C0500h case    2:*/		return 0x821C0504;
		  /* 821C0504h */ case    3:  		/* nop */
		/* 821C0504h case    3:*/		cpu::op::nop();
		/* 821C0504h case    3:*/		return 0x821C0508;
	}
	return 0x821C0508;
} // Block from 821C04F8h-821C0508h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821C0508h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C0508( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C0508) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C0508);
		  /* 821C0508h */ case    0:  		/* mfspr R12, LR */
		/* 821C0508h case    0:*/		regs.R12 = regs.LR;
		/* 821C0508h case    0:*/		return 0x821C050C;
		  /* 821C050Ch */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821C050Ch case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821C050Ch case    1:*/		return 0x821C0510;
		  /* 821C0510h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 821C0510h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821C0510h case    2:*/		return 0x821C0514;
		  /* 821C0514h */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 821C0514h case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821C0514h case    3:*/		return 0x821C0518;
		  /* 821C0518h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 821C0518h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821C0518h case    4:*/		return 0x821C051C;
		  /* 821C051Ch */ case    5:  		/* mr R3, R4 */
		/* 821C051Ch case    5:*/		regs.R3 = regs.R4;
		/* 821C051Ch case    5:*/		return 0x821C0520;
		  /* 821C0520h */ case    6:  		/* mr R31, R7 */
		/* 821C0520h case    6:*/		regs.R31 = regs.R7;
		/* 821C0520h case    6:*/		return 0x821C0524;
		  /* 821C0524h */ case    7:  		/* mr R30, R10 */
		/* 821C0524h case    7:*/		regs.R30 = regs.R10;
		/* 821C0524h case    7:*/		return 0x821C0528;
		  /* 821C0528h */ case    8:  		/* rlwinm. R11, R9, 0, 27, 28 */
		/* 821C0528h case    8:*/		cpu::op::rlwinm<1,0,27,28>(regs,&regs.R11,regs.R9);
		/* 821C0528h case    8:*/		return 0x821C052C;
		  /* 821C052Ch */ case    9:  		/* bc 12, CR0_EQ, 48 */
		/* 821C052Ch case    9:*/		if ( regs.CR[0].eq ) { return 0x821C055C;  }
		/* 821C052Ch case    9:*/		return 0x821C0530;
		  /* 821C0530h */ case   10:  		/* lwz R11, <#[R4 + 28]> */
		/* 821C0530h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000001C) );
		/* 821C0530h case   10:*/		return 0x821C0534;
		  /* 821C0534h */ case   11:  		/* lwz R10, <#[R7 + 28]> */
		/* 821C0534h case   11:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R7 + 0x0000001C) );
		/* 821C0534h case   11:*/		return 0x821C0538;
		  /* 821C0538h */ case   12:  		/* cmpw CR6, R10, R11 */
		/* 821C0538h case   12:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R11);
		/* 821C0538h case   12:*/		return 0x821C053C;
		  /* 821C053Ch */ case   13:  		/* bc 12, CR6_EQ, 12 */
		/* 821C053Ch case   13:*/		if ( regs.CR[6].eq ) { return 0x821C0548;  }
		/* 821C053Ch case   13:*/		return 0x821C0540;
		  /* 821C0540h */ case   14:  		/* li R3, 0 */
		/* 821C0540h case   14:*/		cpu::op::li<0>(regs,&regs.R3,0x0);
		/* 821C0540h case   14:*/		return 0x821C0544;
		  /* 821C0544h */ case   15:  		/* b 144 */
		/* 821C0544h case   15:*/		return 0x821C05D4;
		/* 821C0544h case   15:*/		return 0x821C0548;
	}
	return 0x821C0548;
} // Block from 821C0508h-821C0548h (16 instructions)

//////////////////////////////////////////////////////
// Block at 821C0548h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C0548( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C0548) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C0548);
		  /* 821C0548h */ case    0:  		/* rlwinm. R10, R9, 0, 27, 27 */
		/* 821C0548h case    0:*/		cpu::op::rlwinm<1,0,27,27>(regs,&regs.R10,regs.R9);
		/* 821C0548h case    0:*/		return 0x821C054C;
		  /* 821C054Ch */ case    1:  		/* bc 12, CR0_EQ, 16 */
		/* 821C054Ch case    1:*/		if ( regs.CR[0].eq ) { return 0x821C055C;  }
		/* 821C054Ch case    1:*/		return 0x821C0550;
		  /* 821C0550h */ case    2:  		/* lwz R10, <#[R30 + 28]> */
		/* 821C0550h case    2:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000001C) );
		/* 821C0550h case    2:*/		return 0x821C0554;
		  /* 821C0554h */ case    3:  		/* cmpw CR6, R10, R11 */
		/* 821C0554h case    3:*/		cpu::op::cmpw<6>(regs,regs.R10,regs.R11);
		/* 821C0554h case    3:*/		return 0x821C0558;
		  /* 821C0558h */ case    4:  		/* bc 4, CR6_EQ, -24 */
		/* 821C0558h case    4:*/		if ( !regs.CR[6].eq ) { return 0x821C0540;  }
		/* 821C0558h case    4:*/		return 0x821C055C;
	}
	return 0x821C055C;
} // Block from 821C0548h-821C055Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 821C055Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C055C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C055C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C055C);
		  /* 821C055Ch */ case    0:  		/* lwz R11, <#[R3 + 28]> */
		/* 821C055Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000001C) );
		/* 821C055Ch case    0:*/		return 0x821C0560;
		  /* 821C0560h */ case    1:  		/* lwz R10, <#[R30 + 28]> */
		/* 821C0560h case    1:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R30 + 0x0000001C) );
		/* 821C0560h case    1:*/		return 0x821C0564;
		  /* 821C0564h */ case    2:  		/* lwz R11, <#[R11 + 76]> */
		/* 821C0564h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000004C) );
		/* 821C0564h case    2:*/		return 0x821C0568;
		  /* 821C0568h */ case    3:  		/* lwz R10, <#[R10 + 76]> */
		/* 821C0568h case    3:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x0000004C) );
		/* 821C0568h case    3:*/		return 0x821C056C;
		  /* 821C056Ch */ case    4:  		/* xor R11, R11, R10 */
		/* 821C056Ch case    4:*/		cpu::op::xor<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821C056Ch case    4:*/		return 0x821C0570;
		  /* 821C0570h */ case    5:  		/* rlwinm. R11, R11, 0, 13, 31 */
		/* 821C0570h case    5:*/		cpu::op::rlwinm<1,0,13,31>(regs,&regs.R11,regs.R11);
		/* 821C0570h case    5:*/		return 0x821C0574;
		  /* 821C0574h */ case    6:  		/* bc 4, CR0_EQ, -52 */
		/* 821C0574h case    6:*/		if ( !regs.CR[0].eq ) { return 0x821C0540;  }
		/* 821C0574h case    6:*/		return 0x821C0578;
		  /* 821C0578h */ case    7:  		/* mr R4, R5 */
		/* 821C0578h case    7:*/		regs.R4 = regs.R5;
		/* 821C0578h case    7:*/		return 0x821C057C;
		  /* 821C057Ch */ case    8:  		/* bl -11852 */
		/* 821C057Ch case    8:*/		regs.LR = 0x821C0580; return 0x821BD730;
		/* 821C057Ch case    8:*/		return 0x821C0580;
		  /* 821C0580h */ case    9:  		/* mr R7, R3 */
		/* 821C0580h case    9:*/		regs.R7 = regs.R3;
		/* 821C0580h case    9:*/		return 0x821C0584;
		  /* 821C0584h */ case   10:  		/* mr R4, R8 */
		/* 821C0584h case   10:*/		regs.R4 = regs.R8;
		/* 821C0584h case   10:*/		return 0x821C0588;
		  /* 821C0588h */ case   11:  		/* mr R3, R31 */
		/* 821C0588h case   11:*/		regs.R3 = regs.R31;
		/* 821C0588h case   11:*/		return 0x821C058C;
		  /* 821C058Ch */ case   12:  		/* bl -11868 */
		/* 821C058Ch case   12:*/		regs.LR = 0x821C0590; return 0x821BD730;
		/* 821C058Ch case   12:*/		return 0x821C0590;
		  /* 821C0590h */ case   13:  		/* cmpw CR6, R7, R3 */
		/* 821C0590h case   13:*/		cpu::op::cmpw<6>(regs,regs.R7,regs.R3);
		/* 821C0590h case   13:*/		return 0x821C0594;
		  /* 821C0594h */ case   14:  		/* bc 4, CR6_EQ, -84 */
		/* 821C0594h case   14:*/		if ( !regs.CR[6].eq ) { return 0x821C0540;  }
		/* 821C0594h case   14:*/		return 0x821C0598;
		  /* 821C0598h */ case   15:  		/* mr R3, R31 */
		/* 821C0598h case   15:*/		regs.R3 = regs.R31;
		/* 821C0598h case   15:*/		return 0x821C059C;
		  /* 821C059Ch */ case   16:  		/* bl -323060 */
		/* 821C059Ch case   16:*/		regs.LR = 0x821C05A0; return 0x821717A8;
		/* 821C059Ch case   16:*/		return 0x821C05A0;
		  /* 821C05A0h */ case   17:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821C05A0h case   17:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821C05A0h case   17:*/		return 0x821C05A4;
		  /* 821C05A4h */ case   18:  		/* bc 12, CR0_EQ, 44 */
		/* 821C05A4h case   18:*/		if ( regs.CR[0].eq ) { return 0x821C05D0;  }
		/* 821C05A4h case   18:*/		return 0x821C05A8;
		  /* 821C05A8h */ case   19:  		/* lwz R10, <#[R31 + 4]> */
		/* 821C05A8h case   19:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000004) );
		/* 821C05A8h case   19:*/		return 0x821C05AC;
		  /* 821C05ACh */ case   20:  		/* cmplwi CR6, R10, 0 */
		/* 821C05ACh case   20:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821C05ACh case   20:*/		return 0x821C05B0;
		  /* 821C05B0h */ case   21:  		/* bc 12, CR6_EQ, 32 */
		/* 821C05B0h case   21:*/		if ( regs.CR[6].eq ) { return 0x821C05D0;  }
		/* 821C05B0h case   21:*/		return 0x821C05B4;
		  /* 821C05B4h */ case   22:  		/* lwz R11, <#[R10 + 16]> */
		/* 821C05B4h case   22:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R10 + 0x00000010) );
		/* 821C05B4h case   22:*/		return 0x821C05B8;
		  /* 821C05B8h */ case   23:  		/* cmplwi CR6, R11, 0 */
		/* 821C05B8h case   23:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821C05B8h case   23:*/		return 0x821C05BC;
		  /* 821C05BCh */ case   24:  		/* bc 12, CR6_EQ, 12 */
		/* 821C05BCh case   24:*/		if ( regs.CR[6].eq ) { return 0x821C05C8;  }
		/* 821C05BCh case   24:*/		return 0x821C05C0;
		  /* 821C05C0h */ case   25:  		/* cmplw CR6, R11, R30 */
		/* 821C05C0h case   25:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R30);
		/* 821C05C0h case   25:*/		return 0x821C05C4;
		  /* 821C05C4h */ case   26:  		/* bc 4, CR6_EQ, -132 */
		/* 821C05C4h case   26:*/		if ( !regs.CR[6].eq ) { return 0x821C0540;  }
		/* 821C05C4h case   26:*/		return 0x821C05C8;
	}
	return 0x821C05C8;
} // Block from 821C055Ch-821C05C8h (27 instructions)

//////////////////////////////////////////////////////
// Block at 821C05C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C05C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C05C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C05C8);
		  /* 821C05C8h */ case    0:  		/* lwz R10, <#[R10 + 8]> */
		/* 821C05C8h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 821C05C8h case    0:*/		return 0x821C05CC;
		  /* 821C05CCh */ case    1:  		/* b -32 */
		/* 821C05CCh case    1:*/		return 0x821C05AC;
		/* 821C05CCh case    1:*/		return 0x821C05D0;
	}
	return 0x821C05D0;
} // Block from 821C05C8h-821C05D0h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821C05D0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C05D0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C05D0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C05D0);
		  /* 821C05D0h */ case    0:  		/* li R3, 1 */
		/* 821C05D0h case    0:*/		cpu::op::li<0>(regs,&regs.R3,0x1);
		/* 821C05D0h case    0:*/		return 0x821C05D4;
	}
	return 0x821C05D4;
} // Block from 821C05D0h-821C05D4h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821C05D4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C05D4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C05D4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C05D4);
		  /* 821C05D4h */ case    0:  		/* addi R1, R1, 112 */
		/* 821C05D4h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821C05D4h case    0:*/		return 0x821C05D8;
		  /* 821C05D8h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 821C05D8h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821C05D8h case    1:*/		return 0x821C05DC;
		  /* 821C05DCh */ case    2:  		/* mtspr LR, R12 */
		/* 821C05DCh case    2:*/		regs.LR = regs.R12;
		/* 821C05DCh case    2:*/		return 0x821C05E0;
		  /* 821C05E0h */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 821C05E0h case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821C05E0h case    3:*/		return 0x821C05E4;
		  /* 821C05E4h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 821C05E4h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821C05E4h case    4:*/		return 0x821C05E8;
		  /* 821C05E8h */ case    5:  		/* bclr 20, CR0_LT */
		/* 821C05E8h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821C05E8h case    5:*/		return 0x821C05EC;
	}
	return 0x821C05EC;
} // Block from 821C05D4h-821C05ECh (6 instructions)

//////////////////////////////////////////////////////
// Block at 821C05ECh
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C05EC( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C05EC) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C05EC);
		  /* 821C05ECh */ case    0:  		/* nop */
		/* 821C05ECh case    0:*/		cpu::op::nop();
		/* 821C05ECh case    0:*/		return 0x821C05F0;
	}
	return 0x821C05F0;
} // Block from 821C05ECh-821C05F0h (1 instructions)

//////////////////////////////////////////////////////
// Block at 821C05F0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C05F0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C05F0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C05F0);
		  /* 821C05F0h */ case    0:  		/* mfspr R12, LR */
		/* 821C05F0h case    0:*/		regs.R12 = regs.LR;
		/* 821C05F0h case    0:*/		return 0x821C05F4;
		  /* 821C05F4h */ case    1:  		/* stw R12, <#[R1 - 8]> */
		/* 821C05F4h case    1:*/		cpu::mem::store32( regs, regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821C05F4h case    1:*/		return 0x821C05F8;
		  /* 821C05F8h */ case    2:  		/* std R30, <#[R1 - 24]> */
		/* 821C05F8h case    2:*/		cpu::mem::store64( regs, regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821C05F8h case    2:*/		return 0x821C05FC;
		  /* 821C05FCh */ case    3:  		/* std R31, <#[R1 - 16]> */
		/* 821C05FCh case    3:*/		cpu::mem::store64( regs, regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821C05FCh case    3:*/		return 0x821C0600;
		  /* 821C0600h */ case    4:  		/* stwu R1, <#[R1 - 112]> */
		/* 821C0600h case    4:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF90) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF90);
		/* 821C0600h case    4:*/		return 0x821C0604;
		  /* 821C0604h */ case    5:  		/* lwz R31, <#[R4 + 16]> */
		/* 821C0604h case    5:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R4 + 0x00000010) );
		/* 821C0604h case    5:*/		return 0x821C0608;
		  /* 821C0608h */ case    6:  		/* mr R30, R6 */
		/* 821C0608h case    6:*/		regs.R30 = regs.R6;
		/* 821C0608h case    6:*/		return 0x821C060C;
		  /* 821C060Ch */ case    7:  		/* cmplwi CR6, R31, 0 */
		/* 821C060Ch case    7:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821C060Ch case    7:*/		return 0x821C0610;
		  /* 821C0610h */ case    8:  		/* bc 12, CR6_EQ, 160 */
		/* 821C0610h case    8:*/		if ( regs.CR[6].eq ) { return 0x821C06B0;  }
		/* 821C0610h case    8:*/		return 0x821C0614;
		  /* 821C0614h */ case    9:  		/* lwz R11, <#[R31]> */
		/* 821C0614h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821C0614h case    9:*/		return 0x821C0618;
		  /* 821C0618h */ case   10:  		/* cmpwi CR6, R11, 0 */
		/* 821C0618h case   10:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000000);
		/* 821C0618h case   10:*/		return 0x821C061C;
		  /* 821C061Ch */ case   11:  		/* bc 12, CR6_EQ, 16 */
		/* 821C061Ch case   11:*/		if ( regs.CR[6].eq ) { return 0x821C062C;  }
		/* 821C061Ch case   11:*/		return 0x821C0620;
		  /* 821C0620h */ case   12:  		/* lwz R31, <#[R31 + 4]> */
		/* 821C0620h case   12:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R31 + 0x00000004) );
		/* 821C0620h case   12:*/		return 0x821C0624;
		  /* 821C0624h */ case   13:  		/* cmplwi CR6, R31, 0 */
		/* 821C0624h case   13:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821C0624h case   13:*/		return 0x821C0628;
		  /* 821C0628h */ case   14:  		/* bc 4, CR6_EQ, -20 */
		/* 821C0628h case   14:*/		if ( !regs.CR[6].eq ) { return 0x821C0614;  }
		/* 821C0628h case   14:*/		return 0x821C062C;
	}
	return 0x821C062C;
} // Block from 821C05F0h-821C062Ch (15 instructions)

//////////////////////////////////////////////////////
// Block at 821C062Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C062C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C062C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C062C);
		  /* 821C062Ch */ case    0:  		/* cmplwi CR6, R31, 0 */
		/* 821C062Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R31,0x00000000);
		/* 821C062Ch case    0:*/		return 0x821C0630;
		  /* 821C0630h */ case    1:  		/* bc 12, CR6_EQ, 128 */
		/* 821C0630h case    1:*/		if ( regs.CR[6].eq ) { return 0x821C06B0;  }
		/* 821C0630h case    1:*/		return 0x821C0634;
		  /* 821C0634h */ case    2:  		/* lwz R11, <#[R4 + 28]> */
		/* 821C0634h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x0000001C) );
		/* 821C0634h case    2:*/		return 0x821C0638;
		  /* 821C0638h */ case    3:  		/* li R10, 1 */
		/* 821C0638h case    3:*/		cpu::op::li<0>(regs,&regs.R10,0x1);
		/* 821C0638h case    3:*/		return 0x821C063C;
		  /* 821C063Ch */ case    4:  		/* lwz R9, <#[R5 + 8]> */
		/* 821C063Ch case    4:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R5 + 0x00000008) );
		/* 821C063Ch case    4:*/		return 0x821C0640;
		  /* 821C0640h */ case    5:  		/* lwz R11, <#[R11 + 48]> */
		/* 821C0640h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000030) );
		/* 821C0640h case    5:*/		return 0x821C0644;
		  /* 821C0644h */ case    6:  		/* lwz R9, <#[R9 + 40]> */
		/* 821C0644h case    6:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R9 + 0x00000028) );
		/* 821C0644h case    6:*/		return 0x821C0648;
		  /* 821C0648h */ case    7:  		/* rlwinm R8, R11, 0, 13, 31 */
		/* 821C0648h case    7:*/		cpu::op::rlwinm<0,0,13,31>(regs,&regs.R8,regs.R11);
		/* 821C0648h case    7:*/		return 0x821C064C;
		  /* 821C064Ch */ case    8:  		/* rlwinm R11, R8, 27, 5, 31 */
		/* 821C064Ch case    8:*/		cpu::op::rlwinm<0,27,5,31>(regs,&regs.R11,regs.R8);
		/* 821C064Ch case    8:*/		return 0x821C0650;
		  /* 821C0650h */ case    9:  		/* rlwinm R8, R8, 0, 27, 31 */
		/* 821C0650h case    9:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R8,regs.R8);
		/* 821C0650h case    9:*/		return 0x821C0654;
		  /* 821C0654h */ case   10:  		/* addi R11, R11, 1 */
		/* 821C0654h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821C0654h case   10:*/		return 0x821C0658;
		  /* 821C0658h */ case   11:  		/* slw R10, R10, R8 */
		/* 821C0658h case   11:*/		cpu::op::slw<0>(regs,&regs.R10,regs.R10,regs.R8);
		/* 821C0658h case   11:*/		return 0x821C065C;
		  /* 821C065Ch */ case   12:  		/* rlwinm R11, R11, 2, 0, 29 */
		/* 821C065Ch case   12:*/		cpu::op::rlwinm<0,2,0,29>(regs,&regs.R11,regs.R11);
		/* 821C065Ch case   12:*/		return 0x821C0660;
		  /* 821C0660h */ case   13:  		/* lwzx R11, <#[R11 + R9]> */
		/* 821C0660h case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + regs.R9 + 0x00000000) );
		/* 821C0660h case   13:*/		return 0x821C0664;
		  /* 821C0664h */ case   14:  		/* and. R11, R11, R10 */
		/* 821C0664h case   14:*/		cpu::op::and<1>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821C0664h case   14:*/		return 0x821C0668;
		  /* 821C0668h */ case   15:  		/* bc 12, CR0_EQ, 72 */
		/* 821C0668h case   15:*/		if ( regs.CR[0].eq ) { return 0x821C06B0;  }
		/* 821C0668h case   15:*/		return 0x821C066C;
		  /* 821C066Ch */ case   16:  		/* mr R6, R30 */
		/* 821C066Ch case   16:*/		regs.R6 = regs.R30;
		/* 821C066Ch case   16:*/		return 0x821C0670;
		  /* 821C0670h */ case   17:  		/* mr R5, R31 */
		/* 821C0670h case   17:*/		regs.R5 = regs.R31;
		/* 821C0670h case   17:*/		return 0x821C0674;
		  /* 821C0674h */ case   18:  		/* bl -9676 */
		/* 821C0674h case   18:*/		regs.LR = 0x821C0678; return 0x821BE0A8;
		/* 821C0674h case   18:*/		return 0x821C0678;
		  /* 821C0678h */ case   19:  		/* rlwinm. R11, R3, 0, 24, 31 */
		/* 821C0678h case   19:*/		cpu::op::rlwinm<1,0,24,31>(regs,&regs.R11,regs.R3);
		/* 821C0678h case   19:*/		return 0x821C067C;
		  /* 821C067Ch */ case   20:  		/* bc 12, CR0_EQ, 52 */
		/* 821C067Ch case   20:*/		if ( regs.CR[0].eq ) { return 0x821C06B0;  }
		/* 821C067Ch case   20:*/		return 0x821C0680;
		  /* 821C0680h */ case   21:  		/* lwz R11, <#[R30]> */
		/* 821C0680h case   21:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821C0680h case   21:*/		return 0x821C0684;
		  /* 821C0684h */ case   22:  		/* ori R11, R11, 4096 */
		/* 821C0684h case   22:*/		cpu::op::ori<0>(regs,&regs.R11,regs.R11,0x1000);
		/* 821C0684h case   22:*/		return 0x821C0688;
		  /* 821C0688h */ case   23:  		/* stw R11, <#[R30]> */
		/* 821C0688h case   23:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821C0688h case   23:*/		return 0x821C068C;
		  /* 821C068Ch */ case   24:  		/* rlwinm R9, R11, 19, 18, 31 */
		/* 821C068Ch case   24:*/		cpu::op::rlwinm<0,19,18,31>(regs,&regs.R9,regs.R11);
		/* 821C068Ch case   24:*/		return 0x821C0690;
		  /* 821C0690h */ case   25:  		/* lwz R10, <#[R31 + 8]> */
		/* 821C0690h case   25:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R31 + 0x00000008) );
		/* 821C0690h case   25:*/		return 0x821C0694;
		  /* 821C0694h */ case   26:  		/* rlwinm R10, R10, 0, 18, 31 */
		/* 821C0694h case   26:*/		cpu::op::rlwinm<0,0,18,31>(regs,&regs.R10,regs.R10);
		/* 821C0694h case   26:*/		return 0x821C0698;
		  /* 821C0698h */ case   27:  		/* cmplw CR6, R10, R9 */
		/* 821C0698h case   27:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 821C0698h case   27:*/		return 0x821C069C;
		  /* 821C069Ch */ case   28:  		/* bc 4, CR6_LT, 20 */
		/* 821C069Ch case   28:*/		if ( !regs.CR[6].lt ) { return 0x821C06B0;  }
		/* 821C069Ch case   28:*/		return 0x821C06A0;
		  /* 821C06A0h */ case   29:  		/* rlwinm R10, R10, 13, 0, 18 */
		/* 821C06A0h case   29:*/		cpu::op::rlwinm<0,13,0,18>(regs,&regs.R10,regs.R10);
		/* 821C06A0h case   29:*/		return 0x821C06A4;
		  /* 821C06A4h */ case   30:  		/* rlwinm R11, R11, 0, 19, 4 */
		/* 821C06A4h case   30:*/		cpu::op::rlwinm<0,0,19,4>(regs,&regs.R11,regs.R11);
		/* 821C06A4h case   30:*/		return 0x821C06A8;
		  /* 821C06A8h */ case   31:  		/* or R11, R10, R11 */
		/* 821C06A8h case   31:*/		cpu::op::or<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821C06A8h case   31:*/		return 0x821C06AC;
		  /* 821C06ACh */ case   32:  		/* stw R11, <#[R30]> */
		/* 821C06ACh case   32:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R30 + 0x00000000) );
		/* 821C06ACh case   32:*/		return 0x821C06B0;
	}
	return 0x821C06B0;
} // Block from 821C062Ch-821C06B0h (33 instructions)

//////////////////////////////////////////////////////
// Block at 821C06B0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C06B0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C06B0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C06B0);
		  /* 821C06B0h */ case    0:  		/* addi R1, R1, 112 */
		/* 821C06B0h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0x70);
		/* 821C06B0h case    0:*/		return 0x821C06B4;
		  /* 821C06B4h */ case    1:  		/* lwz R12, <#[R1 - 8]> */
		/* 821C06B4h case    1:*/		cpu::mem::load32z( regs, &regs.R12, (uint32)(regs.R1 + 0xFFFFFFF8) );
		/* 821C06B4h case    1:*/		return 0x821C06B8;
		  /* 821C06B8h */ case    2:  		/* mtspr LR, R12 */
		/* 821C06B8h case    2:*/		regs.LR = regs.R12;
		/* 821C06B8h case    2:*/		return 0x821C06BC;
		  /* 821C06BCh */ case    3:  		/* ld R30, <#[R1 - 24]> */
		/* 821C06BCh case    3:*/		cpu::mem::load64( regs, &regs.R30, (uint32)(regs.R1 + 0xFFFFFFE8) );
		/* 821C06BCh case    3:*/		return 0x821C06C0;
		  /* 821C06C0h */ case    4:  		/* ld R31, <#[R1 - 16]> */
		/* 821C06C0h case    4:*/		cpu::mem::load64( regs, &regs.R31, (uint32)(regs.R1 + 0xFFFFFFF0) );
		/* 821C06C0h case    4:*/		return 0x821C06C4;
		  /* 821C06C4h */ case    5:  		/* bclr 20, CR0_LT */
		/* 821C06C4h case    5:*/		if ( 1 ) { return (uint32)regs.LR; }
		/* 821C06C4h case    5:*/		return 0x821C06C8;
	}
	return 0x821C06C8;
} // Block from 821C06B0h-821C06C8h (6 instructions)

//////////////////////////////////////////////////////
// Block at 821C06C8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C06C8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C06C8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C06C8);
		  /* 821C06C8h */ case    0:  		/* mfspr R12, LR */
		/* 821C06C8h case    0:*/		regs.R12 = regs.LR;
		/* 821C06C8h case    0:*/		return 0x821C06CC;
		  /* 821C06CCh */ case    1:  		/* bl -1242272 */
		/* 821C06CCh case    1:*/		regs.LR = 0x821C06D0; return 0x8209122C;
		/* 821C06CCh case    1:*/		return 0x821C06D0;
		  /* 821C06D0h */ case    2:  		/* stwu R1, <#[R1 - 224]> */
		/* 821C06D0h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF20) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF20);
		/* 821C06D0h case    2:*/		return 0x821C06D4;
		  /* 821C06D4h */ case    3:  		/* mr R31, R4 */
		/* 821C06D4h case    3:*/		regs.R31 = regs.R4;
		/* 821C06D4h case    3:*/		return 0x821C06D8;
		  /* 821C06D8h */ case    4:  		/* mr R30, R5 */
		/* 821C06D8h case    4:*/		regs.R30 = regs.R5;
		/* 821C06D8h case    4:*/		return 0x821C06DC;
		  /* 821C06DCh */ case    5:  		/* li R5, 2 */
		/* 821C06DCh case    5:*/		cpu::op::li<0>(regs,&regs.R5,0x2);
		/* 821C06DCh case    5:*/		return 0x821C06E0;
		  /* 821C06E0h */ case    6:  		/* li R4, 24 */
		/* 821C06E0h case    6:*/		cpu::op::li<0>(regs,&regs.R4,0x18);
		/* 821C06E0h case    6:*/		return 0x821C06E4;
		  /* 821C06E4h */ case    7:  		/* mr R27, R3 */
		/* 821C06E4h case    7:*/		regs.R27 = regs.R3;
		/* 821C06E4h case    7:*/		return 0x821C06E8;
		  /* 821C06E8h */ case    8:  		/* mr R19, R6 */
		/* 821C06E8h case    8:*/		regs.R19 = regs.R6;
		/* 821C06E8h case    8:*/		return 0x821C06EC;
		  /* 821C06ECh */ case    9:  		/* bl -376316 */
		/* 821C06ECh case    9:*/		regs.LR = 0x821C06F0; return 0x821648F0;
		/* 821C06ECh case    9:*/		return 0x821C06F0;
		  /* 821C06F0h */ case   10:  		/* mr R26, R3 */
		/* 821C06F0h case   10:*/		regs.R26 = regs.R3;
		/* 821C06F0h case   10:*/		return 0x821C06F4;
		  /* 821C06F4h */ case   11:  		/* mr R6, R3 */
		/* 821C06F4h case   11:*/		regs.R6 = regs.R3;
		/* 821C06F4h case   11:*/		return 0x821C06F8;
		  /* 821C06F8h */ case   12:  		/* mr R5, R30 */
		/* 821C06F8h case   12:*/		regs.R5 = regs.R30;
		/* 821C06F8h case   12:*/		return 0x821C06FC;
		  /* 821C06FCh */ case   13:  		/* mr R4, R31 */
		/* 821C06FCh case   13:*/		regs.R4 = regs.R31;
		/* 821C06FCh case   13:*/		return 0x821C0700;
		  /* 821C0700h */ case   14:  		/* mr R3, R27 */
		/* 821C0700h case   14:*/		regs.R3 = regs.R27;
		/* 821C0700h case   14:*/		return 0x821C0704;
		  /* 821C0704h */ case   15:  		/* bl -7964 */
		/* 821C0704h case   15:*/		regs.LR = 0x821C0708; return 0x821BE7E8;
		/* 821C0704h case   15:*/		return 0x821C0708;
		  /* 821C0708h */ case   16:  		/* cmplwi CR0, R3, 0 */
		/* 821C0708h case   16:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 821C0708h case   16:*/		return 0x821C070C;
		  /* 821C070Ch */ case   17:  		/* bc 4, CR0_EQ, 60 */
		/* 821C070Ch case   17:*/		if ( !regs.CR[0].eq ) { return 0x821C0748;  }
		/* 821C070Ch case   17:*/		return 0x821C0710;
		  /* 821C0710h */ case   18:  		/* lwz R10, <#[R27 + 992]> */
		/* 821C0710h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R27 + 0x000003E0) );
		/* 821C0710h case   18:*/		return 0x821C0714;
		  /* 821C0714h */ case   19:  		/* addi R11, R27, 972 */
		/* 821C0714h case   19:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R27,0x3CC);
		/* 821C0714h case   19:*/		return 0x821C0718;
		  /* 821C0718h */ case   20:  		/* stw R10, <#[R26]> */
		/* 821C0718h case   20:*/		cpu::mem::store32( regs, regs.R10, (uint32)(regs.R26 + 0x00000000) );
		/* 821C0718h case   20:*/		return 0x821C071C;
		  /* 821C071Ch */ case   21:  		/* stw R26, <#[R27 + 992]> */
		/* 821C071Ch case   21:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R27 + 0x000003E0) );
		/* 821C071Ch case   21:*/		return 0x821C0720;
		  /* 821C0720h */ case   22:  		/* b 744 */
		/* 821C0720h case   22:*/		return 0x821C0A08;
		/* 821C0720h case   22:*/		return 0x821C0724;
		  /* 821C0724h */ case   23:  		/* lwz R11, <#[R3 + 4]> */
		/* 821C0724h case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000004) );
		/* 821C0724h case   23:*/		return 0x821C0728;
		  /* 821C0728h */ case   24:  		/* mr R6, R26 */
		/* 821C0728h case   24:*/		regs.R6 = regs.R26;
		/* 821C0728h case   24:*/		return 0x821C072C;
		  /* 821C072Ch */ case   25:  		/* mr R5, R30 */
		/* 821C072Ch case   25:*/		regs.R5 = regs.R30;
		/* 821C072Ch case   25:*/		return 0x821C0730;
		  /* 821C0730h */ case   26:  		/* mr R3, R27 */
		/* 821C0730h case   26:*/		regs.R3 = regs.R27;
		/* 821C0730h case   26:*/		return 0x821C0734;
		  /* 821C0734h */ case   27:  		/* lwz R11, <#[R11 + 52]> */
		/* 821C0734h case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000034) );
		/* 821C0734h case   27:*/		return 0x821C0738;
		  /* 821C0738h */ case   28:  		/* lwz R4, <#[R11 + 12]> */
		/* 821C0738h case   28:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x0000000C) );
		/* 821C0738h case   28:*/		return 0x821C073C;
		  /* 821C073Ch */ case   29:  		/* bl -8020 */
		/* 821C073Ch case   29:*/		regs.LR = 0x821C0740; return 0x821BE7E8;
		/* 821C073Ch case   29:*/		return 0x821C0740;
		  /* 821C0740h */ case   30:  		/* cmplwi CR0, R3, 0 */
		/* 821C0740h case   30:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 821C0740h case   30:*/		return 0x821C0744;
		  /* 821C0744h */ case   31:  		/* bc 12, CR0_EQ, 708 */
		/* 821C0744h case   31:*/		if ( regs.CR[0].eq ) { return 0x821C0A08;  }
		/* 821C0744h case   31:*/		return 0x821C0748;
	}
	return 0x821C0748;
} // Block from 821C06C8h-821C0748h (32 instructions)

//////////////////////////////////////////////////////
// Block at 821C0748h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C0748( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C0748) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C0748);
		  /* 821C0748h */ case    0:  		/* lwz R11, <#[R26 + 8]> */
		/* 821C0748h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000008) );
		/* 821C0748h case    0:*/		return 0x821C074C;
		  /* 821C074Ch */ case    1:  		/* cmplwi CR6, R11, 0 */
		/* 821C074Ch case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821C074Ch case    1:*/		return 0x821C0750;
		  /* 821C0750h */ case    2:  		/* bc 12, CR6_EQ, -44 */
		/* 821C0750h case    2:*/		if ( regs.CR[6].eq ) { return 0x821C0724;  }
		/* 821C0750h case    2:*/		return 0x821C0754;
		  /* 821C0754h */ case    3:  		/* lwz R11, <#[R31 + 4]> */
		/* 821C0754h case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R31 + 0x00000004) );
		/* 821C0754h case    3:*/		return 0x821C0758;
		  /* 821C0758h */ case    4:  		/* lwz R10, <#[R11 + 8]> */
		/* 821C0758h case    4:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R11 + 0x00000008) );
		/* 821C0758h case    4:*/		return 0x821C075C;
		  /* 821C075Ch */ case    5:  		/* cmpwi CR6, R10, 0 */
		/* 821C075Ch case    5:*/		cpu::op::cmpwi<6>(regs,regs.R10,0x00000000);
		/* 821C075Ch case    5:*/		return 0x821C0760;
		  /* 821C0760h */ case    6:  		/* bc 4, CR6_EQ, 68 */
		/* 821C0760h case    6:*/		if ( !regs.CR[6].eq ) { return 0x821C07A4;  }
		/* 821C0760h case    6:*/		return 0x821C0764;
		  /* 821C0764h */ case    7:  		/* lwz R4, <#[R11 + 16]> */
		/* 821C0764h case    7:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000010) );
		/* 821C0764h case    7:*/		return 0x821C0768;
		  /* 821C0768h */ case    8:  		/* lwz R11, <#[R4 + 8]> */
		/* 821C0768h case    8:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000008) );
		/* 821C0768h case    8:*/		return 0x821C076C;
		  /* 821C076Ch */ case    9:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821C076Ch case    9:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821C076Ch case    9:*/		return 0x821C0770;
		  /* 821C0770h */ case   10:  		/* cmplwi CR6, R11, 1664 */
		/* 821C0770h case   10:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000680);
		/* 821C0770h case   10:*/		return 0x821C0774;
		  /* 821C0774h */ case   11:  		/* bc 4, CR6_EQ, 48 */
		/* 821C0774h case   11:*/		if ( !regs.CR[6].eq ) { return 0x821C07A4;  }
		/* 821C0774h case   11:*/		return 0x821C0778;
		  /* 821C0778h */ case   12:  		/* lwz R11, <#[R4 + 52]> */
		/* 821C0778h case   12:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R4 + 0x00000034) );
		/* 821C0778h case   12:*/		return 0x821C077C;
		  /* 821C077Ch */ case   13:  		/* lwz R11, <#[R11 + 12]> */
		/* 821C077Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x0000000C) );
		/* 821C077Ch case   13:*/		return 0x821C0780;
		  /* 821C0780h */ case   14:  		/* cmplw CR6, R11, R31 */
		/* 821C0780h case   14:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R31);
		/* 821C0780h case   14:*/		return 0x821C0784;
		  /* 821C0784h */ case   15:  		/* bc 4, CR6_EQ, 32 */
		/* 821C0784h case   15:*/		if ( !regs.CR[6].eq ) { return 0x821C07A4;  }
		/* 821C0784h case   15:*/		return 0x821C0788;
		  /* 821C0788h */ case   16:  		/* mr R6, R26 */
		/* 821C0788h case   16:*/		regs.R6 = regs.R26;
		/* 821C0788h case   16:*/		return 0x821C078C;
		  /* 821C078Ch */ case   17:  		/* mr R5, R30 */
		/* 821C078Ch case   17:*/		regs.R5 = regs.R30;
		/* 821C078Ch case   17:*/		return 0x821C0790;
		  /* 821C0790h */ case   18:  		/* mr R3, R27 */
		/* 821C0790h case   18:*/		regs.R3 = regs.R27;
		/* 821C0790h case   18:*/		return 0x821C0794;
		  /* 821C0794h */ case   19:  		/* mr R31, R4 */
		/* 821C0794h case   19:*/		regs.R31 = regs.R4;
		/* 821C0794h case   19:*/		return 0x821C0798;
		  /* 821C0798h */ case   20:  		/* bl -8112 */
		/* 821C0798h case   20:*/		regs.LR = 0x821C079C; return 0x821BE7E8;
		/* 821C0798h case   20:*/		return 0x821C079C;
		  /* 821C079Ch */ case   21:  		/* cmplwi CR0, R3, 0 */
		/* 821C079Ch case   21:*/		cpu::op::cmplwi<0>(regs,regs.R3,0x00000000);
		/* 821C079Ch case   21:*/		return 0x821C07A0;
		  /* 821C07A0h */ case   22:  		/* bc 4, CR0_EQ, -76 */
		/* 821C07A0h case   22:*/		if ( !regs.CR[0].eq ) { return 0x821C0754;  }
		/* 821C07A0h case   22:*/		return 0x821C07A4;
	}
	return 0x821C07A4;
} // Block from 821C0748h-821C07A4h (23 instructions)

//////////////////////////////////////////////////////
// Block at 821C07A4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C07A4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C07A4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C07A4);
		  /* 821C07A4h */ case    0:  		/* lwz R11, <#[R26 + 4]> */
		/* 821C07A4h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000004) );
		/* 821C07A4h case    0:*/		return 0x821C07A8;
		  /* 821C07A8h */ case    1:  		/* cmplwi CR6, R11, 1 */
		/* 821C07A8h case    1:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 821C07A8h case    1:*/		return 0x821C07AC;
		  /* 821C07ACh */ case    2:  		/* bc 12, CR6_EQ, 604 */
		/* 821C07ACh case    2:*/		if ( regs.CR[6].eq ) { return 0x821C0A08;  }
		/* 821C07ACh case    2:*/		return 0x821C07B0;
		  /* 821C07B0h */ case    3:  		/* cmplwi CR6, R11, 8191 */
		/* 821C07B0h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00001FFF);
		/* 821C07B0h case    3:*/		return 0x821C07B4;
		  /* 821C07B4h */ case    4:  		/* bc 12, CR6_GT, 596 */
		/* 821C07B4h case    4:*/		if ( regs.CR[6].gt ) { return 0x821C0A08;  }
		/* 821C07B4h case    4:*/		return 0x821C07B8;
		  /* 821C07B8h */ case    5:  		/* lwz R11, <#[R19 + 64]> */
		/* 821C07B8h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x00000040) );
		/* 821C07B8h case    5:*/		return 0x821C07BC;
		  /* 821C07BCh */ case    6:  		/* stw R11, <#[R26 + 20]> */
		/* 821C07BCh case    6:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R26 + 0x00000014) );
		/* 821C07BCh case    6:*/		return 0x821C07C0;
		  /* 821C07C0h */ case    7:  		/* stw R26, <#[R19 + 64]> */
		/* 821C07C0h case    7:*/		cpu::mem::store32( regs, regs.R26, (uint32)(regs.R19 + 0x00000040) );
		/* 821C07C0h case    7:*/		return 0x821C07C4;
		  /* 821C07C4h */ case    8:  		/* lwz R17, <#[R26 + 4]> */
		/* 821C07C4h case    8:*/		cpu::mem::load32z( regs, &regs.R17, (uint32)(regs.R26 + 0x00000004) );
		/* 821C07C4h case    8:*/		return 0x821C07C8;
		  /* 821C07C8h */ case    9:  		/* lwz R18, <#[R26 + 12]> */
		/* 821C07C8h case    9:*/		cpu::mem::load32z( regs, &regs.R18, (uint32)(regs.R26 + 0x0000000C) );
		/* 821C07C8h case    9:*/		return 0x821C07CC;
		  /* 821C07CCh */ case   10:  		/* rlwinm R11, R18, 19, 19, 31 */
		/* 821C07CCh case   10:*/		cpu::op::rlwinm<0,19,19,31>(regs,&regs.R11,regs.R18);
		/* 821C07CCh case   10:*/		return 0x821C07D0;
		  /* 821C07D0h */ case   11:  		/* cmplw CR6, R11, R17 */
		/* 821C07D0h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R17);
		/* 821C07D0h case   11:*/		return 0x821C07D4;
		  /* 821C07D4h */ case   12:  		/* bc 4, CR6_EQ, 564 */
		/* 821C07D4h case   12:*/		if ( !regs.CR[6].eq ) { return 0x821C0A08;  }
		/* 821C07D4h case   12:*/		return 0x821C07D8;
	}
	return 0x821C07D8;
} // Block from 821C07A4h-821C07D8h (13 instructions)

//////////////////////////////////////////////////////
// Block at 821C07D8h
// Function '?CleanClonedBlocksWithMarkedInstructions@Compiler@D3DXShader@@AAAXIPAVBlock@2@@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C07D8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C07D8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C07D8);
		  /* 821C07D8h */ case    0:  		/* lwz R11, <#[R26]> */
		/* 821C07D8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R26 + 0x00000000) );
		/* 821C07D8h case    0:*/		return 0x821C07DC;
		  /* 821C07DCh */ case    1:  		/* li R20, 0 */
		/* 821C07DCh case    1:*/		cpu::op::li<0>(regs,&regs.R20,0x0);
		/* 821C07DCh case    1:*/		return 0x821C07E0;
		  /* 821C07E0h */ case    2:  		/* lwz R29, <#[R11 + 8]> */
		/* 821C07E0h case    2:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R11 + 0x00000008) );
		/* 821C07E0h case    2:*/		return 0x821C07E4;
		  /* 821C07E4h */ case    3:  		/* lwz R22, <#[R11]> */
		/* 821C07E4h case    3:*/		cpu::mem::load32z( regs, &regs.R22, (uint32)(regs.R11 + 0x00000000) );
		/* 821C07E4h case    3:*/		return 0x821C07E8;
		  /* 821C07E8h */ case    4:  		/* mr R10, R29 */
		/* 821C07E8h case    4:*/		regs.R10 = regs.R29;
		/* 821C07E8h case    4:*/		return 0x821C07EC;
		  /* 821C07ECh */ case    5:  		/* mr R21, R22 */
		/* 821C07ECh case    5:*/		regs.R21 = regs.R22;
		/* 821C07ECh case    5:*/		return 0x821C07F0;
		  /* 821C07F0h */ case    6:  		/* cmplwi CR0, R29, 0 */
		/* 821C07F0h case    6:*/		cpu::op::cmplwi<0>(regs,regs.R29,0x00000000);
		/* 821C07F0h case    6:*/		return 0x821C07F4;
		  /* 821C07F4h */ case    7:  		/* bc 12, CR0_EQ, 40 */
		/* 821C07F4h case    7:*/		if ( regs.CR[0].eq ) { return 0x821C081C;  }
		/* 821C07F4h case    7:*/		return 0x821C07F8;
		  /* 821C07F8h */ case    8:  		/* lwz R9, <#[R10]> */
		/* 821C07F8h case    8:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R10 + 0x00000000) );
		/* 821C07F8h case    8:*/		return 0x821C07FC;
		  /* 821C07FCh */ case    9:  		/* addi R8, R21, 1 */
		/* 821C07FCh case    9:*/		cpu::op::addi<0>(regs,&regs.R8,regs.R21,0x1);
		/* 821C07FCh case    9:*/		return 0x821C0800;
		  /* 821C0800h */ case   10:  		/* cmplw CR6, R9, R8 */
		/* 821C0800h case   10:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R8);
		/* 821C0800h case   10:*/		return 0x821C0804;
		  /* 821C0804h */ case   11:  		/* bc 12, CR6_EQ, 8 */
		/* 821C0804h case   11:*/		if ( regs.CR[6].eq ) { return 0x821C080C;  }
		/* 821C0804h case   11:*/		return 0x821C0808;
		  /* 821C0808h */ case   12:  		/* addi R20, R20, 1 */
		/* 821C0808h case   12:*/		cpu::op::addi<0>(regs,&regs.R20,regs.R20,0x1);
		/* 821C0808h case   12:*/		return 0x821C080C;
	}
	return 0x821C080C;
} // Block from 821C07D8h-821C080Ch (13 instructions)

//////////////////////////////////////////////////////
// Block at 821C080Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C080C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C080C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C080C);
		  /* 821C080Ch */ case    0:  		/* lwz R10, <#[R10 + 8]> */
		/* 821C080Ch case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000008) );
		/* 821C080Ch case    0:*/		return 0x821C0810;
		  /* 821C0810h */ case    1:  		/* mr R21, R9 */
		/* 821C0810h case    1:*/		regs.R21 = regs.R9;
		/* 821C0810h case    1:*/		return 0x821C0814;
		  /* 821C0814h */ case    2:  		/* cmplwi CR6, R10, 0 */
		/* 821C0814h case    2:*/		cpu::op::cmplwi<6>(regs,regs.R10,0x00000000);
		/* 821C0814h case    2:*/		return 0x821C0818;
		  /* 821C0818h */ case    3:  		/* bc 4, CR6_EQ, -32 */
		/* 821C0818h case    3:*/		if ( !regs.CR[6].eq ) { return 0x821C07F8;  }
		/* 821C0818h case    3:*/		return 0x821C081C;
	}
	return 0x821C081C;
} // Block from 821C080Ch-821C081Ch (4 instructions)

//////////////////////////////////////////////////////
// Block at 821C081Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C081C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C081C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C081C);
		  /* 821C081Ch */ case    0:  		/* lwz R11, <#[R11 + 4]> */
		/* 821C081Ch case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821C081Ch case    0:*/		return 0x821C0820;
		  /* 821C0820h */ case    1:  		/* mr R3, R27 */
		/* 821C0820h case    1:*/		regs.R3 = regs.R27;
		/* 821C0820h case    1:*/		return 0x821C0824;
		  /* 821C0824h */ case    2:  		/* lwz R31, <#[R11 + 48]> */
		/* 821C0824h case    2:*/		cpu::mem::load32z( regs, &regs.R31, (uint32)(regs.R11 + 0x00000030) );
		/* 821C0824h case    2:*/		return 0x821C0828;
		  /* 821C0828h */ case    3:  		/* lwz R30, <#[R31 + 12]> */
		/* 821C0828h case    3:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R31 + 0x0000000C) );
		/* 821C0828h case    3:*/		return 0x821C082C;
		  /* 821C082Ch */ case    4:  		/* addi R28, R30, -8 */
		/* 821C082Ch case    4:*/		cpu::op::addi<0>(regs,&regs.R28,regs.R30,0xFFFFFFF8);
		/* 821C082Ch case    4:*/		return 0x821C0830;
		  /* 821C0830h */ case    5:  		/* lwz R11, <#[R30 + 8]> */
		/* 821C0830h case    5:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821C0830h case    5:*/		return 0x821C0834;
		  /* 821C0834h */ case    6:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 821C0834h case    6:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 821C0834h case    6:*/		return 0x821C0838;
		  /* 821C0838h */ case    7:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 821C0838h case    7:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 821C0838h case    7:*/		return 0x821C083C;
		  /* 821C083Ch */ case    8:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 821C083Ch case    8:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 821C083Ch case    8:*/		return 0x821C0840;
		  /* 821C0840h */ case    9:  		/* bl -377872 */
		/* 821C0840h case    9:*/		regs.LR = 0x821C0844; return 0x82164430;
		/* 821C0840h case    9:*/		return 0x821C0844;
		  /* 821C0844h */ case   10:  		/* lwzx R10, <#[R3 + R28]> */
		/* 821C0844h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + regs.R28 + 0x00000000) );
		/* 821C0844h case   10:*/		return 0x821C0848;
		  /* 821C0848h */ case   11:  		/* lwz R11, <#[R27 + 12]> */
		/* 821C0848h case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R27 + 0x0000000C) );
		/* 821C0848h case   11:*/		return 0x821C084C;
		  /* 821C084Ch */ case   12:  		/* rlwinm R23, R10, 0, 17, 31 */
		/* 821C084Ch case   12:*/		cpu::op::rlwinm<0,0,17,31>(regs,&regs.R23,regs.R10);
		/* 821C084Ch case   12:*/		return 0x821C0850;
		  /* 821C0850h */ case   13:  		/* mulli R10, R23, 40 */
		/* 821C0850h case   13:*/		cpu::op::mulli<0>(regs,&regs.R10,regs.R23,0x28);
		/* 821C0850h case   13:*/		return 0x821C0854;
		  /* 821C0854h */ case   14:  		/* add R11, R10, R11 */
		/* 821C0854h case   14:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821C0854h case   14:*/		return 0x821C0858;
		  /* 821C0858h */ case   15:  		/* lwz R11, <#[R11 + 4]> */
		/* 821C0858h case   15:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821C0858h case   15:*/		return 0x821C085C;
		  /* 821C085Ch */ case   16:  		/* rlwinm R11, R11, 28, 29, 31 */
		/* 821C085Ch case   16:*/		cpu::op::rlwinm<0,28,29,31>(regs,&regs.R11,regs.R11);
		/* 821C085Ch case   16:*/		return 0x821C0860;
		  /* 821C0860h */ case   17:  		/* cmplwi CR6, R11, 2 */
		/* 821C0860h case   17:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000002);
		/* 821C0860h case   17:*/		return 0x821C0864;
		  /* 821C0864h */ case   18:  		/* bc 12, CR6_EQ, 12 */
		/* 821C0864h case   18:*/		if ( regs.CR[6].eq ) { return 0x821C0870;  }
		/* 821C0864h case   18:*/		return 0x821C0868;
		  /* 821C0868h */ case   19:  		/* cmplwi CR6, R11, 7 */
		/* 821C0868h case   19:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000007);
		/* 821C0868h case   19:*/		return 0x821C086C;
		  /* 821C086Ch */ case   20:  		/* bc 4, CR6_EQ, 412 */
		/* 821C086Ch case   20:*/		if ( !regs.CR[6].eq ) { return 0x821C0A08;  }
		/* 821C086Ch case   20:*/		return 0x821C0870;
	}
	return 0x821C0870;
} // Block from 821C081Ch-821C0870h (21 instructions)

//////////////////////////////////////////////////////
// Block at 821C0870h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C0870( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C0870) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C0870);
		  /* 821C0870h */ case    0:  		/* cmplwi CR6, R20, 1 */
		/* 821C0870h case    0:*/		cpu::op::cmplwi<6>(regs,regs.R20,0x00000001);
		/* 821C0870h case    0:*/		return 0x821C0874;
		  /* 821C0874h */ case    1:  		/* bc 12, CR6_GT, 404 */
		/* 821C0874h case    1:*/		if ( regs.CR[6].gt ) { return 0x821C0A08;  }
		/* 821C0874h case    1:*/		return 0x821C0878;
		  /* 821C0878h */ case    2:  		/* lwz R9, <#[R31]> */
		/* 821C0878h case    2:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R31 + 0x00000000) );
		/* 821C0878h case    2:*/		return 0x821C087C;
		  /* 821C087Ch */ case    3:  		/* li R25, 0 */
		/* 821C087Ch case    3:*/		cpu::op::li<0>(regs,&regs.R25,0x0);
		/* 821C087Ch case    3:*/		return 0x821C0880;
		  /* 821C0880h */ case    4:  		/* li R24, 1 */
		/* 821C0880h case    4:*/		cpu::op::li<0>(regs,&regs.R24,0x1);
		/* 821C0880h case    4:*/		return 0x821C0884;
		  /* 821C0884h */ case    5:  		/* rlwinm. R8, R9, 7, 29, 31 */
		/* 821C0884h case    5:*/		cpu::op::rlwinm<1,7,29,31>(regs,&regs.R8,regs.R9);
		/* 821C0884h case    5:*/		return 0x821C0888;
		  /* 821C0888h */ case    6:  		/* li R11, 0 */
		/* 821C0888h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821C0888h case    6:*/		return 0x821C088C;
		  /* 821C088Ch */ case    7:  		/* bc 12, CR0_EQ, 44 */
		/* 821C088Ch case    7:*/		if ( regs.CR[0].eq ) { return 0x821C08B8;  }
		/* 821C088Ch case    7:*/		return 0x821C0890;
		  /* 821C0890h */ case    8:  		/* li R10, 0 */
		/* 821C0890h case    8:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821C0890h case    8:*/		return 0x821C0894;
		  /* 821C0894h */ case    9:  		/* rlwinm R7, R9, 27, 24, 31 */
		/* 821C0894h case    9:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R7,regs.R9);
		/* 821C0894h case    9:*/		return 0x821C0898;
		  /* 821C0898h */ case   10:  		/* addi R11, R11, 1 */
		/* 821C0898h case   10:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821C0898h case   10:*/		return 0x821C089C;
		  /* 821C089Ch */ case   11:  		/* srw R7, R7, R10 */
		/* 821C089Ch case   11:*/		cpu::op::srw<0>(regs,&regs.R7,regs.R7,regs.R10);
		/* 821C089Ch case   11:*/		return 0x821C08A0;
		  /* 821C08A0h */ case   12:  		/* rlwinm R7, R7, 0, 30, 31 */
		/* 821C08A0h case   12:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R7,regs.R7);
		/* 821C08A0h case   12:*/		return 0x821C08A4;
		  /* 821C08A4h */ case   13:  		/* addi R10, R10, 2 */
		/* 821C08A4h case   13:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 821C08A4h case   13:*/		return 0x821C08A8;
		  /* 821C08A8h */ case   14:  		/* slw R7, R24, R7 */
		/* 821C08A8h case   14:*/		cpu::op::slw<0>(regs,&regs.R7,regs.R24,regs.R7);
		/* 821C08A8h case   14:*/		return 0x821C08AC;
		  /* 821C08ACh */ case   15:  		/* or R25, R7, R25 */
		/* 821C08ACh case   15:*/		cpu::op::or<0>(regs,&regs.R25,regs.R7,regs.R25);
		/* 821C08ACh case   15:*/		return 0x821C08B0;
		  /* 821C08B0h */ case   16:  		/* cmplw CR6, R11, R8 */
		/* 821C08B0h case   16:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R8);
		/* 821C08B0h case   16:*/		return 0x821C08B4;
		  /* 821C08B4h */ case   17:  		/* bc 12, CR6_LT, -32 */
		/* 821C08B4h case   17:*/		if ( regs.CR[6].lt ) { return 0x821C0894;  }
		/* 821C08B4h case   17:*/		return 0x821C08B8;
	}
	return 0x821C08B8;
} // Block from 821C0870h-821C08B8h (18 instructions)

//////////////////////////////////////////////////////
// Block at 821C08B8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C08B8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C08B8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C08B8);
		  /* 821C08B8h */ case    0:  		/* lwz R11, <#[R30 + 8]> */
		/* 821C08B8h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821C08B8h case    0:*/		return 0x821C08BC;
		  /* 821C08BCh */ case    1:  		/* mr R3, R27 */
		/* 821C08BCh case    1:*/		regs.R3 = regs.R27;
		/* 821C08BCh case    1:*/		return 0x821C08C0;
		  /* 821C08C0h */ case    2:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 821C08C0h case    2:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 821C08C0h case    2:*/		return 0x821C08C4;
		  /* 821C08C4h */ case    3:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 821C08C4h case    3:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 821C08C4h case    3:*/		return 0x821C08C8;
		  /* 821C08C8h */ case    4:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 821C08C8h case    4:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 821C08C8h case    4:*/		return 0x821C08CC;
		  /* 821C08CCh */ case    5:  		/* bl -378012 */
		/* 821C08CCh case    5:*/		regs.LR = 0x821C08D0; return 0x82164430;
		/* 821C08CCh case    5:*/		return 0x821C08D0;
		  /* 821C08D0h */ case    6:  		/* lwzx R11, <#[R3 + R28]> */
		/* 821C08D0h case    6:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + regs.R28 + 0x00000000) );
		/* 821C08D0h case    6:*/		return 0x821C08D4;
		  /* 821C08D4h */ case    7:  		/* cmplwi CR0, R29, 0 */
		/* 821C08D4h case    7:*/		cpu::op::cmplwi<0>(regs,regs.R29,0x00000000);
		/* 821C08D4h case    7:*/		return 0x821C08D8;
		  /* 821C08D8h */ case    8:  		/* rlwinm R28, R11, 17, 18, 31 */
		/* 821C08D8h case    8:*/		cpu::op::rlwinm<0,17,18,31>(regs,&regs.R28,regs.R11);
		/* 821C08D8h case    8:*/		return 0x821C08DC;
		  /* 821C08DCh */ case    9:  		/* bc 12, CR0_EQ, 192 */
		/* 821C08DCh case    9:*/		if ( regs.CR[0].eq ) { return 0x821C099C;  }
		/* 821C08DCh case    9:*/		return 0x821C08E0;
		  /* 821C08E0h */ case   10:  		/* lwz R10, <#[R29 + 4]> */
		/* 821C08E0h case   10:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R29 + 0x00000004) );
		/* 821C08E0h case   10:*/		return 0x821C08E4;
		  /* 821C08E4h */ case   11:  		/* li R9, 0 */
		/* 821C08E4h case   11:*/		cpu::op::li<0>(regs,&regs.R9,0x0);
		/* 821C08E4h case   11:*/		return 0x821C08E8;
		  /* 821C08E8h */ case   12:  		/* li R11, 0 */
		/* 821C08E8h case   12:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821C08E8h case   12:*/		return 0x821C08EC;
		  /* 821C08ECh */ case   13:  		/* lwz R10, <#[R10 + 48]> */
		/* 821C08ECh case   13:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000030) );
		/* 821C08ECh case   13:*/		return 0x821C08F0;
		  /* 821C08F0h */ case   14:  		/* lwz R8, <#[R10]> */
		/* 821C08F0h case   14:*/		cpu::mem::load32z( regs, &regs.R8, (uint32)(regs.R10 + 0x00000000) );
		/* 821C08F0h case   14:*/		return 0x821C08F4;
		  /* 821C08F4h */ case   15:  		/* lwz R30, <#[R10 + 12]> */
		/* 821C08F4h case   15:*/		cpu::mem::load32z( regs, &regs.R30, (uint32)(regs.R10 + 0x0000000C) );
		/* 821C08F4h case   15:*/		return 0x821C08F8;
		  /* 821C08F8h */ case   16:  		/* rlwinm. R7, R8, 7, 29, 31 */
		/* 821C08F8h case   16:*/		cpu::op::rlwinm<1,7,29,31>(regs,&regs.R7,regs.R8);
		/* 821C08F8h case   16:*/		return 0x821C08FC;
		  /* 821C08FCh */ case   17:  		/* bc 12, CR0_EQ, 44 */
		/* 821C08FCh case   17:*/		if ( regs.CR[0].eq ) { return 0x821C0928;  }
		/* 821C08FCh case   17:*/		return 0x821C0900;
		  /* 821C0900h */ case   18:  		/* li R10, 0 */
		/* 821C0900h case   18:*/		cpu::op::li<0>(regs,&regs.R10,0x0);
		/* 821C0900h case   18:*/		return 0x821C0904;
		  /* 821C0904h */ case   19:  		/* rlwinm R6, R8, 27, 24, 31 */
		/* 821C0904h case   19:*/		cpu::op::rlwinm<0,27,24,31>(regs,&regs.R6,regs.R8);
		/* 821C0904h case   19:*/		return 0x821C0908;
		  /* 821C0908h */ case   20:  		/* addi R11, R11, 1 */
		/* 821C0908h case   20:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821C0908h case   20:*/		return 0x821C090C;
		  /* 821C090Ch */ case   21:  		/* srw R6, R6, R10 */
		/* 821C090Ch case   21:*/		cpu::op::srw<0>(regs,&regs.R6,regs.R6,regs.R10);
		/* 821C090Ch case   21:*/		return 0x821C0910;
		  /* 821C0910h */ case   22:  		/* rlwinm R6, R6, 0, 30, 31 */
		/* 821C0910h case   22:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R6,regs.R6);
		/* 821C0910h case   22:*/		return 0x821C0914;
		  /* 821C0914h */ case   23:  		/* addi R10, R10, 2 */
		/* 821C0914h case   23:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x2);
		/* 821C0914h case   23:*/		return 0x821C0918;
		  /* 821C0918h */ case   24:  		/* slw R6, R24, R6 */
		/* 821C0918h case   24:*/		cpu::op::slw<0>(regs,&regs.R6,regs.R24,regs.R6);
		/* 821C0918h case   24:*/		return 0x821C091C;
		  /* 821C091Ch */ case   25:  		/* or R9, R6, R9 */
		/* 821C091Ch case   25:*/		cpu::op::or<0>(regs,&regs.R9,regs.R6,regs.R9);
		/* 821C091Ch case   25:*/		return 0x821C0920;
		  /* 821C0920h */ case   26:  		/* cmplw CR6, R11, R7 */
		/* 821C0920h case   26:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R7);
		/* 821C0920h case   26:*/		return 0x821C0924;
		  /* 821C0924h */ case   27:  		/* bc 12, CR6_LT, -32 */
		/* 821C0924h case   27:*/		if ( regs.CR[6].lt ) { return 0x821C0904;  }
		/* 821C0924h case   27:*/		return 0x821C0928;
	}
	return 0x821C0928;
} // Block from 821C08B8h-821C0928h (28 instructions)

//////////////////////////////////////////////////////
// Block at 821C0928h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C0928( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C0928) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C0928);
		  /* 821C0928h */ case    0:  		/* cmplw CR6, R9, R25 */
		/* 821C0928h case    0:*/		cpu::op::cmplw<6>(regs,regs.R9,regs.R25);
		/* 821C0928h case    0:*/		return 0x821C092C;
		  /* 821C092Ch */ case    1:  		/* bc 4, CR6_EQ, 220 */
		/* 821C092Ch case    1:*/		if ( !regs.CR[6].eq ) { return 0x821C0A08;  }
		/* 821C092Ch case    1:*/		return 0x821C0930;
		  /* 821C0930h */ case    2:  		/* lwz R11, <#[R30 + 8]> */
		/* 821C0930h case    2:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821C0930h case    2:*/		return 0x821C0934;
		  /* 821C0934h */ case    3:  		/* mr R3, R27 */
		/* 821C0934h case    3:*/		regs.R3 = regs.R27;
		/* 821C0934h case    3:*/		return 0x821C0938;
		  /* 821C0938h */ case    4:  		/* addi R31, R30, -8 */
		/* 821C0938h case    4:*/		cpu::op::addi<0>(regs,&regs.R31,regs.R30,0xFFFFFFF8);
		/* 821C0938h case    4:*/		return 0x821C093C;
		  /* 821C093Ch */ case    5:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 821C093Ch case    5:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 821C093Ch case    5:*/		return 0x821C0940;
		  /* 821C0940h */ case    6:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 821C0940h case    6:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 821C0940h case    6:*/		return 0x821C0944;
		  /* 821C0944h */ case    7:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 821C0944h case    7:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 821C0944h case    7:*/		return 0x821C0948;
		  /* 821C0948h */ case    8:  		/* bl -378136 */
		/* 821C0948h case    8:*/		regs.LR = 0x821C094C; return 0x82164430;
		/* 821C0948h case    8:*/		return 0x821C094C;
		  /* 821C094Ch */ case    9:  		/* lwzx R11, <#[R3 + R31]> */
		/* 821C094Ch case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + regs.R31 + 0x00000000) );
		/* 821C094Ch case    9:*/		return 0x821C0950;
		  /* 821C0950h */ case   10:  		/* rlwinm R11, R11, 0, 17, 31 */
		/* 821C0950h case   10:*/		cpu::op::rlwinm<0,0,17,31>(regs,&regs.R11,regs.R11);
		/* 821C0950h case   10:*/		return 0x821C0954;
		  /* 821C0954h */ case   11:  		/* cmplw CR6, R11, R23 */
		/* 821C0954h case   11:*/		cpu::op::cmplw<6>(regs,regs.R11,regs.R23);
		/* 821C0954h case   11:*/		return 0x821C0958;
		  /* 821C0958h */ case   12:  		/* bc 4, CR6_EQ, 176 */
		/* 821C0958h case   12:*/		if ( !regs.CR[6].eq ) { return 0x821C0A08;  }
		/* 821C0958h case   12:*/		return 0x821C095C;
		  /* 821C095Ch */ case   13:  		/* lwz R11, <#[R30 + 8]> */
		/* 821C095Ch case   13:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R30 + 0x00000008) );
		/* 821C095Ch case   13:*/		return 0x821C0960;
		  /* 821C0960h */ case   14:  		/* mr R3, R27 */
		/* 821C0960h case   14:*/		regs.R3 = regs.R27;
		/* 821C0960h case   14:*/		return 0x821C0964;
		  /* 821C0964h */ case   15:  		/* rlwinm R6, R11, 18, 29, 31 */
		/* 821C0964h case   15:*/		cpu::op::rlwinm<0,18,29,31>(regs,&regs.R6,regs.R11);
		/* 821C0964h case   15:*/		return 0x821C0968;
		  /* 821C0968h */ case   16:  		/* rlwinm R5, R11, 13, 29, 31 */
		/* 821C0968h case   16:*/		cpu::op::rlwinm<0,13,29,31>(regs,&regs.R5,regs.R11);
		/* 821C0968h case   16:*/		return 0x821C096C;
		  /* 821C096Ch */ case   17:  		/* rlwinm R4, R11, 25, 25, 31 */
		/* 821C096Ch case   17:*/		cpu::op::rlwinm<0,25,25,31>(regs,&regs.R4,regs.R11);
		/* 821C096Ch case   17:*/		return 0x821C0970;
		  /* 821C0970h */ case   18:  		/* bl -378176 */
		/* 821C0970h case   18:*/		regs.LR = 0x821C0974; return 0x82164430;
		/* 821C0970h case   18:*/		return 0x821C0974;
		  /* 821C0974h */ case   19:  		/* lwz R11, <#[R29]> */
		/* 821C0974h case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R29 + 0x00000000) );
		/* 821C0974h case   19:*/		return 0x821C0978;
		  /* 821C0978h */ case   20:  		/* lwzx R10, <#[R3 + R31]> */
		/* 821C0978h case   20:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R3 + regs.R31 + 0x00000000) );
		/* 821C0978h case   20:*/		return 0x821C097C;
		  /* 821C097Ch */ case   21:  		/* subf R11, R22, R11 */
		/* 821C097Ch case   21:*/		cpu::op::subf<0>(regs,&regs.R11,regs.R22,regs.R11);
		/* 821C097Ch case   21:*/		return 0x821C0980;
		  /* 821C0980h */ case   22:  		/* rlwinm R10, R10, 17, 18, 31 */
		/* 821C0980h case   22:*/		cpu::op::rlwinm<0,17,18,31>(regs,&regs.R10,regs.R10);
		/* 821C0980h case   22:*/		return 0x821C0984;
		  /* 821C0984h */ case   23:  		/* add R11, R11, R28 */
		/* 821C0984h case   23:*/		cpu::op::add<0>(regs,&regs.R11,regs.R11,regs.R28);
		/* 821C0984h case   23:*/		return 0x821C0988;
		  /* 821C0988h */ case   24:  		/* cmplw CR6, R10, R11 */
		/* 821C0988h case   24:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R11);
		/* 821C0988h case   24:*/		return 0x821C098C;
		  /* 821C098Ch */ case   25:  		/* bc 4, CR6_EQ, 124 */
		/* 821C098Ch case   25:*/		if ( !regs.CR[6].eq ) { return 0x821C0A08;  }
		/* 821C098Ch case   25:*/		return 0x821C0990;
		  /* 821C0990h */ case   26:  		/* lwz R29, <#[R29 + 8]> */
		/* 821C0990h case   26:*/		cpu::mem::load32z( regs, &regs.R29, (uint32)(regs.R29 + 0x00000008) );
		/* 821C0990h case   26:*/		return 0x821C0994;
		  /* 821C0994h */ case   27:  		/* cmplwi CR6, R29, 0 */
		/* 821C0994h case   27:*/		cpu::op::cmplwi<6>(regs,regs.R29,0x00000000);
		/* 821C0994h case   27:*/		return 0x821C0998;
		  /* 821C0998h */ case   28:  		/* bc 4, CR6_EQ, -184 */
		/* 821C0998h case   28:*/		if ( !regs.CR[6].eq ) { return 0x821C08E0;  }
		/* 821C0998h case   28:*/		return 0x821C099C;
	}
	return 0x821C099C;
} // Block from 821C0928h-821C099Ch (29 instructions)

//////////////////////////////////////////////////////
// Block at 821C099Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C099C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C099C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C099C);
		  /* 821C099Ch */ case    0:  		/* rldicl R10, R22, 0, 32 */
		/* 821C099Ch case    0:*/		cpu::op::rldicl<0,0,32>(regs,&regs.R10,regs.R22);
		/* 821C099Ch case    0:*/		return 0x821C09A0;
		  /* 821C09A0h */ case    1:  		/* lfd FR0, <#[R19 + 8]> */
		/* 821C09A0h case    1:*/		cpu::mem::load64f( regs, &regs.FR0, (uint32)(regs.R19 + 0x00000008) );
		/* 821C09A0h case    1:*/		return 0x821C09A4;
		  /* 821C09A4h */ case    2:  		/* mr R11, R20 */
		/* 821C09A4h case    2:*/		regs.R11 = regs.R20;
		/* 821C09A4h case    2:*/		return 0x821C09A8;
		  /* 821C09A8h */ case    3:  		/* std R10, <#[R1 + 80]> */
		/* 821C09A8h case    3:*/		cpu::mem::store64( regs, regs.R10, (uint32)(regs.R1 + 0x00000050) );
		/* 821C09A8h case    3:*/		return 0x821C09AC;
		  /* 821C09ACh */ case    4:  		/* lfd FR13, <#[R1 + 80]> */
		/* 821C09ACh case    4:*/		cpu::mem::load64f( regs, &regs.FR13, (uint32)(regs.R1 + 0x00000050) );
		/* 821C09ACh case    4:*/		return 0x821C09B0;
		  /* 821C09B0h */ case    5:  		/* fcfid FR13, FR13 */
		/* 821C09B0h case    5:*/		cpu::op::fcfid<0>(regs,&regs.FR13,regs.FR13);
		/* 821C09B0h case    5:*/		return 0x821C09B4;
		  /* 821C09B4h */ case    6:  		/* frsp FR13, FR13 */
		/* 821C09B4h case    6:*/		cpu::op::frsp<0>(regs,&regs.FR13,regs.FR13);
		/* 821C09B4h case    6:*/		return 0x821C09B8;
		  /* 821C09B8h */ case    7:  		/* fcmpu CR6, FR13, FR0 */
		/* 821C09B8h case    7:*/		cpu::op::fcmpu<6>(regs,regs.FR13,regs.FR0);
		/* 821C09B8h case    7:*/		return 0x821C09BC;
		  /* 821C09BCh */ case    8:  		/* bc 4, CR6_GT, 8 */
		/* 821C09BCh case    8:*/		if ( !regs.CR[6].gt ) { return 0x821C09C4;  }
		/* 821C09BCh case    8:*/		return 0x821C09C0;
		  /* 821C09C0h */ case    9:  		/* addi R11, R20, 1 */
		/* 821C09C0h case    9:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R20,0x1);
		/* 821C09C0h case    9:*/		return 0x821C09C4;
	}
	return 0x821C09C4;
} // Block from 821C099Ch-821C09C4h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821C09C4h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C09C4( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C09C4) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C09C4);
		  /* 821C09C4h */ case    0:  		/* lwz R9, <#[R19 + 4]> */
		/* 821C09C4h case    0:*/		cpu::mem::load32z( regs, &regs.R9, (uint32)(regs.R19 + 0x00000004) );
		/* 821C09C4h case    0:*/		return 0x821C09C8;
		  /* 821C09C8h */ case    1:  		/* subf R10, R22, R21 */
		/* 821C09C8h case    1:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R22,regs.R21);
		/* 821C09C8h case    1:*/		return 0x821C09CC;
		  /* 821C09CCh */ case    2:  		/* addi R10, R10, 1 */
		/* 821C09CCh case    2:*/		cpu::op::addi<0>(regs,&regs.R10,regs.R10,0x1);
		/* 821C09CCh case    2:*/		return 0x821C09D0;
		  /* 821C09D0h */ case    3:  		/* rlwinm R9, R9, 0, 17, 31 */
		/* 821C09D0h case    3:*/		cpu::op::rlwinm<0,0,17,31>(regs,&regs.R9,regs.R9);
		/* 821C09D0h case    3:*/		return 0x821C09D4;
		  /* 821C09D4h */ case    4:  		/* cmplw CR6, R10, R9 */
		/* 821C09D4h case    4:*/		cpu::op::cmplw<6>(regs,regs.R10,regs.R9);
		/* 821C09D4h case    4:*/		return 0x821C09D8;
		  /* 821C09D8h */ case    5:  		/* bc 4, CR6_LT, 8 */
		/* 821C09D8h case    5:*/		if ( !regs.CR[6].lt ) { return 0x821C09E0;  }
		/* 821C09D8h case    5:*/		return 0x821C09DC;
		  /* 821C09DCh */ case    6:  		/* addi R11, R11, 1 */
		/* 821C09DCh case    6:*/		cpu::op::addi<0>(regs,&regs.R11,regs.R11,0x1);
		/* 821C09DCh case    6:*/		return 0x821C09E0;
	}
	return 0x821C09E0;
} // Block from 821C09C4h-821C09E0h (7 instructions)

//////////////////////////////////////////////////////
// Block at 821C09E0h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C09E0( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C09E0) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C09E0);
		  /* 821C09E0h */ case    0:  		/* lwz R10, <#[R26 + 16]> */
		/* 821C09E0h case    0:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R26 + 0x00000010) );
		/* 821C09E0h case    0:*/		return 0x821C09E4;
		  /* 821C09E4h */ case    1:  		/* mr R9, R11 */
		/* 821C09E4h case    1:*/		regs.R9 = regs.R11;
		/* 821C09E4h case    1:*/		return 0x821C09E8;
		  /* 821C09E8h */ case    2:  		/* oris R8, R18, 1024 */
		/* 821C09E8h case    2:*/		cpu::op::oris<0>(regs,&regs.R8,regs.R18,0x400);
		/* 821C09E8h case    2:*/		return 0x821C09EC;
		  /* 821C09ECh */ case    3:  		/* rlwimi R9, R10, 0, 0, 18 */
		/* 821C09ECh case    3:*/		cpu::op::rlwimi<0,0,0,18>(regs,&regs.R9,regs.R10);
		/* 821C09ECh case    3:*/		return 0x821C09F0;
		  /* 821C09F0h */ case    4:  		/* subf R10, R11, R17 */
		/* 821C09F0h case    4:*/		cpu::op::subf<0>(regs,&regs.R10,regs.R11,regs.R17);
		/* 821C09F0h case    4:*/		return 0x821C09F4;
		  /* 821C09F4h */ case    5:  		/* stw R8, <#[R26 + 12]> */
		/* 821C09F4h case    5:*/		cpu::mem::store32( regs, regs.R8, (uint32)(regs.R26 + 0x0000000C) );
		/* 821C09F4h case    5:*/		return 0x821C09F8;
		  /* 821C09F8h */ case    6:  		/* stw R9, <#[R26 + 16]> */
		/* 821C09F8h case    6:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R26 + 0x00000010) );
		/* 821C09F8h case    6:*/		return 0x821C09FC;
		  /* 821C09FCh */ case    7:  		/* lwz R11, <#[R19 + 76]> */
		/* 821C09FCh case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R19 + 0x0000004C) );
		/* 821C09FCh case    7:*/		return 0x821C0A00;
		  /* 821C0A00h */ case    8:  		/* add R11, R10, R11 */
		/* 821C0A00h case    8:*/		cpu::op::add<0>(regs,&regs.R11,regs.R10,regs.R11);
		/* 821C0A00h case    8:*/		return 0x821C0A04;
		  /* 821C0A04h */ case    9:  		/* stw R11, <#[R19 + 76]> */
		/* 821C0A04h case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R19 + 0x0000004C) );
		/* 821C0A04h case    9:*/		return 0x821C0A08;
	}
	return 0x821C0A08;
} // Block from 821C09E0h-821C0A08h (10 instructions)

//////////////////////////////////////////////////////
// Block at 821C0A08h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C0A08( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C0A08) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C0A08);
		  /* 821C0A08h */ case    0:  		/* addi R1, R1, 224 */
		/* 821C0A08h case    0:*/		cpu::op::addi<0>(regs,&regs.R1,regs.R1,0xE0);
		/* 821C0A08h case    0:*/		return 0x821C0A0C;
		  /* 821C0A0Ch */ case    1:  		/* b -1243024 */
		/* 821C0A0Ch case    1:*/		return 0x8209127C;
		/* 821C0A0Ch case    1:*/		return 0x821C0A10;
	}
	return 0x821C0A10;
} // Block from 821C0A08h-821C0A10h (2 instructions)

//////////////////////////////////////////////////////
// Block at 821C0A10h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C0A10( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C0A10) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C0A10);
		  /* 821C0A10h */ case    0:  		/* mfspr R12, LR */
		/* 821C0A10h case    0:*/		regs.R12 = regs.LR;
		/* 821C0A10h case    0:*/		return 0x821C0A14;
		  /* 821C0A14h */ case    1:  		/* bl -1243100 */
		/* 821C0A14h case    1:*/		regs.LR = 0x821C0A18; return 0x82091238;
		/* 821C0A14h case    1:*/		return 0x821C0A18;
		  /* 821C0A18h */ case    2:  		/* stwu R1, <#[R1 - 256]> */
		/* 821C0A18h case    2:*/		cpu::mem::store32( regs, regs.R1, (uint32)(regs.R1 + 0xFFFFFF00) );
		regs.R1 = (uint32)(regs.R1 + 0xFFFFFF00);
		/* 821C0A18h case    2:*/		return 0x821C0A1C;
		  /* 821C0A1Ch */ case    3:  		/* lwz R11, <#[R5]> */
		/* 821C0A1Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R5 + 0x00000000) );
		/* 821C0A1Ch case    3:*/		return 0x821C0A20;
		  /* 821C0A20h */ case    4:  		/* mr R22, R4 */
		/* 821C0A20h case    4:*/		regs.R22 = regs.R4;
		/* 821C0A20h case    4:*/		return 0x821C0A24;
		  /* 821C0A24h */ case    5:  		/* mr R29, R3 */
		/* 821C0A24h case    5:*/		regs.R29 = regs.R3;
		/* 821C0A24h case    5:*/		return 0x821C0A28;
		  /* 821C0A28h */ case    6:  		/* mr R31, R5 */
		/* 821C0A28h case    6:*/		regs.R31 = regs.R5;
		/* 821C0A28h case    6:*/		return 0x821C0A2C;
		  /* 821C0A2Ch */ case    7:  		/* mr R20, R6 */
		/* 821C0A2Ch case    7:*/		regs.R20 = regs.R6;
		/* 821C0A2Ch case    7:*/		return 0x821C0A30;
		  /* 821C0A30h */ case    8:  		/* lwz R4, <#[R11 + 120]> */
		/* 821C0A30h case    8:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R11 + 0x00000078) );
		/* 821C0A30h case    8:*/		return 0x821C0A34;
		  /* 821C0A34h */ case    9:  		/* bl 176908 */
		/* 821C0A34h case    9:*/		regs.LR = 0x821C0A38; return 0x821EBD40;
		/* 821C0A34h case    9:*/		return 0x821C0A38;
		  /* 821C0A38h */ case   10:  		/* lwz R11, <#[R3]> */
		/* 821C0A38h case   10:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x00000000) );
		/* 821C0A38h case   10:*/		return 0x821C0A3C;
		  /* 821C0A3Ch */ case   11:  		/* lwz R11, <#[R11 + 4]> */
		/* 821C0A3Ch case   11:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821C0A3Ch case   11:*/		return 0x821C0A40;
		  /* 821C0A40h */ case   12:  		/* mtspr CTR, R11 */
		/* 821C0A40h case   12:*/		regs.CTR = regs.R11;
		/* 821C0A40h case   12:*/		return 0x821C0A44;
		  /* 821C0A44h */ case   13:  		/* bcctrl 20, CR0_LT */
		/* 821C0A44h case   13:*/		if ( 1 ) { regs.LR = 0x821C0A48; return (uint32)regs.CTR; }
		/* 821C0A44h case   13:*/		return 0x821C0A48;
		  /* 821C0A48h */ case   14:  		/* or. R25, R3, R3 */
		/* 821C0A48h case   14:*/		cpu::op::or<1>(regs,&regs.R25,regs.R3,regs.R3);
		/* 821C0A48h case   14:*/		return 0x821C0A4C;
		  /* 821C0A4Ch */ case   15:  		/* mr R26, R25 */
		/* 821C0A4Ch case   15:*/		regs.R26 = regs.R25;
		/* 821C0A4Ch case   15:*/		return 0x821C0A50;
		  /* 821C0A50h */ case   16:  		/* bc 12, CR0_EQ, 376 */
		/* 821C0A50h case   16:*/		if ( regs.CR[0].eq ) { return 0x821C0BC8;  }
		/* 821C0A50h case   16:*/		return 0x821C0A54;
		  /* 821C0A54h */ case   17:  		/* addi R23, R31, 4 */
		/* 821C0A54h case   17:*/		cpu::op::addi<0>(regs,&regs.R23,regs.R31,0x4);
		/* 821C0A54h case   17:*/		return 0x821C0A58;
		  /* 821C0A58h */ case   18:  		/* li R24, 3 */
		/* 821C0A58h case   18:*/		cpu::op::li<0>(regs,&regs.R24,0x3);
		/* 821C0A58h case   18:*/		return 0x821C0A5C;
		  /* 821C0A5Ch */ case   19:  		/* li R21, 24 */
		/* 821C0A5Ch case   19:*/		cpu::op::li<0>(regs,&regs.R21,0x18);
		/* 821C0A5Ch case   19:*/		return 0x821C0A60;
		  /* 821C0A60h */ case   20:  		/* mr R3, R29 */
		/* 821C0A60h case   20:*/		regs.R3 = regs.R29;
		/* 821C0A60h case   20:*/		return 0x821C0A64;
		  /* 821C0A64h */ case   21:  		/* lwz R4, <#[R26 + 8]> */
		/* 821C0A64h case   21:*/		cpu::mem::load32z( regs, &regs.R4, (uint32)(regs.R26 + 0x00000008) );
		/* 821C0A64h case   21:*/		return 0x821C0A68;
		  /* 821C0A68h */ case   22:  		/* bl 176856 */
		/* 821C0A68h case   22:*/		regs.LR = 0x821C0A6C; return 0x821EBD40;
		/* 821C0A68h case   22:*/		return 0x821C0A6C;
		  /* 821C0A6Ch */ case   23:  		/* lwz R11, <#[R3 + 12]> */
		/* 821C0A6Ch case   23:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R3 + 0x0000000C) );
		/* 821C0A6Ch case   23:*/		return 0x821C0A70;
		  /* 821C0A70h */ case   24:  		/* mr R27, R3 */
		/* 821C0A70h case   24:*/		regs.R27 = regs.R3;
		/* 821C0A70h case   24:*/		return 0x821C0A74;
		  /* 821C0A74h */ case   25:  		/* cmplwi CR6, R11, 0 */
		/* 821C0A74h case   25:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000000);
		/* 821C0A74h case   25:*/		return 0x821C0A78;
		  /* 821C0A78h */ case   26:  		/* bc 12, CR6_EQ, 316 */
		/* 821C0A78h case   26:*/		if ( regs.CR[6].eq ) { return 0x821C0BB4;  }
		/* 821C0A78h case   26:*/		return 0x821C0A7C;
		  /* 821C0A7Ch */ case   27:  		/* lwz R11, <#[R11 + 4]> */
		/* 821C0A7Ch case   27:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000004) );
		/* 821C0A7Ch case   27:*/		return 0x821C0A80;
	}
	return 0x821C0A80;
} // Block from 821C0A10h-821C0A80h (28 instructions)

//////////////////////////////////////////////////////
// Block at 821C0A80h
// Function '?LinkIdenticalInstructions@Compiler@D3DXShader@@AAA_NPAV?$DoubleLinkList@VInstruction@D3DXShader@@$0CE@@2@0@Z'
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C0A80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C0A80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C0A80);
		  /* 821C0A80h */ case    0:  		/* cmpwi CR6, R11, 3 */
		/* 821C0A80h case    0:*/		cpu::op::cmpwi<6>(regs,regs.R11,0x00000003);
		/* 821C0A80h case    0:*/		return 0x821C0A84;
		  /* 821C0A84h */ case    1:  		/* bc 12, CR6_EQ, 304 */
		/* 821C0A84h case    1:*/		if ( regs.CR[6].eq ) { return 0x821C0BB4;  }
		/* 821C0A84h case    1:*/		return 0x821C0A88;
		  /* 821C0A88h */ case    2:  		/* lwzu R28, <#[R23 + 4]> */
		/* 821C0A88h case    2:*/		cpu::mem::load32z( regs, &regs.R28, (uint32)(regs.R23 + 0x00000004) );
		regs.R23 = (uint32)(regs.R23 + 0x00000004);
		/* 821C0A88h case    2:*/		return 0x821C0A8C;
		  /* 821C0A8Ch */ case    3:  		/* lwz R11, <#[R28 + 12]> */
		/* 821C0A8Ch case    3:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R28 + 0x0000000C) );
		/* 821C0A8Ch case    3:*/		return 0x821C0A90;
		  /* 821C0A90h */ case    4:  		/* stw R11, <#[R1 + 80]> */
		/* 821C0A90h case    4:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 821C0A90h case    4:*/		return 0x821C0A94;
		  /* 821C0A94h */ case    5:  		/* lwz R10, <#[R28]> */
		/* 821C0A94h case    5:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R28 + 0x00000000) );
		/* 821C0A94h case    5:*/		return 0x821C0A98;
		  /* 821C0A98h */ case    6:  		/* rlwinm R9, R10, 0, 27, 31 */
		/* 821C0A98h case    6:*/		cpu::op::rlwinm<0,0,27,31>(regs,&regs.R9,regs.R10);
		/* 821C0A98h case    6:*/		return 0x821C0A9C;
		  /* 821C0A9Ch */ case    7:  		/* stw R9, <#[R1 + 84]> */
		/* 821C0A9Ch case    7:*/		cpu::mem::store32( regs, regs.R9, (uint32)(regs.R1 + 0x00000054) );
		/* 821C0A9Ch case    7:*/		return 0x821C0AA0;
		  /* 821C0AA0h */ case    8:  		/* rlwinm R30, R10, 27, 30, 31 */
		/* 821C0AA0h case    8:*/		cpu::op::rlwinm<0,27,30,31>(regs,&regs.R30,regs.R10);
		/* 821C0AA0h case    8:*/		return 0x821C0AA4;
		  /* 821C0AA4h */ case    9:  		/* lwz R11, <#[R11 + 8]> */
		/* 821C0AA4h case    9:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821C0AA4h case    9:*/		return 0x821C0AA8;
		  /* 821C0AA8h */ case   10:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821C0AA8h case   10:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821C0AA8h case   10:*/		return 0x821C0AAC;
		  /* 821C0AACh */ case   11:  		/* cmplwi CR6, R11, 16000 */
		/* 821C0AACh case   11:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E80);
		/* 821C0AACh case   11:*/		return 0x821C0AB0;
		  /* 821C0AB0h */ case   12:  		/* bc 12, CR6_EQ, 56 */
		/* 821C0AB0h case   12:*/		if ( regs.CR[6].eq ) { return 0x821C0AE8;  }
		/* 821C0AB0h case   12:*/		return 0x821C0AB4;
		  /* 821C0AB4h */ case   13:  		/* addi R7, R1, 84 */
		/* 821C0AB4h case   13:*/		cpu::op::addi<0>(regs,&regs.R7,regs.R1,0x54);
		/* 821C0AB4h case   13:*/		return 0x821C0AB8;
		  /* 821C0AB8h */ case   14:  		/* addi R6, R1, 88 */
		/* 821C0AB8h case   14:*/		cpu::op::addi<0>(regs,&regs.R6,regs.R1,0x58);
		/* 821C0AB8h case   14:*/		return 0x821C0ABC;
		  /* 821C0ABCh */ case   15:  		/* addi R5, R1, 80 */
		/* 821C0ABCh case   15:*/		cpu::op::addi<0>(regs,&regs.R5,regs.R1,0x50);
		/* 821C0ABCh case   15:*/		return 0x821C0AC0;
		  /* 821C0AC0h */ case   16:  		/* mr R4, R28 */
		/* 821C0AC0h case   16:*/		regs.R4 = regs.R28;
		/* 821C0AC0h case   16:*/		return 0x821C0AC4;
		  /* 821C0AC4h */ case   17:  		/* mr R3, R29 */
		/* 821C0AC4h case   17:*/		regs.R3 = regs.R29;
		/* 821C0AC4h case   17:*/		return 0x821C0AC8;
		  /* 821C0AC8h */ case   18:  		/* bl 452656 */
		/* 821C0AC8h case   18:*/		regs.LR = 0x821C0ACC; return 0x8222F2F8;
		/* 821C0AC8h case   18:*/		return 0x821C0ACC;
		  /* 821C0ACCh */ case   19:  		/* lwz R11, <#[R1 + 80]> */
		/* 821C0ACCh case   19:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 821C0ACCh case   19:*/		return 0x821C0AD0;
		  /* 821C0AD0h */ case   20:  		/* lwz R11, <#[R11 + 8]> */
		/* 821C0AD0h case   20:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000008) );
		/* 821C0AD0h case   20:*/		return 0x821C0AD4;
		  /* 821C0AD4h */ case   21:  		/* rlwinm R11, R11, 0, 18, 24 */
		/* 821C0AD4h case   21:*/		cpu::op::rlwinm<0,0,18,24>(regs,&regs.R11,regs.R11);
		/* 821C0AD4h case   21:*/		return 0x821C0AD8;
		  /* 821C0AD8h */ case   22:  		/* cmplwi CR6, R11, 16000 */
		/* 821C0AD8h case   22:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00003E80);
		/* 821C0AD8h case   22:*/		return 0x821C0ADC;
		  /* 821C0ADCh */ case   23:  		/* bc 4, CR6_EQ, 252 */
		/* 821C0ADCh case   23:*/		if ( !regs.CR[6].eq ) { return 0x821C0BD8;  }
		/* 821C0ADCh case   23:*/		return 0x821C0AE0;
		  /* 821C0AE0h */ case   24:  		/* lwz R11, <#[R1 + 88]> */
		/* 821C0AE0h case   24:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000058) );
		/* 821C0AE0h case   24:*/		return 0x821C0AE4;
		  /* 821C0AE4h */ case   25:  		/* rlwinm R30, R11, 0, 30, 31 */
		/* 821C0AE4h case   25:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R30,regs.R11);
		/* 821C0AE4h case   25:*/		return 0x821C0AE8;
	}
	return 0x821C0AE8;
} // Block from 821C0A80h-821C0AE8h (26 instructions)

//////////////////////////////////////////////////////
// Block at 821C0AE8h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C0AE8( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C0AE8) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C0AE8);
		  /* 821C0AE8h */ case    0:  		/* li R5, 17 */
		/* 821C0AE8h case    0:*/		cpu::op::li<0>(regs,&regs.R5,0x11);
		/* 821C0AE8h case    0:*/		return 0x821C0AEC;
		  /* 821C0AECh */ case    1:  		/* li R4, 56 */
		/* 821C0AECh case    1:*/		cpu::op::li<0>(regs,&regs.R4,0x38);
		/* 821C0AECh case    1:*/		return 0x821C0AF0;
		  /* 821C0AF0h */ case    2:  		/* mr R3, R29 */
		/* 821C0AF0h case    2:*/		regs.R3 = regs.R29;
		/* 821C0AF0h case    2:*/		return 0x821C0AF4;
		  /* 821C0AF4h */ case    3:  		/* bl -343884 */
		/* 821C0AF4h case    3:*/		regs.LR = 0x821C0AF8; return 0x8216CBA8;
		/* 821C0AF4h case    3:*/		return 0x821C0AF8;
		  /* 821C0AF8h */ case    4:  		/* mr R31, R3 */
		/* 821C0AF8h case    4:*/		regs.R31 = regs.R3;
		/* 821C0AF8h case    4:*/		return 0x821C0AFC;
		  /* 821C0AFCh */ case    5:  		/* addi R3, R1, 96 */
		/* 821C0AFCh case    5:*/		cpu::op::addi<0>(regs,&regs.R3,regs.R1,0x60);
		/* 821C0AFCh case    5:*/		return 0x821C0B00;
		  /* 821C0B00h */ case    6:  		/* bl -1012440 */
		/* 821C0B00h case    6:*/		regs.LR = 0x821C0B04; return 0x820C9828;
		/* 821C0B00h case    6:*/		return 0x821C0B04;
		  /* 821C0B04h */ case    7:  		/* lwz R11, <#[R1 + 96]> */
		/* 821C0B04h case    7:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000060) );
		/* 821C0B04h case    7:*/		return 0x821C0B08;
		  /* 821C0B08h */ case    8:  		/* mr R4, R30 */
		/* 821C0B08h case    8:*/		regs.R4 = regs.R30;
		/* 821C0B08h case    8:*/		return 0x821C0B0C;
		  /* 821C0B0Ch */ case    9:  		/* stw R11, <#[R31]> */
		/* 821C0B0Ch case    9:*/		cpu::mem::store32( regs, regs.R11, (uint32)(regs.R31 + 0x00000000) );
		/* 821C0B0Ch case    9:*/		return 0x821C0B10;
		  /* 821C0B10h */ case   10:  		/* lwz R5, <#[R1 + 84]> */
		/* 821C0B10h case   10:*/		cpu::mem::load32z( regs, &regs.R5, (uint32)(regs.R1 + 0x00000054) );
		/* 821C0B10h case   10:*/		return 0x821C0B14;
		  /* 821C0B14h */ case   11:  		/* lwz R3, <#[R1 + 80]> */
		/* 821C0B14h case   11:*/		cpu::mem::load32z( regs, &regs.R3, (uint32)(regs.R1 + 0x00000050) );
		/* 821C0B14h case   11:*/		return 0x821C0B18;
		  /* 821C0B18h */ case   12:  		/* bl 396168 */
		/* 821C0B18h case   12:*/		regs.LR = 0x821C0B1C; return 0x822216A0;
		/* 821C0B18h case   12:*/		return 0x821C0B1C;
		  /* 821C0B1Ch */ case   13:  		/* stw R24, <#[R31 + 4]> */
		/* 821C0B1Ch case   13:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00000004) );
		/* 821C0B1Ch case   13:*/		return 0x821C0B20;
		  /* 821C0B20h */ case   14:  		/* lwz R11, <#[R1 + 80]> */
		/* 821C0B20h case   14:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R1 + 0x00000050) );
		/* 821C0B20h case   14:*/		return 0x821C0B24;
		  /* 821C0B24h */ case   15:  		/* rlwinm R10, R11, 0, 0, 19 */
		/* 821C0B24h case   15:*/		cpu::op::rlwinm<0,0,0,19>(regs,&regs.R10,regs.R11);
		/* 821C0B24h case   15:*/		return 0x821C0B28;
		  /* 821C0B28h */ case   16:  		/* lwz R10, <#[R10]> */
		/* 821C0B28h case   16:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000000) );
		/* 821C0B28h case   16:*/		return 0x821C0B2C;
		  /* 821C0B2Ch */ case   17:  		/* lwz R10, <#[R10 + 148]> */
		/* 821C0B2Ch case   17:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000094) );
		/* 821C0B2Ch case   17:*/		return 0x821C0B30;
		  /* 821C0B30h */ case   18:  		/* lwz R10, <#[R10 + 40]> */
		/* 821C0B30h case   18:*/		cpu::mem::load32z( regs, &regs.R10, (uint32)(regs.R10 + 0x00000028) );
		/* 821C0B30h case   18:*/		return 0x821C0B34;
		  /* 821C0B34h */ case   19:  		/* nor R10, R10, R10 */
		/* 821C0B34h case   19:*/		cpu::op::nor<0>(regs,&regs.R10,regs.R10,regs.R10);
		/* 821C0B34h case   19:*/		return 0x821C0B38;
		  /* 821C0B38h */ case   20:  		/* rlwinm. R10, R10, 18, 31, 31 */
		/* 821C0B38h case   20:*/		cpu::op::rlwinm<1,18,31,31>(regs,&regs.R10,regs.R10);
		/* 821C0B38h case   20:*/		return 0x821C0B3C;
		  /* 821C0B3Ch */ case   21:  		/* bc 4, CR0_EQ, 12 */
		/* 821C0B3Ch case   21:*/		if ( !regs.CR[0].eq ) { return 0x821C0B48;  }
		/* 821C0B3Ch case   21:*/		return 0x821C0B40;
		  /* 821C0B40h */ case   22:  		/* li R11, 0 */
		/* 821C0B40h case   22:*/		cpu::op::li<0>(regs,&regs.R11,0x0);
		/* 821C0B40h case   22:*/		return 0x821C0B44;
		  /* 821C0B44h */ case   23:  		/* b 24 */
		/* 821C0B44h case   23:*/		return 0x821C0B5C;
		/* 821C0B44h case   23:*/		return 0x821C0B48;
	}
	return 0x821C0B48;
} // Block from 821C0AE8h-821C0B48h (24 instructions)

//////////////////////////////////////////////////////
// Block at 821C0B48h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C0B48( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C0B48) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C0B48);
		  /* 821C0B48h */ case    0:  		/* lwz R11, <#[R11 + 20]> */
		/* 821C0B48h case    0:*/		cpu::mem::load32z( regs, &regs.R11, (uint32)(regs.R11 + 0x00000014) );
		/* 821C0B48h case    0:*/		return 0x821C0B4C;
		  /* 821C0B4Ch */ case    1:  		/* rlwinm R10, R30, 1, 0, 30 */
		/* 821C0B4Ch case    1:*/		cpu::op::rlwinm<0,1,0,30>(regs,&regs.R10,regs.R30);
		/* 821C0B4Ch case    1:*/		return 0x821C0B50;
		  /* 821C0B50h */ case    2:  		/* rlwinm R11, R11, 30, 24, 31 */
		/* 821C0B50h case    2:*/		cpu::op::rlwinm<0,30,24,31>(regs,&regs.R11,regs.R11);
		/* 821C0B50h case    2:*/		return 0x821C0B54;
		  /* 821C0B54h */ case    3:  		/* srw R11, R11, R10 */
		/* 821C0B54h case    3:*/		cpu::op::srw<0>(regs,&regs.R11,regs.R11,regs.R10);
		/* 821C0B54h case    3:*/		return 0x821C0B58;
		  /* 821C0B58h */ case    4:  		/* rlwinm R11, R11, 0, 30, 31 */
		/* 821C0B58h case    4:*/		cpu::op::rlwinm<0,0,30,31>(regs,&regs.R11,regs.R11);
		/* 821C0B58h case    4:*/		return 0x821C0B5C;
	}
	return 0x821C0B5C;
} // Block from 821C0B48h-821C0B5Ch (5 instructions)

//////////////////////////////////////////////////////
// Block at 821C0B5Ch
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C0B5C( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C0B5C) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C0B5C);
		  /* 821C0B5Ch */ case    0:  		/* cmplwi CR6, R11, 1 */
		/* 821C0B5Ch case    0:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000001);
		/* 821C0B5Ch case    0:*/		return 0x821C0B60;
		  /* 821C0B60h */ case    1:  		/* bc 12, CR6_LT, 48 */
		/* 821C0B60h case    1:*/		if ( regs.CR[6].lt ) { return 0x821C0B90;  }
		/* 821C0B60h case    1:*/		return 0x821C0B64;
		  /* 821C0B64h */ case    2:  		/* bc 12, CR6_EQ, 28 */
		/* 821C0B64h case    2:*/		if ( regs.CR[6].eq ) { return 0x821C0B80;  }
		/* 821C0B64h case    2:*/		return 0x821C0B68;
		  /* 821C0B68h */ case    3:  		/* cmplwi CR6, R11, 3 */
		/* 821C0B68h case    3:*/		cpu::op::cmplwi<6>(regs,regs.R11,0x00000003);
		/* 821C0B68h case    3:*/		return 0x821C0B6C;
		  /* 821C0B6Ch */ case    4:  		/* bc 4, CR6_LT, 116 */
		/* 821C0B6Ch case    4:*/		if ( !regs.CR[6].lt ) { return 0x821C0BE0;  }
		/* 821C0B6Ch case    4:*/		return 0x821C0B70;
		  /* 821C0B70h */ case    5:  		/* fctidz FR0, FR1 */
		/* 821C0B70h case    5:*/		cpu::op::fctidz<0>(regs,&regs.FR0,regs.FR1);
		/* 821C0B70h case    5:*/		return 0x821C0B74;
		  /* 821C0B74h */ case    6:  		/* li R11, 2 */
		/* 821C0B74h case    6:*/		cpu::op::li<0>(regs,&regs.R11,0x2);
		/* 821C0B74h case    6:*/		return 0x821C0B78;
		  /* 821C0B78h */ case    7:  		/* stfiwx FR0, <#[R31 + R21]> */
		/* 821C0B78h case    7:*/		cpu::mem::store32( regs, regs.FR0, (uint32)(regs.R31 + regs.R21 + 0x00000000) );
		/* 821C0B78h case    7:*/		return 0x821C0B7C;
		  /* 821C0B7Ch */ case    8:  		/* b 32 */
		/* 821C0B7Ch case    8:*/		return 0x821C0B9C;
		/* 821C0B7Ch case    8:*/		return 0x821C0B80;
	}
	return 0x821C0B80;
} // Block from 821C0B5Ch-821C0B80h (9 instructions)

//////////////////////////////////////////////////////
// Block at 821C0B80h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C0B80( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C0B80) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C0B80);
		  /* 821C0B80h */ case    0:  		/* fctiwz FR0, FR1 */
		/* 821C0B80h case    0:*/		cpu::op::fctiwz<0>(regs,&regs.FR0,regs.FR1);
		/* 821C0B80h case    0:*/		return 0x821C0B84;
		  /* 821C0B84h */ case    1:  		/* stw R24, <#[R31 + 16]> */
		/* 821C0B84h case    1:*/		cpu::mem::store32( regs, regs.R24, (uint32)(regs.R31 + 0x00000010) );
		/* 821C0B84h case    1:*/		return 0x821C0B88;
		  /* 821C0B88h */ case    2:  		/* stfiwx FR0, <#[R31 + R21]> */
		/* 821C0B88h case    2:*/		cpu::mem::store32( regs, regs.FR0, (uint32)(regs.R31 + regs.R21 + 0x00000000) );
		/* 821C0B88h case    2:*/		return 0x821C0B8C;
		  /* 821C0B8Ch */ case    3:  		/* b 20 */
		/* 821C0B8Ch case    3:*/		return 0x821C0BA0;
		/* 821C0B8Ch case    3:*/		return 0x821C0B90;
	}
	return 0x821C0B90;
} // Block from 821C0B80h-821C0B90h (4 instructions)

//////////////////////////////////////////////////////
// Block at 821C0B90h
//////////////////////////////////////////////////////
uint64 __fastcall _code__block821C0B90( uint64 ip, cpu::CpuRegs& regs )
{
	const uint32 local_instr = (uint32)(ip - 0x821C0B90) / 4;
	switch ( local_instr )
	{
		default:	runtime::InvalidAddress(ip, 0x821C0B90);
		  /* 821C0B90h */ case    0:  		/* frsp FR0, FR1 */
		/* 821C0B90h case    0:*/		cpu::op::frsp<0>(regs,&regs.FR0,regs.FR1);
		/* 821C0B90h case    0:*/		return 0x821C0B94;
		  /* 821C0B94h */ case    1:  		/* stfd FR0, <#[R31 + 24]> */
		/* 821C0B94h case    1:*/		cpu::mem::store64f( regs, regs.FR0, (uint32)(regs.R31 + 0x00000018) );
		/* 821C0B94h case    1:*/		return 0x821C0B98;
		  /* 821C0B98h */ case    2:  		/* li R11, 7 */
		/* 821C0B98h case    2:*/		cpu::op::li<0>(regs,&regs.R11,0x7);
		/* 821C0B98h case    2:*/		return 0x821C0B9C;
	}
	return 0x821C0B9C;
} // Block from 821C0B90h-821C0B9Ch (3 instructions)

